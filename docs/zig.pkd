---
name: Zig
slug: zig
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2015–2024, Zig contributors
  Licensed under the MIT License.
  https://ziglang.org/documentation/0.13.0/
homepage: https://ziglang.org/

---
- name: Appendix
  id: index#Appendix
  summary: null
  description: '## Appendix'
- name: 'Appendix: Containers'
  id: index#Containers
  summary: A container in Zig is any syntactical construct that acts as a namespace to hold variable and function declarations
  description: |-
    ### Containers

    A *container* in Zig is any syntactical construct that acts as a namespace to hold [variable](#Container-Level-Variables) and [function](#Functions) declarations. Containers are also type definitions which can be instantiated. [Structs](#struct), [enums](#enum), [unions](#union), [opaques](#opaque), and even Zig source files themselves are containers.

    Although containers (except Zig source files) use curly braces to surround their definition, they should not be confused with [blocks](#Blocks) or functions. Containers do not contain statements.
- name: 'Appendix: Grammar'
  id: index#Grammar
  summary: null
  description: |-
    ### Grammar

    ``` zig
    Root <- skip container_doc_comment? ContainerMembers eof

    # *** Top level ***
    ContainerMembers <- ContainerDeclaration* (ContainerField COMMA)* (ContainerField / ContainerDeclaration*)

    ContainerDeclaration <- TestDecl / ComptimeDecl / doc_comment? KEYWORD_pub? Decl

    TestDecl <- KEYWORD_test (STRINGLITERALSINGLE / IDENTIFIER)? Block

    ComptimeDecl <- KEYWORD_comptime Block

    Decl
        <- (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE? / KEYWORD_inline / KEYWORD_noinline)? FnProto (SEMICOLON / Block)
         / (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE?)? KEYWORD_threadlocal? GlobalVarDecl
         / KEYWORD_usingnamespace Expr SEMICOLON

    FnProto <- KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? AddrSpace? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr

    VarDeclProto <- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? AddrSpace? LinkSection?

    GlobalVarDecl <- VarDeclProto (EQUAL Expr)? SEMICOLON

    ContainerField <- doc_comment? KEYWORD_comptime? !KEYWORD_fn (IDENTIFIER COLON)? TypeExpr ByteAlign? (EQUAL Expr)?

    # *** Block Level ***
    Statement
        <- KEYWORD_comptime ComptimeStatement
         / KEYWORD_nosuspend BlockExprStatement
         / KEYWORD_suspend BlockExprStatement
         / KEYWORD_defer BlockExprStatement
         / KEYWORD_errdefer Payload? BlockExprStatement
         / IfStatement
         / LabeledStatement
         / SwitchExpr
         / VarDeclExprStatement

    ComptimeStatement
        <- BlockExpr
         / VarDeclExprStatement

    IfStatement
        <- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?
         / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )

    LabeledStatement <- BlockLabel? (Block / LoopStatement)

    LoopStatement <- KEYWORD_inline? (ForStatement / WhileStatement)

    ForStatement
        <- ForPrefix BlockExpr ( KEYWORD_else Statement )?
         / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )

    WhileStatement
        <- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?
         / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )

    BlockExprStatement
        <- BlockExpr
         / AssignExpr SEMICOLON

    BlockExpr <- BlockLabel? Block

    # An expression, assignment, or any destructure, as a statement.
    VarDeclExprStatement
        <- VarDeclProto (COMMA (VarDeclProto / Expr))* EQUAL Expr SEMICOLON
         / Expr (AssignOp Expr / (COMMA (VarDeclProto / Expr))+ EQUAL Expr)? SEMICOLON

    # *** Expression Level ***

    # An assignment or a destructure whose LHS are all lvalue expressions.
    AssignExpr <- Expr (AssignOp Expr / (COMMA Expr)+ EQUAL Expr)?

    SingleAssignExpr <- Expr (AssignOp Expr)?

    Expr <- BoolOrExpr

    BoolOrExpr <- BoolAndExpr (KEYWORD_or BoolAndExpr)*

    BoolAndExpr <- CompareExpr (KEYWORD_and CompareExpr)*

    CompareExpr <- BitwiseExpr (CompareOp BitwiseExpr)?

    BitwiseExpr <- BitShiftExpr (BitwiseOp BitShiftExpr)*

    BitShiftExpr <- AdditionExpr (BitShiftOp AdditionExpr)*

    AdditionExpr <- MultiplyExpr (AdditionOp MultiplyExpr)*

    MultiplyExpr <- PrefixExpr (MultiplyOp PrefixExpr)*

    PrefixExpr <- PrefixOp* PrimaryExpr

    PrimaryExpr
        <- AsmExpr
         / IfExpr
         / KEYWORD_break BreakLabel? Expr?
         / KEYWORD_comptime Expr
         / KEYWORD_nosuspend Expr
         / KEYWORD_continue BreakLabel?
         / KEYWORD_resume Expr
         / KEYWORD_return Expr?
         / BlockLabel? LoopExpr
         / Block
         / CurlySuffixExpr

    IfExpr <- IfPrefix Expr (KEYWORD_else Payload? Expr)?

    Block <- LBRACE Statement* RBRACE

    LoopExpr <- KEYWORD_inline? (ForExpr / WhileExpr)

    ForExpr <- ForPrefix Expr (KEYWORD_else Expr)?

    WhileExpr <- WhilePrefix Expr (KEYWORD_else Payload? Expr)?

    CurlySuffixExpr <- TypeExpr InitList?

    InitList
        <- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE
         / LBRACE Expr (COMMA Expr)* COMMA? RBRACE
         / LBRACE RBRACE

    TypeExpr <- PrefixTypeOp* ErrorUnionExpr

    ErrorUnionExpr <- SuffixExpr (EXCLAMATIONMARK TypeExpr)?

    SuffixExpr
        <- KEYWORD_async PrimaryTypeExpr SuffixOp* FnCallArguments
         / PrimaryTypeExpr (SuffixOp / FnCallArguments)*

    PrimaryTypeExpr
        <- BUILTINIDENTIFIER FnCallArguments
         / CHAR_LITERAL
         / ContainerDecl
         / DOT IDENTIFIER
         / DOT InitList
         / ErrorSetDecl
         / FLOAT
         / FnProto
         / GroupedExpr
         / LabeledTypeExpr
         / IDENTIFIER
         / IfTypeExpr
         / INTEGER
         / KEYWORD_comptime TypeExpr
         / KEYWORD_error DOT IDENTIFIER
         / KEYWORD_anyframe
         / KEYWORD_unreachable
         / STRINGLITERAL
         / SwitchExpr

    ContainerDecl <- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto

    ErrorSetDecl <- KEYWORD_error LBRACE IdentifierList RBRACE

    GroupedExpr <- LPAREN Expr RPAREN

    IfTypeExpr <- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?

    LabeledTypeExpr
        <- BlockLabel Block
         / BlockLabel? LoopTypeExpr

    LoopTypeExpr <- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)

    ForTypeExpr <- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?

    WhileTypeExpr <- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?

    SwitchExpr <- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE

    # *** Assembly ***
    AsmExpr <- KEYWORD_asm KEYWORD_volatile? LPAREN Expr AsmOutput? RPAREN

    AsmOutput <- COLON AsmOutputList AsmInput?

    AsmOutputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN

    AsmInput <- COLON AsmInputList AsmClobbers?

    AsmInputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN

    AsmClobbers <- COLON StringList

    # *** Helper grammar ***
    BreakLabel <- COLON IDENTIFIER

    BlockLabel <- IDENTIFIER COLON

    FieldInit <- DOT IDENTIFIER EQUAL Expr

    WhileContinueExpr <- COLON LPAREN AssignExpr RPAREN

    LinkSection <- KEYWORD_linksection LPAREN Expr RPAREN

    AddrSpace <- KEYWORD_addrspace LPAREN Expr RPAREN

    # Fn specific
    CallConv <- KEYWORD_callconv LPAREN Expr RPAREN

    ParamDecl
        <- doc_comment? (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType
         / DOT3

    ParamType
        <- KEYWORD_anytype
         / TypeExpr

    # Control flow prefixes
    IfPrefix <- KEYWORD_if LPAREN Expr RPAREN PtrPayload?

    WhilePrefix <- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?

    ForPrefix <- KEYWORD_for LPAREN ForArgumentsList RPAREN PtrListPayload

    # Payloads
    Payload <- PIPE IDENTIFIER PIPE

    PtrPayload <- PIPE ASTERISK? IDENTIFIER PIPE

    PtrIndexPayload <- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE

    PtrListPayload <- PIPE ASTERISK? IDENTIFIER (COMMA ASTERISK? IDENTIFIER)* COMMA? PIPE

    # Switch specific
    SwitchProng <- KEYWORD_inline? SwitchCase EQUALRARROW PtrIndexPayload? SingleAssignExpr

    SwitchCase
        <- SwitchItem (COMMA SwitchItem)* COMMA?
         / KEYWORD_else

    SwitchItem <- Expr (DOT3 Expr)?

    # For specific
    ForArgumentsList <- ForItem (COMMA ForItem)* COMMA?

    ForItem <- Expr (DOT2 Expr?)?

    # Operators
    AssignOp
        <- ASTERISKEQUAL
         / ASTERISKPIPEEQUAL
         / SLASHEQUAL
         / PERCENTEQUAL
         / PLUSEQUAL
         / PLUSPIPEEQUAL
         / MINUSEQUAL
         / MINUSPIPEEQUAL
         / LARROW2EQUAL
         / LARROW2PIPEEQUAL
         / RARROW2EQUAL
         / AMPERSANDEQUAL
         / CARETEQUAL
         / PIPEEQUAL
         / ASTERISKPERCENTEQUAL
         / PLUSPERCENTEQUAL
         / MINUSPERCENTEQUAL
         / EQUAL

    CompareOp
        <- EQUALEQUAL
         / EXCLAMATIONMARKEQUAL
         / LARROW
         / RARROW
         / LARROWEQUAL
         / RARROWEQUAL

    BitwiseOp
        <- AMPERSAND
         / CARET
         / PIPE
         / KEYWORD_orelse
         / KEYWORD_catch Payload?

    BitShiftOp
        <- LARROW2
         / RARROW2
         / LARROW2PIPE

    AdditionOp
        <- PLUS
         / MINUS
         / PLUS2
         / PLUSPERCENT
         / MINUSPERCENT
         / PLUSPIPE
         / MINUSPIPE

    MultiplyOp
        <- PIPE2
         / ASTERISK
         / SLASH
         / PERCENT
         / ASTERISK2
         / ASTERISKPERCENT
         / ASTERISKPIPE

    PrefixOp
        <- EXCLAMATIONMARK
         / MINUS
         / TILDE
         / MINUSPERCENT
         / AMPERSAND
         / KEYWORD_try
         / KEYWORD_await

    PrefixTypeOp
        <- QUESTIONMARK
         / KEYWORD_anyframe MINUSRARROW
         / SliceTypeStart (ByteAlign / AddrSpace / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*
         / PtrTypeStart (AddrSpace / KEYWORD_align LPAREN Expr (COLON Expr COLON Expr)? RPAREN / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*
         / ArrayTypeStart

    SuffixOp
        <- LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET
         / DOT IDENTIFIER
         / DOTASTERISK
         / DOTQUESTIONMARK

    FnCallArguments <- LPAREN ExprList RPAREN

    # Ptr specific
    SliceTypeStart <- LBRACKET (COLON Expr)? RBRACKET

    PtrTypeStart
        <- ASTERISK
         / ASTERISK2
         / LBRACKET ASTERISK (LETTERC / COLON Expr)? RBRACKET

    ArrayTypeStart <- LBRACKET Expr (COLON Expr)? RBRACKET

    # ContainerDecl specific
    ContainerDeclAuto <- ContainerDeclType LBRACE container_doc_comment? ContainerMembers RBRACE

    ContainerDeclType
        <- KEYWORD_struct (LPAREN Expr RPAREN)?
         / KEYWORD_opaque
         / KEYWORD_enum (LPAREN Expr RPAREN)?
         / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?

    # Alignment
    ByteAlign <- KEYWORD_align LPAREN Expr RPAREN

    # Lists
    IdentifierList <- (doc_comment? IDENTIFIER COMMA)* (doc_comment? IDENTIFIER)?

    SwitchProngList <- (SwitchProng COMMA)* SwitchProng?

    AsmOutputList <- (AsmOutputItem COMMA)* AsmOutputItem?

    AsmInputList <- (AsmInputItem COMMA)* AsmInputItem?

    StringList <- (STRINGLITERAL COMMA)* STRINGLITERAL?

    ParamDeclList <- (ParamDecl COMMA)* ParamDecl?

    ExprList <- (Expr COMMA)* Expr?

    # *** Tokens ***
    eof <- !.
    bin <- [01]
    bin_ <- '_'? bin
    oct <- [0-7]
    oct_ <- '_'? oct
    hex <- [0-9a-fA-F]
    hex_ <- '_'? hex
    dec <- [0-9]
    dec_ <- '_'? dec

    bin_int <- bin bin_*
    oct_int <- oct oct_*
    dec_int <- dec dec_*
    hex_int <- hex hex_*

    ox80_oxBF <- [\200-\277]
    oxF4 <- '\364'
    ox80_ox8F <- [\200-\217]
    oxF1_oxF3 <- [\361-\363]
    oxF0 <- '\360'
    ox90_0xBF <- [\220-\277]
    oxEE_oxEF <- [\356-\357]
    oxED <- '\355'
    ox80_ox9F <- [\200-\237]
    oxE1_oxEC <- [\341-\354]
    oxE0 <- '\340'
    oxA0_oxBF <- [\240-\277]
    oxC2_oxDF <- [\302-\337]

    # From https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/
    # First Byte      Second Byte     Third Byte      Fourth Byte
    # [0x00,0x7F]
    # [0xC2,0xDF]     [0x80,0xBF]
    #    0xE0         [0xA0,0xBF]     [0x80,0xBF]
    # [0xE1,0xEC]     [0x80,0xBF]     [0x80,0xBF]
    #    0xED         [0x80,0x9F]     [0x80,0xBF]
    # [0xEE,0xEF]     [0x80,0xBF]     [0x80,0xBF]
    #    0xF0         [0x90,0xBF]     [0x80,0xBF]     [0x80,0xBF]
    # [0xF1,0xF3]     [0x80,0xBF]     [0x80,0xBF]     [0x80,0xBF]
    #    0xF4         [0x80,0x8F]     [0x80,0xBF]     [0x80,0xBF]

    mb_utf8_literal <-
           oxF4      ox80_ox8F ox80_oxBF ox80_oxBF
         / oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF
         / oxF0      ox90_0xBF ox80_oxBF ox80_oxBF
         / oxEE_oxEF ox80_oxBF ox80_oxBF
         / oxED      ox80_ox9F ox80_oxBF
         / oxE1_oxEC ox80_oxBF ox80_oxBF
         / oxE0      oxA0_oxBF ox80_oxBF
         / oxC2_oxDF ox80_oxBF

    ascii_char_not_nl_slash_squote <- [\000-\011\013-\046\050-\133\135-\177]

    char_escape
        <- "\\x" hex hex
         / "\\u{" hex+ "}"
         / "\\" [nr\\t'"]
    char_char
        <- mb_utf8_literal
         / char_escape
         / ascii_char_not_nl_slash_squote

    string_char
        <- char_escape
         / [^\\"\n]

    container_doc_comment <- ('//!' [^\n]* [ \n]* skip)+
    doc_comment <- ('///' [^\n]* [ \n]* skip)+
    line_comment <- '//' ![!/][^\n]* / '////' [^\n]*
    line_string <- ("\\\\" [^\n]* [ \n]*)+
    skip <- ([ \n] / line_comment)*

    CHAR_LITERAL <- "'" char_char "'" skip
    FLOAT
        <- "0x" hex_int "." hex_int ([pP] [-+]? dec_int)? skip
         /      dec_int "." dec_int ([eE] [-+]? dec_int)? skip
         / "0x" hex_int [pP] [-+]? dec_int skip
         /      dec_int [eE] [-+]? dec_int skip
    INTEGER
        <- "0b" bin_int skip
         / "0o" oct_int skip
         / "0x" hex_int skip
         /      dec_int   skip
    STRINGLITERALSINGLE <- "\"" string_char* "\"" skip
    STRINGLITERAL
        <- STRINGLITERALSINGLE
         / (line_string                 skip)+
    IDENTIFIER
        <- !keyword [A-Za-z_] [A-Za-z0-9_]* skip
         / "@" STRINGLITERALSINGLE
    BUILTINIDENTIFIER <- "@"[A-Za-z_][A-Za-z0-9_]* skip


    AMPERSAND            <- '&'      ![=]      skip
    AMPERSANDEQUAL       <- '&='               skip
    ASTERISK             <- '*'      ![*%=|]   skip
    ASTERISK2            <- '**'               skip
    ASTERISKEQUAL        <- '*='               skip
    ASTERISKPERCENT      <- '*%'     ![=]      skip
    ASTERISKPERCENTEQUAL <- '*%='              skip
    ASTERISKPIPE         <- '*|'     ![=]      skip
    ASTERISKPIPEEQUAL    <- '*|='              skip
    CARET                <- '^'      ![=]      skip
    CARETEQUAL           <- '^='               skip
    COLON                <- ':'                skip
    COMMA                <- ','                skip
    DOT                  <- '.'      ![*.?]    skip
    DOT2                 <- '..'     ![.]      skip
    DOT3                 <- '...'              skip
    DOTASTERISK          <- '.*'               skip
    DOTQUESTIONMARK      <- '.?'               skip
    EQUAL                <- '='      ![>=]     skip
    EQUALEQUAL           <- '=='               skip
    EQUALRARROW          <- '=>'               skip
    EXCLAMATIONMARK      <- '!'      ![=]      skip
    EXCLAMATIONMARKEQUAL <- '!='               skip
    LARROW               <- '<'      ![<=]     skip
    LARROW2              <- '<<'     ![=|]     skip
    LARROW2EQUAL         <- '<<='              skip
    LARROW2PIPE          <- '<<|'    ![=]      skip
    LARROW2PIPEEQUAL     <- '<<|='             skip
    LARROWEQUAL          <- '<='               skip
    LBRACE               <- '{'                skip
    LBRACKET             <- '['                skip
    LPAREN               <- '('                skip
    MINUS                <- '-'      ![%=>|]   skip
    MINUSEQUAL           <- '-='               skip
    MINUSPERCENT         <- '-%'     ![=]      skip
    MINUSPERCENTEQUAL    <- '-%='              skip
    MINUSPIPE            <- '-|'     ![=]      skip
    MINUSPIPEEQUAL       <- '-|='              skip
    MINUSRARROW          <- '->'               skip
    PERCENT              <- '%'      ![=]      skip
    PERCENTEQUAL         <- '%='               skip
    PIPE                 <- '|'      ![|=]     skip
    PIPE2                <- '||'               skip
    PIPEEQUAL            <- '|='               skip
    PLUS                 <- '+'      ![%+=|]   skip
    PLUS2                <- '++'               skip
    PLUSEQUAL            <- '+='               skip
    PLUSPERCENT          <- '+%'     ![=]      skip
    PLUSPERCENTEQUAL     <- '+%='              skip
    PLUSPIPE             <- '+|'     ![=]      skip
    PLUSPIPEEQUAL        <- '+|='              skip
    LETTERC              <- 'c'                skip
    QUESTIONMARK         <- '?'                skip
    RARROW               <- '>'      ![>=]     skip
    RARROW2              <- '>>'     ![=]      skip
    RARROW2EQUAL         <- '>>='              skip
    RARROWEQUAL          <- '>='               skip
    RBRACE               <- '}'                skip
    RBRACKET             <- ']'                skip
    RPAREN               <- ')'                skip
    SEMICOLON            <- ';'                skip
    SLASH                <- '/'      ![=]      skip
    SLASHEQUAL           <- '/='               skip
    TILDE                <- '~'                skip

    end_of_word <- ![a-zA-Z0-9_] skip
    KEYWORD_addrspace   <- 'addrspace'   end_of_word
    KEYWORD_align       <- 'align'       end_of_word
    KEYWORD_allowzero   <- 'allowzero'   end_of_word
    KEYWORD_and         <- 'and'         end_of_word
    KEYWORD_anyframe    <- 'anyframe'    end_of_word
    KEYWORD_anytype     <- 'anytype'     end_of_word
    KEYWORD_asm         <- 'asm'         end_of_word
    KEYWORD_async       <- 'async'       end_of_word
    KEYWORD_await       <- 'await'       end_of_word
    KEYWORD_break       <- 'break'       end_of_word
    KEYWORD_callconv    <- 'callconv'    end_of_word
    KEYWORD_catch       <- 'catch'       end_of_word
    KEYWORD_comptime    <- 'comptime'    end_of_word
    KEYWORD_const       <- 'const'       end_of_word
    KEYWORD_continue    <- 'continue'    end_of_word
    KEYWORD_defer       <- 'defer'       end_of_word
    KEYWORD_else        <- 'else'        end_of_word
    KEYWORD_enum        <- 'enum'        end_of_word
    KEYWORD_errdefer    <- 'errdefer'    end_of_word
    KEYWORD_error       <- 'error'       end_of_word
    KEYWORD_export      <- 'export'      end_of_word
    KEYWORD_extern      <- 'extern'      end_of_word
    KEYWORD_fn          <- 'fn'          end_of_word
    KEYWORD_for         <- 'for'         end_of_word
    KEYWORD_if          <- 'if'          end_of_word
    KEYWORD_inline      <- 'inline'      end_of_word
    KEYWORD_noalias     <- 'noalias'     end_of_word
    KEYWORD_nosuspend   <- 'nosuspend'   end_of_word
    KEYWORD_noinline    <- 'noinline'    end_of_word
    KEYWORD_opaque      <- 'opaque'      end_of_word
    KEYWORD_or          <- 'or'          end_of_word
    KEYWORD_orelse      <- 'orelse'      end_of_word
    KEYWORD_packed      <- 'packed'      end_of_word
    KEYWORD_pub         <- 'pub'         end_of_word
    KEYWORD_resume      <- 'resume'      end_of_word
    KEYWORD_return      <- 'return'      end_of_word
    KEYWORD_linksection <- 'linksection' end_of_word
    KEYWORD_struct      <- 'struct'      end_of_word
    KEYWORD_suspend     <- 'suspend'     end_of_word
    KEYWORD_switch      <- 'switch'      end_of_word
    KEYWORD_test        <- 'test'        end_of_word
    KEYWORD_threadlocal <- 'threadlocal' end_of_word
    KEYWORD_try         <- 'try'         end_of_word
    KEYWORD_union       <- 'union'       end_of_word
    KEYWORD_unreachable <- 'unreachable' end_of_word
    KEYWORD_usingnamespace <- 'usingnamespace' end_of_word
    KEYWORD_var         <- 'var'         end_of_word
    KEYWORD_volatile    <- 'volatile'    end_of_word
    KEYWORD_while       <- 'while'       end_of_word

    keyword <- KEYWORD_addrspace / KEYWORD_align / KEYWORD_allowzero / KEYWORD_and
             / KEYWORD_anyframe / KEYWORD_anytype / KEYWORD_asm / KEYWORD_async
             / KEYWORD_await / KEYWORD_break / KEYWORD_callconv / KEYWORD_catch
             / KEYWORD_comptime / KEYWORD_const / KEYWORD_continue / KEYWORD_defer
             / KEYWORD_else / KEYWORD_enum / KEYWORD_errdefer / KEYWORD_error / KEYWORD_export
             / KEYWORD_extern / KEYWORD_fn / KEYWORD_for / KEYWORD_if
             / KEYWORD_inline / KEYWORD_noalias / KEYWORD_nosuspend / KEYWORD_noinline
             / KEYWORD_opaque / KEYWORD_or / KEYWORD_orelse / KEYWORD_packed
             / KEYWORD_pub / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection
             / KEYWORD_struct / KEYWORD_suspend / KEYWORD_switch / KEYWORD_test
             / KEYWORD_threadlocal / KEYWORD_try / KEYWORD_union / KEYWORD_unreachable
             / KEYWORD_usingnamespace / KEYWORD_var / KEYWORD_volatile / KEYWORD_while
    ```

    grammar.y
- name: 'Appendix: Zen'
  id: index#Zen
  summary: © 2015–2024, Zig contributors Licensed under the MIT License
  description: "### Zen\n\n- Communicate intent precisely.\n- Edge cases matter.\n- Favor reading code over writing code.\n- Only one obvious way to do things.\n- Runtime crashes are better than bugs.\n- Compile errors are better than runtime crashes.\n- Incremental improvements.\n- Avoid local maximums.\n- Reduce the amount one must remember.\n- Focus on code rather than style.\n- Resource allocation may fail; resource deallocation must succeed.\n- Memory is a resource.\n- Together we serve the users.\n\n© 2015–2024, Zig contributors  \nLicensed under the MIT License.  \n[https://ziglang.org/documentation/0.13.0/](https://ziglang.org/documentation/0.13.0/)"
- name: Arrays
  id: index#Arrays
  summary: null
  description: "## Arrays\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\nconst assert = @import(\"std\").debug.assert;\nconst mem = @import(\"std\").mem;\n\n// array literal\nconst message = [_]u8{ 'h', 'e', 'l', 'l', 'o' };\n\n// alternative initialization using result location\nconst alt_message: [5]u8 = .{ 'h', 'e', 'l', 'l', 'o' };\n\ncomptime {\n    assert(mem.eql(u8, &message, &alt_message));\n}\n\n// get the size of an array\ncomptime {\n    assert(message.len == 5);\n}\n\n// A string literal is a single-item pointer to an array.\nconst same_message = \"hello\";\n\ncomptime {\n    assert(mem.eql(u8, &message, same_message));\n}\n\ntest \"iterate over an array\" {\n    var sum: usize = 0;\n    for (message) |byte| {\n        sum += byte;\n    }\n    try expect(sum == 'h' + 'e' + 'l' * 2 + 'o');\n}\n\n// modifiable array\nvar some_integers: [100]i32 = undefined;\n\ntest \"modify an array\" {\n    for (&some_integers, 0..) |*item, i| {\n        item.* = @intCast(i);\n    }\n    try expect(some_integers[10] == 10);\n    try expect(some_integers[99] == 99);\n}\n\n// array concatenation works if the values are known\n// at compile time\nconst part_one = [_]i32{ 1, 2, 3, 4 };\nconst part_two = [_]i32{ 5, 6, 7, 8 };\nconst all_of_it = part_one ++ part_two;\ncomptime {\n    assert(mem.eql(i32, &all_of_it, &[_]i32{ 1, 2, 3, 4, 5, 6, 7, 8 }));\n}\n\n// remember that string literals are arrays\nconst hello = \"hello\";\nconst world = \"world\";\nconst hello_world = hello ++ \" \" ++ world;\ncomptime {\n    assert(mem.eql(u8, hello_world, \"hello world\"));\n}\n\n// ** does repeating patterns\nconst pattern = \"ab\" ** 3;\ncomptime {\n    assert(mem.eql(u8, pattern, \"ababab\"));\n}\n\n// initialize an array to zero\nconst all_zero = [_]u16{0} ** 10;\n\ncomptime {\n    assert(all_zero.len == 10);\n    assert(all_zero[5] == 0);\n}\n\n// use compile-time code to initialize an array\nvar fancy_array = init: {\n    var initial_value: [10]Point = undefined;\n    for (&initial_value, 0..) |*pt, i| {\n        pt.* = Point{\n            .x = @intCast(i),\n            .y = @intCast(i * 2),\n        };\n    }\n    break :init initial_value;\n};\nconst Point = struct {\n    x: i32,\n    y: i32,\n};\n\ntest \"compile-time array initialization\" {\n    try expect(fancy_array[4].x == 4);\n    try expect(fancy_array[4].y == 8);\n}\n\n// call a function to initialize an array\nvar more_points = [_]Point{makePoint(3)} ** 10;\nfn makePoint(x: i32) Point {\n    return Point{\n        .x = x,\n        .y = x * 2,\n    };\n}\ntest \"array initialization with function calls\" {\n    try expect(more_points[4].x == 3);\n    try expect(more_points[4].y == 6);\n    try expect(more_points.len == 10);\n}\n```\n\ntest_arrays.zig\n\n            $ zig test test_arrays.zig\n    1/4 test_arrays.test.iterate over an array...OK\n    2/4 test_arrays.test.modify an array...OK\n    3/4 test_arrays.test.compile-time array initialization...OK\n    4/4 test_arrays.test.array initialization with function calls...OK\n    All 4 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [for](#for)\n- [Slices](#Slices)\n\n&nbsp;"
- name: 'Arrays: Multidimensional Arrays'
  id: index#Multidimensional-Arrays
  summary: null
  description: "### Multidimensional Arrays\n\nMultidimensional arrays can be created by nesting arrays:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst mat4x4 = [4][4]f32{\n    [_]f32{ 1.0, 0.0, 0.0, 0.0 },\n    [_]f32{ 0.0, 1.0, 0.0, 1.0 },\n    [_]f32{ 0.0, 0.0, 1.0, 0.0 },\n    [_]f32{ 0.0, 0.0, 0.0, 1.0 },\n};\ntest \"multidimensional arrays\" {\n    // Access the 2D array by indexing the outer array, and then the inner array.\n    try expect(mat4x4[1][1] == 1.0);\n\n    // Here we iterate with for loops.\n    for (mat4x4, 0..) |row, row_index| {\n        for (row, 0..) |cell, column_index| {\n            if (row_index == column_index) {\n                try expect(cell == 1.0);\n            }\n        }\n    }\n}\n```\n\ntest_multidimensional_arrays.zig\n\n            $ zig test test_multidimensional_arrays.zig\n    1/1 test_multidimensional_arrays.test.multidimensional arrays...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Arrays: Sentinel-Terminated Arrays'
  id: index#Sentinel-Terminated-Arrays
  summary: The syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N
  description: "### Sentinel-Terminated Arrays\n\nThe syntax `[N:x]T` describes an array which has a sentinel element of value `x` at the index corresponding to the length `N`.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"0-terminated sentinel array\" {\n    const array = [_:0]u8{ 1, 2, 3, 4 };\n\n    try expect(@TypeOf(array) == [4:0]u8);\n    try expect(array.len == 4);\n    try expect(array[4] == 0);\n}\n\ntest \"extra 0s in 0-terminated sentinel array\" {\n    // The sentinel value may appear earlier, but does not influence the compile-time 'len'.\n    const array = [_:0]u8{ 1, 0, 0, 4 };\n\n    try expect(@TypeOf(array) == [4:0]u8);\n    try expect(array.len == 4);\n    try expect(array[4] == 0);\n}\n```\n\ntest_null_terminated_array.zig\n\n            $ zig test test_null_terminated_array.zig\n    1/2 test_null_terminated_array.test.0-terminated sentinel array...OK\n    2/2 test_null_terminated_array.test.extra 0s in 0-terminated sentinel array...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [Sentinel-Terminated Pointers](#Sentinel-Terminated-Pointers)\n- [Sentinel-Terminated Slices](#Sentinel-Terminated-Slices)\n\n&nbsp;"
- name: Assembly
  id: index#Assembly
  summary: For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation
  description: "## Assembly\n\nFor some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly:\n\n``` zig\npub fn main() noreturn {\n    const msg = \"hello world\\n\";\n    _ = syscall3(SYS_write, STDOUT_FILENO, @intFromPtr(msg), msg.len);\n    _ = syscall1(SYS_exit, 0);\n    unreachable;\n}\n\npub const SYS_write = 1;\npub const SYS_exit = 60;\n\npub const STDOUT_FILENO = 1;\n\npub fn syscall1(number: usize, arg1: usize) usize {\n    return asm volatile (\"syscall\"\n        : [ret] \"={rax}\" (-> usize),\n        : [number] \"{rax}\" (number),\n          [arg1] \"{rdi}\" (arg1),\n        : \"rcx\", \"r11\"\n    );\n}\n\npub fn syscall3(number: usize, arg1: usize, arg2: usize, arg3: usize) usize {\n    return asm volatile (\"syscall\"\n        : [ret] \"={rax}\" (-> usize),\n        : [number] \"{rax}\" (number),\n          [arg1] \"{rdi}\" (arg1),\n          [arg2] \"{rsi}\" (arg2),\n          [arg3] \"{rdx}\" (arg3),\n        : \"rcx\", \"r11\"\n    );\n}\n```\n\ninline_assembly.zig\n\n            $ zig build-exe inline_assembly.zig -target x86_64-linux\n    $ ./inline_assembly\n    hello world\n\n          \n\nShell\n\nDissecting the syntax:\n\n``` zig\npub fn syscall1(number: usize, arg1: usize) usize {\n    // Inline assembly is an expression which returns a value.\n    // the `asm` keyword begins the expression.\n    return asm\n    // `volatile` is an optional modifier that tells Zig this\n    // inline assembly expression has side-effects. Without\n    // `volatile`, Zig is allowed to delete the inline assembly\n    // code if the result is unused.\n    volatile (\n    // Next is a comptime string which is the assembly code.\n    // Inside this string one may use `%[ret]`, `%[number]`,\n    // or `%[arg1]` where a register is expected, to specify\n    // the register that Zig uses for the argument or return value,\n    // if the register constraint strings are used. However in\n    // the below code, this is not used. A literal `%` can be\n    // obtained by escaping it with a double percent: `%%`.\n    // Often multiline string syntax comes in handy here.\n        \\\\syscall\n        // Next is the output. It is possible in the future Zig will\n        // support multiple outputs, depending on how\n        // https://github.com/ziglang/zig/issues/215 is resolved.\n        // It is allowed for there to be no outputs, in which case\n        // this colon would be directly followed by the colon for the inputs.\n        :\n        // This specifies the name to be used in `%[ret]` syntax in\n        // the above assembly string. This example does not use it,\n        // but the syntax is mandatory.\n          [ret]\n          // Next is the output constraint string. This feature is still\n          // considered unstable in Zig, and so LLVM/GCC documentation\n          // must be used to understand the semantics.\n          // http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string\n          // https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html\n          // In this example, the constraint string means \"the result value of\n          // this inline assembly instruction is whatever is in $rax\".\n          \"={rax}\"\n          // Next is either a value binding, or `->` and then a type. The\n          // type is the result type of the inline assembly expression.\n          // If it is a value binding, then `%[ret]` syntax would be used\n          // to refer to the register bound to the value.\n          (-> usize),\n          // Next is the list of inputs.\n          // The constraint for these inputs means, \"when the assembly code is\n          // executed, $rax shall have the value of `number` and $rdi shall have\n          // the value of `arg1`\". Any number of input parameters is allowed,\n          // including none.\n        : [number] \"{rax}\" (number),\n          [arg1] \"{rdi}\" (arg1),\n          // Next is the list of clobbers. These declare a set of registers whose\n          // values will not be preserved by the execution of this assembly code.\n          // These do not include output or input registers. The special clobber\n          // value of \"memory\" means that the assembly writes to arbitrary undeclared\n          // memory locations - not only the memory pointed to by a declared indirect\n          // output. In this example we list $rcx and $r11 because it is known the\n          // kernel syscall does not preserve these registers.\n        : \"rcx\", \"r11\"\n    );\n}\n```\n\nAssembly Syntax Explained.zig\n\nFor x86 and x86_64 targets, the syntax is AT&T syntax, rather than the more popular Intel syntax. This is due to technical constraints; assembly parsing is provided by LLVM and its support for Intel syntax is buggy and not well tested.\n\nSome day Zig may have its own assembler. This would allow it to integrate more seamlessly into the language, as well as be compatible with the popular NASM syntax. This documentation section will be updated before 1.0.0 is released, with a conclusive statement about the status of AT&T vs Intel/NASM syntax."
- name: 'Assembly: Clobbers'
  id: index#Clobbers
  summary: Clobbers are the set of registers whose values will not be preserved by the execution of the assembly code
  description: |-
    ### Clobbers

    Clobbers are the set of registers whose values will not be preserved by the execution of the assembly code. These do not include output or input registers. The special clobber value of `"memory"` means that the assembly causes writes to arbitrary undeclared memory locations - not only the memory pointed to by a declared indirect output.

    Failure to declare the full set of clobbers for a given inline assembly expression is unchecked [Undefined Behavior](#Undefined-Behavior).
- name: 'Assembly: Global Assembly'
  id: index#Global-Assembly
  summary: When an assembly expression occurs in a container level comptime block, this is global assembly
  description: "### Global Assembly\n\nWhen an assembly expression occurs in a [container](#Containers) level [comptime](#comptime) block, this is **global assembly**.\n\nThis kind of assembly has different rules than inline assembly. First, `volatile` is not valid because all global assembly is unconditionally included. Second, there are no inputs, outputs, or clobbers. All global assembly is concatenated verbatim into one long string and assembled together. There are no template substitution rules regarding `%` as there are in inline assembly expressions.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ncomptime {\n    asm (\n        \\\\.global my_func;\n        \\\\.type my_func, @function;\n        \\\\my_func:\n        \\\\  lea (%rdi,%rsi,1),%eax\n        \\\\  retq\n    );\n}\n\nextern fn my_func(a: i32, b: i32) i32;\n\ntest \"global assembly\" {\n    try expect(my_func(12, 34) == 46);\n}\n```\n\ntest_global_assembly.zig\n\n            $ zig test test_global_assembly.zig -target x86_64-linux\n    1/1 test_global_assembly.test.global assembly...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Assembly: Input Constraints'
  id: index#Input-Constraints
  summary: Input constraints are still considered to be unstable in Zig, and so LLVM documentation and GCC documentation must be used to understand the semantics
  description: |-
    ### Input Constraints

    Input constraints are still considered to be unstable in Zig, and so [LLVM documentation](http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string) and [GCC documentation](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) must be used to understand the semantics.

    Note that some breaking changes to input constraints are planned with [issue \#215](https://github.com/ziglang/zig/issues/215).
- name: 'Assembly: Output Constraints'
  id: index#Output-Constraints
  summary: Output constraints are still considered to be unstable in Zig, and so LLVM documentation and GCC documentation must be used to understand the semantics
  description: |-
    ### Output Constraints

    Output constraints are still considered to be unstable in Zig, and so [LLVM documentation](http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string) and [GCC documentation](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) must be used to understand the semantics.

    Note that some breaking changes to output constraints are planned with [issue \#215](https://github.com/ziglang/zig/issues/215).
- name: Async Functions
  id: index#Async-Functions
  summary: Async functions regressed with the release of 0.11.0
  description: |-
    ## Async Functions

    Async functions regressed with the release of 0.11.0. Their future in the Zig language is unclear due to multiple unsolved problems:

    - LLVM's lack of ability to optimize them.
    - Third-party debuggers' lack of ability to debug them.
    - [The cancellation problem](https://github.com/ziglang/zig/issues/5913).
    - Async function pointers preventing the stack size from being known.

    These problems are surmountable, but it will take time. The Zig team is currently focused on other priorities.
- name: Atomics
  id: index#Atomics
  summary: null
  description: |-
    ## Atomics

    TODO: @fence()

    TODO: @atomic rmw

    TODO: builtin atomic memory ordering enum

    See also:

    - [@atomicLoad](#atomicLoad)
    - [@atomicStore](#atomicStore)
    - [@atomicRmw](#atomicRmw)
    - [@fence](#fence)
    - [@cmpxchgWeak](#cmpxchgWeak)
    - [@cmpxchgStrong](#cmpxchgStrong)

    &nbsp;
- name: Blocks
  id: index#Blocks
  summary: Blocks are expressions
  description: "## Blocks\n\nBlocks are used to limit the scope of variable declarations:\n\n``` zig\ntest \"access variable after block scope\" {\n    {\n        var x: i32 = 1;\n        _ = &x;\n    }\n    x += 1;\n}\n```\n\ntest_blocks.zig\n\n            $ zig test test_blocks.zig\n    doc/langref/test_blocks.zig:6:5: error: use of undeclared identifier 'x'\n        x += 1;\n        ^\n\n\n          \n\nShell\n\nBlocks are expressions. When labeled, `break` can be used to return a value from the block:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"labeled break from labeled block expression\" {\n    var y: i32 = 123;\n\n    const x = blk: {\n        y += 1;\n        break :blk y;\n    };\n    try expect(x == 124);\n    try expect(y == 124);\n}\n```\n\ntest_labeled_break.zig\n\n            $ zig test test_labeled_break.zig\n    1/1 test_labeled_break.test.labeled break from labeled block expression...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nHere, `blk` can be any name.\n\nSee also:\n\n- [Labeled while](#Labeled-while)\n- [Labeled for](#Labeled-for)\n\n&nbsp;"
- name: 'Blocks: Empty Blocks'
  id: index#Empty-Blocks
  summary: null
  description: "### Empty Blocks\n\nAn empty block is equivalent to `void``{}`:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest {\n    const a = {};\n    const b = void{};\n    try expect(@TypeOf(a) == void);\n    try expect(@TypeOf(b) == void);\n    try expect(a == b);\n}\n```\n\ntest_empty_block.zig\n\n            $ zig test test_empty_block.zig\n    1/1 test_empty_block.test_0...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Blocks: Shadowing'
  id: index#Shadowing
  summary: Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing within the scope it is defined
  description: "### Shadowing\n\n[Identifiers](#Identifiers) are never allowed to \"hide\" other identifiers by using the same name:\n\n``` zig\nconst pi = 3.14;\n\ntest \"inside test block\" {\n    // Let's even go inside another block\n    {\n        var pi: i32 = 1234;\n    }\n}\n```\n\ntest_shadowing.zig\n\n            $ zig test test_shadowing.zig\n    doc/langref/test_shadowing.zig:6:13: error: local variable shadows declaration of 'pi'\n            var pi: i32 = 1234;\n                ^~\n    doc/langref/test_shadowing.zig:1:1: note: declared here\n    const pi = 3.14;\n    ^~~~~~~~~~~~~~~\n\n\n          \n\nShell\n\nBecause of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing within the scope it is defined. Note that you can, however, use the same name if the scopes are separate:\n\n``` zig\ntest \"separate scopes\" {\n    {\n        const pi = 3.14;\n        _ = pi;\n    }\n    {\n        var pi: bool = true;\n        _ = &pi;\n    }\n}\n```\n\ntest_scopes.zig\n\n            $ zig test test_scopes.zig\n    1/1 test_scopes.test.separate scopes...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: Build Mode
  id: index#Build-Mode
  summary: null
  description: |-
    ## Build Mode

    Zig has four build modes:

    - [Debug](#Debug) (default)
    - [ReleaseFast](#ReleaseFast)
    - [ReleaseSafe](#ReleaseSafe)
    - [ReleaseSmall](#ReleaseSmall)

    To add standard build options to a `build.zig` file:

    ``` zig
    const std = @import("std");

    pub fn build(b: *std.Build) void {
        const optimize = b.standardOptimizeOption(.{});
        const exe = b.addExecutable(.{
            .name = "example",
            .root_source_file = b.path("example.zig"),
            .optimize = optimize,
        });
        b.default_step.dependOn(&exe.step);
    }
    ```

    build.zig

    This causes these options to be available:

    -Doptimize=Debug

    Optimizations off and safety on (default)

    -Doptimize=ReleaseSafe

    Optimizations on and safety on

    -Doptimize=ReleaseFast

    Optimizations on and safety off

    -Doptimize=ReleaseSmall

    Size optimizations on and safety off
- name: 'Build Mode: Debug'
  id: index#Debug
  summary: null
  description: "### Debug\n\n            $ zig build-exe example.zig\n\n          \n\nShell\n\n- Fast compilation speed\n- Safety checks enabled\n- Slow runtime performance\n- Large binary size\n- No reproducible build requirement\n\n&nbsp;"
- name: 'Build Mode: ReleaseFast'
  id: index#ReleaseFast
  summary: null
  description: "### ReleaseFast\n\n            $ zig build-exe example.zig -O ReleaseFast\n\n          \n\nShell\n\n- Fast runtime performance\n- Safety checks disabled\n- Slow compilation speed\n- Large binary size\n- Reproducible build\n\n&nbsp;"
- name: 'Build Mode: ReleaseSafe'
  id: index#ReleaseSafe
  summary: null
  description: "### ReleaseSafe\n\n            $ zig build-exe example.zig -O ReleaseSafe\n\n          \n\nShell\n\n- Medium runtime performance\n- Safety checks enabled\n- Slow compilation speed\n- Large binary size\n- Reproducible build\n\n&nbsp;"
- name: 'Build Mode: ReleaseSmall'
  id: index#ReleaseSmall
  summary: null
  description: "### ReleaseSmall\n\n            $ zig build-exe example.zig -O ReleaseSmall\n\n          \n\nShell\n\n- Medium runtime performance\n- Safety checks disabled\n- Slow compilation speed\n- Small binary size\n- Reproducible build\n\nSee also:\n\n- [Compile Variables](#Compile-Variables)\n- [Zig Build System](#Zig-Build-System)\n- [Undefined Behavior](#Undefined-Behavior)\n\n&nbsp;"
- name: Builtin Functions
  id: index#Builtin-Functions
  summary: Builtin functions are provided by the compiler and are prefixed with @. The comptime keyword on a parameter means that the parameter must be known at compile time
  description: |-
    ## Builtin Functions

    Builtin functions are provided by the compiler and are prefixed with `@`. The `comptime` keyword on a parameter means that the parameter must be known at compile time.
- name: 'Builtin Functions: @abs'
  id: index#abs
  summary: Returns the absolute value of an integer or a floating point number
  description: |-
    ### @abs

    ``` zig
    @abs(value: anytype) anytype
    ```

    Returns the absolute value of an integer or a floating point number. Uses a dedicated hardware instruction when available. The return type is always an unsigned integer of the same bit width as the operand if the operand is an integer. Unsigned integer operands are supported. The builtin cannot overflow for signed integer operands.

    Supports [Floats](#Floats), [Integers](#Integers) and [Vectors](#Vectors) of floats or integers.
- name: 'Builtin Functions: @addrSpaceCast'
  id: index#addrSpaceCast
  summary: Converts a pointer from one address space to another
  description: |-
    ### @addrSpaceCast

    ``` zig
    @addrSpaceCast(ptr: anytype) anytype
    ```

    Converts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the pointer operand. It is always valid to cast a pointer between the same address spaces.
- name: 'Builtin Functions: @addWithOverflow'
  id: index#addWithOverflow
  summary: Performs a + b and returns a tuple with the result and a possible overflow bit
  description: |-
    ### @addWithOverflow

    ``` zig
    @addWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }
    ```

    Performs `a + b` and returns a tuple with the result and a possible overflow bit.
- name: 'Builtin Functions: @alignCast'
  id: index#alignCast
  summary: ptr can be *T, ?*T, or []T
  description: |-
    ### @alignCast

    ``` zig
    @alignCast(ptr: anytype) anytype
    ```

    `ptr` can be `*T`, `?*T`, or `[]T`. Changes the alignment of a pointer. The alignment to use is inferred based on the result type.

    A [pointer alignment safety check](#Incorrect-Pointer-Alignment) is added to the generated code to make sure the pointer is aligned as promised.
- name: 'Builtin Functions: @alignOf'
  id: index#alignOf
  summary: This function returns the number of bytes that this type should be aligned to for the current target to match the C ABI
  description: |-
    ### @alignOf

    ``` zig
    @alignOf(comptime T: type) comptime_int
    ```

    This function returns the number of bytes that this type should be aligned to for the current target to match the C ABI. When the child type of a pointer has this alignment, the alignment can be omitted from the type.

    ``` zig
    const assert = @import("std").debug.assert;
    comptime {
        assert(*u32 == *align(@alignOf(u32)) u32);
    }
    ```

    The result is a target-specific compile time constant. It is guaranteed to be less than or equal to [@sizeOf(T)](#sizeOf).

    See also:

    - [Alignment](#Alignment)

    &nbsp;
- name: 'Builtin Functions: @as'
  id: index#as
  summary: Performs Type Coercion
  description: |-
    ### @as

    ``` zig
    @as(comptime T: type, expression) T
    ```

    Performs [Type Coercion](#Type-Coercion). This cast is allowed when the conversion is unambiguous and safe, and is the preferred way to convert between types, whenever possible.
- name: 'Builtin Functions: @atomicLoad'
  id: index#atomicLoad
  summary: This builtin function atomically dereferences a pointer to a T and returns the value
  description: |-
    ### @atomicLoad

    ``` zig
    @atomicLoad(comptime T: type, ptr: *const T, comptime ordering: AtomicOrder) T
    ```

    This builtin function atomically dereferences a pointer to a `T` and returns the value.

    `T` must be a pointer, a `bool`, a float, an integer or an enum.

    `AtomicOrder` can be found with `@import``(``"std"``).builtin.AtomicOrder`.

    See also:

    - [@atomicStore](#atomicStore)
    - [@atomicRmw](#atomicRmw)
    - [@fence](#fence)
    - [@cmpxchgWeak](#cmpxchgWeak)
    - [@cmpxchgStrong](#cmpxchgStrong)

    &nbsp;
- name: 'Builtin Functions: @atomicRmw'
  id: index#atomicRmw
  summary: This builtin function dereferences a pointer to a T and atomically modifies the value and returns the previous value
  description: |-
    ### @atomicRmw

    ``` zig
    @atomicRmw(comptime T: type, ptr: *T, comptime op: AtomicRmwOp, operand: T, comptime ordering: AtomicOrder) T
    ```

    This builtin function dereferences a pointer to a `T` and atomically modifies the value and returns the previous value.

    `T` must be a pointer, a `bool`, a float, an integer or an enum.

    `AtomicOrder` can be found with `@import``(``"std"``).builtin.AtomicOrder`.

    `AtomicRmwOp` can be found with `@import``(``"std"``).builtin.AtomicRmwOp`.

    See also:

    - [@atomicStore](#atomicStore)
    - [@atomicLoad](#atomicLoad)
    - [@fence](#fence)
    - [@cmpxchgWeak](#cmpxchgWeak)
    - [@cmpxchgStrong](#cmpxchgStrong)

    &nbsp;
- name: 'Builtin Functions: @atomicStore'
  id: index#atomicStore
  summary: This builtin function dereferences a pointer to a T and atomically stores the given value
  description: |-
    ### @atomicStore

    ``` zig
    @atomicStore(comptime T: type, ptr: *T, value: T, comptime ordering: AtomicOrder) void
    ```

    This builtin function dereferences a pointer to a `T` and atomically stores the given value.

    `T` must be a pointer, a `bool`, a float, an integer or an enum.

    `AtomicOrder` can be found with `@import``(``"std"``).builtin.AtomicOrder`.

    See also:

    - [@atomicLoad](#atomicLoad)
    - [@atomicRmw](#atomicRmw)
    - [@fence](#fence)
    - [@cmpxchgWeak](#cmpxchgWeak)
    - [@cmpxchgStrong](#cmpxchgStrong)

    &nbsp;
- name: 'Builtin Functions: @bitCast'
  id: index#bitCast
  summary: Converts a value of one type to another type
  description: |-
    ### @bitCast

    ``` zig
    @bitCast(value: anytype) anytype
    ```

    Converts a value of one type to another type. The return type is the inferred result type.

    Asserts that `@sizeOf``(``@TypeOf``(value)) == ``@sizeOf``(DestType)`.

    Asserts that `@typeInfo``(DestType) != .Pointer`. Use `@ptrCast` or `@ptrFromInt` if you need this.

    Can be used for these things for example:

    - Convert `f32` to `u32` bits
    - Convert `i32` to `u32` preserving twos complement

    Works at compile-time if `value` is known at compile time. It's a compile error to bitcast a value of undefined layout; this means that, besides the restriction from types which possess dedicated casting builtins (enums, pointers, error sets), bare structs, error unions, slices, optionals, and any other type without a well-defined memory layout, also cannot be used in this operation.
- name: 'Builtin Functions: @bitOffsetOf'
  id: index#bitOffsetOf
  summary: Returns the bit offset of a field relative to its containing struct
  description: |-
    ### @bitOffsetOf

    ``` zig
    @bitOffsetOf(comptime T: type, comptime field_name: []const u8) comptime_int
    ```

    Returns the bit offset of a field relative to its containing struct.

    For non [packed structs](#packed-struct), this will always be divisible by `8`. For packed structs, non-byte-aligned fields will share a byte offset, but they will have different bit offsets.

    See also:

    - [@offsetOf](#offsetOf)

    &nbsp;
- name: 'Builtin Functions: @bitReverse'
  id: index#bitReverse
  summary: '@TypeOf``(``anytype``) accepts any integer type or integer vector type'
  description: |-
    ### @bitReverse

    ``` zig
    @bitReverse(integer: anytype) T
    ```

    `@TypeOf``(``anytype``)` accepts any integer type or integer vector type.

    Reverses the bitpattern of an integer value, including the sign bit if applicable.

    For example 0b10110110 (`u8`` = ``182`, `i8`` = -``74`) becomes 0b01101101 (`u8`` = ``109`, `i8`` = ``109`).
- name: 'Builtin Functions: @bitSizeOf'
  id: index#bitSizeOf
  summary: This function returns the number of bits it takes to store T in memory if the type were a field in a packed struct/union
  description: |-
    ### @bitSizeOf

    ``` zig
    @bitSizeOf(comptime T: type) comptime_int
    ```

    This function returns the number of bits it takes to store `T` in memory if the type were a field in a packed struct/union. The result is a target-specific compile time constant.

    This function measures the size at runtime. For types that are disallowed at runtime, such as `comptime_int` and `type`, the result is `0`.

    See also:

    - [@sizeOf](#sizeOf)
    - [@typeInfo](#typeInfo)

    &nbsp;
- name: 'Builtin Functions: @breakpoint'
  id: index#breakpoint
  summary: This function inserts a platform-specific debug trap instruction which causes debuggers to break there
  description: |-
    ### @breakpoint

    ``` zig
    @breakpoint() void
    ```

    This function inserts a platform-specific debug trap instruction which causes debuggers to break there. Unlike for `@trap``()`, execution may continue after this point if the program is resumed.

    This function is only valid within function scope.

    See also:

    - [@trap](#trap)

    &nbsp;
- name: 'Builtin Functions: @byteSwap'
  id: index#byteSwap
  summary: '@TypeOf``(operand) must be an integer type or an integer vector type with bit count evenly divisible by 8'
  description: |-
    ### @byteSwap

    ``` zig
    @byteSwap(operand: anytype) T
    ```

    `@TypeOf``(operand)` must be an integer type or an integer vector type with bit count evenly divisible by 8.

    `operand` may be an [integer](#Integers) or [vector](#Vectors).

    Swaps the byte order of the integer. This converts a big endian integer to a little endian integer, and converts a little endian integer to a big endian integer.

    Note that for the purposes of memory layout with respect to endianness, the integer type should be related to the number of bytes reported by [@sizeOf](#sizeOf) bytes. This is demonstrated with `u24`. `@sizeOf``(``u24``) == ``4`, which means that a `u24` stored in memory takes 4 bytes, and those 4 bytes are what are swapped on a little vs big endian system. On the other hand, if `T` is specified to be `u24`, then only 3 bytes are reversed.
- name: 'Builtin Functions: @call'
  id: index#call
  summary: '@call allows more flexibility than normal function call syntax does'
  description: "### @call\n\n``` zig\n@call(modifier: std.builtin.CallModifier, function: anytype, args: anytype) anytype\n```\n\nCalls a function, in the same way that invoking an expression with parentheses does:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"noinline function call\" {\n    try expect(@call(.auto, add, .{ 3, 9 }) == 12);\n}\n\nfn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n```\n\ntest_call_builtin.zig\n\n            $ zig test test_call_builtin.zig\n    1/1 test_call_builtin.test.noinline function call...OK\n    All 1 tests passed.\n\n          \n\nShell\n\n`@call` allows more flexibility than normal function call syntax does. The `CallModifier` enum is reproduced here:\n\n``` zig\npub const CallModifier = enum {\n    /// Equivalent to function call syntax.\n    auto,\n\n    /// Equivalent to async keyword used with function call syntax.\n    async_kw,\n\n    /// Prevents tail call optimization. This guarantees that the return\n    /// address will point to the callsite, as opposed to the callsite's\n    /// callsite. If the call is otherwise required to be tail-called\n    /// or inlined, a compile error is emitted instead.\n    never_tail,\n\n    /// Guarantees that the call will not be inlined. If the call is\n    /// otherwise required to be inlined, a compile error is emitted instead.\n    never_inline,\n\n    /// Asserts that the function call will not suspend. This allows a\n    /// non-async function to call an async function.\n    no_async,\n\n    /// Guarantees that the call will be generated with tail call optimization.\n    /// If this is not possible, a compile error is emitted instead.\n    always_tail,\n\n    /// Guarantees that the call will inlined at the callsite.\n    /// If this is not possible, a compile error is emitted instead.\n    always_inline,\n\n    /// Evaluates the call at compile-time. If the call cannot be completed at\n    /// compile-time, a compile error is emitted instead.\n    compile_time,\n};\n```\n\nbuiltin.CallModifier struct.zig"
- name: 'Builtin Functions: @cDefine'
  id: index#cDefine
  summary: This function can only occur inside @cImport
  description: |-
    ### @cDefine

    ``` zig
    @cDefine(comptime name: []const u8, value) void
    ```

    This function can only occur inside `@cImport`.

    This appends `#define $name $value` to the `@cImport` temporary buffer.

    To define without a value, like this:

    ``` zig
    #define _GNU_SOURCE
    ```

    Use the void value, like this:

    ``` zig
    @cDefine("_GNU_SOURCE", {})
    ```

    See also:

    - [Import from C Header File](#Import-from-C-Header-File)
    - [@cInclude](#cInclude)
    - [@cImport](#cImport)
    - [@cUndef](#cUndef)
    - [void](#void)

    &nbsp;
- name: 'Builtin Functions: @ceil'
  id: index#ceil
  summary: Returns the smallest integral value not less than the given floating point number
  description: |-
    ### @ceil

    ``` zig
    @ceil(value: anytype) @TypeOf(value)
    ```

    Returns the smallest integral value not less than the given floating point number. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @cImport'
  id: index#cImport
  summary: This function parses C code and imports the functions, types, variables, and compatible macro definitions into a new empty struct type, and then returns that type
  description: |-
    ### @cImport

    ``` zig
    @cImport(expression) type
    ```

    This function parses C code and imports the functions, types, variables, and compatible macro definitions into a new empty struct type, and then returns that type.

    `expression` is interpreted at compile time. The builtin functions `@cInclude`, `@cDefine`, and `@cUndef` work within this expression, appending to a temporary buffer which is then parsed as C code.

    Usually you should only have one `@cImport` in your entire application, because it saves the compiler from invoking clang multiple times, and prevents inline functions from being duplicated.

    Reasons for having multiple `@cImport` expressions would be:

    - To avoid a symbol collision, for example if foo.h and bar.h both `#define CONNECTION_COUNT`
    - To analyze the C code with different preprocessor defines

    See also:

    - [Import from C Header File](#Import-from-C-Header-File)
    - [@cInclude](#cInclude)
    - [@cDefine](#cDefine)
    - [@cUndef](#cUndef)

    &nbsp;
- name: 'Builtin Functions: @cInclude'
  id: index#cInclude
  summary: This function can only occur inside @cImport
  description: |-
    ### @cInclude

    ``` zig
    @cInclude(comptime path: []const u8) void
    ```

    This function can only occur inside `@cImport`.

    This appends `#include <$path>\n` to the `c_import` temporary buffer.

    See also:

    - [Import from C Header File](#Import-from-C-Header-File)
    - [@cImport](#cImport)
    - [@cDefine](#cDefine)
    - [@cUndef](#cUndef)

    &nbsp;
- name: 'Builtin Functions: @clz'
  id: index#clz
  summary: '@TypeOf``(operand) must be an integer type or an integer vector type'
  description: |-
    ### @clz

    ``` zig
    @clz(operand: anytype) anytype
    ```

    `@TypeOf``(operand)` must be an integer type or an integer vector type.

    `operand` may be an [integer](#Integers) or [vector](#Vectors).

    Counts the number of most-significant (leading in a big-endian sense) zeroes in an integer - "count leading zeroes".

    If `operand` is a [comptime](#comptime)-known integer, the return type is `comptime_int`. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.

    If `operand` is zero, `@clz` returns the bit width of integer type `T`.

    See also:

    - [@ctz](#ctz)
    - [@popCount](#popCount)

    &nbsp;
- name: 'Builtin Functions: @cmpxchgStrong'
  id: index#cmpxchgStrong
  summary: This function performs a strong atomic compare-and-exchange operation, returning null if the current value is not the given expected value
  description: |-
    ### @cmpxchgStrong

    ``` zig
    @cmpxchgStrong(comptime T: type, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T
    ```

    This function performs a strong atomic compare-and-exchange operation, returning `null` if the current value is not the given expected value. It's the equivalent of this code, except atomic:

    ``` zig
    fn cmpxchgStrongButNotAtomic(comptime T: type, ptr: *T, expected_value: T, new_value: T) ?T {
        const old_value = ptr.*;
        if (old_value == expected_value) {
            ptr.* = new_value;
            return null;
        } else {
            return old_value;
        }
    }
    ```

    not_atomic_cmpxchgStrong.zig

    If you are using cmpxchg in a retry loop, [@cmpxchgWeak](#cmpxchgWeak) is the better choice, because it can be implemented more efficiently in machine instructions.

    `T` must be a pointer, a `bool`, a float, an integer or an enum.

    `@typeInfo``(``@TypeOf``(ptr)).Pointer.alignment` must be `>= ``@sizeOf``(T).`

    `AtomicOrder` can be found with `@import``(``"std"``).builtin.AtomicOrder`.

    See also:

    - [@atomicStore](#atomicStore)
    - [@atomicLoad](#atomicLoad)
    - [@atomicRmw](#atomicRmw)
    - [@fence](#fence)
    - [@cmpxchgWeak](#cmpxchgWeak)

    &nbsp;
- name: 'Builtin Functions: @cmpxchgWeak'
  id: index#cmpxchgWeak
  summary: This function performs a weak atomic compare-and-exchange operation, returning null if the current value is not the given expected value
  description: |-
    ### @cmpxchgWeak

    ``` zig
    @cmpxchgWeak(comptime T: type, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T
    ```

    This function performs a weak atomic compare-and-exchange operation, returning `null` if the current value is not the given expected value. It's the equivalent of this code, except atomic:

    ``` zig
    fn cmpxchgWeakButNotAtomic(comptime T: type, ptr: *T, expected_value: T, new_value: T) ?T {
        const old_value = ptr.*;
        if (old_value == expected_value and usuallyTrueButSometimesFalse()) {
            ptr.* = new_value;
            return null;
        } else {
            return old_value;
        }
    }
    ```

    cmpxchgWeakButNotAtomic

    If you are using cmpxchg in a retry loop, the sporadic failure will be no problem, and `cmpxchgWeak` is the better choice, because it can be implemented more efficiently in machine instructions. However if you need a stronger guarantee, use [@cmpxchgStrong](#cmpxchgStrong).

    `T` must be a pointer, a `bool`, a float, an integer or an enum.

    `@typeInfo``(``@TypeOf``(ptr)).Pointer.alignment` must be `>= ``@sizeOf``(T).`

    `AtomicOrder` can be found with `@import``(``"std"``).builtin.AtomicOrder`.

    See also:

    - [@atomicStore](#atomicStore)
    - [@atomicLoad](#atomicLoad)
    - [@atomicRmw](#atomicRmw)
    - [@fence](#fence)
    - [@cmpxchgStrong](#cmpxchgStrong)

    &nbsp;
- name: 'Builtin Functions: @compileError'
  id: index#compileError
  summary: This function, when semantically analyzed, causes a compile error with the message msg
  description: |-
    ### @compileError

    ``` zig
    @compileError(comptime msg: []const u8) noreturn
    ```

    This function, when semantically analyzed, causes a compile error with the message `msg`.

    There are several ways that code avoids being semantically checked, such as using `if` or `switch` with compile time constants, and `comptime` functions.
- name: 'Builtin Functions: @compileLog'
  id: index#compileLog
  summary: This function prints the arguments passed to it at compile-time
  description: "### @compileLog\n\n``` zig\n@compileLog(args: ...) void\n```\n\nThis function prints the arguments passed to it at compile-time.\n\nTo prevent accidentally leaving compile log statements in a codebase, a compilation error is added to the build, pointing to the compile log statement. This error prevents code from being generated, but does not otherwise interfere with analysis.\n\nThis function can be used to do \"printf debugging\" on compile-time executing code.\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst num1 = blk: {\n    var val1: i32 = 99;\n    @compileLog(\"comptime val1 = \", val1);\n    val1 = val1 + 1;\n    break :blk val1;\n};\n\ntest \"main\" {\n    @compileLog(\"comptime in main\");\n\n    print(\"Runtime in main, num1 = {}.\\n\", .{num1});\n}\n```\n\ntest_compileLog_builtin.zig\n\n            $ zig test test_compileLog_builtin.zig\n    doc/langref/test_compileLog_builtin.zig:11:5: error: found compile log statement\n        @compileLog(\"comptime in main\");\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_compileLog_builtin.zig:5:5: note: also here\n        @compileLog(\"comptime val1 = \", val1);\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Compile Log Output:\n    @as(*const [16:0]u8, \"comptime in main\")\n    @as(*const [16:0]u8, \"comptime val1 = \"), @as(i32, 99)\n\n          \n\nShell"
- name: 'Builtin Functions: @constCast'
  id: index#constCast
  summary: Remove const qualifier from a pointer
  description: |-
    ### @constCast

    ``` zig
    @constCast(value: anytype) DestType
    ```

    Remove `const` qualifier from a pointer.
- name: 'Builtin Functions: @cos'
  id: index#cos
  summary: Cosine trigonometric function on a floating point number in radians
  description: |-
    ### @cos

    ``` zig
    @cos(value: anytype) @TypeOf(value)
    ```

    Cosine trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @ctz'
  id: index#ctz
  summary: '@TypeOf``(operand) must be an integer type or an integer vector type'
  description: |-
    ### @ctz

    ``` zig
    @ctz(operand: anytype) anytype
    ```

    `@TypeOf``(operand)` must be an integer type or an integer vector type.

    `operand` may be an [integer](#Integers) or [vector](#Vectors).

    Counts the number of least-significant (trailing in a big-endian sense) zeroes in an integer - "count trailing zeroes".

    If `operand` is a [comptime](#comptime)-known integer, the return type is `comptime_int`. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.

    If `operand` is zero, `@ctz` returns the bit width of integer type `T`.

    See also:

    - [@clz](#clz)
    - [@popCount](#popCount)

    &nbsp;
- name: 'Builtin Functions: @cUndef'
  id: index#cUndef
  summary: This function can only occur inside @cImport
  description: |-
    ### @cUndef

    ``` zig
    @cUndef(comptime name: []const u8) void
    ```

    This function can only occur inside `@cImport`.

    This appends `#undef $name` to the `@cImport` temporary buffer.

    See also:

    - [Import from C Header File](#Import-from-C-Header-File)
    - [@cImport](#cImport)
    - [@cDefine](#cDefine)
    - [@cInclude](#cInclude)

    &nbsp;
- name: 'Builtin Functions: @cVaArg'
  id: index#cVaArg
  summary: Implements the C macro va_arg
  description: |-
    ### @cVaArg

    ``` zig
    @cVaArg(operand: *std.builtin.VaList, comptime T: type) T
    ```

    Implements the C macro `va_arg`.

    See also:

    - [@cVaCopy](#cVaCopy)
    - [@cVaEnd](#cVaEnd)
    - [@cVaStart](#cVaStart)

    &nbsp;
- name: 'Builtin Functions: @cVaCopy'
  id: index#cVaCopy
  summary: Implements the C macro va_copy
  description: |-
    ### @cVaCopy

    ``` zig
    @cVaCopy(src: *std.builtin.VaList) std.builtin.VaList
    ```

    Implements the C macro `va_copy`.

    See also:

    - [@cVaArg](#cVaArg)
    - [@cVaEnd](#cVaEnd)
    - [@cVaStart](#cVaStart)

    &nbsp;
- name: 'Builtin Functions: @cVaEnd'
  id: index#cVaEnd
  summary: Implements the C macro va_end
  description: |-
    ### @cVaEnd

    ``` zig
    @cVaEnd(src: *std.builtin.VaList) void
    ```

    Implements the C macro `va_end`.

    See also:

    - [@cVaArg](#cVaArg)
    - [@cVaCopy](#cVaCopy)
    - [@cVaStart](#cVaStart)

    &nbsp;
- name: 'Builtin Functions: @cVaStart'
  id: index#cVaStart
  summary: Implements the C macro va_start
  description: |-
    ### @cVaStart

    ``` zig
    @cVaStart() std.builtin.VaList
    ```

    Implements the C macro `va_start`. Only valid inside a variadic function.

    See also:

    - [@cVaArg](#cVaArg)
    - [@cVaCopy](#cVaCopy)
    - [@cVaEnd](#cVaEnd)

    &nbsp;
- name: 'Builtin Functions: @divExact'
  id: index#divExact
  summary: Exact division
  description: |-
    ### @divExact

    ``` zig
    @divExact(numerator: T, denominator: T) T
    ```

    Exact division. Caller guarantees `denominator != ``0` and `@divTrunc``(numerator, denominator) * denominator == numerator`.

    - `@divExact``(``6``, ``3``) == ``2`
    - `@divExact``(a, b) * b == a`

    For a function that returns a possible error code, use `@import``(``"std"``).math.divExact`.

    See also:

    - [@divTrunc](#divTrunc)
    - [@divFloor](#divFloor)

    &nbsp;
- name: 'Builtin Functions: @divFloor'
  id: index#divFloor
  summary: Floored division
  description: |-
    ### @divFloor

    ``` zig
    @divFloor(numerator: T, denominator: T) T
    ```

    Floored division. Rounds toward negative infinity. For unsigned integers it is the same as `numerator / denominator`. Caller guarantees `denominator != ``0` and `!(``@typeInfo``(T) == .Int ``and`` T.is_signed ``and`` numerator == std.math.minInt(T) ``and`` denominator == -``1``)`.

    - `@divFloor``(-``5``, ``3``) == -``2`
    - `(``@divFloor``(a, b) * b) + ``@mod``(a, b) == a`

    For a function that returns a possible error code, use `@import``(``"std"``).math.divFloor`.

    See also:

    - [@divTrunc](#divTrunc)
    - [@divExact](#divExact)

    &nbsp;
- name: 'Builtin Functions: @divTrunc'
  id: index#divTrunc
  summary: Truncated division
  description: |-
    ### @divTrunc

    ``` zig
    @divTrunc(numerator: T, denominator: T) T
    ```

    Truncated division. Rounds toward zero. For unsigned integers it is the same as `numerator / denominator`. Caller guarantees `denominator != ``0` and `!(``@typeInfo``(T) == .Int ``and`` T.is_signed ``and`` numerator == std.math.minInt(T) ``and`` denominator == -``1``)`.

    - `@divTrunc``(-``5``, ``3``) == -``1`
    - `(``@divTrunc``(a, b) * b) + ``@rem``(a, b) == a`

    For a function that returns a possible error code, use `@import``(``"std"``).math.divTrunc`.

    See also:

    - [@divFloor](#divFloor)
    - [@divExact](#divExact)

    &nbsp;
- name: 'Builtin Functions: @embedFile'
  id: index#embedFile
  summary: This function returns a compile time constant pointer to null-terminated, fixed-size array with length equal to the byte count of the file given by path
  description: |-
    ### @embedFile

    ``` zig
    @embedFile(comptime path: []const u8) *const [N:0]u8
    ```

    This function returns a compile time constant pointer to null-terminated, fixed-size array with length equal to the byte count of the file given by `path`. The contents of the array are the contents of the file. This is equivalent to a [string literal](#String-Literals-and-Unicode-Code-Point-Literals) with the file contents.

    `path` is absolute or relative to the current file, just like `@import`.

    See also:

    - [@import](#import)

    &nbsp;
- name: 'Builtin Functions: @enumFromInt'
  id: index#enumFromInt
  summary: Converts an integer into an enum value
  description: |-
    ### @enumFromInt

    ``` zig
    @enumFromInt(integer: anytype) anytype
    ```

    Converts an integer into an [enum](#enum) value. The return type is the inferred result type.

    Attempting to convert an integer which represents no value in the chosen enum type invokes safety-checked [Undefined Behavior](#Undefined-Behavior).

    See also:

    - [@intFromEnum](#intFromEnum)

    &nbsp;
- name: 'Builtin Functions: @errorCast'
  id: index#errorCast
  summary: Converts an error set or error union value from one error set to another error set
  description: |-
    ### @errorCast

    ``` zig
    @errorCast(value: anytype) anytype
    ```

    Converts an error set or error union value from one error set to another error set. The return type is the inferred result type. Attempting to convert an error which is not in the destination error set results in safety-protected [Undefined Behavior](#Undefined-Behavior).
- name: 'Builtin Functions: @errorFromInt'
  id: index#errorFromInt
  summary: Converts from the integer representation of an error into The Global Error Set type
  description: |-
    ### @errorFromInt

    ``` zig
    @errorFromInt(value: std.meta.Int(.unsigned, @bitSizeOf(anyerror))) anyerror
    ```

    Converts from the integer representation of an error into [The Global Error Set](#The-Global-Error-Set) type.

    It is generally recommended to avoid this cast, as the integer representation of an error is not stable across source code changes.

    Attempting to convert an integer that does not correspond to any error results in safety-protected [Undefined Behavior](#Undefined-Behavior).

    See also:

    - [@intFromError](#intFromError)

    &nbsp;
- name: 'Builtin Functions: @errorName'
  id: index#errorName
  summary: This function returns the string representation of an error
  description: |-
    ### @errorName

    ``` zig
    @errorName(err: anyerror) [:0]const u8
    ```

    This function returns the string representation of an error. The string representation of `error``.OutOfMem` is `"OutOfMem"`.

    If there are no calls to `@errorName` in an entire application, or all calls have a compile-time known value for `err`, then no error name table will be generated.
- name: 'Builtin Functions: @errorReturnTrace'
  id: index#errorReturnTrace
  summary: If the binary is built with error return tracing, and this function is invoked in a function that calls a function with an error or error union return type, returns a stack trace object
  description: |-
    ### @errorReturnTrace

    ``` zig
    @errorReturnTrace() ?*builtin.StackTrace
    ```

    If the binary is built with error return tracing, and this function is invoked in a function that calls a function with an error or error union return type, returns a stack trace object. Otherwise returns [null](#null).
- name: 'Builtin Functions: @exp'
  id: index#exp
  summary: Base-e exponential function on a floating point number
  description: |-
    ### @exp

    ``` zig
    @exp(value: anytype) @TypeOf(value)
    ```

    Base-e exponential function on a floating point number. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @exp2'
  id: index#exp2
  summary: Base-2 exponential function on a floating point number
  description: |-
    ### @exp2

    ``` zig
    @exp2(value: anytype) @TypeOf(value)
    ```

    Base-2 exponential function on a floating point number. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @export'
  id: index#export
  summary: Creates a symbol in the output object file
  description: "### @export\n\n``` zig\n@export(declaration, comptime options: std.builtin.ExportOptions) void\n```\n\nCreates a symbol in the output object file.\n\n`declaration` must be one of two things:\n\n- An identifier (`x`) identifying a [function](#Functions) or a [variable](#Container-Level-Variables).\n- Field access (`x.y`) looking up a [function](#Functions) or a [variable](#Container-Level-Variables).\n\nThis builtin can be called from a [comptime](#comptime) block to conditionally export symbols. When `declaration` is a function with the C calling convention and `options.linkage` is `Strong`, this is equivalent to the `export` keyword used on a function:\n\n``` zig\ncomptime {\n    @export(internalName, .{ .name = \"foo\", .linkage = .strong });\n}\n\nfn internalName() callconv(.C) void {}\n```\n\nexport_builtin.zig\n\n            $ zig build-obj export_builtin.zig\n\n          \n\nShell\n\nThis is equivalent to:\n\n``` zig\nexport fn foo() void {}\n```\n\nexport_builtin_equivalent_code.zig\n\n            $ zig build-obj export_builtin_equivalent_code.zig\n\n          \n\nShell\n\nNote that even when using `export`, the `@\"foo\"` syntax for [identifiers](#Identifiers) can be used to choose any string for the symbol name:\n\n``` zig\nexport fn @\"A function name that is a complete sentence.\"() void {}\n```\n\nexport_any_symbol_name.zig\n\n            $ zig build-obj export_any_symbol_name.zig\n\n          \n\nShell\n\nWhen looking at the resulting object, you can see the symbol is used verbatim:\n\n``` zig\n00000000000001f0 T A function name that is a complete sentence.\n```\n\nSee also:\n\n- [Exporting a C Library](#Exporting-a-C-Library)\n\n&nbsp;"
- name: 'Builtin Functions: @extern'
  id: index#extern
  summary: Creates a reference to an external symbol in the output object file
  description: |-
    ### @extern

    ``` zig
    @extern(T: type, comptime options: std.builtin.ExternOptions) T
    ```

    Creates a reference to an external symbol in the output object file. T must be a pointer type.

    See also:

    - [@export](#export)

    &nbsp;
- name: 'Builtin Functions: @fence'
  id: index#fence
  summary: The fence function is used to introduce happens-before edges between operations
  description: |-
    ### @fence

    ``` zig
    @fence(order: AtomicOrder) void
    ```

    The `fence` function is used to introduce happens-before edges between operations.

    `AtomicOrder` can be found with `@import``(``"std"``).builtin.AtomicOrder`.

    See also:

    - [@atomicStore](#atomicStore)
    - [@atomicLoad](#atomicLoad)
    - [@atomicRmw](#atomicRmw)
    - [@cmpxchgWeak](#cmpxchgWeak)
    - [@cmpxchgStrong](#cmpxchgStrong)

    &nbsp;
- name: 'Builtin Functions: @field'
  id: index#field
  summary: Performs field access by a compile-time string
  description: "### @field\n\n``` zig\n@field(lhs: anytype, comptime field_name: []const u8) (field)\n```\n\nPerforms field access by a compile-time string. Works on both fields and declarations.\n\n``` zig\nconst std = @import(\"std\");\n\nconst Point = struct {\n    x: u32,\n    y: u32,\n\n    pub var z: u32 = 1;\n};\n\ntest \"field access by string\" {\n    const expect = std.testing.expect;\n    var p = Point{ .x = 0, .y = 0 };\n\n    @field(p, \"x\") = 4;\n    @field(p, \"y\") = @field(p, \"x\") + 1;\n\n    try expect(@field(p, \"x\") == 4);\n    try expect(@field(p, \"y\") == 5);\n}\n\ntest \"decl access by string\" {\n    const expect = std.testing.expect;\n\n    try expect(@field(Point, \"z\") == 1);\n\n    @field(Point, \"z\") = 2;\n    try expect(@field(Point, \"z\") == 2);\n}\n```\n\ntest_field_builtin.zig\n\n            $ zig test test_field_builtin.zig\n    1/2 test_field_builtin.test.field access by string...OK\n    2/2 test_field_builtin.test.decl access by string...OK\n    All 2 tests passed.\n\n          \n\nShell"
- name: 'Builtin Functions: @fieldParentPtr'
  id: index#fieldParentPtr
  summary: Given a pointer to a field, returns the base pointer of a struct
  description: |-
    ### @fieldParentPtr

    ``` zig
    @fieldParentPtr(comptime field_name: []const u8, field_ptr: *T) anytype
    ```

    Given a pointer to a field, returns the base pointer of a struct.
- name: 'Builtin Functions: @floatCast'
  id: index#floatCast
  summary: Convert from one float type to another
  description: |-
    ### @floatCast

    ``` zig
    @floatCast(value: anytype) anytype
    ```

    Convert from one float type to another. This cast is safe, but may cause the numeric value to lose precision. The return type is the inferred result type.
- name: 'Builtin Functions: @floatFromInt'
  id: index#floatFromInt
  summary: Converts an integer to the closest floating point representation
  description: |-
    ### @floatFromInt

    ``` zig
    @floatFromInt(int: anytype) anytype
    ```

    Converts an integer to the closest floating point representation. The return type is the inferred result type. To convert the other way, use [@intFromFloat](#intFromFloat). This operation is legal for all values of all integer types.
- name: 'Builtin Functions: @floor'
  id: index#floor
  summary: Returns the largest integral value not greater than the given floating point number
  description: |-
    ### @floor

    ``` zig
    @floor(value: anytype) @TypeOf(value)
    ```

    Returns the largest integral value not greater than the given floating point number. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @frameAddress'
  id: index#frameAddress
  summary: This function returns the base pointer of the current stack frame
  description: |-
    ### @frameAddress

    ``` zig
    @frameAddress() usize
    ```

    This function returns the base pointer of the current stack frame.

    The implications of this are target-specific and not consistent across all platforms. The frame address may not be available in release mode due to aggressive optimizations.

    This function is only valid within function scope.
- name: 'Builtin Functions: @hasDecl'
  id: index#hasDecl
  summary: Returns whether or not a container has a declaration matching name
  description: "### @hasDecl\n\n``` zig\n@hasDecl(comptime Container: type, comptime name: []const u8) bool\n```\n\nReturns whether or not a [container](#Containers) has a declaration matching `name`.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Foo = struct {\n    nope: i32,\n\n    pub var blah = \"xxx\";\n    const hi = 1;\n};\n\ntest \"@hasDecl\" {\n    try expect(@hasDecl(Foo, \"blah\"));\n\n    // Even though `hi` is private, @hasDecl returns true because this test is\n    // in the same file scope as Foo. It would return false if Foo was declared\n    // in a different file.\n    try expect(@hasDecl(Foo, \"hi\"));\n\n    // @hasDecl is for declarations; not fields.\n    try expect(!@hasDecl(Foo, \"nope\"));\n    try expect(!@hasDecl(Foo, \"nope1234\"));\n}\n```\n\ntest_hasDecl_builtin.zig\n\n            $ zig test test_hasDecl_builtin.zig\n    1/1 test_hasDecl_builtin.test.@hasDecl...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [@hasField](#hasField)\n\n&nbsp;"
- name: 'Builtin Functions: @hasField'
  id: index#hasField
  summary: Returns whether the field name of a struct, union, or enum exists
  description: |-
    ### @hasField

    ``` zig
    @hasField(comptime Container: type, comptime name: []const u8) bool
    ```

    Returns whether the field name of a struct, union, or enum exists.

    The result is a compile time constant.

    It does not include functions, variables, or constants.

    See also:

    - [@hasDecl](#hasDecl)

    &nbsp;
- name: 'Builtin Functions: @import'
  id: index#import
  summary: This function finds a zig file corresponding to path and adds it to the build, if it is not already added
  description: |-
    ### @import

    ``` zig
    @import(comptime path: []const u8) type
    ```

    This function finds a zig file corresponding to `path` and adds it to the build, if it is not already added.

    Zig source files are implicitly structs, with a name equal to the file's basename with the extension truncated. `@import` returns the struct type corresponding to the file.

    Declarations which have the `pub` keyword may be referenced from a different source file than the one they are declared in.

    `path` can be a relative path or it can be the name of a package. If it is a relative path, it is relative to the file that contains the `@import` function call.

    The following packages are always available:

    - `@import``(``"std"``)` - Zig Standard Library
    - `@import``(``"builtin"``)` - Target-specific information The command `zig build-exe --show-builtin` outputs the source to stdout for reference.
    - `@import``(``"root"``)` - Root source file This is usually `src/main.zig` but depends on what file is built.

    See also:

    - [Compile Variables](#Compile-Variables)
    - [@embedFile](#embedFile)

    &nbsp;
- name: 'Builtin Functions: @inComptime'
  id: index#inComptime
  summary: Returns whether the builtin was run in a comptime context
  description: |-
    ### @inComptime

    ``` zig
    @inComptime() bool
    ```

    Returns whether the builtin was run in a `comptime` context. The result is a compile-time constant.

    This can be used to provide alternative, comptime-friendly implementations of functions. It should not be used, for instance, to exclude certain functions from being evaluated at comptime.

    See also:

    - [comptime](#comptime)

    &nbsp;
- name: 'Builtin Functions: @intCast'
  id: index#intCast
  summary: Converts an integer to another integer while keeping the same numerical value
  description: "### @intCast\n\n``` zig\n@intCast(int: anytype) anytype\n```\n\nConverts an integer to another integer while keeping the same numerical value. The return type is the inferred result type. Attempting to convert a number which is out of range of the destination type results in safety-protected [Undefined Behavior](#Undefined-Behavior).\n\n``` zig\ntest \"integer cast panic\" {\n    var a: u16 = 0xabcd; // runtime-known\n    _ = &a;\n    const b: u8 = @intCast(a);\n    _ = b;\n}\n```\n\ntest_intCast_builtin.zig\n\n            $ zig test test_intCast_builtin.zig\n    1/1 test_intCast_builtin.test.integer cast panic...thread 3573820 panic: integer cast truncated bits\n    /home/andy/src/zig/doc/langref/test_intCast_builtin.zig:4:19: 0x103ce6b in test.integer cast panic (test)\n        const b: u8 = @intCast(a);\n                      ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048290 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e24b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d389 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cef1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/a3b6539437d55800e891e62090700351/test\n\n          \n\nShell\n\nTo truncate the significant bits of a number out of range of the destination type, use [@truncate](#truncate).\n\nIf `T` is `comptime_int`, then this is semantically equivalent to [Type Coercion](#Type-Coercion)."
- name: 'Builtin Functions: @intFromBool'
  id: index#intFromBool
  summary: Converts true to @as``(``u1``, ``1``) and false to @as``(``u1``, ``0``)
  description: |-
    ### @intFromBool

    ``` zig
    @intFromBool(value: bool) u1
    ```

    Converts `true` to `@as``(``u1``, ``1``)` and `false` to `@as``(``u1``, ``0``)`.
- name: 'Builtin Functions: @intFromEnum'
  id: index#intFromEnum
  summary: Converts an enumeration value into its integer tag type
  description: |-
    ### @intFromEnum

    ``` zig
    @intFromEnum(enum_or_tagged_union: anytype) anytype
    ```

    Converts an enumeration value into its integer tag type. When a tagged union is passed, the tag value is used as the enumeration value.

    If there is only one possible enum value, the result is a `comptime_int` known at [comptime](#comptime).

    See also:

    - [@enumFromInt](#enumFromInt)

    &nbsp;
- name: 'Builtin Functions: @intFromError'
  id: index#intFromError
  summary: Converts an error to the integer representation of an error
  description: |-
    ### @intFromError

    ``` zig
    @intFromError(err: anytype) std.meta.Int(.unsigned, @bitSizeOf(anyerror))
    ```

    Supports the following types:

    - [The Global Error Set](#The-Global-Error-Set)
    - [Error Set Type](#Error-Set-Type)
    - [Error Union Type](#Error-Union-Type)

    Converts an error to the integer representation of an error.

    It is generally recommended to avoid this cast, as the integer representation of an error is not stable across source code changes.

    See also:

    - [@errorFromInt](#errorFromInt)

    &nbsp;
- name: 'Builtin Functions: @intFromFloat'
  id: index#intFromFloat
  summary: Converts the integer part of a floating point number to the inferred result type
  description: |-
    ### @intFromFloat

    ``` zig
    @intFromFloat(float: anytype) anytype
    ```

    Converts the integer part of a floating point number to the inferred result type.

    If the integer part of the floating point number cannot fit in the destination type, it invokes safety-checked [Undefined Behavior](#Undefined-Behavior).

    See also:

    - [@floatFromInt](#floatFromInt)

    &nbsp;
- name: 'Builtin Functions: @intFromPtr'
  id: index#intFromPtr
  summary: Converts value to a usize which is the address of the pointer
  description: |-
    ### @intFromPtr

    ``` zig
    @intFromPtr(value: anytype) usize
    ```

    Converts `value` to a `usize` which is the address of the pointer. `value` can be `*T` or `?*T`.

    To convert the other way, use [@ptrFromInt](#ptrFromInt)
- name: 'Builtin Functions: @log'
  id: index#log
  summary: Returns the natural logarithm of a floating point number
  description: |-
    ### @log

    ``` zig
    @log(value: anytype) @TypeOf(value)
    ```

    Returns the natural logarithm of a floating point number. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @log10'
  id: index#log10
  summary: Returns the logarithm to the base 10 of a floating point number
  description: |-
    ### @log10

    ``` zig
    @log10(value: anytype) @TypeOf(value)
    ```

    Returns the logarithm to the base 10 of a floating point number. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @log2'
  id: index#log2
  summary: Returns the logarithm to the base 2 of a floating point number
  description: |-
    ### @log2

    ``` zig
    @log2(value: anytype) @TypeOf(value)
    ```

    Returns the logarithm to the base 2 of a floating point number. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @max'
  id: index#max
  summary: Returns the maximum value of a and b
  description: |-
    ### @max

    ``` zig
    @max(a: T, b: T) T
    ```

    Returns the maximum value of `a` and `b`. This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise.

    NaNs are handled as follows: if one of the operands of a (pairwise) operation is NaN, the other operand is returned. If both operands are NaN, NaN is returned.

    See also:

    - [@min](#min)
    - [Vectors](#Vectors)

    &nbsp;
- name: 'Builtin Functions: @memcpy'
  id: index#memcpy
  summary: This function copies bytes from one region of memory to another
  description: |-
    ### @memcpy

    ``` zig
    @memcpy(noalias dest, noalias source) void
    ```

    This function copies bytes from one region of memory to another.

    `dest` must be a mutable slice, a mutable pointer to an array, or a mutable many-item [pointer](#Pointers). It may have any alignment, and it may have any element type.

    `source` must be a slice, a pointer to an array, or a many-item [pointer](#Pointers). It may have any alignment, and it may have any element type.

    The `source` element type must support [Type Coercion](#Type-Coercion) into the `dest` element type. The element types may have different ABI size, however, that may incur a performance penalty.

    Similar to [for](#for) loops, at least one of `source` and `dest` must provide a length, and if two lengths are provided, they must be equal.

    Finally, the two memory regions must not overlap.
- name: 'Builtin Functions: @memset'
  id: index#memset
  summary: This function sets all the elements of a memory region to elem
  description: |-
    ### @memset

    ``` zig
    @memset(dest, elem) void
    ```

    This function sets all the elements of a memory region to `elem`.

    `dest` must be a mutable slice or a mutable pointer to an array. It may have any alignment, and it may have any element type.

    `elem` is coerced to the element type of `dest`.

    For securely zeroing out sensitive contents from memory, you should use `std.crypto.utils.secureZero`
- name: 'Builtin Functions: @min'
  id: index#min
  summary: Returns the minimum value of a and b
  description: |-
    ### @min

    ``` zig
    @min(a: T, b: T) T
    ```

    Returns the minimum value of `a` and `b`. This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise.

    NaNs are handled as follows: if one of the operands of a (pairwise) operation is NaN, the other operand is returned. If both operands are NaN, NaN is returned.

    See also:

    - [@max](#max)
    - [Vectors](#Vectors)

    &nbsp;
- name: 'Builtin Functions: @mod'
  id: index#mod
  summary: Modulus division
  description: |-
    ### @mod

    ``` zig
    @mod(numerator: T, denominator: T) T
    ```

    Modulus division. For unsigned integers this is the same as `numerator % denominator`. Caller guarantees `denominator > ``0`, otherwise the operation will result in a [Remainder Division by Zero](#Remainder-Division-by-Zero) when runtime safety checks are enabled.

    - `@mod``(-``5``, ``3``) == ``1`
    - `(``@divFloor``(a, b) * b) + ``@mod``(a, b) == a`

    For a function that returns an error code, see `@import``(``"std"``).math.mod`.

    See also:

    - [@rem](#rem)

    &nbsp;
- name: 'Builtin Functions: @mulAdd'
  id: index#mulAdd
  summary: Fused multiply-add, similar to (a * b) + c, except only rounds once, and is thus more accurate
  description: |-
    ### @mulAdd

    ``` zig
    @mulAdd(comptime T: type, a: T, b: T, c: T) T
    ```

    Fused multiply-add, similar to `(a * b) + c`, except only rounds once, and is thus more accurate.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @mulWithOverflow'
  id: index#mulWithOverflow
  summary: Performs a * b and returns a tuple with the result and a possible overflow bit
  description: |-
    ### @mulWithOverflow

    ``` zig
    @mulWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }
    ```

    Performs `a * b` and returns a tuple with the result and a possible overflow bit.
- name: 'Builtin Functions: @offsetOf'
  id: index#offsetOf
  summary: Returns the byte offset of a field relative to its containing struct
  description: |-
    ### @offsetOf

    ``` zig
    @offsetOf(comptime T: type, comptime field_name: []const u8) comptime_int
    ```

    Returns the byte offset of a field relative to its containing struct.

    See also:

    - [@bitOffsetOf](#bitOffsetOf)

    &nbsp;
- name: 'Builtin Functions: @panic'
  id: index#panic
  summary: Invokes the panic handler function
  description: |-
    ### @panic

    ``` zig
    @panic(message: []const u8) noreturn
    ```

    Invokes the panic handler function. By default the panic handler function calls the public `panic` function exposed in the root source file, or if there is not one specified, the `std.builtin.default_panic` function from `std/builtin.zig`.

    Generally it is better to use `@import``(``"std"``).debug.panic`. However, `@panic` can be useful for 2 scenarios:

    - From library code, calling the programmer's panic function if they exposed one in the root source file.
    - When mixing C and Zig code, calling the canonical panic implementation across multiple .o files.

    See also:

    - [Root Source File](#Root-Source-File)

    &nbsp;
- name: 'Builtin Functions: @popCount'
  id: index#popCount
  summary: '@TypeOf``(operand) must be an integer type'
  description: |-
    ### @popCount

    ``` zig
    @popCount(operand: anytype) anytype
    ```

    `@TypeOf``(operand)` must be an integer type.

    `operand` may be an [integer](#Integers) or [vector](#Vectors).

    Counts the number of bits set in an integer - "population count".

    If `operand` is a [comptime](#comptime)-known integer, the return type is `comptime_int`. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.

    See also:

    - [@ctz](#ctz)
    - [@clz](#clz)

    &nbsp;
- name: 'Builtin Functions: @prefetch'
  id: index#prefetch
  summary: This builtin tells the compiler to emit a prefetch instruction if supported by the target CPU
  description: |-
    ### @prefetch

    ``` zig
    @prefetch(ptr: anytype, comptime options: PrefetchOptions) void
    ```

    This builtin tells the compiler to emit a prefetch instruction if supported by the target CPU. If the target CPU does not support the requested prefetch instruction, this builtin is a no-op. This function has no effect on the behavior of the program, only on the performance characteristics.

    The `ptr` argument may be any pointer type and determines the memory address to prefetch. This function does not dereference the pointer, it is perfectly legal to pass a pointer to invalid memory to this function and no illegal behavior will result.

    `PrefetchOptions` can be found with `@import``(``"std"``).builtin.PrefetchOptions`.
- name: 'Builtin Functions: @ptrCast'
  id: index#ptrCast
  summary: Converts a pointer of one type to a pointer of another type
  description: |-
    ### @ptrCast

    ``` zig
    @ptrCast(value: anytype) anytype
    ```

    Converts a pointer of one type to a pointer of another type. The return type is the inferred result type.

    [Optional Pointers](#Optional-Pointers) are allowed. Casting an optional pointer which is [null](#null) to a non-optional pointer invokes safety-checked [Undefined Behavior](#Undefined-Behavior).

    `@ptrCast` cannot be used for:

    - Removing `const` qualifier, use [@constCast](#constCast).
    - Removing `volatile` qualifier, use [@volatileCast](#volatileCast).
    - Changing pointer address space, use [@addrSpaceCast](#addrSpaceCast).
    - Increasing pointer alignment, use [@alignCast](#alignCast).
    - Casting a non-slice pointer to a slice, use slicing syntax `ptr[start..end]`.

    &nbsp;
- name: 'Builtin Functions: @ptrFromInt'
  id: index#ptrFromInt
  summary: Converts an integer to a pointer
  description: |-
    ### @ptrFromInt

    ``` zig
    @ptrFromInt(address: usize) anytype
    ```

    Converts an integer to a [pointer](#Pointers). The return type is the inferred result type. To convert the other way, use [@intFromPtr](#intFromPtr). Casting an address of 0 to a destination type which in not [optional](#Optional-Pointers) and does not have the `allowzero` attribute will result in a [Pointer Cast Invalid Null](#Pointer-Cast-Invalid-Null) panic when runtime safety checks are enabled.

    If the destination pointer type does not allow address zero and `address` is zero, this invokes safety-checked [Undefined Behavior](#Undefined-Behavior).
- name: 'Builtin Functions: @reduce'
  id: index#reduce
  summary: Transforms a vector into a scalar value (of type E) by performing a sequential horizontal reduction of its elements using the specified operator op
  description: "### @reduce\n\n``` zig\n@reduce(comptime op: std.builtin.ReduceOp, value: anytype) E\n```\n\nTransforms a [vector](#Vectors) into a scalar value (of type `E`) by performing a sequential horizontal reduction of its elements using the specified operator `op`.\n\nNot every operator is available for every vector element type:\n\n- Every operator is available for [integer](#Integers) vectors.\n- `.And`, `.Or`, `.Xor` are additionally available for `bool` vectors,\n- `.Min`, `.Max`, `.Add`, `.Mul` are additionally available for [floating point](#Floats) vectors,\n\nNote that `.Add` and `.Mul` reductions on integral types are wrapping; when applied on floating point types the operation associativity is preserved, unless the float mode is set to `Optimized`.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"vector @reduce\" {\n    const V = @Vector(4, i32);\n    const value = V{ 1, -1, 1, -1 };\n    const result = value > @as(V, @splat(0));\n    // result is { true, false, true, false };\n    try comptime expect(@TypeOf(result) == @Vector(4, bool));\n    const is_all_true = @reduce(.And, result);\n    try comptime expect(@TypeOf(is_all_true) == bool);\n    try expect(is_all_true == false);\n}\n```\n\ntest_reduce_builtin.zig\n\n            $ zig test test_reduce_builtin.zig\n    1/1 test_reduce_builtin.test.vector @reduce...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [Vectors](#Vectors)\n- [@setFloatMode](#setFloatMode)\n\n&nbsp;"
- name: 'Builtin Functions: @rem'
  id: index#rem
  summary: Remainder division
  description: |-
    ### @rem

    ``` zig
    @rem(numerator: T, denominator: T) T
    ```

    Remainder division. For unsigned integers this is the same as `numerator % denominator`. Caller guarantees `denominator > ``0`, otherwise the operation will result in a [Remainder Division by Zero](#Remainder-Division-by-Zero) when runtime safety checks are enabled.

    - `@rem``(-``5``, ``3``) == -``2`
    - `(``@divTrunc``(a, b) * b) + ``@rem``(a, b) == a`

    For a function that returns an error code, see `@import``(``"std"``).math.rem`.

    See also:

    - [@mod](#mod)

    &nbsp;
- name: 'Builtin Functions: @returnAddress'
  id: index#returnAddress
  summary: This function returns the address of the next machine code instruction that will be executed when the current function returns
  description: |-
    ### @returnAddress

    ``` zig
    @returnAddress() usize
    ```

    This function returns the address of the next machine code instruction that will be executed when the current function returns.

    The implications of this are target-specific and not consistent across all platforms.

    This function is only valid within function scope. If the function gets inlined into a calling function, the returned address will apply to the calling function.
- name: 'Builtin Functions: @round'
  id: index#round
  summary: Rounds the given floating point number to an integer, away from zero
  description: |-
    ### @round

    ``` zig
    @round(value: anytype) @TypeOf(value)
    ```

    Rounds the given floating point number to an integer, away from zero. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @select'
  id: index#select
  summary: Selects values element-wise from a or b based on pred
  description: |-
    ### @select

    ``` zig
    @select(comptime T: type, pred: @Vector(len, bool), a: @Vector(len, T), b: @Vector(len, T)) @Vector(len, T)
    ```

    Selects values element-wise from `a` or `b` based on `pred`. If `pred[i]` is `true`, the corresponding element in the result will be `a[i]` and otherwise `b[i]`.

    See also:

    - [Vectors](#Vectors)

    &nbsp;
- name: 'Builtin Functions: @setAlignStack'
  id: index#setAlignStack
  summary: Ensures that a function will have a stack alignment of at least alignment bytes
  description: |-
    ### @setAlignStack

    ``` zig
    @setAlignStack(comptime alignment: u29) void
    ```

    Ensures that a function will have a stack alignment of at least `alignment` bytes.
- name: 'Builtin Functions: @setCold'
  id: index#setCold
  summary: Tells the optimizer that the current function is (or is not) rarely called
  description: |-
    ### @setCold

    ``` zig
    @setCold(comptime is_cold: bool) void
    ```

    Tells the optimizer that the current function is (or is not) rarely called. This function is only valid within function scope.
- name: 'Builtin Functions: @setEvalBranchQuota'
  id: index#setEvalBranchQuota
  summary: Increase the maximum number of backwards branches that compile-time code execution can use before giving up and making a compile error
  description: "### @setEvalBranchQuota\n\n``` zig\n@setEvalBranchQuota(comptime new_quota: u32) void\n```\n\nIncrease the maximum number of backwards branches that compile-time code execution can use before giving up and making a compile error.\n\nIf the `new_quota` is smaller than the default quota (`1000`) or a previously explicitly set quota, it is ignored.\n\nExample:\n\n``` zig\ntest \"foo\" {\n    comptime {\n        var i = 0;\n        while (i < 1001) : (i += 1) {}\n    }\n}\n```\n\ntest_without_setEvalBranchQuota_builtin.zig\n\n            $ zig test test_without_setEvalBranchQuota_builtin.zig\n    doc/langref/test_without_setEvalBranchQuota_builtin.zig:4:9: error: evaluation exceeded 1000 backwards branches\n            while (i < 1001) : (i += 1) {}\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_without_setEvalBranchQuota_builtin.zig:4:9: note: use @setEvalBranchQuota() to raise the branch limit from 1000\n\n\n          \n\nShell\n\nNow we use `@setEvalBranchQuota`:\n\n``` zig\ntest \"foo\" {\n    comptime {\n        @setEvalBranchQuota(1001);\n        var i = 0;\n        while (i < 1001) : (i += 1) {}\n    }\n}\n```\n\ntest_setEvalBranchQuota_builtin.zig\n\n            $ zig test test_setEvalBranchQuota_builtin.zig\n    1/1 test_setEvalBranchQuota_builtin.test.foo...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [comptime](#comptime)\n\n&nbsp;"
- name: 'Builtin Functions: @setFloatMode'
  id: index#setFloatMode
  summary: Changes the current scope's rules about how floating point operations are defined
  description: |-
    ### @setFloatMode

    ``` zig
    @setFloatMode(comptime mode: FloatMode) void
    ```

    Changes the current scope's rules about how floating point operations are defined.

    - `Strict` (default) - Floating point operations follow strict IEEE compliance.
    - `Optimized` - Floating point operations may do all of the following:
      - Assume the arguments and result are not NaN. Optimizations are required to retain defined behavior over NaNs, but the value of the result is undefined.
      - Assume the arguments and result are not +/-Inf. Optimizations are required to retain defined behavior over +/-Inf, but the value of the result is undefined.
      - Treat the sign of a zero argument or result as insignificant.
      - Use the reciprocal of an argument rather than perform division.
      - Perform floating-point contraction (e.g. fusing a multiply followed by an addition into a fused multiply-add).
      - Perform algebraically equivalent transformations that may change results in floating point (e.g. reassociate).

      This is equivalent to `-ffast-math` in GCC.

    The floating point mode is inherited by child scopes, and can be overridden in any scope. You can set the floating point mode in a struct or module scope by using a comptime block.

    `FloatMode` can be found with `@import``(``"std"``).builtin.FloatMode`.

    See also:

    - [Floating Point Operations](#Floating-Point-Operations)

    &nbsp;
- name: 'Builtin Functions: @setRuntimeSafety'
  id: index#setRuntimeSafety
  summary: Sets whether runtime safety checks are enabled for the scope that contains the function call
  description: "### @setRuntimeSafety\n\n``` zig\n@setRuntimeSafety(comptime safety_on: bool) void\n```\n\nSets whether runtime safety checks are enabled for the scope that contains the function call.\n\n``` zig\ntest \"@setRuntimeSafety\" {\n    // The builtin applies to the scope that it is called in. So here, integer overflow\n    // will not be caught in ReleaseFast and ReleaseSmall modes:\n    // var x: u8 = 255;\n    // x += 1; // undefined behavior in ReleaseFast/ReleaseSmall modes.\n    {\n        // However this block has safety enabled, so safety checks happen here,\n        // even in ReleaseFast and ReleaseSmall modes.\n        @setRuntimeSafety(true);\n        var x: u8 = 255;\n        x += 1;\n\n        {\n            // The value can be overridden at any scope. So here integer overflow\n            // would not be caught in any build mode.\n            @setRuntimeSafety(false);\n            // var x: u8 = 255;\n            // x += 1; // undefined behavior in all build modes.\n        }\n    }\n}\n```\n\ntest_setRuntimeSafety_builtin.zig\n\n            $ zig test test_setRuntimeSafety_builtin.zig -OReleaseFast\n    1/1 test_setRuntimeSafety_builtin.test.@setRuntimeSafety...thread 3579742 panic: integer overflow\n    /home/andy/src/zig/doc/langref/test_setRuntimeSafety_builtin.zig:11:11: 0x100ae54 in test.@setRuntimeSafety (test)\n            x += 1;\n              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x100c9b0 in main (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x100af44 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x100ae71 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/7c74a2939d84ddd0f45519d7a9f1c0f7/test\n\n          \n\nShell\n\nNote: it is [planned](https://github.com/ziglang/zig/issues/978) to replace `@setRuntimeSafety` with `@optimizeFor`"
- name: 'Builtin Functions: @shlExact'
  id: index#shlExact
  summary: Performs the left shift operation (<<)
  description: |-
    ### @shlExact

    ``` zig
    @shlExact(value: T, shift_amt: Log2T) T
    ```

    Performs the left shift operation (`<<`). For unsigned integers, the result is [undefined](#undefined) if any 1 bits are shifted out. For signed integers, the result is [undefined](#undefined) if any bits that disagree with the resultant sign bit are shifted out.

    The type of `shift_amt` is an unsigned integer with `log2(``@typeInfo``(T).Int.bits)` bits. This is because `shift_amt >= ``@typeInfo``(T).Int.bits` is undefined behavior.

    `comptime_int` is modeled as an integer with an infinite number of bits, meaning that in such case, `@shlExact` always produces a result and cannot produce a compile error.

    See also:

    - [@shrExact](#shrExact)
    - [@shlWithOverflow](#shlWithOverflow)

    &nbsp;
- name: 'Builtin Functions: @shlWithOverflow'
  id: index#shlWithOverflow
  summary: Performs a << b and returns a tuple with the result and a possible overflow bit
  description: |-
    ### @shlWithOverflow

    ``` zig
    @shlWithOverflow(a: anytype, shift_amt: Log2T) struct { @TypeOf(a), u1 }
    ```

    Performs `a << b` and returns a tuple with the result and a possible overflow bit.

    The type of `shift_amt` is an unsigned integer with `log2(``@typeInfo``(``@TypeOf``(a)).Int.bits)` bits. This is because `shift_amt >= ``@typeInfo``(``@TypeOf``(a)).Int.bits` is undefined behavior.

    See also:

    - [@shlExact](#shlExact)
    - [@shrExact](#shrExact)

    &nbsp;
- name: 'Builtin Functions: @shrExact'
  id: index#shrExact
  summary: Performs the right shift operation (>>)
  description: |-
    ### @shrExact

    ``` zig
    @shrExact(value: T, shift_amt: Log2T) T
    ```

    Performs the right shift operation (`>>`). Caller guarantees that the shift will not shift any 1 bits out.

    The type of `shift_amt` is an unsigned integer with `log2(``@typeInfo``(T).Int.bits)` bits. This is because `shift_amt >= ``@typeInfo``(T).Int.bits` is undefined behavior.

    See also:

    - [@shlExact](#shlExact)
    - [@shlWithOverflow](#shlWithOverflow)

    &nbsp;
- name: 'Builtin Functions: @shuffle'
  id: index#shuffle
  summary: Constructs a new vector by selecting elements from a and b based on mask
  description: "### @shuffle\n\n``` zig\n@shuffle(comptime E: type, a: @Vector(a_len, E), b: @Vector(b_len, E), comptime mask: @Vector(mask_len, i32)) @Vector(mask_len, E)\n```\n\nConstructs a new [vector](#Vectors) by selecting elements from `a` and `b` based on `mask`.\n\nEach element in `mask` selects an element from either `a` or `b`. Positive numbers select from `a` starting at 0. Negative values select from `b`, starting at `-``1` and going down. It is recommended to use the `~` operator for indexes from `b` so that both indexes can start from `0` (i.e. `~``@as``(``i32``, ``0``)` is `-``1`).\n\nFor each element of `mask`, if it or the selected value from `a` or `b` is `undefined`, then the resulting element is `undefined`.\n\n`a_len` and `b_len` may differ in length. Out-of-bounds element indexes in `mask` result in compile errors.\n\nIf `a` or `b` is `undefined`, it is equivalent to a vector of all `undefined` with the same length as the other vector. If both vectors are `undefined`, `@shuffle` returns a vector with all elements `undefined`.\n\n`E` must be an [integer](#Integers), [float](#Floats), [pointer](#Pointers), or `bool`. The mask may be any vector length, and its length determines the result length.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"vector @shuffle\" {\n    const a = @Vector(7, u8){ 'o', 'l', 'h', 'e', 'r', 'z', 'w' };\n    const b = @Vector(4, u8){ 'w', 'd', '!', 'x' };\n\n    // To shuffle within a single vector, pass undefined as the second argument.\n    // Notice that we can re-order, duplicate, or omit elements of the input vector\n    const mask1 = @Vector(5, i32){ 2, 3, 1, 1, 0 };\n    const res1: @Vector(5, u8) = @shuffle(u8, a, undefined, mask1);\n    try expect(std.mem.eql(u8, &@as([5]u8, res1), \"hello\"));\n\n    // Combining two vectors\n    const mask2 = @Vector(6, i32){ -1, 0, 4, 1, -2, -3 };\n    const res2: @Vector(6, u8) = @shuffle(u8, a, b, mask2);\n    try expect(std.mem.eql(u8, &@as([6]u8, res2), \"world!\"));\n}\n```\n\ntest_shuffle_builtin.zig\n\n            $ zig test test_shuffle_builtin.zig\n    1/1 test_shuffle_builtin.test.vector @shuffle...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [Vectors](#Vectors)\n\n&nbsp;"
- name: 'Builtin Functions: @sin'
  id: index#sin
  summary: Sine trigonometric function on a floating point number in radians
  description: |-
    ### @sin

    ``` zig
    @sin(value: anytype) @TypeOf(value)
    ```

    Sine trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @sizeOf'
  id: index#sizeOf
  summary: This function returns the number of bytes it takes to store T in memory
  description: |-
    ### @sizeOf

    ``` zig
    @sizeOf(comptime T: type) comptime_int
    ```

    This function returns the number of bytes it takes to store `T` in memory. The result is a target-specific compile time constant.

    This size may contain padding bytes. If there were two consecutive T in memory, the padding would be the offset in bytes between element at index 0 and the element at index 1. For [integer](#Integers), consider whether you want to use `@sizeOf``(T)` or `@typeInfo``(T).Int.bits`.

    This function measures the size at runtime. For types that are disallowed at runtime, such as `comptime_int` and `type`, the result is `0`.

    See also:

    - [@bitSizeOf](#bitSizeOf)
    - [@typeInfo](#typeInfo)

    &nbsp;
- name: 'Builtin Functions: @splat'
  id: index#splat
  summary: Produces a vector where each element is the value scalar
  description: "### @splat\n\n``` zig\n@splat(scalar: anytype) anytype\n```\n\nProduces a vector where each element is the value `scalar`. The return type and thus the length of the vector is inferred.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"vector @splat\" {\n    const scalar: u32 = 5;\n    const result: @Vector(4, u32) = @splat(scalar);\n    try expect(std.mem.eql(u32, &@as([4]u32, result), &[_]u32{ 5, 5, 5, 5 }));\n}\n```\n\ntest_splat_builtin.zig\n\n            $ zig test test_splat_builtin.zig\n    1/1 test_splat_builtin.test.vector @splat...OK\n    All 1 tests passed.\n\n          \n\nShell\n\n`scalar` must be an [integer](#Integers), [bool](#Primitive-Types), [float](#Floats), or [pointer](#Pointers).\n\nSee also:\n\n- [Vectors](#Vectors)\n- [@shuffle](#shuffle)\n\n&nbsp;"
- name: 'Builtin Functions: @sqrt'
  id: index#sqrt
  summary: Performs the square root of a floating point number
  description: |-
    ### @sqrt

    ``` zig
    @sqrt(value: anytype) @TypeOf(value)
    ```

    Performs the square root of a floating point number. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @src'
  id: index#src
  summary: Returns a SourceLocation struct representing the function's name and location in the source code
  description: "### @src\n\n``` zig\n@src() std.builtin.SourceLocation\n```\n\nReturns a `SourceLocation` struct representing the function's name and location in the source code. This must be called in a function.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"@src\" {\n    try doTheTest();\n}\n\nfn doTheTest() !void {\n    const src = @src();\n\n    try expect(src.line == 9);\n    try expect(src.column == 17);\n    try expect(std.mem.endsWith(u8, src.fn_name, \"doTheTest\"));\n    try expect(std.mem.endsWith(u8, src.file, \"test_src_builtin.zig\"));\n}\n```\n\ntest_src_builtin.zig\n\n            $ zig test test_src_builtin.zig\n    1/1 test_src_builtin.test.@src...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Builtin Functions: @subWithOverflow'
  id: index#subWithOverflow
  summary: Performs a - b and returns a tuple with the result and a possible overflow bit
  description: |-
    ### @subWithOverflow

    ``` zig
    @subWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }
    ```

    Performs `a - b` and returns a tuple with the result and a possible overflow bit.
- name: 'Builtin Functions: @tagName'
  id: index#tagName
  summary: Converts an enum value or union value to a string literal representing the name
  description: |-
    ### @tagName

    ``` zig
    @tagName(value: anytype) [:0]const u8
    ```

    Converts an enum value or union value to a string literal representing the name.

    If the enum is non-exhaustive and the tag value does not map to a name, it invokes safety-checked [Undefined Behavior](#Undefined-Behavior).
- name: 'Builtin Functions: @tan'
  id: index#tan
  summary: Tangent trigonometric function on a floating point number in radians
  description: |-
    ### @tan

    ``` zig
    @tan(value: anytype) @TypeOf(value)
    ```

    Tangent trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @This'
  id: index#This
  summary: Returns the innermost struct, enum, or union that this function call is inside
  description: "### @This\n\n``` zig\n@This() type\n```\n\nReturns the innermost struct, enum, or union that this function call is inside. This can be useful for an anonymous struct that needs to refer to itself:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"@This()\" {\n    var items = [_]i32{ 1, 2, 3, 4 };\n    const list = List(i32){ .items = items[0..] };\n    try expect(list.length() == 4);\n}\n\nfn List(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        items: []T,\n\n        fn length(self: Self) usize {\n            return self.items.len;\n        }\n    };\n}\n```\n\ntest_this_builtin.zig\n\n            $ zig test test_this_builtin.zig\n    1/1 test_this_builtin.test.@This()...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nWhen `@This``()` is used at file scope, it returns a reference to the struct that corresponds to the current file."
- name: 'Builtin Functions: @trap'
  id: index#trap
  summary: This function inserts a platform-specific trap/jam instruction which can be used to exit the program abnormally
  description: |-
    ### @trap

    ``` zig
    @trap() noreturn
    ```

    This function inserts a platform-specific trap/jam instruction which can be used to exit the program abnormally. This may be implemented by explicitly emitting an invalid instruction which may cause an illegal instruction exception of some sort. Unlike for `@breakpoint``()`, execution does not continue after this point.

    Outside function scope, this builtin causes a compile error.

    See also:

    - [@breakpoint](#breakpoint)

    &nbsp;
- name: 'Builtin Functions: @trunc'
  id: index#trunc
  summary: Rounds the given floating point number to an integer, towards zero
  description: |-
    ### @trunc

    ``` zig
    @trunc(value: anytype) @TypeOf(value)
    ```

    Rounds the given floating point number to an integer, towards zero. Uses a dedicated hardware instruction when available.

    Supports [Floats](#Floats) and [Vectors](#Vectors) of floats.
- name: 'Builtin Functions: @truncate'
  id: index#truncate
  summary: This function truncates bits from an integer type, resulting in a smaller or same-sized integer type
  description: "### @truncate\n\n``` zig\n@truncate(integer: anytype) anytype\n```\n\nThis function truncates bits from an integer type, resulting in a smaller or same-sized integer type. The return type is the inferred result type.\n\nThis function always truncates the significant bits of the integer, regardless of endianness on the target platform.\n\nCalling `@truncate` on a number out of range of the destination type is well defined and working code:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"integer truncation\" {\n    const a: u16 = 0xabcd;\n    const b: u8 = @truncate(a);\n    try expect(b == 0xcd);\n}\n```\n\ntest_truncate_builtin.zig\n\n            $ zig test test_truncate_builtin.zig\n    1/1 test_truncate_builtin.test.integer truncation...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nUse [@intCast](#intCast) to convert numbers guaranteed to fit the destination type."
- name: 'Builtin Functions: @Type'
  id: index#Type
  summary: This function is the inverse of @typeInfo
  description: |-
    ### @Type

    ``` zig
    @Type(comptime info: std.builtin.Type) type
    ```

    This function is the inverse of [@typeInfo](#typeInfo). It reifies type information into a `type`.

    It is available for the following types:

    - ` ``type`` `
    - ` ``noreturn`` `
    - ` ``void`` `
    - ` ``bool`` `
    - [Integers](#Integers) - The maximum bit count for an integer type is `65535`.
    - [Floats](#Floats)
    - [Pointers](#Pointers)
    - ` ``comptime_int`` `
    - ` ``comptime_float`` `
    - `@TypeOf``(``undefined``)`
    - `@TypeOf``(``null``)`
    - [Arrays](#Arrays)
    - [Optionals](#Optionals)
    - [Error Set Type](#Error-Set-Type)
    - [Error Union Type](#Error-Union-Type)
    - [Vectors](#Vectors)
    - [opaque](#opaque)
    - ` ``anyframe`` `
    - [struct](#struct)
    - [enum](#enum)
    - [Enum Literals](#Enum-Literals)
    - [union](#union)
    - [Functions](#Functions)

    &nbsp;
- name: 'Builtin Functions: @typeInfo'
  id: index#typeInfo
  summary: Provides type reflection
  description: |-
    ### @typeInfo

    ``` zig
    @typeInfo(comptime T: type) std.builtin.Type
    ```

    Provides type reflection.

    Type information of [structs](#struct), [unions](#union), [enums](#enum), and [error sets](#Error-Set-Type) has fields which are guaranteed to be in the same order as appearance in the source file.

    Type information of [structs](#struct), [unions](#union), [enums](#enum), and [opaques](#opaque) has declarations, which are also guaranteed to be in the same order as appearance in the source file.
- name: 'Builtin Functions: @typeName'
  id: index#typeName
  summary: This function returns the string representation of a type, as an array
  description: |-
    ### @typeName

    ``` zig
    @typeName(T: type) *const [N:0]u8
    ```

    This function returns the string representation of a type, as an array. It is equivalent to a string literal of the type name. The returned type name is fully qualified with the parent namespace included as part of the type name with a series of dots.
- name: 'Builtin Functions: @TypeOf'
  id: index#TypeOf
  summary: '@TypeOf is a special builtin function that takes any (nonzero) number of expressions as parameters and returns the type of the result, using Peer Type Resolution'
  description: "### @TypeOf\n\n``` zig\n@TypeOf(...) type\n```\n\n`@TypeOf` is a special builtin function that takes any (nonzero) number of expressions as parameters and returns the type of the result, using [Peer Type Resolution](#Peer-Type-Resolution).\n\nThe expressions are evaluated, however they are guaranteed to have no *runtime* side-effects:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"no runtime side effects\" {\n    var data: i32 = 0;\n    const T = @TypeOf(foo(i32, &data));\n    try comptime expect(T == i32);\n    try expect(data == 0);\n}\n\nfn foo(comptime T: type, ptr: *T) T {\n    ptr.* += 1;\n    return ptr.*;\n}\n```\n\ntest_TypeOf_builtin.zig\n\n            $ zig test test_TypeOf_builtin.zig\n    1/1 test_TypeOf_builtin.test.no runtime side effects...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Builtin Functions: @unionInit'
  id: index#unionInit
  summary: This is the same thing as union initialization syntax, except that the field name is a comptime-known value rather than an identifier token
  description: |-
    ### @unionInit

    ``` zig
    @unionInit(comptime Union: type, comptime active_field_name: []const u8, init_expr) Union
    ```

    This is the same thing as [union](#union) initialization syntax, except that the field name is a [comptime](#comptime)-known value rather than an identifier token.

    `@unionInit` forwards its [result location](#Result-Location-Semantics) to `init_expr`.
- name: 'Builtin Functions: @Vector'
  id: index#Vector
  summary: Creates Vectors
  description: |-
    ### @Vector

    ``` zig
    @Vector(len: comptime_int, Element: type) type
    ```

    Creates [Vectors](#Vectors).
- name: 'Builtin Functions: @volatileCast'
  id: index#volatileCast
  summary: Remove volatile qualifier from a pointer
  description: |-
    ### @volatileCast

    ``` zig
    @volatileCast(value: anytype) DestType
    ```

    Remove `volatile` qualifier from a pointer.
- name: 'Builtin Functions: @wasmMemoryGrow'
  id: index#wasmMemoryGrow
  summary: This function increases the size of the Wasm memory identified by index by delta in units of unsigned number of Wasm pages
  description: "### @wasmMemoryGrow\n\n``` zig\n@wasmMemoryGrow(index: u32, delta: usize) isize\n```\n\nThis function increases the size of the Wasm memory identified by `index` by `delta` in units of unsigned number of Wasm pages. Note that each Wasm page is 64KB in size. On success, returns previous memory size; on failure, if the allocation fails, returns -1.\n\nThis function is a low level intrinsic with no safety mechanisms usually useful for allocator designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use something like `@import``(``\"std\"``).heap.WasmPageAllocator`.\n\n``` zig\nconst std = @import(\"std\");\nconst native_arch = @import(\"builtin\").target.cpu.arch;\nconst expect = std.testing.expect;\n\ntest \"@wasmMemoryGrow\" {\n    if (native_arch != .wasm32) return error.SkipZigTest;\n\n    const prev = @wasmMemorySize(0);\n    try expect(prev == @wasmMemoryGrow(0, 1));\n    try expect(prev + 1 == @wasmMemorySize(0));\n}\n```\n\ntest_wasmMemoryGrow_builtin.zig\n\n            $ zig test test_wasmMemoryGrow_builtin.zig\n    1/1 test_wasmMemoryGrow_builtin.test.@wasmMemoryGrow...SKIP\n    0 passed; 1 skipped; 0 failed.\n\n          \n\nShell\n\nSee also:\n\n- [@wasmMemorySize](#wasmMemorySize)\n\n&nbsp;"
- name: 'Builtin Functions: @wasmMemorySize'
  id: index#wasmMemorySize
  summary: This function returns the size of the Wasm memory identified by index as an unsigned value in units of Wasm pages
  description: |-
    ### @wasmMemorySize

    ``` zig
    @wasmMemorySize(index: u32) usize
    ```

    This function returns the size of the Wasm memory identified by `index` as an unsigned value in units of Wasm pages. Note that each Wasm page is 64KB in size.

    This function is a low level intrinsic with no safety mechanisms usually useful for allocator designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use something like `@import``(``"std"``).heap.WasmPageAllocator`.

    See also:

    - [@wasmMemoryGrow](#wasmMemoryGrow)

    &nbsp;
- name: 'Builtin Functions: @workGroupId'
  id: index#workGroupId
  summary: Returns the index of the work group in the current kernel invocation in dimension dimension
  description: |-
    ### @workGroupId

    ``` zig
    @workGroupId(comptime dimension: u32) u32
    ```

    Returns the index of the work group in the current kernel invocation in dimension `dimension`.
- name: 'Builtin Functions: @workGroupSize'
  id: index#workGroupSize
  summary: Returns the number of work items that a work group has in dimension dimension
  description: |-
    ### @workGroupSize

    ``` zig
    @workGroupSize(comptime dimension: u32) u32
    ```

    Returns the number of work items that a work group has in dimension `dimension`.
- name: 'Builtin Functions: @workItemId'
  id: index#workItemId
  summary: Returns the index of the work item in the work group in dimension dimension
  description: |-
    ### @workItemId

    ``` zig
    @workItemId(comptime dimension: u32) u32
    ```

    Returns the index of the work item in the work group in dimension `dimension`. This function returns values between `0` (inclusive) and `@workGroupSize``(dimension)` (exclusive).
- name: C
  id: index#C
  summary: Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code
  description: |-
    ## C

    Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code.

    There are a few ways that Zig facilitates C interop.
- name: 'C: C Macros'
  id: index#C-Macros
  summary: C Translation makes a best-effort attempt to translate function-like macros into equivalent Zig functions
  description: "### C Macros\n\nC Translation makes a best-effort attempt to translate function-like macros into equivalent Zig functions. Since C macros operate at the level of lexical tokens, not all C macros can be translated to Zig. Macros that cannot be translated will be demoted to `@compileError`. Note that C code which *uses* macros will be translated without any additional issues (since Zig operates on the pre-processed source with macros expanded). It is merely the macros themselves which may not be translatable to Zig.\n\nConsider the following example:\n\n``` zig\n#define MAKELOCAL(NAME, INIT) int NAME = INIT\nint foo(void) {\n   MAKELOCAL(a, 1);\n   MAKELOCAL(b, 2);\n   return a + b;\n}\n```\n\nmacro.c\n\n            $ zig translate-c macro.c > macro.zig\n\n          \n\nShell\n\n``` zig\npub export fn foo() c_int {\n    var a: c_int = 1;\n    _ = &a;\n    var b: c_int = 2;\n    _ = &b;\n    return a + b;\n}\npub const MAKELOCAL = @compileError(\"unable to translate C expr: unexpected token .Equal\"); // macro.c:1:9\n```\n\nmacro.zig\n\nNote that `foo` was translated correctly despite using a non-translatable macro. `MAKELOCAL` was demoted to `@compileError` since it cannot be expressed as a Zig function; this simply means that you cannot directly use `MAKELOCAL` from Zig.\n\nSee also:\n\n- [@compileError](#compileError)\n\n&nbsp;"
- name: 'C: C Pointers'
  id: index#C-Pointers
  summary: This type is to be avoided whenever possible
  description: |-
    ### C Pointers

    This type is to be avoided whenever possible. The only valid reason for using a C pointer is in auto-generated code from translating C code.

    When importing C header files, it is ambiguous whether pointers should be translated as single-item pointers (`*T`) or many-item pointers (`[*]T`). C pointers are a compromise so that Zig code can utilize translated header files directly.

    `[*c]T` - C pointer.

    - Supports all the syntax of the other two pointer types (`*T`) and (`[*]T`).
    - Coerces to other pointer types, as well as [Optional Pointers](#Optional-Pointers). When a C pointer is coerced to a non-optional pointer, safety-checked [Undefined Behavior](#Undefined-Behavior) occurs if the address is 0.
    - Allows address 0. On non-freestanding targets, dereferencing address 0 is safety-checked [Undefined Behavior](#Undefined-Behavior). Optional C pointers introduce another bit to keep track of null, just like `?``usize`. Note that creating an optional C pointer is unnecessary as one can use normal [Optional Pointers](#Optional-Pointers).
    - Supports [Type Coercion](#Type-Coercion) to and from integers.
    - Supports comparison with integers.
    - Does not support Zig-only pointer attributes such as alignment. Use normal [Pointers](#Pointers) please!

    When a C pointer is pointing to a single struct (not an array), dereference the C pointer to access the struct's fields or member data. That syntax looks like this:

    `ptr_to_struct.*.struct_member`

    This is comparable to doing `->` in C.

    When a C pointer is pointing to an array of structs, the syntax reverts to this:

    `ptr_to_struct_array[index].struct_member`
- name: 'C: C Translation Caching'
  id: index#C-Translation-Caching
  summary: The C translation feature (whether used via zig translate-c or @cImport) integrates with the Zig caching system
  description: "### C Translation Caching\n\nThe C translation feature (whether used via zig translate-c or `@cImport`) integrates with the Zig caching system. Subsequent runs with the same source file, target, and cflags will use the cache instead of repeatedly translating the same code.\n\nTo see where the cached files are stored when compiling code that uses `@cImport`, use the --verbose-cimport flag:\n\n``` zig\nconst c = @cImport({\n    @cDefine(\"_NO_CRT_STDIO_INLINE\", \"1\");\n    @cInclude(\"stdio.h\");\n});\npub fn main() void {\n    _ = c;\n}\n```\n\nverbose_cimport_flag.zig\n\n            $ zig build-exe verbose_cimport_flag.zig -lc --verbose-cimport\n    info(compilation): C import source: /home/andy/src/zig/.zig-cache/o/f4e9c68cba40c97888f064d67b031021/cimport.h\n    info(compilation): C import .d file: /home/andy/src/zig/.zig-cache/o/f4e9c68cba40c97888f064d67b031021/cimport.h.d\n    info(compilation): C import output: /home/andy/src/zig/.zig-cache/o/1b63455e1d0d323f51bdc4909717e28b/cimport.zig\n    $ ./verbose_cimport_flag\n\n          \n\nShell\n\n`cimport.h` contains the file to translate (constructed from calls to `@cInclude`, `@cDefine`, and `@cUndef`), `cimport.h.d` is the list of file dependencies, and `cimport.zig` contains the translated output.\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [C Translation CLI](#C-Translation-CLI)\n- [@cInclude](#cInclude)\n- [@cImport](#cImport)\n\n&nbsp;"
- name: 'C: C Translation CLI'
  id: index#C-Translation-CLI
  summary: Zig's C translation capability is available as a CLI tool via zig translate-c
  description: "### C Translation CLI\n\nZig's C translation capability is available as a CLI tool via zig translate-c. It requires a single filename as an argument. It may also take a set of optional flags that are forwarded to clang. It writes the translated file to stdout.\n\n#### [Command line flags](#toc-Command-line-flags)\n\n- -I: Specify a search directory for include files. May be used multiple times. Equivalent to [clang's -I flag](https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-i-dir). The current directory is *not* included by default; use -I. to include it.\n- -D: Define a preprocessor macro. Equivalent to [clang's -D flag](https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-d-macro).\n- -cflags \\[flags\\] --: Pass arbitrary additional [command line flags](https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html) to clang. Note: the list of flags must end with --\n- -target: The [target triple](#Targets) for the translated Zig code. If no target is specified, the current host target will be used.\n\n#### [Using -target and -cflags](#toc-Using--target-and--cflags)\n\n**Important!** When translating C code with zig translate-c, you **must** use the same -target triple that you will use when compiling the translated code. In addition, you **must** ensure that the -cflags used, if any, match the cflags used by code on the target system. Using the incorrect -target or -cflags could result in clang or Zig parse failures, or subtle ABI incompatibilities when linking with C code.\n\n``` zig\nlong FOO = __LONG_MAX__;\n```\n\nvarytarget.h\n\n            $ zig translate-c -target thumb-freestanding-gnueabihf varytarget.h|grep FOO\n    pub export var FOO: c_long = 2147483647;\n    $ zig translate-c -target x86_64-macos-gnu varytarget.h|grep FOO\n    pub export var FOO: c_long = 9223372036854775807;\n\n          \n\nShell\n\n``` zig\nenum FOO { BAR };\nint do_something(enum FOO foo);\n```\n\nvarycflags.h\n\n            $ zig translate-c varycflags.h|grep -B1 do_something\n    pub const enum_FOO = c_uint;\n    pub extern fn do_something(foo: enum_FOO) c_int;\n    $ zig translate-c -cflags -fshort-enums -- varycflags.h|grep -B1 do_something\n    pub const enum_FOO = u8;\n    pub extern fn do_something(foo: enum_FOO) c_int;\n\n          \n\nShell\n\n#### [@cImport vs translate-c](#toc-cImport-vs-translate-c)\n\n`@cImport` and zig translate-c use the same underlying C translation functionality, so on a technical level they are equivalent. In practice, `@cImport` is useful as a way to quickly and easily access numeric constants, typedefs, and record types without needing any extra setup. If you need to pass [cflags](#Using--target-and--cflags) to clang, or if you would like to edit the translated code, it is recommended to use zig translate-c and save the results to a file. Common reasons for editing the generated code include: changing `anytype` parameters in function-like macros to more specific types; changing `[*c]T` pointers to `[*]T` or `*T` pointers for improved type safety; and [enabling or disabling runtime safety](#setRuntimeSafety) within specific functions.\n\nSee also:\n\n- [Targets](#Targets)\n- [C Type Primitives](#C-Type-Primitives)\n- [Pointers](#Pointers)\n- [C Pointers](#C-Pointers)\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cInclude](#cInclude)\n- [@cImport](#cImport)\n- [@setRuntimeSafety](#setRuntimeSafety)\n\n&nbsp;"
- name: 'C: C Type Primitives'
  id: index#C-Type-Primitives
  summary: These have guaranteed C ABI compatibility and can be used like any other type
  description: |-
    ### C Type Primitives

    These have guaranteed C ABI compatibility and can be used like any other type.

    - ` ``c_char`` `
    - ` ``c_short`` `
    - ` ``c_ushort`` `
    - ` ``c_int`` `
    - ` ``c_uint`` `
    - ` ``c_long`` `
    - ` ``c_ulong`` `
    - ` ``c_longlong`` `
    - ` ``c_ulonglong`` `
    - ` ``c_longdouble`` `

    To interop with the C `void` type, use `anyopaque`.

    See also:

    - [Primitive Types](#Primitive-Types)

    &nbsp;
- name: 'C: C Variadic Functions'
  id: index#C-Variadic-Functions
  summary: Zig supports extern variadic functions
  description: "### C Variadic Functions\n\nZig supports extern variadic functions.\n\n``` zig\nconst std = @import(\"std\");\nconst testing = std.testing;\n\npub extern \"c\" fn printf(format: [*:0]const u8, ...) c_int;\n\ntest \"variadic function\" {\n    try testing.expect(printf(\"Hello, world!\\n\") == 14);\n    try testing.expect(@typeInfo(@TypeOf(printf)).Fn.is_var_args);\n}\n```\n\ntest_variadic_function.zig\n\n            $ zig test test_variadic_function.zig -lc\n    1/1 test_variadic_function.test.variadic function...OK\n    All 1 tests passed.\n    Hello, world!\n\n          \n\nShell\n\nVariadic functions can be implemented using [@cVaStart](#cVaStart), [@cVaEnd](#cVaEnd), [@cVaArg](#cVaArg) and [@cVaCopy](#cVaCopy).\n\n``` zig\nconst std = @import(\"std\");\nconst testing = std.testing;\nconst builtin = @import(\"builtin\");\n\nfn add(count: c_int, ...) callconv(.C) c_int {\n    var ap = @cVaStart();\n    defer @cVaEnd(&ap);\n    var i: usize = 0;\n    var sum: c_int = 0;\n    while (i < count) : (i += 1) {\n        sum += @cVaArg(&ap, c_int);\n    }\n    return sum;\n}\n\ntest \"defining a variadic function\" {\n    if (builtin.cpu.arch == .aarch64 and builtin.os.tag != .macos) {\n        // https://github.com/ziglang/zig/issues/14096\n        return error.SkipZigTest;\n    }\n    if (builtin.cpu.arch == .x86_64 and builtin.os.tag == .windows) {\n        // https://github.com/ziglang/zig/issues/16961\n        return error.SkipZigTest;\n    }\n\n    try std.testing.expectEqual(@as(c_int, 0), add(0));\n    try std.testing.expectEqual(@as(c_int, 1), add(1, @as(c_int, 1)));\n    try std.testing.expectEqual(@as(c_int, 3), add(2, @as(c_int, 1), @as(c_int, 2)));\n}\n```\n\ntest_defining_variadic_function.zig\n\n            $ zig test test_defining_variadic_function.zig\n    1/1 test_defining_variadic_function.test.defining a variadic function...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'C: Exporting a C Library'
  id: index#Exporting-a-C-Library
  summary: One of the primary use cases for Zig is exporting a library with the C ABI for other programming languages to call into
  description: "### Exporting a C Library\n\nOne of the primary use cases for Zig is exporting a library with the C ABI for other programming languages to call into. The `export` keyword in front of functions, variables, and types causes them to be part of the library API:\n\n``` zig\nexport fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n```\n\nmathtest.zig\n\nTo make a static library:\n\n            $ zig build-lib mathtest.zig\n\n          \n\nShell\n\nTo make a shared library:\n\n            $ zig build-lib mathtest.zig -dynamic\n\n          \n\nShell\n\nHere is an example with the [Zig Build System](#Zig-Build-System):\n\n``` zig\n// This header is generated by zig from mathtest.zig\n#include \"mathtest.h\"\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    int32_t result = add(42, 1337);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n```\n\ntest.c\n\n``` zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const lib = b.addSharedLibrary(.{\n        .name = \"mathtest\",\n        .root_source_file = b.path(\"mathtest.zig\"),\n        .version = .{ .major = 1, .minor = 0, .patch = 0 },\n    });\n    const exe = b.addExecutable(.{\n        .name = \"test\",\n    });\n    exe.addCSourceFile(.{ .file = b.path(\"test.c\"), .flags = &.{\"-std=c99\"} });\n    exe.linkLibrary(lib);\n    exe.linkSystemLibrary(\"c\");\n\n    b.default_step.dependOn(&exe.step);\n\n    const run_cmd = exe.run();\n\n    const test_step = b.step(\"test\", \"Test the program\");\n    test_step.dependOn(&run_cmd.step);\n}\n```\n\nbuild_c.zig\n\n            $ zig build test\n    1379\n\n          \n\nShell\n\nSee also:\n\n- [export](#export)\n\n&nbsp;"
- name: 'C: Import from C Header File'
  id: index#Import-from-C-Header-File
  summary: The @cImport function takes an expression as a parameter
  description: "### Import from C Header File\n\nThe `@cImport` builtin function can be used to directly import symbols from `.h` files:\n\n``` zig\nconst c = @cImport({\n    // See https://github.com/ziglang/zig/issues/515\n    @cDefine(\"_NO_CRT_STDIO_INLINE\", \"1\");\n    @cInclude(\"stdio.h\");\n});\npub fn main() void {\n    _ = c.printf(\"hello\\n\");\n}\n```\n\ncImport_builtin.zig\n\n            $ zig build-exe cImport_builtin.zig -lc\n    $ ./cImport_builtin\n    hello\n\n          \n\nShell\n\nThe `@cImport` function takes an expression as a parameter. This expression is evaluated at compile-time and is used to control preprocessor directives and include multiple `.h` files:\n\n``` zig\nconst builtin = @import(\"builtin\");\n\nconst c = @cImport({\n    @cDefine(\"NDEBUG\", builtin.mode == .ReleaseFast);\n    if (something) {\n        @cDefine(\"_GNU_SOURCE\", {});\n    }\n    @cInclude(\"stdlib.h\");\n    if (something) {\n        @cUndef(\"_GNU_SOURCE\");\n    }\n    @cInclude(\"soundio.h\");\n});\n```\n\n@cImport Expression\n\nSee also:\n\n- [@cImport](#cImport)\n- [@cInclude](#cInclude)\n- [@cDefine](#cDefine)\n- [@cUndef](#cUndef)\n- [@import](#import)\n\n&nbsp;"
- name: 'C: Mixing Object Files'
  id: index#Mixing-Object-Files
  summary: You can mix Zig object files with any other object files that respect the C ABI
  description: "### Mixing Object Files\n\nYou can mix Zig object files with any other object files that respect the C ABI. Example:\n\n``` zig\nconst base64 = @import(\"std\").base64;\n\nexport fn decode_base_64(\n    dest_ptr: [*]u8,\n    dest_len: usize,\n    source_ptr: [*]const u8,\n    source_len: usize,\n) usize {\n    const src = source_ptr[0..source_len];\n    const dest = dest_ptr[0..dest_len];\n    const base64_decoder = base64.standard.Decoder;\n    const decoded_size = base64_decoder.calcSizeForSlice(src) catch unreachable;\n    base64_decoder.decode(dest[0..decoded_size], src) catch unreachable;\n    return decoded_size;\n}\n```\n\nbase64.zig\n\n``` zig\n// This header is generated by zig from base64.zig\n#include \"base64.h\"\n\n#include <string.h>\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    const char *encoded = \"YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz\";\n    char buf[200];\n\n    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));\n    buf[len] = 0;\n    puts(buf);\n\n    return 0;\n}\n```\n\ntest.c\n\n``` zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const obj = b.addObject(.{\n        .name = \"base64\",\n        .root_source_file = b.path(\"base64.zig\"),\n    });\n\n    const exe = b.addExecutable(.{\n        .name = \"test\",\n    });\n    exe.addCSourceFile(.{ .file = b.path(\"test.c\"), .flags = &.{\"-std=c99\"} });\n    exe.addObject(obj);\n    exe.linkSystemLibrary(\"c\");\n    b.installArtifact(exe);\n}\n```\n\nbuild_object.zig\n\n            $ zig build\n    $ ./zig-out/bin/test\n    all your base are belong to us\n\n          \n\nShell\n\nSee also:\n\n- [Targets](#Targets)\n- [Zig Build System](#Zig-Build-System)\n\n&nbsp;"
- name: 'C: Translation failures'
  id: index#Translation-failures
  summary: Some C constructs cannot be translated to Zig - for example, goto, structs with bitfields, and token-pasting macros
  description: |-
    ### Translation failures

    Some C constructs cannot be translated to Zig - for example, *goto*, structs with bitfields, and token-pasting macros. Zig employs *demotion* to allow translation to continue in the face of non-translatable entities.

    Demotion comes in three varieties - [opaque](#opaque), *extern*, and `@compileError`. C structs and unions that cannot be translated correctly will be translated as `opaque``{}`. Functions that contain opaque types or code constructs that cannot be translated will be demoted to `extern` declarations. Thus, non-translatable types can still be used as pointers, and non-translatable functions can be called so long as the linker is aware of the compiled function.

    `@compileError` is used when top-level definitions (global variables, function prototypes, macros) cannot be translated or demoted. Since Zig uses lazy analysis for top-level declarations, untranslatable entities will not cause a compile error in your code unless you actually use them.

    See also:

    - [opaque](#opaque)
    - [extern](#extern)
    - [@compileError](#compileError)

    &nbsp;
- name: Casting
  id: index#Casting
  summary: A type cast converts a value of one type to another
  description: |-
    ## Casting

    A **type cast** converts a value of one type to another. Zig has [Type Coercion](#Type-Coercion) for conversions that are known to be completely safe and unambiguous, and [Explicit Casts](#Explicit-Casts) for conversions that one would not want to happen on accident. There is also a third kind of type conversion called [Peer Type Resolution](#Peer-Type-Resolution) for the case when a result type must be decided given multiple operand types.
- name: 'Casting: Explicit Casts'
  id: index#Explicit-Casts
  summary: Explicit casts are performed via Builtin Functions
  description: |-
    ### Explicit Casts

    Explicit casts are performed via [Builtin Functions](#Builtin-Functions). Some explicit casts are safe; some are not. Some explicit casts perform language-level assertions; some do not. Some explicit casts are no-ops at runtime; some are not.

    - [@bitCast](#bitCast) - change type but maintain bit representation
    - [@alignCast](#alignCast) - make a pointer have more alignment
    - [@enumFromInt](#enumFromInt) - obtain an enum value based on its integer tag value
    - [@errorFromInt](#errorFromInt) - obtain an error code based on its integer value
    - [@errorCast](#errorCast) - convert to a smaller error set
    - [@floatCast](#floatCast) - convert a larger float to a smaller float
    - [@floatFromInt](#floatFromInt) - convert an integer to a float value
    - [@intCast](#intCast) - convert between integer types
    - [@intFromBool](#intFromBool) - convert true to 1 and false to 0
    - [@intFromEnum](#intFromEnum) - obtain the integer tag value of an enum or tagged union
    - [@intFromError](#intFromError) - obtain the integer value of an error code
    - [@intFromFloat](#intFromFloat) - obtain the integer part of a float value
    - [@intFromPtr](#intFromPtr) - obtain the address of a pointer
    - [@ptrFromInt](#ptrFromInt) - convert an address to a pointer
    - [@ptrCast](#ptrCast) - convert between pointer types
    - [@truncate](#truncate) - convert between integer types, chopping off bits

    &nbsp;
- name: 'Casting: Peer Type Resolution'
  id: index#Peer-Type-Resolution
  summary: This kind of type resolution chooses a type that all peer types can coerce into
  description: "### Peer Type Resolution\n\nPeer Type Resolution occurs in these places:\n\n- [switch](#switch) expressions\n- [if](#if) expressions\n- [while](#while) expressions\n- [for](#for) expressions\n- Multiple break statements in a block\n- Some [binary operations](#Table-of-Operators)\n\nThis kind of type resolution chooses a type that all peer types can coerce into. Here are some examples:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\n\ntest \"peer resolve int widening\" {\n    const a: i8 = 12;\n    const b: i16 = 34;\n    const c = a + b;\n    try expect(c == 46);\n    try expect(@TypeOf(c) == i16);\n}\n\ntest \"peer resolve arrays of different size to const slice\" {\n    try expect(mem.eql(u8, boolToStr(true), \"true\"));\n    try expect(mem.eql(u8, boolToStr(false), \"false\"));\n    try comptime expect(mem.eql(u8, boolToStr(true), \"true\"));\n    try comptime expect(mem.eql(u8, boolToStr(false), \"false\"));\n}\nfn boolToStr(b: bool) []const u8 {\n    return if (b) \"true\" else \"false\";\n}\n\ntest \"peer resolve array and const slice\" {\n    try testPeerResolveArrayConstSlice(true);\n    try comptime testPeerResolveArrayConstSlice(true);\n}\nfn testPeerResolveArrayConstSlice(b: bool) !void {\n    const value1 = if (b) \"aoeu\" else @as([]const u8, \"zz\");\n    const value2 = if (b) @as([]const u8, \"zz\") else \"aoeu\";\n    try expect(mem.eql(u8, value1, \"aoeu\"));\n    try expect(mem.eql(u8, value2, \"zz\"));\n}\n\ntest \"peer type resolution: ?T and T\" {\n    try expect(peerTypeTAndOptionalT(true, false).? == 0);\n    try expect(peerTypeTAndOptionalT(false, false).? == 3);\n    comptime {\n        try expect(peerTypeTAndOptionalT(true, false).? == 0);\n        try expect(peerTypeTAndOptionalT(false, false).? == 3);\n    }\n}\nfn peerTypeTAndOptionalT(c: bool, b: bool) ?usize {\n    if (c) {\n        return if (b) null else @as(usize, 0);\n    }\n\n    return @as(usize, 3);\n}\n\ntest \"peer type resolution: *[0]u8 and []const u8\" {\n    try expect(peerTypeEmptyArrayAndSlice(true, \"hi\").len == 0);\n    try expect(peerTypeEmptyArrayAndSlice(false, \"hi\").len == 1);\n    comptime {\n        try expect(peerTypeEmptyArrayAndSlice(true, \"hi\").len == 0);\n        try expect(peerTypeEmptyArrayAndSlice(false, \"hi\").len == 1);\n    }\n}\nfn peerTypeEmptyArrayAndSlice(a: bool, slice: []const u8) []const u8 {\n    if (a) {\n        return &[_]u8{};\n    }\n\n    return slice[0..1];\n}\ntest \"peer type resolution: *[0]u8, []const u8, and anyerror![]u8\" {\n    {\n        var data = \"hi\".*;\n        const slice = data[0..];\n        try expect((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);\n        try expect((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);\n    }\n    comptime {\n        var data = \"hi\".*;\n        const slice = data[0..];\n        try expect((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);\n        try expect((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);\n    }\n}\nfn peerTypeEmptyArrayAndSliceAndError(a: bool, slice: []u8) anyerror![]u8 {\n    if (a) {\n        return &[_]u8{};\n    }\n\n    return slice[0..1];\n}\n\ntest \"peer type resolution: *const T and ?*T\" {\n    const a: *const usize = @ptrFromInt(0x123456780);\n    const b: ?*usize = @ptrFromInt(0x123456780);\n    try expect(a == b);\n    try expect(b == a);\n}\n\ntest \"peer type resolution: error union switch\" {\n    // The non-error and error cases are only peers if the error case is just a switch expression;\n    // the pattern `if (x) {...} else |err| blk: { switch (err) {...} }` does not consider the\n    // non-error and error case to be peers.\n    var a: error{ A, B, C }!u32 = 0;\n    _ = &a;\n    const b = if (a) |x|\n        x + 3\n    else |err| switch (err) {\n        error.A => 0,\n        error.B => 1,\n        error.C => null,\n    };\n    try expect(@TypeOf(b) == ?u32);\n\n    // The non-error and error cases are only peers if the error case is just a switch expression;\n    // the pattern `x catch |err| blk: { switch (err) {...} }` does not consider the unwrapped `x`\n    // and error case to be peers.\n    const c = a catch |err| switch (err) {\n        error.A => 0,\n        error.B => 1,\n        error.C => null,\n    };\n    try expect(@TypeOf(c) == ?u32);\n}\n```\n\ntest_peer_type_resolution.zig\n\n            $ zig test test_peer_type_resolution.zig\n    1/8 test_peer_type_resolution.test.peer resolve int widening...OK\n    2/8 test_peer_type_resolution.test.peer resolve arrays of different size to const slice...OK\n    3/8 test_peer_type_resolution.test.peer resolve array and const slice...OK\n    4/8 test_peer_type_resolution.test.peer type resolution: ?T and T...OK\n    5/8 test_peer_type_resolution.test.peer type resolution: *[0]u8 and []const u8...OK\n    6/8 test_peer_type_resolution.test.peer type resolution: *[0]u8, []const u8, and anyerror![]u8...OK\n    7/8 test_peer_type_resolution.test.peer type resolution: *const T and ?*T...OK\n    8/8 test_peer_type_resolution.test.peer type resolution: error union switch...OK\n    All 8 tests passed.\n\n          \n\nShell"
- name: 'Casting: Type Coercion'
  id: index#Type-Coercion
  summary: Type coercions are only allowed when it is completely unambiguous how to get from one type to another, and the transformation is guaranteed to be safe
  description: "### Type Coercion\n\nType coercion occurs when one type is expected, but different type is provided:\n\n``` zig\ntest \"type coercion - variable declaration\" {\n    const a: u8 = 1;\n    const b: u16 = a;\n    _ = b;\n}\n\ntest \"type coercion - function call\" {\n    const a: u8 = 1;\n    foo(a);\n}\n\nfn foo(b: u16) void {\n    _ = b;\n}\n\ntest \"type coercion - @as builtin\" {\n    const a: u8 = 1;\n    const b = @as(u16, a);\n    _ = b;\n}\n```\n\ntest_type_coercion.zig\n\n            $ zig test test_type_coercion.zig\n    1/3 test_type_coercion.test.type coercion - variable declaration...OK\n    2/3 test_type_coercion.test.type coercion - function call...OK\n    3/3 test_type_coercion.test.type coercion - @as builtin...OK\n    All 3 tests passed.\n\n          \n\nShell\n\nType coercions are only allowed when it is completely unambiguous how to get from one type to another, and the transformation is guaranteed to be safe. There is one exception, which is [C Pointers](#C-Pointers).\n\n#### [Type Coercion: Stricter Qualification](#toc-Type-Coercion-Stricter-Qualification)\n\nValues which have the same representation at runtime can be cast to increase the strictness of the qualifiers, no matter how nested the qualifiers are:\n\n- `const` - non-const to const is allowed\n- `volatile` - non-volatile to volatile is allowed\n- `align` - bigger to smaller alignment is allowed\n- [error sets](#Error-Set-Type) to supersets is allowed\n\nThese casts are no-ops at runtime since the value representation does not change.\n\n``` zig\ntest \"type coercion - const qualification\" {\n    var a: i32 = 1;\n    const b: *i32 = &a;\n    foo(b);\n}\n\nfn foo(_: *const i32) void {}\n```\n\ntest_no_op_casts.zig\n\n            $ zig test test_no_op_casts.zig\n    1/1 test_no_op_casts.test.type coercion - const qualification...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nIn addition, pointers coerce to const optional pointers:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\n\ntest \"cast *[1][*]const u8 to [*]const ?[*]const u8\" {\n    const window_name = [1][*]const u8{\"window name\"};\n    const x: [*]const ?[*]const u8 = &window_name;\n    try expect(mem.eql(u8, std.mem.sliceTo(@as([*:0]const u8, @ptrCast(x[0].?)), 0), \"window name\"));\n}\n```\n\ntest_pointer_coerce_const_optional.zig\n\n            $ zig test test_pointer_coerce_const_optional.zig\n    1/1 test_pointer_coerce_const_optional.test.cast *[1][*]const u8 to [*]const ?[*]const u8...OK\n    All 1 tests passed.\n\n          \n\nShell\n\n#### [Type Coercion: Integer and Float Widening](#toc-Type-Coercion-Integer-and-Float-Widening)\n\n[Integers](#Integers) coerce to integer types which can represent every value of the old type, and likewise [Floats](#Floats) coerce to float types which can represent every value of the old type.\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\n\ntest \"integer widening\" {\n    const a: u8 = 250;\n    const b: u16 = a;\n    const c: u32 = b;\n    const d: u64 = c;\n    const e: u64 = d;\n    const f: u128 = e;\n    try expect(f == a);\n}\n\ntest \"implicit unsigned integer to signed integer\" {\n    const a: u8 = 250;\n    const b: i16 = a;\n    try expect(b == 250);\n}\n\ntest \"float widening\" {\n    const a: f16 = 12.34;\n    const b: f32 = a;\n    const c: f64 = b;\n    const d: f128 = c;\n    try expect(d == a);\n}\n```\n\ntest_integer_widening.zig\n\n            $ zig test test_integer_widening.zig\n    1/3 test_integer_widening.test.integer widening...OK\n    2/3 test_integer_widening.test.implicit unsigned integer to signed integer...OK\n    3/3 test_integer_widening.test.float widening...OK\n    All 3 tests passed.\n\n          \n\nShell\n\n#### [Type Coercion: Float to Int](#toc-Type-Coercion-Float-to-Int)\n\nA compiler error is appropriate because this ambiguous expression leaves the compiler two choices about the coercion.\n\n- Cast `54.0` to `comptime_int` resulting in `@as``(``comptime_int``, ``10``)`, which is casted to `@as``(``f32``, ``10``)`\n- Cast `5` to `comptime_float` resulting in `@as``(``comptime_float``, ``10.8``)`, which is casted to `@as``(``f32``, ``10.8``)`\n\n``` zig\n// Compile time coercion of float to int\ntest \"implicit cast to comptime_int\" {\n    const f: f32 = 54.0 / 5;\n    _ = f;\n}\n```\n\ntest_ambiguous_coercion.zig\n\n            $ zig test test_ambiguous_coercion.zig\n    doc/langref/test_ambiguous_coercion.zig:3:25: error: ambiguous coercion of division operands 'comptime_float' and 'comptime_int'; non-zero remainder '4'\n        const f: f32 = 54.0 / 5;\n                       ~~~~~^~~\n\n\n          \n\nShell\n\n#### [Type Coercion: Slices, Arrays and Pointers](#toc-Type-Coercion-Slices-Arrays-and-Pointers)\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\n// You can assign constant pointers to arrays to a slice with\n// const modifier on the element type. Useful in particular for\n// String literals.\ntest \"*const [N]T to []const T\" {\n    const x1: []const u8 = \"hello\";\n    const x2: []const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };\n    try expect(std.mem.eql(u8, x1, x2));\n\n    const y: []const f32 = &[2]f32{ 1.2, 3.4 };\n    try expect(y[0] == 1.2);\n}\n\n// Likewise, it works when the destination type is an error union.\ntest \"*const [N]T to E![]const T\" {\n    const x1: anyerror![]const u8 = \"hello\";\n    const x2: anyerror![]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };\n    try expect(std.mem.eql(u8, try x1, try x2));\n\n    const y: anyerror![]const f32 = &[2]f32{ 1.2, 3.4 };\n    try expect((try y)[0] == 1.2);\n}\n\n// Likewise, it works when the destination type is an optional.\ntest \"*const [N]T to ?[]const T\" {\n    const x1: ?[]const u8 = \"hello\";\n    const x2: ?[]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };\n    try expect(std.mem.eql(u8, x1.?, x2.?));\n\n    const y: ?[]const f32 = &[2]f32{ 1.2, 3.4 };\n    try expect(y.?[0] == 1.2);\n}\n\n// In this cast, the array length becomes the slice length.\ntest \"*[N]T to []T\" {\n    var buf: [5]u8 = \"hello\".*;\n    const x: []u8 = &buf;\n    try expect(std.mem.eql(u8, x, \"hello\"));\n\n    const buf2 = [2]f32{ 1.2, 3.4 };\n    const x2: []const f32 = &buf2;\n    try expect(std.mem.eql(f32, x2, &[2]f32{ 1.2, 3.4 }));\n}\n\n// Single-item pointers to arrays can be coerced to many-item pointers.\ntest \"*[N]T to [*]T\" {\n    var buf: [5]u8 = \"hello\".*;\n    const x: [*]u8 = &buf;\n    try expect(x[4] == 'o');\n    // x[5] would be an uncaught out of bounds pointer dereference!\n}\n\n// Likewise, it works when the destination type is an optional.\ntest \"*[N]T to ?[*]T\" {\n    var buf: [5]u8 = \"hello\".*;\n    const x: ?[*]u8 = &buf;\n    try expect(x.?[4] == 'o');\n}\n\n// Single-item pointers can be cast to len-1 single-item arrays.\ntest \"*T to *[1]T\" {\n    var x: i32 = 1234;\n    const y: *[1]i32 = &x;\n    const z: [*]i32 = y;\n    try expect(z[0] == 1234);\n}\n```\n\ntest_coerce_slices_arrays_and_pointers.zig\n\n            $ zig test test_coerce_slices_arrays_and_pointers.zig\n    1/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to []const T...OK\n    2/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to E![]const T...OK\n    3/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to ?[]const T...OK\n    4/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to []T...OK\n    5/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to [*]T...OK\n    6/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to ?[*]T...OK\n    7/7 test_coerce_slices_arrays_and_pointers.test.*T to *[1]T...OK\n    All 7 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [C Pointers](#C-Pointers)\n\n#### [Type Coercion: Optionals](#toc-Type-Coercion-Optionals)\n\nThe payload type of [Optionals](#Optionals), as well as [null](#null), coerce to the optional type.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coerce to optionals\" {\n    const x: ?i32 = 1234;\n    const y: ?i32 = null;\n\n    try expect(x.? == 1234);\n    try expect(y == null);\n}\n```\n\ntest_coerce_optionals.zig\n\n            $ zig test test_coerce_optionals.zig\n    1/1 test_coerce_optionals.test.coerce to optionals...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nOptionals work nested inside the [Error Union Type](#Error-Union-Type), too:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coerce to optionals wrapped in error union\" {\n    const x: anyerror!?i32 = 1234;\n    const y: anyerror!?i32 = null;\n\n    try expect((try x).? == 1234);\n    try expect((try y) == null);\n}\n```\n\ntest_coerce_optional_wrapped_error_union.zig\n\n            $ zig test test_coerce_optional_wrapped_error_union.zig\n    1/1 test_coerce_optional_wrapped_error_union.test.coerce to optionals wrapped in error union...OK\n    All 1 tests passed.\n\n          \n\nShell\n\n#### [Type Coercion: Error Unions](#toc-Type-Coercion-Error-Unions)\n\nThe payload type of an [Error Union Type](#Error-Union-Type) as well as the [Error Set Type](#Error-Set-Type) coerce to the error union type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coercion to error unions\" {\n    const x: anyerror!i32 = 1234;\n    const y: anyerror!i32 = error.Failure;\n\n    try expect((try x) == 1234);\n    try std.testing.expectError(error.Failure, y);\n}\n```\n\ntest_coerce_to_error_union.zig\n\n            $ zig test test_coerce_to_error_union.zig\n    1/1 test_coerce_to_error_union.test.coercion to error unions...OK\n    All 1 tests passed.\n\n          \n\nShell\n\n#### [Type Coercion: Compile-Time Known Numbers](#toc-Type-Coercion-Compile-Time-Known-Numbers)\n\nWhen a number is [comptime](#comptime)-known to be representable in the destination type, it may be coerced:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coercing large integer type to smaller one when value is comptime-known to fit\" {\n    const x: u64 = 255;\n    const y: u8 = x;\n    try expect(y == 255);\n}\n```\n\ntest_coerce_large_to_small.zig\n\n            $ zig test test_coerce_large_to_small.zig\n    1/1 test_coerce_large_to_small.test.coercing large integer type to smaller one when value is comptime-known to fit...OK\n    All 1 tests passed.\n\n          \n\nShell\n\n#### [Type Coercion: Unions and Enums](#toc-Type-Coercion-Unions-and-Enums)\n\nTagged unions can be coerced to enums, and enums can be coerced to tagged unions when they are [comptime](#comptime)-known to be a field of the union that has only one possible value, such as [void](#void):\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst E = enum {\n    one,\n    two,\n    three,\n};\n\nconst U = union(E) {\n    one: i32,\n    two: f32,\n    three,\n};\n\nconst U2 = union(enum) {\n    a: void,\n    b: f32,\n\n    fn tag(self: U2) usize {\n        switch (self) {\n            .a => return 1,\n            .b => return 2,\n        }\n    }\n};\n\ntest \"coercion between unions and enums\" {\n    const u = U{ .two = 12.34 };\n    const e: E = u; // coerce union to enum\n    try expect(e == E.two);\n\n    const three = E.three;\n    const u_2: U = three; // coerce enum to union\n    try expect(u_2 == E.three);\n\n    const u_3: U = .three; // coerce enum literal to union\n    try expect(u_3 == E.three);\n\n    const u_4: U2 = .a; // coerce enum literal to union with inferred enum tag type.\n    try expect(u_4.tag() == 1);\n\n    // The following example is invalid.\n    // error: coercion from enum '@TypeOf(.enum_literal)' to union 'test_coerce_unions_enum.U2' must initialize 'f32' field 'b'\n    //var u_5: U2 = .b;\n    //try expect(u_5.tag() == 2);\n}\n```\n\ntest_coerce_unions_enums.zig\n\n            $ zig test test_coerce_unions_enums.zig\n    1/1 test_coerce_unions_enums.test.coercion between unions and enums...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [union](#union)\n- [enum](#enum)\n\n#### [Type Coercion: undefined](#toc-Type-Coercion-undefined)\n\n[undefined](#undefined) can be coerced to any type.\n\n#### [Type Coercion: Tuples to Arrays](#toc-Type-Coercion-Tuples-to-Arrays)\n\n[Tuples](#Tuples) can be coerced to arrays, if all of the fields have the same type.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Tuple = struct { u8, u8 };\ntest \"coercion from homogenous tuple to array\" {\n    const tuple: Tuple = .{ 5, 6 };\n    const array: [2]u8 = tuple;\n    _ = array;\n}\n```\n\ntest_coerce_tuples_arrays.zig\n\n            $ zig test test_coerce_tuples_arrays.zig\n    1/1 test_coerce_tuples_arrays.test.coercion from homogenous tuple to array...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: Comments
  id: index#Comments
  summary: Zig supports 3 types of comments
  description: "## Comments\n\nZig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation.\n\nThe generated documentation is still experimental, and can be produced with:\n\n            zig test -femit-docs main.zig\n\n          \n\nShell\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    // Comments in Zig start with \"//\" and end at the next LF byte (end of line).\n    // The line below is a comment and won't be executed.\n\n    //print(\"Hello?\", .{});\n\n    print(\"Hello, world!\\n\", .{}); // another comment\n}\n```\n\ncomments.zig\n\n            $ zig build-exe comments.zig\n    $ ./comments\n    Hello, world!\n\n          \n\nShell\n\nThere are no multiline comments in Zig (e.g. like `/* */` comments in C). This allows Zig to have the property that each line of code can be tokenized out of context."
- name: 'Comments: Doc Comments'
  id: index#Doc-Comments
  summary: A doc comment is one that begins with exactly three slashes (i.e
  description: "### Doc Comments\n\nA doc comment is one that begins with exactly three slashes (i.e. `///` but not `////`); multiple doc comments in a row are merged together to form a multiline doc comment. The doc comment documents whatever immediately follows it.\n\n``` zig\n/// A structure for storing a timestamp, with nanosecond precision (this is a\n/// multiline doc comment).\nconst Timestamp = struct {\n    /// The number of seconds since the epoch (this is also a doc comment).\n    seconds: i64, // signed so we can represent pre-1970 (not a doc comment)\n    /// The number of nanoseconds past the second (doc comment again).\n    nanos: u32,\n\n    /// Returns a `Timestamp` struct representing the Unix epoch; that is, the\n    /// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).\n    pub fn unixEpoch() Timestamp {\n        return Timestamp{\n            .seconds = 0,\n            .nanos = 0,\n        };\n    }\n};\n```\n\ndoc_comments.zig\n\nDoc comments are only allowed in certain places; it is a compile error to have a doc comment in an unexpected place, such as in the middle of an expression, or just before a non-doc comment.\n\n``` zig\n/// doc-comment\n//! top-level doc-comment\nconst std = @import(\"std\");\n```\n\ninvalid_doc-comment.zig\n\n            $ zig build-obj invalid_doc-comment.zig\n    doc/langref/invalid_doc-comment.zig:1:16: error: expected type expression, found 'a document comment'\n    /// doc-comment\n                   ^\n\n\n          \n\nShell\n\n``` zig\npub fn main() void {}\n\n/// End of file\n```\n\nunattached_doc-comment.zig\n\n            $ zig build-obj unattached_doc-comment.zig\n    doc/langref/unattached_doc-comment.zig:3:1: error: unattached documentation comment\n    /// End of file\n    ^~~~~~~~~~~~~~~\n\n\n          \n\nShell\n\nDoc comments can be interleaved with normal comments. Currently, when producing the package documentation, normal comments are merged with doc comments."
- name: 'Comments: Top-Level Doc Comments'
  id: index#Top-Level-Doc-Comments
  summary: 'A top-level doc comment is one that begins with two slashes and an exclamation point: //!; it documents the current module'
  description: |-
    ### Top-Level Doc Comments

    A top-level doc comment is one that begins with two slashes and an exclamation point: `//!`; it documents the current module.

    It is a compile error if a top-level doc comment is not placed at the start of a [container](#Containers), before any expressions.

    ``` zig
    //! This module provides functions for retrieving the current date and
    //! time with varying degrees of precision and accuracy. It does not
    //! depend on libc, but will use functions from it if available.

    const S = struct {
        //! Top level comments are allowed inside a container other than a module,
        //! but it is not very useful.  Currently, when producing the package
        //! documentation, these comments are ignored.
    };
    ```

    tldoc_comments.zig
- name: Compile Variables
  id: index#Compile-Variables
  summary: Compile variables are accessible by importing the "builtin" package, which the compiler makes available to every Zig source file
  description: |-
    ## Compile Variables

    Compile variables are accessible by importing the `"builtin"` package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode.

    ``` zig
    const builtin = @import("builtin");
    const separator = if (builtin.os.tag == .windows) '\\' else '/';
    ```

    compile_variables.zig

    Example of what is imported with `@import``(``"builtin"``)`:

    ``` zig
    const std = @import("std");
    /// Zig version. When writing code that supports multiple versions of Zig, prefer
    /// feature detection (i.e. with `@hasDecl` or `@hasField`) over version checks.
    pub const zig_version = std.SemanticVersion.parse(zig_version_string) catch unreachable;
    pub const zig_version_string = "0.13.0";
    pub const zig_backend = std.builtin.CompilerBackend.stage2_llvm;

    pub const output_mode = std.builtin.OutputMode.Exe;
    pub const link_mode = std.builtin.LinkMode.static;
    pub const is_test = false;
    pub const single_threaded = false;
    pub const abi = std.Target.Abi.gnu;
    pub const cpu: std.Target.Cpu = .{
        .arch = .x86_64,
        .model = &std.Target.x86.cpu.znver4,
        .features = std.Target.x86.featureSet(&[_]std.Target.x86.Feature{
            .@"64bit",
            .adx,
            .aes,
            .allow_light_256_bit,
            .avx,
            .avx2,
            .avx512bf16,
            .avx512bitalg,
            .avx512bw,
            .avx512cd,
            .avx512dq,
            .avx512f,
            .avx512ifma,
            .avx512vbmi,
            .avx512vbmi2,
            .avx512vl,
            .avx512vnni,
            .avx512vpopcntdq,
            .bmi,
            .bmi2,
            .branchfusion,
            .clflushopt,
            .clwb,
            .clzero,
            .cmov,
            .crc32,
            .cx16,
            .cx8,
            .evex512,
            .f16c,
            .fast_15bytenop,
            .fast_bextr,
            .fast_lzcnt,
            .fast_movbe,
            .fast_scalar_fsqrt,
            .fast_scalar_shift_masks,
            .fast_variable_perlane_shuffle,
            .fast_vector_fsqrt,
            .fma,
            .fsgsbase,
            .fsrm,
            .fxsr,
            .gfni,
            .invpcid,
            .lzcnt,
            .macrofusion,
            .mmx,
            .movbe,
            .mwaitx,
            .nopl,
            .pclmul,
            .pku,
            .popcnt,
            .prfchw,
            .rdpid,
            .rdpru,
            .rdrnd,
            .rdseed,
            .sahf,
            .sbb_dep_breaking,
            .sha,
            .shstk,
            .slow_shld,
            .sse,
            .sse2,
            .sse3,
            .sse4_1,
            .sse4_2,
            .sse4a,
            .ssse3,
            .vaes,
            .vpclmulqdq,
            .vzeroupper,
            .wbnoinvd,
            .x87,
            .xsave,
            .xsavec,
            .xsaveopt,
            .xsaves,
        }),
    };
    pub const os = std.Target.Os{
        .tag = .linux,
        .version_range = .{ .linux = .{
            .range = .{
                .min = .{
                    .major = 6,
                    .minor = 9,
                    .patch = 2,
                },
                .max = .{
                    .major = 6,
                    .minor = 9,
                    .patch = 2,
                },
            },
            .glibc = .{
                .major = 2,
                .minor = 39,
                .patch = 0,
            },
        }},
    };
    pub const target: std.Target = .{
        .cpu = cpu,
        .os = os,
        .abi = abi,
        .ofmt = object_format,
        .dynamic_linker = std.Target.DynamicLinker.init("/nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/ld-linux-x86-64.so.2"),
    };
    pub const object_format = std.Target.ObjectFormat.elf;
    pub const mode = std.builtin.OptimizeMode.Debug;
    pub const link_libc = false;
    pub const link_libcpp = false;
    pub const have_error_return_tracing = true;
    pub const valgrind_support = true;
    pub const sanitize_thread = false;
    pub const position_independent_code = false;
    pub const position_independent_executable = false;
    pub const strip_debug_info = false;
    pub const code_model = std.builtin.CodeModel.default;
    pub const omit_frame_pointer = false;
    ```

    @import("builtin")

    See also:

    - [Build Mode](#Build-Mode)

    &nbsp;
- name: comptime
  id: index#comptime
  summary: Zig places importance on the concept of whether an expression is known at compile-time
  description: |-
    ## comptime

    Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful.
- name: 'comptime: Case Study: print in Zig'
  id: index#Case-Study-print-in-Zig
  summary: Putting all of this together, let's see how print works in Zig
  description: "### Case Study: print in Zig\n\nPutting all of this together, let's see how `print` works in Zig.\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst a_number: i32 = 1234;\nconst a_string = \"foobar\";\n\npub fn main() void {\n    print(\"here is a string: '{s}' here is a number: {}\\n\", .{ a_string, a_number });\n}\n```\n\nprint.zig\n\n            $ zig build-exe print.zig\n    $ ./print\n    here is a string: 'foobar' here is a number: 1234\n\n          \n\nShell\n\nLet's crack open the implementation of this and see how it works:\n\n``` zig\nconst Writer = struct {\n    /// Calls print and then flushes the buffer.\n    pub fn print(self: *Writer, comptime format: []const u8, args: anytype) anyerror!void {\n        const State = enum {\n            start,\n            open_brace,\n            close_brace,\n        };\n\n        comptime var start_index: usize = 0;\n        comptime var state = State.start;\n        comptime var next_arg: usize = 0;\n\n        inline for (format, 0..) |c, i| {\n            switch (state) {\n                State.start => switch (c) {\n                    '{' => {\n                        if (start_index < i) try self.write(format[start_index..i]);\n                        state = State.open_brace;\n                    },\n                    '}' => {\n                        if (start_index < i) try self.write(format[start_index..i]);\n                        state = State.close_brace;\n                    },\n                    else => {},\n                },\n                State.open_brace => switch (c) {\n                    '{' => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    '}' => {\n                        try self.printValue(args[next_arg]);\n                        next_arg += 1;\n                        state = State.start;\n                        start_index = i + 1;\n                    },\n                    's' => {\n                        continue;\n                    },\n                    else => @compileError(\"Unknown format character: \" ++ [1]u8{c}),\n                },\n                State.close_brace => switch (c) {\n                    '}' => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    else => @compileError(\"Single '}' encountered in format string\"),\n                },\n            }\n        }\n        comptime {\n            if (args.len != next_arg) {\n                @compileError(\"Unused arguments\");\n            }\n            if (state != State.start) {\n                @compileError(\"Incomplete format string: \" ++ format);\n            }\n        }\n        if (start_index < format.len) {\n            try self.write(format[start_index..format.len]);\n        }\n        try self.flush();\n    }\n\n    fn write(self: *Writer, value: []const u8) !void {\n        _ = self;\n        _ = value;\n    }\n    pub fn printValue(self: *Writer, value: anytype) !void {\n        _ = self;\n        _ = value;\n    }\n    fn flush(self: *Writer) !void {\n        _ = self;\n    }\n};\n```\n\npoc_print_fn.zig\n\nThis is a proof of concept implementation; the actual function in the standard library has more formatting capabilities.\n\nNote that this is not hard-coded into the Zig compiler; this is userland code in the standard library.\n\nWhen this function is analyzed from our example code above, Zig partially evaluates the function and emits a function that actually looks like this:\n\n``` zig\npub fn print(self: *Writer, arg0: []const u8, arg1: i32) !void {\n    try self.write(\"here is a string: '\");\n    try self.printValue(arg0);\n    try self.write(\"' here is a number: \");\n    try self.printValue(arg1);\n    try self.write(\"\\n\");\n    try self.flush();\n}\n```\n\nEmitted print Function\n\n`printValue` is a function that takes a parameter of any type, and does different things depending on the type:\n\n``` zig\nconst Writer = struct {\n    pub fn printValue(self: *Writer, value: anytype) !void {\n        switch (@typeInfo(@TypeOf(value))) {\n            .Int => {\n                return self.writeInt(value);\n            },\n            .Float => {\n                return self.writeFloat(value);\n            },\n            .Pointer => {\n                return self.write(value);\n            },\n            else => {\n                @compileError(\"Unable to print type '\" ++ @typeName(@TypeOf(value)) ++ \"'\");\n            },\n        }\n    }\n\n    fn write(self: *Writer, value: []const u8) !void {\n        _ = self;\n        _ = value;\n    }\n    fn writeInt(self: *Writer, value: anytype) !void {\n        _ = self;\n        _ = value;\n    }\n    fn writeFloat(self: *Writer, value: anytype) !void {\n        _ = self;\n        _ = value;\n    }\n};\n```\n\npoc_printValue_fn.zig\n\nAnd now, what happens if we give too many arguments to `print`?\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst a_number: i32 = 1234;\nconst a_string = \"foobar\";\n\ntest \"print too many arguments\" {\n    print(\"here is a string: '{s}' here is a number: {}\\n\", .{\n        a_string,\n        a_number,\n        a_number,\n    });\n}\n```\n\ntest_print_too_many_args.zig\n\n            $ zig test test_print_too_many_args.zig\n    lib/std/fmt.zig:203:18: error: unused argument in 'here is a string: '{s}' here is a number: {}\n                                   '\n                1 => @compileError(\"unused argument in '\" ++ fmt ++ \"'\"),\n                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    referenced by:\n        print__anon_2377: lib/std/io/Writer.zig:24:26\n        print: lib/std/io.zig:324:47\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\n\n          \n\nShell\n\nZig gives programmers the tools needed to protect themselves against their own mistakes.\n\nZig doesn't care whether the format argument is a string literal, only that it is a compile-time known value that can be coerced to a `[]``const`` ``u8`:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst a_number: i32 = 1234;\nconst a_string = \"foobar\";\nconst fmt = \"here is a string: '{s}' here is a number: {}\\n\";\n\npub fn main() void {\n    print(fmt, .{ a_string, a_number });\n}\n```\n\nprint_comptime-known_format.zig\n\n            $ zig build-exe print_comptime-known_format.zig\n    $ ./print_comptime-known_format\n    here is a string: 'foobar' here is a number: 1234\n\n          \n\nShell\n\nThis works fine.\n\nZig does not special case string formatting in the compiler and instead exposes enough power to accomplish this task in userland. It does so without introducing another language on top of Zig, such as a macro language or a preprocessor language. It's Zig all the way down.\n\nSee also:\n\n- [inline while](#inline-while)\n- [inline for](#inline-for)\n\n&nbsp;"
- name: 'comptime: Generic Data Structures'
  id: index#Generic-Data-Structures
  summary: Zig uses comptime capabilities to implement generic data structures without introducing any special-case syntax
  description: |-
    ### Generic Data Structures

    Zig uses comptime capabilities to implement generic data structures without introducing any special-case syntax.

    Here is an example of a generic `List` data structure.

    ``` zig
    fn List(comptime T: type) type {
        return struct {
            items: []T,
            len: usize,
        };
    }

    // The generic List data structure can be instantiated by passing in a type:
    var buffer: [10]i32 = undefined;
    var list = List(i32){
        .items = &buffer,
        .len = 0,
    };
    ```

    generic_data_structure.zig

    That's it. It's a function that returns an anonymous `struct`. For the purposes of error messages and debugging, Zig infers the name `"List(i32)"` from the function name and parameters invoked when creating the anonymous struct.

    To explicitly give a type a name, we assign it to a constant.

    ``` zig
    const Node = struct {
        next: ?*Node,
        name: []const u8,
    };

    var node_a = Node{
        .next = null,
        .name = "Node A",
    };

    var node_b = Node{
        .next = &node_a,
        .name = "Node B",
    };
    ```

    anonymous_struct_name.zig

    In this example, the `Node` struct refers to itself. This works because all top level declarations are order-independent. As long as the compiler can determine the size of the struct, it is free to refer to itself. In this case, `Node` refers to itself as a pointer, which has a well-defined size at compile time, so it works fine.
- name: 'comptime: Introducing the Compile-Time Concept'
  id: index#Introducing-the-Compile-Time-Concept
  summary: Compile-time parameters is how Zig implements generics
  description: "### Introducing the Compile-Time Concept\n\n#### [Compile-Time Parameters](#toc-Compile-Time-Parameters)\n\nCompile-time parameters is how Zig implements generics. It is compile-time duck typing.\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a > b) a else b;\n}\nfn gimmeTheBiggerFloat(a: f32, b: f32) f32 {\n    return max(f32, a, b);\n}\nfn gimmeTheBiggerInteger(a: u64, b: u64) u64 {\n    return max(u64, a, b);\n}\n```\n\ncompile-time_duck_typing.zig\n\nIn Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions, and returned from functions. However, they can only be used in expressions which are known at *compile-time*, which is why the parameter `T` in the above snippet must be marked with `comptime`.\n\nA `comptime` parameter means that:\n\n- At the callsite, the value must be known at compile-time, or it is a compile error.\n- In the function definition, the value is known at compile-time.\n\nFor example, if we were to introduce another function to the above snippet:\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a > b) a else b;\n}\ntest \"try to pass a runtime type\" {\n    foo(false);\n}\nfn foo(condition: bool) void {\n    const result = max(if (condition) f32 else u64, 1234, 5678);\n    _ = result;\n}\n```\n\ntest_unresolved_comptime_value.zig\n\n            $ zig test test_unresolved_comptime_value.zig\n    doc/langref/test_unresolved_comptime_value.zig:8:28: error: unable to resolve comptime value\n        const result = max(if (condition) f32 else u64, 1234, 5678);\n                               ^~~~~~~~~\n    doc/langref/test_unresolved_comptime_value.zig:8:28: note: condition in comptime branch must be comptime-known\n    referenced by:\n        test.try to pass a runtime type: doc/langref/test_unresolved_comptime_value.zig:5:5\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\n\n          \n\nShell\n\nThis is an error because the programmer attempted to pass a value only known at run-time to a function which expects a value known at compile-time.\n\nAnother way to get an error is if we pass a type that violates the type checker when the function is analyzed. This is what it means to have *compile-time duck typing*.\n\nFor example:\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a > b) a else b;\n}\ntest \"try to compare bools\" {\n    _ = max(bool, true, false);\n}\n```\n\ntest_comptime_mismatched_type.zig\n\n            $ zig test test_comptime_mismatched_type.zig\n    doc/langref/test_comptime_mismatched_type.zig:2:18: error: operator > not allowed for type 'bool'\n        return if (a > b) a else b;\n                   ~~^~~\n    referenced by:\n        test.try to compare bools: doc/langref/test_comptime_mismatched_type.zig:5:12\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\n\n          \n\nShell\n\nOn the flip side, inside the function definition with the `comptime` parameter, the value is known at compile-time. This means that we actually could make this work for the bool type if we wanted to:\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    if (T == bool) {\n        return a or b;\n    } else if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\ntest \"try to compare bools\" {\n    try @import(\"std\").testing.expect(max(bool, false, true) == true);\n}\n```\n\ntest_comptime_max_with_bool.zig\n\n            $ zig test test_comptime_max_with_bool.zig\n    1/1 test_comptime_max_with_bool.test.try to compare bools...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nThis works because Zig implicitly inlines `if` expressions when the condition is known at compile-time, and the compiler guarantees that it will skip analysis of the branch not taken.\n\nThis means that the actual function generated for `max` in this situation looks like this:\n\n``` zig\nfn max(a: bool, b: bool) bool {\n    {\n        return a or b;\n    }\n}\n```\n\ncompiler_generated_function.zig\n\nAll the code that dealt with compile-time known values is eliminated and we are left with only the necessary run-time code to accomplish the task.\n\nThis works the same way for `switch` expressions - they are implicitly inlined when the target expression is compile-time known.\n\n#### [Compile-Time Variables](#toc-Compile-Time-Variables)\n\nIn Zig, the programmer can label variables as `comptime`. This guarantees to the compiler that every load and store of the variable is performed at compile-time. Any violation of this results in a compile error.\n\nThis combined with the fact that we can `inline` loops allows us to write a function which is partially evaluated at compile-time and partially at run-time.\n\nFor example:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nconst CmdFn = struct {\n    name: []const u8,\n    func: fn (i32) i32,\n};\n\nconst cmd_fns = [_]CmdFn{\n    CmdFn{ .name = \"one\", .func = one },\n    CmdFn{ .name = \"two\", .func = two },\n    CmdFn{ .name = \"three\", .func = three },\n};\nfn one(value: i32) i32 {\n    return value + 1;\n}\nfn two(value: i32) i32 {\n    return value + 2;\n}\nfn three(value: i32) i32 {\n    return value + 3;\n}\n\nfn performFn(comptime prefix_char: u8, start_value: i32) i32 {\n    var result: i32 = start_value;\n    comptime var i = 0;\n    inline while (i < cmd_fns.len) : (i += 1) {\n        if (cmd_fns[i].name[0] == prefix_char) {\n            result = cmd_fns[i].func(result);\n        }\n    }\n    return result;\n}\n\ntest \"perform fn\" {\n    try expect(performFn('t', 1) == 6);\n    try expect(performFn('o', 0) == 1);\n    try expect(performFn('w', 99) == 99);\n}\n```\n\ntest_comptime_evaluation.zig\n\n            $ zig test test_comptime_evaluation.zig\n    1/1 test_comptime_evaluation.test.perform fn...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nThis example is a bit contrived, because the compile-time evaluation component is unnecessary; this code would work fine if it was all done at run-time. But it does end up generating different code. In this example, the function `performFn` is generated three different times, for the different values of `prefix_char` provided:\n\n``` zig\n// From the line:\n// expect(performFn('t', 1) == 6);\nfn performFn(start_value: i32) i32 {\n    var result: i32 = start_value;\n    result = two(result);\n    result = three(result);\n    return result;\n}\n```\n\nperformFn_1\n\n``` zig\n// From the line:\n// expect(performFn('o', 0) == 1);\nfn performFn(start_value: i32) i32 {\n    var result: i32 = start_value;\n    result = one(result);\n    return result;\n}\n```\n\nperformFn_2\n\n``` zig\n// From the line:\n// expect(performFn('w', 99) == 99);\nfn performFn(start_value: i32) i32 {\n    var result: i32 = start_value;\n    _ = &result;\n    return result;\n}\n```\n\nperformFn_3\n\nNote that this happens even in a debug build. This is not a way to write more optimized code, but it is a way to make sure that what *should* happen at compile-time, *does* happen at compile-time. This catches more errors and allows expressiveness that in other languages requires using macros, generated code, or a preprocessor to accomplish.\n\n#### [Compile-Time Expressions](#toc-Compile-Time-Expressions)\n\nIn Zig, it matters whether a given expression is known at compile-time or run-time. A programmer can use a `comptime` expression to guarantee that the expression will be evaluated at compile-time. If this cannot be accomplished, the compiler will emit an error. For example:\n\n``` zig\nextern fn exit() noreturn;\n\ntest \"foo\" {\n    comptime {\n        exit();\n    }\n}\n```\n\ntest_comptime_call_extern_function.zig\n\n            $ zig test test_comptime_call_extern_function.zig\n    doc/langref/test_comptime_call_extern_function.zig:5:13: error: comptime call of extern function\n            exit();\n            ~~~~^~\n\n\n          \n\nShell\n\nIt doesn't make sense that a program could call `exit()` (or any other external function) at compile-time, so this is a compile error. However, a `comptime` expression does much more than sometimes cause a compile error.\n\nWithin a `comptime` expression:\n\n- All variables are `comptime` variables.\n- All `if`, `while`, `for`, and `switch` expressions are evaluated at compile-time, or emit a compile error if this is not possible.\n- All `return` and `try` expressions are invalid (unless the function itself is called at compile-time).\n- All code with runtime side effects or depending on runtime values emits a compile error.\n- All function calls cause the compiler to interpret the function at compile-time, emitting a compile error if the function tries to do something that has global runtime side effects.\n\nThis means that a programmer can create a function which is called both at compile-time and run-time, with no modification to the function required.\n\nLet's look at an example:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nfn fibonacci(index: u32) u32 {\n    if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    // test fibonacci at run-time\n    try expect(fibonacci(7) == 13);\n\n    // test fibonacci at compile-time\n    try comptime expect(fibonacci(7) == 13);\n}\n```\n\ntest_fibonacci_recursion.zig\n\n            $ zig test test_fibonacci_recursion.zig\n    1/1 test_fibonacci_recursion.test.fibonacci...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nImagine if we had forgotten the base case of the recursive function and tried to run the tests:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nfn fibonacci(index: u32) u32 {\n    //if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    try comptime expect(fibonacci(7) == 13);\n}\n```\n\ntest_fibonacci_comptime_overflow.zig\n\n            $ zig test test_fibonacci_comptime_overflow.zig\n    doc/langref/test_fibonacci_comptime_overflow.zig:5:28: error: overflow of integer type 'u32' with value '-1'\n        return fibonacci(index - 1) + fibonacci(index - 2);\n                         ~~~~~~^~~\n    doc/langref/test_fibonacci_comptime_overflow.zig:5:21: note: called from here (7 times)\n        return fibonacci(index - 1) + fibonacci(index - 2);\n               ~~~~~~~~~^~~~~~~~~~~\n    doc/langref/test_fibonacci_comptime_overflow.zig:9:34: note: called from here\n        try comptime expect(fibonacci(7) == 13);\n                            ~~~~~~~~~^~~\n\n\n          \n\nShell\n\nThe compiler produces an error which is a stack trace from trying to evaluate the function at compile-time.\n\nLuckily, we used an unsigned integer, and so when we tried to subtract 1 from 0, it triggered undefined behavior, which is always a compile error if the compiler knows it happened. But what would have happened if we used a signed integer?\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\n\nfn fibonacci(index: i32) i32 {\n    //if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    try comptime assert(fibonacci(7) == 13);\n}\n```\n\nfibonacci_comptime_infinite_recursion.zig\n\nThe compiler is supposed to notice that evaluating this function at compile-time took more than 1000 branches, and thus emits an error and gives up. If the programmer wants to increase the budget for compile-time computation, they can use a built-in function called [@setEvalBranchQuota](#setEvalBranchQuota) to change the default number 1000 to something else.\n\nHowever, there is a [design flaw in the compiler](https://github.com/ziglang/zig/issues/13724) causing it to stack overflow instead of having the proper behavior here. I'm terribly sorry about that. I hope to get this resolved before the next release.\n\nWhat if we fix the base case, but put the wrong value in the `expect` line?\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\n\nfn fibonacci(index: i32) i32 {\n    if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    try comptime assert(fibonacci(7) == 99999);\n}\n```\n\ntest_fibonacci_comptime_unreachable.zig\n\n            $ zig test test_fibonacci_comptime_unreachable.zig\n    lib/std/debug.zig:412:14: error: reached unreachable code\n        if (!ok) unreachable; // assertion failure\n                 ^~~~~~~~~~~\n    doc/langref/test_fibonacci_comptime_unreachable.zig:9:24: note: called from here\n        try comptime assert(fibonacci(7) == 99999);\n                     ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\n\n          \n\nShell\n\nAt [container](#Containers) level (outside of any function), all expressions are implicitly `comptime` expressions. This means that we can use functions to initialize complex static data. For example:\n\n``` zig\nconst first_25_primes = firstNPrimes(25);\nconst sum_of_first_25_primes = sum(&first_25_primes);\n\nfn firstNPrimes(comptime n: usize) [n]i32 {\n    var prime_list: [n]i32 = undefined;\n    var next_index: usize = 0;\n    var test_number: i32 = 2;\n    while (next_index < prime_list.len) : (test_number += 1) {\n        var test_prime_index: usize = 0;\n        var is_prime = true;\n        while (test_prime_index < next_index) : (test_prime_index += 1) {\n            if (test_number % prime_list[test_prime_index] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            prime_list[next_index] = test_number;\n            next_index += 1;\n        }\n    }\n    return prime_list;\n}\n\nfn sum(numbers: []const i32) i32 {\n    var result: i32 = 0;\n    for (numbers) |x| {\n        result += x;\n    }\n    return result;\n}\n\ntest \"variable values\" {\n    try @import(\"std\").testing.expect(sum_of_first_25_primes == 1060);\n}\n```\n\ntest_container-level_comptime_expressions.zig\n\n            $ zig test test_container-level_comptime_expressions.zig\n    1/1 test_container-level_comptime_expressions.test.variable values...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nWhen we compile this program, Zig generates the constants with the answer pre-computed. Here are the lines from the generated LLVM IR:\n\n``` zig\n@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]\n@1 = internal unnamed_addr constant i32 1060\n```\n\nNote that we did not have to do anything special with the syntax of these functions. For example, we could call the `sum` function as is with a slice of numbers whose length and values were only known at run-time."
- name: defer
  id: index#defer
  summary: Executes an expression unconditionally at scope exit
  description: "## defer\n\nExecutes an expression unconditionally at scope exit.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst print = std.debug.print;\n\nfn deferExample() !usize {\n    var a: usize = 1;\n\n    {\n        defer a = 2;\n        a = 1;\n    }\n    try expect(a == 2);\n\n    a = 5;\n    return a;\n}\n\ntest \"defer basics\" {\n    try expect((try deferExample()) == 5);\n}\n```\n\ntest_defer.zig\n\n            $ zig test test_defer.zig\n    1/1 test_defer.test.defer basics...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nDefer expressions are evaluated in reverse order.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst print = std.debug.print;\n\ntest \"defer unwinding\" {\n    print(\"\\n\", .{});\n\n    defer {\n        print(\"1 \", .{});\n    }\n    defer {\n        print(\"2 \", .{});\n    }\n    if (false) {\n        // defers are not run if they are never executed.\n        defer {\n            print(\"3 \", .{});\n        }\n    }\n}\n```\n\ndefer_unwind.zig\n\n            $ zig test defer_unwind.zig\n    1/1 defer_unwind.test.defer unwinding...\n    2 1 OK\n    All 1 tests passed.\n\n          \n\nShell\n\nInside a defer expression the return statement is not allowed.\n\n``` zig\nfn deferInvalidExample() !void {\n    defer {\n        return error.DeferError;\n    }\n\n    return error.DeferError;\n}\n```\n\ntest_invalid_defer.zig\n\n            $ zig test test_invalid_defer.zig\n    doc/langref/test_invalid_defer.zig:3:9: error: cannot return from defer expression\n            return error.DeferError;\n            ^~~~~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_invalid_defer.zig:2:5: note: defer expression here\n        defer {\n        ^~~~~\n\n\n          \n\nShell\n\nSee also:\n\n- [Errors](#Errors)\n\n&nbsp;"
- name: enum
  id: index#enum
  summary: null
  description: "## enum\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\nconst mem = @import(\"std\").mem;\n\n// Declare an enum.\nconst Type = enum {\n    ok,\n    not_ok,\n};\n\n// Declare a specific enum field.\nconst c = Type.ok;\n\n// If you want access to the ordinal value of an enum, you\n// can specify the tag type.\nconst Value = enum(u2) {\n    zero,\n    one,\n    two,\n};\n// Now you can cast between u2 and Value.\n// The ordinal value starts from 0, counting up by 1 from the previous member.\ntest \"enum ordinal value\" {\n    try expect(@intFromEnum(Value.zero) == 0);\n    try expect(@intFromEnum(Value.one) == 1);\n    try expect(@intFromEnum(Value.two) == 2);\n}\n\n// You can override the ordinal value for an enum.\nconst Value2 = enum(u32) {\n    hundred = 100,\n    thousand = 1000,\n    million = 1000000,\n};\ntest \"set enum ordinal value\" {\n    try expect(@intFromEnum(Value2.hundred) == 100);\n    try expect(@intFromEnum(Value2.thousand) == 1000);\n    try expect(@intFromEnum(Value2.million) == 1000000);\n}\n\n// You can also override only some values.\nconst Value3 = enum(u4) {\n    a,\n    b = 8,\n    c,\n    d = 4,\n    e,\n};\ntest \"enum implicit ordinal values and overridden values\" {\n    try expect(@intFromEnum(Value3.a) == 0);\n    try expect(@intFromEnum(Value3.b) == 8);\n    try expect(@intFromEnum(Value3.c) == 9);\n    try expect(@intFromEnum(Value3.d) == 4);\n    try expect(@intFromEnum(Value3.e) == 5);\n}\n\n// Enums can have methods, the same as structs and unions.\n// Enum methods are not special, they are only namespaced\n// functions that you can call with dot syntax.\nconst Suit = enum {\n    clubs,\n    spades,\n    diamonds,\n    hearts,\n\n    pub fn isClubs(self: Suit) bool {\n        return self == Suit.clubs;\n    }\n};\ntest \"enum method\" {\n    const p = Suit.spades;\n    try expect(!p.isClubs());\n}\n\n// An enum can be switched upon.\nconst Foo = enum {\n    string,\n    number,\n    none,\n};\ntest \"enum switch\" {\n    const p = Foo.number;\n    const what_is_it = switch (p) {\n        Foo.string => \"this is a string\",\n        Foo.number => \"this is a number\",\n        Foo.none => \"this is a none\",\n    };\n    try expect(mem.eql(u8, what_is_it, \"this is a number\"));\n}\n\n// @typeInfo can be used to access the integer tag type of an enum.\nconst Small = enum {\n    one,\n    two,\n    three,\n    four,\n};\ntest \"std.meta.Tag\" {\n    try expect(@typeInfo(Small).Enum.tag_type == u2);\n}\n\n// @typeInfo tells us the field count and the fields names:\ntest \"@typeInfo\" {\n    try expect(@typeInfo(Small).Enum.fields.len == 4);\n    try expect(mem.eql(u8, @typeInfo(Small).Enum.fields[1].name, \"two\"));\n}\n\n// @tagName gives a [:0]const u8 representation of an enum value:\ntest \"@tagName\" {\n    try expect(mem.eql(u8, @tagName(Small.three), \"three\"));\n}\n```\n\ntest_enums.zig\n\n            $ zig test test_enums.zig\n    1/8 test_enums.test.enum ordinal value...OK\n    2/8 test_enums.test.set enum ordinal value...OK\n    3/8 test_enums.test.enum implicit ordinal values and overridden values...OK\n    4/8 test_enums.test.enum method...OK\n    5/8 test_enums.test.enum switch...OK\n    6/8 test_enums.test.std.meta.Tag...OK\n    7/8 test_enums.test.@typeInfo...OK\n    8/8 test_enums.test.@tagName...OK\n    All 8 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [@typeInfo](#typeInfo)\n- [@tagName](#tagName)\n- [@sizeOf](#sizeOf)\n\n&nbsp;"
- name: 'enum: Enum Literals'
  id: index#Enum-Literals
  summary: null
  description: "### Enum Literals\n\nEnum literals allow specifying the name of an enum field without specifying the enum type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Color = enum {\n    auto,\n    off,\n    on,\n};\n\ntest \"enum literals\" {\n    const color1: Color = .auto;\n    const color2 = Color.auto;\n    try expect(color1 == color2);\n}\n\ntest \"switch using enum literals\" {\n    const color = Color.on;\n    const result = switch (color) {\n        .auto => false,\n        .on => true,\n        .off => false,\n    };\n    try expect(result);\n}\n```\n\ntest_enum_literals.zig\n\n            $ zig test test_enum_literals.zig\n    1/2 test_enum_literals.test.enum literals...OK\n    2/2 test_enum_literals.test.switch using enum literals...OK\n    All 2 tests passed.\n\n          \n\nShell"
- name: 'enum: extern enum'
  id: index#extern-enum
  summary: null
  description: "### extern enum\n\nBy default, enums are not guaranteed to be compatible with the C ABI:\n\n``` zig\nconst Foo = enum { a, b, c };\nexport fn entry(foo: Foo) void {\n    _ = foo;\n}\n```\n\nenum_export_error.zig\n\n            $ zig build-obj enum_export_error.zig\n    doc/langref/enum_export_error.zig:2:17: error: parameter of type 'enum_export_error.Foo' not allowed in function with calling convention 'C'\n    export fn entry(foo: Foo) void {\n                    ^~~~~~~~\n    doc/langref/enum_export_error.zig:2:17: note: enum tag type 'u2' is not extern compatible\n    doc/langref/enum_export_error.zig:2:17: note: only integers with 0, 8, 16, 32, 64 and 128 bits are extern compatible\n    doc/langref/enum_export_error.zig:1:13: note: enum declared here\n    const Foo = enum { a, b, c };\n                ^~~~~~~~~~~~~~~~\n\n\n          \n\nShell\n\nFor a C-ABI-compatible enum, provide an explicit tag type to the enum:\n\n``` zig\nconst Foo = enum(c_int) { a, b, c };\nexport fn entry(foo: Foo) void {\n    _ = foo;\n}\n```\n\nenum_export.zig\n\n            $ zig build-obj enum_export.zig\n\n          \n\nShell"
- name: 'enum: Non-exhaustive enum'
  id: index#Non-exhaustive-enum
  summary: A non-exhaustive enum can be created by adding a trailing _ field
  description: "### Non-exhaustive enum\n\nA non-exhaustive enum can be created by adding a trailing `_` field. The enum must specify a tag type and cannot consume every enumeration value.\n\n[@enumFromInt](#enumFromInt) on a non-exhaustive enum involves the safety semantics of [@intCast](#intCast) to the integer tag type, but beyond that always results in a well-defined enum value.\n\nA switch on a non-exhaustive enum can include a `_` prong as an alternative to an `else` prong. With a `_` prong the compiler errors if all the known tag names are not handled by the switch.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Number = enum(u8) {\n    one,\n    two,\n    three,\n    _,\n};\n\ntest \"switch on non-exhaustive enum\" {\n    const number = Number.one;\n    const result = switch (number) {\n        .one => true,\n        .two, .three => false,\n        _ => false,\n    };\n    try expect(result);\n    const is_one = switch (number) {\n        .one => true,\n        else => false,\n    };\n    try expect(is_one);\n}\n```\n\ntest_switch_non-exhaustive.zig\n\n            $ zig test test_switch_non-exhaustive.zig\n    1/1 test_switch_non-exhaustive.test.switch on non-exhaustive enum...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: Errors
  id: index#Errors
  summary: null
  description: '## Errors'
- name: 'Errors: Error Return Traces'
  id: index#Error-Return-Traces
  summary: Error Return Traces show all the points in the code that an error was returned to the calling function
  description: "### Error Return Traces\n\nError Return Traces show all the points in the code that an error was returned to the calling function. This makes it practical to use [try](#try) everywhere and then still be able to know what happened if an error ends up bubbling all the way out of your application.\n\n``` zig\npub fn main() !void {\n    try foo(12);\n}\n\nfn foo(x: i32) !void {\n    if (x >= 5) {\n        try bar();\n    } else {\n        try bang2();\n    }\n}\n\nfn bar() !void {\n    if (baz()) {\n        try quux();\n    } else |err| switch (err) {\n        error.FileNotFound => try hello(),\n    }\n}\n\nfn baz() !void {\n    try bang1();\n}\n\nfn quux() !void {\n    try bang2();\n}\n\nfn hello() !void {\n    try bang2();\n}\n\nfn bang1() !void {\n    return error.FileNotFound;\n}\n\nfn bang2() !void {\n    return error.PermissionDenied;\n}\n```\n\nerror_return_trace.zig\n\n            $ zig build-exe error_return_trace.zig\n    $ ./error_return_trace\n    error: PermissionDenied\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:34:5: 0x1034e08 in bang1 (error_return_trace)\n        return error.FileNotFound;\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:22:5: 0x1034f13 in baz (error_return_trace)\n        try bang1();\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:38:5: 0x1034f38 in bang2 (error_return_trace)\n        return error.PermissionDenied;\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:30:5: 0x1034fa3 in hello (error_return_trace)\n        try bang2();\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:17:31: 0x103505a in bar (error_return_trace)\n            error.FileNotFound => try hello(),\n                                  ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:7:9: 0x1035140 in foo (error_return_trace)\n            try bar();\n            ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:2:5: 0x1035198 in main (error_return_trace)\n        try foo(12);\n        ^\n\n          \n\nShell\n\nLook closely at this example. This is no stack trace.\n\nYou can see that the final error bubbled up was `PermissionDenied`, but the original error that started this whole thing was `FileNotFound`. In the `bar` function, the code handles the original error code, and then returns another one, from the switch statement. Error Return Traces make this clear, whereas a stack trace would look like this:\n\n``` zig\npub fn main() void {\n    foo(12);\n}\n\nfn foo(x: i32) void {\n    if (x >= 5) {\n        bar();\n    } else {\n        bang2();\n    }\n}\n\nfn bar() void {\n    if (baz()) {\n        quux();\n    } else {\n        hello();\n    }\n}\n\nfn baz() bool {\n    return bang1();\n}\n\nfn quux() void {\n    bang2();\n}\n\nfn hello() void {\n    bang2();\n}\n\nfn bang1() bool {\n    return false;\n}\n\nfn bang2() void {\n    @panic(\"PermissionDenied\");\n}\n```\n\nstack_trace.zig\n\n            $ zig build-exe stack_trace.zig\n    $ ./stack_trace\n    thread 3570764 panic: PermissionDenied\n    /home/andy/src/zig/doc/langref/stack_trace.zig:38:5: 0x1039320 in bang2 (stack_trace)\n        @panic(\"PermissionDenied\");\n        ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:30:10: 0x1068bd8 in hello (stack_trace)\n        bang2();\n             ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:17:14: 0x10392fc in bar (stack_trace)\n            hello();\n                 ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:7:12: 0x103721c in foo (stack_trace)\n            bar();\n               ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:2:8: 0x103519d in main (stack_trace)\n        foo(12);\n           ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (stack_trace)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (stack_trace)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell\n\nHere, the stack trace does not explain how the control flow in `bar` got to the `hello()` call. One would have to open a debugger or further instrument the application in order to find out. The error return trace, on the other hand, shows exactly how the error bubbled up.\n\nThis debugging feature makes it easier to iterate quickly on code that robustly handles all error conditions. This means that Zig developers will naturally find themselves writing correct, robust code in order to increase their development pace.\n\nError Return Traces are enabled by default in [Debug](#Debug) and [ReleaseSafe](#ReleaseSafe) builds and disabled by default in [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) builds.\n\nThere are a few ways to activate this error return tracing feature:\n\n- Return an error from main\n- An error makes its way to `catch``unreachable` and you have not overridden the default panic handler\n- Use [errorReturnTrace](#errorReturnTrace) to access the current return trace. You can use `std.debug.dumpStackTrace` to print it. This function returns comptime-known [null](#null) when building without error return tracing support.\n\n#### [Implementation Details](#toc-Implementation-Details)\n\nTo analyze performance cost, there are two cases:\n\n- when no errors are returned\n- when returning errors\n\nFor the case when no errors are returned, the cost is a single memory write operation, only in the first non-failable function in the call graph that calls a failable function, i.e. when a function returning `void` calls a function returning `error`. This is to initialize this struct in the stack memory:\n\n``` zig\npub const StackTrace = struct {\n    index: usize,\n    instruction_addresses: [N]usize,\n};\n```\n\nstack_trace_struct.zig\n\nHere, N is the maximum function call depth as determined by call graph analysis. Recursion is ignored and counts for 2.\n\nA pointer to `StackTrace` is passed as a secret parameter to every function that can return an error, but it's always the first parameter, so it can likely sit in a register and stay there.\n\nThat's it for the path when no errors occur. It's practically free in terms of performance.\n\nWhen generating the code for a function that returns an error, just before the `return` statement (only for the `return` statements that return errors), Zig generates a call to this function:\n\n``` zig\n// marked as \"no-inline\" in LLVM IR\nfn __zig_return_error(stack_trace: *StackTrace) void {\n    stack_trace.instruction_addresses[stack_trace.index] = @returnAddress();\n    stack_trace.index = (stack_trace.index + 1) % N;\n}\n```\n\nzig_return_error_fn.zig\n\nThe cost is 2 math operations plus some memory reads and writes. The memory accessed is constrained and should remain cached for the duration of the error return bubbling.\n\nAs for code size cost, 1 function call before a return statement is no big deal. Even so, I have [a plan](https://github.com/ziglang/zig/issues/690) to make the call to `__zig_return_error` a tail call, which brings the code size cost down to actually zero. What is a return statement in code without error return tracing can become a jump instruction in code with error return tracing."
- name: 'Errors: Error Set Type'
  id: index#Error-Set-Type
  summary: An error set is like an enum
  description: "### Error Set Type\n\nAn error set is like an [enum](#enum). However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value.\n\nThe error set type defaults to a `u16`, though if the maximum number of distinct error values is provided via the --error-limit \\[num\\] command line parameter an integer type with the minimum number of bits required to represent all of the error values will be used.\n\nYou can [coerce](#Type-Coercion) an error from a subset to a superset:\n\n``` zig\nconst std = @import(\"std\");\n\nconst FileOpenError = error{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\nconst AllocationError = error{\n    OutOfMemory,\n};\n\ntest \"coerce subset to superset\" {\n    const err = foo(AllocationError.OutOfMemory);\n    try std.testing.expect(err == FileOpenError.OutOfMemory);\n}\n\nfn foo(err: AllocationError) FileOpenError {\n    return err;\n}\n```\n\ntest_coerce_error_subset_to_superset.zig\n\n            $ zig test test_coerce_error_subset_to_superset.zig\n    1/1 test_coerce_error_subset_to_superset.test.coerce subset to superset...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nBut you cannot [coerce](#Type-Coercion) an error from a superset to a subset:\n\n``` zig\nconst FileOpenError = error{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\nconst AllocationError = error{\n    OutOfMemory,\n};\n\ntest \"coerce superset to subset\" {\n    foo(FileOpenError.OutOfMemory) catch {};\n}\n\nfn foo(err: FileOpenError) AllocationError {\n    return err;\n}\n```\n\ntest_coerce_error_superset_to_subset.zig\n\n            $ zig test test_coerce_error_superset_to_subset.zig\n    doc/langref/test_coerce_error_superset_to_subset.zig:16:12: error: expected type 'error{OutOfMemory}', found 'error{AccessDenied,OutOfMemory,FileNotFound}'\n        return err;\n               ^~~\n    doc/langref/test_coerce_error_superset_to_subset.zig:16:12: note: 'error.AccessDenied' not a member of destination error set\n    doc/langref/test_coerce_error_superset_to_subset.zig:16:12: note: 'error.FileNotFound' not a member of destination error set\n    doc/langref/test_coerce_error_superset_to_subset.zig:15:28: note: function return type declared here\n    fn foo(err: FileOpenError) AllocationError {\n                               ^~~~~~~~~~~~~~~\n    referenced by:\n        test.coerce superset to subset: doc/langref/test_coerce_error_superset_to_subset.zig:12:5\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\n\n          \n\nShell\n\nThere is a shortcut for declaring an error set with only 1 value, and then getting that value:\n\n``` zig\nconst err = error.FileNotFound;\n```\n\nsingle_value_error_set_shortcut.zig\n\nThis is equivalent to:\n\n``` zig\nconst err = (error{FileNotFound}).FileNotFound;\n```\n\nsingle_value_error_set.zig\n\nThis becomes useful when using [Inferred Error Sets](#Inferred-Error-Sets).\n\n#### [The Global Error Set](#toc-The-Global-Error-Set)\n\n`anyerror` refers to the global error set. This is the error set that contains all errors in the entire compilation unit. It is a superset of all other error sets and a subset of none of them.\n\nYou can [coerce](#Type-Coercion) any error set to the global one, and you can explicitly cast an error of the global error set to a non-global one. This inserts a language-level assert to make sure the error value is in fact in the destination error set.\n\nThe global error set should generally be avoided because it prevents the compiler from knowing what errors are possible at compile-time. Knowing the error set at compile-time is better for generated documentation and helpful error messages, such as forgetting a possible error value in a [switch](#switch)."
- name: 'Errors: Error Union Type'
  id: index#Error-Union-Type
  summary: An error set type and normal type can be combined with the ! binary operator to form an error union type
  description: "### Error Union Type\n\nAn error set type and normal type can be combined with the `!` binary operator to form an error union type. You are likely to use an error union type more often than an error set type by itself.\n\nHere is a function to parse a string into a 64-bit integer:\n\n``` zig\nconst std = @import(\"std\");\nconst maxInt = std.math.maxInt;\n\npub fn parseU64(buf: []const u8, radix: u8) !u64 {\n    var x: u64 = 0;\n\n    for (buf) |c| {\n        const digit = charToDigit(c);\n\n        if (digit >= radix) {\n            return error.InvalidChar;\n        }\n\n        // x *= radix\n        var ov = @mulWithOverflow(x, radix);\n        if (ov[1] != 0) return error.OverFlow;\n\n        // x += digit\n        ov = @addWithOverflow(ov[0], digit);\n        if (ov[1] != 0) return error.OverFlow;\n        x = ov[0];\n    }\n\n    return x;\n}\n\nfn charToDigit(c: u8) u8 {\n    return switch (c) {\n        '0'...'9' => c - '0',\n        'A'...'Z' => c - 'A' + 10,\n        'a'...'z' => c - 'a' + 10,\n        else => maxInt(u8),\n    };\n}\n\ntest \"parse u64\" {\n    const result = try parseU64(\"1234\", 10);\n    try std.testing.expect(result == 1234);\n}\n```\n\nerror_union_parsing_u64.zig\n\n            $ zig test error_union_parsing_u64.zig\n    1/1 error_union_parsing_u64.test.parse u64...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nNotice the return type is `!``u64`. This means that the function either returns an unsigned 64 bit integer, or an error. We left off the error set to the left of the `!`, so the error set is inferred.\n\nWithin the function definition, you can see some return statements that return an error, and at the bottom a return statement that returns a `u64`. Both types [coerce](#Type-Coercion) to `anyerror``!``u64`.\n\nWhat it looks like to use this function varies depending on what you're trying to do. One of the following:\n\n- You want to provide a default value if it returned an error.\n- If it returned an error then you want to return the same error.\n- You know with complete certainty it will not return an error, so want to unconditionally unwrap it.\n- You want to take a different action for each possible error.\n\n#### [catch](#toc-catch)\n\nIf you want to provide a default value, you can use the `catch` binary operator:\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) void {\n    const number = parseU64(str, 10) catch 13;\n    _ = number; // ...\n}\n```\n\ncatch.zig\n\nIn this code, `number` will be equal to the successfully parsed string, or a default value of 13. The type of the right hand side of the binary `catch` operator must match the unwrapped error union type, or be of type `noreturn`.\n\nIf you want to provide a default value with `catch` after performing some logic, you can combine `catch` with named [Blocks](#Blocks):\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) void {\n    const number = parseU64(str, 10) catch blk: {\n        // do things\n        break :blk 13;\n    };\n    _ = number; // number is now initialized\n}\n```\n\nhandle_error_with_catch_block.zig.zig\n\n#### [try](#toc-try)\n\nLet's say you wanted to return the error if you got one, otherwise continue with the function logic:\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) !void {\n    const number = parseU64(str, 10) catch |err| return err;\n    _ = number; // ...\n}\n```\n\ncatch_err_return.zig\n\nThere is a shortcut for this. The `try` expression:\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) !void {\n    const number = try parseU64(str, 10);\n    _ = number; // ...\n}\n```\n\ntry.zig\n\n`try` evaluates an error union expression. If it is an error, it returns from the current function with the same error. Otherwise, the expression results in the unwrapped value.\n\nMaybe you know with complete certainty that an expression will never be an error. In this case you can do this:\n\n`const`` number = parseU64(``\"1234\"``, ``10``) ``catch`` ``unreachable``;`\n\nHere we know for sure that \"1234\" will parse successfully. So we put the `unreachable` value on the right hand side. `unreachable` generates a panic in [Debug](#Debug) and [ReleaseSafe](#ReleaseSafe) modes and undefined behavior in [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) modes. So, while we're debugging the application, if there *was* a surprise error here, the application would crash appropriately.\n\nYou may want to take a different action for every situation. For that, we combine the [if](#if) and [switch](#switch) expression:\n\n``` zig\nfn doAThing(str: []u8) void {\n    if (parseU64(str, 10)) |number| {\n        doSomethingWithNumber(number);\n    } else |err| switch (err) {\n        error.Overflow => {\n            // handle overflow...\n        },\n        // we promise that InvalidChar won't happen (or crash in debug mode if it does)\n        error.InvalidChar => unreachable,\n    }\n}\n```\n\nhandle_all_error_scenarios.zig\n\nFinally, you may want to handle only some errors. For that, you can capture the unhandled errors in the `else` case, which now contains a narrower error set:\n\n``` zig\nfn doAnotherThing(str: []u8) error{InvalidChar}!void {\n    if (parseU64(str, 10)) |number| {\n        doSomethingWithNumber(number);\n    } else |err| switch (err) {\n        error.Overflow => {\n            // handle overflow...\n        },\n        else => |leftover_err| return leftover_err,\n    }\n}\n```\n\nhandle_some_error_scenarios.zig\n\nYou must use the variable capture syntax. If you don't need the variable, you can capture with `_` and avoid the `switch`.\n\n``` zig\nfn doADifferentThing(str: []u8) void {\n    if (parseU64(str, 10)) |number| {\n        doSomethingWithNumber(number);\n    } else |_| {\n        // do as you'd like\n    }\n}\n```\n\nhandle_no_error_scenarios.zig\n\n#### [errdefer](#toc-errdefer)\n\nThe other component to error handling is defer statements. In addition to an unconditional [defer](#defer), Zig has `errdefer`, which evaluates the deferred expression on block exit path if and only if the function returned with an error from the block.\n\nExample:\n\n``` zig\nfn createFoo(param: i32) !Foo {\n    const foo = try tryToAllocateFoo();\n    // now we have allocated foo. we need to free it if the function fails.\n    // but we want to return it if the function succeeds.\n    errdefer deallocateFoo(foo);\n\n    const tmp_buf = allocateTmpBuffer() orelse return error.OutOfMemory;\n    // tmp_buf is truly a temporary resource, and we for sure want to clean it up\n    // before this block leaves scope\n    defer deallocateTmpBuffer(tmp_buf);\n\n    if (param > 1337) return error.InvalidParam;\n\n    // here the errdefer will not run since we're returning success from the function.\n    // but the defer will run!\n    return foo;\n}\n```\n\nerrdefer_example.zig\n\nThe neat thing about this is that you get robust error handling without the verbosity and cognitive overhead of trying to make sure every exit path is covered. The deallocation code is always directly following the allocation code.\n\n#### [Common errdefer Slip-Ups](#toc-Common-errdefer-Slip-Ups)\n\nIt should be noted that `errdefer` statements only last until the end of the block they are written in, and therefore are not run if an error is returned outside of that block:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct {\n    data: u32,\n};\n\nfn tryToAllocateFoo(allocator: Allocator) !*Foo {\n    return allocator.create(Foo);\n}\n\nfn deallocateFoo(allocator: Allocator, foo: *Foo) void {\n    allocator.destroy(foo);\n}\n\nfn getFooData() !u32 {\n    return 666;\n}\n\nfn createFoo(allocator: Allocator, param: i32) !*Foo {\n    const foo = getFoo: {\n        var foo = try tryToAllocateFoo(allocator);\n        errdefer deallocateFoo(allocator, foo); // Only lasts until the end of getFoo\n\n        // Calls deallocateFoo on error\n        foo.data = try getFooData();\n\n        break :getFoo foo;\n    };\n\n    // Outside of the scope of the errdefer, so\n    // deallocateFoo will not be called here\n    if (param > 1337) return error.InvalidParam;\n\n    return foo;\n}\n\ntest \"createFoo\" {\n    try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));\n}\n```\n\ntest_errdefer_slip_ups.zig\n\n            $ zig test test_errdefer_slip_ups.zig\n    1/1 test_errdefer_slip_ups.test.createFoo...OK\n    [gpa] (err): memory address 0x7f11f521a000 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:9:28: 0x103d3cf in tryToAllocateFoo (test)\n        return allocator.create(Foo);\n                               ^\n    /home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:22:39: 0x103d5e5 in createFoo (test)\n            var foo = try tryToAllocateFoo(allocator);\n                                          ^\n    /home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:39:62: 0x103d82d in test.createFoo (test)\n        try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));\n                                                                 ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104d2a0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x104340b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103f9f9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103f561 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    All 1 tests passed.\n    1 errors were logged.\n    1 tests leaked memory.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/58c079cb550addefaa354f72d736afd7/test\n\n          \n\nShell\n\nTo ensure that `deallocateFoo` is properly called when returning an error, you must add an `errdefer` outside of the block:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct {\n    data: u32,\n};\n\nfn tryToAllocateFoo(allocator: Allocator) !*Foo {\n    return allocator.create(Foo);\n}\n\nfn deallocateFoo(allocator: Allocator, foo: *Foo) void {\n    allocator.destroy(foo);\n}\n\nfn getFooData() !u32 {\n    return 666;\n}\n\nfn createFoo(allocator: Allocator, param: i32) !*Foo {\n    const foo = getFoo: {\n        var foo = try tryToAllocateFoo(allocator);\n        errdefer deallocateFoo(allocator, foo);\n\n        foo.data = try getFooData();\n\n        break :getFoo foo;\n    };\n    // This lasts for the rest of the function\n    errdefer deallocateFoo(allocator, foo);\n\n    // Error is now properly handled by errdefer\n    if (param > 1337) return error.InvalidParam;\n\n    return foo;\n}\n\ntest \"createFoo\" {\n    try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));\n}\n```\n\ntest_errdefer_block.zig\n\n            $ zig test test_errdefer_block.zig\n    1/1 test_errdefer_block.test.createFoo...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nThe fact that errdefers only last for the block they are declared in is especially important when using loops:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct { data: *u32 };\n\nfn getData() !u32 {\n    return 666;\n}\n\nfn genFoos(allocator: Allocator, num: usize) ![]Foo {\n    const foos = try allocator.alloc(Foo, num);\n    errdefer allocator.free(foos);\n\n    for (foos, 0..) |*foo, i| {\n        foo.data = try allocator.create(u32);\n        // This errdefer does not last between iterations\n        errdefer allocator.destroy(foo.data);\n\n        // The data for the first 3 foos will be leaked\n        if (i >= 3) return error.TooManyFoos;\n\n        foo.data.* = try getData();\n    }\n\n    return foos;\n}\n\ntest \"genFoos\" {\n    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n}\n```\n\ntest_errdefer_loop_leak.zig\n\n            $ zig test test_errdefer_loop_leak.zig\n    1/1 test_errdefer_loop_leak.test.genFoos...OK\n    [gpa] (err): memory address 0x7f57c7578000 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)\n            foo.data = try allocator.create(u32);\n                                           ^\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)\n        try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n                                                              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    [gpa] (err): memory address 0x7f57c7578004 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)\n            foo.data = try allocator.create(u32);\n                                           ^\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)\n        try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n                                                              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    [gpa] (err): memory address 0x7f57c7578008 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)\n            foo.data = try allocator.create(u32);\n                                           ^\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)\n        try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n                                                              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    All 1 tests passed.\n    3 errors were logged.\n    1 tests leaked memory.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/29fcda275b7c426418534b679850fa2e/test\n\n          \n\nShell\n\nSpecial care must be taken with code that allocates in a loop to make sure that no memory is leaked when returning an error:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct { data: *u32 };\n\nfn getData() !u32 {\n    return 666;\n}\n\nfn genFoos(allocator: Allocator, num: usize) ![]Foo {\n    const foos = try allocator.alloc(Foo, num);\n    errdefer allocator.free(foos);\n\n    // Used to track how many foos have been initialized\n    // (including their data being allocated)\n    var num_allocated: usize = 0;\n    errdefer for (foos[0..num_allocated]) |foo| {\n        allocator.destroy(foo.data);\n    };\n    for (foos, 0..) |*foo, i| {\n        foo.data = try allocator.create(u32);\n        num_allocated += 1;\n\n        if (i >= 3) return error.TooManyFoos;\n\n        foo.data.* = try getData();\n    }\n\n    return foos;\n}\n\ntest \"genFoos\" {\n    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n}\n```\n\ntest_errdefer_loop.zig\n\n            $ zig test test_errdefer_loop.zig\n    1/1 test_errdefer_loop.test.genFoos...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nA couple of other tidbits about error handling:\n\n- These primitives give enough expressiveness that it's completely practical to have failing to check for an error be a compile error. If you really want to ignore the error, you can add `catch``unreachable` and get the added benefit of crashing in Debug and ReleaseSafe modes if your assumption was wrong.\n- Since Zig understands error types, it can pre-weight branches in favor of errors not occurring. Just a small optimization benefit that is not available in other languages.\n\nSee also:\n\n- [defer](#defer)\n- [if](#if)\n- [switch](#switch)\n\nAn error union is created with the `!` binary operator. You can use compile-time reflection to access the child type of an error union:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"error union\" {\n    var foo: anyerror!i32 = undefined;\n\n    // Coerce from child type of an error union:\n    foo = 1234;\n\n    // Coerce from an error set:\n    foo = error.SomeError;\n\n    // Use compile-time reflection to access the payload type of an error union:\n    try comptime expect(@typeInfo(@TypeOf(foo)).ErrorUnion.payload == i32);\n\n    // Use compile-time reflection to access the error set type of an error union:\n    try comptime expect(@typeInfo(@TypeOf(foo)).ErrorUnion.error_set == anyerror);\n}\n```\n\ntest_error_union.zig\n\n            $ zig test test_error_union.zig\n    1/1 test_error_union.test.error union...OK\n    All 1 tests passed.\n\n          \n\nShell\n\n#### [Merging Error Sets](#toc-Merging-Error-Sets)\n\nUse the `||` operator to merge two error sets together. The resulting error set contains the errors of both error sets. Doc comments from the left-hand side override doc comments from the right-hand side. In this example, the doc comments for `C.PathNotFound` is `A doc comment`.\n\nThis is especially useful for functions which return different error sets depending on [comptime](#comptime) branches. For example, the Zig standard library uses `LinuxFileOpenError || WindowsFileOpenError` for the error set of opening files.\n\n``` zig\nconst A = error{\n    NotDir,\n\n    /// A doc comment\n    PathNotFound,\n};\nconst B = error{\n    OutOfMemory,\n\n    /// B doc comment\n    PathNotFound,\n};\n\nconst C = A || B;\n\nfn foo() C!void {\n    return error.NotDir;\n}\n\ntest \"merge error sets\" {\n    if (foo()) {\n        @panic(\"unexpected\");\n    } else |err| switch (err) {\n        error.OutOfMemory => @panic(\"unexpected\"),\n        error.PathNotFound => @panic(\"unexpected\"),\n        error.NotDir => {},\n    }\n}\n```\n\ntest_merging_error_sets.zig\n\n            $ zig test test_merging_error_sets.zig\n    1/1 test_merging_error_sets.test.merge error sets...OK\n    All 1 tests passed.\n\n          \n\nShell\n\n#### [Inferred Error Sets](#toc-Inferred-Error-Sets)\n\nBecause many functions in Zig return a possible error, Zig supports inferring the error set. To infer the error set for a function, prepend the `!` operator to the function’s return type, like `!T`:\n\n``` zig\n// With an inferred error set\npub fn add_inferred(comptime T: type, a: T, b: T) !T {\n    const ov = @addWithOverflow(a, b);\n    if (ov[1] != 0) return error.Overflow;\n    return ov[0];\n}\n\n// With an explicit error set\npub fn add_explicit(comptime T: type, a: T, b: T) Error!T {\n    const ov = @addWithOverflow(a, b);\n    if (ov[1] != 0) return error.Overflow;\n    return ov[0];\n}\n\nconst Error = error{\n    Overflow,\n};\n\nconst std = @import(\"std\");\n\ntest \"inferred error set\" {\n    if (add_inferred(u8, 255, 1)) |_| unreachable else |err| switch (err) {\n        error.Overflow => {}, // ok\n    }\n}\n```\n\ntest_inferred_error_sets.zig\n\n            $ zig test test_inferred_error_sets.zig\n    1/1 test_inferred_error_sets.test.inferred error set...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nWhen a function has an inferred error set, that function becomes generic and thus it becomes trickier to do certain things with it, such as obtain a function pointer, or have an error set that is consistent across different build targets. Additionally, inferred error sets are incompatible with recursion.\n\nIn these situations, it is recommended to use an explicit error set. You can generally start with an empty error set and let compile errors guide you toward completing the set.\n\nThese limitations may be overcome in a future version of Zig."
- name: Floats
  id: index#Floats
  summary: null
  description: |-
    ## Floats

    Zig has the following floating point types:

    - `f16` - IEEE-754-2008 binary16
    - `f32` - IEEE-754-2008 binary32
    - `f64` - IEEE-754-2008 binary64
    - `f80` - IEEE-754-2008 80-bit extended precision
    - `f128` - IEEE-754-2008 binary128
    - `c_longdouble` - matches `long double` for the target C ABI

    &nbsp;
- name: 'Floats: Float Literals'
  id: index#Float-Literals
  summary: Float literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128
  description: |-
    ### Float Literals

    Float literals have type `comptime_float` which is guaranteed to have the same precision and operations of the largest other floating point type, which is `f128`.

    Float literals [coerce](#Type-Coercion) to any floating point type, and to any [integer](#Integers) type when there is no fractional component.

    ``` zig
    const floating_point = 123.0E+77;
    const another_float = 123.0;
    const yet_another = 123.0e+77;

    const hex_floating_point = 0x103.70p-5;
    const another_hex_float = 0x103.70;
    const yet_another_hex_float = 0x103.70P-5;

    // underscores may be placed between two digits as a visual separator
    const lightspeed = 299_792_458.000_000;
    const nanosecond = 0.000_000_001;
    const more_hex = 0x1234_5678.9ABC_CDEFp-10;
    ```

    float_literals.zig

    There is no syntax for NaN, infinity, or negative infinity. For these special values, one must use the standard library:

    ``` zig
    const std = @import("std");

    const inf = std.math.inf(f32);
    const negative_inf = -std.math.inf(f64);
    const nan = std.math.nan(f128);
    ```

    float_special_values.zig
- name: 'Floats: Floating Point Operations'
  id: index#Floating-Point-Operations
  summary: For this test we have to separate code into two object files - otherwise the optimizer figures out all the values at compile-time, which operates in strict mode
  description: "### Floating Point Operations\n\nBy default floating point operations use `Strict` mode, but you can switch to `Optimized` mode on a per-block basis:\n\n``` zig\nconst std = @import(\"std\");\nconst big = @as(f64, 1 << 40);\n\nexport fn foo_strict(x: f64) f64 {\n    return x + big - big;\n}\n\nexport fn foo_optimized(x: f64) f64 {\n    @setFloatMode(.optimized);\n    return x + big - big;\n}\n```\n\nfloat_mode_obj.zig\n\n            $ zig build-obj float_mode_obj.zig -O ReleaseFast\n\n          \n\nShell\n\nFor this test we have to separate code into two object files - otherwise the optimizer figures out all the values at compile-time, which operates in strict mode.\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nextern fn foo_strict(x: f64) f64;\nextern fn foo_optimized(x: f64) f64;\n\npub fn main() void {\n    const x = 0.001;\n    print(\"optimized = {}\\n\", .{foo_optimized(x)});\n    print(\"strict = {}\\n\", .{foo_strict(x)});\n}\n```\n\nfloat_mode_exe.zig\n\nSee also:\n\n- [@setFloatMode](#setFloatMode)\n- [Division by Zero](#Division-by-Zero)\n\n&nbsp;"
- name: for
  id: index#for
  summary: null
  description: "## for\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"for basics\" {\n    const items = [_]i32{ 4, 5, 3, 4, 0 };\n    var sum: i32 = 0;\n\n    // For loops iterate over slices and arrays.\n    for (items) |value| {\n        // Break and continue are supported.\n        if (value == 0) {\n            continue;\n        }\n        sum += value;\n    }\n    try expect(sum == 16);\n\n    // To iterate over a portion of a slice, reslice.\n    for (items[0..1]) |value| {\n        sum += value;\n    }\n    try expect(sum == 20);\n\n    // To access the index of iteration, specify a second condition as well\n    // as a second capture value.\n    var sum2: i32 = 0;\n    for (items, 0..) |_, i| {\n        try expect(@TypeOf(i) == usize);\n        sum2 += @as(i32, @intCast(i));\n    }\n    try expect(sum2 == 10);\n\n    // To iterate over consecutive integers, use the range syntax.\n    // Unbounded range is always a compile error.\n    var sum3: usize = 0;\n    for (0..5) |i| {\n        sum3 += i;\n    }\n    try expect(sum3 == 10);\n}\n\ntest \"multi object for\" {\n    const items = [_]usize{ 1, 2, 3 };\n    const items2 = [_]usize{ 4, 5, 6 };\n    var count: usize = 0;\n\n    // Iterate over multiple objects.\n    // All lengths must be equal at the start of the loop, otherwise detectable\n    // illegal behavior occurs.\n    for (items, items2) |i, j| {\n        count += i + j;\n    }\n\n    try expect(count == 21);\n}\n\ntest \"for reference\" {\n    var items = [_]i32{ 3, 4, 2 };\n\n    // Iterate over the slice by reference by\n    // specifying that the capture value is a pointer.\n    for (&items) |*value| {\n        value.* += 1;\n    }\n\n    try expect(items[0] == 4);\n    try expect(items[1] == 5);\n    try expect(items[2] == 3);\n}\n\ntest \"for else\" {\n    // For allows an else attached to it, the same as a while loop.\n    const items = [_]?i32{ 3, 4, null, 5 };\n\n    // For loops can also be used as expressions.\n    // Similar to while loops, when you break from a for loop, the else branch is not evaluated.\n    var sum: i32 = 0;\n    const result = for (items) |value| {\n        if (value != null) {\n            sum += value.?;\n        }\n    } else blk: {\n        try expect(sum == 12);\n        break :blk sum;\n    };\n    try expect(result == 12);\n}\n```\n\ntest_for.zig\n\n            $ zig test test_for.zig\n    1/4 test_for.test.for basics...OK\n    2/4 test_for.test.multi object for...OK\n    3/4 test_for.test.for reference...OK\n    4/4 test_for.test.for else...OK\n    All 4 tests passed.\n\n          \n\nShell"
- name: 'for: inline for'
  id: index#inline-for
  summary: For loops can be inlined
  description: "### inline for\n\nFor loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"inline for loop\" {\n    const nums = [_]i32{ 2, 4, 6 };\n    var sum: usize = 0;\n    inline for (nums) |i| {\n        const T = switch (i) {\n            2 => f32,\n            4 => i8,\n            6 => bool,\n            else => unreachable,\n        };\n        sum += typeNameLength(T);\n    }\n    try expect(sum == 9);\n}\n\nfn typeNameLength(comptime T: type) usize {\n    return @typeName(T).len;\n}\n```\n\ntest_inline_for.zig\n\n            $ zig test test_inline_for.zig\n    1/1 test_inline_for.test.inline for loop...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nIt is recommended to use `inline` loops only for one of these reasons:\n\n- You need the loop to execute at [comptime](#comptime) for the semantics to work.\n- You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.\n\nSee also:\n\n- [while](#while)\n- [comptime](#comptime)\n- [Arrays](#Arrays)\n- [Slices](#Slices)\n\n&nbsp;"
- name: 'for: Labeled for'
  id: index#Labeled-for
  summary: null
  description: "### Labeled for\n\nWhen a `for` loop is labeled, it can be referenced from a `break` or `continue` from within a nested loop:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"nested break\" {\n    var count: usize = 0;\n    outer: for (1..6) |_| {\n        for (1..6) |_| {\n            count += 1;\n            break :outer;\n        }\n    }\n    try expect(count == 1);\n}\n\ntest \"nested continue\" {\n    var count: usize = 0;\n    outer: for (1..9) |_| {\n        for (1..6) |_| {\n            count += 1;\n            continue :outer;\n        }\n    }\n\n    try expect(count == 8);\n}\n```\n\ntest_for_nested_break.zig\n\n            $ zig test test_for_nested_break.zig\n    1/2 test_for_nested_break.test.nested break...OK\n    2/2 test_for_nested_break.test.nested continue...OK\n    All 2 tests passed.\n\n          \n\nShell"
- name: Functions
  id: index#Functions
  summary: There is a difference between a function body and a function pointer
  description: "## Functions\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst native_arch = builtin.cpu.arch;\nconst expect = std.testing.expect;\n\n// Functions are declared like this\nfn add(a: i8, b: i8) i8 {\n    if (a == 0) {\n        return b;\n    }\n\n    return a + b;\n}\n\n// The export specifier makes a function externally visible in the generated\n// object file, and makes it use the C ABI.\nexport fn sub(a: i8, b: i8) i8 {\n    return a - b;\n}\n\n// The extern specifier is used to declare a function that will be resolved\n// at link time, when linking statically, or at runtime, when linking\n// dynamically. The quoted identifier after the extern keyword specifies\n// the library that has the function. (e.g. \"c\" -> libc.so)\n// The callconv specifier changes the calling convention of the function.\nconst WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C;\nextern \"kernel32\" fn ExitProcess(exit_code: u32) callconv(WINAPI) noreturn;\nextern \"c\" fn atan2(a: f64, b: f64) f64;\n\n// The @setCold builtin tells the optimizer that a function is rarely called.\nfn abort() noreturn {\n    @setCold(true);\n    while (true) {}\n}\n\n// The naked calling convention makes a function not have any function prologue or epilogue.\n// This can be useful when integrating with assembly.\nfn _start() callconv(.Naked) noreturn {\n    abort();\n}\n\n// The inline calling convention forces a function to be inlined at all call sites.\n// If the function cannot be inlined, it is a compile-time error.\ninline fn shiftLeftOne(a: u32) u32 {\n    return a << 1;\n}\n\n// The pub specifier allows the function to be visible when importing.\n// Another file can use @import and call sub2\npub fn sub2(a: i8, b: i8) i8 {\n    return a - b;\n}\n\n// Function pointers are prefixed with `*const `.\nconst Call2Op = *const fn (a: i8, b: i8) i8;\nfn doOp(fnCall: Call2Op, op1: i8, op2: i8) i8 {\n    return fnCall(op1, op2);\n}\n\ntest \"function\" {\n    try expect(doOp(add, 5, 6) == 11);\n    try expect(doOp(sub2, 5, 6) == -1);\n}\n```\n\ntest_functions.zig\n\n            $ zig test test_functions.zig\n    1/1 test_functions.test.function...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nThere is a difference between a function *body* and a function *pointer*. Function bodies are [comptime](#comptime)-only types while function [Pointers](#Pointers) may be runtime-known."
- name: 'Functions: Function Parameter Type Inference'
  id: index#Function-Parameter-Type-Inference
  summary: Function parameters can be declared with anytype in place of the type
  description: "### Function Parameter Type Inference\n\nFunction parameters can be declared with `anytype` in place of the type. In this case the parameter types will be inferred when the function is called. Use [@TypeOf](#TypeOf) and [@typeInfo](#typeInfo) to get information about the inferred type.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nfn addFortyTwo(x: anytype) @TypeOf(x) {\n    return x + 42;\n}\n\ntest \"fn type inference\" {\n    try expect(addFortyTwo(1) == 43);\n    try expect(@TypeOf(addFortyTwo(1)) == comptime_int);\n    const y: i64 = 2;\n    try expect(addFortyTwo(y) == 44);\n    try expect(@TypeOf(addFortyTwo(y)) == i64);\n}\n```\n\ntest_fn_type_inference.zig\n\n            $ zig test test_fn_type_inference.zig\n    1/1 test_fn_type_inference.test.fn type inference...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Functions: Function Reflection'
  id: index#Function-Reflection
  summary: null
  description: "### Function Reflection\n\n``` zig\nconst std = @import(\"std\");\nconst math = std.math;\nconst testing = std.testing;\n\ntest \"fn reflection\" {\n    try testing.expect(@typeInfo(@TypeOf(testing.expect)).Fn.params[0].type.? == bool);\n    try testing.expect(@typeInfo(@TypeOf(testing.tmpDir)).Fn.return_type.? == testing.TmpDir);\n\n    try testing.expect(@typeInfo(@TypeOf(math.Log2Int)).Fn.is_generic);\n}\n```\n\ntest_fn_reflection.zig\n\n            $ zig test test_fn_reflection.zig\n    1/1 test_fn_reflection.test.fn reflection...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Functions: inline fn'
  id: index#inline-fn
  summary: Adding the inline keyword to a function definition makes that function become semantically inlined at the callsite
  description: "### inline fn\n\nAdding the `inline` keyword to a function definition makes that function become *semantically inlined* at the callsite. This is not a hint to be possibly observed by optimization passes, but has implications on the types and values involved in the function call.\n\nUnlike normal function calls, arguments at an inline function callsite which are compile-time known are treated as [Compile Time Parameters](#Compile-Time-Parameters). This can potentially propagate all the way to the return value:\n\n``` zig\ntest \"inline function call\" {\n    if (foo(1200, 34) != 1234) {\n        @compileError(\"bad\");\n    }\n}\n\ninline fn foo(a: i32, b: i32) i32 {\n    return a + b;\n}\n```\n\ninline_call.zig\n\n            $ zig test inline_call.zig\n    1/1 inline_call.test.inline function call...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nIf `inline` is removed, the test fails with the compile error instead of passing.\n\nIt is generally better to let the compiler decide when to inline a function, except for these scenarios:\n\n- To change how many stack frames are in the call stack, for debugging purposes.\n- To force comptime-ness of the arguments to propagate to the return value of the function, as in the above example.\n- Real world performance measurements demand it.\n\nNote that `inline` actually *restricts* what the compiler is allowed to do. This can harm binary size, compilation speed, and even runtime performance."
- name: 'Functions: Pass-by-value Parameters'
  id: index#Pass-by-value-Parameters
  summary: Primitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body
  description: "### Pass-by-value Parameters\n\nPrimitive types such as [Integers](#Integers) and [Floats](#Floats) passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register.\n\nStructs, unions, and arrays can sometimes be more efficiently passed as a reference, since a copy could be arbitrarily expensive depending on the size. When these types are passed as parameters, Zig may choose to copy and pass by value, or pass by reference, whichever way Zig decides will be faster. This is made possible, in part, by the fact that parameters are immutable.\n\n``` zig\nconst Point = struct {\n    x: i32,\n    y: i32,\n};\n\nfn foo(point: Point) i32 {\n    // Here, `point` could be a reference, or a copy. The function body\n    // can ignore the difference and treat it as a value. Be very careful\n    // taking the address of the parameter - it should be treated as if\n    // the address will become invalid when the function returns.\n    return point.x + point.y;\n}\n\nconst expect = @import(\"std\").testing.expect;\n\ntest \"pass struct to function\" {\n    try expect(foo(Point{ .x = 1, .y = 2 }) == 3);\n}\n```\n\ntest_pass_by_reference_or_value.zig\n\n            $ zig test test_pass_by_reference_or_value.zig\n    1/1 test_pass_by_reference_or_value.test.pass struct to function...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nFor extern functions, Zig follows the C ABI for passing structs and unions by value."
- name: Hello World
  id: index#Hello-World
  summary: Most of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant
  description: "## Hello World\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n```\n\nhello.zig\n\n            $ zig build-exe hello.zig\n    $ ./hello\n    Hello, world!\n\n          \n\nShell\n\nMost of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. For this common case, there is a simpler API:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    std.debug.print(\"Hello, world!\\n\", .{});\n}\n```\n\nhello_again.zig\n\n            $ zig build-exe hello_again.zig\n    $ ./hello_again\n    Hello, world!\n\n          \n\nShell\n\nIn this case, the `!` may be omitted from the return type because no errors are returned from the function.\n\nSee also:\n\n- [Values](#Values)\n- [@import](#import)\n- [Errors](#Errors)\n- [Root Source File](#Root-Source-File)\n- [Source Encoding](#Source-Encoding)"
- name: if
  id: index#if
  summary: null
  description: "## if\n\n``` zig\n// If expressions have three uses, corresponding to the three types:\n// * bool\n// * ?T\n// * anyerror!T\n\nconst expect = @import(\"std\").testing.expect;\n\ntest \"if expression\" {\n    // If expressions are used instead of a ternary expression.\n    const a: u32 = 5;\n    const b: u32 = 4;\n    const result = if (a != b) 47 else 3089;\n    try expect(result == 47);\n}\n\ntest \"if boolean\" {\n    // If expressions test boolean conditions.\n    const a: u32 = 5;\n    const b: u32 = 4;\n    if (a != b) {\n        try expect(true);\n    } else if (a == 9) {\n        unreachable;\n    } else {\n        unreachable;\n    }\n}\n\ntest \"if error union\" {\n    // If expressions test for errors.\n    // Note the |err| capture on the else.\n\n    const a: anyerror!u32 = 0;\n    if (a) |value| {\n        try expect(value == 0);\n    } else |err| {\n        _ = err;\n        unreachable;\n    }\n\n    const b: anyerror!u32 = error.BadValue;\n    if (b) |value| {\n        _ = value;\n        unreachable;\n    } else |err| {\n        try expect(err == error.BadValue);\n    }\n\n    // The else and |err| capture is strictly required.\n    if (a) |value| {\n        try expect(value == 0);\n    } else |_| {}\n\n    // To check only the error value, use an empty block expression.\n    if (b) |_| {} else |err| {\n        try expect(err == error.BadValue);\n    }\n\n    // Access the value by reference using a pointer capture.\n    var c: anyerror!u32 = 3;\n    if (c) |*value| {\n        value.* = 9;\n    } else |_| {\n        unreachable;\n    }\n\n    if (c) |value| {\n        try expect(value == 9);\n    } else |_| {\n        unreachable;\n    }\n}\n```\n\ntest_if.zig\n\n            $ zig test test_if.zig\n    1/3 test_if.test.if expression...OK\n    2/3 test_if.test.if boolean...OK\n    3/3 test_if.test.if error union...OK\n    All 3 tests passed.\n\n          \n\nShell"
- name: 'if: if with Optionals'
  id: index#if-with-Optionals
  summary: null
  description: "### if with Optionals\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"if optional\" {\n    // If expressions test for null.\n\n    const a: ?u32 = 0;\n    if (a) |value| {\n        try expect(value == 0);\n    } else {\n        unreachable;\n    }\n\n    const b: ?u32 = null;\n    if (b) |_| {\n        unreachable;\n    } else {\n        try expect(true);\n    }\n\n    // The else is not required.\n    if (a) |value| {\n        try expect(value == 0);\n    }\n\n    // To test against null only, use the binary equality operator.\n    if (b == null) {\n        try expect(true);\n    }\n\n    // Access the value by reference using a pointer capture.\n    var c: ?u32 = 3;\n    if (c) |*value| {\n        value.* = 2;\n    }\n\n    if (c) |value| {\n        try expect(value == 2);\n    } else {\n        unreachable;\n    }\n}\n\ntest \"if error union with optional\" {\n    // If expressions test for errors before unwrapping optionals.\n    // The |optional_value| capture's type is ?u32.\n\n    const a: anyerror!?u32 = 0;\n    if (a) |optional_value| {\n        try expect(optional_value.? == 0);\n    } else |err| {\n        _ = err;\n        unreachable;\n    }\n\n    const b: anyerror!?u32 = null;\n    if (b) |optional_value| {\n        try expect(optional_value == null);\n    } else |_| {\n        unreachable;\n    }\n\n    const c: anyerror!?u32 = error.BadValue;\n    if (c) |optional_value| {\n        _ = optional_value;\n        unreachable;\n    } else |err| {\n        try expect(err == error.BadValue);\n    }\n\n    // Access the value by reference by using a pointer capture each time.\n    var d: anyerror!?u32 = 3;\n    if (d) |*optional_value| {\n        if (optional_value.*) |*value| {\n            value.* = 9;\n        }\n    } else |_| {\n        unreachable;\n    }\n\n    if (d) |optional_value| {\n        try expect(optional_value.? == 9);\n    } else |_| {\n        unreachable;\n    }\n}\n```\n\ntest_if_optionals.zig\n\n            $ zig test test_if_optionals.zig\n    1/2 test_if_optionals.test.if optional...OK\n    2/2 test_if_optionals.test.if error union with optional...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [Optionals](#Optionals)\n- [Errors](#Errors)\n\n&nbsp;"
- name: Integers
  id: index#Integers
  summary: null
  description: '## Integers'
- name: 'Integers: Integer Literals'
  id: index#Integer-Literals
  summary: null
  description: |-
    ### Integer Literals

    ``` zig
    const decimal_int = 98222;
    const hex_int = 0xff;
    const another_hex_int = 0xFF;
    const octal_int = 0o755;
    const binary_int = 0b11110000;

    // underscores may be placed between two digits as a visual separator
    const one_billion = 1_000_000_000;
    const binary_mask = 0b1_1111_1111;
    const permissions = 0o7_5_5;
    const big_address = 0xFF80_0000_0000_0000;
    ```

    integer_literals.zig
- name: 'Integers: Runtime Integer Values'
  id: index#Runtime-Integer-Values
  summary: Integer literals have no size limitation, and if any undefined behavior occurs, the compiler catches it
  description: |-
    ### Runtime Integer Values

    Integer literals have no size limitation, and if any undefined behavior occurs, the compiler catches it.

    However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to undefined behavior.

    ``` zig
    fn divide(a: i32, b: i32) i32 {
        return a / b;
    }
    ```

    runtime_vs_comptime.zig

    In this function, values `a` and `b` are known only at runtime, and thus this division operation is vulnerable to both [Integer Overflow](#Integer-Overflow) and [Division by Zero](#Division-by-Zero).

    Operators such as `+` and `-` cause undefined behavior on integer overflow. Alternative operators are provided for wrapping and saturating arithmetic on all targets. `+%` and `-%` perform wrapping arithmetic while `+|` and `-|` perform saturating arithmetic.

    Zig supports arbitrary bit-width integers, referenced by using an identifier of `i` or `u` followed by digits. For example, the identifier `i7` refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is `65535`. For signed integer types, Zig uses a [two's complement](https://en.wikipedia.org/wiki/Two's_complement) representation.

    See also:

    - [Wrapping Operations](#Wrapping-Operations)

    &nbsp;
- name: Introduction
  id: index#Introduction
  summary: Zig is a general-purpose programming language and toolchain for maintaining robust, optimal, and reusable software
  description: |-
    ## Introduction

    [Zig](https://ziglang.org) is a general-purpose programming language and toolchain for maintaining **robust**, **optimal**, and **reusable** software.

    Robust

    Behavior is correct even for edge cases such as out of memory.

    Optimal

    Write programs the best way they can behave and perform.

    Reusable

    The same code works in many environments which have different constraints.

    Maintainable

    Precisely communicate intent to the compiler and other programmers. The language imposes a low overhead to reading code and is resilient to changing requirements and environments.

    Often the most efficient way to learn something new is to see examples, so this documentation shows how to use each of Zig's features. It is all on one page so you can search with your browser's search tool.

    The code samples in this document are compiled and tested as part of the main test suite of Zig.

    This HTML document depends on no external files, so you can use it offline.
- name: Keyword Reference
  id: index#Keyword-Reference
  summary: null
  description: |-
    ## Keyword Reference

    [TABLE]
- name: Memory
  id: index#Memory
  summary: The Zig language performs no memory management on behalf of the programmer
  description: "## Memory\n\nThe Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question:\n\n[Where are the bytes?](#Where-are-the-bytes)\n\nLike Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - `malloc`, `realloc`, and `free`. When linking against libc, Zig exposes this allocator with `std.heap.c_allocator`. However, by convention, there is no default allocator in Zig. Instead, functions which need to allocate accept an `Allocator` parameter. Likewise, data structures such as `std.ArrayList` accept an `Allocator` parameter in their initialization functions:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nconst expect = std.testing.expect;\n\ntest \"using an allocator\" {\n    var buffer: [100]u8 = undefined;\n    var fba = std.heap.FixedBufferAllocator.init(&buffer);\n    const allocator = fba.allocator();\n    const result = try concat(allocator, \"foo\", \"bar\");\n    try expect(std.mem.eql(u8, \"foobar\", result));\n}\n\nfn concat(allocator: Allocator, a: []const u8, b: []const u8) ![]u8 {\n    const result = try allocator.alloc(u8, a.len + b.len);\n    @memcpy(result[0..a.len], a);\n    @memcpy(result[a.len..], b);\n    return result;\n}\n```\n\ntest_allocator.zig\n\n            $ zig test test_allocator.zig\n    1/1 test_allocator.test.using an allocator...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nIn the above example, 100 bytes of stack memory are used to initialize a `FixedBufferAllocator`, which is then passed to a function. As a convenience there is a global `FixedBufferAllocator` available for quick tests at `std.testing.allocator`, which will also perform basic leak detection.\n\nZig has a general purpose allocator available to be imported with `std.heap.GeneralPurposeAllocator`. However, it is still recommended to follow the [Choosing an Allocator](#Choosing-an-Allocator) guide."
- name: 'Memory: Choosing an Allocator'
  id: index#Choosing-an-Allocator
  summary: What allocator to use depends on a number of factors
  description: |-
    ### Choosing an Allocator

    What allocator to use depends on a number of factors. Here is a flow chart to help you decide:

    1.  Are you making a library? In this case, best to accept an `Allocator` as a parameter and allow your library's users to decide what allocator to use.
    2.  Are you linking libc? In this case, `std.heap.c_allocator` is likely the right choice, at least for your main allocator.
    3.  Is the maximum number of bytes that you will need bounded by a number known at [comptime](#comptime)? In this case, use `std.heap.FixedBufferAllocator` or `std.heap.ThreadSafeFixedBufferAllocator` depending on whether you need thread-safety or not.
    4.  Is your program a command line application which runs from start to end without any fundamental cyclical pattern (such as a video game main loop, or a web server request handler), such that it would make sense to free everything at once at the end? In this case, it is recommended to follow this pattern:
        ``` zig
        const std = @import("std");

        pub fn main() !void {
            var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
            defer arena.deinit();

            const allocator = arena.allocator();

            const ptr = try allocator.create(i32);
            std.debug.print("ptr={*}\n", .{ptr});
        }
        ```

        cli_allocation.zig

            $ zig build-exe cli_allocation.zig
            $ ./cli_allocation
            ptr=i32@7f989ee8e010

        Shell

        When using this kind of allocator, there is no need to free anything manually. Everything gets freed at once with the call to `arena.deinit()`.
    5.  Are the allocations part of a cyclical pattern such as a video game main loop, or a web server request handler? If the allocations can all be freed at once, at the end of the cycle, for example once the video game frame has been fully rendered, or the web server request has been served, then `std.heap.ArenaAllocator` is a great candidate. As demonstrated in the previous bullet point, this allows you to free entire arenas at once. Note also that if an upper bound of memory can be established, then `std.heap.FixedBufferAllocator` can be used as a further optimization.
    6.  Are you writing a test, and you want to make sure `error``.OutOfMemory` is handled correctly? In this case, use `std.testing.FailingAllocator`.
    7.  Are you writing a test? In this case, use `std.testing.allocator`.
    8.  Finally, if none of the above apply, you need a general purpose allocator. Zig's general purpose allocator is available as a function that takes a [comptime](#comptime) [struct](#struct) of configuration options and returns a type. Generally, you will set up one `std.heap.GeneralPurposeAllocator` in your main function, and then pass it or sub-allocators around to various parts of your application.
    9.  You can also consider [Implementing an Allocator](#Implementing-an-Allocator).

    &nbsp;
- name: 'Memory: Heap Allocation Failure'
  id: index#Heap-Allocation-Failure
  summary: Many programming languages choose to handle the possibility of heap allocation failure by unconditionally crashing
  description: |-
    ### Heap Allocation Failure

    Many programming languages choose to handle the possibility of heap allocation failure by unconditionally crashing. By convention, Zig programmers do not consider this to be a satisfactory solution. Instead, `error``.OutOfMemory` represents heap allocation failure, and Zig libraries return this error code whenever heap allocation failure prevented an operation from completing successfully.

    Some have argued that because some operating systems such as Linux have memory overcommit enabled by default, it is pointless to handle heap allocation failure. There are many problems with this reasoning:

    - Only some operating systems have an overcommit feature.
      - Linux has it enabled by default, but it is configurable.
      - Windows does not overcommit.
      - Embedded systems do not have overcommit.
      - Hobby operating systems may or may not have overcommit.
    - For real-time systems, not only is there no overcommit, but typically the maximum amount of memory per application is determined ahead of time.
    - When writing a library, one of the main goals is code reuse. By making code handle allocation failure correctly, a library becomes eligible to be reused in more contexts.
    - Although some software has grown to depend on overcommit being enabled, its existence is the source of countless user experience disasters. When a system with overcommit enabled, such as Linux on default settings, comes close to memory exhaustion, the system locks up and becomes unusable. At this point, the OOM Killer selects an application to kill based on heuristics. This non-deterministic decision often results in an important process being killed, and often fails to return the system back to working order.

    &nbsp;
- name: 'Memory: Implementing an Allocator'
  id: index#Implementing-an-Allocator
  summary: Zig programmers can implement their own allocators by fulfilling the Allocator interface
  description: |-
    ### Implementing an Allocator

    Zig programmers can implement their own allocators by fulfilling the Allocator interface. In order to do this one must read carefully the documentation comments in std/mem.zig and then supply a `allocFn` and a `resizeFn`.

    There are many example allocators to look at for inspiration. Look at std/heap.zig and `std.heap.GeneralPurposeAllocator`.
- name: 'Memory: Lifetime and Ownership'
  id: index#Lifetime-and-Ownership
  summary: It is the Zig programmer's responsibility to ensure that a pointer is not accessed when the memory pointed to is no longer available
  description: |-
    ### Lifetime and Ownership

    It is the Zig programmer's responsibility to ensure that a [pointer](#Pointers) is not accessed when the memory pointed to is no longer available. Note that a [slice](#Slices) is a form of pointer, in that it references other memory.

    In order to prevent bugs, there are some helpful conventions to follow when dealing with pointers. In general, when a function returns a pointer, the documentation for the function should explain who "owns" the pointer. This concept helps the programmer decide when it is appropriate, if ever, to free the pointer.

    For example, the function's documentation may say "caller owns the returned memory", in which case the code that calls the function must have a plan for when to free that memory. Probably in this situation, the function will accept an `Allocator` parameter.

    Sometimes the lifetime of a pointer may be more complicated. For example, the `std.ArrayList(T).items` slice has a lifetime that remains valid until the next time the list is resized, such as by appending new elements.

    The API documentation for functions and data structures should take great care to explain the ownership and lifetime semantics of pointers. Ownership determines whose responsibility it is to free the memory referenced by the pointer, and lifetime determines the point at which the memory becomes inaccessible (lest [Undefined Behavior](#Undefined-Behavior) occur).
- name: 'Memory: Recursion'
  id: index#Recursion
  summary: Recursion is a fundamental tool in modeling software
  description: |-
    ### Recursion

    Recursion is a fundamental tool in modeling software. However it has an often-overlooked problem: unbounded memory allocation.

    Recursion is an area of active experimentation in Zig and so the documentation here is not final. You can read a [summary of recursion status in the 0.3.0 release notes](https://ziglang.org/download/0.3.0/release-notes.html#recursion).

    The short summary is that currently recursion works normally as you would expect. Although Zig code is not yet protected from stack overflow, it is planned that a future version of Zig will provide such protection, with some degree of cooperation from Zig code required.
- name: 'Memory: Where are the bytes?'
  id: index#Where-are-the-bytes
  summary: String literals such as "hello" are in the global constant data section
  description: "### Where are the bytes?\n\nString literals such as `\"hello\"` are in the global constant data section. This is why it is an error to pass a string literal to a mutable slice, like this:\n\n``` zig\nfn foo(s: []u8) void {\n    _ = s;\n}\n\ntest \"string literal to mutable slice\" {\n    foo(\"hello\");\n}\n```\n\ntest_string_literal_to_slice.zig\n\n            $ zig test test_string_literal_to_slice.zig\n    doc/langref/test_string_literal_to_slice.zig:6:9: error: expected type '[]u8', found '*const [5:0]u8'\n        foo(\"hello\");\n            ^~~~~~~\n    doc/langref/test_string_literal_to_slice.zig:6:9: note: cast discards const qualifier\n    doc/langref/test_string_literal_to_slice.zig:1:11: note: parameter type declared here\n    fn foo(s: []u8) void {\n              ^~~~\n\n\n          \n\nShell\n\nHowever if you make the slice constant, then it works:\n\n``` zig\nfn foo(s: []const u8) void {\n    _ = s;\n}\n\ntest \"string literal to constant slice\" {\n    foo(\"hello\");\n}\n```\n\ntest_string_literal_to_const_slice.zig\n\n            $ zig test test_string_literal_to_const_slice.zig\n    1/1 test_string_literal_to_const_slice.test.string literal to constant slice...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nJust like string literals, `const` declarations, when the value is known at [comptime](#comptime), are stored in the global constant data section. Also [Compile Time Variables](#Compile-Time-Variables) are stored in the global constant data section.\n\n`var` declarations inside functions are stored in the function's stack frame. Once a function returns, any [Pointers](#Pointers) to variables in the function's stack frame become invalid references, and dereferencing them becomes unchecked [Undefined Behavior](#Undefined-Behavior).\n\n`var` declarations at the top level or in [struct](#struct) declarations are stored in the global data section.\n\nThe location of memory allocated with `allocator.alloc` or `allocator.create` is determined by the allocator's implementation.\n\nTODO: thread local variables"
- name: noreturn
  id: index#noreturn
  summary: When resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type
  description: "## noreturn\n\n`noreturn` is the type of:\n\n- ` ``break`` `\n- ` ``continue`` `\n- ` ``return`` `\n- ` ``unreachable`` `\n- `while`` (``true``) {}`\n\nWhen resolving types together, such as `if` clauses or `switch` prongs, the `noreturn` type is compatible with every other type. Consider:\n\n``` zig\nfn foo(condition: bool, b: u32) void {\n    const a = if (condition) b else return;\n    _ = a;\n    @panic(\"do something with a\");\n}\ntest \"noreturn\" {\n    foo(false, 1);\n}\n```\n\ntest_noreturn.zig\n\n            $ zig test test_noreturn.zig\n    1/1 test_noreturn.test.noreturn...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nAnother use case for `noreturn` is the `exit` function:\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst native_arch = builtin.cpu.arch;\nconst expect = std.testing.expect;\n\nconst WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C;\nextern \"kernel32\" fn ExitProcess(exit_code: c_uint) callconv(WINAPI) noreturn;\n\ntest \"foo\" {\n    const value = bar() catch ExitProcess(1);\n    try expect(value == 1234);\n}\n\nfn bar() anyerror!u32 {\n    return 1234;\n}\n```\n\ntest_noreturn_from_exit.zig\n\n            $ zig test test_noreturn_from_exit.zig -target x86_64-windows --test-no-exec\n\n          \n\nShell"
- name: opaque
  id: index#opaque
  summary: opaque`` {} declares a new type with an unknown (but non-zero) size and alignment
  description: "## opaque\n\n`opaque`` {}` declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as [structs](#struct), [unions](#union), and [enums](#enum).\n\nThis is typically used for type safety when interacting with C code that does not expose struct details. Example:\n\n``` zig\nconst Derp = opaque {};\nconst Wat = opaque {};\n\nextern fn bar(d: *Derp) void;\nfn foo(w: *Wat) callconv(.C) void {\n    bar(w);\n}\n\ntest \"call foo\" {\n    foo(undefined);\n}\n```\n\ntest_opaque.zig\n\n            $ zig test test_opaque.zig\n    doc/langref/test_opaque.zig:6:9: error: expected type '*test_opaque.Derp', found '*test_opaque.Wat'\n        bar(w);\n            ^\n    doc/langref/test_opaque.zig:6:9: note: pointer type child 'test_opaque.Wat' cannot cast into pointer type child 'test_opaque.Derp'\n    doc/langref/test_opaque.zig:2:13: note: opaque declared here\n    const Wat = opaque {};\n                ^~~~~~~~~\n    doc/langref/test_opaque.zig:1:14: note: opaque declared here\n    const Derp = opaque {};\n                 ^~~~~~~~~\n    doc/langref/test_opaque.zig:4:18: note: parameter type declared here\n    extern fn bar(d: *Derp) void;\n                     ^~~~~\n    referenced by:\n        test.call foo: doc/langref/test_opaque.zig:10:5\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\n\n          \n\nShell"
- name: Operators
  id: index#Operators
  summary: There is no operator overloading
  description: |-
    ## Operators

    There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else.
- name: 'Operators: Precedence'
  id: index#Precedence
  summary: null
  description: |-
    ### Precedence

    ``` zig
    x() x[] x.y x.* x.?
    a!b
    x{}
    !x -x -%x ~x &x ?x
    * / % ** *% *| ||
    + - ++ +% -% +| -|
    << >> <<|
    & ^ | orelse catch
    == != < > <= >=
    and
    or
    = *= *%= *|= /= %= += +%= +|= -= -%= -|= <<= <<|= >>= &= ^= |=
    ```
- name: 'Operators: Table of Operators'
  id: index#Table-of-Operators
  summary: null
  description: |-
    ### Table of Operators

    [TABLE]
- name: Optionals
  id: index#Optionals
  summary: One area that Zig provides safety without compromising efficiency or readability is with the optional type
  description: |-
    ## Optionals

    One area that Zig provides safety without compromising efficiency or readability is with the optional type.

    The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this:

    ``` zig
    // normal integer
    const normal_int: i32 = 1234;

    // optional integer
    const optional_int: ?i32 = 5678;
    ```

    optional_integer.zig

    Now the variable `optional_int` could be an `i32`, or `null`.

    Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being [the worst mistake of computer science](https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/).

    Zig does not have them.

    Instead, you can use an optional pointer. This secretly compiles down to a normal pointer, since we know we can use 0 as the null value for the optional type. But the compiler can check your work and make sure you don't assign null to something that can't be null.

    Typically the downside of not having null is that it makes the code more verbose to write. But, let's compare some equivalent C code and Zig code.

    Task: call malloc, if the result is null, return null.

    C code

    ``` zig
    // malloc prototype included for reference
    void *malloc(size_t size);

    struct Foo *do_a_thing(void) {
        char *ptr = malloc(1234);
        if (!ptr) return NULL;
        // ...
    }
    ```

    call_malloc_in_c.c

    Zig code

    ``` zig
    // malloc prototype included for reference
    extern fn malloc(size: usize) ?[*]u8;

    fn doAThing() ?*Foo {
        const ptr = malloc(1234) orelse return null;
        _ = ptr; // ...
    }
    ```

    call_malloc_from_zig.zig

    Here, Zig is at least as convenient, if not more, than C. And, the type of "ptr" is `[*]``u8` *not* `?[*]``u8`. The `orelse` keyword unwrapped the optional type and therefore `ptr` is guaranteed to be non-null everywhere it is used in the function.

    The other form of checking against NULL you might see looks like this:

    ``` zig
    void do_a_thing(struct Foo *foo) {
        // do some stuff

        if (foo) {
            do_something_with_foo(foo);
        }

        // do some stuff
    }
    ```

    checking_null_in_c.c

    In Zig you can accomplish the same thing:

    ``` zig
    const Foo = struct {};
    fn doSomethingWithFoo(foo: *Foo) void {
        _ = foo;
    }

    fn doAThing(optional_foo: ?*Foo) void {
        // do some stuff

        if (optional_foo) |foo| {
            doSomethingWithFoo(foo);
        }

        // do some stuff
    }
    ```

    checking_null_in_zig.zig

    Once again, the notable thing here is that inside the if block, `foo` is no longer an optional pointer, it is a pointer, which cannot be null.

    One benefit to this is that functions which take pointers as arguments can be annotated with the "nonnull" attribute - `__attribute__((nonnull))` in [GCC](https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html). The optimizer can sometimes make better decisions knowing that pointer arguments cannot be null.
- name: 'Optionals: null'
  id: index#null
  summary: null
  description: |-
    ### null

    Just like [undefined](#undefined), `null` has its own type, and the only way to use it is to cast it to a different type:

    ``` zig
    const optional_value: ?i32 = null;
    ```

    null.zig
- name: 'Optionals: Optional Pointers'
  id: index#Optional-Pointers
  summary: An optional pointer is guaranteed to be the same size as a pointer
  description: "### Optional Pointers\n\nAn optional pointer is guaranteed to be the same size as a pointer. The `null` of the optional is guaranteed to be address 0.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"optional pointers\" {\n    // Pointers cannot be null. If you want a null pointer, use the optional\n    // prefix `?` to make the pointer type optional.\n    var ptr: ?*i32 = null;\n\n    var x: i32 = 1;\n    ptr = &x;\n\n    try expect(ptr.?.* == 1);\n\n    // Optional pointers are the same size as normal pointers, because pointer\n    // value 0 is used as the null value.\n    try expect(@sizeOf(?*i32) == @sizeOf(*i32));\n}\n```\n\ntest_optional_pointer.zig\n\n            $ zig test test_optional_pointer.zig\n    1/1 test_optional_pointer.test.optional pointers...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [while with Optionals](#while-with-Optionals)\n- [if with Optionals](#if-with-Optionals)\n\n&nbsp;"
- name: 'Optionals: Optional Type'
  id: index#Optional-Type
  summary: An optional is created by putting ? in front of a type
  description: "### Optional Type\n\nAn optional is created by putting `?` in front of a type. You can use compile-time reflection to access the child type of an optional:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"optional type\" {\n    // Declare an optional and coerce from null:\n    var foo: ?i32 = null;\n\n    // Coerce from child type of an optional\n    foo = 1234;\n\n    // Use compile-time reflection to access the child type of the optional:\n    try comptime expect(@typeInfo(@TypeOf(foo)).Optional.child == i32);\n}\n```\n\ntest_optional_type.zig\n\n            $ zig test test_optional_type.zig\n    1/1 test_optional_type.test.optional type...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: Pointers
  id: index#Pointers
  summary: 'Zig has two kinds of pointers: single-item and many-item'
  description: "## Pointers\n\nZig has two kinds of pointers: single-item and many-item.\n\n- `*T` - single-item pointer to exactly one item.\n  - Supports deref syntax: `ptr.*`\n- `[*]T` - many-item pointer to unknown number of items.\n  - Supports index syntax: `ptr[i]`\n  - Supports slice syntax: `ptr[start..end]` and `ptr[start..]`\n  - Supports pointer arithmetic: `ptr + x`, `ptr - x`\n  - `T` must have a known size, which means that it cannot be `anyopaque` or any other [opaque type](#opaque).\n\nThese types are closely related to [Arrays](#Arrays) and [Slices](#Slices):\n\n- `*[N]T` - pointer to N items, same as single-item pointer to an array.\n  - Supports index syntax: `array_ptr[i]`\n  - Supports slice syntax: `array_ptr[start..end]`\n  - Supports len property: `array_ptr.len`\n\n&nbsp;\n\n- `[]T` - is a slice (a fat pointer, which contains a pointer of type `[*]T` and a length).\n  - Supports index syntax: `slice[i]`\n  - Supports slice syntax: `slice[start..end]`\n  - Supports len property: `slice.len`\n\nUse `&x` to obtain a single-item pointer:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"address of syntax\" {\n    // Get the address of a variable:\n    const x: i32 = 1234;\n    const x_ptr = &x;\n\n    // Dereference a pointer:\n    try expect(x_ptr.* == 1234);\n\n    // When you get the address of a const variable, you get a const single-item pointer.\n    try expect(@TypeOf(x_ptr) == *const i32);\n\n    // If you want to mutate the value, you'd need an address of a mutable variable:\n    var y: i32 = 5678;\n    const y_ptr = &y;\n    try expect(@TypeOf(y_ptr) == *i32);\n    y_ptr.* += 1;\n    try expect(y_ptr.* == 5679);\n}\n\ntest \"pointer array access\" {\n    // Taking an address of an individual element gives a\n    // single-item pointer. This kind of pointer\n    // does not support pointer arithmetic.\n    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    const ptr = &array[2];\n    try expect(@TypeOf(ptr) == *u8);\n\n    try expect(array[2] == 3);\n    ptr.* += 1;\n    try expect(array[2] == 4);\n}\n```\n\ntest_single_item_pointer.zig\n\n            $ zig test test_single_item_pointer.zig\n    1/2 test_single_item_pointer.test.address of syntax...OK\n    2/2 test_single_item_pointer.test.pointer array access...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nZig supports pointer arithmetic. It's better to assign the pointer to `[*]T` and increment that variable. For example, directly incrementing the pointer from a slice will corrupt it.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"pointer arithmetic with many-item pointer\" {\n    const array = [_]i32{ 1, 2, 3, 4 };\n    var ptr: [*]const i32 = &array;\n\n    try expect(ptr[0] == 1);\n    ptr += 1;\n    try expect(ptr[0] == 2);\n\n    // slicing a many-item pointer without an end is equivalent to\n    // pointer arithmetic: `ptr[start..] == ptr + start`\n    try expect(ptr[1..] == ptr + 1);\n}\n\ntest \"pointer arithmetic with slices\" {\n    var array = [_]i32{ 1, 2, 3, 4 };\n    var length: usize = 0; // var to make it runtime-known\n    _ = &length; // suppress 'var is never mutated' error\n    var slice = array[length..array.len];\n\n    try expect(slice[0] == 1);\n    try expect(slice.len == 4);\n\n    slice.ptr += 1;\n    // now the slice is in an bad state since len has not been updated\n\n    try expect(slice[0] == 2);\n    try expect(slice.len == 4);\n}\n```\n\ntest_pointer_arithmetic.zig\n\n            $ zig test test_pointer_arithmetic.zig\n    1/2 test_pointer_arithmetic.test.pointer arithmetic with many-item pointer...OK\n    2/2 test_pointer_arithmetic.test.pointer arithmetic with slices...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nIn Zig, we generally prefer [Slices](#Slices) rather than [Sentinel-Terminated Pointers](#Sentinel-Terminated-Pointers). You can turn an array or pointer into a slice using slice syntax.\n\nSlices have bounds checking and are therefore protected against this kind of undefined behavior. This is one reason we prefer slices to pointers.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"pointer slicing\" {\n    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    var start: usize = 2; // var to make it runtime-known\n    _ = &start; // suppress 'var is never mutated' error\n    const slice = array[start..4];\n    try expect(slice.len == 2);\n\n    try expect(array[3] == 4);\n    slice[1] += 1;\n    try expect(array[3] == 5);\n}\n```\n\ntest_slice_bounds.zig\n\n            $ zig test test_slice_bounds.zig\n    1/1 test_slice_bounds.test.pointer slicing...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nPointers work at compile-time too, as long as the code does not depend on an undefined memory layout:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"comptime pointers\" {\n    comptime {\n        var x: i32 = 1;\n        const ptr = &x;\n        ptr.* += 1;\n        x += 1;\n        try expect(ptr.* == 3);\n    }\n}\n```\n\ntest_comptime_pointers.zig\n\n            $ zig test test_comptime_pointers.zig\n    1/1 test_comptime_pointers.test.comptime pointers...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nTo convert an integer address into a pointer, use `@ptrFromInt`. To convert a pointer to an integer, use `@intFromPtr`:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"@intFromPtr and @ptrFromInt\" {\n    const ptr: *i32 = @ptrFromInt(0xdeadbee0);\n    const addr = @intFromPtr(ptr);\n    try expect(@TypeOf(addr) == usize);\n    try expect(addr == 0xdeadbee0);\n}\n```\n\ntest_integer_pointer_conversion.zig\n\n            $ zig test test_integer_pointer_conversion.zig\n    1/1 test_integer_pointer_conversion.test.@intFromPtr and @ptrFromInt...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nZig is able to preserve memory addresses in comptime code, as long as the pointer is never dereferenced:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"comptime @ptrFromInt\" {\n    comptime {\n        // Zig is able to do this at compile-time, as long as\n        // ptr is never dereferenced.\n        const ptr: *i32 = @ptrFromInt(0xdeadbee0);\n        const addr = @intFromPtr(ptr);\n        try expect(@TypeOf(addr) == usize);\n        try expect(addr == 0xdeadbee0);\n    }\n}\n```\n\ntest_comptime_pointer_conversion.zig\n\n            $ zig test test_comptime_pointer_conversion.zig\n    1/1 test_comptime_pointer_conversion.test.comptime @ptrFromInt...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [Optional Pointers](#Optional-Pointers)\n- [@ptrFromInt](#ptrFromInt)\n- [@intFromPtr](#intFromPtr)\n- [C Pointers](#C-Pointers)\n\n&nbsp;"
- name: 'Pointers: Alignment'
  id: index#Alignment
  summary: Each type has an alignment - a number of bytes such that, when a value of the type is loaded from or stored to memory, the memory address must be evenly divisible by this number
  description: "### Alignment\n\nEach type has an **alignment** - a number of bytes such that, when a value of the type is loaded from or stored to memory, the memory address must be evenly divisible by this number. You can use [@alignOf](#alignOf) to find out this value for any type.\n\nAlignment depends on the CPU architecture, but is always a power of two, and less than `1`` << ``29`.\n\nIn Zig, a pointer type has an alignment value. If the value is equal to the alignment of the underlying type, it can be omitted from the type:\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\n\ntest \"variable alignment\" {\n    var x: i32 = 1234;\n    const align_of_i32 = @alignOf(@TypeOf(x));\n    try expect(@TypeOf(&x) == *i32);\n    try expect(*i32 == *align(align_of_i32) i32);\n    if (builtin.target.cpu.arch == .x86_64) {\n        try expect(@typeInfo(*i32).Pointer.alignment == 4);\n    }\n}\n```\n\ntest_variable_alignment.zig\n\n            $ zig test test_variable_alignment.zig\n    1/1 test_variable_alignment.test.variable alignment...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nIn the same way that a `*``i32` can be [coerced](#Type-Coercion) to a `*``const`` ``i32`, a pointer with a larger alignment can be implicitly cast to a pointer with a smaller alignment, but not vice versa.\n\nYou can specify alignment on variables and functions. If you do this, then pointers to them get the specified alignment:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nvar foo: u8 align(4) = 100;\n\ntest \"global variable alignment\" {\n    try expect(@typeInfo(@TypeOf(&foo)).Pointer.alignment == 4);\n    try expect(@TypeOf(&foo) == *align(4) u8);\n    const as_pointer_to_array: *align(4) [1]u8 = &foo;\n    const as_slice: []align(4) u8 = as_pointer_to_array;\n    const as_unaligned_slice: []u8 = as_slice;\n    try expect(as_unaligned_slice[0] == 100);\n}\n\nfn derp() align(@sizeOf(usize) * 2) i32 {\n    return 1234;\n}\nfn noop1() align(1) void {}\nfn noop4() align(4) void {}\n\ntest \"function alignment\" {\n    try expect(derp() == 1234);\n    try expect(@TypeOf(derp) == fn () i32);\n    try expect(@TypeOf(&derp) == *align(@sizeOf(usize) * 2) const fn () i32);\n\n    noop1();\n    try expect(@TypeOf(noop1) == fn () void);\n    try expect(@TypeOf(&noop1) == *align(1) const fn () void);\n\n    noop4();\n    try expect(@TypeOf(noop4) == fn () void);\n    try expect(@TypeOf(&noop4) == *align(4) const fn () void);\n}\n```\n\ntest_variable_func_alignment.zig\n\n            $ zig test test_variable_func_alignment.zig\n    1/2 test_variable_func_alignment.test.global variable alignment...OK\n    2/2 test_variable_func_alignment.test.function alignment...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nIf you have a pointer or a slice that has a small alignment, but you know that it actually has a bigger alignment, use [@alignCast](#alignCast) to change the pointer into a more aligned pointer. This is a no-op at runtime, but inserts a [safety check](#Incorrect-Pointer-Alignment):\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"pointer alignment safety\" {\n    var array align(4) = [_]u32{ 0x11111111, 0x11111111 };\n    const bytes = std.mem.sliceAsBytes(array[0..]);\n    try std.testing.expect(foo(bytes) == 0x11111111);\n}\nfn foo(bytes: []u8) u32 {\n    const slice4 = bytes[1..5];\n    const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n    return int_slice[0];\n}\n```\n\ntest_incorrect_pointer_alignment.zig\n\n            $ zig test test_incorrect_pointer_alignment.zig\n    1/1 test_incorrect_pointer_alignment.test.pointer alignment safety...thread 3568823 panic: incorrect alignment\n    /home/andy/src/zig/doc/langref/test_incorrect_pointer_alignment.zig:10:68: 0x103d13a in foo (test)\n        const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n                                                                       ^\n    /home/andy/src/zig/doc/langref/test_incorrect_pointer_alignment.zig:6:31: 0x103cfd7 in test.pointer alignment safety (test)\n        try std.testing.expect(foo(bytes) == 0x11111111);\n                                  ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1047f10 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e28b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d609 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103d171 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/c771705677c0d2df24e00269a9189f97/test\n\n          \n\nShell"
- name: 'Pointers: allowzero'
  id: index#allowzero
  summary: This pointer attribute allows a pointer to have address zero
  description: "### allowzero\n\nThis pointer attribute allows a pointer to have address zero. This is only ever needed on the freestanding OS target, where the address zero is mappable. If you want to represent null pointers, use [Optional Pointers](#Optional-Pointers) instead. [Optional Pointers](#Optional-Pointers) with `allowzero` are not the same size as pointers. In this code example, if the pointer did not have the `allowzero` attribute, this would be a [Pointer Cast Invalid Null](#Pointer-Cast-Invalid-Null) panic:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"allowzero\" {\n    var zero: usize = 0; // var to make to runtime-known\n    _ = &zero; // suppress 'var is never mutated' error\n    const ptr: *allowzero i32 = @ptrFromInt(zero);\n    try expect(@intFromPtr(ptr) == 0);\n}\n```\n\ntest_allowzero.zig\n\n            $ zig test test_allowzero.zig\n    1/1 test_allowzero.test.allowzero...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Pointers: Sentinel-Terminated Pointers'
  id: index#Sentinel-Terminated-Pointers
  summary: The syntax [*:x]T describes a pointer that has a length determined by a sentinel value
  description: "### Sentinel-Terminated Pointers\n\nThe syntax `[*:x]T` describes a pointer that has a length determined by a sentinel value. This provides protection against buffer overflow and overreads.\n\n``` zig\nconst std = @import(\"std\");\n\n// This is also available as `std.c.printf`.\npub extern \"c\" fn printf(format: [*:0]const u8, ...) c_int;\n\npub fn main() anyerror!void {\n    _ = printf(\"Hello, world!\\n\"); // OK\n\n    const msg = \"Hello, world!\\n\";\n    const non_null_terminated_msg: [msg.len]u8 = msg.*;\n    _ = printf(&non_null_terminated_msg);\n}\n```\n\nsentinel-terminated_pointer.zig\n\n            $ zig build-exe sentinel-terminated_pointer.zig -lc\n    /home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: error: expected type '[*:0]const u8', found '*const [14]u8'\n        _ = printf(&non_null_terminated_msg);\n                   ^~~~~~~~~~~~~~~~~~~~~~~~\n    /home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: note: destination pointer requires '0' sentinel\n    /home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:4:35: note: parameter type declared here\n    pub extern \"c\" fn printf(format: [*:0]const u8, ...) c_int;\n                                     ~^~~~~~~~~~~~\n    referenced by:\n        callMain: /home/andy/src/zig/lib/std/start.zig:524:32\n        callMainWithArgs: /home/andy/src/zig/lib/std/start.zig:482:12\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\n\n          \n\nShell\n\nSee also:\n\n- [Sentinel-Terminated Slices](#Sentinel-Terminated-Slices)\n- [Sentinel-Terminated Arrays](#Sentinel-Terminated-Arrays)\n\n&nbsp;"
- name: 'Pointers: volatile'
  id: index#volatile
  summary: Loads and stores are assumed to not have side effects
  description: "### volatile\n\nLoads and stores are assumed to not have side effects. If a given load or store should have side effects, such as Memory Mapped Input/Output (MMIO), use `volatile`. In the following code, loads and stores with `mmio_ptr` are guaranteed to all happen and in the same order as in source code:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"volatile\" {\n    const mmio_ptr: *volatile u8 = @ptrFromInt(0x12345678);\n    try expect(@TypeOf(mmio_ptr) == *volatile u8);\n}\n```\n\ntest_volatile.zig\n\n            $ zig test test_volatile.zig\n    1/1 test_volatile.test.volatile...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nNote that `volatile` is unrelated to concurrency and [Atomics](#Atomics). If you see code that is using `volatile` for something other than Memory Mapped Input/Output, it is probably a bug.\n\n[@ptrCast](#ptrCast) converts a pointer's element type to another. This creates a new pointer that can cause undetectable illegal behavior depending on the loads and stores that pass through it. Generally, other kinds of type conversions are preferable to `@ptrCast` if possible.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"pointer casting\" {\n    const bytes align(@alignOf(u32)) = [_]u8{ 0x12, 0x12, 0x12, 0x12 };\n    const u32_ptr: *const u32 = @ptrCast(&bytes);\n    try expect(u32_ptr.* == 0x12121212);\n\n    // Even this example is contrived - there are better ways to do the above than\n    // pointer casting. For example, using a slice narrowing cast:\n    const u32_value = std.mem.bytesAsSlice(u32, bytes[0..])[0];\n    try expect(u32_value == 0x12121212);\n\n    // And even another way, the most straightforward way to do it:\n    try expect(@as(u32, @bitCast(bytes)) == 0x12121212);\n}\n\ntest \"pointer child type\" {\n    // pointer types have a `child` field which tells you the type they point to.\n    try expect(@typeInfo(*u32).Pointer.child == u32);\n}\n```\n\ntest_pointer_casting.zig\n\n            $ zig test test_pointer_casting.zig\n    1/2 test_pointer_casting.test.pointer casting...OK\n    2/2 test_pointer_casting.test.pointer child type...OK\n    All 2 tests passed.\n\n          \n\nShell"
- name: Result Location Semantics
  id: index#Result-Location-Semantics
  summary: During compilation, every Zig expression and sub-expression is assigned optional result location information
  description: |-
    ## Result Location Semantics

    During compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to `_`, for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory location to place it in.

    As a motivating example, consider the statement `const`` x: ``u32`` = ``42``;`. The type annotation here provides a result type of `u32` to the initialization expression `42`, instructing the compiler to coerce this integer (initally of type `comptime_int`) to this type. We will see more examples shortly.

    This is not an implementation detail: the logic outlined above is codified into the Zig language specification, and is the primary mechanism of type inference in the language. This system is collectively referred to as "Result Location Semantics".
- name: 'Result Location Semantics: Result Locations'
  id: index#Result-Locations
  summary: 'In addition to result type information, every expression may be optionally assigned a result location: a pointer to which the value must be directly written'
  description: "### Result Locations\n\nIn addition to result type information, every expression may be optionally assigned a result location: a pointer to which the value must be directly written. This system can be used to prevent intermediate copies when initializing data structures, which can be important for types which must have a fixed memory address (\"pinned\" types).\n\nWhen compiling the simple assignment expression `x = e`, many languages would create the temporary value `e` on the stack, and then assign it to `x`, potentially performing a type coercion in the process. Zig approaches this differently. The expression `e` is given a result type matching the type of `x`, and a result location of `&x`. For many syntactic forms of `e`, this has no practical impact. However, it can have important semantic effects when working with more complex syntax forms.\n\nFor instance, if the expression `.{ .a = x, .b = y }` has a result location of `ptr`, then `x` is given a result location of `&ptr.a`, and `y` a result location of `&ptr.b`. Without this system, this expression would construct a temporary struct value entirely on the stack, and only then copy it to the destination address. In essence, Zig desugars the assignment `foo = .{ .a = x, .b = y }` to the two statements `foo.a = x; foo.b = y;`.\n\nThis can sometimes be important when assigning an aggregate value where the initialization expression depends on the previous value of the aggregate. The easiest way to demonstrate this is by attempting to swap fields of a struct or array - the following logic looks sound, but in fact is not:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\ntest \"attempt to swap array elements with array initializer\" {\n    var arr: [2]u32 = .{ 1, 2 };\n    arr = .{ arr[1], arr[0] };\n    // The previous line is equivalent to the following two lines:\n    //   arr[0] = arr[1];\n    //   arr[1] = arr[0];\n    // So this fails!\n    try expect(arr[0] == 2); // succeeds\n    try expect(arr[1] == 1); // fails\n}\n```\n\nresult_location_interfering_with_swap.zig\n\n            $ zig test result_location_interfering_with_swap.zig\n    1/1 result_location_interfering_with_swap.test.attempt to swap array elements with array initializer...FAIL (TestUnexpectedResult)\n    /home/andy/src/zig/lib/std/testing.zig:540:14: 0x103ce1f in expect (test)\n        if (!ok) return error.TestUnexpectedResult;\n                 ^\n    /home/andy/src/zig/doc/langref/result_location_interfering_with_swap.zig:10:5: 0x103cf85 in test.attempt to swap array elements with array initializer (test)\n        try expect(arr[1] == 1); // fails\n        ^\n    0 passed; 0 skipped; 1 failed.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/c42c6019fdf548f70655aafe3673a46e/test\n\n          \n\nShell\n\nThe following table details how some common expressions propagate result locations, where `x` and `y` are arbitrary sub-expressions. Note that some expressions cannot provide meaningful result locations to sub-expressions, even if they themselves have a result location.\n\n| Expression           | Result Location | Sub-expression Result Locations                                                   |\n|----------------------|-----------------|-----------------------------------------------------------------------------------|\n| `const`` val: T = x` | \\-              | `x` has result location `&val`                                                    |\n| `var`` val: T = x`   | \\-              | `x` has result location `&val`                                                    |\n| `val = x`            | \\-              | `x` has result location `&val`                                                    |\n| `@as``(T, x)`        | `ptr`           | `x` has no result location                                                        |\n| `&x`                 | `ptr`           | `x` has no result location                                                        |\n| `f(x)`               | `ptr`           | `x` has no result location                                                        |\n| `.{x}`               | `ptr`           | `x` has result location `&ptr[``0``]`                                             |\n| `.{ .a = x }`        | `ptr`           | `x` has result location `&ptr.a`                                                  |\n| `T{x}`               | `ptr`           | `x` has no result location (typed initializers do not propagate result locations) |\n| `T{ .a = x }`        | `ptr`           | `x` has no result location (typed initializers do not propagate result locations) |\n| `@Type``(x)`         | `ptr`           | `x` has no result location                                                        |\n| `@typeInfo``(x)`     | `ptr`           | `x` has no result location                                                        |\n| `x << y`             | `ptr`           | `x` and `y` do not have result locations                                          |"
- name: 'Result Location Semantics: Result Types'
  id: index#Result-Types
  summary: Result types are propagated recursively through expressions where possible
  description: "### Result Types\n\nResult types are propagated recursively through expressions where possible. For instance, if the expression `&e` has result type `*``u32`, then `e` is given a result type of `u32`, allowing the language to perform this coercion before taking a reference.\n\nThe result type mechanism is utilized by casting builtins such as `@intCast`. Rather than taking as an argument the type to cast to, these builtins use their result type to determine this information. The result type is often known from context; where it is not, the `@as` builtin can be used to explicitly provide a result type.\n\nWe can break down the result types for each component of a simple expression as follows:\n\n``` zig\nconst expectEqual = @import(\"std\").testing.expectEqual;\ntest \"result type propagates through struct initializer\" {\n    const S = struct { x: u32 };\n    const val: u64 = 123;\n    const s: S = .{ .x = @intCast(val) };\n    // .{ .x = @intCast(val) }   has result type `S` due to the type annotation\n    //         @intCast(val)     has result type `u32` due to the type of the field `S.x`\n    //                  val      has no result type, as it is permitted to be any integer type\n    try expectEqual(@as(u32, 123), s.x);\n}\n```\n\nresult_type_propagation.zig\n\n            $ zig test result_type_propagation.zig\n    1/1 result_type_propagation.test.result type propagates through struct initializer...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nThis result type information is useful for the aforementioned cast builtins, as well as to avoid the construction of pre-coercion values, and to avoid the need for explicit type coercions in some cases. The following table details how some common expressions propagate result types, where `x` and `y` are arbitrary sub-expressions.\n\n| Expression           | Parent Result Type | Sub-expression Result Type                      |\n|----------------------|--------------------|-------------------------------------------------|\n| `const`` val: T = x` | \\-                 | `x` is a `T`                                    |\n| `var`` val: T = x`   | \\-                 | `x` is a `T`                                    |\n| `val = x`            | \\-                 | `x` is a `@TypeOf``(val)`                       |\n| `@as``(T, x)`        | \\-                 | `x` is a `T`                                    |\n| `&x`                 | `*T`               | `x` is a `T`                                    |\n| `&x`                 | `[]T`              | `x` is some array of `T`                        |\n| `f(x)`               | \\-                 | `x` has the type of the first parameter of `f`  |\n| `.{x}`               | `T`                | `x` is a `std.meta.FieldType(T, .@\"0\")`         |\n| `.{ .a = x }`        | `T`                | `x` is a `std.meta.FieldType(T, .a)`            |\n| `T{x}`               | \\-                 | `x` is a `std.meta.FieldType(T, .@\"0\")`         |\n| `T{ .a = x }`        | \\-                 | `x` is a `std.meta.FieldType(T, .a)`            |\n| `@Type``(x)`         | \\-                 | `x` is a `std.builtin.Type`                     |\n| `@typeInfo``(x)`     | \\-                 | `x` is a `type`                                 |\n| `x << y`             | \\-                 | `y` is a `std.math.Log2IntCeil(``@TypeOf``(x))` |"
- name: Root Source File
  id: index#Root-Source-File
  summary: null
  description: |-
    ## Root Source File

    TODO: explain how root source file finds other files

    TODO: pub fn main

    TODO: pub fn panic

    TODO: if linking with libc you can use export fn main

    TODO: order independent top level declarations

    TODO: lazy analysis

    TODO: using comptime { \_ = @import() }
- name: Single Threaded Builds
  id: index#Single-Threaded-Builds
  summary: null
  description: |-
    ## Single Threaded Builds

    Zig has a compile option -fsingle-threaded which has the following effects:

    - All [Thread Local Variables](#Thread-Local-Variables) are treated as regular [Container Level Variables](#Container-Level-Variables).
    - The overhead of [Async Functions](#Async-Functions) becomes equivalent to function call overhead.
    - The `@import``(``"builtin"``).single_threaded` becomes `true` and therefore various userland APIs which read this variable become more efficient. For example `std.Mutex` becomes an empty data structure and all of its functions become no-ops.

    &nbsp;
- name: Slices
  id: index#Slices
  summary: A slice is a pointer and a length
  description: "## Slices\n\nA slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the \\`len\\` field.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\nconst expectEqualSlices = @import(\"std\").testing.expectEqualSlices;\n\ntest \"basic slices\" {\n    var array = [_]i32{ 1, 2, 3, 4 };\n    var known_at_runtime_zero: usize = 0;\n    _ = &known_at_runtime_zero;\n    const slice = array[known_at_runtime_zero..array.len];\n\n    // alternative initialization using result location\n    const alt_slice: []const i32 = &.{ 1, 2, 3, 4 };\n\n    try expectEqualSlices(i32, slice, alt_slice);\n\n    try expect(@TypeOf(slice) == []i32);\n    try expect(&slice[0] == &array[0]);\n    try expect(slice.len == array.len);\n\n    // If you slice with comptime-known start and end positions, the result is\n    // a pointer to an array, rather than a slice.\n    const array_ptr = array[0..array.len];\n    try expect(@TypeOf(array_ptr) == *[array.len]i32);\n\n    // You can perform a slice-by-length by slicing twice. This allows the compiler\n    // to perform some optimisations like recognising a comptime-known length when\n    // the start position is only known at runtime.\n    var runtime_start: usize = 1;\n    _ = &runtime_start;\n    const length = 2;\n    const array_ptr_len = array[runtime_start..][0..length];\n    try expect(@TypeOf(array_ptr_len) == *[length]i32);\n\n    // Using the address-of operator on a slice gives a single-item pointer.\n    try expect(@TypeOf(&slice[0]) == *i32);\n    // Using the `ptr` field gives a many-item pointer.\n    try expect(@TypeOf(slice.ptr) == [*]i32);\n    try expect(@intFromPtr(slice.ptr) == @intFromPtr(&slice[0]));\n\n    // Slices have array bounds checking. If you try to access something out\n    // of bounds, you'll get a safety check failure:\n    slice[10] += 1;\n\n    // Note that `slice.ptr` does not invoke safety checking, while `&slice[0]`\n    // asserts that the slice has len > 0.\n}\n```\n\ntest_basic_slices.zig\n\n            $ zig test test_basic_slices.zig\n    1/1 test_basic_slices.test.basic slices...thread 3571722 panic: index out of bounds: index 10, len 4\n    /home/andy/src/zig/doc/langref/test_basic_slices.zig:41:10: 0x103f955 in test.basic slices (test)\n        slice[10] += 1;\n             ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104c800 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x104210b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103fe49 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103f9b1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/3c391d75c939ce98356b98dd812503b1/test\n\n          \n\nShell\n\nThis is one reason we prefer slices to pointers.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\nconst fmt = std.fmt;\n\ntest \"using slices for strings\" {\n    // Zig has no concept of strings. String literals are const pointers\n    // to null-terminated arrays of u8, and by convention parameters\n    // that are \"strings\" are expected to be UTF-8 encoded slices of u8.\n    // Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8\n    const hello: []const u8 = \"hello\";\n    const world: []const u8 = \"世界\";\n\n    var all_together: [100]u8 = undefined;\n    // You can use slice syntax with at least one runtime-known index on an\n    // array to convert an array into a slice.\n    var start: usize = 0;\n    _ = &start;\n    const all_together_slice = all_together[start..];\n    // String concatenation example.\n    const hello_world = try fmt.bufPrint(all_together_slice, \"{s} {s}\", .{ hello, world });\n\n    // Generally, you can use UTF-8 and not worry about whether something is a\n    // string. If you don't need to deal with individual characters, no need\n    // to decode.\n    try expect(mem.eql(u8, hello_world, \"hello 世界\"));\n}\n\ntest \"slice pointer\" {\n    var array: [10]u8 = undefined;\n    const ptr = &array;\n    try expect(@TypeOf(ptr) == *[10]u8);\n\n    // A pointer to an array can be sliced just like an array:\n    var start: usize = 0;\n    var end: usize = 5;\n    _ = .{ &start, &end };\n    const slice = ptr[start..end];\n    // The slice is mutable because we sliced a mutable pointer.\n    try expect(@TypeOf(slice) == []u8);\n    slice[2] = 3;\n    try expect(array[2] == 3);\n\n    // Again, slicing with comptime-known indexes will produce another pointer\n    // to an array:\n    const ptr2 = slice[2..3];\n    try expect(ptr2.len == 1);\n    try expect(ptr2[0] == 3);\n    try expect(@TypeOf(ptr2) == *[1]u8);\n}\n```\n\ntest_slices.zig\n\n            $ zig test test_slices.zig\n    1/2 test_slices.test.using slices for strings...OK\n    2/2 test_slices.test.slice pointer...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [Pointers](#Pointers)\n- [for](#for)\n- [Arrays](#Arrays)\n\n&nbsp;"
- name: 'Slices: Sentinel-Terminated Slices'
  id: index#Sentinel-Terminated-Slices
  summary: The syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at the element indexed by the length
  description: "### Sentinel-Terminated Slices\n\nThe syntax `[:x]T` is a slice which has a runtime-known length and also guarantees a sentinel value at the element indexed by the length. The type does not guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element access to the `len` index.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"0-terminated slice\" {\n    const slice: [:0]const u8 = \"hello\";\n\n    try expect(slice.len == 5);\n    try expect(slice[5] == 0);\n}\n```\n\ntest_null_terminated_slice.zig\n\n            $ zig test test_null_terminated_slice.zig\n    1/1 test_null_terminated_slice.test.0-terminated slice...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSentinel-terminated slices can also be created using a variation of the slice syntax `data[start..end :x]`, where `data` is a many-item pointer, array or slice and `x` is the sentinel value.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"0-terminated slicing\" {\n    var array = [_]u8{ 3, 2, 1, 0, 3, 2, 1, 0 };\n    var runtime_length: usize = 3;\n    _ = &runtime_length;\n    const slice = array[0..runtime_length :0];\n\n    try expect(@TypeOf(slice) == [:0]u8);\n    try expect(slice.len == 3);\n}\n```\n\ntest_null_terminated_slicing.zig\n\n            $ zig test test_null_terminated_slicing.zig\n    1/1 test_null_terminated_slicing.test.0-terminated slicing...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSentinel-terminated slicing asserts that the element in the sentinel position of the backing data is actually the sentinel value. If this is not the case, safety-protected [Undefined Behavior](#Undefined-Behavior) results.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"sentinel mismatch\" {\n    var array = [_]u8{ 3, 2, 1, 0 };\n\n    // Creating a sentinel-terminated slice from the array with a length of 2\n    // will result in the value `1` occupying the sentinel element position.\n    // This does not match the indicated sentinel value of `0` and will lead\n    // to a runtime panic.\n    var runtime_length: usize = 2;\n    _ = &runtime_length;\n    const slice = array[0..runtime_length :0];\n\n    _ = slice;\n}\n```\n\ntest_sentinel_mismatch.zig\n\n            $ zig test test_sentinel_mismatch.zig\n    1/1 test_sentinel_mismatch.test.sentinel mismatch...thread 3579807 panic: sentinel mismatch: expected 0, found 1\n    /home/andy/src/zig/doc/langref/test_sentinel_mismatch.zig:13:24: 0x103cf16 in test.sentinel mismatch (test)\n        const slice = array[0..runtime_length :0];\n                           ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048aa0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103eabb in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d4f9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103d061 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/2af8da0d34d396fbb50fa515cef10c72/test\n\n          \n\nShell\n\nSee also:\n\n- [Sentinel-Terminated Pointers](#Sentinel-Terminated-Pointers)\n- [Sentinel-Terminated Arrays](#Sentinel-Terminated-Arrays)\n\n&nbsp;"
- name: Source Encoding
  id: index#Source-Encoding
  summary: Zig source code is encoded in UTF-8
  description: |-
    ## Source Encoding

    Zig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error.

    Throughout all zig source code (including in comments), some code points are never allowed:

    - Ascii control characters, except for U+000a (LF), U+000d (CR), and U+0009 (HT): U+0000 - U+0008, U+000b - U+000c, U+000e - U+0001f, U+007f.
    - Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS).

    LF (byte value 0x0a, code point U+000a, `'\n'`) is the line terminator in Zig source code. This byte value terminates every line of zig source code except the last line of the file. It is recommended that non-empty source files end with an empty line, which means the last byte would be 0x0a (LF).

    Each LF may be immediately preceded by a single CR (byte value 0x0d, code point U+000d, `'\r'`) to form a Windows style line ending, but this is discouraged. Note that in multiline strings, CRLF sequences will be encoded as LF when compiled into a zig program. A CR in any other context is not allowed.

    HT hard tabs (byte value 0x09, code point U+0009, `'\t'`) are interchangeable with SP spaces (byte value 0x20, code point U+0020, `' '`) as a token separator, but use of hard tabs is discouraged. See [Grammar](#Grammar).

    For compatibility with other tools, the compiler ignores a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark is not allowed anywhere else in the source.

    Note that running zig fmt on a source file will implement all recommendations mentioned here.

    Note that a tool reading Zig source code can make assumptions if the source code is assumed to be correct Zig code. For example, when identifying the ends of lines, a tool can use a naive search such as `/\n/`, or an [advanced](https://msdn.microsoft.com/en-us/library/dd409797.aspx) search such as `/\r\n?|[\n\u0085\u2028\u2029]/`, and in either case line endings will be correctly identified. For another example, when identifying the whitespace before the first token on a line, a tool can either use a naive search such as `/[ \t]/`, or an [advanced](https://tc39.es/ecma262/#sec-characterclassescape) search such as `/\s/`, and in either case whitespace will be correctly identified.
- name: struct
  id: index#struct
  summary: null
  description: "## struct\n\n``` zig\n// Declare a struct.\n// Zig gives no guarantees about the order of fields and the size of\n// the struct but the fields are guaranteed to be ABI-aligned.\nconst Point = struct {\n    x: f32,\n    y: f32,\n};\n\n// Maybe we want to pass it to OpenGL so we want to be particular about\n// how the bytes are arranged.\nconst Point2 = packed struct {\n    x: f32,\n    y: f32,\n};\n\n// Declare an instance of a struct.\nconst p = Point{\n    .x = 0.12,\n    .y = 0.34,\n};\n\n// Maybe we're not ready to fill out some of the fields.\nvar p2 = Point{\n    .x = 0.12,\n    .y = undefined,\n};\n\n// Structs can have methods\n// Struct methods are not special, they are only namespaced\n// functions that you can call with dot syntax.\nconst Vec3 = struct {\n    x: f32,\n    y: f32,\n    z: f32,\n\n    pub fn init(x: f32, y: f32, z: f32) Vec3 {\n        return Vec3{\n            .x = x,\n            .y = y,\n            .z = z,\n        };\n    }\n\n    pub fn dot(self: Vec3, other: Vec3) f32 {\n        return self.x * other.x + self.y * other.y + self.z * other.z;\n    }\n};\n\nconst expect = @import(\"std\").testing.expect;\ntest \"dot product\" {\n    const v1 = Vec3.init(1.0, 0.0, 0.0);\n    const v2 = Vec3.init(0.0, 1.0, 0.0);\n    try expect(v1.dot(v2) == 0.0);\n\n    // Other than being available to call with dot syntax, struct methods are\n    // not special. You can reference them as any other declaration inside\n    // the struct:\n    try expect(Vec3.dot(v1, v2) == 0.0);\n}\n\n// Structs can have declarations.\n// Structs can have 0 fields.\nconst Empty = struct {\n    pub const PI = 3.14;\n};\ntest \"struct namespaced variable\" {\n    try expect(Empty.PI == 3.14);\n    try expect(@sizeOf(Empty) == 0);\n\n    // you can still instantiate an empty struct\n    const does_nothing = Empty{};\n\n    _ = does_nothing;\n}\n\n// struct field order is determined by the compiler for optimal performance.\n// however, you can still calculate a struct base pointer given a field pointer:\nfn setYBasedOnX(x: *f32, y: f32) void {\n    const point: *Point = @fieldParentPtr(\"x\", x);\n    point.y = y;\n}\ntest \"field parent pointer\" {\n    var point = Point{\n        .x = 0.1234,\n        .y = 0.5678,\n    };\n    setYBasedOnX(&point.x, 0.9);\n    try expect(point.y == 0.9);\n}\n\n// You can return a struct from a function. This is how we do generics\n// in Zig:\nfn LinkedList(comptime T: type) type {\n    return struct {\n        pub const Node = struct {\n            prev: ?*Node,\n            next: ?*Node,\n            data: T,\n        };\n\n        first: ?*Node,\n        last: ?*Node,\n        len: usize,\n    };\n}\n\ntest \"linked list\" {\n    // Functions called at compile-time are memoized. This means you can\n    // do this:\n    try expect(LinkedList(i32) == LinkedList(i32));\n\n    const list = LinkedList(i32){\n        .first = null,\n        .last = null,\n        .len = 0,\n    };\n    try expect(list.len == 0);\n\n    // Since types are first class values you can instantiate the type\n    // by assigning it to a variable:\n    const ListOfInts = LinkedList(i32);\n    try expect(ListOfInts == LinkedList(i32));\n\n    var node = ListOfInts.Node{\n        .prev = null,\n        .next = null,\n        .data = 1234,\n    };\n    const list2 = LinkedList(i32){\n        .first = &node,\n        .last = &node,\n        .len = 1,\n    };\n\n    // When using a pointer to a struct, fields can be accessed directly,\n    // without explicitly dereferencing the pointer.\n    // So you can do\n    try expect(list2.first.?.data == 1234);\n    // instead of try expect(list2.first.?.*.data == 1234);\n}\n```\n\ntest_structs.zig\n\n            $ zig test test_structs.zig\n    1/4 test_structs.test.dot product...OK\n    2/4 test_structs.test.struct namespaced variable...OK\n    3/4 test_structs.test.field parent pointer...OK\n    4/4 test_structs.test.linked list...OK\n    All 4 tests passed.\n\n          \n\nShell"
- name: 'struct: Anonymous Struct Literals'
  id: index#Anonymous-Struct-Literals
  summary: Zig allows omitting the struct type of a literal
  description: "### Anonymous Struct Literals\n\nZig allows omitting the struct type of a literal. When the result is [coerced](#Type-Coercion), the struct literal will directly instantiate the [result location](#Result-Location-Semantics), with no copy:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Point = struct { x: i32, y: i32 };\n\ntest \"anonymous struct literal\" {\n    const pt: Point = .{\n        .x = 13,\n        .y = 67,\n    };\n    try expect(pt.x == 13);\n    try expect(pt.y == 67);\n}\n```\n\ntest_struct_result.zig\n\n            $ zig test test_struct_result.zig\n    1/1 test_struct_result.test.anonymous struct literal...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nThe struct type can be inferred. Here the [result location](#Result-Location-Semantics) does not include a type, and so Zig infers the type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"fully anonymous struct\" {\n    try check(.{\n        .int = @as(u32, 1234),\n        .float = @as(f64, 12.34),\n        .b = true,\n        .s = \"hi\",\n    });\n}\n\nfn check(args: anytype) !void {\n    try expect(args.int == 1234);\n    try expect(args.float == 12.34);\n    try expect(args.b);\n    try expect(args.s[0] == 'h');\n    try expect(args.s[1] == 'i');\n}\n```\n\ntest_anonymous_struct.zig\n\n            $ zig test test_anonymous_struct.zig\n    1/1 test_anonymous_struct.test.fully anonymous struct...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'struct: Default Field Values'
  id: index#Default-Field-Values
  summary: Each struct field may have an expression indicating the default field value
  description: "### Default Field Values\n\nEach struct field may have an expression indicating the default field value. Such expressions are executed at [comptime](#comptime), and allow the field to be omitted in a struct literal expression:\n\n``` zig\nconst Foo = struct {\n    a: i32 = 1234,\n    b: i32,\n};\n\ntest \"default struct initialization fields\" {\n    const x: Foo = .{\n        .b = 5,\n    };\n    if (x.a + x.b != 1239) {\n        comptime unreachable;\n    }\n}\n```\n\nstruct_default_field_values.zig\n\n            $ zig test struct_default_field_values.zig\n    1/1 struct_default_field_values.test.default struct initialization fields...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nDefault field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization.\n\nFor example, here is an inappropriate use of default struct field initialization:\n\n``` zig\nconst Threshold = struct {\n    minimum: f32 = 0.25,\n    maximum: f32 = 0.75,\n\n    const Category = enum { low, medium, high };\n\n    fn categorize(t: Threshold, value: f32) Category {\n        assert(t.maximum >= t.minimum);\n        if (value < t.minimum) return .low;\n        if (value > t.maximum) return .high;\n        return .medium;\n    }\n};\n\npub fn main() !void {\n    var threshold: Threshold = .{\n        .maximum = 0.20,\n    };\n    const category = threshold.categorize(0.90);\n    try std.io.getStdOut().writeAll(@tagName(category));\n}\n\nconst std = @import(\"std\");\nconst assert = std.debug.assert;\n```\n\nbad_default_value.zig\n\n            $ zig build-exe bad_default_value.zig\n    $ ./bad_default_value\n    thread 3570319 panic: reached unreachable code\n    /home/andy/src/zig/lib/std/debug.zig:412:14: 0x1037a6d in assert (bad_default_value)\n        if (!ok) unreachable; // assertion failure\n                 ^\n    /home/andy/src/zig/doc/langref/bad_default_value.zig:8:15: 0x1034f59 in categorize (bad_default_value)\n            assert(t.maximum >= t.minimum);\n                  ^\n    /home/andy/src/zig/doc/langref/bad_default_value.zig:19:42: 0x1034e8a in main (bad_default_value)\n        const category = threshold.categorize(0.90);\n                                             ^\n    /home/andy/src/zig/lib/std/start.zig:524:37: 0x1034da5 in posixCallMainAndExit (bad_default_value)\n                const result = root.main() catch |err| {\n                                        ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10348c1 in _start (bad_default_value)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell\n\nAbove you can see the danger of ignoring this principle. The default field values caused the data invariant to be violated, causing illegal behavior.\n\nTo fix this, remove the default values from all the struct fields, and provide a named default value:\n\n``` zig\nconst Threshold = struct {\n    minimum: f32,\n    maximum: f32,\n\n    const default: Threshold = .{\n        .minimum = 0.25,\n        .maximum = 0.75,\n    };\n};\n```\n\nstruct_default_value.zig\n\nIf a struct value requires a runtime-known value in order to be initialized without violating data invariants, then use an initialization method that accepts those runtime values, and populates the remaining fields."
- name: 'struct: extern struct'
  id: index#extern-struct
  summary: An extern``struct has in-memory layout matching the C ABI for the target
  description: |-
    ### extern struct

    An `extern``struct` has in-memory layout matching the C ABI for the target.

    If well-defined in-memory layout is not required, [struct](#struct) is a better choice because it places fewer restrictions on the compiler.

    See [packed struct](#packed-struct) for a struct that has the ABI of its backing integer, which can be useful for modeling flags.

    See also:

    - [extern union](#extern-union)
    - [extern enum](#extern-enum)

    &nbsp;
- name: 'struct: packed struct'
  id: index#packed-struct
  summary: This means that a packed``struct can participate in a @bitCast or a @ptrCast to reinterpret memory
  description: "### packed struct\n\nUnlike normal structs, `packed` structs have guaranteed in-memory layout:\n\n- Fields remain in the order declared, least to most significant.\n- There is no padding between fields.\n- Zig supports arbitrary width [Integers](#Integers) and although normally, integers with fewer than 8 bits will still use 1 byte of memory, in packed structs, they use exactly their bit width.\n- `bool` fields use exactly 1 bit.\n- An [enum](#enum) field uses exactly the bit width of its integer tag type.\n- A [packed union](#packed-union) field uses exactly the bit width of the union field with the largest bit width.\n\nThis means that a `packed``struct` can participate in a [@bitCast](#bitCast) or a [@ptrCast](#ptrCast) to reinterpret memory. This even works at [comptime](#comptime):\n\n``` zig\nconst std = @import(\"std\");\nconst native_endian = @import(\"builtin\").target.cpu.arch.endian();\nconst expect = std.testing.expect;\n\nconst Full = packed struct {\n    number: u16,\n};\nconst Divided = packed struct {\n    half1: u8,\n    quarter3: u4,\n    quarter4: u4,\n};\n\ntest \"@bitCast between packed structs\" {\n    try doTheTest();\n    try comptime doTheTest();\n}\n\nfn doTheTest() !void {\n    try expect(@sizeOf(Full) == 2);\n    try expect(@sizeOf(Divided) == 2);\n    const full = Full{ .number = 0x1234 };\n    const divided: Divided = @bitCast(full);\n    try expect(divided.half1 == 0x34);\n    try expect(divided.quarter3 == 0x2);\n    try expect(divided.quarter4 == 0x1);\n\n    const ordered: [2]u8 = @bitCast(full);\n    switch (native_endian) {\n        .big => {\n            try expect(ordered[0] == 0x12);\n            try expect(ordered[1] == 0x34);\n        },\n        .little => {\n            try expect(ordered[0] == 0x34);\n            try expect(ordered[1] == 0x12);\n        },\n    }\n}\n```\n\ntest_packed_structs.zig\n\n            $ zig test test_packed_structs.zig\n    1/1 test_packed_structs.test.@bitCast between packed structs...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nThe backing integer is inferred from the fields' total bit width. Optionally, it can be explicitly provided and enforced at compile time:\n\n``` zig\ntest \"missized packed struct\" {\n    const S = packed struct(u32) { a: u16, b: u8 };\n    _ = S{ .a = 4, .b = 2 };\n}\n```\n\ntest_missized_packed_struct.zig\n\n            $ zig test test_missized_packed_struct.zig\n    doc/langref/test_missized_packed_struct.zig:2:29: error: backing integer type 'u32' has bit size 32 but the struct fields have a total bit size of 24\n        const S = packed struct(u32) { a: u16, b: u8 };\n                                ^~~\n\n\n          \n\nShell\n\nZig allows the address to be taken of a non-byte-aligned field:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\nvar foo = BitField{\n    .a = 1,\n    .b = 2,\n    .c = 3,\n};\n\ntest \"pointer to non-byte-aligned field\" {\n    const ptr = &foo.b;\n    try expect(ptr.* == 2);\n}\n```\n\ntest_pointer_to_non-byte_aligned_field.zig\n\n            $ zig test test_pointer_to_non-byte_aligned_field.zig\n    1/1 test_pointer_to_non-byte_aligned_field.test.pointer to non-byte-aligned field...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nHowever, the pointer to a non-byte-aligned field has special properties and cannot be passed when a normal pointer is expected:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\nvar bit_field = BitField{\n    .a = 1,\n    .b = 2,\n    .c = 3,\n};\n\ntest \"pointer to non-byte-aligned field\" {\n    try expect(bar(&bit_field.b) == 2);\n}\n\nfn bar(x: *const u3) u3 {\n    return x.*;\n}\n```\n\ntest_misaligned_pointer.zig\n\n            $ zig test test_misaligned_pointer.zig\n    doc/langref/test_misaligned_pointer.zig:17:20: error: expected type '*const u3', found '*align(1:3:1) u3'\n        try expect(bar(&bit_field.b) == 2);\n                       ^~~~~~~~~~~~\n    doc/langref/test_misaligned_pointer.zig:17:20: note: pointer host size '1' cannot cast into pointer host size '0'\n    doc/langref/test_misaligned_pointer.zig:17:20: note: pointer bit offset '3' cannot cast into pointer bit offset '0'\n    doc/langref/test_misaligned_pointer.zig:20:11: note: parameter type declared here\n    fn bar(x: *const u3) u3 {\n              ^~~~~~~~~\n\n\n          \n\nShell\n\nIn this case, the function `bar` cannot be called because the pointer to the non-ABI-aligned field mentions the bit offset, but the function expects an ABI-aligned pointer.\n\nPointers to non-ABI-aligned fields share the same address as the other fields within their host integer:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\nvar bit_field = BitField{\n    .a = 1,\n    .b = 2,\n    .c = 3,\n};\n\ntest \"pointers of sub-byte-aligned fields share addresses\" {\n    try expect(@intFromPtr(&bit_field.a) == @intFromPtr(&bit_field.b));\n    try expect(@intFromPtr(&bit_field.a) == @intFromPtr(&bit_field.c));\n}\n```\n\ntest_packed_struct_field_address.zig\n\n            $ zig test test_packed_struct_field_address.zig\n    1/1 test_packed_struct_field_address.test.pointers of sub-byte-aligned fields share addresses...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nThis can be observed with [@bitOffsetOf](#bitOffsetOf) and [offsetOf](#offsetOf):\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\ntest \"offsets of non-byte-aligned fields\" {\n    comptime {\n        try expect(@bitOffsetOf(BitField, \"a\") == 0);\n        try expect(@bitOffsetOf(BitField, \"b\") == 3);\n        try expect(@bitOffsetOf(BitField, \"c\") == 6);\n\n        try expect(@offsetOf(BitField, \"a\") == 0);\n        try expect(@offsetOf(BitField, \"b\") == 0);\n        try expect(@offsetOf(BitField, \"c\") == 0);\n    }\n}\n```\n\ntest_bitOffsetOf_offsetOf.zig\n\n            $ zig test test_bitOffsetOf_offsetOf.zig\n    1/1 test_bitOffsetOf_offsetOf.test.offsets of non-byte-aligned fields...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nPacked structs have the same alignment as their backing integer, however, overaligned pointers to packed structs can override this:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst S = packed struct {\n    a: u32,\n    b: u32,\n};\ntest \"overaligned pointer to packed struct\" {\n    var foo: S align(4) = .{ .a = 1, .b = 2 };\n    const ptr: *align(4) S = &foo;\n    const ptr_to_b: *u32 = &ptr.b;\n    try expect(ptr_to_b.* == 2);\n}\n```\n\ntest_overaligned_packed_struct.zig\n\n            $ zig test test_overaligned_packed_struct.zig\n    1/1 test_overaligned_packed_struct.test.overaligned pointer to packed struct...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nIt's also possible to set alignment of struct fields:\n\n``` zig\nconst std = @import(\"std\");\nconst expectEqual = std.testing.expectEqual;\n\ntest \"aligned struct fields\" {\n    const S = struct {\n        a: u32 align(2),\n        b: u32 align(64),\n    };\n    var foo = S{ .a = 1, .b = 2 };\n\n    try expectEqual(64, @alignOf(S));\n    try expectEqual(*align(2) u32, @TypeOf(&foo.a));\n    try expectEqual(*align(64) u32, @TypeOf(&foo.b));\n}\n```\n\ntest_aligned_struct_fields.zig\n\n            $ zig test test_aligned_struct_fields.zig\n    1/1 test_aligned_struct_fields.test.aligned struct fields...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nUsing packed structs with [volatile](#volatile) is problematic, and may be a compile error in the future. For details on this subscribe to [this issue](https://github.com/ziglang/zig/issues/1761). TODO update these docs with a recommendation on how to use packed structs with MMIO (the use case for volatile packed structs) once this issue is resolved. Don't worry, there will be a good solution for this use case in zig."
- name: 'struct: Struct Naming'
  id: index#Struct-Naming
  summary: Since all structs are anonymous, Zig infers the type name based on a few rules
  description: "### Struct Naming\n\nSince all structs are anonymous, Zig infers the type name based on a few rules.\n\n- If the struct is in the initialization expression of a variable, it gets named after that variable.\n- If the struct is in the `return` expression, it gets named after the function it is returning from, with the parameter values serialized.\n- Otherwise, the struct gets a name such as `(filename.funcname.__struct_ID)`.\n- If the struct is declared inside another struct, it gets named after both the parent struct and the name inferred by the previous rules, separated by a dot.\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    const Foo = struct {};\n    std.debug.print(\"variable: {s}\\n\", .{@typeName(Foo)});\n    std.debug.print(\"anonymous: {s}\\n\", .{@typeName(struct {})});\n    std.debug.print(\"function: {s}\\n\", .{@typeName(List(i32))});\n}\n\nfn List(comptime T: type) type {\n    return struct {\n        x: T,\n    };\n}\n```\n\nstruct_name.zig\n\n            $ zig build-exe struct_name.zig\n    $ ./struct_name\n    variable: struct_name.main.Foo\n    anonymous: struct_name.main__struct_3331\n    function: struct_name.List(i32)\n\n          \n\nShell"
- name: 'struct: Tuples'
  id: index#Tuples
  summary: The fields are implicitly named using numbers starting from 0
  description: "### Tuples\n\nAnonymous structs can be created without specifying field names, and are referred to as \"tuples\".\n\nThe fields are implicitly named using numbers starting from 0. Because their names are integers, they cannot be accessed with `.` syntax without also wrapping them in `@\"\"`. Names inside `@\"\"` are always recognised as [identifiers](#Identifiers).\n\nLike arrays, tuples have a .len field, can be indexed (provided the index is comptime-known) and work with the ++ and \\*\\* operators. They can also be iterated over with [inline for](#inline-for).\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"tuple\" {\n    const values = .{\n        @as(u32, 1234),\n        @as(f64, 12.34),\n        true,\n        \"hi\",\n    } ++ .{false} ** 2;\n    try expect(values[0] == 1234);\n    try expect(values[4] == false);\n    inline for (values, 0..) |v, i| {\n        if (i != 2) continue;\n        try expect(v);\n    }\n    try expect(values.len == 6);\n    try expect(values.@\"3\"[0] == 'h');\n}\n```\n\ntest_tuples.zig\n\n            $ zig test test_tuples.zig\n    1/1 test_tuples.test.tuple...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [comptime](#comptime)\n- [@fieldParentPtr](#fieldParentPtr)\n\n&nbsp;"
- name: Style Guide
  id: index#Style-Guide
  summary: These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style
  description: |-
    ## Style Guide

    These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style.
- name: 'Style Guide: Avoid Redundancy in Names'
  id: index#Avoid-Redundancy-in-Names
  summary: Everything is a value, all types are data, everything is context, all logic manages state
  description: |-
    ### Avoid Redundancy in Names

    Avoid these words in type names:

    - Value
    - Data
    - Context
    - Manager
    - utils, misc, or somebody's initials

    Everything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word that applies to all types.

    Temptation to use "utilities", "miscellaneous", or somebody's initials is a failure to categorize, or more commonly, overcategorization. Such declarations can live at the root of a module that needs them with no namespace needed.
- name: 'Style Guide: Avoid Redundant Names in Fully-Qualified Namespaces'
  id: index#Avoid-Redundant-Names-in-Fully-Qualified-Namespaces
  summary: Every declaration is assigned a fully qualified namespace by the compiler, creating a tree structure
  description: "### Avoid Redundant Names in Fully-Qualified Namespaces\n\nEvery declaration is assigned a **fully qualified namespace** by the compiler, creating a tree structure. Choose names based on the fully-qualified namespace, and avoid redundant name segments.\n\n``` zig\nconst std = @import(\"std\");\n\npub const json = struct {\n    pub const JsonValue = union(enum) {\n        number: f64,\n        boolean: bool,\n        // ...\n    };\n};\n\npub fn main() void {\n    std.debug.print(\"{s}\\n\", .{@typeName(json.JsonValue)});\n}\n```\n\nredundant_fqn.zig\n\n            $ zig build-exe redundant_fqn.zig\n    $ ./redundant_fqn\n    redundant_fqn.json.JsonValue\n\n          \n\nShell\n\nIn this example, \"json\" is repeated in the fully-qualified namespace. The solution is to delete `Json` from `JsonValue`. In this example we have an empty struct named `json` but remember that files also act as part of the fully-qualified namespace.\n\nThis example is an exception to the rule specified in [Avoid Redundancy in Names](#Avoid-Redundancy-in-Names). The meaning of the type has been reduced to its core: it is a json value. The name cannot be any more specific without being incorrect."
- name: 'Style Guide: Doc Comment Guidance'
  id: index#Doc-Comment-Guidance
  summary: null
  description: |-
    ### Doc Comment Guidance

    - Omit any information that is redundant based on the name of the thing being documented.
    - Duplicating information onto multiple similar functions is encouraged because it helps IDEs and other tools provide better help text.
    - Use the word **assume** to indicate invariants that cause [Undefined Behavior](#Undefined-Behavior) when violated.
    - Use the word **assert** to indicate invariants that cause *safety-checked* [Undefined Behavior](#Undefined-Behavior) when violated.

    &nbsp;
- name: 'Style Guide: Examples'
  id: index#Examples
  summary: See the Zig Standard Library for more examples
  description: |-
    ### Examples

    ``` zig
    const namespace_name = @import("dir_name/file_name.zig");
    const TypeName = @import("dir_name/TypeName.zig");
    var global_var: i32 = undefined;
    const const_name = 42;
    const primitive_type_alias = f32;
    const string_alias = []u8;

    const StructName = struct {
        field: i32,
    };
    const StructAlias = StructName;

    fn functionName(param_name: TypeName) void {
        var functionPointer = functionName;
        functionPointer();
        functionPointer = otherFunction;
        functionPointer();
    }
    const functionAlias = functionName;

    fn ListTemplateFunction(comptime ChildType: type, comptime fixed_size: usize) type {
        return List(ChildType, fixed_size);
    }

    fn ShortList(comptime T: type, comptime n: usize) type {
        return struct {
            field_name: [n]T,
            fn methodName() void {}
        };
    }

    // The word XML loses its casing when used in Zig identifiers.
    const xml_document =
        \\<?xml version="1.0" encoding="UTF-8"?>
        \\<document>
        \\</document>
    ;
    const XmlParser = struct {
        field: i32,
    };

    // The initials BE (Big Endian) are just another word in Zig identifier names.
    fn readU32Be() u32 {}
    ```

    style_example.zig

    See the [Zig Standard Library](#Zig-Standard-Library) for more examples.
- name: 'Style Guide: Names'
  id: index#Names
  summary: 'Roughly speaking: camelCaseFunctionName, TitleCaseTypeName, snake_case_variable_name'
  description: |-
    ### Names

    Roughly speaking: `camelCaseFunctionName`, `TitleCaseTypeName`, `snake_case_variable_name`. More precisely:

    - If `x` is a `type` then `x` should be `TitleCase`, unless it is a `struct` with 0 fields and is never meant to be instantiated, in which case it is considered to be a "namespace" and uses `snake_case`.
    - If `x` is callable, and `x`'s return type is `type`, then `x` should be `TitleCase`.
    - If `x` is otherwise callable, then `x` should be `camelCase`.
    - Otherwise, `x` should be `snake_case`.

    Acronyms, initialisms, proper nouns, or any other word that has capitalization rules in written English are subject to naming conventions just like any other word. Even acronyms that are only 2 letters long are subject to these conventions.

    File names fall into two categories: types and namespaces. If the file (implicitly a struct) has top level fields, it should be named like any other struct with fields using `TitleCase`. Otherwise, it should use `snake_case`. Directory names should be `snake_case`.

    These are general rules of thumb; if it makes sense to do something different, do what makes sense. For example, if there is an established convention such as `ENOENT`, follow the established convention.
- name: 'Style Guide: Whitespace'
  id: index#Whitespace
  summary: null
  description: |-
    ### Whitespace

    - 4 space indentation
    - Open braces on same line, unless you need to wrap.
    - If a list of things is longer than 2, put each item on its own line and exercise the ability to put an extra comma at the end.
    - Line length: aim for 100; use common sense.

    &nbsp;
- name: switch
  id: index#switch
  summary: switch can be used to capture the field values of a Tagged union
  description: "## switch\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\n\ntest \"switch simple\" {\n    const a: u64 = 10;\n    const zz: u64 = 103;\n\n    // All branches of a switch expression must be able to be coerced to a\n    // common type.\n    //\n    // Branches cannot fallthrough. If fallthrough behavior is desired, combine\n    // the cases and use an if.\n    const b = switch (a) {\n        // Multiple cases can be combined via a ','\n        1, 2, 3 => 0,\n\n        // Ranges can be specified using the ... syntax. These are inclusive\n        // of both ends.\n        5...100 => 1,\n\n        // Branches can be arbitrarily complex.\n        101 => blk: {\n            const c: u64 = 5;\n            break :blk c * 2 + 1;\n        },\n\n        // Switching on arbitrary expressions is allowed as long as the\n        // expression is known at compile-time.\n        zz => zz,\n        blk: {\n            const d: u32 = 5;\n            const e: u32 = 100;\n            break :blk d + e;\n        } => 107,\n\n        // The else branch catches everything not already captured.\n        // Else branches are mandatory unless the entire range of values\n        // is handled.\n        else => 9,\n    };\n\n    try expect(b == 1);\n}\n\n// Switch expressions can be used outside a function:\nconst os_msg = switch (builtin.target.os.tag) {\n    .linux => \"we found a linux user\",\n    else => \"not a linux user\",\n};\n\n// Inside a function, switch statements implicitly are compile-time\n// evaluated if the target expression is compile-time known.\ntest \"switch inside function\" {\n    switch (builtin.target.os.tag) {\n        .fuchsia => {\n            // On an OS other than fuchsia, block is not even analyzed,\n            // so this compile error is not triggered.\n            // On fuchsia this compile error would be triggered.\n            @compileError(\"fuchsia not supported\");\n        },\n        else => {},\n    }\n}\n```\n\ntest_switch.zig\n\n            $ zig test test_switch.zig\n    1/2 test_switch.test.switch simple...OK\n    2/2 test_switch.test.switch inside function...OK\n    All 2 tests passed.\n\n          \n\nShell\n\n`switch` can be used to capture the field values of a [Tagged union](#Tagged-union). Modifications to the field values can be done by placing a `*` before the capture variable name, turning it into a pointer.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"switch on tagged union\" {\n    const Point = struct {\n        x: u8,\n        y: u8,\n    };\n    const Item = union(enum) {\n        a: u32,\n        c: Point,\n        d,\n        e: u32,\n    };\n\n    var a = Item{ .c = Point{ .x = 1, .y = 2 } };\n\n    // Switching on more complex enums is allowed.\n    const b = switch (a) {\n        // A capture group is allowed on a match, and will return the enum\n        // value matched. If the payload types of both cases are the same\n        // they can be put into the same switch prong.\n        Item.a, Item.e => |item| item,\n\n        // A reference to the matched value can be obtained using `*` syntax.\n        Item.c => |*item| blk: {\n            item.*.x += 1;\n            break :blk 6;\n        },\n\n        // No else is required if the types cases was exhaustively handled\n        Item.d => 8,\n    };\n\n    try expect(b == 6);\n    try expect(a.c.x == 2);\n}\n```\n\ntest_switch_tagged_union.zig\n\n            $ zig test test_switch_tagged_union.zig\n    1/1 test_switch_tagged_union.test.switch on tagged union...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [comptime](#comptime)\n- [enum](#enum)\n- [@compileError](#compileError)\n- [Compile Variables](#Compile-Variables)\n\n&nbsp;"
- name: 'switch: Exhaustive Switching'
  id: index#Exhaustive-Switching
  summary: When a switch expression does not have an else clause, it must exhaustively list all the possible values
  description: "### Exhaustive Switching\n\nWhen a `switch` expression does not have an `else` clause, it must exhaustively list all the possible values. Failure to do so is a compile error:\n\n``` zig\nconst Color = enum {\n    auto,\n    off,\n    on,\n};\n\ntest \"exhaustive switching\" {\n    const color = Color.off;\n    switch (color) {\n        Color.auto => {},\n        Color.on => {},\n    }\n}\n```\n\ntest_unhandled_enumeration_value.zig\n\n            $ zig test test_unhandled_enumeration_value.zig\n    doc/langref/test_unhandled_enumeration_value.zig:9:5: error: switch must handle all possibilities\n        switch (color) {\n        ^~~~~~\n    doc/langref/test_unhandled_enumeration_value.zig:3:5: note: unhandled enumeration value: 'off'\n        off,\n        ^~~\n    doc/langref/test_unhandled_enumeration_value.zig:1:15: note: enum 'test_unhandled_enumeration_value.Color' declared here\n    const Color = enum {\n                  ^~~~\n\n\n          \n\nShell"
- name: 'switch: Inline Switch Prongs'
  id: index#Inline-Switch-Prongs
  summary: Switch prongs can be marked as inline to generate the prong's body for each possible value it could have, making the captured value comptime
  description: "### Inline Switch Prongs\n\nSwitch prongs can be marked as `inline` to generate the prong's body for each possible value it could have, making the captured value [comptime](#comptime).\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst expectError = std.testing.expectError;\n\nfn isFieldOptional(comptime T: type, field_index: usize) !bool {\n    const fields = @typeInfo(T).Struct.fields;\n    return switch (field_index) {\n        // This prong is analyzed twice with `idx` being a\n        // comptime-known value each time.\n        inline 0, 1 => |idx| @typeInfo(fields[idx].type) == .Optional,\n        else => return error.IndexOutOfBounds,\n    };\n}\n\nconst Struct1 = struct { a: u32, b: ?u32 };\n\ntest \"using @typeInfo with runtime values\" {\n    var index: usize = 0;\n    try expect(!try isFieldOptional(Struct1, index));\n    index += 1;\n    try expect(try isFieldOptional(Struct1, index));\n    index += 1;\n    try expectError(error.IndexOutOfBounds, isFieldOptional(Struct1, index));\n}\n\n// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent\n// of this function:\nfn isFieldOptionalUnrolled(field_index: usize) !bool {\n    return switch (field_index) {\n        0 => false,\n        1 => true,\n        else => return error.IndexOutOfBounds,\n    };\n}\n```\n\ntest_inline_switch.zig\n\n            $ zig test test_inline_switch.zig\n    1/1 test_inline_switch.test.using @typeInfo with runtime values...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nThe `inline` keyword may also be combined with ranges:\n\n``` zig\nfn isFieldOptional(comptime T: type, field_index: usize) !bool {\n    const fields = @typeInfo(T).Struct.fields;\n    return switch (field_index) {\n        inline 0...fields.len - 1 => |idx| @typeInfo(fields[idx].type) == .Optional,\n        else => return error.IndexOutOfBounds,\n    };\n}\n```\n\ninline_prong_range.zig\n\n`inline``else` prongs can be used as a type safe alternative to `inline``for` loops:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst SliceTypeA = extern struct {\n    len: usize,\n    ptr: [*]u32,\n};\nconst SliceTypeB = extern struct {\n    ptr: [*]SliceTypeA,\n    len: usize,\n};\nconst AnySlice = union(enum) {\n    a: SliceTypeA,\n    b: SliceTypeB,\n    c: []const u8,\n    d: []AnySlice,\n};\n\nfn withFor(any: AnySlice) usize {\n    const Tag = @typeInfo(AnySlice).Union.tag_type.?;\n    inline for (@typeInfo(Tag).Enum.fields) |field| {\n        // With `inline for` the function gets generated as\n        // a series of `if` statements relying on the optimizer\n        // to convert it to a switch.\n        if (field.value == @intFromEnum(any)) {\n            return @field(any, field.name).len;\n        }\n    }\n    // When using `inline for` the compiler doesn't know that every\n    // possible case has been handled requiring an explicit `unreachable`.\n    unreachable;\n}\n\nfn withSwitch(any: AnySlice) usize {\n    return switch (any) {\n        // With `inline else` the function is explicitly generated\n        // as the desired switch and the compiler can check that\n        // every possible case is handled.\n        inline else => |slice| slice.len,\n    };\n}\n\ntest \"inline for and inline else similarity\" {\n    const any = AnySlice{ .c = \"hello\" };\n    try expect(withFor(any) == 5);\n    try expect(withSwitch(any) == 5);\n}\n```\n\ntest_inline_else.zig\n\n            $ zig test test_inline_else.zig\n    1/1 test_inline_else.test.inline for and inline else similarity...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nWhen using an inline prong switching on an union an additional capture can be used to obtain the union's enum tag value.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst U = union(enum) {\n    a: u32,\n    b: f32,\n};\n\nfn getNum(u: U) u32 {\n    switch (u) {\n        // Here `num` is a runtime-known value that is either\n        // `u.a` or `u.b` and `tag` is `u`'s comptime-known tag value.\n        inline else => |num, tag| {\n            if (tag == .b) {\n                return @intFromFloat(num);\n            }\n            return num;\n        },\n    }\n}\n\ntest \"test\" {\n    const u = U{ .b = 42 };\n    try expect(getNum(u) == 42);\n}\n```\n\ntest_inline_switch_union_tag.zig\n\n            $ zig test test_inline_switch_union_tag.zig\n    1/1 test_inline_switch_union_tag.test.test...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nSee also:\n\n- [inline while](#inline-while)\n- [inline for](#inline-for)\n\n&nbsp;"
- name: 'switch: Switching with Enum Literals'
  id: index#Switching-with-Enum-Literals
  summary: null
  description: "### Switching with Enum Literals\n\n[Enum Literals](#Enum-Literals) can be useful to use with `switch` to avoid repetitively specifying [enum](#enum) or [union](#union) types:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Color = enum {\n    auto,\n    off,\n    on,\n};\n\ntest \"enum literals with switch\" {\n    const color = Color.off;\n    const result = switch (color) {\n        .auto => false,\n        .on => false,\n        .off => true,\n    };\n    try expect(result);\n}\n```\n\ntest_exhaustive_switch.zig\n\n            $ zig test test_exhaustive_switch.zig\n    1/1 test_exhaustive_switch.test.enum literals with switch...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: Table of Contents
  id: index#table-of-contents
  summary: Zig is a general-purpose programming language and toolchain for maintaining robust, optimal, and reusable software
  description: "# Zig Language Reference\n\n## Introduction\n\n[Zig](https://ziglang.org) is a general-purpose programming language and toolchain for maintaining **robust**, **optimal**, and **reusable** software.\n\nRobust  \nBehavior is correct even for edge cases such as out of memory.\n\nOptimal  \nWrite programs the best way they can behave and perform.\n\nReusable  \nThe same code works in many environments which have different constraints.\n\nMaintainable  \nPrecisely communicate intent to the compiler and other programmers. The language imposes a low overhead to reading code and is resilient to changing requirements and environments.\n\nOften the most efficient way to learn something new is to see examples, so this documentation shows how to use each of Zig's features. It is all on one page so you can search with your browser's search tool.\n\nThe code samples in this document are compiled and tested as part of the main test suite of Zig.\n\nThis HTML document depends on no external files, so you can use it offline.\n\n## Zig Standard Library\n\nThe [Zig Standard Library](https://ziglang.org/documentation/master/std/) has its own documentation.\n\nZig's Standard Library contains commonly used algorithms, data structures, and definitions to help you build programs or libraries. You will see many examples of Zig's Standard Library used in this documentation. To learn more about the Zig Standard Library, visit the link above.\n\n## Hello World\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n```\n\nhello.zig\n\n    $ zig build-exe hello.zig\n    $ ./hello\n    Hello, world!\n\nShell\n\nMost of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. For this common case, there is a simpler API:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    std.debug.print(\"Hello, world!\\n\", .{});\n}\n```\n\nhello_again.zig\n\n    $ zig build-exe hello_again.zig\n    $ ./hello_again\n    Hello, world!\n\nShell\n\nIn this case, the `!` may be omitted from the return type because no errors are returned from the function.\n\nSee also:\n\n- [Values](#Values)\n- [@import](#import)\n- [Errors](#Errors)\n- [Root Source File](#Root-Source-File)\n- [Source Encoding](#Source-Encoding)\n\n## Comments\n\nZig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation.\n\nThe generated documentation is still experimental, and can be produced with:\n\n    zig test -femit-docs main.zig\n\nShell\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    // Comments in Zig start with \"//\" and end at the next LF byte (end of line).\n    // The line below is a comment and won't be executed.\n\n    //print(\"Hello?\", .{});\n\n    print(\"Hello, world!\\n\", .{}); // another comment\n}\n```\n\ncomments.zig\n\n    $ zig build-exe comments.zig\n    $ ./comments\n    Hello, world!\n\nShell\n\nThere are no multiline comments in Zig (e.g. like `/* */` comments in C). This allows Zig to have the property that each line of code can be tokenized out of context.\n\n### Doc Comments\n\nA doc comment is one that begins with exactly three slashes (i.e. `///` but not `////`); multiple doc comments in a row are merged together to form a multiline doc comment. The doc comment documents whatever immediately follows it.\n\n``` zig\n/// A structure for storing a timestamp, with nanosecond precision (this is a\n/// multiline doc comment).\nconst Timestamp = struct {\n    /// The number of seconds since the epoch (this is also a doc comment).\n    seconds: i64, // signed so we can represent pre-1970 (not a doc comment)\n    /// The number of nanoseconds past the second (doc comment again).\n    nanos: u32,\n\n    /// Returns a `Timestamp` struct representing the Unix epoch; that is, the\n    /// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).\n    pub fn unixEpoch() Timestamp {\n        return Timestamp{\n            .seconds = 0,\n            .nanos = 0,\n        };\n    }\n};\n```\n\ndoc_comments.zig\n\nDoc comments are only allowed in certain places; it is a compile error to have a doc comment in an unexpected place, such as in the middle of an expression, or just before a non-doc comment.\n\n``` zig\n/// doc-comment\n//! top-level doc-comment\nconst std = @import(\"std\");\n```\n\ninvalid_doc-comment.zig\n\n    $ zig build-obj invalid_doc-comment.zig\n    doc/langref/invalid_doc-comment.zig:1:16: error: expected type expression, found 'a document comment'\n    /// doc-comment\n                   ^\n\nShell\n\n``` zig\npub fn main() void {}\n\n/// End of file\n```\n\nunattached_doc-comment.zig\n\n    $ zig build-obj unattached_doc-comment.zig\n    doc/langref/unattached_doc-comment.zig:3:1: error: unattached documentation comment\n    /// End of file\n    ^~~~~~~~~~~~~~~\n\nShell\n\nDoc comments can be interleaved with normal comments. Currently, when producing the package documentation, normal comments are merged with doc comments.\n\n### Top-Level Doc Comments\n\nA top-level doc comment is one that begins with two slashes and an exclamation point: `//!`; it documents the current module.\n\nIt is a compile error if a top-level doc comment is not placed at the start of a [container](#Containers), before any expressions.\n\n``` zig\n//! This module provides functions for retrieving the current date and\n//! time with varying degrees of precision and accuracy. It does not\n//! depend on libc, but will use functions from it if available.\n\nconst S = struct {\n    //! Top level comments are allowed inside a container other than a module,\n    //! but it is not very useful.  Currently, when producing the package\n    //! documentation, these comments are ignored.\n};\n```\n\ntldoc_comments.zig\n\n## Values\n\n``` zig\n// Top-level declarations are order-independent:\nconst print = std.debug.print;\nconst std = @import(\"std\");\nconst os = std.os;\nconst assert = std.debug.assert;\n\npub fn main() void {\n    // integers\n    const one_plus_one: i32 = 1 + 1;\n    print(\"1 + 1 = {}\\n\", .{one_plus_one});\n\n    // floats\n    const seven_div_three: f32 = 7.0 / 3.0;\n    print(\"7.0 / 3.0 = {}\\n\", .{seven_div_three});\n\n    // boolean\n    print(\"{}\\n{}\\n{}\\n\", .{\n        true and false,\n        true or false,\n        !true,\n    });\n\n    // optional\n    var optional_value: ?[]const u8 = null;\n    assert(optional_value == null);\n\n    print(\"\\noptional 1\\ntype: {}\\nvalue: {?s}\\n\", .{\n        @TypeOf(optional_value), optional_value,\n    });\n\n    optional_value = \"hi\";\n    assert(optional_value != null);\n\n    print(\"\\noptional 2\\ntype: {}\\nvalue: {?s}\\n\", .{\n        @TypeOf(optional_value), optional_value,\n    });\n\n    // error union\n    var number_or_error: anyerror!i32 = error.ArgNotFound;\n\n    print(\"\\nerror union 1\\ntype: {}\\nvalue: {!}\\n\", .{\n        @TypeOf(number_or_error),\n        number_or_error,\n    });\n\n    number_or_error = 1234;\n\n    print(\"\\nerror union 2\\ntype: {}\\nvalue: {!}\\n\", .{\n        @TypeOf(number_or_error), number_or_error,\n    });\n}\n```\n\nvalues.zig\n\n    $ zig build-exe values.zig\n    $ ./values\n    1 + 1 = 2\n    7.0 / 3.0 = 2.3333333e0\n    false\n    true\n    false\n\n    optional 1\n    type: ?[]const u8\n    value: null\n\n    optional 2\n    type: ?[]const u8\n    value: hi\n\n    error union 1\n    type: anyerror!i32\n    value: error.ArgNotFound\n\n    error union 2\n    type: anyerror!i32\n    value: 1234\n\nShell\n\n### Primitive Types\n\n| Type             | C Equivalent          | Description                                                                                   |\n|------------------|-----------------------|-----------------------------------------------------------------------------------------------|\n| `i8`             | `int8_t`              | signed 8-bit integer                                                                          |\n| `u8`             | `uint8_t`             | unsigned 8-bit integer                                                                        |\n| `i16`            | `int16_t`             | signed 16-bit integer                                                                         |\n| `u16`            | `uint16_t`            | unsigned 16-bit integer                                                                       |\n| `i32`            | `int32_t`             | signed 32-bit integer                                                                         |\n| `u32`            | `uint32_t`            | unsigned 32-bit integer                                                                       |\n| `i64`            | `int64_t`             | signed 64-bit integer                                                                         |\n| `u64`            | `uint64_t`            | unsigned 64-bit integer                                                                       |\n| `i128`           | `__int128`            | signed 128-bit integer                                                                        |\n| `u128`           | `unsigned __int128`   | unsigned 128-bit integer                                                                      |\n| `isize`          | `intptr_t`            | signed pointer sized integer                                                                  |\n| `usize`          | `uintptr_t`, `size_t` | unsigned pointer sized integer. Also see [\\#5185](https://github.com/ziglang/zig/issues/5185) |\n| `c_char`         | `char`                | for ABI compatibility with C                                                                  |\n| `c_short`        | `short`               | for ABI compatibility with C                                                                  |\n| `c_ushort`       | `unsigned short`      | for ABI compatibility with C                                                                  |\n| `c_int`          | `int`                 | for ABI compatibility with C                                                                  |\n| `c_uint`         | `unsigned int`        | for ABI compatibility with C                                                                  |\n| `c_long`         | `long`                | for ABI compatibility with C                                                                  |\n| `c_ulong`        | `unsigned long`       | for ABI compatibility with C                                                                  |\n| `c_longlong`     | `long long`           | for ABI compatibility with C                                                                  |\n| `c_ulonglong`    | `unsigned long long`  | for ABI compatibility with C                                                                  |\n| `c_longdouble`   | `long double`         | for ABI compatibility with C                                                                  |\n| `f16`            | `_Float16`            | 16-bit floating point (10-bit mantissa) IEEE-754-2008 binary16                                |\n| `f32`            | `float`               | 32-bit floating point (23-bit mantissa) IEEE-754-2008 binary32                                |\n| `f64`            | `double`              | 64-bit floating point (52-bit mantissa) IEEE-754-2008 binary64                                |\n| `f80`            | `double`              | 80-bit floating point (64-bit mantissa) IEEE-754-2008 80-bit extended precision               |\n| `f128`           | `_Float128`           | 128-bit floating point (112-bit mantissa) IEEE-754-2008 binary128                             |\n| `bool`           | `bool`                | `true` or `false`                                                                             |\n| `anyopaque`      | `void`                | Used for type-erased pointers.                                                                |\n| `void`           | (none)                | Always the value `void``{}`                                                                   |\n| `noreturn`       | (none)                | the type of `break`, `continue`, `return`, `unreachable`, and `while`` (``true``) {}`         |\n| `type`           | (none)                | the type of types                                                                             |\n| `anyerror`       | (none)                | an error code                                                                                 |\n| `comptime_int`   | (none)                | Only allowed for [comptime](#comptime)-known values. The type of integer literals.            |\n| `comptime_float` | (none)                | Only allowed for [comptime](#comptime)-known values. The type of float literals.              |\n\nPrimitive Types\n\nIn addition to the integer types above, arbitrary bit-width integers can be referenced by using an identifier of `i` or `u` followed by digits. For example, the identifier `i7` refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is `65535`.\n\nSee also:\n\n- [Integers](#Integers)\n- [Floats](#Floats)\n- [void](#void)\n- [Errors](#Errors)\n- [@Type](#Type)\n\n### Primitive Values\n\n| Name               | Description                            |\n|--------------------|----------------------------------------|\n| `true` and `false` | `bool` values                          |\n| `null`             | used to set an optional type to `null` |\n| `undefined`        | used to leave a value unspecified      |\n\nPrimitive Values\n\nSee also:\n\n- [Optionals](#Optionals)\n- [undefined](#undefined)\n\n### String Literals and Unicode Code Point Literals\n\nString literals are constant single-item [Pointers](#Pointers) to null-terminated byte arrays. The type of string literals encodes both the length, and the fact that they are null-terminated, and thus they can be [coerced](#Type-Coercion) to both [Slices](#Slices) and [Null-Terminated Pointers](#Sentinel-Terminated-Pointers). Dereferencing string literals converts them to [Arrays](#Arrays).\n\nBecause Zig source code is [UTF-8 encoded](#Source-Encoding), any non-ASCII bytes appearing within a string literal in source code carry their UTF-8 meaning into the content of the string in the Zig program; the bytes are not modified by the compiler. It is possible to embed non-UTF-8 bytes into a string literal using `\\xNN` notation.\n\nIndexing into a string containing non-ASCII bytes returns individual bytes, whether valid UTF-8 or not.\n\nUnicode code point literals have type `comptime_int`, the same as [Integer Literals](#Integer-Literals). All [Escape Sequences](#Escape-Sequences) are valid in both string literals and Unicode code point literals.\n\n``` zig\nconst print = @import(\"std\").debug.print;\nconst mem = @import(\"std\").mem; // will be used to compare bytes\n\npub fn main() void {\n    const bytes = \"hello\";\n    print(\"{}\\n\", .{@TypeOf(bytes)}); // *const [5:0]u8\n    print(\"{d}\\n\", .{bytes.len}); // 5\n    print(\"{c}\\n\", .{bytes[1]}); // 'e'\n    print(\"{d}\\n\", .{bytes[5]}); // 0\n    print(\"{}\\n\", .{'e' == '\\x65'}); // true\n    print(\"{d}\\n\", .{'\\u{1f4a9}'}); // 128169\n    print(\"{d}\\n\", .{'💯'}); // 128175\n    print(\"{u}\\n\", .{'⚡'});\n    print(\"{}\\n\", .{mem.eql(u8, \"hello\", \"h\\x65llo\")}); // true\n    print(\"{}\\n\", .{mem.eql(u8, \"💯\", \"\\xf0\\x9f\\x92\\xaf\")}); // also true\n    const invalid_utf8 = \"\\xff\\xfe\"; // non-UTF-8 strings are possible with \\xNN notation.\n    print(\"0x{x}\\n\", .{invalid_utf8[1]}); // indexing them returns individual bytes...\n    print(\"0x{x}\\n\", .{\"💯\"[1]}); // ...as does indexing part-way through non-ASCII characters\n}\n```\n\nstring_literals.zig\n\n    $ zig build-exe string_literals.zig\n    $ ./string_literals\n    *const [5:0]u8\n    5\n    e\n    0\n    true\n    128169\n    128175\n    ⚡\n    true\n    true\n    0xfe\n    0x9f\n\nShell\n\nSee also:\n\n- [Arrays](#Arrays)\n- [Source Encoding](#Source-Encoding)\n\n#### [Escape Sequences](#toc-Escape-Sequences)\n\n| Escape Sequence | Name                                                            |\n|-----------------|-----------------------------------------------------------------|\n| `\\n`            | Newline                                                         |\n| `\\r`            | Carriage Return                                                 |\n| `\\t`            | Tab                                                             |\n| `\\\\`            | Backslash                                                       |\n| `\\'`            | Single Quote                                                    |\n| `\\\"`            | Double Quote                                                    |\n| `\\xNN`          | hexadecimal 8-bit byte value (2 digits)                         |\n| `\\u{NNNNNN}`    | hexadecimal Unicode code point UTF-8 encoded (1 or more digits) |\n\nEscape Sequences\n\nNote that the maximum valid Unicode point is `0x10ffff`.\n\n#### [Multiline String Literals](#toc-Multiline-String-Literals)\n\nMultiline string literals have no escapes and can span across multiple lines. To start a multiline string literal, use the `\\\\` token. Just like a comment, the string literal goes until the end of the line. The end of the line is not included in the string literal. However, if the next line begins with `\\\\` then a newline is appended and the string literal continues.\n\n``` zig\nconst hello_world_in_c =\n    \\\\#include <stdio.h>\n    \\\\\n    \\\\int main(int argc, char **argv) {\n    \\\\    printf(\"hello world\\n\");\n    \\\\    return 0;\n    \\\\}\n;\n```\n\nmultiline_string_literals.zig\n\nSee also:\n\n- [@embedFile](#embedFile)\n\n### Assignment\n\nUse the `const` keyword to assign a value to an identifier:\n\n``` zig\nconst x = 1234;\n\nfn foo() void {\n    // It works at file scope as well as inside functions.\n    const y = 5678;\n\n    // Once assigned, an identifier cannot be changed.\n    y += 1;\n}\n\npub fn main() void {\n    foo();\n}\n```\n\nconstant_identifier_cannot_change.zig\n\n    $ zig build-exe constant_identifier_cannot_change.zig\n    /home/andy/src/zig/doc/langref/constant_identifier_cannot_change.zig:8:7: error: cannot assign to constant\n        y += 1;\n        ~~^~~~\n    referenced by:\n        main: /home/andy/src/zig/doc/langref/constant_identifier_cannot_change.zig:12:5\n        callMain: /home/andy/src/zig/lib/std/start.zig:514:17\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\n`const` applies to all of the bytes that the identifier immediately addresses. [Pointers](#Pointers) have their own const-ness.\n\nIf you need a variable that you can modify, use the `var` keyword:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    var y: i32 = 5678;\n\n    y += 1;\n\n    print(\"{d}\", .{y});\n}\n```\n\nmutable_var.zig\n\n    $ zig build-exe mutable_var.zig\n    $ ./mutable_var\n    5679\n\nShell\n\nVariables must be initialized:\n\n``` zig\npub fn main() void {\n    var x: i32;\n\n    x = 1;\n}\n```\n\nvar_must_be_initialized.zig\n\n    $ zig build-exe var_must_be_initialized.zig\n    /home/andy/src/zig/doc/langref/var_must_be_initialized.zig:2:15: error: expected '=', found ';'\n        var x: i32;\n                  ^\n\nShell\n\n#### [undefined](#toc-undefined)\n\nUse `undefined` to leave variables uninitialized:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    var x: i32 = undefined;\n    x = 1;\n    print(\"{d}\", .{x});\n}\n```\n\nassign_undefined.zig\n\n    $ zig build-exe assign_undefined.zig\n    $ ./assign_undefined\n    1\n\nShell\n\n`undefined` can be [coerced](#Type-Coercion) to any type. Once this happens, it is no longer possible to detect that the value is `undefined`. `undefined` means the value could be anything, even something that is nonsense according to the type. Translated into English, `undefined` means \"Not a meaningful value. Using this value would be a bug. The value will be unused, or overwritten before being used.\"\n\nIn [Debug](#Debug) mode, Zig writes `0xaa` bytes to undefined memory. This is to catch bugs early, and to help detect use of undefined memory in a debugger. However, this behavior is only an implementation feature, not a language semantic, so it is not guaranteed to be observable to code.\n\n## Zig Test\n\nCode written within one or more `test` declarations can be used to ensure behavior meets expectations:\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"expect addOne adds one to 41\" {\n\n    // The Standard Library contains useful functions to help create tests.\n    // `expect` is a function that verifies its argument is true.\n    // It will return an error if its argument is false to indicate a failure.\n    // `try` is used to return an error to the test runner to notify it that the test failed.\n    try std.testing.expect(addOne(41) == 42);\n}\n\ntest addOne {\n    // A test name can also be written using an identifier.\n    // This is a doctest, and serves as documentation for `addOne`.\n    try std.testing.expect(addOne(41) == 42);\n}\n\n/// The function `addOne` adds one to the number given as its argument.\nfn addOne(number: i32) i32 {\n    return number + 1;\n}\n```\n\ntesting_introduction.zig\n\n    $ zig test testing_introduction.zig\n    1/2 testing_introduction.test.expect addOne adds one to 41...OK\n    2/2 testing_introduction.decltest.addOne...OK\n    All 2 tests passed.\n\nShell\n\nThe `testing_introduction.zig` code sample tests the [function](#Functions) `addOne` to ensure that it returns `42` given the input `41`. From this test's perspective, the `addOne` function is said to be *code under test*.\n\nzig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the *default test runner* provided by the [Zig Standard Library](#Zig-Standard-Library) as its main entry point. During the build, `test` declarations found while [resolving](#Root-Source-File) the given Zig source file are included for the default test runner to run and report on.\n\nThis documentation discusses the features of the default test runner as provided by the Zig Standard Library. Its source code is located in `lib/test_runner.zig`.\n\nThe shell output shown above displays two lines after the zig test command. These lines are printed to standard error by the default test runner:\n\n`1/2 testing_introduction.test.expect addOne adds one to 41...`  \nLines like this indicate which test, out of the total number of tests, is being run. In this case, `1/2` indicates that the first test, out of a total of two tests, is being run. Note that, when the test runner program's standard error is output to the terminal, these lines are cleared when a test succeeds.\n\n`2/2 testing_introduction.decltest.addOne...`  \nWhen the test name is an identifier, the default test runner uses the text decltest instead of test.\n\n`All 2 tests passed.`  \nThis line indicates the total number of tests that have passed.\n\n### Test Declarations\n\nTest declarations contain the [keyword](#Keyword-Reference) `test`, followed by an optional name written as a [string literal](#String-Literals-and-Unicode-Code-Point-Literals) or an [identifier](#Identifiers), followed by a [block](#Blocks) containing any valid Zig code that is allowed in a [function](#Functions).\n\nNon-named test blocks always run during test builds and are exempt from [Skip Tests](#Skip-Tests).\n\nTest declarations are similar to [Functions](#Functions): they have a return type and a block of code. The implicit return type of `test` is the [Error Union Type](#Error-Union-Type) `anyerror``!``void`, and it cannot be changed. When a Zig source file is not built using the zig test tool, the test declarations are omitted from the build.\n\nTest declarations can be written in the same file, where code under test is written, or in a separate Zig source file. Since test declarations are top-level declarations, they are order-independent and can be written before or after the code under test.\n\nSee also:\n\n- [The Global Error Set](#The-Global-Error-Set)\n- [Grammar](#Grammar)\n\n#### [Doctests](#toc-Doctests)\n\nTest declarations named using an identifier are *doctests*. The identifier must refer to another declaration in scope. A doctest, like a [doc comment](#Doc-Comments), serves as documentation for the associated declaration, and will appear in the generated documentation for the declaration.\n\nAn effective doctest should be self-contained and focused on the declaration being tested, answering questions a new user might have about its interface or intended usage, while avoiding unnecessary or confusing details. A doctest is not a substitute for a doc comment, but rather a supplement and companion providing a testable, code-driven example, verified by zig test.\n\n### Test Failure\n\nThe default test runner checks for an [error](#Errors) returned from a test. When a test returns an error, the test is considered a failure and its [error return trace](#Error-Return-Traces) is output to standard error. The total number of failures will be reported after all tests have run.\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"expect this to fail\" {\n    try std.testing.expect(false);\n}\n\ntest \"expect this to succeed\" {\n    try std.testing.expect(true);\n}\n```\n\ntesting_failure.zig\n\n    $ zig test testing_failure.zig\n    1/2 testing_failure.test.expect this to fail...FAIL (TestUnexpectedResult)\n    /home/andy/src/zig/lib/std/testing.zig:540:14: 0x103ce3f in expect (test)\n        if (!ok) return error.TestUnexpectedResult;\n                 ^\n    /home/andy/src/zig/doc/langref/testing_failure.zig:4:5: 0x103cf55 in test.expect this to fail (test)\n        try std.testing.expect(false);\n        ^\n    2/2 testing_failure.test.expect this to succeed...OK\n    1 passed; 0 skipped; 1 failed.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/054f0b6f088824f384d1b6c648523593/test\n\nShell\n\n### Skip Tests\n\nOne way to skip tests is to filter them out by using the zig test command line parameter --test-filter \\[text\\]. This makes the test build only include tests whose name contains the supplied filter text. Note that non-named tests are run even when using the --test-filter \\[text\\] command line parameter.\n\nTo programmatically skip a test, make a `test` return the error `error``.SkipZigTest` and the default test runner will consider the test as being skipped. The total number of skipped tests will be reported after all tests have run.\n\n``` zig\ntest \"this will be skipped\" {\n    return error.SkipZigTest;\n}\n```\n\ntesting_skip.zig\n\n    $ zig test testing_skip.zig\n    1/1 testing_skip.test.this will be skipped...SKIP\n    0 passed; 1 skipped; 0 failed.\n\nShell\n\n### Report Memory Leaks\n\nWhen code allocates [Memory](#Memory) using the [Zig Standard Library](#Zig-Standard-Library)'s testing allocator, `std.testing.allocator`, the default test runner will report any leaks that are found from using the testing allocator:\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"detect leak\" {\n    var list = std.ArrayList(u21).init(std.testing.allocator);\n    // missing `defer list.deinit();`\n    try list.append('☔');\n\n    try std.testing.expect(list.items.len == 1);\n}\n```\n\ntesting_detect_leak.zig\n\n    $ zig test testing_detect_leak.zig\n    1/1 testing_detect_leak.test.detect leak...OK\n    [gpa] (err): memory address 0x7fdbea69e000 leaked:\n    /home/andy/src/zig/lib/std/array_list.zig:457:67: 0x104f76e in ensureTotalCapacityPrecise (test)\n                    const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);\n                                                                      ^\n    /home/andy/src/zig/lib/std/array_list.zig:434:51: 0x1045610 in ensureTotalCapacity (test)\n                return self.ensureTotalCapacityPrecise(better_capacity);\n                                                      ^\n    /home/andy/src/zig/lib/std/array_list.zig:483:41: 0x1041fe0 in addOne (test)\n                try self.ensureTotalCapacity(newlen);\n                                            ^\n    /home/andy/src/zig/lib/std/array_list.zig:262:49: 0x103ef2d in append (test)\n                const new_item_ptr = try self.addOne();\n                                                    ^\n    /home/andy/src/zig/doc/langref/testing_detect_leak.zig:6:20: 0x103d172 in test.detect leak (test)\n        try list.append('☔');\n                       ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104c6a0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x10428bb in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103f429 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103ef91 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    All 1 tests passed.\n    1 errors were logged.\n    1 tests leaked memory.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/4a17198138bf81bcfabd5652b0d6be24/test\n\nShell\n\nSee also:\n\n- [defer](#defer)\n- [Memory](#Memory)\n\n### Detecting Test Build\n\nUse the [compile variable](#Compile-Variables) `@import``(``\"builtin\"``).is_test` to detect a test build:\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\n\ntest \"builtin.is_test\" {\n    try expect(isATest());\n}\n\nfn isATest() bool {\n    return builtin.is_test;\n}\n```\n\ntesting_detect_test.zig\n\n    $ zig test testing_detect_test.zig\n    1/1 testing_detect_test.test.builtin.is_test...OK\n    All 1 tests passed.\n\nShell\n\n### Test Output and Logging\n\nThe default test runner and the Zig Standard Library's testing namespace output messages to standard error.\n\n### The Testing Namespace\n\nThe Zig Standard Library's `testing` namespace contains useful functions to help you create tests. In addition to the `expect` function, this document uses a couple of more functions as exemplified here:\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"expectEqual demo\" {\n    const expected: i32 = 42;\n    const actual = 42;\n\n    // The first argument to `expectEqual` is the known, expected, result.\n    // The second argument is the result of some expression.\n    // The actual's type is casted to the type of expected.\n    try std.testing.expectEqual(expected, actual);\n}\n\ntest \"expectError demo\" {\n    const expected_error = error.DemoError;\n    const actual_error_union: anyerror!void = error.DemoError;\n\n    // `expectError` will fail when the actual error is different than\n    // the expected error.\n    try std.testing.expectError(expected_error, actual_error_union);\n}\n```\n\ntesting_namespace.zig\n\n    $ zig test testing_namespace.zig\n    1/2 testing_namespace.test.expectEqual demo...OK\n    2/2 testing_namespace.test.expectError demo...OK\n    All 2 tests passed.\n\nShell\n\nThe Zig Standard Library also contains functions to compare [Slices](#Slices), strings, and more. See the rest of the `std.testing` namespace in the [Zig Standard Library](#Zig-Standard-Library) for more available functions.\n\n### Test Tool Documentation\n\nzig test has a few command line parameters which affect the compilation. See zig test --help for a full list.\n\n## Variables\n\nA variable is a unit of [Memory](#Memory) storage.\n\nIt is generally preferable to use `const` rather than `var` when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities.\n\nThe `extern` keyword or [@extern](#extern) builtin function can be used to link against a variable that is exported from another object. The `export` keyword or [@export](#export) builtin function can be used to make a variable available to other objects at link time. In both cases, the type of the variable must be C ABI compatible.\n\nSee also:\n\n- [Exporting a C Library](#Exporting-a-C-Library)\n\n### Identifiers\n\nVariable identifiers are never allowed to shadow identifiers from an outer scope.\n\nIdentifiers must start with an alphabetic character or underscore and may be followed by any number of alphanumeric characters or underscores. They must not overlap with any keywords. See [Keyword Reference](#Keyword-Reference).\n\nIf a name that does not fit these requirements is needed, such as for linking with external libraries, the `@\"\"` syntax may be used.\n\n``` zig\nconst @\"identifier with spaces in it\" = 0xff;\nconst @\"1SmallStep4Man\" = 112358;\n\nconst c = @import(\"std\").c;\npub extern \"c\" fn @\"error\"() void;\npub extern \"c\" fn @\"fstat$INODE64\"(fd: c.fd_t, buf: *c.Stat) c_int;\n\nconst Color = enum {\n    red,\n    @\"really red\",\n};\nconst color: Color = .@\"really red\";\n```\n\nidentifiers.zig\n\n### Container Level Variables\n\n[Container](#Containers) level variables have static lifetime and are order-independent and lazily analyzed. The initialization value of container level variables is implicitly [comptime](#comptime). If a container level variable is `const` then its value is `comptime`-known, otherwise it is runtime-known.\n\n``` zig\nvar y: i32 = add(10, x);\nconst x: i32 = add(12, 34);\n\ntest \"container level variables\" {\n    try expect(x == 46);\n    try expect(y == 56);\n}\n\nfn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n```\n\ntest_container_level_variables.zig\n\n    $ zig test test_container_level_variables.zig\n    1/1 test_container_level_variables.test.container level variables...OK\n    All 1 tests passed.\n\nShell\n\nContainer level variables may be declared inside a [struct](#struct), [union](#union), [enum](#enum), or [opaque](#opaque):\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"namespaced container level variable\" {\n    try expect(foo() == 1235);\n    try expect(foo() == 1236);\n}\n\nconst S = struct {\n    var x: i32 = 1234;\n};\n\nfn foo() i32 {\n    S.x += 1;\n    return S.x;\n}\n```\n\ntest_namespaced_container_level_variable.zig\n\n    $ zig test test_namespaced_container_level_variable.zig\n    1/1 test_namespaced_container_level_variable.test.namespaced container level variable...OK\n    All 1 tests passed.\n\nShell\n\n### Static Local Variables\n\nIt is also possible to have local variables with static lifetime by using containers inside functions.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"static local variable\" {\n    try expect(foo() == 1235);\n    try expect(foo() == 1236);\n}\n\nfn foo() i32 {\n    const S = struct {\n        var x: i32 = 1234;\n    };\n    S.x += 1;\n    return S.x;\n}\n```\n\ntest_static_local_variable.zig\n\n    $ zig test test_static_local_variable.zig\n    1/1 test_static_local_variable.test.static local variable...OK\n    All 1 tests passed.\n\nShell\n\n### Thread Local Variables\n\nA variable may be specified to be a thread-local variable using the `threadlocal` keyword, which makes each thread work with a separate instance of the variable:\n\n``` zig\nconst std = @import(\"std\");\nconst assert = std.debug.assert;\n\nthreadlocal var x: i32 = 1234;\n\ntest \"thread local storage\" {\n    const thread1 = try std.Thread.spawn(.{}, testTls, .{});\n    const thread2 = try std.Thread.spawn(.{}, testTls, .{});\n    testTls();\n    thread1.join();\n    thread2.join();\n}\n\nfn testTls() void {\n    assert(x == 1234);\n    x += 1;\n    assert(x == 1235);\n}\n```\n\ntest_thread_local_variables.zig\n\n    $ zig test test_thread_local_variables.zig\n    1/1 test_thread_local_variables.test.thread local storage...OK\n    All 1 tests passed.\n\nShell\n\nFor [Single Threaded Builds](#Single-Threaded-Builds), all thread local variables are treated as regular [Container Level Variables](#Container-Level-Variables).\n\nThread local variables may not be `const`.\n\n### Local Variables\n\nLocal variables occur inside [Functions](#Functions), [comptime](#comptime) blocks, and [@cImport](#cImport) blocks.\n\nWhen a local variable is `const`, it means that after initialization, the variable's value will not change. If the initialization value of a `const` variable is [comptime](#comptime)-known, then the variable is also `comptime`-known.\n\nA local variable may be qualified with the `comptime` keyword. This causes the variable's value to be `comptime`-known, and all loads and stores of the variable to happen during semantic analysis of the program, rather than at runtime. All variables declared in a `comptime` expression are implicitly `comptime` variables.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"comptime vars\" {\n    var x: i32 = 1;\n    comptime var y: i32 = 1;\n\n    x += 1;\n    y += 1;\n\n    try expect(x == 2);\n    try expect(y == 2);\n\n    if (y != 2) {\n        // This compile error never triggers because y is a comptime variable,\n        // and so `y != 2` is a comptime value, and this if is statically evaluated.\n        @compileError(\"wrong y value\");\n    }\n}\n```\n\ntest_comptime_variables.zig\n\n    $ zig test test_comptime_variables.zig\n    1/1 test_comptime_variables.test.comptime vars...OK\n    All 1 tests passed.\n\nShell\n\n## Integers\n\n### Integer Literals\n\n``` zig\nconst decimal_int = 98222;\nconst hex_int = 0xff;\nconst another_hex_int = 0xFF;\nconst octal_int = 0o755;\nconst binary_int = 0b11110000;\n\n// underscores may be placed between two digits as a visual separator\nconst one_billion = 1_000_000_000;\nconst binary_mask = 0b1_1111_1111;\nconst permissions = 0o7_5_5;\nconst big_address = 0xFF80_0000_0000_0000;\n```\n\ninteger_literals.zig\n\n### Runtime Integer Values\n\nInteger literals have no size limitation, and if any undefined behavior occurs, the compiler catches it.\n\nHowever, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to undefined behavior.\n\n``` zig\nfn divide(a: i32, b: i32) i32 {\n    return a / b;\n}\n```\n\nruntime_vs_comptime.zig\n\nIn this function, values `a` and `b` are known only at runtime, and thus this division operation is vulnerable to both [Integer Overflow](#Integer-Overflow) and [Division by Zero](#Division-by-Zero).\n\nOperators such as `+` and `-` cause undefined behavior on integer overflow. Alternative operators are provided for wrapping and saturating arithmetic on all targets. `+%` and `-%` perform wrapping arithmetic while `+|` and `-|` perform saturating arithmetic.\n\nZig supports arbitrary bit-width integers, referenced by using an identifier of `i` or `u` followed by digits. For example, the identifier `i7` refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is `65535`. For signed integer types, Zig uses a [two's complement](https://en.wikipedia.org/wiki/Two's_complement) representation.\n\nSee also:\n\n- [Wrapping Operations](#Wrapping-Operations)\n\n## Floats\n\nZig has the following floating point types:\n\n- `f16` - IEEE-754-2008 binary16\n- `f32` - IEEE-754-2008 binary32\n- `f64` - IEEE-754-2008 binary64\n- `f80` - IEEE-754-2008 80-bit extended precision\n- `f128` - IEEE-754-2008 binary128\n- `c_longdouble` - matches `long double` for the target C ABI\n\n### Float Literals\n\nFloat literals have type `comptime_float` which is guaranteed to have the same precision and operations of the largest other floating point type, which is `f128`.\n\nFloat literals [coerce](#Type-Coercion) to any floating point type, and to any [integer](#Integers) type when there is no fractional component.\n\n``` zig\nconst floating_point = 123.0E+77;\nconst another_float = 123.0;\nconst yet_another = 123.0e+77;\n\nconst hex_floating_point = 0x103.70p-5;\nconst another_hex_float = 0x103.70;\nconst yet_another_hex_float = 0x103.70P-5;\n\n// underscores may be placed between two digits as a visual separator\nconst lightspeed = 299_792_458.000_000;\nconst nanosecond = 0.000_000_001;\nconst more_hex = 0x1234_5678.9ABC_CDEFp-10;\n```\n\nfloat_literals.zig\n\nThere is no syntax for NaN, infinity, or negative infinity. For these special values, one must use the standard library:\n\n``` zig\nconst std = @import(\"std\");\n\nconst inf = std.math.inf(f32);\nconst negative_inf = -std.math.inf(f64);\nconst nan = std.math.nan(f128);\n```\n\nfloat_special_values.zig\n\n### Floating Point Operations\n\nBy default floating point operations use `Strict` mode, but you can switch to `Optimized` mode on a per-block basis:\n\n``` zig\nconst std = @import(\"std\");\nconst big = @as(f64, 1 << 40);\n\nexport fn foo_strict(x: f64) f64 {\n    return x + big - big;\n}\n\nexport fn foo_optimized(x: f64) f64 {\n    @setFloatMode(.optimized);\n    return x + big - big;\n}\n```\n\nfloat_mode_obj.zig\n\n    $ zig build-obj float_mode_obj.zig -O ReleaseFast\n\nShell\n\nFor this test we have to separate code into two object files - otherwise the optimizer figures out all the values at compile-time, which operates in strict mode.\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nextern fn foo_strict(x: f64) f64;\nextern fn foo_optimized(x: f64) f64;\n\npub fn main() void {\n    const x = 0.001;\n    print(\"optimized = {}\\n\", .{foo_optimized(x)});\n    print(\"strict = {}\\n\", .{foo_strict(x)});\n}\n```\n\nfloat_mode_exe.zig\n\nSee also:\n\n- [@setFloatMode](#setFloatMode)\n- [Division by Zero](#Division-by-Zero)\n\n## Operators\n\nThere is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else.\n\n### Table of Operators\n\n[TABLE]\n\n### Precedence\n\n``` zig\nx() x[] x.y x.* x.?\na!b\nx{}\n!x -x -%x ~x &x ?x\n* / % ** *% *| ||\n+ - ++ +% -% +| -|\n<< >> <<|\n& ^ | orelse catch\n== != < > <= >=\nand\nor\n= *= *%= *|= /= %= += +%= +|= -= -%= -|= <<= <<|= >>= &= ^= |=\n```\n\n## Arrays\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\nconst assert = @import(\"std\").debug.assert;\nconst mem = @import(\"std\").mem;\n\n// array literal\nconst message = [_]u8{ 'h', 'e', 'l', 'l', 'o' };\n\n// alternative initialization using result location\nconst alt_message: [5]u8 = .{ 'h', 'e', 'l', 'l', 'o' };\n\ncomptime {\n    assert(mem.eql(u8, &message, &alt_message));\n}\n\n// get the size of an array\ncomptime {\n    assert(message.len == 5);\n}\n\n// A string literal is a single-item pointer to an array.\nconst same_message = \"hello\";\n\ncomptime {\n    assert(mem.eql(u8, &message, same_message));\n}\n\ntest \"iterate over an array\" {\n    var sum: usize = 0;\n    for (message) |byte| {\n        sum += byte;\n    }\n    try expect(sum == 'h' + 'e' + 'l' * 2 + 'o');\n}\n\n// modifiable array\nvar some_integers: [100]i32 = undefined;\n\ntest \"modify an array\" {\n    for (&some_integers, 0..) |*item, i| {\n        item.* = @intCast(i);\n    }\n    try expect(some_integers[10] == 10);\n    try expect(some_integers[99] == 99);\n}\n\n// array concatenation works if the values are known\n// at compile time\nconst part_one = [_]i32{ 1, 2, 3, 4 };\nconst part_two = [_]i32{ 5, 6, 7, 8 };\nconst all_of_it = part_one ++ part_two;\ncomptime {\n    assert(mem.eql(i32, &all_of_it, &[_]i32{ 1, 2, 3, 4, 5, 6, 7, 8 }));\n}\n\n// remember that string literals are arrays\nconst hello = \"hello\";\nconst world = \"world\";\nconst hello_world = hello ++ \" \" ++ world;\ncomptime {\n    assert(mem.eql(u8, hello_world, \"hello world\"));\n}\n\n// ** does repeating patterns\nconst pattern = \"ab\" ** 3;\ncomptime {\n    assert(mem.eql(u8, pattern, \"ababab\"));\n}\n\n// initialize an array to zero\nconst all_zero = [_]u16{0} ** 10;\n\ncomptime {\n    assert(all_zero.len == 10);\n    assert(all_zero[5] == 0);\n}\n\n// use compile-time code to initialize an array\nvar fancy_array = init: {\n    var initial_value: [10]Point = undefined;\n    for (&initial_value, 0..) |*pt, i| {\n        pt.* = Point{\n            .x = @intCast(i),\n            .y = @intCast(i * 2),\n        };\n    }\n    break :init initial_value;\n};\nconst Point = struct {\n    x: i32,\n    y: i32,\n};\n\ntest \"compile-time array initialization\" {\n    try expect(fancy_array[4].x == 4);\n    try expect(fancy_array[4].y == 8);\n}\n\n// call a function to initialize an array\nvar more_points = [_]Point{makePoint(3)} ** 10;\nfn makePoint(x: i32) Point {\n    return Point{\n        .x = x,\n        .y = x * 2,\n    };\n}\ntest \"array initialization with function calls\" {\n    try expect(more_points[4].x == 3);\n    try expect(more_points[4].y == 6);\n    try expect(more_points.len == 10);\n}\n```\n\ntest_arrays.zig\n\n    $ zig test test_arrays.zig\n    1/4 test_arrays.test.iterate over an array...OK\n    2/4 test_arrays.test.modify an array...OK\n    3/4 test_arrays.test.compile-time array initialization...OK\n    4/4 test_arrays.test.array initialization with function calls...OK\n    All 4 tests passed.\n\nShell\n\nSee also:\n\n- [for](#for)\n- [Slices](#Slices)\n\n### Multidimensional Arrays\n\nMultidimensional arrays can be created by nesting arrays:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst mat4x4 = [4][4]f32{\n    [_]f32{ 1.0, 0.0, 0.0, 0.0 },\n    [_]f32{ 0.0, 1.0, 0.0, 1.0 },\n    [_]f32{ 0.0, 0.0, 1.0, 0.0 },\n    [_]f32{ 0.0, 0.0, 0.0, 1.0 },\n};\ntest \"multidimensional arrays\" {\n    // Access the 2D array by indexing the outer array, and then the inner array.\n    try expect(mat4x4[1][1] == 1.0);\n\n    // Here we iterate with for loops.\n    for (mat4x4, 0..) |row, row_index| {\n        for (row, 0..) |cell, column_index| {\n            if (row_index == column_index) {\n                try expect(cell == 1.0);\n            }\n        }\n    }\n}\n```\n\ntest_multidimensional_arrays.zig\n\n    $ zig test test_multidimensional_arrays.zig\n    1/1 test_multidimensional_arrays.test.multidimensional arrays...OK\n    All 1 tests passed.\n\nShell\n\n### Sentinel-Terminated Arrays\n\nThe syntax `[N:x]T` describes an array which has a sentinel element of value `x` at the index corresponding to the length `N`.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"0-terminated sentinel array\" {\n    const array = [_:0]u8{ 1, 2, 3, 4 };\n\n    try expect(@TypeOf(array) == [4:0]u8);\n    try expect(array.len == 4);\n    try expect(array[4] == 0);\n}\n\ntest \"extra 0s in 0-terminated sentinel array\" {\n    // The sentinel value may appear earlier, but does not influence the compile-time 'len'.\n    const array = [_:0]u8{ 1, 0, 0, 4 };\n\n    try expect(@TypeOf(array) == [4:0]u8);\n    try expect(array.len == 4);\n    try expect(array[4] == 0);\n}\n```\n\ntest_null_terminated_array.zig\n\n    $ zig test test_null_terminated_array.zig\n    1/2 test_null_terminated_array.test.0-terminated sentinel array...OK\n    2/2 test_null_terminated_array.test.extra 0s in 0-terminated sentinel array...OK\n    All 2 tests passed.\n\nShell\n\nSee also:\n\n- [Sentinel-Terminated Pointers](#Sentinel-Terminated-Pointers)\n- [Sentinel-Terminated Slices](#Sentinel-Terminated-Slices)\n\n## Vectors\n\nA vector is a group of booleans, [Integers](#Integers), [Floats](#Floats), or [Pointers](#Pointers) which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function [@Vector](#Vector).\n\nVectors support the same builtin operators as their underlying base types. These operations are performed element-wise, and return a vector of the same length as the input vectors. This includes:\n\n- Arithmetic (`+`, `-`, `/`, `*`, `@divFloor`, `@sqrt`, `@ceil`, `@log`, etc.)\n- Bitwise operators (`>>`, `<<`, `&`, `|`, `~`, etc.)\n- Comparison operators (`<`, `>`, `==`, etc.)\n\nIt is prohibited to use a math operator on a mixture of scalars (individual numbers) and vectors. Zig provides the [@splat](#splat) builtin to easily convert from scalars to vectors, and it supports [@reduce](#reduce) and array indexing syntax to convert from vectors to scalars. Vectors also support assignment to and from fixed-length arrays with comptime-known length.\n\nFor rearranging elements within and between vectors, Zig provides the [@shuffle](#shuffle) and [@select](#select) functions.\n\nOperations on vectors shorter than the target machine's native SIMD size will typically compile to single SIMD instructions, while vectors longer than the target machine's native SIMD size will compile to multiple SIMD instructions. If a given operation doesn't have SIMD support on the target architecture, the compiler will default to operating on each vector element one at a time. Zig supports any comptime-known vector length up to 2^32-1, although small powers of two (2-64) are most typical. Note that excessively long vector lengths (e.g. 2^20) may result in compiler crashes on current versions of Zig.\n\n``` zig\nconst std = @import(\"std\");\nconst expectEqual = std.testing.expectEqual;\n\ntest \"Basic vector usage\" {\n    // Vectors have a compile-time known length and base type.\n    const a = @Vector(4, i32){ 1, 2, 3, 4 };\n    const b = @Vector(4, i32){ 5, 6, 7, 8 };\n\n    // Math operations take place element-wise.\n    const c = a + b;\n\n    // Individual vector elements can be accessed using array indexing syntax.\n    try expectEqual(6, c[0]);\n    try expectEqual(8, c[1]);\n    try expectEqual(10, c[2]);\n    try expectEqual(12, c[3]);\n}\n\ntest \"Conversion between vectors, arrays, and slices\" {\n    // Vectors and fixed-length arrays can be automatically assigned back and forth\n    const arr1: [4]f32 = [_]f32{ 1.1, 3.2, 4.5, 5.6 };\n    const vec: @Vector(4, f32) = arr1;\n    const arr2: [4]f32 = vec;\n    try expectEqual(arr1, arr2);\n\n    // You can also assign from a slice with comptime-known length to a vector using .*\n    const vec2: @Vector(2, f32) = arr1[1..3].*;\n\n    const slice: []const f32 = &arr1;\n    var offset: u32 = 1; // var to make it runtime-known\n    _ = &offset; // suppress 'var is never mutated' error\n    // To extract a comptime-known length from a runtime-known offset,\n    // first extract a new slice from the starting offset, then an array of\n    // comptime-known length\n    const vec3: @Vector(2, f32) = slice[offset..][0..2].*;\n    try expectEqual(slice[offset], vec2[0]);\n    try expectEqual(slice[offset + 1], vec2[1]);\n    try expectEqual(vec2, vec3);\n}\n```\n\ntest_vector.zig\n\n    $ zig test test_vector.zig\n    1/2 test_vector.test.Basic vector usage...OK\n    2/2 test_vector.test.Conversion between vectors, arrays, and slices...OK\n    All 2 tests passed.\n\nShell\n\nTODO talk about C ABI interop  \nTODO consider suggesting std.MultiArrayList\n\nSee also:\n\n- [@splat](#splat)\n- [@shuffle](#shuffle)\n- [@select](#select)\n- [@reduce](#reduce)\n\n## Pointers\n\nZig has two kinds of pointers: single-item and many-item.\n\n- `*T` - single-item pointer to exactly one item.\n  - Supports deref syntax: `ptr.*`\n- `[*]T` - many-item pointer to unknown number of items.\n  - Supports index syntax: `ptr[i]`\n  - Supports slice syntax: `ptr[start..end]` and `ptr[start..]`\n  - Supports pointer arithmetic: `ptr + x`, `ptr - x`\n  - `T` must have a known size, which means that it cannot be `anyopaque` or any other [opaque type](#opaque).\n\nThese types are closely related to [Arrays](#Arrays) and [Slices](#Slices):\n\n- `*[N]T` - pointer to N items, same as single-item pointer to an array.\n  - Supports index syntax: `array_ptr[i]`\n  - Supports slice syntax: `array_ptr[start..end]`\n  - Supports len property: `array_ptr.len`\n\n- `[]T` - is a slice (a fat pointer, which contains a pointer of type `[*]T` and a length).\n  - Supports index syntax: `slice[i]`\n  - Supports slice syntax: `slice[start..end]`\n  - Supports len property: `slice.len`\n\nUse `&x` to obtain a single-item pointer:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"address of syntax\" {\n    // Get the address of a variable:\n    const x: i32 = 1234;\n    const x_ptr = &x;\n\n    // Dereference a pointer:\n    try expect(x_ptr.* == 1234);\n\n    // When you get the address of a const variable, you get a const single-item pointer.\n    try expect(@TypeOf(x_ptr) == *const i32);\n\n    // If you want to mutate the value, you'd need an address of a mutable variable:\n    var y: i32 = 5678;\n    const y_ptr = &y;\n    try expect(@TypeOf(y_ptr) == *i32);\n    y_ptr.* += 1;\n    try expect(y_ptr.* == 5679);\n}\n\ntest \"pointer array access\" {\n    // Taking an address of an individual element gives a\n    // single-item pointer. This kind of pointer\n    // does not support pointer arithmetic.\n    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    const ptr = &array[2];\n    try expect(@TypeOf(ptr) == *u8);\n\n    try expect(array[2] == 3);\n    ptr.* += 1;\n    try expect(array[2] == 4);\n}\n```\n\ntest_single_item_pointer.zig\n\n    $ zig test test_single_item_pointer.zig\n    1/2 test_single_item_pointer.test.address of syntax...OK\n    2/2 test_single_item_pointer.test.pointer array access...OK\n    All 2 tests passed.\n\nShell\n\nZig supports pointer arithmetic. It's better to assign the pointer to `[*]T` and increment that variable. For example, directly incrementing the pointer from a slice will corrupt it.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"pointer arithmetic with many-item pointer\" {\n    const array = [_]i32{ 1, 2, 3, 4 };\n    var ptr: [*]const i32 = &array;\n\n    try expect(ptr[0] == 1);\n    ptr += 1;\n    try expect(ptr[0] == 2);\n\n    // slicing a many-item pointer without an end is equivalent to\n    // pointer arithmetic: `ptr[start..] == ptr + start`\n    try expect(ptr[1..] == ptr + 1);\n}\n\ntest \"pointer arithmetic with slices\" {\n    var array = [_]i32{ 1, 2, 3, 4 };\n    var length: usize = 0; // var to make it runtime-known\n    _ = &length; // suppress 'var is never mutated' error\n    var slice = array[length..array.len];\n\n    try expect(slice[0] == 1);\n    try expect(slice.len == 4);\n\n    slice.ptr += 1;\n    // now the slice is in an bad state since len has not been updated\n\n    try expect(slice[0] == 2);\n    try expect(slice.len == 4);\n}\n```\n\ntest_pointer_arithmetic.zig\n\n    $ zig test test_pointer_arithmetic.zig\n    1/2 test_pointer_arithmetic.test.pointer arithmetic with many-item pointer...OK\n    2/2 test_pointer_arithmetic.test.pointer arithmetic with slices...OK\n    All 2 tests passed.\n\nShell\n\nIn Zig, we generally prefer [Slices](#Slices) rather than [Sentinel-Terminated Pointers](#Sentinel-Terminated-Pointers). You can turn an array or pointer into a slice using slice syntax.\n\nSlices have bounds checking and are therefore protected against this kind of undefined behavior. This is one reason we prefer slices to pointers.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"pointer slicing\" {\n    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    var start: usize = 2; // var to make it runtime-known\n    _ = &start; // suppress 'var is never mutated' error\n    const slice = array[start..4];\n    try expect(slice.len == 2);\n\n    try expect(array[3] == 4);\n    slice[1] += 1;\n    try expect(array[3] == 5);\n}\n```\n\ntest_slice_bounds.zig\n\n    $ zig test test_slice_bounds.zig\n    1/1 test_slice_bounds.test.pointer slicing...OK\n    All 1 tests passed.\n\nShell\n\nPointers work at compile-time too, as long as the code does not depend on an undefined memory layout:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"comptime pointers\" {\n    comptime {\n        var x: i32 = 1;\n        const ptr = &x;\n        ptr.* += 1;\n        x += 1;\n        try expect(ptr.* == 3);\n    }\n}\n```\n\ntest_comptime_pointers.zig\n\n    $ zig test test_comptime_pointers.zig\n    1/1 test_comptime_pointers.test.comptime pointers...OK\n    All 1 tests passed.\n\nShell\n\nTo convert an integer address into a pointer, use `@ptrFromInt`. To convert a pointer to an integer, use `@intFromPtr`:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"@intFromPtr and @ptrFromInt\" {\n    const ptr: *i32 = @ptrFromInt(0xdeadbee0);\n    const addr = @intFromPtr(ptr);\n    try expect(@TypeOf(addr) == usize);\n    try expect(addr == 0xdeadbee0);\n}\n```\n\ntest_integer_pointer_conversion.zig\n\n    $ zig test test_integer_pointer_conversion.zig\n    1/1 test_integer_pointer_conversion.test.@intFromPtr and @ptrFromInt...OK\n    All 1 tests passed.\n\nShell\n\nZig is able to preserve memory addresses in comptime code, as long as the pointer is never dereferenced:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"comptime @ptrFromInt\" {\n    comptime {\n        // Zig is able to do this at compile-time, as long as\n        // ptr is never dereferenced.\n        const ptr: *i32 = @ptrFromInt(0xdeadbee0);\n        const addr = @intFromPtr(ptr);\n        try expect(@TypeOf(addr) == usize);\n        try expect(addr == 0xdeadbee0);\n    }\n}\n```\n\ntest_comptime_pointer_conversion.zig\n\n    $ zig test test_comptime_pointer_conversion.zig\n    1/1 test_comptime_pointer_conversion.test.comptime @ptrFromInt...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [Optional Pointers](#Optional-Pointers)\n- [@ptrFromInt](#ptrFromInt)\n- [@intFromPtr](#intFromPtr)\n- [C Pointers](#C-Pointers)\n\n### volatile\n\nLoads and stores are assumed to not have side effects. If a given load or store should have side effects, such as Memory Mapped Input/Output (MMIO), use `volatile`. In the following code, loads and stores with `mmio_ptr` are guaranteed to all happen and in the same order as in source code:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"volatile\" {\n    const mmio_ptr: *volatile u8 = @ptrFromInt(0x12345678);\n    try expect(@TypeOf(mmio_ptr) == *volatile u8);\n}\n```\n\ntest_volatile.zig\n\n    $ zig test test_volatile.zig\n    1/1 test_volatile.test.volatile...OK\n    All 1 tests passed.\n\nShell\n\nNote that `volatile` is unrelated to concurrency and [Atomics](#Atomics). If you see code that is using `volatile` for something other than Memory Mapped Input/Output, it is probably a bug.\n\n[@ptrCast](#ptrCast) converts a pointer's element type to another. This creates a new pointer that can cause undetectable illegal behavior depending on the loads and stores that pass through it. Generally, other kinds of type conversions are preferable to `@ptrCast` if possible.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"pointer casting\" {\n    const bytes align(@alignOf(u32)) = [_]u8{ 0x12, 0x12, 0x12, 0x12 };\n    const u32_ptr: *const u32 = @ptrCast(&bytes);\n    try expect(u32_ptr.* == 0x12121212);\n\n    // Even this example is contrived - there are better ways to do the above than\n    // pointer casting. For example, using a slice narrowing cast:\n    const u32_value = std.mem.bytesAsSlice(u32, bytes[0..])[0];\n    try expect(u32_value == 0x12121212);\n\n    // And even another way, the most straightforward way to do it:\n    try expect(@as(u32, @bitCast(bytes)) == 0x12121212);\n}\n\ntest \"pointer child type\" {\n    // pointer types have a `child` field which tells you the type they point to.\n    try expect(@typeInfo(*u32).Pointer.child == u32);\n}\n```\n\ntest_pointer_casting.zig\n\n    $ zig test test_pointer_casting.zig\n    1/2 test_pointer_casting.test.pointer casting...OK\n    2/2 test_pointer_casting.test.pointer child type...OK\n    All 2 tests passed.\n\nShell\n\n### Alignment\n\nEach type has an **alignment** - a number of bytes such that, when a value of the type is loaded from or stored to memory, the memory address must be evenly divisible by this number. You can use [@alignOf](#alignOf) to find out this value for any type.\n\nAlignment depends on the CPU architecture, but is always a power of two, and less than `1`` << ``29`.\n\nIn Zig, a pointer type has an alignment value. If the value is equal to the alignment of the underlying type, it can be omitted from the type:\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\n\ntest \"variable alignment\" {\n    var x: i32 = 1234;\n    const align_of_i32 = @alignOf(@TypeOf(x));\n    try expect(@TypeOf(&x) == *i32);\n    try expect(*i32 == *align(align_of_i32) i32);\n    if (builtin.target.cpu.arch == .x86_64) {\n        try expect(@typeInfo(*i32).Pointer.alignment == 4);\n    }\n}\n```\n\ntest_variable_alignment.zig\n\n    $ zig test test_variable_alignment.zig\n    1/1 test_variable_alignment.test.variable alignment...OK\n    All 1 tests passed.\n\nShell\n\nIn the same way that a `*``i32` can be [coerced](#Type-Coercion) to a `*``const`` ``i32`, a pointer with a larger alignment can be implicitly cast to a pointer with a smaller alignment, but not vice versa.\n\nYou can specify alignment on variables and functions. If you do this, then pointers to them get the specified alignment:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nvar foo: u8 align(4) = 100;\n\ntest \"global variable alignment\" {\n    try expect(@typeInfo(@TypeOf(&foo)).Pointer.alignment == 4);\n    try expect(@TypeOf(&foo) == *align(4) u8);\n    const as_pointer_to_array: *align(4) [1]u8 = &foo;\n    const as_slice: []align(4) u8 = as_pointer_to_array;\n    const as_unaligned_slice: []u8 = as_slice;\n    try expect(as_unaligned_slice[0] == 100);\n}\n\nfn derp() align(@sizeOf(usize) * 2) i32 {\n    return 1234;\n}\nfn noop1() align(1) void {}\nfn noop4() align(4) void {}\n\ntest \"function alignment\" {\n    try expect(derp() == 1234);\n    try expect(@TypeOf(derp) == fn () i32);\n    try expect(@TypeOf(&derp) == *align(@sizeOf(usize) * 2) const fn () i32);\n\n    noop1();\n    try expect(@TypeOf(noop1) == fn () void);\n    try expect(@TypeOf(&noop1) == *align(1) const fn () void);\n\n    noop4();\n    try expect(@TypeOf(noop4) == fn () void);\n    try expect(@TypeOf(&noop4) == *align(4) const fn () void);\n}\n```\n\ntest_variable_func_alignment.zig\n\n    $ zig test test_variable_func_alignment.zig\n    1/2 test_variable_func_alignment.test.global variable alignment...OK\n    2/2 test_variable_func_alignment.test.function alignment...OK\n    All 2 tests passed.\n\nShell\n\nIf you have a pointer or a slice that has a small alignment, but you know that it actually has a bigger alignment, use [@alignCast](#alignCast) to change the pointer into a more aligned pointer. This is a no-op at runtime, but inserts a [safety check](#Incorrect-Pointer-Alignment):\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"pointer alignment safety\" {\n    var array align(4) = [_]u32{ 0x11111111, 0x11111111 };\n    const bytes = std.mem.sliceAsBytes(array[0..]);\n    try std.testing.expect(foo(bytes) == 0x11111111);\n}\nfn foo(bytes: []u8) u32 {\n    const slice4 = bytes[1..5];\n    const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n    return int_slice[0];\n}\n```\n\ntest_incorrect_pointer_alignment.zig\n\n    $ zig test test_incorrect_pointer_alignment.zig\n    1/1 test_incorrect_pointer_alignment.test.pointer alignment safety...thread 3568823 panic: incorrect alignment\n    /home/andy/src/zig/doc/langref/test_incorrect_pointer_alignment.zig:10:68: 0x103d13a in foo (test)\n        const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n                                                                       ^\n    /home/andy/src/zig/doc/langref/test_incorrect_pointer_alignment.zig:6:31: 0x103cfd7 in test.pointer alignment safety (test)\n        try std.testing.expect(foo(bytes) == 0x11111111);\n                                  ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1047f10 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e28b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d609 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103d171 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/c771705677c0d2df24e00269a9189f97/test\n\nShell\n\n### allowzero\n\nThis pointer attribute allows a pointer to have address zero. This is only ever needed on the freestanding OS target, where the address zero is mappable. If you want to represent null pointers, use [Optional Pointers](#Optional-Pointers) instead. [Optional Pointers](#Optional-Pointers) with `allowzero` are not the same size as pointers. In this code example, if the pointer did not have the `allowzero` attribute, this would be a [Pointer Cast Invalid Null](#Pointer-Cast-Invalid-Null) panic:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"allowzero\" {\n    var zero: usize = 0; // var to make to runtime-known\n    _ = &zero; // suppress 'var is never mutated' error\n    const ptr: *allowzero i32 = @ptrFromInt(zero);\n    try expect(@intFromPtr(ptr) == 0);\n}\n```\n\ntest_allowzero.zig\n\n    $ zig test test_allowzero.zig\n    1/1 test_allowzero.test.allowzero...OK\n    All 1 tests passed.\n\nShell\n\n### Sentinel-Terminated Pointers\n\nThe syntax `[*:x]T` describes a pointer that has a length determined by a sentinel value. This provides protection against buffer overflow and overreads.\n\n``` zig\nconst std = @import(\"std\");\n\n// This is also available as `std.c.printf`.\npub extern \"c\" fn printf(format: [*:0]const u8, ...) c_int;\n\npub fn main() anyerror!void {\n    _ = printf(\"Hello, world!\\n\"); // OK\n\n    const msg = \"Hello, world!\\n\";\n    const non_null_terminated_msg: [msg.len]u8 = msg.*;\n    _ = printf(&non_null_terminated_msg);\n}\n```\n\nsentinel-terminated_pointer.zig\n\n    $ zig build-exe sentinel-terminated_pointer.zig -lc\n    /home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: error: expected type '[*:0]const u8', found '*const [14]u8'\n        _ = printf(&non_null_terminated_msg);\n                   ^~~~~~~~~~~~~~~~~~~~~~~~\n    /home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: note: destination pointer requires '0' sentinel\n    /home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:4:35: note: parameter type declared here\n    pub extern \"c\" fn printf(format: [*:0]const u8, ...) c_int;\n                                     ~^~~~~~~~~~~~\n    referenced by:\n        callMain: /home/andy/src/zig/lib/std/start.zig:524:32\n        callMainWithArgs: /home/andy/src/zig/lib/std/start.zig:482:12\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\nSee also:\n\n- [Sentinel-Terminated Slices](#Sentinel-Terminated-Slices)\n- [Sentinel-Terminated Arrays](#Sentinel-Terminated-Arrays)\n\n## Slices\n\nA slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the \\`len\\` field.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\nconst expectEqualSlices = @import(\"std\").testing.expectEqualSlices;\n\ntest \"basic slices\" {\n    var array = [_]i32{ 1, 2, 3, 4 };\n    var known_at_runtime_zero: usize = 0;\n    _ = &known_at_runtime_zero;\n    const slice = array[known_at_runtime_zero..array.len];\n\n    // alternative initialization using result location\n    const alt_slice: []const i32 = &.{ 1, 2, 3, 4 };\n\n    try expectEqualSlices(i32, slice, alt_slice);\n\n    try expect(@TypeOf(slice) == []i32);\n    try expect(&slice[0] == &array[0]);\n    try expect(slice.len == array.len);\n\n    // If you slice with comptime-known start and end positions, the result is\n    // a pointer to an array, rather than a slice.\n    const array_ptr = array[0..array.len];\n    try expect(@TypeOf(array_ptr) == *[array.len]i32);\n\n    // You can perform a slice-by-length by slicing twice. This allows the compiler\n    // to perform some optimisations like recognising a comptime-known length when\n    // the start position is only known at runtime.\n    var runtime_start: usize = 1;\n    _ = &runtime_start;\n    const length = 2;\n    const array_ptr_len = array[runtime_start..][0..length];\n    try expect(@TypeOf(array_ptr_len) == *[length]i32);\n\n    // Using the address-of operator on a slice gives a single-item pointer.\n    try expect(@TypeOf(&slice[0]) == *i32);\n    // Using the `ptr` field gives a many-item pointer.\n    try expect(@TypeOf(slice.ptr) == [*]i32);\n    try expect(@intFromPtr(slice.ptr) == @intFromPtr(&slice[0]));\n\n    // Slices have array bounds checking. If you try to access something out\n    // of bounds, you'll get a safety check failure:\n    slice[10] += 1;\n\n    // Note that `slice.ptr` does not invoke safety checking, while `&slice[0]`\n    // asserts that the slice has len > 0.\n}\n```\n\ntest_basic_slices.zig\n\n    $ zig test test_basic_slices.zig\n    1/1 test_basic_slices.test.basic slices...thread 3571722 panic: index out of bounds: index 10, len 4\n    /home/andy/src/zig/doc/langref/test_basic_slices.zig:41:10: 0x103f955 in test.basic slices (test)\n        slice[10] += 1;\n             ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104c800 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x104210b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103fe49 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103f9b1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/3c391d75c939ce98356b98dd812503b1/test\n\nShell\n\nThis is one reason we prefer slices to pointers.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\nconst fmt = std.fmt;\n\ntest \"using slices for strings\" {\n    // Zig has no concept of strings. String literals are const pointers\n    // to null-terminated arrays of u8, and by convention parameters\n    // that are \"strings\" are expected to be UTF-8 encoded slices of u8.\n    // Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8\n    const hello: []const u8 = \"hello\";\n    const world: []const u8 = \"世界\";\n\n    var all_together: [100]u8 = undefined;\n    // You can use slice syntax with at least one runtime-known index on an\n    // array to convert an array into a slice.\n    var start: usize = 0;\n    _ = &start;\n    const all_together_slice = all_together[start..];\n    // String concatenation example.\n    const hello_world = try fmt.bufPrint(all_together_slice, \"{s} {s}\", .{ hello, world });\n\n    // Generally, you can use UTF-8 and not worry about whether something is a\n    // string. If you don't need to deal with individual characters, no need\n    // to decode.\n    try expect(mem.eql(u8, hello_world, \"hello 世界\"));\n}\n\ntest \"slice pointer\" {\n    var array: [10]u8 = undefined;\n    const ptr = &array;\n    try expect(@TypeOf(ptr) == *[10]u8);\n\n    // A pointer to an array can be sliced just like an array:\n    var start: usize = 0;\n    var end: usize = 5;\n    _ = .{ &start, &end };\n    const slice = ptr[start..end];\n    // The slice is mutable because we sliced a mutable pointer.\n    try expect(@TypeOf(slice) == []u8);\n    slice[2] = 3;\n    try expect(array[2] == 3);\n\n    // Again, slicing with comptime-known indexes will produce another pointer\n    // to an array:\n    const ptr2 = slice[2..3];\n    try expect(ptr2.len == 1);\n    try expect(ptr2[0] == 3);\n    try expect(@TypeOf(ptr2) == *[1]u8);\n}\n```\n\ntest_slices.zig\n\n    $ zig test test_slices.zig\n    1/2 test_slices.test.using slices for strings...OK\n    2/2 test_slices.test.slice pointer...OK\n    All 2 tests passed.\n\nShell\n\nSee also:\n\n- [Pointers](#Pointers)\n- [for](#for)\n- [Arrays](#Arrays)\n\n### Sentinel-Terminated Slices\n\nThe syntax `[:x]T` is a slice which has a runtime-known length and also guarantees a sentinel value at the element indexed by the length. The type does not guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element access to the `len` index.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"0-terminated slice\" {\n    const slice: [:0]const u8 = \"hello\";\n\n    try expect(slice.len == 5);\n    try expect(slice[5] == 0);\n}\n```\n\ntest_null_terminated_slice.zig\n\n    $ zig test test_null_terminated_slice.zig\n    1/1 test_null_terminated_slice.test.0-terminated slice...OK\n    All 1 tests passed.\n\nShell\n\nSentinel-terminated slices can also be created using a variation of the slice syntax `data[start..end :x]`, where `data` is a many-item pointer, array or slice and `x` is the sentinel value.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"0-terminated slicing\" {\n    var array = [_]u8{ 3, 2, 1, 0, 3, 2, 1, 0 };\n    var runtime_length: usize = 3;\n    _ = &runtime_length;\n    const slice = array[0..runtime_length :0];\n\n    try expect(@TypeOf(slice) == [:0]u8);\n    try expect(slice.len == 3);\n}\n```\n\ntest_null_terminated_slicing.zig\n\n    $ zig test test_null_terminated_slicing.zig\n    1/1 test_null_terminated_slicing.test.0-terminated slicing...OK\n    All 1 tests passed.\n\nShell\n\nSentinel-terminated slicing asserts that the element in the sentinel position of the backing data is actually the sentinel value. If this is not the case, safety-protected [Undefined Behavior](#Undefined-Behavior) results.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"sentinel mismatch\" {\n    var array = [_]u8{ 3, 2, 1, 0 };\n\n    // Creating a sentinel-terminated slice from the array with a length of 2\n    // will result in the value `1` occupying the sentinel element position.\n    // This does not match the indicated sentinel value of `0` and will lead\n    // to a runtime panic.\n    var runtime_length: usize = 2;\n    _ = &runtime_length;\n    const slice = array[0..runtime_length :0];\n\n    _ = slice;\n}\n```\n\ntest_sentinel_mismatch.zig\n\n    $ zig test test_sentinel_mismatch.zig\n    1/1 test_sentinel_mismatch.test.sentinel mismatch...thread 3579807 panic: sentinel mismatch: expected 0, found 1\n    /home/andy/src/zig/doc/langref/test_sentinel_mismatch.zig:13:24: 0x103cf16 in test.sentinel mismatch (test)\n        const slice = array[0..runtime_length :0];\n                           ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048aa0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103eabb in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d4f9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103d061 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/2af8da0d34d396fbb50fa515cef10c72/test\n\nShell\n\nSee also:\n\n- [Sentinel-Terminated Pointers](#Sentinel-Terminated-Pointers)\n- [Sentinel-Terminated Arrays](#Sentinel-Terminated-Arrays)\n\n## struct\n\n``` zig\n// Declare a struct.\n// Zig gives no guarantees about the order of fields and the size of\n// the struct but the fields are guaranteed to be ABI-aligned.\nconst Point = struct {\n    x: f32,\n    y: f32,\n};\n\n// Maybe we want to pass it to OpenGL so we want to be particular about\n// how the bytes are arranged.\nconst Point2 = packed struct {\n    x: f32,\n    y: f32,\n};\n\n// Declare an instance of a struct.\nconst p = Point{\n    .x = 0.12,\n    .y = 0.34,\n};\n\n// Maybe we're not ready to fill out some of the fields.\nvar p2 = Point{\n    .x = 0.12,\n    .y = undefined,\n};\n\n// Structs can have methods\n// Struct methods are not special, they are only namespaced\n// functions that you can call with dot syntax.\nconst Vec3 = struct {\n    x: f32,\n    y: f32,\n    z: f32,\n\n    pub fn init(x: f32, y: f32, z: f32) Vec3 {\n        return Vec3{\n            .x = x,\n            .y = y,\n            .z = z,\n        };\n    }\n\n    pub fn dot(self: Vec3, other: Vec3) f32 {\n        return self.x * other.x + self.y * other.y + self.z * other.z;\n    }\n};\n\nconst expect = @import(\"std\").testing.expect;\ntest \"dot product\" {\n    const v1 = Vec3.init(1.0, 0.0, 0.0);\n    const v2 = Vec3.init(0.0, 1.0, 0.0);\n    try expect(v1.dot(v2) == 0.0);\n\n    // Other than being available to call with dot syntax, struct methods are\n    // not special. You can reference them as any other declaration inside\n    // the struct:\n    try expect(Vec3.dot(v1, v2) == 0.0);\n}\n\n// Structs can have declarations.\n// Structs can have 0 fields.\nconst Empty = struct {\n    pub const PI = 3.14;\n};\ntest \"struct namespaced variable\" {\n    try expect(Empty.PI == 3.14);\n    try expect(@sizeOf(Empty) == 0);\n\n    // you can still instantiate an empty struct\n    const does_nothing = Empty{};\n\n    _ = does_nothing;\n}\n\n// struct field order is determined by the compiler for optimal performance.\n// however, you can still calculate a struct base pointer given a field pointer:\nfn setYBasedOnX(x: *f32, y: f32) void {\n    const point: *Point = @fieldParentPtr(\"x\", x);\n    point.y = y;\n}\ntest \"field parent pointer\" {\n    var point = Point{\n        .x = 0.1234,\n        .y = 0.5678,\n    };\n    setYBasedOnX(&point.x, 0.9);\n    try expect(point.y == 0.9);\n}\n\n// You can return a struct from a function. This is how we do generics\n// in Zig:\nfn LinkedList(comptime T: type) type {\n    return struct {\n        pub const Node = struct {\n            prev: ?*Node,\n            next: ?*Node,\n            data: T,\n        };\n\n        first: ?*Node,\n        last: ?*Node,\n        len: usize,\n    };\n}\n\ntest \"linked list\" {\n    // Functions called at compile-time are memoized. This means you can\n    // do this:\n    try expect(LinkedList(i32) == LinkedList(i32));\n\n    const list = LinkedList(i32){\n        .first = null,\n        .last = null,\n        .len = 0,\n    };\n    try expect(list.len == 0);\n\n    // Since types are first class values you can instantiate the type\n    // by assigning it to a variable:\n    const ListOfInts = LinkedList(i32);\n    try expect(ListOfInts == LinkedList(i32));\n\n    var node = ListOfInts.Node{\n        .prev = null,\n        .next = null,\n        .data = 1234,\n    };\n    const list2 = LinkedList(i32){\n        .first = &node,\n        .last = &node,\n        .len = 1,\n    };\n\n    // When using a pointer to a struct, fields can be accessed directly,\n    // without explicitly dereferencing the pointer.\n    // So you can do\n    try expect(list2.first.?.data == 1234);\n    // instead of try expect(list2.first.?.*.data == 1234);\n}\n```\n\ntest_structs.zig\n\n    $ zig test test_structs.zig\n    1/4 test_structs.test.dot product...OK\n    2/4 test_structs.test.struct namespaced variable...OK\n    3/4 test_structs.test.field parent pointer...OK\n    4/4 test_structs.test.linked list...OK\n    All 4 tests passed.\n\nShell\n\n### Default Field Values\n\nEach struct field may have an expression indicating the default field value. Such expressions are executed at [comptime](#comptime), and allow the field to be omitted in a struct literal expression:\n\n``` zig\nconst Foo = struct {\n    a: i32 = 1234,\n    b: i32,\n};\n\ntest \"default struct initialization fields\" {\n    const x: Foo = .{\n        .b = 5,\n    };\n    if (x.a + x.b != 1239) {\n        comptime unreachable;\n    }\n}\n```\n\nstruct_default_field_values.zig\n\n    $ zig test struct_default_field_values.zig\n    1/1 struct_default_field_values.test.default struct initialization fields...OK\n    All 1 tests passed.\n\nShell\n\nDefault field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization.\n\nFor example, here is an inappropriate use of default struct field initialization:\n\n``` zig\nconst Threshold = struct {\n    minimum: f32 = 0.25,\n    maximum: f32 = 0.75,\n\n    const Category = enum { low, medium, high };\n\n    fn categorize(t: Threshold, value: f32) Category {\n        assert(t.maximum >= t.minimum);\n        if (value < t.minimum) return .low;\n        if (value > t.maximum) return .high;\n        return .medium;\n    }\n};\n\npub fn main() !void {\n    var threshold: Threshold = .{\n        .maximum = 0.20,\n    };\n    const category = threshold.categorize(0.90);\n    try std.io.getStdOut().writeAll(@tagName(category));\n}\n\nconst std = @import(\"std\");\nconst assert = std.debug.assert;\n```\n\nbad_default_value.zig\n\n    $ zig build-exe bad_default_value.zig\n    $ ./bad_default_value\n    thread 3570319 panic: reached unreachable code\n    /home/andy/src/zig/lib/std/debug.zig:412:14: 0x1037a6d in assert (bad_default_value)\n        if (!ok) unreachable; // assertion failure\n                 ^\n    /home/andy/src/zig/doc/langref/bad_default_value.zig:8:15: 0x1034f59 in categorize (bad_default_value)\n            assert(t.maximum >= t.minimum);\n                  ^\n    /home/andy/src/zig/doc/langref/bad_default_value.zig:19:42: 0x1034e8a in main (bad_default_value)\n        const category = threshold.categorize(0.90);\n                                             ^\n    /home/andy/src/zig/lib/std/start.zig:524:37: 0x1034da5 in posixCallMainAndExit (bad_default_value)\n                const result = root.main() catch |err| {\n                                        ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10348c1 in _start (bad_default_value)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nAbove you can see the danger of ignoring this principle. The default field values caused the data invariant to be violated, causing illegal behavior.\n\nTo fix this, remove the default values from all the struct fields, and provide a named default value:\n\n``` zig\nconst Threshold = struct {\n    minimum: f32,\n    maximum: f32,\n\n    const default: Threshold = .{\n        .minimum = 0.25,\n        .maximum = 0.75,\n    };\n};\n```\n\nstruct_default_value.zig\n\nIf a struct value requires a runtime-known value in order to be initialized without violating data invariants, then use an initialization method that accepts those runtime values, and populates the remaining fields.\n\n### extern struct\n\nAn `extern`` ``struct` has in-memory layout matching the C ABI for the target.\n\nIf well-defined in-memory layout is not required, [struct](#struct) is a better choice because it places fewer restrictions on the compiler.\n\nSee [packed struct](#packed-struct) for a struct that has the ABI of its backing integer, which can be useful for modeling flags.\n\nSee also:\n\n- [extern union](#extern-union)\n- [extern enum](#extern-enum)\n\n### packed struct\n\nUnlike normal structs, `packed` structs have guaranteed in-memory layout:\n\n- Fields remain in the order declared, least to most significant.\n- There is no padding between fields.\n- Zig supports arbitrary width [Integers](#Integers) and although normally, integers with fewer than 8 bits will still use 1 byte of memory, in packed structs, they use exactly their bit width.\n- `bool` fields use exactly 1 bit.\n- An [enum](#enum) field uses exactly the bit width of its integer tag type.\n- A [packed union](#packed-union) field uses exactly the bit width of the union field with the largest bit width.\n\nThis means that a `packed`` ``struct` can participate in a [@bitCast](#bitCast) or a [@ptrCast](#ptrCast) to reinterpret memory. This even works at [comptime](#comptime):\n\n``` zig\nconst std = @import(\"std\");\nconst native_endian = @import(\"builtin\").target.cpu.arch.endian();\nconst expect = std.testing.expect;\n\nconst Full = packed struct {\n    number: u16,\n};\nconst Divided = packed struct {\n    half1: u8,\n    quarter3: u4,\n    quarter4: u4,\n};\n\ntest \"@bitCast between packed structs\" {\n    try doTheTest();\n    try comptime doTheTest();\n}\n\nfn doTheTest() !void {\n    try expect(@sizeOf(Full) == 2);\n    try expect(@sizeOf(Divided) == 2);\n    const full = Full{ .number = 0x1234 };\n    const divided: Divided = @bitCast(full);\n    try expect(divided.half1 == 0x34);\n    try expect(divided.quarter3 == 0x2);\n    try expect(divided.quarter4 == 0x1);\n\n    const ordered: [2]u8 = @bitCast(full);\n    switch (native_endian) {\n        .big => {\n            try expect(ordered[0] == 0x12);\n            try expect(ordered[1] == 0x34);\n        },\n        .little => {\n            try expect(ordered[0] == 0x34);\n            try expect(ordered[1] == 0x12);\n        },\n    }\n}\n```\n\ntest_packed_structs.zig\n\n    $ zig test test_packed_structs.zig\n    1/1 test_packed_structs.test.@bitCast between packed structs...OK\n    All 1 tests passed.\n\nShell\n\nThe backing integer is inferred from the fields' total bit width. Optionally, it can be explicitly provided and enforced at compile time:\n\n``` zig\ntest \"missized packed struct\" {\n    const S = packed struct(u32) { a: u16, b: u8 };\n    _ = S{ .a = 4, .b = 2 };\n}\n```\n\ntest_missized_packed_struct.zig\n\n    $ zig test test_missized_packed_struct.zig\n    doc/langref/test_missized_packed_struct.zig:2:29: error: backing integer type 'u32' has bit size 32 but the struct fields have a total bit size of 24\n        const S = packed struct(u32) { a: u16, b: u8 };\n                                ^~~\n\nShell\n\nZig allows the address to be taken of a non-byte-aligned field:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\nvar foo = BitField{\n    .a = 1,\n    .b = 2,\n    .c = 3,\n};\n\ntest \"pointer to non-byte-aligned field\" {\n    const ptr = &foo.b;\n    try expect(ptr.* == 2);\n}\n```\n\ntest_pointer_to_non-byte_aligned_field.zig\n\n    $ zig test test_pointer_to_non-byte_aligned_field.zig\n    1/1 test_pointer_to_non-byte_aligned_field.test.pointer to non-byte-aligned field...OK\n    All 1 tests passed.\n\nShell\n\nHowever, the pointer to a non-byte-aligned field has special properties and cannot be passed when a normal pointer is expected:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\nvar bit_field = BitField{\n    .a = 1,\n    .b = 2,\n    .c = 3,\n};\n\ntest \"pointer to non-byte-aligned field\" {\n    try expect(bar(&bit_field.b) == 2);\n}\n\nfn bar(x: *const u3) u3 {\n    return x.*;\n}\n```\n\ntest_misaligned_pointer.zig\n\n    $ zig test test_misaligned_pointer.zig\n    doc/langref/test_misaligned_pointer.zig:17:20: error: expected type '*const u3', found '*align(1:3:1) u3'\n        try expect(bar(&bit_field.b) == 2);\n                       ^~~~~~~~~~~~\n    doc/langref/test_misaligned_pointer.zig:17:20: note: pointer host size '1' cannot cast into pointer host size '0'\n    doc/langref/test_misaligned_pointer.zig:17:20: note: pointer bit offset '3' cannot cast into pointer bit offset '0'\n    doc/langref/test_misaligned_pointer.zig:20:11: note: parameter type declared here\n    fn bar(x: *const u3) u3 {\n              ^~~~~~~~~\n\nShell\n\nIn this case, the function `bar` cannot be called because the pointer to the non-ABI-aligned field mentions the bit offset, but the function expects an ABI-aligned pointer.\n\nPointers to non-ABI-aligned fields share the same address as the other fields within their host integer:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\nvar bit_field = BitField{\n    .a = 1,\n    .b = 2,\n    .c = 3,\n};\n\ntest \"pointers of sub-byte-aligned fields share addresses\" {\n    try expect(@intFromPtr(&bit_field.a) == @intFromPtr(&bit_field.b));\n    try expect(@intFromPtr(&bit_field.a) == @intFromPtr(&bit_field.c));\n}\n```\n\ntest_packed_struct_field_address.zig\n\n    $ zig test test_packed_struct_field_address.zig\n    1/1 test_packed_struct_field_address.test.pointers of sub-byte-aligned fields share addresses...OK\n    All 1 tests passed.\n\nShell\n\nThis can be observed with [@bitOffsetOf](#bitOffsetOf) and [offsetOf](#offsetOf):\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\ntest \"offsets of non-byte-aligned fields\" {\n    comptime {\n        try expect(@bitOffsetOf(BitField, \"a\") == 0);\n        try expect(@bitOffsetOf(BitField, \"b\") == 3);\n        try expect(@bitOffsetOf(BitField, \"c\") == 6);\n\n        try expect(@offsetOf(BitField, \"a\") == 0);\n        try expect(@offsetOf(BitField, \"b\") == 0);\n        try expect(@offsetOf(BitField, \"c\") == 0);\n    }\n}\n```\n\ntest_bitOffsetOf_offsetOf.zig\n\n    $ zig test test_bitOffsetOf_offsetOf.zig\n    1/1 test_bitOffsetOf_offsetOf.test.offsets of non-byte-aligned fields...OK\n    All 1 tests passed.\n\nShell\n\nPacked structs have the same alignment as their backing integer, however, overaligned pointers to packed structs can override this:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst S = packed struct {\n    a: u32,\n    b: u32,\n};\ntest \"overaligned pointer to packed struct\" {\n    var foo: S align(4) = .{ .a = 1, .b = 2 };\n    const ptr: *align(4) S = &foo;\n    const ptr_to_b: *u32 = &ptr.b;\n    try expect(ptr_to_b.* == 2);\n}\n```\n\ntest_overaligned_packed_struct.zig\n\n    $ zig test test_overaligned_packed_struct.zig\n    1/1 test_overaligned_packed_struct.test.overaligned pointer to packed struct...OK\n    All 1 tests passed.\n\nShell\n\nIt's also possible to set alignment of struct fields:\n\n``` zig\nconst std = @import(\"std\");\nconst expectEqual = std.testing.expectEqual;\n\ntest \"aligned struct fields\" {\n    const S = struct {\n        a: u32 align(2),\n        b: u32 align(64),\n    };\n    var foo = S{ .a = 1, .b = 2 };\n\n    try expectEqual(64, @alignOf(S));\n    try expectEqual(*align(2) u32, @TypeOf(&foo.a));\n    try expectEqual(*align(64) u32, @TypeOf(&foo.b));\n}\n```\n\ntest_aligned_struct_fields.zig\n\n    $ zig test test_aligned_struct_fields.zig\n    1/1 test_aligned_struct_fields.test.aligned struct fields...OK\n    All 1 tests passed.\n\nShell\n\nUsing packed structs with [volatile](#volatile) is problematic, and may be a compile error in the future. For details on this subscribe to [this issue](https://github.com/ziglang/zig/issues/1761). TODO update these docs with a recommendation on how to use packed structs with MMIO (the use case for volatile packed structs) once this issue is resolved. Don't worry, there will be a good solution for this use case in zig.\n\n### Struct Naming\n\nSince all structs are anonymous, Zig infers the type name based on a few rules.\n\n- If the struct is in the initialization expression of a variable, it gets named after that variable.\n- If the struct is in the `return` expression, it gets named after the function it is returning from, with the parameter values serialized.\n- Otherwise, the struct gets a name such as `(filename.funcname.__struct_ID)`.\n- If the struct is declared inside another struct, it gets named after both the parent struct and the name inferred by the previous rules, separated by a dot.\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    const Foo = struct {};\n    std.debug.print(\"variable: {s}\\n\", .{@typeName(Foo)});\n    std.debug.print(\"anonymous: {s}\\n\", .{@typeName(struct {})});\n    std.debug.print(\"function: {s}\\n\", .{@typeName(List(i32))});\n}\n\nfn List(comptime T: type) type {\n    return struct {\n        x: T,\n    };\n}\n```\n\nstruct_name.zig\n\n    $ zig build-exe struct_name.zig\n    $ ./struct_name\n    variable: struct_name.main.Foo\n    anonymous: struct_name.main__struct_3331\n    function: struct_name.List(i32)\n\nShell\n\n### Anonymous Struct Literals\n\nZig allows omitting the struct type of a literal. When the result is [coerced](#Type-Coercion), the struct literal will directly instantiate the [result location](#Result-Location-Semantics), with no copy:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Point = struct { x: i32, y: i32 };\n\ntest \"anonymous struct literal\" {\n    const pt: Point = .{\n        .x = 13,\n        .y = 67,\n    };\n    try expect(pt.x == 13);\n    try expect(pt.y == 67);\n}\n```\n\ntest_struct_result.zig\n\n    $ zig test test_struct_result.zig\n    1/1 test_struct_result.test.anonymous struct literal...OK\n    All 1 tests passed.\n\nShell\n\nThe struct type can be inferred. Here the [result location](#Result-Location-Semantics) does not include a type, and so Zig infers the type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"fully anonymous struct\" {\n    try check(.{\n        .int = @as(u32, 1234),\n        .float = @as(f64, 12.34),\n        .b = true,\n        .s = \"hi\",\n    });\n}\n\nfn check(args: anytype) !void {\n    try expect(args.int == 1234);\n    try expect(args.float == 12.34);\n    try expect(args.b);\n    try expect(args.s[0] == 'h');\n    try expect(args.s[1] == 'i');\n}\n```\n\ntest_anonymous_struct.zig\n\n    $ zig test test_anonymous_struct.zig\n    1/1 test_anonymous_struct.test.fully anonymous struct...OK\n    All 1 tests passed.\n\nShell\n\n### Tuples\n\nAnonymous structs can be created without specifying field names, and are referred to as \"tuples\".\n\nThe fields are implicitly named using numbers starting from 0. Because their names are integers, they cannot be accessed with `.` syntax without also wrapping them in `@\"\"`. Names inside `@\"\"` are always recognised as [identifiers](#Identifiers).\n\nLike arrays, tuples have a .len field, can be indexed (provided the index is comptime-known) and work with the ++ and \\*\\* operators. They can also be iterated over with [inline for](#inline-for).\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"tuple\" {\n    const values = .{\n        @as(u32, 1234),\n        @as(f64, 12.34),\n        true,\n        \"hi\",\n    } ++ .{false} ** 2;\n    try expect(values[0] == 1234);\n    try expect(values[4] == false);\n    inline for (values, 0..) |v, i| {\n        if (i != 2) continue;\n        try expect(v);\n    }\n    try expect(values.len == 6);\n    try expect(values.@\"3\"[0] == 'h');\n}\n```\n\ntest_tuples.zig\n\n    $ zig test test_tuples.zig\n    1/1 test_tuples.test.tuple...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [comptime](#comptime)\n- [@fieldParentPtr](#fieldParentPtr)\n\n## enum\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\nconst mem = @import(\"std\").mem;\n\n// Declare an enum.\nconst Type = enum {\n    ok,\n    not_ok,\n};\n\n// Declare a specific enum field.\nconst c = Type.ok;\n\n// If you want access to the ordinal value of an enum, you\n// can specify the tag type.\nconst Value = enum(u2) {\n    zero,\n    one,\n    two,\n};\n// Now you can cast between u2 and Value.\n// The ordinal value starts from 0, counting up by 1 from the previous member.\ntest \"enum ordinal value\" {\n    try expect(@intFromEnum(Value.zero) == 0);\n    try expect(@intFromEnum(Value.one) == 1);\n    try expect(@intFromEnum(Value.two) == 2);\n}\n\n// You can override the ordinal value for an enum.\nconst Value2 = enum(u32) {\n    hundred = 100,\n    thousand = 1000,\n    million = 1000000,\n};\ntest \"set enum ordinal value\" {\n    try expect(@intFromEnum(Value2.hundred) == 100);\n    try expect(@intFromEnum(Value2.thousand) == 1000);\n    try expect(@intFromEnum(Value2.million) == 1000000);\n}\n\n// You can also override only some values.\nconst Value3 = enum(u4) {\n    a,\n    b = 8,\n    c,\n    d = 4,\n    e,\n};\ntest \"enum implicit ordinal values and overridden values\" {\n    try expect(@intFromEnum(Value3.a) == 0);\n    try expect(@intFromEnum(Value3.b) == 8);\n    try expect(@intFromEnum(Value3.c) == 9);\n    try expect(@intFromEnum(Value3.d) == 4);\n    try expect(@intFromEnum(Value3.e) == 5);\n}\n\n// Enums can have methods, the same as structs and unions.\n// Enum methods are not special, they are only namespaced\n// functions that you can call with dot syntax.\nconst Suit = enum {\n    clubs,\n    spades,\n    diamonds,\n    hearts,\n\n    pub fn isClubs(self: Suit) bool {\n        return self == Suit.clubs;\n    }\n};\ntest \"enum method\" {\n    const p = Suit.spades;\n    try expect(!p.isClubs());\n}\n\n// An enum can be switched upon.\nconst Foo = enum {\n    string,\n    number,\n    none,\n};\ntest \"enum switch\" {\n    const p = Foo.number;\n    const what_is_it = switch (p) {\n        Foo.string => \"this is a string\",\n        Foo.number => \"this is a number\",\n        Foo.none => \"this is a none\",\n    };\n    try expect(mem.eql(u8, what_is_it, \"this is a number\"));\n}\n\n// @typeInfo can be used to access the integer tag type of an enum.\nconst Small = enum {\n    one,\n    two,\n    three,\n    four,\n};\ntest \"std.meta.Tag\" {\n    try expect(@typeInfo(Small).Enum.tag_type == u2);\n}\n\n// @typeInfo tells us the field count and the fields names:\ntest \"@typeInfo\" {\n    try expect(@typeInfo(Small).Enum.fields.len == 4);\n    try expect(mem.eql(u8, @typeInfo(Small).Enum.fields[1].name, \"two\"));\n}\n\n// @tagName gives a [:0]const u8 representation of an enum value:\ntest \"@tagName\" {\n    try expect(mem.eql(u8, @tagName(Small.three), \"three\"));\n}\n```\n\ntest_enums.zig\n\n    $ zig test test_enums.zig\n    1/8 test_enums.test.enum ordinal value...OK\n    2/8 test_enums.test.set enum ordinal value...OK\n    3/8 test_enums.test.enum implicit ordinal values and overridden values...OK\n    4/8 test_enums.test.enum method...OK\n    5/8 test_enums.test.enum switch...OK\n    6/8 test_enums.test.std.meta.Tag...OK\n    7/8 test_enums.test.@typeInfo...OK\n    8/8 test_enums.test.@tagName...OK\n    All 8 tests passed.\n\nShell\n\nSee also:\n\n- [@typeInfo](#typeInfo)\n- [@tagName](#tagName)\n- [@sizeOf](#sizeOf)\n\n### extern enum\n\nBy default, enums are not guaranteed to be compatible with the C ABI:\n\n``` zig\nconst Foo = enum { a, b, c };\nexport fn entry(foo: Foo) void {\n    _ = foo;\n}\n```\n\nenum_export_error.zig\n\n    $ zig build-obj enum_export_error.zig\n    doc/langref/enum_export_error.zig:2:17: error: parameter of type 'enum_export_error.Foo' not allowed in function with calling convention 'C'\n    export fn entry(foo: Foo) void {\n                    ^~~~~~~~\n    doc/langref/enum_export_error.zig:2:17: note: enum tag type 'u2' is not extern compatible\n    doc/langref/enum_export_error.zig:2:17: note: only integers with 0, 8, 16, 32, 64 and 128 bits are extern compatible\n    doc/langref/enum_export_error.zig:1:13: note: enum declared here\n    const Foo = enum { a, b, c };\n                ^~~~~~~~~~~~~~~~\n\nShell\n\nFor a C-ABI-compatible enum, provide an explicit tag type to the enum:\n\n``` zig\nconst Foo = enum(c_int) { a, b, c };\nexport fn entry(foo: Foo) void {\n    _ = foo;\n}\n```\n\nenum_export.zig\n\n    $ zig build-obj enum_export.zig\n\nShell\n\n### Enum Literals\n\nEnum literals allow specifying the name of an enum field without specifying the enum type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Color = enum {\n    auto,\n    off,\n    on,\n};\n\ntest \"enum literals\" {\n    const color1: Color = .auto;\n    const color2 = Color.auto;\n    try expect(color1 == color2);\n}\n\ntest \"switch using enum literals\" {\n    const color = Color.on;\n    const result = switch (color) {\n        .auto => false,\n        .on => true,\n        .off => false,\n    };\n    try expect(result);\n}\n```\n\ntest_enum_literals.zig\n\n    $ zig test test_enum_literals.zig\n    1/2 test_enum_literals.test.enum literals...OK\n    2/2 test_enum_literals.test.switch using enum literals...OK\n    All 2 tests passed.\n\nShell\n\n### Non-exhaustive enum\n\nA non-exhaustive enum can be created by adding a trailing `_` field. The enum must specify a tag type and cannot consume every enumeration value.\n\n[@enumFromInt](#enumFromInt) on a non-exhaustive enum involves the safety semantics of [@intCast](#intCast) to the integer tag type, but beyond that always results in a well-defined enum value.\n\nA switch on a non-exhaustive enum can include a `_` prong as an alternative to an `else` prong. With a `_` prong the compiler errors if all the known tag names are not handled by the switch.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Number = enum(u8) {\n    one,\n    two,\n    three,\n    _,\n};\n\ntest \"switch on non-exhaustive enum\" {\n    const number = Number.one;\n    const result = switch (number) {\n        .one => true,\n        .two, .three => false,\n        _ => false,\n    };\n    try expect(result);\n    const is_one = switch (number) {\n        .one => true,\n        else => false,\n    };\n    try expect(is_one);\n}\n```\n\ntest_switch_non-exhaustive.zig\n\n    $ zig test test_switch_non-exhaustive.zig\n    1/1 test_switch_non-exhaustive.test.switch on non-exhaustive enum...OK\n    All 1 tests passed.\n\nShell\n\n## union\n\nA bare `union` defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use [@ptrCast](#ptrCast), or use an [extern union](#extern-union) or a [packed union](#packed-union) which have guaranteed in-memory layout. [Accessing the non-active field](#Wrong-Union-Field-Access) is safety-checked [Undefined Behavior](#Undefined-Behavior):\n\n``` zig\nconst Payload = union {\n    int: i64,\n    float: f64,\n    boolean: bool,\n};\ntest \"simple union\" {\n    var payload = Payload{ .int = 1234 };\n    payload.float = 12.34;\n}\n```\n\ntest_wrong_union_access.zig\n\n    $ zig test test_wrong_union_access.zig\n    1/1 test_wrong_union_access.test.simple union...thread 3579408 panic: access of union field 'float' while field 'int' is active\n    /home/andy/src/zig/doc/langref/test_wrong_union_access.zig:8:12: 0x103ce87 in test.simple union (test)\n        payload.float = 12.34;\n               ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048070 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e08b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d419 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cf81 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/bb9968225995fac0bbc9f2116e8583c2/test\n\nShell\n\nYou can activate another field by assigning the entire union:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Payload = union {\n    int: i64,\n    float: f64,\n    boolean: bool,\n};\ntest \"simple union\" {\n    var payload = Payload{ .int = 1234 };\n    try expect(payload.int == 1234);\n    payload = Payload{ .float = 12.34 };\n    try expect(payload.float == 12.34);\n}\n```\n\ntest_simple_union.zig\n\n    $ zig test test_simple_union.zig\n    1/1 test_simple_union.test.simple union...OK\n    All 1 tests passed.\n\nShell\n\nIn order to use [switch](#switch) with a union, it must be a [Tagged union](#Tagged-union).\n\nTo initialize a union when the tag is a [comptime](#comptime)-known name, see [@unionInit](#unionInit).\n\n### Tagged union\n\nUnions can be declared with an enum tag type. This turns the union into a *tagged* union, which makes it eligible to use with [switch](#switch) expressions. Tagged unions coerce to their tag type: [Type Coercion: Unions and Enums](#Type-Coercion-Unions-and-Enums).\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst ComplexTypeTag = enum {\n    ok,\n    not_ok,\n};\nconst ComplexType = union(ComplexTypeTag) {\n    ok: u8,\n    not_ok: void,\n};\n\ntest \"switch on tagged union\" {\n    const c = ComplexType{ .ok = 42 };\n    try expect(@as(ComplexTypeTag, c) == ComplexTypeTag.ok);\n\n    switch (c) {\n        ComplexTypeTag.ok => |value| try expect(value == 42),\n        ComplexTypeTag.not_ok => unreachable,\n    }\n}\n\ntest \"get tag type\" {\n    try expect(std.meta.Tag(ComplexType) == ComplexTypeTag);\n}\n```\n\ntest_tagged_union.zig\n\n    $ zig test test_tagged_union.zig\n    1/2 test_tagged_union.test.switch on tagged union...OK\n    2/2 test_tagged_union.test.get tag type...OK\n    All 2 tests passed.\n\nShell\n\nIn order to modify the payload of a tagged union in a switch expression, place a `*` before the variable name to make it a pointer:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst ComplexTypeTag = enum {\n    ok,\n    not_ok,\n};\nconst ComplexType = union(ComplexTypeTag) {\n    ok: u8,\n    not_ok: void,\n};\n\ntest \"modify tagged union in switch\" {\n    var c = ComplexType{ .ok = 42 };\n\n    switch (c) {\n        ComplexTypeTag.ok => |*value| value.* += 1,\n        ComplexTypeTag.not_ok => unreachable,\n    }\n\n    try expect(c.ok == 43);\n}\n```\n\ntest_switch_modify_tagged_union.zig\n\n    $ zig test test_switch_modify_tagged_union.zig\n    1/1 test_switch_modify_tagged_union.test.modify tagged union in switch...OK\n    All 1 tests passed.\n\nShell\n\nUnions can be made to infer the enum tag type. Further, unions can have methods just like structs and enums.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Variant = union(enum) {\n    int: i32,\n    boolean: bool,\n\n    // void can be omitted when inferring enum tag type.\n    none,\n\n    fn truthy(self: Variant) bool {\n        return switch (self) {\n            Variant.int => |x_int| x_int != 0,\n            Variant.boolean => |x_bool| x_bool,\n            Variant.none => false,\n        };\n    }\n};\n\ntest \"union method\" {\n    var v1 = Variant{ .int = 1 };\n    var v2 = Variant{ .boolean = false };\n\n    try expect(v1.truthy());\n    try expect(!v2.truthy());\n}\n```\n\ntest_union_method.zig\n\n    $ zig test test_union_method.zig\n    1/1 test_union_method.test.union method...OK\n    All 1 tests passed.\n\nShell\n\n[@tagName](#tagName) can be used to return a [comptime](#comptime) `[:``0``]``const`` ``u8` value representing the field name:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Small2 = union(enum) {\n    a: i32,\n    b: bool,\n    c: u8,\n};\ntest \"@tagName\" {\n    try expect(std.mem.eql(u8, @tagName(Small2.a), \"a\"));\n}\n```\n\ntest_tagName.zig\n\n    $ zig test test_tagName.zig\n    1/1 test_tagName.test.@tagName...OK\n    All 1 tests passed.\n\nShell\n\n### extern union\n\nAn `extern`` ``union` has memory layout guaranteed to be compatible with the target C ABI.\n\nSee also:\n\n- [extern struct](#extern-struct)\n\n### packed union\n\nA `packed`` ``union` has well-defined in-memory layout and is eligible to be in a [packed struct](#packed-struct).\n\n### Anonymous Union Literals\n\n[Anonymous Struct Literals](#Anonymous-Struct-Literals) syntax can be used to initialize unions without specifying the type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Number = union {\n    int: i32,\n    float: f64,\n};\n\ntest \"anonymous union literal syntax\" {\n    const i: Number = .{ .int = 42 };\n    const f = makeNumber();\n    try expect(i.int == 42);\n    try expect(f.float == 12.34);\n}\n\nfn makeNumber() Number {\n    return .{ .float = 12.34 };\n}\n```\n\ntest_anonymous_union.zig\n\n    $ zig test test_anonymous_union.zig\n    1/1 test_anonymous_union.test.anonymous union literal syntax...OK\n    All 1 tests passed.\n\nShell\n\n## opaque\n\n`opaque`` {}` declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as [structs](#struct), [unions](#union), and [enums](#enum).\n\nThis is typically used for type safety when interacting with C code that does not expose struct details. Example:\n\n``` zig\nconst Derp = opaque {};\nconst Wat = opaque {};\n\nextern fn bar(d: *Derp) void;\nfn foo(w: *Wat) callconv(.C) void {\n    bar(w);\n}\n\ntest \"call foo\" {\n    foo(undefined);\n}\n```\n\ntest_opaque.zig\n\n    $ zig test test_opaque.zig\n    doc/langref/test_opaque.zig:6:9: error: expected type '*test_opaque.Derp', found '*test_opaque.Wat'\n        bar(w);\n            ^\n    doc/langref/test_opaque.zig:6:9: note: pointer type child 'test_opaque.Wat' cannot cast into pointer type child 'test_opaque.Derp'\n    doc/langref/test_opaque.zig:2:13: note: opaque declared here\n    const Wat = opaque {};\n                ^~~~~~~~~\n    doc/langref/test_opaque.zig:1:14: note: opaque declared here\n    const Derp = opaque {};\n                 ^~~~~~~~~\n    doc/langref/test_opaque.zig:4:18: note: parameter type declared here\n    extern fn bar(d: *Derp) void;\n                     ^~~~~\n    referenced by:\n        test.call foo: doc/langref/test_opaque.zig:10:5\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\n## Blocks\n\nBlocks are used to limit the scope of variable declarations:\n\n``` zig\ntest \"access variable after block scope\" {\n    {\n        var x: i32 = 1;\n        _ = &x;\n    }\n    x += 1;\n}\n```\n\ntest_blocks.zig\n\n    $ zig test test_blocks.zig\n    doc/langref/test_blocks.zig:6:5: error: use of undeclared identifier 'x'\n        x += 1;\n        ^\n\nShell\n\nBlocks are expressions. When labeled, `break` can be used to return a value from the block:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"labeled break from labeled block expression\" {\n    var y: i32 = 123;\n\n    const x = blk: {\n        y += 1;\n        break :blk y;\n    };\n    try expect(x == 124);\n    try expect(y == 124);\n}\n```\n\ntest_labeled_break.zig\n\n    $ zig test test_labeled_break.zig\n    1/1 test_labeled_break.test.labeled break from labeled block expression...OK\n    All 1 tests passed.\n\nShell\n\nHere, `blk` can be any name.\n\nSee also:\n\n- [Labeled while](#Labeled-while)\n- [Labeled for](#Labeled-for)\n\n### Shadowing\n\n[Identifiers](#Identifiers) are never allowed to \"hide\" other identifiers by using the same name:\n\n``` zig\nconst pi = 3.14;\n\ntest \"inside test block\" {\n    // Let's even go inside another block\n    {\n        var pi: i32 = 1234;\n    }\n}\n```\n\ntest_shadowing.zig\n\n    $ zig test test_shadowing.zig\n    doc/langref/test_shadowing.zig:6:13: error: local variable shadows declaration of 'pi'\n            var pi: i32 = 1234;\n                ^~\n    doc/langref/test_shadowing.zig:1:1: note: declared here\n    const pi = 3.14;\n    ^~~~~~~~~~~~~~~\n\nShell\n\nBecause of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing within the scope it is defined. Note that you can, however, use the same name if the scopes are separate:\n\n``` zig\ntest \"separate scopes\" {\n    {\n        const pi = 3.14;\n        _ = pi;\n    }\n    {\n        var pi: bool = true;\n        _ = &pi;\n    }\n}\n```\n\ntest_scopes.zig\n\n    $ zig test test_scopes.zig\n    1/1 test_scopes.test.separate scopes...OK\n    All 1 tests passed.\n\nShell\n\n### Empty Blocks\n\nAn empty block is equivalent to `void``{}`:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest {\n    const a = {};\n    const b = void{};\n    try expect(@TypeOf(a) == void);\n    try expect(@TypeOf(b) == void);\n    try expect(a == b);\n}\n```\n\ntest_empty_block.zig\n\n    $ zig test test_empty_block.zig\n    1/1 test_empty_block.test_0...OK\n    All 1 tests passed.\n\nShell\n\n## switch\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\n\ntest \"switch simple\" {\n    const a: u64 = 10;\n    const zz: u64 = 103;\n\n    // All branches of a switch expression must be able to be coerced to a\n    // common type.\n    //\n    // Branches cannot fallthrough. If fallthrough behavior is desired, combine\n    // the cases and use an if.\n    const b = switch (a) {\n        // Multiple cases can be combined via a ','\n        1, 2, 3 => 0,\n\n        // Ranges can be specified using the ... syntax. These are inclusive\n        // of both ends.\n        5...100 => 1,\n\n        // Branches can be arbitrarily complex.\n        101 => blk: {\n            const c: u64 = 5;\n            break :blk c * 2 + 1;\n        },\n\n        // Switching on arbitrary expressions is allowed as long as the\n        // expression is known at compile-time.\n        zz => zz,\n        blk: {\n            const d: u32 = 5;\n            const e: u32 = 100;\n            break :blk d + e;\n        } => 107,\n\n        // The else branch catches everything not already captured.\n        // Else branches are mandatory unless the entire range of values\n        // is handled.\n        else => 9,\n    };\n\n    try expect(b == 1);\n}\n\n// Switch expressions can be used outside a function:\nconst os_msg = switch (builtin.target.os.tag) {\n    .linux => \"we found a linux user\",\n    else => \"not a linux user\",\n};\n\n// Inside a function, switch statements implicitly are compile-time\n// evaluated if the target expression is compile-time known.\ntest \"switch inside function\" {\n    switch (builtin.target.os.tag) {\n        .fuchsia => {\n            // On an OS other than fuchsia, block is not even analyzed,\n            // so this compile error is not triggered.\n            // On fuchsia this compile error would be triggered.\n            @compileError(\"fuchsia not supported\");\n        },\n        else => {},\n    }\n}\n```\n\ntest_switch.zig\n\n    $ zig test test_switch.zig\n    1/2 test_switch.test.switch simple...OK\n    2/2 test_switch.test.switch inside function...OK\n    All 2 tests passed.\n\nShell\n\n`switch` can be used to capture the field values of a [Tagged union](#Tagged-union). Modifications to the field values can be done by placing a `*` before the capture variable name, turning it into a pointer.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"switch on tagged union\" {\n    const Point = struct {\n        x: u8,\n        y: u8,\n    };\n    const Item = union(enum) {\n        a: u32,\n        c: Point,\n        d,\n        e: u32,\n    };\n\n    var a = Item{ .c = Point{ .x = 1, .y = 2 } };\n\n    // Switching on more complex enums is allowed.\n    const b = switch (a) {\n        // A capture group is allowed on a match, and will return the enum\n        // value matched. If the payload types of both cases are the same\n        // they can be put into the same switch prong.\n        Item.a, Item.e => |item| item,\n\n        // A reference to the matched value can be obtained using `*` syntax.\n        Item.c => |*item| blk: {\n            item.*.x += 1;\n            break :blk 6;\n        },\n\n        // No else is required if the types cases was exhaustively handled\n        Item.d => 8,\n    };\n\n    try expect(b == 6);\n    try expect(a.c.x == 2);\n}\n```\n\ntest_switch_tagged_union.zig\n\n    $ zig test test_switch_tagged_union.zig\n    1/1 test_switch_tagged_union.test.switch on tagged union...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [comptime](#comptime)\n- [enum](#enum)\n- [@compileError](#compileError)\n- [Compile Variables](#Compile-Variables)\n\n### Exhaustive Switching\n\nWhen a `switch` expression does not have an `else` clause, it must exhaustively list all the possible values. Failure to do so is a compile error:\n\n``` zig\nconst Color = enum {\n    auto,\n    off,\n    on,\n};\n\ntest \"exhaustive switching\" {\n    const color = Color.off;\n    switch (color) {\n        Color.auto => {},\n        Color.on => {},\n    }\n}\n```\n\ntest_unhandled_enumeration_value.zig\n\n    $ zig test test_unhandled_enumeration_value.zig\n    doc/langref/test_unhandled_enumeration_value.zig:9:5: error: switch must handle all possibilities\n        switch (color) {\n        ^~~~~~\n    doc/langref/test_unhandled_enumeration_value.zig:3:5: note: unhandled enumeration value: 'off'\n        off,\n        ^~~\n    doc/langref/test_unhandled_enumeration_value.zig:1:15: note: enum 'test_unhandled_enumeration_value.Color' declared here\n    const Color = enum {\n                  ^~~~\n\nShell\n\n### Switching with Enum Literals\n\n[Enum Literals](#Enum-Literals) can be useful to use with `switch` to avoid repetitively specifying [enum](#enum) or [union](#union) types:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Color = enum {\n    auto,\n    off,\n    on,\n};\n\ntest \"enum literals with switch\" {\n    const color = Color.off;\n    const result = switch (color) {\n        .auto => false,\n        .on => false,\n        .off => true,\n    };\n    try expect(result);\n}\n```\n\ntest_exhaustive_switch.zig\n\n    $ zig test test_exhaustive_switch.zig\n    1/1 test_exhaustive_switch.test.enum literals with switch...OK\n    All 1 tests passed.\n\nShell\n\n### Inline Switch Prongs\n\nSwitch prongs can be marked as `inline` to generate the prong's body for each possible value it could have, making the captured value [comptime](#comptime).\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst expectError = std.testing.expectError;\n\nfn isFieldOptional(comptime T: type, field_index: usize) !bool {\n    const fields = @typeInfo(T).Struct.fields;\n    return switch (field_index) {\n        // This prong is analyzed twice with `idx` being a\n        // comptime-known value each time.\n        inline 0, 1 => |idx| @typeInfo(fields[idx].type) == .Optional,\n        else => return error.IndexOutOfBounds,\n    };\n}\n\nconst Struct1 = struct { a: u32, b: ?u32 };\n\ntest \"using @typeInfo with runtime values\" {\n    var index: usize = 0;\n    try expect(!try isFieldOptional(Struct1, index));\n    index += 1;\n    try expect(try isFieldOptional(Struct1, index));\n    index += 1;\n    try expectError(error.IndexOutOfBounds, isFieldOptional(Struct1, index));\n}\n\n// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent\n// of this function:\nfn isFieldOptionalUnrolled(field_index: usize) !bool {\n    return switch (field_index) {\n        0 => false,\n        1 => true,\n        else => return error.IndexOutOfBounds,\n    };\n}\n```\n\ntest_inline_switch.zig\n\n    $ zig test test_inline_switch.zig\n    1/1 test_inline_switch.test.using @typeInfo with runtime values...OK\n    All 1 tests passed.\n\nShell\n\nThe `inline` keyword may also be combined with ranges:\n\n``` zig\nfn isFieldOptional(comptime T: type, field_index: usize) !bool {\n    const fields = @typeInfo(T).Struct.fields;\n    return switch (field_index) {\n        inline 0...fields.len - 1 => |idx| @typeInfo(fields[idx].type) == .Optional,\n        else => return error.IndexOutOfBounds,\n    };\n}\n```\n\ninline_prong_range.zig\n\n`inline`` ``else` prongs can be used as a type safe alternative to `inline`` ``for` loops:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst SliceTypeA = extern struct {\n    len: usize,\n    ptr: [*]u32,\n};\nconst SliceTypeB = extern struct {\n    ptr: [*]SliceTypeA,\n    len: usize,\n};\nconst AnySlice = union(enum) {\n    a: SliceTypeA,\n    b: SliceTypeB,\n    c: []const u8,\n    d: []AnySlice,\n};\n\nfn withFor(any: AnySlice) usize {\n    const Tag = @typeInfo(AnySlice).Union.tag_type.?;\n    inline for (@typeInfo(Tag).Enum.fields) |field| {\n        // With `inline for` the function gets generated as\n        // a series of `if` statements relying on the optimizer\n        // to convert it to a switch.\n        if (field.value == @intFromEnum(any)) {\n            return @field(any, field.name).len;\n        }\n    }\n    // When using `inline for` the compiler doesn't know that every\n    // possible case has been handled requiring an explicit `unreachable`.\n    unreachable;\n}\n\nfn withSwitch(any: AnySlice) usize {\n    return switch (any) {\n        // With `inline else` the function is explicitly generated\n        // as the desired switch and the compiler can check that\n        // every possible case is handled.\n        inline else => |slice| slice.len,\n    };\n}\n\ntest \"inline for and inline else similarity\" {\n    const any = AnySlice{ .c = \"hello\" };\n    try expect(withFor(any) == 5);\n    try expect(withSwitch(any) == 5);\n}\n```\n\ntest_inline_else.zig\n\n    $ zig test test_inline_else.zig\n    1/1 test_inline_else.test.inline for and inline else similarity...OK\n    All 1 tests passed.\n\nShell\n\nWhen using an inline prong switching on an union an additional capture can be used to obtain the union's enum tag value.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst U = union(enum) {\n    a: u32,\n    b: f32,\n};\n\nfn getNum(u: U) u32 {\n    switch (u) {\n        // Here `num` is a runtime-known value that is either\n        // `u.a` or `u.b` and `tag` is `u`'s comptime-known tag value.\n        inline else => |num, tag| {\n            if (tag == .b) {\n                return @intFromFloat(num);\n            }\n            return num;\n        },\n    }\n}\n\ntest \"test\" {\n    const u = U{ .b = 42 };\n    try expect(getNum(u) == 42);\n}\n```\n\ntest_inline_switch_union_tag.zig\n\n    $ zig test test_inline_switch_union_tag.zig\n    1/1 test_inline_switch_union_tag.test.test...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [inline while](#inline-while)\n- [inline for](#inline-for)\n\n## while\n\nA while loop is used to repeatedly execute an expression until some condition is no longer true.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while basic\" {\n    var i: usize = 0;\n    while (i < 10) {\n        i += 1;\n    }\n    try expect(i == 10);\n}\n```\n\ntest_while.zig\n\n    $ zig test test_while.zig\n    1/1 test_while.test.while basic...OK\n    All 1 tests passed.\n\nShell\n\nUse `break` to exit a while loop early.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while break\" {\n    var i: usize = 0;\n    while (true) {\n        if (i == 10)\n            break;\n        i += 1;\n    }\n    try expect(i == 10);\n}\n```\n\ntest_while_break.zig\n\n    $ zig test test_while_break.zig\n    1/1 test_while_break.test.while break...OK\n    All 1 tests passed.\n\nShell\n\nUse `continue` to jump back to the beginning of the loop.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while continue\" {\n    var i: usize = 0;\n    while (true) {\n        i += 1;\n        if (i < 10)\n            continue;\n        break;\n    }\n    try expect(i == 10);\n}\n```\n\ntest_while_continue.zig\n\n    $ zig test test_while_continue.zig\n    1/1 test_while_continue.test.while continue...OK\n    All 1 tests passed.\n\nShell\n\nWhile loops support a continue expression which is executed when the loop is continued. The `continue` keyword respects this expression.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while loop continue expression\" {\n    var i: usize = 0;\n    while (i < 10) : (i += 1) {}\n    try expect(i == 10);\n}\n\ntest \"while loop continue expression, more complicated\" {\n    var i: usize = 1;\n    var j: usize = 1;\n    while (i * j < 2000) : ({\n        i *= 2;\n        j *= 3;\n    }) {\n        const my_ij = i * j;\n        try expect(my_ij < 2000);\n    }\n}\n```\n\ntest_while_continue_expression.zig\n\n    $ zig test test_while_continue_expression.zig\n    1/2 test_while_continue_expression.test.while loop continue expression...OK\n    2/2 test_while_continue_expression.test.while loop continue expression, more complicated...OK\n    All 2 tests passed.\n\nShell\n\nWhile loops are expressions. The result of the expression is the result of the `else` clause of a while loop, which is executed when the condition of the while loop is tested as false.\n\n`break`, like `return`, accepts a value parameter. This is the result of the `while` expression. When you `break` from a while loop, the `else` branch is not evaluated.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while else\" {\n    try expect(rangeHasNumber(0, 10, 5));\n    try expect(!rangeHasNumber(0, 10, 15));\n}\n\nfn rangeHasNumber(begin: usize, end: usize, number: usize) bool {\n    var i = begin;\n    return while (i < end) : (i += 1) {\n        if (i == number) {\n            break true;\n        }\n    } else false;\n}\n```\n\ntest_while_else.zig\n\n    $ zig test test_while_else.zig\n    1/1 test_while_else.test.while else...OK\n    All 1 tests passed.\n\nShell\n\n### Labeled while\n\nWhen a `while` loop is labeled, it can be referenced from a `break` or `continue` from within a nested loop:\n\n``` zig\ntest \"nested break\" {\n    outer: while (true) {\n        while (true) {\n            break :outer;\n        }\n    }\n}\n\ntest \"nested continue\" {\n    var i: usize = 0;\n    outer: while (i < 10) : (i += 1) {\n        while (true) {\n            continue :outer;\n        }\n    }\n}\n```\n\ntest_while_nested_break.zig\n\n    $ zig test test_while_nested_break.zig\n    1/2 test_while_nested_break.test.nested break...OK\n    2/2 test_while_nested_break.test.nested continue...OK\n    All 2 tests passed.\n\nShell\n\n### while with Optionals\n\nJust like [if](#if) expressions, while loops can take an optional as the condition and capture the payload. When [null](#null) is encountered the loop exits.\n\nWhen the `|x|` syntax is present on a `while` expression, the while condition must have an [Optional Type](#Optional-Type).\n\nThe `else` branch is allowed on optional iteration. In this case, it will be executed on the first null value encountered.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while null capture\" {\n    var sum1: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyNullSequence()) |value| {\n        sum1 += value;\n    }\n    try expect(sum1 == 3);\n\n    // null capture with an else block\n    var sum2: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyNullSequence()) |value| {\n        sum2 += value;\n    } else {\n        try expect(sum2 == 3);\n    }\n\n    // null capture with a continue expression\n    var i: u32 = 0;\n    var sum3: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyNullSequence()) |value| : (i += 1) {\n        sum3 += value;\n    }\n    try expect(i == 3);\n}\n\nvar numbers_left: u32 = undefined;\nfn eventuallyNullSequence() ?u32 {\n    return if (numbers_left == 0) null else blk: {\n        numbers_left -= 1;\n        break :blk numbers_left;\n    };\n}\n```\n\ntest_while_null_capture.zig\n\n    $ zig test test_while_null_capture.zig\n    1/1 test_while_null_capture.test.while null capture...OK\n    All 1 tests passed.\n\nShell\n\n### while with Error Unions\n\nJust like [if](#if) expressions, while loops can take an error union as the condition and capture the payload or the error code. When the condition results in an error code the else branch is evaluated and the loop is finished.\n\nWhen the `else`` |x|` syntax is present on a `while` expression, the while condition must have an [Error Union Type](#Error-Union-Type).\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while error union capture\" {\n    var sum1: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyErrorSequence()) |value| {\n        sum1 += value;\n    } else |err| {\n        try expect(err == error.ReachedZero);\n    }\n}\n\nvar numbers_left: u32 = undefined;\n\nfn eventuallyErrorSequence() anyerror!u32 {\n    return if (numbers_left == 0) error.ReachedZero else blk: {\n        numbers_left -= 1;\n        break :blk numbers_left;\n    };\n}\n```\n\ntest_while_error_capture.zig\n\n    $ zig test test_while_error_capture.zig\n    1/1 test_while_error_capture.test.while error union capture...OK\n    All 1 tests passed.\n\nShell\n\n### inline while\n\nWhile loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"inline while loop\" {\n    comptime var i = 0;\n    var sum: usize = 0;\n    inline while (i < 3) : (i += 1) {\n        const T = switch (i) {\n            0 => f32,\n            1 => i8,\n            2 => bool,\n            else => unreachable,\n        };\n        sum += typeNameLength(T);\n    }\n    try expect(sum == 9);\n}\n\nfn typeNameLength(comptime T: type) usize {\n    return @typeName(T).len;\n}\n```\n\ntest_inline_while.zig\n\n    $ zig test test_inline_while.zig\n    1/1 test_inline_while.test.inline while loop...OK\n    All 1 tests passed.\n\nShell\n\nIt is recommended to use `inline` loops only for one of these reasons:\n\n- You need the loop to execute at [comptime](#comptime) for the semantics to work.\n- You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.\n\nSee also:\n\n- [if](#if)\n- [Optionals](#Optionals)\n- [Errors](#Errors)\n- [comptime](#comptime)\n- [unreachable](#unreachable)\n\n## for\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"for basics\" {\n    const items = [_]i32{ 4, 5, 3, 4, 0 };\n    var sum: i32 = 0;\n\n    // For loops iterate over slices and arrays.\n    for (items) |value| {\n        // Break and continue are supported.\n        if (value == 0) {\n            continue;\n        }\n        sum += value;\n    }\n    try expect(sum == 16);\n\n    // To iterate over a portion of a slice, reslice.\n    for (items[0..1]) |value| {\n        sum += value;\n    }\n    try expect(sum == 20);\n\n    // To access the index of iteration, specify a second condition as well\n    // as a second capture value.\n    var sum2: i32 = 0;\n    for (items, 0..) |_, i| {\n        try expect(@TypeOf(i) == usize);\n        sum2 += @as(i32, @intCast(i));\n    }\n    try expect(sum2 == 10);\n\n    // To iterate over consecutive integers, use the range syntax.\n    // Unbounded range is always a compile error.\n    var sum3: usize = 0;\n    for (0..5) |i| {\n        sum3 += i;\n    }\n    try expect(sum3 == 10);\n}\n\ntest \"multi object for\" {\n    const items = [_]usize{ 1, 2, 3 };\n    const items2 = [_]usize{ 4, 5, 6 };\n    var count: usize = 0;\n\n    // Iterate over multiple objects.\n    // All lengths must be equal at the start of the loop, otherwise detectable\n    // illegal behavior occurs.\n    for (items, items2) |i, j| {\n        count += i + j;\n    }\n\n    try expect(count == 21);\n}\n\ntest \"for reference\" {\n    var items = [_]i32{ 3, 4, 2 };\n\n    // Iterate over the slice by reference by\n    // specifying that the capture value is a pointer.\n    for (&items) |*value| {\n        value.* += 1;\n    }\n\n    try expect(items[0] == 4);\n    try expect(items[1] == 5);\n    try expect(items[2] == 3);\n}\n\ntest \"for else\" {\n    // For allows an else attached to it, the same as a while loop.\n    const items = [_]?i32{ 3, 4, null, 5 };\n\n    // For loops can also be used as expressions.\n    // Similar to while loops, when you break from a for loop, the else branch is not evaluated.\n    var sum: i32 = 0;\n    const result = for (items) |value| {\n        if (value != null) {\n            sum += value.?;\n        }\n    } else blk: {\n        try expect(sum == 12);\n        break :blk sum;\n    };\n    try expect(result == 12);\n}\n```\n\ntest_for.zig\n\n    $ zig test test_for.zig\n    1/4 test_for.test.for basics...OK\n    2/4 test_for.test.multi object for...OK\n    3/4 test_for.test.for reference...OK\n    4/4 test_for.test.for else...OK\n    All 4 tests passed.\n\nShell\n\n### Labeled for\n\nWhen a `for` loop is labeled, it can be referenced from a `break` or `continue` from within a nested loop:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"nested break\" {\n    var count: usize = 0;\n    outer: for (1..6) |_| {\n        for (1..6) |_| {\n            count += 1;\n            break :outer;\n        }\n    }\n    try expect(count == 1);\n}\n\ntest \"nested continue\" {\n    var count: usize = 0;\n    outer: for (1..9) |_| {\n        for (1..6) |_| {\n            count += 1;\n            continue :outer;\n        }\n    }\n\n    try expect(count == 8);\n}\n```\n\ntest_for_nested_break.zig\n\n    $ zig test test_for_nested_break.zig\n    1/2 test_for_nested_break.test.nested break...OK\n    2/2 test_for_nested_break.test.nested continue...OK\n    All 2 tests passed.\n\nShell\n\n### inline for\n\nFor loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"inline for loop\" {\n    const nums = [_]i32{ 2, 4, 6 };\n    var sum: usize = 0;\n    inline for (nums) |i| {\n        const T = switch (i) {\n            2 => f32,\n            4 => i8,\n            6 => bool,\n            else => unreachable,\n        };\n        sum += typeNameLength(T);\n    }\n    try expect(sum == 9);\n}\n\nfn typeNameLength(comptime T: type) usize {\n    return @typeName(T).len;\n}\n```\n\ntest_inline_for.zig\n\n    $ zig test test_inline_for.zig\n    1/1 test_inline_for.test.inline for loop...OK\n    All 1 tests passed.\n\nShell\n\nIt is recommended to use `inline` loops only for one of these reasons:\n\n- You need the loop to execute at [comptime](#comptime) for the semantics to work.\n- You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.\n\nSee also:\n\n- [while](#while)\n- [comptime](#comptime)\n- [Arrays](#Arrays)\n- [Slices](#Slices)\n\n## if\n\n``` zig\n// If expressions have three uses, corresponding to the three types:\n// * bool\n// * ?T\n// * anyerror!T\n\nconst expect = @import(\"std\").testing.expect;\n\ntest \"if expression\" {\n    // If expressions are used instead of a ternary expression.\n    const a: u32 = 5;\n    const b: u32 = 4;\n    const result = if (a != b) 47 else 3089;\n    try expect(result == 47);\n}\n\ntest \"if boolean\" {\n    // If expressions test boolean conditions.\n    const a: u32 = 5;\n    const b: u32 = 4;\n    if (a != b) {\n        try expect(true);\n    } else if (a == 9) {\n        unreachable;\n    } else {\n        unreachable;\n    }\n}\n\ntest \"if error union\" {\n    // If expressions test for errors.\n    // Note the |err| capture on the else.\n\n    const a: anyerror!u32 = 0;\n    if (a) |value| {\n        try expect(value == 0);\n    } else |err| {\n        _ = err;\n        unreachable;\n    }\n\n    const b: anyerror!u32 = error.BadValue;\n    if (b) |value| {\n        _ = value;\n        unreachable;\n    } else |err| {\n        try expect(err == error.BadValue);\n    }\n\n    // The else and |err| capture is strictly required.\n    if (a) |value| {\n        try expect(value == 0);\n    } else |_| {}\n\n    // To check only the error value, use an empty block expression.\n    if (b) |_| {} else |err| {\n        try expect(err == error.BadValue);\n    }\n\n    // Access the value by reference using a pointer capture.\n    var c: anyerror!u32 = 3;\n    if (c) |*value| {\n        value.* = 9;\n    } else |_| {\n        unreachable;\n    }\n\n    if (c) |value| {\n        try expect(value == 9);\n    } else |_| {\n        unreachable;\n    }\n}\n```\n\ntest_if.zig\n\n    $ zig test test_if.zig\n    1/3 test_if.test.if expression...OK\n    2/3 test_if.test.if boolean...OK\n    3/3 test_if.test.if error union...OK\n    All 3 tests passed.\n\nShell\n\n### if with Optionals\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"if optional\" {\n    // If expressions test for null.\n\n    const a: ?u32 = 0;\n    if (a) |value| {\n        try expect(value == 0);\n    } else {\n        unreachable;\n    }\n\n    const b: ?u32 = null;\n    if (b) |_| {\n        unreachable;\n    } else {\n        try expect(true);\n    }\n\n    // The else is not required.\n    if (a) |value| {\n        try expect(value == 0);\n    }\n\n    // To test against null only, use the binary equality operator.\n    if (b == null) {\n        try expect(true);\n    }\n\n    // Access the value by reference using a pointer capture.\n    var c: ?u32 = 3;\n    if (c) |*value| {\n        value.* = 2;\n    }\n\n    if (c) |value| {\n        try expect(value == 2);\n    } else {\n        unreachable;\n    }\n}\n\ntest \"if error union with optional\" {\n    // If expressions test for errors before unwrapping optionals.\n    // The |optional_value| capture's type is ?u32.\n\n    const a: anyerror!?u32 = 0;\n    if (a) |optional_value| {\n        try expect(optional_value.? == 0);\n    } else |err| {\n        _ = err;\n        unreachable;\n    }\n\n    const b: anyerror!?u32 = null;\n    if (b) |optional_value| {\n        try expect(optional_value == null);\n    } else |_| {\n        unreachable;\n    }\n\n    const c: anyerror!?u32 = error.BadValue;\n    if (c) |optional_value| {\n        _ = optional_value;\n        unreachable;\n    } else |err| {\n        try expect(err == error.BadValue);\n    }\n\n    // Access the value by reference by using a pointer capture each time.\n    var d: anyerror!?u32 = 3;\n    if (d) |*optional_value| {\n        if (optional_value.*) |*value| {\n            value.* = 9;\n        }\n    } else |_| {\n        unreachable;\n    }\n\n    if (d) |optional_value| {\n        try expect(optional_value.? == 9);\n    } else |_| {\n        unreachable;\n    }\n}\n```\n\ntest_if_optionals.zig\n\n    $ zig test test_if_optionals.zig\n    1/2 test_if_optionals.test.if optional...OK\n    2/2 test_if_optionals.test.if error union with optional...OK\n    All 2 tests passed.\n\nShell\n\nSee also:\n\n- [Optionals](#Optionals)\n- [Errors](#Errors)\n\n## defer\n\nExecutes an expression unconditionally at scope exit.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst print = std.debug.print;\n\nfn deferExample() !usize {\n    var a: usize = 1;\n\n    {\n        defer a = 2;\n        a = 1;\n    }\n    try expect(a == 2);\n\n    a = 5;\n    return a;\n}\n\ntest \"defer basics\" {\n    try expect((try deferExample()) == 5);\n}\n```\n\ntest_defer.zig\n\n    $ zig test test_defer.zig\n    1/1 test_defer.test.defer basics...OK\n    All 1 tests passed.\n\nShell\n\nDefer expressions are evaluated in reverse order.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst print = std.debug.print;\n\ntest \"defer unwinding\" {\n    print(\"\\n\", .{});\n\n    defer {\n        print(\"1 \", .{});\n    }\n    defer {\n        print(\"2 \", .{});\n    }\n    if (false) {\n        // defers are not run if they are never executed.\n        defer {\n            print(\"3 \", .{});\n        }\n    }\n}\n```\n\ndefer_unwind.zig\n\n    $ zig test defer_unwind.zig\n    1/1 defer_unwind.test.defer unwinding...\n    2 1 OK\n    All 1 tests passed.\n\nShell\n\nInside a defer expression the return statement is not allowed.\n\n``` zig\nfn deferInvalidExample() !void {\n    defer {\n        return error.DeferError;\n    }\n\n    return error.DeferError;\n}\n```\n\ntest_invalid_defer.zig\n\n    $ zig test test_invalid_defer.zig\n    doc/langref/test_invalid_defer.zig:3:9: error: cannot return from defer expression\n            return error.DeferError;\n            ^~~~~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_invalid_defer.zig:2:5: note: defer expression here\n        defer {\n        ^~~~~\n\nShell\n\nSee also:\n\n- [Errors](#Errors)\n\n## unreachable\n\nIn [Debug](#Debug) and [ReleaseSafe](#ReleaseSafe) mode `unreachable` emits a call to `panic` with the message `reached unreachable code`.\n\nIn [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) mode, the optimizer uses the assumption that `unreachable` code will never be hit to perform optimizations.\n\n### Basics\n\n``` zig\n// unreachable is used to assert that control flow will never reach a\n// particular location:\ntest \"basic math\" {\n    const x = 1;\n    const y = 2;\n    if (x + y != 3) {\n        unreachable;\n    }\n}\n```\n\ntest_unreachable.zig\n\n    $ zig test test_unreachable.zig\n    1/1 test_unreachable.test.basic math...OK\n    All 1 tests passed.\n\nShell\n\nIn fact, this is how `std.debug.assert` is implemented:\n\n``` zig\n// This is how std.debug.assert is implemented\nfn assert(ok: bool) void {\n    if (!ok) unreachable; // assertion failure\n}\n\n// This test will fail because we hit unreachable.\ntest \"this will fail\" {\n    assert(false);\n}\n```\n\ntest_assertion_failure.zig\n\n    $ zig test test_assertion_failure.zig\n    1/1 test_assertion_failure.test.this will fail...thread 3571599 panic: reached unreachable code\n    /home/andy/src/zig/doc/langref/test_assertion_failure.zig:3:14: 0x103cd9d in assert (test)\n        if (!ok) unreachable; // assertion failure\n                 ^\n    /home/andy/src/zig/doc/langref/test_assertion_failure.zig:8:11: 0x103cd5a in test.this will fail (test)\n        assert(false);\n              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x10479a0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103dbbb in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d249 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cdb1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/a6b3ce5875a9e285c15739b2a1b30733/test\n\nShell\n\n### At Compile-Time\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\n\ntest \"type of unreachable\" {\n    comptime {\n        // The type of unreachable is noreturn.\n\n        // However this assertion will still fail to compile because\n        // unreachable expressions are compile errors.\n\n        assert(@TypeOf(unreachable) == noreturn);\n    }\n}\n```\n\ntest_comptime_unreachable.zig\n\n    $ zig test test_comptime_unreachable.zig\n    doc/langref/test_comptime_unreachable.zig:10:16: error: unreachable code\n            assert(@TypeOf(unreachable) == noreturn);\n                   ^~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_comptime_unreachable.zig:10:24: note: control flow is diverted here\n            assert(@TypeOf(unreachable) == noreturn);\n                           ^~~~~~~~~~~\n\nShell\n\nSee also:\n\n- [Zig Test](#Zig-Test)\n- [Build Mode](#Build-Mode)\n- [comptime](#comptime)\n\n## noreturn\n\n`noreturn` is the type of:\n\n- `break`\n- `continue`\n- `return`\n- `unreachable`\n- `while`` (``true``) {}`\n\nWhen resolving types together, such as `if` clauses or `switch` prongs, the `noreturn` type is compatible with every other type. Consider:\n\n``` zig\nfn foo(condition: bool, b: u32) void {\n    const a = if (condition) b else return;\n    _ = a;\n    @panic(\"do something with a\");\n}\ntest \"noreturn\" {\n    foo(false, 1);\n}\n```\n\ntest_noreturn.zig\n\n    $ zig test test_noreturn.zig\n    1/1 test_noreturn.test.noreturn...OK\n    All 1 tests passed.\n\nShell\n\nAnother use case for `noreturn` is the `exit` function:\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst native_arch = builtin.cpu.arch;\nconst expect = std.testing.expect;\n\nconst WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C;\nextern \"kernel32\" fn ExitProcess(exit_code: c_uint) callconv(WINAPI) noreturn;\n\ntest \"foo\" {\n    const value = bar() catch ExitProcess(1);\n    try expect(value == 1234);\n}\n\nfn bar() anyerror!u32 {\n    return 1234;\n}\n```\n\ntest_noreturn_from_exit.zig\n\n    $ zig test test_noreturn_from_exit.zig -target x86_64-windows --test-no-exec\n\nShell\n\n## Functions\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst native_arch = builtin.cpu.arch;\nconst expect = std.testing.expect;\n\n// Functions are declared like this\nfn add(a: i8, b: i8) i8 {\n    if (a == 0) {\n        return b;\n    }\n\n    return a + b;\n}\n\n// The export specifier makes a function externally visible in the generated\n// object file, and makes it use the C ABI.\nexport fn sub(a: i8, b: i8) i8 {\n    return a - b;\n}\n\n// The extern specifier is used to declare a function that will be resolved\n// at link time, when linking statically, or at runtime, when linking\n// dynamically. The quoted identifier after the extern keyword specifies\n// the library that has the function. (e.g. \"c\" -> libc.so)\n// The callconv specifier changes the calling convention of the function.\nconst WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C;\nextern \"kernel32\" fn ExitProcess(exit_code: u32) callconv(WINAPI) noreturn;\nextern \"c\" fn atan2(a: f64, b: f64) f64;\n\n// The @setCold builtin tells the optimizer that a function is rarely called.\nfn abort() noreturn {\n    @setCold(true);\n    while (true) {}\n}\n\n// The naked calling convention makes a function not have any function prologue or epilogue.\n// This can be useful when integrating with assembly.\nfn _start() callconv(.Naked) noreturn {\n    abort();\n}\n\n// The inline calling convention forces a function to be inlined at all call sites.\n// If the function cannot be inlined, it is a compile-time error.\ninline fn shiftLeftOne(a: u32) u32 {\n    return a << 1;\n}\n\n// The pub specifier allows the function to be visible when importing.\n// Another file can use @import and call sub2\npub fn sub2(a: i8, b: i8) i8 {\n    return a - b;\n}\n\n// Function pointers are prefixed with `*const `.\nconst Call2Op = *const fn (a: i8, b: i8) i8;\nfn doOp(fnCall: Call2Op, op1: i8, op2: i8) i8 {\n    return fnCall(op1, op2);\n}\n\ntest \"function\" {\n    try expect(doOp(add, 5, 6) == 11);\n    try expect(doOp(sub2, 5, 6) == -1);\n}\n```\n\ntest_functions.zig\n\n    $ zig test test_functions.zig\n    1/1 test_functions.test.function...OK\n    All 1 tests passed.\n\nShell\n\nThere is a difference between a function *body* and a function *pointer*. Function bodies are [comptime](#comptime)-only types while function [Pointers](#Pointers) may be runtime-known.\n\n### Pass-by-value Parameters\n\nPrimitive types such as [Integers](#Integers) and [Floats](#Floats) passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register.\n\nStructs, unions, and arrays can sometimes be more efficiently passed as a reference, since a copy could be arbitrarily expensive depending on the size. When these types are passed as parameters, Zig may choose to copy and pass by value, or pass by reference, whichever way Zig decides will be faster. This is made possible, in part, by the fact that parameters are immutable.\n\n``` zig\nconst Point = struct {\n    x: i32,\n    y: i32,\n};\n\nfn foo(point: Point) i32 {\n    // Here, `point` could be a reference, or a copy. The function body\n    // can ignore the difference and treat it as a value. Be very careful\n    // taking the address of the parameter - it should be treated as if\n    // the address will become invalid when the function returns.\n    return point.x + point.y;\n}\n\nconst expect = @import(\"std\").testing.expect;\n\ntest \"pass struct to function\" {\n    try expect(foo(Point{ .x = 1, .y = 2 }) == 3);\n}\n```\n\ntest_pass_by_reference_or_value.zig\n\n    $ zig test test_pass_by_reference_or_value.zig\n    1/1 test_pass_by_reference_or_value.test.pass struct to function...OK\n    All 1 tests passed.\n\nShell\n\nFor extern functions, Zig follows the C ABI for passing structs and unions by value.\n\n### Function Parameter Type Inference\n\nFunction parameters can be declared with `anytype` in place of the type. In this case the parameter types will be inferred when the function is called. Use [@TypeOf](#TypeOf) and [@typeInfo](#typeInfo) to get information about the inferred type.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nfn addFortyTwo(x: anytype) @TypeOf(x) {\n    return x + 42;\n}\n\ntest \"fn type inference\" {\n    try expect(addFortyTwo(1) == 43);\n    try expect(@TypeOf(addFortyTwo(1)) == comptime_int);\n    const y: i64 = 2;\n    try expect(addFortyTwo(y) == 44);\n    try expect(@TypeOf(addFortyTwo(y)) == i64);\n}\n```\n\ntest_fn_type_inference.zig\n\n    $ zig test test_fn_type_inference.zig\n    1/1 test_fn_type_inference.test.fn type inference...OK\n    All 1 tests passed.\n\nShell\n\n### inline fn\n\nAdding the `inline` keyword to a function definition makes that function become *semantically inlined* at the callsite. This is not a hint to be possibly observed by optimization passes, but has implications on the types and values involved in the function call.\n\nUnlike normal function calls, arguments at an inline function callsite which are compile-time known are treated as [Compile Time Parameters](#Compile-Time-Parameters). This can potentially propagate all the way to the return value:\n\n``` zig\ntest \"inline function call\" {\n    if (foo(1200, 34) != 1234) {\n        @compileError(\"bad\");\n    }\n}\n\ninline fn foo(a: i32, b: i32) i32 {\n    return a + b;\n}\n```\n\ninline_call.zig\n\n    $ zig test inline_call.zig\n    1/1 inline_call.test.inline function call...OK\n    All 1 tests passed.\n\nShell\n\nIf `inline` is removed, the test fails with the compile error instead of passing.\n\nIt is generally better to let the compiler decide when to inline a function, except for these scenarios:\n\n- To change how many stack frames are in the call stack, for debugging purposes.\n- To force comptime-ness of the arguments to propagate to the return value of the function, as in the above example.\n- Real world performance measurements demand it.\n\nNote that `inline` actually *restricts* what the compiler is allowed to do. This can harm binary size, compilation speed, and even runtime performance.\n\n### Function Reflection\n\n``` zig\nconst std = @import(\"std\");\nconst math = std.math;\nconst testing = std.testing;\n\ntest \"fn reflection\" {\n    try testing.expect(@typeInfo(@TypeOf(testing.expect)).Fn.params[0].type.? == bool);\n    try testing.expect(@typeInfo(@TypeOf(testing.tmpDir)).Fn.return_type.? == testing.TmpDir);\n\n    try testing.expect(@typeInfo(@TypeOf(math.Log2Int)).Fn.is_generic);\n}\n```\n\ntest_fn_reflection.zig\n\n    $ zig test test_fn_reflection.zig\n    1/1 test_fn_reflection.test.fn reflection...OK\n    All 1 tests passed.\n\nShell\n\n## Errors\n\n### Error Set Type\n\nAn error set is like an [enum](#enum). However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value.\n\nThe error set type defaults to a `u16`, though if the maximum number of distinct error values is provided via the --error-limit \\[num\\] command line parameter an integer type with the minimum number of bits required to represent all of the error values will be used.\n\nYou can [coerce](#Type-Coercion) an error from a subset to a superset:\n\n``` zig\nconst std = @import(\"std\");\n\nconst FileOpenError = error{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\nconst AllocationError = error{\n    OutOfMemory,\n};\n\ntest \"coerce subset to superset\" {\n    const err = foo(AllocationError.OutOfMemory);\n    try std.testing.expect(err == FileOpenError.OutOfMemory);\n}\n\nfn foo(err: AllocationError) FileOpenError {\n    return err;\n}\n```\n\ntest_coerce_error_subset_to_superset.zig\n\n    $ zig test test_coerce_error_subset_to_superset.zig\n    1/1 test_coerce_error_subset_to_superset.test.coerce subset to superset...OK\n    All 1 tests passed.\n\nShell\n\nBut you cannot [coerce](#Type-Coercion) an error from a superset to a subset:\n\n``` zig\nconst FileOpenError = error{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\nconst AllocationError = error{\n    OutOfMemory,\n};\n\ntest \"coerce superset to subset\" {\n    foo(FileOpenError.OutOfMemory) catch {};\n}\n\nfn foo(err: FileOpenError) AllocationError {\n    return err;\n}\n```\n\ntest_coerce_error_superset_to_subset.zig\n\n    $ zig test test_coerce_error_superset_to_subset.zig\n    doc/langref/test_coerce_error_superset_to_subset.zig:16:12: error: expected type 'error{OutOfMemory}', found 'error{AccessDenied,OutOfMemory,FileNotFound}'\n        return err;\n               ^~~\n    doc/langref/test_coerce_error_superset_to_subset.zig:16:12: note: 'error.AccessDenied' not a member of destination error set\n    doc/langref/test_coerce_error_superset_to_subset.zig:16:12: note: 'error.FileNotFound' not a member of destination error set\n    doc/langref/test_coerce_error_superset_to_subset.zig:15:28: note: function return type declared here\n    fn foo(err: FileOpenError) AllocationError {\n                               ^~~~~~~~~~~~~~~\n    referenced by:\n        test.coerce superset to subset: doc/langref/test_coerce_error_superset_to_subset.zig:12:5\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\nThere is a shortcut for declaring an error set with only 1 value, and then getting that value:\n\n``` zig\nconst err = error.FileNotFound;\n```\n\nsingle_value_error_set_shortcut.zig\n\nThis is equivalent to:\n\n``` zig\nconst err = (error{FileNotFound}).FileNotFound;\n```\n\nsingle_value_error_set.zig\n\nThis becomes useful when using [Inferred Error Sets](#Inferred-Error-Sets).\n\n#### [The Global Error Set](#toc-The-Global-Error-Set)\n\n`anyerror` refers to the global error set. This is the error set that contains all errors in the entire compilation unit. It is a superset of all other error sets and a subset of none of them.\n\nYou can [coerce](#Type-Coercion) any error set to the global one, and you can explicitly cast an error of the global error set to a non-global one. This inserts a language-level assert to make sure the error value is in fact in the destination error set.\n\nThe global error set should generally be avoided because it prevents the compiler from knowing what errors are possible at compile-time. Knowing the error set at compile-time is better for generated documentation and helpful error messages, such as forgetting a possible error value in a [switch](#switch).\n\n### Error Union Type\n\nAn error set type and normal type can be combined with the `!` binary operator to form an error union type. You are likely to use an error union type more often than an error set type by itself.\n\nHere is a function to parse a string into a 64-bit integer:\n\n``` zig\nconst std = @import(\"std\");\nconst maxInt = std.math.maxInt;\n\npub fn parseU64(buf: []const u8, radix: u8) !u64 {\n    var x: u64 = 0;\n\n    for (buf) |c| {\n        const digit = charToDigit(c);\n\n        if (digit >= radix) {\n            return error.InvalidChar;\n        }\n\n        // x *= radix\n        var ov = @mulWithOverflow(x, radix);\n        if (ov[1] != 0) return error.OverFlow;\n\n        // x += digit\n        ov = @addWithOverflow(ov[0], digit);\n        if (ov[1] != 0) return error.OverFlow;\n        x = ov[0];\n    }\n\n    return x;\n}\n\nfn charToDigit(c: u8) u8 {\n    return switch (c) {\n        '0'...'9' => c - '0',\n        'A'...'Z' => c - 'A' + 10,\n        'a'...'z' => c - 'a' + 10,\n        else => maxInt(u8),\n    };\n}\n\ntest \"parse u64\" {\n    const result = try parseU64(\"1234\", 10);\n    try std.testing.expect(result == 1234);\n}\n```\n\nerror_union_parsing_u64.zig\n\n    $ zig test error_union_parsing_u64.zig\n    1/1 error_union_parsing_u64.test.parse u64...OK\n    All 1 tests passed.\n\nShell\n\nNotice the return type is `!``u64`. This means that the function either returns an unsigned 64 bit integer, or an error. We left off the error set to the left of the `!`, so the error set is inferred.\n\nWithin the function definition, you can see some return statements that return an error, and at the bottom a return statement that returns a `u64`. Both types [coerce](#Type-Coercion) to `anyerror``!``u64`.\n\nWhat it looks like to use this function varies depending on what you're trying to do. One of the following:\n\n- You want to provide a default value if it returned an error.\n- If it returned an error then you want to return the same error.\n- You know with complete certainty it will not return an error, so want to unconditionally unwrap it.\n- You want to take a different action for each possible error.\n\n#### [catch](#toc-catch)\n\nIf you want to provide a default value, you can use the `catch` binary operator:\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) void {\n    const number = parseU64(str, 10) catch 13;\n    _ = number; // ...\n}\n```\n\ncatch.zig\n\nIn this code, `number` will be equal to the successfully parsed string, or a default value of 13. The type of the right hand side of the binary `catch` operator must match the unwrapped error union type, or be of type `noreturn`.\n\nIf you want to provide a default value with `catch` after performing some logic, you can combine `catch` with named [Blocks](#Blocks):\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) void {\n    const number = parseU64(str, 10) catch blk: {\n        // do things\n        break :blk 13;\n    };\n    _ = number; // number is now initialized\n}\n```\n\nhandle_error_with_catch_block.zig.zig\n\n#### [try](#toc-try)\n\nLet's say you wanted to return the error if you got one, otherwise continue with the function logic:\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) !void {\n    const number = parseU64(str, 10) catch |err| return err;\n    _ = number; // ...\n}\n```\n\ncatch_err_return.zig\n\nThere is a shortcut for this. The `try` expression:\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) !void {\n    const number = try parseU64(str, 10);\n    _ = number; // ...\n}\n```\n\ntry.zig\n\n`try` evaluates an error union expression. If it is an error, it returns from the current function with the same error. Otherwise, the expression results in the unwrapped value.\n\nMaybe you know with complete certainty that an expression will never be an error. In this case you can do this:\n\n`const`` number = parseU64(``\"1234\"``, ``10``) ``catch`` ``unreachable``;`\n\nHere we know for sure that \"1234\" will parse successfully. So we put the `unreachable` value on the right hand side. `unreachable` generates a panic in [Debug](#Debug) and [ReleaseSafe](#ReleaseSafe) modes and undefined behavior in [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) modes. So, while we're debugging the application, if there *was* a surprise error here, the application would crash appropriately.\n\nYou may want to take a different action for every situation. For that, we combine the [if](#if) and [switch](#switch) expression:\n\n``` zig\nfn doAThing(str: []u8) void {\n    if (parseU64(str, 10)) |number| {\n        doSomethingWithNumber(number);\n    } else |err| switch (err) {\n        error.Overflow => {\n            // handle overflow...\n        },\n        // we promise that InvalidChar won't happen (or crash in debug mode if it does)\n        error.InvalidChar => unreachable,\n    }\n}\n```\n\nhandle_all_error_scenarios.zig\n\nFinally, you may want to handle only some errors. For that, you can capture the unhandled errors in the `else` case, which now contains a narrower error set:\n\n``` zig\nfn doAnotherThing(str: []u8) error{InvalidChar}!void {\n    if (parseU64(str, 10)) |number| {\n        doSomethingWithNumber(number);\n    } else |err| switch (err) {\n        error.Overflow => {\n            // handle overflow...\n        },\n        else => |leftover_err| return leftover_err,\n    }\n}\n```\n\nhandle_some_error_scenarios.zig\n\nYou must use the variable capture syntax. If you don't need the variable, you can capture with `_` and avoid the `switch`.\n\n``` zig\nfn doADifferentThing(str: []u8) void {\n    if (parseU64(str, 10)) |number| {\n        doSomethingWithNumber(number);\n    } else |_| {\n        // do as you'd like\n    }\n}\n```\n\nhandle_no_error_scenarios.zig\n\n#### [errdefer](#toc-errdefer)\n\nThe other component to error handling is defer statements. In addition to an unconditional [defer](#defer), Zig has `errdefer`, which evaluates the deferred expression on block exit path if and only if the function returned with an error from the block.\n\nExample:\n\n``` zig\nfn createFoo(param: i32) !Foo {\n    const foo = try tryToAllocateFoo();\n    // now we have allocated foo. we need to free it if the function fails.\n    // but we want to return it if the function succeeds.\n    errdefer deallocateFoo(foo);\n\n    const tmp_buf = allocateTmpBuffer() orelse return error.OutOfMemory;\n    // tmp_buf is truly a temporary resource, and we for sure want to clean it up\n    // before this block leaves scope\n    defer deallocateTmpBuffer(tmp_buf);\n\n    if (param > 1337) return error.InvalidParam;\n\n    // here the errdefer will not run since we're returning success from the function.\n    // but the defer will run!\n    return foo;\n}\n```\n\nerrdefer_example.zig\n\nThe neat thing about this is that you get robust error handling without the verbosity and cognitive overhead of trying to make sure every exit path is covered. The deallocation code is always directly following the allocation code.\n\n#### [Common errdefer Slip-Ups](#toc-Common-errdefer-Slip-Ups)\n\nIt should be noted that `errdefer` statements only last until the end of the block they are written in, and therefore are not run if an error is returned outside of that block:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct {\n    data: u32,\n};\n\nfn tryToAllocateFoo(allocator: Allocator) !*Foo {\n    return allocator.create(Foo);\n}\n\nfn deallocateFoo(allocator: Allocator, foo: *Foo) void {\n    allocator.destroy(foo);\n}\n\nfn getFooData() !u32 {\n    return 666;\n}\n\nfn createFoo(allocator: Allocator, param: i32) !*Foo {\n    const foo = getFoo: {\n        var foo = try tryToAllocateFoo(allocator);\n        errdefer deallocateFoo(allocator, foo); // Only lasts until the end of getFoo\n\n        // Calls deallocateFoo on error\n        foo.data = try getFooData();\n\n        break :getFoo foo;\n    };\n\n    // Outside of the scope of the errdefer, so\n    // deallocateFoo will not be called here\n    if (param > 1337) return error.InvalidParam;\n\n    return foo;\n}\n\ntest \"createFoo\" {\n    try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));\n}\n```\n\ntest_errdefer_slip_ups.zig\n\n    $ zig test test_errdefer_slip_ups.zig\n    1/1 test_errdefer_slip_ups.test.createFoo...OK\n    [gpa] (err): memory address 0x7f11f521a000 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:9:28: 0x103d3cf in tryToAllocateFoo (test)\n        return allocator.create(Foo);\n                               ^\n    /home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:22:39: 0x103d5e5 in createFoo (test)\n            var foo = try tryToAllocateFoo(allocator);\n                                          ^\n    /home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:39:62: 0x103d82d in test.createFoo (test)\n        try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));\n                                                                 ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104d2a0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x104340b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103f9f9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103f561 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    All 1 tests passed.\n    1 errors were logged.\n    1 tests leaked memory.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/58c079cb550addefaa354f72d736afd7/test\n\nShell\n\nTo ensure that `deallocateFoo` is properly called when returning an error, you must add an `errdefer` outside of the block:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct {\n    data: u32,\n};\n\nfn tryToAllocateFoo(allocator: Allocator) !*Foo {\n    return allocator.create(Foo);\n}\n\nfn deallocateFoo(allocator: Allocator, foo: *Foo) void {\n    allocator.destroy(foo);\n}\n\nfn getFooData() !u32 {\n    return 666;\n}\n\nfn createFoo(allocator: Allocator, param: i32) !*Foo {\n    const foo = getFoo: {\n        var foo = try tryToAllocateFoo(allocator);\n        errdefer deallocateFoo(allocator, foo);\n\n        foo.data = try getFooData();\n\n        break :getFoo foo;\n    };\n    // This lasts for the rest of the function\n    errdefer deallocateFoo(allocator, foo);\n\n    // Error is now properly handled by errdefer\n    if (param > 1337) return error.InvalidParam;\n\n    return foo;\n}\n\ntest \"createFoo\" {\n    try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));\n}\n```\n\ntest_errdefer_block.zig\n\n    $ zig test test_errdefer_block.zig\n    1/1 test_errdefer_block.test.createFoo...OK\n    All 1 tests passed.\n\nShell\n\nThe fact that errdefers only last for the block they are declared in is especially important when using loops:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct { data: *u32 };\n\nfn getData() !u32 {\n    return 666;\n}\n\nfn genFoos(allocator: Allocator, num: usize) ![]Foo {\n    const foos = try allocator.alloc(Foo, num);\n    errdefer allocator.free(foos);\n\n    for (foos, 0..) |*foo, i| {\n        foo.data = try allocator.create(u32);\n        // This errdefer does not last between iterations\n        errdefer allocator.destroy(foo.data);\n\n        // The data for the first 3 foos will be leaked\n        if (i >= 3) return error.TooManyFoos;\n\n        foo.data.* = try getData();\n    }\n\n    return foos;\n}\n\ntest \"genFoos\" {\n    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n}\n```\n\ntest_errdefer_loop_leak.zig\n\n    $ zig test test_errdefer_loop_leak.zig\n    1/1 test_errdefer_loop_leak.test.genFoos...OK\n    [gpa] (err): memory address 0x7f57c7578000 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)\n            foo.data = try allocator.create(u32);\n                                           ^\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)\n        try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n                                                              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    [gpa] (err): memory address 0x7f57c7578004 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)\n            foo.data = try allocator.create(u32);\n                                           ^\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)\n        try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n                                                              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    [gpa] (err): memory address 0x7f57c7578008 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)\n            foo.data = try allocator.create(u32);\n                                           ^\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)\n        try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n                                                              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    All 1 tests passed.\n    3 errors were logged.\n    1 tests leaked memory.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/29fcda275b7c426418534b679850fa2e/test\n\nShell\n\nSpecial care must be taken with code that allocates in a loop to make sure that no memory is leaked when returning an error:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct { data: *u32 };\n\nfn getData() !u32 {\n    return 666;\n}\n\nfn genFoos(allocator: Allocator, num: usize) ![]Foo {\n    const foos = try allocator.alloc(Foo, num);\n    errdefer allocator.free(foos);\n\n    // Used to track how many foos have been initialized\n    // (including their data being allocated)\n    var num_allocated: usize = 0;\n    errdefer for (foos[0..num_allocated]) |foo| {\n        allocator.destroy(foo.data);\n    };\n    for (foos, 0..) |*foo, i| {\n        foo.data = try allocator.create(u32);\n        num_allocated += 1;\n\n        if (i >= 3) return error.TooManyFoos;\n\n        foo.data.* = try getData();\n    }\n\n    return foos;\n}\n\ntest \"genFoos\" {\n    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n}\n```\n\ntest_errdefer_loop.zig\n\n    $ zig test test_errdefer_loop.zig\n    1/1 test_errdefer_loop.test.genFoos...OK\n    All 1 tests passed.\n\nShell\n\nA couple of other tidbits about error handling:\n\n- These primitives give enough expressiveness that it's completely practical to have failing to check for an error be a compile error. If you really want to ignore the error, you can add `catch`` ``unreachable` and get the added benefit of crashing in Debug and ReleaseSafe modes if your assumption was wrong.\n- Since Zig understands error types, it can pre-weight branches in favor of errors not occurring. Just a small optimization benefit that is not available in other languages.\n\nSee also:\n\n- [defer](#defer)\n- [if](#if)\n- [switch](#switch)\n\nAn error union is created with the `!` binary operator. You can use compile-time reflection to access the child type of an error union:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"error union\" {\n    var foo: anyerror!i32 = undefined;\n\n    // Coerce from child type of an error union:\n    foo = 1234;\n\n    // Coerce from an error set:\n    foo = error.SomeError;\n\n    // Use compile-time reflection to access the payload type of an error union:\n    try comptime expect(@typeInfo(@TypeOf(foo)).ErrorUnion.payload == i32);\n\n    // Use compile-time reflection to access the error set type of an error union:\n    try comptime expect(@typeInfo(@TypeOf(foo)).ErrorUnion.error_set == anyerror);\n}\n```\n\ntest_error_union.zig\n\n    $ zig test test_error_union.zig\n    1/1 test_error_union.test.error union...OK\n    All 1 tests passed.\n\nShell\n\n#### [Merging Error Sets](#toc-Merging-Error-Sets)\n\nUse the `||` operator to merge two error sets together. The resulting error set contains the errors of both error sets. Doc comments from the left-hand side override doc comments from the right-hand side. In this example, the doc comments for `C.PathNotFound` is `A doc comment`.\n\nThis is especially useful for functions which return different error sets depending on [comptime](#comptime) branches. For example, the Zig standard library uses `LinuxFileOpenError || WindowsFileOpenError` for the error set of opening files.\n\n``` zig\nconst A = error{\n    NotDir,\n\n    /// A doc comment\n    PathNotFound,\n};\nconst B = error{\n    OutOfMemory,\n\n    /// B doc comment\n    PathNotFound,\n};\n\nconst C = A || B;\n\nfn foo() C!void {\n    return error.NotDir;\n}\n\ntest \"merge error sets\" {\n    if (foo()) {\n        @panic(\"unexpected\");\n    } else |err| switch (err) {\n        error.OutOfMemory => @panic(\"unexpected\"),\n        error.PathNotFound => @panic(\"unexpected\"),\n        error.NotDir => {},\n    }\n}\n```\n\ntest_merging_error_sets.zig\n\n    $ zig test test_merging_error_sets.zig\n    1/1 test_merging_error_sets.test.merge error sets...OK\n    All 1 tests passed.\n\nShell\n\n#### [Inferred Error Sets](#toc-Inferred-Error-Sets)\n\nBecause many functions in Zig return a possible error, Zig supports inferring the error set. To infer the error set for a function, prepend the `!` operator to the function’s return type, like `!T`:\n\n``` zig\n// With an inferred error set\npub fn add_inferred(comptime T: type, a: T, b: T) !T {\n    const ov = @addWithOverflow(a, b);\n    if (ov[1] != 0) return error.Overflow;\n    return ov[0];\n}\n\n// With an explicit error set\npub fn add_explicit(comptime T: type, a: T, b: T) Error!T {\n    const ov = @addWithOverflow(a, b);\n    if (ov[1] != 0) return error.Overflow;\n    return ov[0];\n}\n\nconst Error = error{\n    Overflow,\n};\n\nconst std = @import(\"std\");\n\ntest \"inferred error set\" {\n    if (add_inferred(u8, 255, 1)) |_| unreachable else |err| switch (err) {\n        error.Overflow => {}, // ok\n    }\n}\n```\n\ntest_inferred_error_sets.zig\n\n    $ zig test test_inferred_error_sets.zig\n    1/1 test_inferred_error_sets.test.inferred error set...OK\n    All 1 tests passed.\n\nShell\n\nWhen a function has an inferred error set, that function becomes generic and thus it becomes trickier to do certain things with it, such as obtain a function pointer, or have an error set that is consistent across different build targets. Additionally, inferred error sets are incompatible with recursion.\n\nIn these situations, it is recommended to use an explicit error set. You can generally start with an empty error set and let compile errors guide you toward completing the set.\n\nThese limitations may be overcome in a future version of Zig.\n\n### Error Return Traces\n\nError Return Traces show all the points in the code that an error was returned to the calling function. This makes it practical to use [try](#try) everywhere and then still be able to know what happened if an error ends up bubbling all the way out of your application.\n\n``` zig\npub fn main() !void {\n    try foo(12);\n}\n\nfn foo(x: i32) !void {\n    if (x >= 5) {\n        try bar();\n    } else {\n        try bang2();\n    }\n}\n\nfn bar() !void {\n    if (baz()) {\n        try quux();\n    } else |err| switch (err) {\n        error.FileNotFound => try hello(),\n    }\n}\n\nfn baz() !void {\n    try bang1();\n}\n\nfn quux() !void {\n    try bang2();\n}\n\nfn hello() !void {\n    try bang2();\n}\n\nfn bang1() !void {\n    return error.FileNotFound;\n}\n\nfn bang2() !void {\n    return error.PermissionDenied;\n}\n```\n\nerror_return_trace.zig\n\n    $ zig build-exe error_return_trace.zig\n    $ ./error_return_trace\n    error: PermissionDenied\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:34:5: 0x1034e08 in bang1 (error_return_trace)\n        return error.FileNotFound;\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:22:5: 0x1034f13 in baz (error_return_trace)\n        try bang1();\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:38:5: 0x1034f38 in bang2 (error_return_trace)\n        return error.PermissionDenied;\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:30:5: 0x1034fa3 in hello (error_return_trace)\n        try bang2();\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:17:31: 0x103505a in bar (error_return_trace)\n            error.FileNotFound => try hello(),\n                                  ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:7:9: 0x1035140 in foo (error_return_trace)\n            try bar();\n            ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:2:5: 0x1035198 in main (error_return_trace)\n        try foo(12);\n        ^\n\nShell\n\nLook closely at this example. This is no stack trace.\n\nYou can see that the final error bubbled up was `PermissionDenied`, but the original error that started this whole thing was `FileNotFound`. In the `bar` function, the code handles the original error code, and then returns another one, from the switch statement. Error Return Traces make this clear, whereas a stack trace would look like this:\n\n``` zig\npub fn main() void {\n    foo(12);\n}\n\nfn foo(x: i32) void {\n    if (x >= 5) {\n        bar();\n    } else {\n        bang2();\n    }\n}\n\nfn bar() void {\n    if (baz()) {\n        quux();\n    } else {\n        hello();\n    }\n}\n\nfn baz() bool {\n    return bang1();\n}\n\nfn quux() void {\n    bang2();\n}\n\nfn hello() void {\n    bang2();\n}\n\nfn bang1() bool {\n    return false;\n}\n\nfn bang2() void {\n    @panic(\"PermissionDenied\");\n}\n```\n\nstack_trace.zig\n\n    $ zig build-exe stack_trace.zig\n    $ ./stack_trace\n    thread 3570764 panic: PermissionDenied\n    /home/andy/src/zig/doc/langref/stack_trace.zig:38:5: 0x1039320 in bang2 (stack_trace)\n        @panic(\"PermissionDenied\");\n        ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:30:10: 0x1068bd8 in hello (stack_trace)\n        bang2();\n             ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:17:14: 0x10392fc in bar (stack_trace)\n            hello();\n                 ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:7:12: 0x103721c in foo (stack_trace)\n            bar();\n               ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:2:8: 0x103519d in main (stack_trace)\n        foo(12);\n           ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (stack_trace)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (stack_trace)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nHere, the stack trace does not explain how the control flow in `bar` got to the `hello()` call. One would have to open a debugger or further instrument the application in order to find out. The error return trace, on the other hand, shows exactly how the error bubbled up.\n\nThis debugging feature makes it easier to iterate quickly on code that robustly handles all error conditions. This means that Zig developers will naturally find themselves writing correct, robust code in order to increase their development pace.\n\nError Return Traces are enabled by default in [Debug](#Debug) and [ReleaseSafe](#ReleaseSafe) builds and disabled by default in [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) builds.\n\nThere are a few ways to activate this error return tracing feature:\n\n- Return an error from main\n- An error makes its way to `catch`` ``unreachable` and you have not overridden the default panic handler\n- Use [errorReturnTrace](#errorReturnTrace) to access the current return trace. You can use `std.debug.dumpStackTrace` to print it. This function returns comptime-known [null](#null) when building without error return tracing support.\n\n#### [Implementation Details](#toc-Implementation-Details)\n\nTo analyze performance cost, there are two cases:\n\n- when no errors are returned\n- when returning errors\n\nFor the case when no errors are returned, the cost is a single memory write operation, only in the first non-failable function in the call graph that calls a failable function, i.e. when a function returning `void` calls a function returning `error`. This is to initialize this struct in the stack memory:\n\n``` zig\npub const StackTrace = struct {\n    index: usize,\n    instruction_addresses: [N]usize,\n};\n```\n\nstack_trace_struct.zig\n\nHere, N is the maximum function call depth as determined by call graph analysis. Recursion is ignored and counts for 2.\n\nA pointer to `StackTrace` is passed as a secret parameter to every function that can return an error, but it's always the first parameter, so it can likely sit in a register and stay there.\n\nThat's it for the path when no errors occur. It's practically free in terms of performance.\n\nWhen generating the code for a function that returns an error, just before the `return` statement (only for the `return` statements that return errors), Zig generates a call to this function:\n\n``` zig\n// marked as \"no-inline\" in LLVM IR\nfn __zig_return_error(stack_trace: *StackTrace) void {\n    stack_trace.instruction_addresses[stack_trace.index] = @returnAddress();\n    stack_trace.index = (stack_trace.index + 1) % N;\n}\n```\n\nzig_return_error_fn.zig\n\nThe cost is 2 math operations plus some memory reads and writes. The memory accessed is constrained and should remain cached for the duration of the error return bubbling.\n\nAs for code size cost, 1 function call before a return statement is no big deal. Even so, I have [a plan](https://github.com/ziglang/zig/issues/690) to make the call to `__zig_return_error` a tail call, which brings the code size cost down to actually zero. What is a return statement in code without error return tracing can become a jump instruction in code with error return tracing.\n\n## Optionals\n\nOne area that Zig provides safety without compromising efficiency or readability is with the optional type.\n\nThe question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this:\n\n``` zig\n// normal integer\nconst normal_int: i32 = 1234;\n\n// optional integer\nconst optional_int: ?i32 = 5678;\n```\n\noptional_integer.zig\n\nNow the variable `optional_int` could be an `i32`, or `null`.\n\nInstead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being [the worst mistake of computer science](https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/).\n\nZig does not have them.\n\nInstead, you can use an optional pointer. This secretly compiles down to a normal pointer, since we know we can use 0 as the null value for the optional type. But the compiler can check your work and make sure you don't assign null to something that can't be null.\n\nTypically the downside of not having null is that it makes the code more verbose to write. But, let's compare some equivalent C code and Zig code.\n\nTask: call malloc, if the result is null, return null.\n\nC code\n\n``` zig\n// malloc prototype included for reference\nvoid *malloc(size_t size);\n\nstruct Foo *do_a_thing(void) {\n    char *ptr = malloc(1234);\n    if (!ptr) return NULL;\n    // ...\n}\n```\n\ncall_malloc_in_c.c\n\nZig code\n\n``` zig\n// malloc prototype included for reference\nextern fn malloc(size: usize) ?[*]u8;\n\nfn doAThing() ?*Foo {\n    const ptr = malloc(1234) orelse return null;\n    _ = ptr; // ...\n}\n```\n\ncall_malloc_from_zig.zig\n\nHere, Zig is at least as convenient, if not more, than C. And, the type of \"ptr\" is `[*]``u8` *not* `?[*]``u8`. The `orelse` keyword unwrapped the optional type and therefore `ptr` is guaranteed to be non-null everywhere it is used in the function.\n\nThe other form of checking against NULL you might see looks like this:\n\n``` zig\nvoid do_a_thing(struct Foo *foo) {\n    // do some stuff\n\n    if (foo) {\n        do_something_with_foo(foo);\n    }\n\n    // do some stuff\n}\n```\n\nchecking_null_in_c.c\n\nIn Zig you can accomplish the same thing:\n\n``` zig\nconst Foo = struct {};\nfn doSomethingWithFoo(foo: *Foo) void {\n    _ = foo;\n}\n\nfn doAThing(optional_foo: ?*Foo) void {\n    // do some stuff\n\n    if (optional_foo) |foo| {\n        doSomethingWithFoo(foo);\n    }\n\n    // do some stuff\n}\n```\n\nchecking_null_in_zig.zig\n\nOnce again, the notable thing here is that inside the if block, `foo` is no longer an optional pointer, it is a pointer, which cannot be null.\n\nOne benefit to this is that functions which take pointers as arguments can be annotated with the \"nonnull\" attribute - `__attribute__((nonnull))` in [GCC](https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html). The optimizer can sometimes make better decisions knowing that pointer arguments cannot be null.\n\n### Optional Type\n\nAn optional is created by putting `?` in front of a type. You can use compile-time reflection to access the child type of an optional:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"optional type\" {\n    // Declare an optional and coerce from null:\n    var foo: ?i32 = null;\n\n    // Coerce from child type of an optional\n    foo = 1234;\n\n    // Use compile-time reflection to access the child type of the optional:\n    try comptime expect(@typeInfo(@TypeOf(foo)).Optional.child == i32);\n}\n```\n\ntest_optional_type.zig\n\n    $ zig test test_optional_type.zig\n    1/1 test_optional_type.test.optional type...OK\n    All 1 tests passed.\n\nShell\n\n### null\n\nJust like [undefined](#undefined), `null` has its own type, and the only way to use it is to cast it to a different type:\n\n``` zig\nconst optional_value: ?i32 = null;\n```\n\nnull.zig\n\n### Optional Pointers\n\nAn optional pointer is guaranteed to be the same size as a pointer. The `null` of the optional is guaranteed to be address 0.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"optional pointers\" {\n    // Pointers cannot be null. If you want a null pointer, use the optional\n    // prefix `?` to make the pointer type optional.\n    var ptr: ?*i32 = null;\n\n    var x: i32 = 1;\n    ptr = &x;\n\n    try expect(ptr.?.* == 1);\n\n    // Optional pointers are the same size as normal pointers, because pointer\n    // value 0 is used as the null value.\n    try expect(@sizeOf(?*i32) == @sizeOf(*i32));\n}\n```\n\ntest_optional_pointer.zig\n\n    $ zig test test_optional_pointer.zig\n    1/1 test_optional_pointer.test.optional pointers...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [while with Optionals](#while-with-Optionals)\n- [if with Optionals](#if-with-Optionals)\n\n## Casting\n\nA **type cast** converts a value of one type to another. Zig has [Type Coercion](#Type-Coercion) for conversions that are known to be completely safe and unambiguous, and [Explicit Casts](#Explicit-Casts) for conversions that one would not want to happen on accident. There is also a third kind of type conversion called [Peer Type Resolution](#Peer-Type-Resolution) for the case when a result type must be decided given multiple operand types.\n\n### Type Coercion\n\nType coercion occurs when one type is expected, but different type is provided:\n\n``` zig\ntest \"type coercion - variable declaration\" {\n    const a: u8 = 1;\n    const b: u16 = a;\n    _ = b;\n}\n\ntest \"type coercion - function call\" {\n    const a: u8 = 1;\n    foo(a);\n}\n\nfn foo(b: u16) void {\n    _ = b;\n}\n\ntest \"type coercion - @as builtin\" {\n    const a: u8 = 1;\n    const b = @as(u16, a);\n    _ = b;\n}\n```\n\ntest_type_coercion.zig\n\n    $ zig test test_type_coercion.zig\n    1/3 test_type_coercion.test.type coercion - variable declaration...OK\n    2/3 test_type_coercion.test.type coercion - function call...OK\n    3/3 test_type_coercion.test.type coercion - @as builtin...OK\n    All 3 tests passed.\n\nShell\n\nType coercions are only allowed when it is completely unambiguous how to get from one type to another, and the transformation is guaranteed to be safe. There is one exception, which is [C Pointers](#C-Pointers).\n\n#### [Type Coercion: Stricter Qualification](#toc-Type-Coercion-Stricter-Qualification)\n\nValues which have the same representation at runtime can be cast to increase the strictness of the qualifiers, no matter how nested the qualifiers are:\n\n- `const` - non-const to const is allowed\n- `volatile` - non-volatile to volatile is allowed\n- `align` - bigger to smaller alignment is allowed\n- [error sets](#Error-Set-Type) to supersets is allowed\n\nThese casts are no-ops at runtime since the value representation does not change.\n\n``` zig\ntest \"type coercion - const qualification\" {\n    var a: i32 = 1;\n    const b: *i32 = &a;\n    foo(b);\n}\n\nfn foo(_: *const i32) void {}\n```\n\ntest_no_op_casts.zig\n\n    $ zig test test_no_op_casts.zig\n    1/1 test_no_op_casts.test.type coercion - const qualification...OK\n    All 1 tests passed.\n\nShell\n\nIn addition, pointers coerce to const optional pointers:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\n\ntest \"cast *[1][*]const u8 to [*]const ?[*]const u8\" {\n    const window_name = [1][*]const u8{\"window name\"};\n    const x: [*]const ?[*]const u8 = &window_name;\n    try expect(mem.eql(u8, std.mem.sliceTo(@as([*:0]const u8, @ptrCast(x[0].?)), 0), \"window name\"));\n}\n```\n\ntest_pointer_coerce_const_optional.zig\n\n    $ zig test test_pointer_coerce_const_optional.zig\n    1/1 test_pointer_coerce_const_optional.test.cast *[1][*]const u8 to [*]const ?[*]const u8...OK\n    All 1 tests passed.\n\nShell\n\n#### [Type Coercion: Integer and Float Widening](#toc-Type-Coercion-Integer-and-Float-Widening)\n\n[Integers](#Integers) coerce to integer types which can represent every value of the old type, and likewise [Floats](#Floats) coerce to float types which can represent every value of the old type.\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\n\ntest \"integer widening\" {\n    const a: u8 = 250;\n    const b: u16 = a;\n    const c: u32 = b;\n    const d: u64 = c;\n    const e: u64 = d;\n    const f: u128 = e;\n    try expect(f == a);\n}\n\ntest \"implicit unsigned integer to signed integer\" {\n    const a: u8 = 250;\n    const b: i16 = a;\n    try expect(b == 250);\n}\n\ntest \"float widening\" {\n    const a: f16 = 12.34;\n    const b: f32 = a;\n    const c: f64 = b;\n    const d: f128 = c;\n    try expect(d == a);\n}\n```\n\ntest_integer_widening.zig\n\n    $ zig test test_integer_widening.zig\n    1/3 test_integer_widening.test.integer widening...OK\n    2/3 test_integer_widening.test.implicit unsigned integer to signed integer...OK\n    3/3 test_integer_widening.test.float widening...OK\n    All 3 tests passed.\n\nShell\n\n#### [Type Coercion: Float to Int](#toc-Type-Coercion-Float-to-Int)\n\nA compiler error is appropriate because this ambiguous expression leaves the compiler two choices about the coercion.\n\n- Cast `54.0` to `comptime_int` resulting in `@as``(``comptime_int``, ``10``)`, which is casted to `@as``(``f32``, ``10``)`\n- Cast `5` to `comptime_float` resulting in `@as``(``comptime_float``, ``10.8``)`, which is casted to `@as``(``f32``, ``10.8``)`\n\n``` zig\n// Compile time coercion of float to int\ntest \"implicit cast to comptime_int\" {\n    const f: f32 = 54.0 / 5;\n    _ = f;\n}\n```\n\ntest_ambiguous_coercion.zig\n\n    $ zig test test_ambiguous_coercion.zig\n    doc/langref/test_ambiguous_coercion.zig:3:25: error: ambiguous coercion of division operands 'comptime_float' and 'comptime_int'; non-zero remainder '4'\n        const f: f32 = 54.0 / 5;\n                       ~~~~~^~~\n\nShell\n\n#### [Type Coercion: Slices, Arrays and Pointers](#toc-Type-Coercion-Slices-Arrays-and-Pointers)\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\n// You can assign constant pointers to arrays to a slice with\n// const modifier on the element type. Useful in particular for\n// String literals.\ntest \"*const [N]T to []const T\" {\n    const x1: []const u8 = \"hello\";\n    const x2: []const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };\n    try expect(std.mem.eql(u8, x1, x2));\n\n    const y: []const f32 = &[2]f32{ 1.2, 3.4 };\n    try expect(y[0] == 1.2);\n}\n\n// Likewise, it works when the destination type is an error union.\ntest \"*const [N]T to E![]const T\" {\n    const x1: anyerror![]const u8 = \"hello\";\n    const x2: anyerror![]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };\n    try expect(std.mem.eql(u8, try x1, try x2));\n\n    const y: anyerror![]const f32 = &[2]f32{ 1.2, 3.4 };\n    try expect((try y)[0] == 1.2);\n}\n\n// Likewise, it works when the destination type is an optional.\ntest \"*const [N]T to ?[]const T\" {\n    const x1: ?[]const u8 = \"hello\";\n    const x2: ?[]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };\n    try expect(std.mem.eql(u8, x1.?, x2.?));\n\n    const y: ?[]const f32 = &[2]f32{ 1.2, 3.4 };\n    try expect(y.?[0] == 1.2);\n}\n\n// In this cast, the array length becomes the slice length.\ntest \"*[N]T to []T\" {\n    var buf: [5]u8 = \"hello\".*;\n    const x: []u8 = &buf;\n    try expect(std.mem.eql(u8, x, \"hello\"));\n\n    const buf2 = [2]f32{ 1.2, 3.4 };\n    const x2: []const f32 = &buf2;\n    try expect(std.mem.eql(f32, x2, &[2]f32{ 1.2, 3.4 }));\n}\n\n// Single-item pointers to arrays can be coerced to many-item pointers.\ntest \"*[N]T to [*]T\" {\n    var buf: [5]u8 = \"hello\".*;\n    const x: [*]u8 = &buf;\n    try expect(x[4] == 'o');\n    // x[5] would be an uncaught out of bounds pointer dereference!\n}\n\n// Likewise, it works when the destination type is an optional.\ntest \"*[N]T to ?[*]T\" {\n    var buf: [5]u8 = \"hello\".*;\n    const x: ?[*]u8 = &buf;\n    try expect(x.?[4] == 'o');\n}\n\n// Single-item pointers can be cast to len-1 single-item arrays.\ntest \"*T to *[1]T\" {\n    var x: i32 = 1234;\n    const y: *[1]i32 = &x;\n    const z: [*]i32 = y;\n    try expect(z[0] == 1234);\n}\n```\n\ntest_coerce_slices_arrays_and_pointers.zig\n\n    $ zig test test_coerce_slices_arrays_and_pointers.zig\n    1/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to []const T...OK\n    2/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to E![]const T...OK\n    3/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to ?[]const T...OK\n    4/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to []T...OK\n    5/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to [*]T...OK\n    6/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to ?[*]T...OK\n    7/7 test_coerce_slices_arrays_and_pointers.test.*T to *[1]T...OK\n    All 7 tests passed.\n\nShell\n\nSee also:\n\n- [C Pointers](#C-Pointers)\n\n#### [Type Coercion: Optionals](#toc-Type-Coercion-Optionals)\n\nThe payload type of [Optionals](#Optionals), as well as [null](#null), coerce to the optional type.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coerce to optionals\" {\n    const x: ?i32 = 1234;\n    const y: ?i32 = null;\n\n    try expect(x.? == 1234);\n    try expect(y == null);\n}\n```\n\ntest_coerce_optionals.zig\n\n    $ zig test test_coerce_optionals.zig\n    1/1 test_coerce_optionals.test.coerce to optionals...OK\n    All 1 tests passed.\n\nShell\n\nOptionals work nested inside the [Error Union Type](#Error-Union-Type), too:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coerce to optionals wrapped in error union\" {\n    const x: anyerror!?i32 = 1234;\n    const y: anyerror!?i32 = null;\n\n    try expect((try x).? == 1234);\n    try expect((try y) == null);\n}\n```\n\ntest_coerce_optional_wrapped_error_union.zig\n\n    $ zig test test_coerce_optional_wrapped_error_union.zig\n    1/1 test_coerce_optional_wrapped_error_union.test.coerce to optionals wrapped in error union...OK\n    All 1 tests passed.\n\nShell\n\n#### [Type Coercion: Error Unions](#toc-Type-Coercion-Error-Unions)\n\nThe payload type of an [Error Union Type](#Error-Union-Type) as well as the [Error Set Type](#Error-Set-Type) coerce to the error union type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coercion to error unions\" {\n    const x: anyerror!i32 = 1234;\n    const y: anyerror!i32 = error.Failure;\n\n    try expect((try x) == 1234);\n    try std.testing.expectError(error.Failure, y);\n}\n```\n\ntest_coerce_to_error_union.zig\n\n    $ zig test test_coerce_to_error_union.zig\n    1/1 test_coerce_to_error_union.test.coercion to error unions...OK\n    All 1 tests passed.\n\nShell\n\n#### [Type Coercion: Compile-Time Known Numbers](#toc-Type-Coercion-Compile-Time-Known-Numbers)\n\nWhen a number is [comptime](#comptime)-known to be representable in the destination type, it may be coerced:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coercing large integer type to smaller one when value is comptime-known to fit\" {\n    const x: u64 = 255;\n    const y: u8 = x;\n    try expect(y == 255);\n}\n```\n\ntest_coerce_large_to_small.zig\n\n    $ zig test test_coerce_large_to_small.zig\n    1/1 test_coerce_large_to_small.test.coercing large integer type to smaller one when value is comptime-known to fit...OK\n    All 1 tests passed.\n\nShell\n\n#### [Type Coercion: Unions and Enums](#toc-Type-Coercion-Unions-and-Enums)\n\nTagged unions can be coerced to enums, and enums can be coerced to tagged unions when they are [comptime](#comptime)-known to be a field of the union that has only one possible value, such as [void](#void):\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst E = enum {\n    one,\n    two,\n    three,\n};\n\nconst U = union(E) {\n    one: i32,\n    two: f32,\n    three,\n};\n\nconst U2 = union(enum) {\n    a: void,\n    b: f32,\n\n    fn tag(self: U2) usize {\n        switch (self) {\n            .a => return 1,\n            .b => return 2,\n        }\n    }\n};\n\ntest \"coercion between unions and enums\" {\n    const u = U{ .two = 12.34 };\n    const e: E = u; // coerce union to enum\n    try expect(e == E.two);\n\n    const three = E.three;\n    const u_2: U = three; // coerce enum to union\n    try expect(u_2 == E.three);\n\n    const u_3: U = .three; // coerce enum literal to union\n    try expect(u_3 == E.three);\n\n    const u_4: U2 = .a; // coerce enum literal to union with inferred enum tag type.\n    try expect(u_4.tag() == 1);\n\n    // The following example is invalid.\n    // error: coercion from enum '@TypeOf(.enum_literal)' to union 'test_coerce_unions_enum.U2' must initialize 'f32' field 'b'\n    //var u_5: U2 = .b;\n    //try expect(u_5.tag() == 2);\n}\n```\n\ntest_coerce_unions_enums.zig\n\n    $ zig test test_coerce_unions_enums.zig\n    1/1 test_coerce_unions_enums.test.coercion between unions and enums...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [union](#union)\n- [enum](#enum)\n\n#### [Type Coercion: undefined](#toc-Type-Coercion-undefined)\n\n[undefined](#undefined) can be coerced to any type.\n\n#### [Type Coercion: Tuples to Arrays](#toc-Type-Coercion-Tuples-to-Arrays)\n\n[Tuples](#Tuples) can be coerced to arrays, if all of the fields have the same type.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Tuple = struct { u8, u8 };\ntest \"coercion from homogenous tuple to array\" {\n    const tuple: Tuple = .{ 5, 6 };\n    const array: [2]u8 = tuple;\n    _ = array;\n}\n```\n\ntest_coerce_tuples_arrays.zig\n\n    $ zig test test_coerce_tuples_arrays.zig\n    1/1 test_coerce_tuples_arrays.test.coercion from homogenous tuple to array...OK\n    All 1 tests passed.\n\nShell\n\n### Explicit Casts\n\nExplicit casts are performed via [Builtin Functions](#Builtin-Functions). Some explicit casts are safe; some are not. Some explicit casts perform language-level assertions; some do not. Some explicit casts are no-ops at runtime; some are not.\n\n- [@bitCast](#bitCast) - change type but maintain bit representation\n- [@alignCast](#alignCast) - make a pointer have more alignment\n- [@enumFromInt](#enumFromInt) - obtain an enum value based on its integer tag value\n- [@errorFromInt](#errorFromInt) - obtain an error code based on its integer value\n- [@errorCast](#errorCast) - convert to a smaller error set\n- [@floatCast](#floatCast) - convert a larger float to a smaller float\n- [@floatFromInt](#floatFromInt) - convert an integer to a float value\n- [@intCast](#intCast) - convert between integer types\n- [@intFromBool](#intFromBool) - convert true to 1 and false to 0\n- [@intFromEnum](#intFromEnum) - obtain the integer tag value of an enum or tagged union\n- [@intFromError](#intFromError) - obtain the integer value of an error code\n- [@intFromFloat](#intFromFloat) - obtain the integer part of a float value\n- [@intFromPtr](#intFromPtr) - obtain the address of a pointer\n- [@ptrFromInt](#ptrFromInt) - convert an address to a pointer\n- [@ptrCast](#ptrCast) - convert between pointer types\n- [@truncate](#truncate) - convert between integer types, chopping off bits\n\n### Peer Type Resolution\n\nPeer Type Resolution occurs in these places:\n\n- [switch](#switch) expressions\n- [if](#if) expressions\n- [while](#while) expressions\n- [for](#for) expressions\n- Multiple break statements in a block\n- Some [binary operations](#Table-of-Operators)\n\nThis kind of type resolution chooses a type that all peer types can coerce into. Here are some examples:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\n\ntest \"peer resolve int widening\" {\n    const a: i8 = 12;\n    const b: i16 = 34;\n    const c = a + b;\n    try expect(c == 46);\n    try expect(@TypeOf(c) == i16);\n}\n\ntest \"peer resolve arrays of different size to const slice\" {\n    try expect(mem.eql(u8, boolToStr(true), \"true\"));\n    try expect(mem.eql(u8, boolToStr(false), \"false\"));\n    try comptime expect(mem.eql(u8, boolToStr(true), \"true\"));\n    try comptime expect(mem.eql(u8, boolToStr(false), \"false\"));\n}\nfn boolToStr(b: bool) []const u8 {\n    return if (b) \"true\" else \"false\";\n}\n\ntest \"peer resolve array and const slice\" {\n    try testPeerResolveArrayConstSlice(true);\n    try comptime testPeerResolveArrayConstSlice(true);\n}\nfn testPeerResolveArrayConstSlice(b: bool) !void {\n    const value1 = if (b) \"aoeu\" else @as([]const u8, \"zz\");\n    const value2 = if (b) @as([]const u8, \"zz\") else \"aoeu\";\n    try expect(mem.eql(u8, value1, \"aoeu\"));\n    try expect(mem.eql(u8, value2, \"zz\"));\n}\n\ntest \"peer type resolution: ?T and T\" {\n    try expect(peerTypeTAndOptionalT(true, false).? == 0);\n    try expect(peerTypeTAndOptionalT(false, false).? == 3);\n    comptime {\n        try expect(peerTypeTAndOptionalT(true, false).? == 0);\n        try expect(peerTypeTAndOptionalT(false, false).? == 3);\n    }\n}\nfn peerTypeTAndOptionalT(c: bool, b: bool) ?usize {\n    if (c) {\n        return if (b) null else @as(usize, 0);\n    }\n\n    return @as(usize, 3);\n}\n\ntest \"peer type resolution: *[0]u8 and []const u8\" {\n    try expect(peerTypeEmptyArrayAndSlice(true, \"hi\").len == 0);\n    try expect(peerTypeEmptyArrayAndSlice(false, \"hi\").len == 1);\n    comptime {\n        try expect(peerTypeEmptyArrayAndSlice(true, \"hi\").len == 0);\n        try expect(peerTypeEmptyArrayAndSlice(false, \"hi\").len == 1);\n    }\n}\nfn peerTypeEmptyArrayAndSlice(a: bool, slice: []const u8) []const u8 {\n    if (a) {\n        return &[_]u8{};\n    }\n\n    return slice[0..1];\n}\ntest \"peer type resolution: *[0]u8, []const u8, and anyerror![]u8\" {\n    {\n        var data = \"hi\".*;\n        const slice = data[0..];\n        try expect((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);\n        try expect((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);\n    }\n    comptime {\n        var data = \"hi\".*;\n        const slice = data[0..];\n        try expect((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);\n        try expect((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);\n    }\n}\nfn peerTypeEmptyArrayAndSliceAndError(a: bool, slice: []u8) anyerror![]u8 {\n    if (a) {\n        return &[_]u8{};\n    }\n\n    return slice[0..1];\n}\n\ntest \"peer type resolution: *const T and ?*T\" {\n    const a: *const usize = @ptrFromInt(0x123456780);\n    const b: ?*usize = @ptrFromInt(0x123456780);\n    try expect(a == b);\n    try expect(b == a);\n}\n\ntest \"peer type resolution: error union switch\" {\n    // The non-error and error cases are only peers if the error case is just a switch expression;\n    // the pattern `if (x) {...} else |err| blk: { switch (err) {...} }` does not consider the\n    // non-error and error case to be peers.\n    var a: error{ A, B, C }!u32 = 0;\n    _ = &a;\n    const b = if (a) |x|\n        x + 3\n    else |err| switch (err) {\n        error.A => 0,\n        error.B => 1,\n        error.C => null,\n    };\n    try expect(@TypeOf(b) == ?u32);\n\n    // The non-error and error cases are only peers if the error case is just a switch expression;\n    // the pattern `x catch |err| blk: { switch (err) {...} }` does not consider the unwrapped `x`\n    // and error case to be peers.\n    const c = a catch |err| switch (err) {\n        error.A => 0,\n        error.B => 1,\n        error.C => null,\n    };\n    try expect(@TypeOf(c) == ?u32);\n}\n```\n\ntest_peer_type_resolution.zig\n\n    $ zig test test_peer_type_resolution.zig\n    1/8 test_peer_type_resolution.test.peer resolve int widening...OK\n    2/8 test_peer_type_resolution.test.peer resolve arrays of different size to const slice...OK\n    3/8 test_peer_type_resolution.test.peer resolve array and const slice...OK\n    4/8 test_peer_type_resolution.test.peer type resolution: ?T and T...OK\n    5/8 test_peer_type_resolution.test.peer type resolution: *[0]u8 and []const u8...OK\n    6/8 test_peer_type_resolution.test.peer type resolution: *[0]u8, []const u8, and anyerror![]u8...OK\n    7/8 test_peer_type_resolution.test.peer type resolution: *const T and ?*T...OK\n    8/8 test_peer_type_resolution.test.peer type resolution: error union switch...OK\n    All 8 tests passed.\n\nShell\n\n## Zero Bit Types\n\nFor some types, [@sizeOf](#sizeOf) is 0:\n\n- [void](#void)\n- The [Integers](#Integers) `u0` and `i0`.\n- [Arrays](#Arrays) and [Vectors](#Vectors) with len 0, or with an element type that is a zero bit type.\n- An [enum](#enum) with only 1 tag.\n- A [struct](#struct) with all fields being zero bit types.\n- A [union](#union) with only 1 field which is a zero bit type.\n\nThese types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code:\n\n``` zig\nexport fn entry() void {\n    var x: void = {};\n    var y: void = {};\n    x = y;\n    y = x;\n}\n```\n\nzero_bit_types.zig\n\nWhen this turns into machine code, there is no code generated in the body of `entry`, even in [Debug](#Debug) mode. For example, on x86_64:\n\n``` zig\n0000000000000010 <entry>:\n  10:   55                      push   %rbp\n  11:   48 89 e5                mov    %rsp,%rbp\n  14:   5d                      pop    %rbp\n  15:   c3                      retq   \n```\n\nThese assembly instructions do not have any code associated with the void values - they only perform the function call prologue and epilogue.\n\n### void\n\n`void` can be useful for instantiating generic types. For example, given a `Map(Key, Value)`, one can pass `void` for the `Value` type to make it into a `Set`:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"turn HashMap into a set with void\" {\n    var map = std.AutoHashMap(i32, void).init(std.testing.allocator);\n    defer map.deinit();\n\n    try map.put(1, {});\n    try map.put(2, {});\n\n    try expect(map.contains(2));\n    try expect(!map.contains(3));\n\n    _ = map.remove(2);\n    try expect(!map.contains(2));\n}\n```\n\ntest_void_in_hashmap.zig\n\n    $ zig test test_void_in_hashmap.zig\n    1/1 test_void_in_hashmap.test.turn HashMap into a set with void...OK\n    All 1 tests passed.\n\nShell\n\nNote that this is different from using a dummy value for the hash map value. By using `void` as the type of the value, the hash map entry type has no value field, and thus the hash map takes up less space. Further, all the code that deals with storing and loading the value is deleted, as seen above.\n\n`void` is distinct from `anyopaque`. `void` has a known size of 0 bytes, and `anyopaque` has an unknown, but non-zero, size.\n\nExpressions of type `void` are the only ones whose value can be ignored. For example, ignoring a non-`void` expression is a compile error:\n\n``` zig\ntest \"ignoring expression value\" {\n    foo();\n}\n\nfn foo() i32 {\n    return 1234;\n}\n```\n\ntest_expression_ignored.zig\n\n    $ zig test test_expression_ignored.zig\n    doc/langref/test_expression_ignored.zig:2:8: error: value of type 'i32' ignored\n        foo();\n        ~~~^~\n    doc/langref/test_expression_ignored.zig:2:8: note: all non-void values must be used\n    doc/langref/test_expression_ignored.zig:2:8: note: to discard the value, assign it to '_'\n\nShell\n\nHowever, if the expression has type `void`, there will be no error. Expression results can be explicitly ignored by assigning them to `_`.\n\n``` zig\ntest \"void is ignored\" {\n    returnsVoid();\n}\n\ntest \"explicitly ignoring expression value\" {\n    _ = foo();\n}\n\nfn returnsVoid() void {}\n\nfn foo() i32 {\n    return 1234;\n}\n```\n\ntest_void_ignored.zig\n\n    $ zig test test_void_ignored.zig\n    1/2 test_void_ignored.test.void is ignored...OK\n    2/2 test_void_ignored.test.explicitly ignoring expression value...OK\n    All 2 tests passed.\n\nShell\n\n## Result Location Semantics\n\nDuring compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to `_`, for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory location to place it in.\n\nAs a motivating example, consider the statement `const`` x: ``u32`` = ``42``;`. The type annotation here provides a result type of `u32` to the initialization expression `42`, instructing the compiler to coerce this integer (initally of type `comptime_int`) to this type. We will see more examples shortly.\n\nThis is not an implementation detail: the logic outlined above is codified into the Zig language specification, and is the primary mechanism of type inference in the language. This system is collectively referred to as \"Result Location Semantics\".\n\n### Result Types\n\nResult types are propagated recursively through expressions where possible. For instance, if the expression `&e` has result type `*``u32`, then `e` is given a result type of `u32`, allowing the language to perform this coercion before taking a reference.\n\nThe result type mechanism is utilized by casting builtins such as `@intCast`. Rather than taking as an argument the type to cast to, these builtins use their result type to determine this information. The result type is often known from context; where it is not, the `@as` builtin can be used to explicitly provide a result type.\n\nWe can break down the result types for each component of a simple expression as follows:\n\n``` zig\nconst expectEqual = @import(\"std\").testing.expectEqual;\ntest \"result type propagates through struct initializer\" {\n    const S = struct { x: u32 };\n    const val: u64 = 123;\n    const s: S = .{ .x = @intCast(val) };\n    // .{ .x = @intCast(val) }   has result type `S` due to the type annotation\n    //         @intCast(val)     has result type `u32` due to the type of the field `S.x`\n    //                  val      has no result type, as it is permitted to be any integer type\n    try expectEqual(@as(u32, 123), s.x);\n}\n```\n\nresult_type_propagation.zig\n\n    $ zig test result_type_propagation.zig\n    1/1 result_type_propagation.test.result type propagates through struct initializer...OK\n    All 1 tests passed.\n\nShell\n\nThis result type information is useful for the aforementioned cast builtins, as well as to avoid the construction of pre-coercion values, and to avoid the need for explicit type coercions in some cases. The following table details how some common expressions propagate result types, where `x` and `y` are arbitrary sub-expressions.\n\n| Expression           | Parent Result Type | Sub-expression Result Type                      |\n|----------------------|--------------------|-------------------------------------------------|\n| `const`` val: T = x` | \\-                 | `x` is a `T`                                    |\n| `var`` val: T = x`   | \\-                 | `x` is a `T`                                    |\n| `val = x`            | \\-                 | `x` is a `@TypeOf``(val)`                       |\n| `@as``(T, x)`        | \\-                 | `x` is a `T`                                    |\n| `&x`                 | `*T`               | `x` is a `T`                                    |\n| `&x`                 | `[]T`              | `x` is some array of `T`                        |\n| `f(x)`               | \\-                 | `x` has the type of the first parameter of `f`  |\n| `.{x}`               | `T`                | `x` is a `std.meta.FieldType(T, .@\"0\")`         |\n| `.{ .a = x }`        | `T`                | `x` is a `std.meta.FieldType(T, .a)`            |\n| `T{x}`               | \\-                 | `x` is a `std.meta.FieldType(T, .@\"0\")`         |\n| `T{ .a = x }`        | \\-                 | `x` is a `std.meta.FieldType(T, .a)`            |\n| `@Type``(x)`         | \\-                 | `x` is a `std.builtin.Type`                     |\n| `@typeInfo``(x)`     | \\-                 | `x` is a `type`                                 |\n| `x << y`             | \\-                 | `y` is a `std.math.Log2IntCeil(``@TypeOf``(x))` |\n\n### Result Locations\n\nIn addition to result type information, every expression may be optionally assigned a result location: a pointer to which the value must be directly written. This system can be used to prevent intermediate copies when initializing data structures, which can be important for types which must have a fixed memory address (\"pinned\" types).\n\nWhen compiling the simple assignment expression `x = e`, many languages would create the temporary value `e` on the stack, and then assign it to `x`, potentially performing a type coercion in the process. Zig approaches this differently. The expression `e` is given a result type matching the type of `x`, and a result location of `&x`. For many syntactic forms of `e`, this has no practical impact. However, it can have important semantic effects when working with more complex syntax forms.\n\nFor instance, if the expression `.{ .a = x, .b = y }` has a result location of `ptr`, then `x` is given a result location of `&ptr.a`, and `y` a result location of `&ptr.b`. Without this system, this expression would construct a temporary struct value entirely on the stack, and only then copy it to the destination address. In essence, Zig desugars the assignment `foo = .{ .a = x, .b = y }` to the two statements `foo.a = x; foo.b = y;`.\n\nThis can sometimes be important when assigning an aggregate value where the initialization expression depends on the previous value of the aggregate. The easiest way to demonstrate this is by attempting to swap fields of a struct or array - the following logic looks sound, but in fact is not:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\ntest \"attempt to swap array elements with array initializer\" {\n    var arr: [2]u32 = .{ 1, 2 };\n    arr = .{ arr[1], arr[0] };\n    // The previous line is equivalent to the following two lines:\n    //   arr[0] = arr[1];\n    //   arr[1] = arr[0];\n    // So this fails!\n    try expect(arr[0] == 2); // succeeds\n    try expect(arr[1] == 1); // fails\n}\n```\n\nresult_location_interfering_with_swap.zig\n\n    $ zig test result_location_interfering_with_swap.zig\n    1/1 result_location_interfering_with_swap.test.attempt to swap array elements with array initializer...FAIL (TestUnexpectedResult)\n    /home/andy/src/zig/lib/std/testing.zig:540:14: 0x103ce1f in expect (test)\n        if (!ok) return error.TestUnexpectedResult;\n                 ^\n    /home/andy/src/zig/doc/langref/result_location_interfering_with_swap.zig:10:5: 0x103cf85 in test.attempt to swap array elements with array initializer (test)\n        try expect(arr[1] == 1); // fails\n        ^\n    0 passed; 0 skipped; 1 failed.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/c42c6019fdf548f70655aafe3673a46e/test\n\nShell\n\nThe following table details how some common expressions propagate result locations, where `x` and `y` are arbitrary sub-expressions. Note that some expressions cannot provide meaningful result locations to sub-expressions, even if they themselves have a result location.\n\n| Expression           | Result Location | Sub-expression Result Locations                                                   |\n|----------------------|-----------------|-----------------------------------------------------------------------------------|\n| `const`` val: T = x` | \\-              | `x` has result location `&val`                                                    |\n| `var`` val: T = x`   | \\-              | `x` has result location `&val`                                                    |\n| `val = x`            | \\-              | `x` has result location `&val`                                                    |\n| `@as``(T, x)`        | `ptr`           | `x` has no result location                                                        |\n| `&x`                 | `ptr`           | `x` has no result location                                                        |\n| `f(x)`               | `ptr`           | `x` has no result location                                                        |\n| `.{x}`               | `ptr`           | `x` has result location `&ptr[``0``]`                                             |\n| `.{ .a = x }`        | `ptr`           | `x` has result location `&ptr.a`                                                  |\n| `T{x}`               | `ptr`           | `x` has no result location (typed initializers do not propagate result locations) |\n| `T{ .a = x }`        | `ptr`           | `x` has no result location (typed initializers do not propagate result locations) |\n| `@Type``(x)`         | `ptr`           | `x` has no result location                                                        |\n| `@typeInfo``(x)`     | `ptr`           | `x` has no result location                                                        |\n| `x << y`             | `ptr`           | `x` and `y` do not have result locations                                          |\n\n## usingnamespace\n\n`usingnamespace` is a declaration that mixes all the public declarations of the operand, which must be a [struct](#struct), [union](#union), [enum](#enum), or [opaque](#opaque), into the namespace:\n\n``` zig\ntest \"using std namespace\" {\n    const S = struct {\n        usingnamespace @import(\"std\");\n    };\n    try S.testing.expect(true);\n}\n```\n\ntest_usingnamespace.zig\n\n    $ zig test test_usingnamespace.zig\n    1/1 test_usingnamespace.test.using std namespace...OK\n    All 1 tests passed.\n\nShell\n\n`usingnamespace` has an important use case when organizing the public API of a file or package. For example, one might have `c.zig` with all of the [C imports](#Import-from-C-Header-File):\n\n``` zig\npub usingnamespace @cImport({\n    @cInclude(\"epoxy/gl.h\");\n    @cInclude(\"GLFW/glfw3.h\");\n    @cDefine(\"STBI_ONLY_PNG\", \"\");\n    @cDefine(\"STBI_NO_STDIO\", \"\");\n    @cInclude(\"stb_image.h\");\n});\n```\n\nc.zig\n\nThe above example demonstrates using `pub` to qualify the `usingnamespace` additionally makes the imported declarations `pub`. This can be used to forward declarations, giving precise control over what declarations a given file exposes.\n\n## comptime\n\nZig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful.\n\n### Introducing the Compile-Time Concept\n\n#### [Compile-Time Parameters](#toc-Compile-Time-Parameters)\n\nCompile-time parameters is how Zig implements generics. It is compile-time duck typing.\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a > b) a else b;\n}\nfn gimmeTheBiggerFloat(a: f32, b: f32) f32 {\n    return max(f32, a, b);\n}\nfn gimmeTheBiggerInteger(a: u64, b: u64) u64 {\n    return max(u64, a, b);\n}\n```\n\ncompile-time_duck_typing.zig\n\nIn Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions, and returned from functions. However, they can only be used in expressions which are known at *compile-time*, which is why the parameter `T` in the above snippet must be marked with `comptime`.\n\nA `comptime` parameter means that:\n\n- At the callsite, the value must be known at compile-time, or it is a compile error.\n- In the function definition, the value is known at compile-time.\n\nFor example, if we were to introduce another function to the above snippet:\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a > b) a else b;\n}\ntest \"try to pass a runtime type\" {\n    foo(false);\n}\nfn foo(condition: bool) void {\n    const result = max(if (condition) f32 else u64, 1234, 5678);\n    _ = result;\n}\n```\n\ntest_unresolved_comptime_value.zig\n\n    $ zig test test_unresolved_comptime_value.zig\n    doc/langref/test_unresolved_comptime_value.zig:8:28: error: unable to resolve comptime value\n        const result = max(if (condition) f32 else u64, 1234, 5678);\n                               ^~~~~~~~~\n    doc/langref/test_unresolved_comptime_value.zig:8:28: note: condition in comptime branch must be comptime-known\n    referenced by:\n        test.try to pass a runtime type: doc/langref/test_unresolved_comptime_value.zig:5:5\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\nThis is an error because the programmer attempted to pass a value only known at run-time to a function which expects a value known at compile-time.\n\nAnother way to get an error is if we pass a type that violates the type checker when the function is analyzed. This is what it means to have *compile-time duck typing*.\n\nFor example:\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a > b) a else b;\n}\ntest \"try to compare bools\" {\n    _ = max(bool, true, false);\n}\n```\n\ntest_comptime_mismatched_type.zig\n\n    $ zig test test_comptime_mismatched_type.zig\n    doc/langref/test_comptime_mismatched_type.zig:2:18: error: operator > not allowed for type 'bool'\n        return if (a > b) a else b;\n                   ~~^~~\n    referenced by:\n        test.try to compare bools: doc/langref/test_comptime_mismatched_type.zig:5:12\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\nOn the flip side, inside the function definition with the `comptime` parameter, the value is known at compile-time. This means that we actually could make this work for the bool type if we wanted to:\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    if (T == bool) {\n        return a or b;\n    } else if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\ntest \"try to compare bools\" {\n    try @import(\"std\").testing.expect(max(bool, false, true) == true);\n}\n```\n\ntest_comptime_max_with_bool.zig\n\n    $ zig test test_comptime_max_with_bool.zig\n    1/1 test_comptime_max_with_bool.test.try to compare bools...OK\n    All 1 tests passed.\n\nShell\n\nThis works because Zig implicitly inlines `if` expressions when the condition is known at compile-time, and the compiler guarantees that it will skip analysis of the branch not taken.\n\nThis means that the actual function generated for `max` in this situation looks like this:\n\n``` zig\nfn max(a: bool, b: bool) bool {\n    {\n        return a or b;\n    }\n}\n```\n\ncompiler_generated_function.zig\n\nAll the code that dealt with compile-time known values is eliminated and we are left with only the necessary run-time code to accomplish the task.\n\nThis works the same way for `switch` expressions - they are implicitly inlined when the target expression is compile-time known.\n\n#### [Compile-Time Variables](#toc-Compile-Time-Variables)\n\nIn Zig, the programmer can label variables as `comptime`. This guarantees to the compiler that every load and store of the variable is performed at compile-time. Any violation of this results in a compile error.\n\nThis combined with the fact that we can `inline` loops allows us to write a function which is partially evaluated at compile-time and partially at run-time.\n\nFor example:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nconst CmdFn = struct {\n    name: []const u8,\n    func: fn (i32) i32,\n};\n\nconst cmd_fns = [_]CmdFn{\n    CmdFn{ .name = \"one\", .func = one },\n    CmdFn{ .name = \"two\", .func = two },\n    CmdFn{ .name = \"three\", .func = three },\n};\nfn one(value: i32) i32 {\n    return value + 1;\n}\nfn two(value: i32) i32 {\n    return value + 2;\n}\nfn three(value: i32) i32 {\n    return value + 3;\n}\n\nfn performFn(comptime prefix_char: u8, start_value: i32) i32 {\n    var result: i32 = start_value;\n    comptime var i = 0;\n    inline while (i < cmd_fns.len) : (i += 1) {\n        if (cmd_fns[i].name[0] == prefix_char) {\n            result = cmd_fns[i].func(result);\n        }\n    }\n    return result;\n}\n\ntest \"perform fn\" {\n    try expect(performFn('t', 1) == 6);\n    try expect(performFn('o', 0) == 1);\n    try expect(performFn('w', 99) == 99);\n}\n```\n\ntest_comptime_evaluation.zig\n\n    $ zig test test_comptime_evaluation.zig\n    1/1 test_comptime_evaluation.test.perform fn...OK\n    All 1 tests passed.\n\nShell\n\nThis example is a bit contrived, because the compile-time evaluation component is unnecessary; this code would work fine if it was all done at run-time. But it does end up generating different code. In this example, the function `performFn` is generated three different times, for the different values of `prefix_char` provided:\n\n``` zig\n// From the line:\n// expect(performFn('t', 1) == 6);\nfn performFn(start_value: i32) i32 {\n    var result: i32 = start_value;\n    result = two(result);\n    result = three(result);\n    return result;\n}\n```\n\nperformFn_1\n\n``` zig\n// From the line:\n// expect(performFn('o', 0) == 1);\nfn performFn(start_value: i32) i32 {\n    var result: i32 = start_value;\n    result = one(result);\n    return result;\n}\n```\n\nperformFn_2\n\n``` zig\n// From the line:\n// expect(performFn('w', 99) == 99);\nfn performFn(start_value: i32) i32 {\n    var result: i32 = start_value;\n    _ = &result;\n    return result;\n}\n```\n\nperformFn_3\n\nNote that this happens even in a debug build. This is not a way to write more optimized code, but it is a way to make sure that what *should* happen at compile-time, *does* happen at compile-time. This catches more errors and allows expressiveness that in other languages requires using macros, generated code, or a preprocessor to accomplish.\n\n#### [Compile-Time Expressions](#toc-Compile-Time-Expressions)\n\nIn Zig, it matters whether a given expression is known at compile-time or run-time. A programmer can use a `comptime` expression to guarantee that the expression will be evaluated at compile-time. If this cannot be accomplished, the compiler will emit an error. For example:\n\n``` zig\nextern fn exit() noreturn;\n\ntest \"foo\" {\n    comptime {\n        exit();\n    }\n}\n```\n\ntest_comptime_call_extern_function.zig\n\n    $ zig test test_comptime_call_extern_function.zig\n    doc/langref/test_comptime_call_extern_function.zig:5:13: error: comptime call of extern function\n            exit();\n            ~~~~^~\n\nShell\n\nIt doesn't make sense that a program could call `exit()` (or any other external function) at compile-time, so this is a compile error. However, a `comptime` expression does much more than sometimes cause a compile error.\n\nWithin a `comptime` expression:\n\n- All variables are `comptime` variables.\n- All `if`, `while`, `for`, and `switch` expressions are evaluated at compile-time, or emit a compile error if this is not possible.\n- All `return` and `try` expressions are invalid (unless the function itself is called at compile-time).\n- All code with runtime side effects or depending on runtime values emits a compile error.\n- All function calls cause the compiler to interpret the function at compile-time, emitting a compile error if the function tries to do something that has global runtime side effects.\n\nThis means that a programmer can create a function which is called both at compile-time and run-time, with no modification to the function required.\n\nLet's look at an example:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nfn fibonacci(index: u32) u32 {\n    if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    // test fibonacci at run-time\n    try expect(fibonacci(7) == 13);\n\n    // test fibonacci at compile-time\n    try comptime expect(fibonacci(7) == 13);\n}\n```\n\ntest_fibonacci_recursion.zig\n\n    $ zig test test_fibonacci_recursion.zig\n    1/1 test_fibonacci_recursion.test.fibonacci...OK\n    All 1 tests passed.\n\nShell\n\nImagine if we had forgotten the base case of the recursive function and tried to run the tests:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nfn fibonacci(index: u32) u32 {\n    //if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    try comptime expect(fibonacci(7) == 13);\n}\n```\n\ntest_fibonacci_comptime_overflow.zig\n\n    $ zig test test_fibonacci_comptime_overflow.zig\n    doc/langref/test_fibonacci_comptime_overflow.zig:5:28: error: overflow of integer type 'u32' with value '-1'\n        return fibonacci(index - 1) + fibonacci(index - 2);\n                         ~~~~~~^~~\n    doc/langref/test_fibonacci_comptime_overflow.zig:5:21: note: called from here (7 times)\n        return fibonacci(index - 1) + fibonacci(index - 2);\n               ~~~~~~~~~^~~~~~~~~~~\n    doc/langref/test_fibonacci_comptime_overflow.zig:9:34: note: called from here\n        try comptime expect(fibonacci(7) == 13);\n                            ~~~~~~~~~^~~\n\nShell\n\nThe compiler produces an error which is a stack trace from trying to evaluate the function at compile-time.\n\nLuckily, we used an unsigned integer, and so when we tried to subtract 1 from 0, it triggered undefined behavior, which is always a compile error if the compiler knows it happened. But what would have happened if we used a signed integer?\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\n\nfn fibonacci(index: i32) i32 {\n    //if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    try comptime assert(fibonacci(7) == 13);\n}\n```\n\nfibonacci_comptime_infinite_recursion.zig\n\nThe compiler is supposed to notice that evaluating this function at compile-time took more than 1000 branches, and thus emits an error and gives up. If the programmer wants to increase the budget for compile-time computation, they can use a built-in function called [@setEvalBranchQuota](#setEvalBranchQuota) to change the default number 1000 to something else.\n\nHowever, there is a [design flaw in the compiler](https://github.com/ziglang/zig/issues/13724) causing it to stack overflow instead of having the proper behavior here. I'm terribly sorry about that. I hope to get this resolved before the next release.\n\nWhat if we fix the base case, but put the wrong value in the `expect` line?\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\n\nfn fibonacci(index: i32) i32 {\n    if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    try comptime assert(fibonacci(7) == 99999);\n}\n```\n\ntest_fibonacci_comptime_unreachable.zig\n\n    $ zig test test_fibonacci_comptime_unreachable.zig\n    lib/std/debug.zig:412:14: error: reached unreachable code\n        if (!ok) unreachable; // assertion failure\n                 ^~~~~~~~~~~\n    doc/langref/test_fibonacci_comptime_unreachable.zig:9:24: note: called from here\n        try comptime assert(fibonacci(7) == 99999);\n                     ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\nShell\n\nAt [container](#Containers) level (outside of any function), all expressions are implicitly `comptime` expressions. This means that we can use functions to initialize complex static data. For example:\n\n``` zig\nconst first_25_primes = firstNPrimes(25);\nconst sum_of_first_25_primes = sum(&first_25_primes);\n\nfn firstNPrimes(comptime n: usize) [n]i32 {\n    var prime_list: [n]i32 = undefined;\n    var next_index: usize = 0;\n    var test_number: i32 = 2;\n    while (next_index < prime_list.len) : (test_number += 1) {\n        var test_prime_index: usize = 0;\n        var is_prime = true;\n        while (test_prime_index < next_index) : (test_prime_index += 1) {\n            if (test_number % prime_list[test_prime_index] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            prime_list[next_index] = test_number;\n            next_index += 1;\n        }\n    }\n    return prime_list;\n}\n\nfn sum(numbers: []const i32) i32 {\n    var result: i32 = 0;\n    for (numbers) |x| {\n        result += x;\n    }\n    return result;\n}\n\ntest \"variable values\" {\n    try @import(\"std\").testing.expect(sum_of_first_25_primes == 1060);\n}\n```\n\ntest_container-level_comptime_expressions.zig\n\n    $ zig test test_container-level_comptime_expressions.zig\n    1/1 test_container-level_comptime_expressions.test.variable values...OK\n    All 1 tests passed.\n\nShell\n\nWhen we compile this program, Zig generates the constants with the answer pre-computed. Here are the lines from the generated LLVM IR:\n\n``` zig\n@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]\n@1 = internal unnamed_addr constant i32 1060\n```\n\nNote that we did not have to do anything special with the syntax of these functions. For example, we could call the `sum` function as is with a slice of numbers whose length and values were only known at run-time.\n\n### Generic Data Structures\n\nZig uses comptime capabilities to implement generic data structures without introducing any special-case syntax.\n\nHere is an example of a generic `List` data structure.\n\n``` zig\nfn List(comptime T: type) type {\n    return struct {\n        items: []T,\n        len: usize,\n    };\n}\n\n// The generic List data structure can be instantiated by passing in a type:\nvar buffer: [10]i32 = undefined;\nvar list = List(i32){\n    .items = &buffer,\n    .len = 0,\n};\n```\n\ngeneric_data_structure.zig\n\nThat's it. It's a function that returns an anonymous `struct`. For the purposes of error messages and debugging, Zig infers the name `\"List(i32)\"` from the function name and parameters invoked when creating the anonymous struct.\n\nTo explicitly give a type a name, we assign it to a constant.\n\n``` zig\nconst Node = struct {\n    next: ?*Node,\n    name: []const u8,\n};\n\nvar node_a = Node{\n    .next = null,\n    .name = \"Node A\",\n};\n\nvar node_b = Node{\n    .next = &node_a,\n    .name = \"Node B\",\n};\n```\n\nanonymous_struct_name.zig\n\nIn this example, the `Node` struct refers to itself. This works because all top level declarations are order-independent. As long as the compiler can determine the size of the struct, it is free to refer to itself. In this case, `Node` refers to itself as a pointer, which has a well-defined size at compile time, so it works fine.\n\n### Case Study: print in Zig\n\nPutting all of this together, let's see how `print` works in Zig.\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst a_number: i32 = 1234;\nconst a_string = \"foobar\";\n\npub fn main() void {\n    print(\"here is a string: '{s}' here is a number: {}\\n\", .{ a_string, a_number });\n}\n```\n\nprint.zig\n\n    $ zig build-exe print.zig\n    $ ./print\n    here is a string: 'foobar' here is a number: 1234\n\nShell\n\nLet's crack open the implementation of this and see how it works:\n\n``` zig\nconst Writer = struct {\n    /// Calls print and then flushes the buffer.\n    pub fn print(self: *Writer, comptime format: []const u8, args: anytype) anyerror!void {\n        const State = enum {\n            start,\n            open_brace,\n            close_brace,\n        };\n\n        comptime var start_index: usize = 0;\n        comptime var state = State.start;\n        comptime var next_arg: usize = 0;\n\n        inline for (format, 0..) |c, i| {\n            switch (state) {\n                State.start => switch (c) {\n                    '{' => {\n                        if (start_index < i) try self.write(format[start_index..i]);\n                        state = State.open_brace;\n                    },\n                    '}' => {\n                        if (start_index < i) try self.write(format[start_index..i]);\n                        state = State.close_brace;\n                    },\n                    else => {},\n                },\n                State.open_brace => switch (c) {\n                    '{' => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    '}' => {\n                        try self.printValue(args[next_arg]);\n                        next_arg += 1;\n                        state = State.start;\n                        start_index = i + 1;\n                    },\n                    's' => {\n                        continue;\n                    },\n                    else => @compileError(\"Unknown format character: \" ++ [1]u8{c}),\n                },\n                State.close_brace => switch (c) {\n                    '}' => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    else => @compileError(\"Single '}' encountered in format string\"),\n                },\n            }\n        }\n        comptime {\n            if (args.len != next_arg) {\n                @compileError(\"Unused arguments\");\n            }\n            if (state != State.start) {\n                @compileError(\"Incomplete format string: \" ++ format);\n            }\n        }\n        if (start_index < format.len) {\n            try self.write(format[start_index..format.len]);\n        }\n        try self.flush();\n    }\n\n    fn write(self: *Writer, value: []const u8) !void {\n        _ = self;\n        _ = value;\n    }\n    pub fn printValue(self: *Writer, value: anytype) !void {\n        _ = self;\n        _ = value;\n    }\n    fn flush(self: *Writer) !void {\n        _ = self;\n    }\n};\n```\n\npoc_print_fn.zig\n\nThis is a proof of concept implementation; the actual function in the standard library has more formatting capabilities.\n\nNote that this is not hard-coded into the Zig compiler; this is userland code in the standard library.\n\nWhen this function is analyzed from our example code above, Zig partially evaluates the function and emits a function that actually looks like this:\n\n``` zig\npub fn print(self: *Writer, arg0: []const u8, arg1: i32) !void {\n    try self.write(\"here is a string: '\");\n    try self.printValue(arg0);\n    try self.write(\"' here is a number: \");\n    try self.printValue(arg1);\n    try self.write(\"\\n\");\n    try self.flush();\n}\n```\n\nEmitted print Function\n\n`printValue` is a function that takes a parameter of any type, and does different things depending on the type:\n\n``` zig\nconst Writer = struct {\n    pub fn printValue(self: *Writer, value: anytype) !void {\n        switch (@typeInfo(@TypeOf(value))) {\n            .Int => {\n                return self.writeInt(value);\n            },\n            .Float => {\n                return self.writeFloat(value);\n            },\n            .Pointer => {\n                return self.write(value);\n            },\n            else => {\n                @compileError(\"Unable to print type '\" ++ @typeName(@TypeOf(value)) ++ \"'\");\n            },\n        }\n    }\n\n    fn write(self: *Writer, value: []const u8) !void {\n        _ = self;\n        _ = value;\n    }\n    fn writeInt(self: *Writer, value: anytype) !void {\n        _ = self;\n        _ = value;\n    }\n    fn writeFloat(self: *Writer, value: anytype) !void {\n        _ = self;\n        _ = value;\n    }\n};\n```\n\npoc_printValue_fn.zig\n\nAnd now, what happens if we give too many arguments to `print`?\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst a_number: i32 = 1234;\nconst a_string = \"foobar\";\n\ntest \"print too many arguments\" {\n    print(\"here is a string: '{s}' here is a number: {}\\n\", .{\n        a_string,\n        a_number,\n        a_number,\n    });\n}\n```\n\ntest_print_too_many_args.zig\n\n    $ zig test test_print_too_many_args.zig\n    lib/std/fmt.zig:203:18: error: unused argument in 'here is a string: '{s}' here is a number: {}\n                                   '\n                1 => @compileError(\"unused argument in '\" ++ fmt ++ \"'\"),\n                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    referenced by:\n        print__anon_2377: lib/std/io/Writer.zig:24:26\n        print: lib/std/io.zig:324:47\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\nZig gives programmers the tools needed to protect themselves against their own mistakes.\n\nZig doesn't care whether the format argument is a string literal, only that it is a compile-time known value that can be coerced to a `[]``const`` ``u8`:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst a_number: i32 = 1234;\nconst a_string = \"foobar\";\nconst fmt = \"here is a string: '{s}' here is a number: {}\\n\";\n\npub fn main() void {\n    print(fmt, .{ a_string, a_number });\n}\n```\n\nprint_comptime-known_format.zig\n\n    $ zig build-exe print_comptime-known_format.zig\n    $ ./print_comptime-known_format\n    here is a string: 'foobar' here is a number: 1234\n\nShell\n\nThis works fine.\n\nZig does not special case string formatting in the compiler and instead exposes enough power to accomplish this task in userland. It does so without introducing another language on top of Zig, such as a macro language or a preprocessor language. It's Zig all the way down.\n\nSee also:\n\n- [inline while](#inline-while)\n- [inline for](#inline-for)\n\n## Assembly\n\nFor some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly:\n\n``` zig\npub fn main() noreturn {\n    const msg = \"hello world\\n\";\n    _ = syscall3(SYS_write, STDOUT_FILENO, @intFromPtr(msg), msg.len);\n    _ = syscall1(SYS_exit, 0);\n    unreachable;\n}\n\npub const SYS_write = 1;\npub const SYS_exit = 60;\n\npub const STDOUT_FILENO = 1;\n\npub fn syscall1(number: usize, arg1: usize) usize {\n    return asm volatile (\"syscall\"\n        : [ret] \"={rax}\" (-> usize),\n        : [number] \"{rax}\" (number),\n          [arg1] \"{rdi}\" (arg1),\n        : \"rcx\", \"r11\"\n    );\n}\n\npub fn syscall3(number: usize, arg1: usize, arg2: usize, arg3: usize) usize {\n    return asm volatile (\"syscall\"\n        : [ret] \"={rax}\" (-> usize),\n        : [number] \"{rax}\" (number),\n          [arg1] \"{rdi}\" (arg1),\n          [arg2] \"{rsi}\" (arg2),\n          [arg3] \"{rdx}\" (arg3),\n        : \"rcx\", \"r11\"\n    );\n}\n```\n\ninline_assembly.zig\n\n    $ zig build-exe inline_assembly.zig -target x86_64-linux\n    $ ./inline_assembly\n    hello world\n\nShell\n\nDissecting the syntax:\n\n``` zig\npub fn syscall1(number: usize, arg1: usize) usize {\n    // Inline assembly is an expression which returns a value.\n    // the `asm` keyword begins the expression.\n    return asm\n    // `volatile` is an optional modifier that tells Zig this\n    // inline assembly expression has side-effects. Without\n    // `volatile`, Zig is allowed to delete the inline assembly\n    // code if the result is unused.\n    volatile (\n    // Next is a comptime string which is the assembly code.\n    // Inside this string one may use `%[ret]`, `%[number]`,\n    // or `%[arg1]` where a register is expected, to specify\n    // the register that Zig uses for the argument or return value,\n    // if the register constraint strings are used. However in\n    // the below code, this is not used. A literal `%` can be\n    // obtained by escaping it with a double percent: `%%`.\n    // Often multiline string syntax comes in handy here.\n        \\\\syscall\n        // Next is the output. It is possible in the future Zig will\n        // support multiple outputs, depending on how\n        // https://github.com/ziglang/zig/issues/215 is resolved.\n        // It is allowed for there to be no outputs, in which case\n        // this colon would be directly followed by the colon for the inputs.\n        :\n        // This specifies the name to be used in `%[ret]` syntax in\n        // the above assembly string. This example does not use it,\n        // but the syntax is mandatory.\n          [ret]\n          // Next is the output constraint string. This feature is still\n          // considered unstable in Zig, and so LLVM/GCC documentation\n          // must be used to understand the semantics.\n          // http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string\n          // https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html\n          // In this example, the constraint string means \"the result value of\n          // this inline assembly instruction is whatever is in $rax\".\n          \"={rax}\"\n          // Next is either a value binding, or `->` and then a type. The\n          // type is the result type of the inline assembly expression.\n          // If it is a value binding, then `%[ret]` syntax would be used\n          // to refer to the register bound to the value.\n          (-> usize),\n          // Next is the list of inputs.\n          // The constraint for these inputs means, \"when the assembly code is\n          // executed, $rax shall have the value of `number` and $rdi shall have\n          // the value of `arg1`\". Any number of input parameters is allowed,\n          // including none.\n        : [number] \"{rax}\" (number),\n          [arg1] \"{rdi}\" (arg1),\n          // Next is the list of clobbers. These declare a set of registers whose\n          // values will not be preserved by the execution of this assembly code.\n          // These do not include output or input registers. The special clobber\n          // value of \"memory\" means that the assembly writes to arbitrary undeclared\n          // memory locations - not only the memory pointed to by a declared indirect\n          // output. In this example we list $rcx and $r11 because it is known the\n          // kernel syscall does not preserve these registers.\n        : \"rcx\", \"r11\"\n    );\n}\n```\n\nAssembly Syntax Explained.zig\n\nFor x86 and x86_64 targets, the syntax is AT&T syntax, rather than the more popular Intel syntax. This is due to technical constraints; assembly parsing is provided by LLVM and its support for Intel syntax is buggy and not well tested.\n\nSome day Zig may have its own assembler. This would allow it to integrate more seamlessly into the language, as well as be compatible with the popular NASM syntax. This documentation section will be updated before 1.0.0 is released, with a conclusive statement about the status of AT&T vs Intel/NASM syntax.\n\n### Output Constraints\n\nOutput constraints are still considered to be unstable in Zig, and so [LLVM documentation](http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string) and [GCC documentation](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) must be used to understand the semantics.\n\nNote that some breaking changes to output constraints are planned with [issue \\#215](https://github.com/ziglang/zig/issues/215).\n\n### Input Constraints\n\nInput constraints are still considered to be unstable in Zig, and so [LLVM documentation](http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string) and [GCC documentation](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) must be used to understand the semantics.\n\nNote that some breaking changes to input constraints are planned with [issue \\#215](https://github.com/ziglang/zig/issues/215).\n\n### Clobbers\n\nClobbers are the set of registers whose values will not be preserved by the execution of the assembly code. These do not include output or input registers. The special clobber value of `\"memory\"` means that the assembly causes writes to arbitrary undeclared memory locations - not only the memory pointed to by a declared indirect output.\n\nFailure to declare the full set of clobbers for a given inline assembly expression is unchecked [Undefined Behavior](#Undefined-Behavior).\n\n### Global Assembly\n\nWhen an assembly expression occurs in a [container](#Containers) level [comptime](#comptime) block, this is **global assembly**.\n\nThis kind of assembly has different rules than inline assembly. First, `volatile` is not valid because all global assembly is unconditionally included. Second, there are no inputs, outputs, or clobbers. All global assembly is concatenated verbatim into one long string and assembled together. There are no template substitution rules regarding `%` as there are in inline assembly expressions.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ncomptime {\n    asm (\n        \\\\.global my_func;\n        \\\\.type my_func, @function;\n        \\\\my_func:\n        \\\\  lea (%rdi,%rsi,1),%eax\n        \\\\  retq\n    );\n}\n\nextern fn my_func(a: i32, b: i32) i32;\n\ntest \"global assembly\" {\n    try expect(my_func(12, 34) == 46);\n}\n```\n\ntest_global_assembly.zig\n\n    $ zig test test_global_assembly.zig -target x86_64-linux\n    1/1 test_global_assembly.test.global assembly...OK\n    All 1 tests passed.\n\nShell\n\n## Atomics\n\nTODO: @fence()\n\nTODO: @atomic rmw\n\nTODO: builtin atomic memory ordering enum\n\nSee also:\n\n- [@atomicLoad](#atomicLoad)\n- [@atomicStore](#atomicStore)\n- [@atomicRmw](#atomicRmw)\n- [@fence](#fence)\n- [@cmpxchgWeak](#cmpxchgWeak)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n## Async Functions\n\nAsync functions regressed with the release of 0.11.0. Their future in the Zig language is unclear due to multiple unsolved problems:\n\n- LLVM's lack of ability to optimize them.\n- Third-party debuggers' lack of ability to debug them.\n- [The cancellation problem](https://github.com/ziglang/zig/issues/5913).\n- Async function pointers preventing the stack size from being known.\n\nThese problems are surmountable, but it will take time. The Zig team is currently focused on other priorities.\n\n## Builtin Functions\n\nBuiltin functions are provided by the compiler and are prefixed with `@`. The `comptime` keyword on a parameter means that the parameter must be known at compile time.\n\n### @addrSpaceCast\n\n``` zig\n@addrSpaceCast(ptr: anytype) anytype\n```\n\nConverts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the pointer operand. It is always valid to cast a pointer between the same address spaces.\n\n### @addWithOverflow\n\n``` zig\n@addWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }\n```\n\nPerforms `a + b` and returns a tuple with the result and a possible overflow bit.\n\n### @alignCast\n\n``` zig\n@alignCast(ptr: anytype) anytype\n```\n\n`ptr` can be `*T`, `?*T`, or `[]T`. Changes the alignment of a pointer. The alignment to use is inferred based on the result type.\n\nA [pointer alignment safety check](#Incorrect-Pointer-Alignment) is added to the generated code to make sure the pointer is aligned as promised.\n\n### @alignOf\n\n``` zig\n@alignOf(comptime T: type) comptime_int\n```\n\nThis function returns the number of bytes that this type should be aligned to for the current target to match the C ABI. When the child type of a pointer has this alignment, the alignment can be omitted from the type.\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\ncomptime {\n    assert(*u32 == *align(@alignOf(u32)) u32);\n}\n```\n\nThe result is a target-specific compile time constant. It is guaranteed to be less than or equal to [@sizeOf(T)](#sizeOf).\n\nSee also:\n\n- [Alignment](#Alignment)\n\n### @as\n\n``` zig\n@as(comptime T: type, expression) T\n```\n\nPerforms [Type Coercion](#Type-Coercion). This cast is allowed when the conversion is unambiguous and safe, and is the preferred way to convert between types, whenever possible.\n\n### @atomicLoad\n\n``` zig\n@atomicLoad(comptime T: type, ptr: *const T, comptime ordering: AtomicOrder) T\n```\n\nThis builtin function atomically dereferences a pointer to a `T` and returns the value.\n\n`T` must be a pointer, a `bool`, a float, an integer or an enum.\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\nSee also:\n\n- [@atomicStore](#atomicStore)\n- [@atomicRmw](#atomicRmw)\n- [@fence](#fence)\n- [@cmpxchgWeak](#cmpxchgWeak)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n### @atomicRmw\n\n``` zig\n@atomicRmw(comptime T: type, ptr: *T, comptime op: AtomicRmwOp, operand: T, comptime ordering: AtomicOrder) T\n```\n\nThis builtin function dereferences a pointer to a `T` and atomically modifies the value and returns the previous value.\n\n`T` must be a pointer, a `bool`, a float, an integer or an enum.\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\n`AtomicRmwOp` can be found with `@import``(``\"std\"``).builtin.AtomicRmwOp`.\n\nSee also:\n\n- [@atomicStore](#atomicStore)\n- [@atomicLoad](#atomicLoad)\n- [@fence](#fence)\n- [@cmpxchgWeak](#cmpxchgWeak)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n### @atomicStore\n\n``` zig\n@atomicStore(comptime T: type, ptr: *T, value: T, comptime ordering: AtomicOrder) void\n```\n\nThis builtin function dereferences a pointer to a `T` and atomically stores the given value.\n\n`T` must be a pointer, a `bool`, a float, an integer or an enum.\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\nSee also:\n\n- [@atomicLoad](#atomicLoad)\n- [@atomicRmw](#atomicRmw)\n- [@fence](#fence)\n- [@cmpxchgWeak](#cmpxchgWeak)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n### @bitCast\n\n``` zig\n@bitCast(value: anytype) anytype\n```\n\nConverts a value of one type to another type. The return type is the inferred result type.\n\nAsserts that `@sizeOf``(``@TypeOf``(value)) == ``@sizeOf``(DestType)`.\n\nAsserts that `@typeInfo``(DestType) != .Pointer`. Use `@ptrCast` or `@ptrFromInt` if you need this.\n\nCan be used for these things for example:\n\n- Convert `f32` to `u32` bits\n- Convert `i32` to `u32` preserving twos complement\n\nWorks at compile-time if `value` is known at compile time. It's a compile error to bitcast a value of undefined layout; this means that, besides the restriction from types which possess dedicated casting builtins (enums, pointers, error sets), bare structs, error unions, slices, optionals, and any other type without a well-defined memory layout, also cannot be used in this operation.\n\n### @bitOffsetOf\n\n``` zig\n@bitOffsetOf(comptime T: type, comptime field_name: []const u8) comptime_int\n```\n\nReturns the bit offset of a field relative to its containing struct.\n\nFor non [packed structs](#packed-struct), this will always be divisible by `8`. For packed structs, non-byte-aligned fields will share a byte offset, but they will have different bit offsets.\n\nSee also:\n\n- [@offsetOf](#offsetOf)\n\n### @bitSizeOf\n\n``` zig\n@bitSizeOf(comptime T: type) comptime_int\n```\n\nThis function returns the number of bits it takes to store `T` in memory if the type were a field in a packed struct/union. The result is a target-specific compile time constant.\n\nThis function measures the size at runtime. For types that are disallowed at runtime, such as `comptime_int` and `type`, the result is `0`.\n\nSee also:\n\n- [@sizeOf](#sizeOf)\n- [@typeInfo](#typeInfo)\n\n### @breakpoint\n\n``` zig\n@breakpoint() void\n```\n\nThis function inserts a platform-specific debug trap instruction which causes debuggers to break there. Unlike for `@trap``()`, execution may continue after this point if the program is resumed.\n\nThis function is only valid within function scope.\n\nSee also:\n\n- [@trap](#trap)\n\n### @mulAdd\n\n``` zig\n@mulAdd(comptime T: type, a: T, b: T, c: T) T\n```\n\nFused multiply-add, similar to `(a * b) + c`, except only rounds once, and is thus more accurate.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @byteSwap\n\n``` zig\n@byteSwap(operand: anytype) T\n```\n\n`@TypeOf``(operand)` must be an integer type or an integer vector type with bit count evenly divisible by 8.\n\n`operand` may be an [integer](#Integers) or [vector](#Vectors).\n\nSwaps the byte order of the integer. This converts a big endian integer to a little endian integer, and converts a little endian integer to a big endian integer.\n\nNote that for the purposes of memory layout with respect to endianness, the integer type should be related to the number of bytes reported by [@sizeOf](#sizeOf) bytes. This is demonstrated with `u24`. `@sizeOf``(``u24``) == ``4`, which means that a `u24` stored in memory takes 4 bytes, and those 4 bytes are what are swapped on a little vs big endian system. On the other hand, if `T` is specified to be `u24`, then only 3 bytes are reversed.\n\n### @bitReverse\n\n``` zig\n@bitReverse(integer: anytype) T\n```\n\n`@TypeOf``(``anytype``)` accepts any integer type or integer vector type.\n\nReverses the bitpattern of an integer value, including the sign bit if applicable.\n\nFor example 0b10110110 (`u8`` = ``182`, `i8`` = -``74`) becomes 0b01101101 (`u8`` = ``109`, `i8`` = ``109`).\n\n### @offsetOf\n\n``` zig\n@offsetOf(comptime T: type, comptime field_name: []const u8) comptime_int\n```\n\nReturns the byte offset of a field relative to its containing struct.\n\nSee also:\n\n- [@bitOffsetOf](#bitOffsetOf)\n\n### @call\n\n``` zig\n@call(modifier: std.builtin.CallModifier, function: anytype, args: anytype) anytype\n```\n\nCalls a function, in the same way that invoking an expression with parentheses does:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"noinline function call\" {\n    try expect(@call(.auto, add, .{ 3, 9 }) == 12);\n}\n\nfn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n```\n\ntest_call_builtin.zig\n\n    $ zig test test_call_builtin.zig\n    1/1 test_call_builtin.test.noinline function call...OK\n    All 1 tests passed.\n\nShell\n\n`@call` allows more flexibility than normal function call syntax does. The `CallModifier` enum is reproduced here:\n\n``` zig\npub const CallModifier = enum {\n    /// Equivalent to function call syntax.\n    auto,\n\n    /// Equivalent to async keyword used with function call syntax.\n    async_kw,\n\n    /// Prevents tail call optimization. This guarantees that the return\n    /// address will point to the callsite, as opposed to the callsite's\n    /// callsite. If the call is otherwise required to be tail-called\n    /// or inlined, a compile error is emitted instead.\n    never_tail,\n\n    /// Guarantees that the call will not be inlined. If the call is\n    /// otherwise required to be inlined, a compile error is emitted instead.\n    never_inline,\n\n    /// Asserts that the function call will not suspend. This allows a\n    /// non-async function to call an async function.\n    no_async,\n\n    /// Guarantees that the call will be generated with tail call optimization.\n    /// If this is not possible, a compile error is emitted instead.\n    always_tail,\n\n    /// Guarantees that the call will inlined at the callsite.\n    /// If this is not possible, a compile error is emitted instead.\n    always_inline,\n\n    /// Evaluates the call at compile-time. If the call cannot be completed at\n    /// compile-time, a compile error is emitted instead.\n    compile_time,\n};\n```\n\nbuiltin.CallModifier struct.zig\n\n### @cDefine\n\n``` zig\n@cDefine(comptime name: []const u8, value) void\n```\n\nThis function can only occur inside `@cImport`.\n\nThis appends `#define $name $value` to the `@cImport` temporary buffer.\n\nTo define without a value, like this:\n\n``` zig\n#define _GNU_SOURCE\n```\n\nUse the void value, like this:\n\n``` zig\n@cDefine(\"_GNU_SOURCE\", {})\n```\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cInclude](#cInclude)\n- [@cImport](#cImport)\n- [@cUndef](#cUndef)\n- [void](#void)\n\n### @cImport\n\n``` zig\n@cImport(expression) type\n```\n\nThis function parses C code and imports the functions, types, variables, and compatible macro definitions into a new empty struct type, and then returns that type.\n\n`expression` is interpreted at compile time. The builtin functions `@cInclude`, `@cDefine`, and `@cUndef` work within this expression, appending to a temporary buffer which is then parsed as C code.\n\nUsually you should only have one `@cImport` in your entire application, because it saves the compiler from invoking clang multiple times, and prevents inline functions from being duplicated.\n\nReasons for having multiple `@cImport` expressions would be:\n\n- To avoid a symbol collision, for example if foo.h and bar.h both `#define CONNECTION_COUNT`\n- To analyze the C code with different preprocessor defines\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cInclude](#cInclude)\n- [@cDefine](#cDefine)\n- [@cUndef](#cUndef)\n\n### @cInclude\n\n``` zig\n@cInclude(comptime path: []const u8) void\n```\n\nThis function can only occur inside `@cImport`.\n\nThis appends `#include <$path>\\n` to the `c_import` temporary buffer.\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cImport](#cImport)\n- [@cDefine](#cDefine)\n- [@cUndef](#cUndef)\n\n### @clz\n\n``` zig\n@clz(operand: anytype) anytype\n```\n\n`@TypeOf``(operand)` must be an integer type or an integer vector type.\n\n`operand` may be an [integer](#Integers) or [vector](#Vectors).\n\nCounts the number of most-significant (leading in a big-endian sense) zeroes in an integer - \"count leading zeroes\".\n\nIf `operand` is a [comptime](#comptime)-known integer, the return type is `comptime_int`. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.\n\nIf `operand` is zero, `@clz` returns the bit width of integer type `T`.\n\nSee also:\n\n- [@ctz](#ctz)\n- [@popCount](#popCount)\n\n### @cmpxchgStrong\n\n``` zig\n@cmpxchgStrong(comptime T: type, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T\n```\n\nThis function performs a strong atomic compare-and-exchange operation, returning `null` if the current value is not the given expected value. It's the equivalent of this code, except atomic:\n\n``` zig\nfn cmpxchgStrongButNotAtomic(comptime T: type, ptr: *T, expected_value: T, new_value: T) ?T {\n    const old_value = ptr.*;\n    if (old_value == expected_value) {\n        ptr.* = new_value;\n        return null;\n    } else {\n        return old_value;\n    }\n}\n```\n\nnot_atomic_cmpxchgStrong.zig\n\nIf you are using cmpxchg in a retry loop, [@cmpxchgWeak](#cmpxchgWeak) is the better choice, because it can be implemented more efficiently in machine instructions.\n\n`T` must be a pointer, a `bool`, a float, an integer or an enum.\n\n`@typeInfo``(``@TypeOf``(ptr)).Pointer.alignment` must be `>= ``@sizeOf``(T).`\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\nSee also:\n\n- [@atomicStore](#atomicStore)\n- [@atomicLoad](#atomicLoad)\n- [@atomicRmw](#atomicRmw)\n- [@fence](#fence)\n- [@cmpxchgWeak](#cmpxchgWeak)\n\n### @cmpxchgWeak\n\n``` zig\n@cmpxchgWeak(comptime T: type, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T\n```\n\nThis function performs a weak atomic compare-and-exchange operation, returning `null` if the current value is not the given expected value. It's the equivalent of this code, except atomic:\n\n``` zig\nfn cmpxchgWeakButNotAtomic(comptime T: type, ptr: *T, expected_value: T, new_value: T) ?T {\n    const old_value = ptr.*;\n    if (old_value == expected_value and usuallyTrueButSometimesFalse()) {\n        ptr.* = new_value;\n        return null;\n    } else {\n        return old_value;\n    }\n}\n```\n\ncmpxchgWeakButNotAtomic\n\nIf you are using cmpxchg in a retry loop, the sporadic failure will be no problem, and `cmpxchgWeak` is the better choice, because it can be implemented more efficiently in machine instructions. However if you need a stronger guarantee, use [@cmpxchgStrong](#cmpxchgStrong).\n\n`T` must be a pointer, a `bool`, a float, an integer or an enum.\n\n`@typeInfo``(``@TypeOf``(ptr)).Pointer.alignment` must be `>= ``@sizeOf``(T).`\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\nSee also:\n\n- [@atomicStore](#atomicStore)\n- [@atomicLoad](#atomicLoad)\n- [@atomicRmw](#atomicRmw)\n- [@fence](#fence)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n### @compileError\n\n``` zig\n@compileError(comptime msg: []const u8) noreturn\n```\n\nThis function, when semantically analyzed, causes a compile error with the message `msg`.\n\nThere are several ways that code avoids being semantically checked, such as using `if` or `switch` with compile time constants, and `comptime` functions.\n\n### @compileLog\n\n``` zig\n@compileLog(args: ...) void\n```\n\nThis function prints the arguments passed to it at compile-time.\n\nTo prevent accidentally leaving compile log statements in a codebase, a compilation error is added to the build, pointing to the compile log statement. This error prevents code from being generated, but does not otherwise interfere with analysis.\n\nThis function can be used to do \"printf debugging\" on compile-time executing code.\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst num1 = blk: {\n    var val1: i32 = 99;\n    @compileLog(\"comptime val1 = \", val1);\n    val1 = val1 + 1;\n    break :blk val1;\n};\n\ntest \"main\" {\n    @compileLog(\"comptime in main\");\n\n    print(\"Runtime in main, num1 = {}.\\n\", .{num1});\n}\n```\n\ntest_compileLog_builtin.zig\n\n    $ zig test test_compileLog_builtin.zig\n    doc/langref/test_compileLog_builtin.zig:11:5: error: found compile log statement\n        @compileLog(\"comptime in main\");\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_compileLog_builtin.zig:5:5: note: also here\n        @compileLog(\"comptime val1 = \", val1);\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Compile Log Output:\n    @as(*const [16:0]u8, \"comptime in main\")\n    @as(*const [16:0]u8, \"comptime val1 = \"), @as(i32, 99)\n\nShell\n\n### @constCast\n\n``` zig\n@constCast(value: anytype) DestType\n```\n\nRemove `const` qualifier from a pointer.\n\n### @ctz\n\n``` zig\n@ctz(operand: anytype) anytype\n```\n\n`@TypeOf``(operand)` must be an integer type or an integer vector type.\n\n`operand` may be an [integer](#Integers) or [vector](#Vectors).\n\nCounts the number of least-significant (trailing in a big-endian sense) zeroes in an integer - \"count trailing zeroes\".\n\nIf `operand` is a [comptime](#comptime)-known integer, the return type is `comptime_int`. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.\n\nIf `operand` is zero, `@ctz` returns the bit width of integer type `T`.\n\nSee also:\n\n- [@clz](#clz)\n- [@popCount](#popCount)\n\n### @cUndef\n\n``` zig\n@cUndef(comptime name: []const u8) void\n```\n\nThis function can only occur inside `@cImport`.\n\nThis appends `#undef $name` to the `@cImport` temporary buffer.\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cImport](#cImport)\n- [@cDefine](#cDefine)\n- [@cInclude](#cInclude)\n\n### @cVaArg\n\n``` zig\n@cVaArg(operand: *std.builtin.VaList, comptime T: type) T\n```\n\nImplements the C macro `va_arg`.\n\nSee also:\n\n- [@cVaCopy](#cVaCopy)\n- [@cVaEnd](#cVaEnd)\n- [@cVaStart](#cVaStart)\n\n### @cVaCopy\n\n``` zig\n@cVaCopy(src: *std.builtin.VaList) std.builtin.VaList\n```\n\nImplements the C macro `va_copy`.\n\nSee also:\n\n- [@cVaArg](#cVaArg)\n- [@cVaEnd](#cVaEnd)\n- [@cVaStart](#cVaStart)\n\n### @cVaEnd\n\n``` zig\n@cVaEnd(src: *std.builtin.VaList) void\n```\n\nImplements the C macro `va_end`.\n\nSee also:\n\n- [@cVaArg](#cVaArg)\n- [@cVaCopy](#cVaCopy)\n- [@cVaStart](#cVaStart)\n\n### @cVaStart\n\n``` zig\n@cVaStart() std.builtin.VaList\n```\n\nImplements the C macro `va_start`. Only valid inside a variadic function.\n\nSee also:\n\n- [@cVaArg](#cVaArg)\n- [@cVaCopy](#cVaCopy)\n- [@cVaEnd](#cVaEnd)\n\n### @divExact\n\n``` zig\n@divExact(numerator: T, denominator: T) T\n```\n\nExact division. Caller guarantees `denominator != ``0` and `@divTrunc``(numerator, denominator) * denominator == numerator`.\n\n- `@divExact``(``6``, ``3``) == ``2`\n- `@divExact``(a, b) * b == a`\n\nFor a function that returns a possible error code, use `@import``(``\"std\"``).math.divExact`.\n\nSee also:\n\n- [@divTrunc](#divTrunc)\n- [@divFloor](#divFloor)\n\n### @divFloor\n\n``` zig\n@divFloor(numerator: T, denominator: T) T\n```\n\nFloored division. Rounds toward negative infinity. For unsigned integers it is the same as `numerator / denominator`. Caller guarantees `denominator != ``0` and `!(``@typeInfo``(T) == .Int ``and`` T.is_signed ``and`` numerator == std.math.minInt(T) ``and`` denominator == -``1``)`.\n\n- `@divFloor``(-``5``, ``3``) == -``2`\n- `(``@divFloor``(a, b) * b) + ``@mod``(a, b) == a`\n\nFor a function that returns a possible error code, use `@import``(``\"std\"``).math.divFloor`.\n\nSee also:\n\n- [@divTrunc](#divTrunc)\n- [@divExact](#divExact)\n\n### @divTrunc\n\n``` zig\n@divTrunc(numerator: T, denominator: T) T\n```\n\nTruncated division. Rounds toward zero. For unsigned integers it is the same as `numerator / denominator`. Caller guarantees `denominator != ``0` and `!(``@typeInfo``(T) == .Int ``and`` T.is_signed ``and`` numerator == std.math.minInt(T) ``and`` denominator == -``1``)`.\n\n- `@divTrunc``(-``5``, ``3``) == -``1`\n- `(``@divTrunc``(a, b) * b) + ``@rem``(a, b) == a`\n\nFor a function that returns a possible error code, use `@import``(``\"std\"``).math.divTrunc`.\n\nSee also:\n\n- [@divFloor](#divFloor)\n- [@divExact](#divExact)\n\n### @embedFile\n\n``` zig\n@embedFile(comptime path: []const u8) *const [N:0]u8\n```\n\nThis function returns a compile time constant pointer to null-terminated, fixed-size array with length equal to the byte count of the file given by `path`. The contents of the array are the contents of the file. This is equivalent to a [string literal](#String-Literals-and-Unicode-Code-Point-Literals) with the file contents.\n\n`path` is absolute or relative to the current file, just like `@import`.\n\nSee also:\n\n- [@import](#import)\n\n### @enumFromInt\n\n``` zig\n@enumFromInt(integer: anytype) anytype\n```\n\nConverts an integer into an [enum](#enum) value. The return type is the inferred result type.\n\nAttempting to convert an integer which represents no value in the chosen enum type invokes safety-checked [Undefined Behavior](#Undefined-Behavior).\n\nSee also:\n\n- [@intFromEnum](#intFromEnum)\n\n### @errorFromInt\n\n``` zig\n@errorFromInt(value: std.meta.Int(.unsigned, @bitSizeOf(anyerror))) anyerror\n```\n\nConverts from the integer representation of an error into [The Global Error Set](#The-Global-Error-Set) type.\n\nIt is generally recommended to avoid this cast, as the integer representation of an error is not stable across source code changes.\n\nAttempting to convert an integer that does not correspond to any error results in safety-protected [Undefined Behavior](#Undefined-Behavior).\n\nSee also:\n\n- [@intFromError](#intFromError)\n\n### @errorName\n\n``` zig\n@errorName(err: anyerror) [:0]const u8\n```\n\nThis function returns the string representation of an error. The string representation of `error``.OutOfMem` is `\"OutOfMem\"`.\n\nIf there are no calls to `@errorName` in an entire application, or all calls have a compile-time known value for `err`, then no error name table will be generated.\n\n### @errorReturnTrace\n\n``` zig\n@errorReturnTrace() ?*builtin.StackTrace\n```\n\nIf the binary is built with error return tracing, and this function is invoked in a function that calls a function with an error or error union return type, returns a stack trace object. Otherwise returns [null](#null).\n\n### @errorCast\n\n``` zig\n@errorCast(value: anytype) anytype\n```\n\nConverts an error set or error union value from one error set to another error set. The return type is the inferred result type. Attempting to convert an error which is not in the destination error set results in safety-protected [Undefined Behavior](#Undefined-Behavior).\n\n### @export\n\n``` zig\n@export(declaration, comptime options: std.builtin.ExportOptions) void\n```\n\nCreates a symbol in the output object file.\n\n`declaration` must be one of two things:\n\n- An identifier (`x`) identifying a [function](#Functions) or a [variable](#Container-Level-Variables).\n- Field access (`x.y`) looking up a [function](#Functions) or a [variable](#Container-Level-Variables).\n\nThis builtin can be called from a [comptime](#comptime) block to conditionally export symbols. When `declaration` is a function with the C calling convention and `options.linkage` is `Strong`, this is equivalent to the `export` keyword used on a function:\n\n``` zig\ncomptime {\n    @export(internalName, .{ .name = \"foo\", .linkage = .strong });\n}\n\nfn internalName() callconv(.C) void {}\n```\n\nexport_builtin.zig\n\n    $ zig build-obj export_builtin.zig\n\nShell\n\nThis is equivalent to:\n\n``` zig\nexport fn foo() void {}\n```\n\nexport_builtin_equivalent_code.zig\n\n    $ zig build-obj export_builtin_equivalent_code.zig\n\nShell\n\nNote that even when using `export`, the `@\"foo\"` syntax for [identifiers](#Identifiers) can be used to choose any string for the symbol name:\n\n``` zig\nexport fn @\"A function name that is a complete sentence.\"() void {}\n```\n\nexport_any_symbol_name.zig\n\n    $ zig build-obj export_any_symbol_name.zig\n\nShell\n\nWhen looking at the resulting object, you can see the symbol is used verbatim:\n\n``` zig\n00000000000001f0 T A function name that is a complete sentence.\n```\n\nSee also:\n\n- [Exporting a C Library](#Exporting-a-C-Library)\n\n### @extern\n\n``` zig\n@extern(T: type, comptime options: std.builtin.ExternOptions) T\n```\n\nCreates a reference to an external symbol in the output object file. T must be a pointer type.\n\nSee also:\n\n- [@export](#export)\n\n### @fence\n\n``` zig\n@fence(order: AtomicOrder) void\n```\n\nThe `fence` function is used to introduce happens-before edges between operations.\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\nSee also:\n\n- [@atomicStore](#atomicStore)\n- [@atomicLoad](#atomicLoad)\n- [@atomicRmw](#atomicRmw)\n- [@cmpxchgWeak](#cmpxchgWeak)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n### @field\n\n``` zig\n@field(lhs: anytype, comptime field_name: []const u8) (field)\n```\n\nPerforms field access by a compile-time string. Works on both fields and declarations.\n\n``` zig\nconst std = @import(\"std\");\n\nconst Point = struct {\n    x: u32,\n    y: u32,\n\n    pub var z: u32 = 1;\n};\n\ntest \"field access by string\" {\n    const expect = std.testing.expect;\n    var p = Point{ .x = 0, .y = 0 };\n\n    @field(p, \"x\") = 4;\n    @field(p, \"y\") = @field(p, \"x\") + 1;\n\n    try expect(@field(p, \"x\") == 4);\n    try expect(@field(p, \"y\") == 5);\n}\n\ntest \"decl access by string\" {\n    const expect = std.testing.expect;\n\n    try expect(@field(Point, \"z\") == 1);\n\n    @field(Point, \"z\") = 2;\n    try expect(@field(Point, \"z\") == 2);\n}\n```\n\ntest_field_builtin.zig\n\n    $ zig test test_field_builtin.zig\n    1/2 test_field_builtin.test.field access by string...OK\n    2/2 test_field_builtin.test.decl access by string...OK\n    All 2 tests passed.\n\nShell\n\n### @fieldParentPtr\n\n``` zig\n@fieldParentPtr(comptime field_name: []const u8, field_ptr: *T) anytype\n```\n\nGiven a pointer to a field, returns the base pointer of a struct.\n\n### @floatCast\n\n``` zig\n@floatCast(value: anytype) anytype\n```\n\nConvert from one float type to another. This cast is safe, but may cause the numeric value to lose precision. The return type is the inferred result type.\n\n### @floatFromInt\n\n``` zig\n@floatFromInt(int: anytype) anytype\n```\n\nConverts an integer to the closest floating point representation. The return type is the inferred result type. To convert the other way, use [@intFromFloat](#intFromFloat). This operation is legal for all values of all integer types.\n\n### @frameAddress\n\n``` zig\n@frameAddress() usize\n```\n\nThis function returns the base pointer of the current stack frame.\n\nThe implications of this are target-specific and not consistent across all platforms. The frame address may not be available in release mode due to aggressive optimizations.\n\nThis function is only valid within function scope.\n\n### @hasDecl\n\n``` zig\n@hasDecl(comptime Container: type, comptime name: []const u8) bool\n```\n\nReturns whether or not a [container](#Containers) has a declaration matching `name`.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Foo = struct {\n    nope: i32,\n\n    pub var blah = \"xxx\";\n    const hi = 1;\n};\n\ntest \"@hasDecl\" {\n    try expect(@hasDecl(Foo, \"blah\"));\n\n    // Even though `hi` is private, @hasDecl returns true because this test is\n    // in the same file scope as Foo. It would return false if Foo was declared\n    // in a different file.\n    try expect(@hasDecl(Foo, \"hi\"));\n\n    // @hasDecl is for declarations; not fields.\n    try expect(!@hasDecl(Foo, \"nope\"));\n    try expect(!@hasDecl(Foo, \"nope1234\"));\n}\n```\n\ntest_hasDecl_builtin.zig\n\n    $ zig test test_hasDecl_builtin.zig\n    1/1 test_hasDecl_builtin.test.@hasDecl...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [@hasField](#hasField)\n\n### @hasField\n\n``` zig\n@hasField(comptime Container: type, comptime name: []const u8) bool\n```\n\nReturns whether the field name of a struct, union, or enum exists.\n\nThe result is a compile time constant.\n\nIt does not include functions, variables, or constants.\n\nSee also:\n\n- [@hasDecl](#hasDecl)\n\n### @import\n\n``` zig\n@import(comptime path: []const u8) type\n```\n\nThis function finds a zig file corresponding to `path` and adds it to the build, if it is not already added.\n\nZig source files are implicitly structs, with a name equal to the file's basename with the extension truncated. `@import` returns the struct type corresponding to the file.\n\nDeclarations which have the `pub` keyword may be referenced from a different source file than the one they are declared in.\n\n`path` can be a relative path or it can be the name of a package. If it is a relative path, it is relative to the file that contains the `@import` function call.\n\nThe following packages are always available:\n\n- `@import``(``\"std\"``)` - Zig Standard Library\n- `@import``(``\"builtin\"``)` - Target-specific information The command `zig build-exe --show-builtin` outputs the source to stdout for reference.\n- `@import``(``\"root\"``)` - Root source file This is usually `src/main.zig` but depends on what file is built.\n\nSee also:\n\n- [Compile Variables](#Compile-Variables)\n- [@embedFile](#embedFile)\n\n### @inComptime\n\n``` zig\n@inComptime() bool\n```\n\nReturns whether the builtin was run in a `comptime` context. The result is a compile-time constant.\n\nThis can be used to provide alternative, comptime-friendly implementations of functions. It should not be used, for instance, to exclude certain functions from being evaluated at comptime.\n\nSee also:\n\n- [comptime](#comptime)\n\n### @intCast\n\n``` zig\n@intCast(int: anytype) anytype\n```\n\nConverts an integer to another integer while keeping the same numerical value. The return type is the inferred result type. Attempting to convert a number which is out of range of the destination type results in safety-protected [Undefined Behavior](#Undefined-Behavior).\n\n``` zig\ntest \"integer cast panic\" {\n    var a: u16 = 0xabcd; // runtime-known\n    _ = &a;\n    const b: u8 = @intCast(a);\n    _ = b;\n}\n```\n\ntest_intCast_builtin.zig\n\n    $ zig test test_intCast_builtin.zig\n    1/1 test_intCast_builtin.test.integer cast panic...thread 3573820 panic: integer cast truncated bits\n    /home/andy/src/zig/doc/langref/test_intCast_builtin.zig:4:19: 0x103ce6b in test.integer cast panic (test)\n        const b: u8 = @intCast(a);\n                      ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048290 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e24b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d389 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cef1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/a3b6539437d55800e891e62090700351/test\n\nShell\n\nTo truncate the significant bits of a number out of range of the destination type, use [@truncate](#truncate).\n\nIf `T` is `comptime_int`, then this is semantically equivalent to [Type Coercion](#Type-Coercion).\n\n### @intFromBool\n\n``` zig\n@intFromBool(value: bool) u1\n```\n\nConverts `true` to `@as``(``u1``, ``1``)` and `false` to `@as``(``u1``, ``0``)`.\n\n### @intFromEnum\n\n``` zig\n@intFromEnum(enum_or_tagged_union: anytype) anytype\n```\n\nConverts an enumeration value into its integer tag type. When a tagged union is passed, the tag value is used as the enumeration value.\n\nIf there is only one possible enum value, the result is a `comptime_int` known at [comptime](#comptime).\n\nSee also:\n\n- [@enumFromInt](#enumFromInt)\n\n### @intFromError\n\n``` zig\n@intFromError(err: anytype) std.meta.Int(.unsigned, @bitSizeOf(anyerror))\n```\n\nSupports the following types:\n\n- [The Global Error Set](#The-Global-Error-Set)\n- [Error Set Type](#Error-Set-Type)\n- [Error Union Type](#Error-Union-Type)\n\nConverts an error to the integer representation of an error.\n\nIt is generally recommended to avoid this cast, as the integer representation of an error is not stable across source code changes.\n\nSee also:\n\n- [@errorFromInt](#errorFromInt)\n\n### @intFromFloat\n\n``` zig\n@intFromFloat(float: anytype) anytype\n```\n\nConverts the integer part of a floating point number to the inferred result type.\n\nIf the integer part of the floating point number cannot fit in the destination type, it invokes safety-checked [Undefined Behavior](#Undefined-Behavior).\n\nSee also:\n\n- [@floatFromInt](#floatFromInt)\n\n### @intFromPtr\n\n``` zig\n@intFromPtr(value: anytype) usize\n```\n\nConverts `value` to a `usize` which is the address of the pointer. `value` can be `*T` or `?*T`.\n\nTo convert the other way, use [@ptrFromInt](#ptrFromInt)\n\n### @max\n\n``` zig\n@max(a: T, b: T) T\n```\n\nReturns the maximum value of `a` and `b`. This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise.\n\nNaNs are handled as follows: if one of the operands of a (pairwise) operation is NaN, the other operand is returned. If both operands are NaN, NaN is returned.\n\nSee also:\n\n- [@min](#min)\n- [Vectors](#Vectors)\n\n### @memcpy\n\n``` zig\n@memcpy(noalias dest, noalias source) void\n```\n\nThis function copies bytes from one region of memory to another.\n\n`dest` must be a mutable slice, a mutable pointer to an array, or a mutable many-item [pointer](#Pointers). It may have any alignment, and it may have any element type.\n\n`source` must be a slice, a pointer to an array, or a many-item [pointer](#Pointers). It may have any alignment, and it may have any element type.\n\nThe `source` element type must support [Type Coercion](#Type-Coercion) into the `dest` element type. The element types may have different ABI size, however, that may incur a performance penalty.\n\nSimilar to [for](#for) loops, at least one of `source` and `dest` must provide a length, and if two lengths are provided, they must be equal.\n\nFinally, the two memory regions must not overlap.\n\n### @memset\n\n``` zig\n@memset(dest, elem) void\n```\n\nThis function sets all the elements of a memory region to `elem`.\n\n`dest` must be a mutable slice or a mutable pointer to an array. It may have any alignment, and it may have any element type.\n\n`elem` is coerced to the element type of `dest`.\n\nFor securely zeroing out sensitive contents from memory, you should use `std.crypto.utils.secureZero`\n\n### @min\n\n``` zig\n@min(a: T, b: T) T\n```\n\nReturns the minimum value of `a` and `b`. This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise.\n\nNaNs are handled as follows: if one of the operands of a (pairwise) operation is NaN, the other operand is returned. If both operands are NaN, NaN is returned.\n\nSee also:\n\n- [@max](#max)\n- [Vectors](#Vectors)\n\n### @wasmMemorySize\n\n``` zig\n@wasmMemorySize(index: u32) usize\n```\n\nThis function returns the size of the Wasm memory identified by `index` as an unsigned value in units of Wasm pages. Note that each Wasm page is 64KB in size.\n\nThis function is a low level intrinsic with no safety mechanisms usually useful for allocator designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use something like `@import``(``\"std\"``).heap.WasmPageAllocator`.\n\nSee also:\n\n- [@wasmMemoryGrow](#wasmMemoryGrow)\n\n### @wasmMemoryGrow\n\n``` zig\n@wasmMemoryGrow(index: u32, delta: usize) isize\n```\n\nThis function increases the size of the Wasm memory identified by `index` by `delta` in units of unsigned number of Wasm pages. Note that each Wasm page is 64KB in size. On success, returns previous memory size; on failure, if the allocation fails, returns -1.\n\nThis function is a low level intrinsic with no safety mechanisms usually useful for allocator designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use something like `@import``(``\"std\"``).heap.WasmPageAllocator`.\n\n``` zig\nconst std = @import(\"std\");\nconst native_arch = @import(\"builtin\").target.cpu.arch;\nconst expect = std.testing.expect;\n\ntest \"@wasmMemoryGrow\" {\n    if (native_arch != .wasm32) return error.SkipZigTest;\n\n    const prev = @wasmMemorySize(0);\n    try expect(prev == @wasmMemoryGrow(0, 1));\n    try expect(prev + 1 == @wasmMemorySize(0));\n}\n```\n\ntest_wasmMemoryGrow_builtin.zig\n\n    $ zig test test_wasmMemoryGrow_builtin.zig\n    1/1 test_wasmMemoryGrow_builtin.test.@wasmMemoryGrow...SKIP\n    0 passed; 1 skipped; 0 failed.\n\nShell\n\nSee also:\n\n- [@wasmMemorySize](#wasmMemorySize)\n\n### @mod\n\n``` zig\n@mod(numerator: T, denominator: T) T\n```\n\nModulus division. For unsigned integers this is the same as `numerator % denominator`. Caller guarantees `denominator > ``0`, otherwise the operation will result in a [Remainder Division by Zero](#Remainder-Division-by-Zero) when runtime safety checks are enabled.\n\n- `@mod``(-``5``, ``3``) == ``1`\n- `(``@divFloor``(a, b) * b) + ``@mod``(a, b) == a`\n\nFor a function that returns an error code, see `@import``(``\"std\"``).math.mod`.\n\nSee also:\n\n- [@rem](#rem)\n\n### @mulWithOverflow\n\n``` zig\n@mulWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }\n```\n\nPerforms `a * b` and returns a tuple with the result and a possible overflow bit.\n\n### @panic\n\n``` zig\n@panic(message: []const u8) noreturn\n```\n\nInvokes the panic handler function. By default the panic handler function calls the public `panic` function exposed in the root source file, or if there is not one specified, the `std.builtin.default_panic` function from `std/builtin.zig`.\n\nGenerally it is better to use `@import``(``\"std\"``).debug.panic`. However, `@panic` can be useful for 2 scenarios:\n\n- From library code, calling the programmer's panic function if they exposed one in the root source file.\n- When mixing C and Zig code, calling the canonical panic implementation across multiple .o files.\n\nSee also:\n\n- [Root Source File](#Root-Source-File)\n\n### @popCount\n\n``` zig\n@popCount(operand: anytype) anytype\n```\n\n`@TypeOf``(operand)` must be an integer type.\n\n`operand` may be an [integer](#Integers) or [vector](#Vectors).\n\nCounts the number of bits set in an integer - \"population count\".\n\nIf `operand` is a [comptime](#comptime)-known integer, the return type is `comptime_int`. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.\n\nSee also:\n\n- [@ctz](#ctz)\n- [@clz](#clz)\n\n### @prefetch\n\n``` zig\n@prefetch(ptr: anytype, comptime options: PrefetchOptions) void\n```\n\nThis builtin tells the compiler to emit a prefetch instruction if supported by the target CPU. If the target CPU does not support the requested prefetch instruction, this builtin is a no-op. This function has no effect on the behavior of the program, only on the performance characteristics.\n\nThe `ptr` argument may be any pointer type and determines the memory address to prefetch. This function does not dereference the pointer, it is perfectly legal to pass a pointer to invalid memory to this function and no illegal behavior will result.\n\n`PrefetchOptions` can be found with `@import``(``\"std\"``).builtin.PrefetchOptions`.\n\n### @ptrCast\n\n``` zig\n@ptrCast(value: anytype) anytype\n```\n\nConverts a pointer of one type to a pointer of another type. The return type is the inferred result type.\n\n[Optional Pointers](#Optional-Pointers) are allowed. Casting an optional pointer which is [null](#null) to a non-optional pointer invokes safety-checked [Undefined Behavior](#Undefined-Behavior).\n\n`@ptrCast` cannot be used for:\n\n- Removing `const` qualifier, use [@constCast](#constCast).\n- Removing `volatile` qualifier, use [@volatileCast](#volatileCast).\n- Changing pointer address space, use [@addrSpaceCast](#addrSpaceCast).\n- Increasing pointer alignment, use [@alignCast](#alignCast).\n- Casting a non-slice pointer to a slice, use slicing syntax `ptr[start..end]`.\n\n### @ptrFromInt\n\n``` zig\n@ptrFromInt(address: usize) anytype\n```\n\nConverts an integer to a [pointer](#Pointers). The return type is the inferred result type. To convert the other way, use [@intFromPtr](#intFromPtr). Casting an address of 0 to a destination type which in not [optional](#Optional-Pointers) and does not have the `allowzero` attribute will result in a [Pointer Cast Invalid Null](#Pointer-Cast-Invalid-Null) panic when runtime safety checks are enabled.\n\nIf the destination pointer type does not allow address zero and `address` is zero, this invokes safety-checked [Undefined Behavior](#Undefined-Behavior).\n\n### @rem\n\n``` zig\n@rem(numerator: T, denominator: T) T\n```\n\nRemainder division. For unsigned integers this is the same as `numerator % denominator`. Caller guarantees `denominator > ``0`, otherwise the operation will result in a [Remainder Division by Zero](#Remainder-Division-by-Zero) when runtime safety checks are enabled.\n\n- `@rem``(-``5``, ``3``) == -``2`\n- `(``@divTrunc``(a, b) * b) + ``@rem``(a, b) == a`\n\nFor a function that returns an error code, see `@import``(``\"std\"``).math.rem`.\n\nSee also:\n\n- [@mod](#mod)\n\n### @returnAddress\n\n``` zig\n@returnAddress() usize\n```\n\nThis function returns the address of the next machine code instruction that will be executed when the current function returns.\n\nThe implications of this are target-specific and not consistent across all platforms.\n\nThis function is only valid within function scope. If the function gets inlined into a calling function, the returned address will apply to the calling function.\n\n### @select\n\n``` zig\n@select(comptime T: type, pred: @Vector(len, bool), a: @Vector(len, T), b: @Vector(len, T)) @Vector(len, T)\n```\n\nSelects values element-wise from `a` or `b` based on `pred`. If `pred[i]` is `true`, the corresponding element in the result will be `a[i]` and otherwise `b[i]`.\n\nSee also:\n\n- [Vectors](#Vectors)\n\n### @setAlignStack\n\n``` zig\n@setAlignStack(comptime alignment: u29) void\n```\n\nEnsures that a function will have a stack alignment of at least `alignment` bytes.\n\n### @setCold\n\n``` zig\n@setCold(comptime is_cold: bool) void\n```\n\nTells the optimizer that the current function is (or is not) rarely called. This function is only valid within function scope.\n\n### @setEvalBranchQuota\n\n``` zig\n@setEvalBranchQuota(comptime new_quota: u32) void\n```\n\nIncrease the maximum number of backwards branches that compile-time code execution can use before giving up and making a compile error.\n\nIf the `new_quota` is smaller than the default quota (`1000`) or a previously explicitly set quota, it is ignored.\n\nExample:\n\n``` zig\ntest \"foo\" {\n    comptime {\n        var i = 0;\n        while (i < 1001) : (i += 1) {}\n    }\n}\n```\n\ntest_without_setEvalBranchQuota_builtin.zig\n\n    $ zig test test_without_setEvalBranchQuota_builtin.zig\n    doc/langref/test_without_setEvalBranchQuota_builtin.zig:4:9: error: evaluation exceeded 1000 backwards branches\n            while (i < 1001) : (i += 1) {}\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_without_setEvalBranchQuota_builtin.zig:4:9: note: use @setEvalBranchQuota() to raise the branch limit from 1000\n\nShell\n\nNow we use `@setEvalBranchQuota`:\n\n``` zig\ntest \"foo\" {\n    comptime {\n        @setEvalBranchQuota(1001);\n        var i = 0;\n        while (i < 1001) : (i += 1) {}\n    }\n}\n```\n\ntest_setEvalBranchQuota_builtin.zig\n\n    $ zig test test_setEvalBranchQuota_builtin.zig\n    1/1 test_setEvalBranchQuota_builtin.test.foo...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [comptime](#comptime)\n\n### @setFloatMode\n\n``` zig\n@setFloatMode(comptime mode: FloatMode) void\n```\n\nChanges the current scope's rules about how floating point operations are defined.\n\n- `Strict` (default) - Floating point operations follow strict IEEE compliance.\n- `Optimized` - Floating point operations may do all of the following:\n  - Assume the arguments and result are not NaN. Optimizations are required to retain defined behavior over NaNs, but the value of the result is undefined.\n  - Assume the arguments and result are not +/-Inf. Optimizations are required to retain defined behavior over +/-Inf, but the value of the result is undefined.\n  - Treat the sign of a zero argument or result as insignificant.\n  - Use the reciprocal of an argument rather than perform division.\n  - Perform floating-point contraction (e.g. fusing a multiply followed by an addition into a fused multiply-add).\n  - Perform algebraically equivalent transformations that may change results in floating point (e.g. reassociate).\n\n  This is equivalent to `-ffast-math` in GCC.\n\nThe floating point mode is inherited by child scopes, and can be overridden in any scope. You can set the floating point mode in a struct or module scope by using a comptime block.\n\n`FloatMode` can be found with `@import``(``\"std\"``).builtin.FloatMode`.\n\nSee also:\n\n- [Floating Point Operations](#Floating-Point-Operations)\n\n### @setRuntimeSafety\n\n``` zig\n@setRuntimeSafety(comptime safety_on: bool) void\n```\n\nSets whether runtime safety checks are enabled for the scope that contains the function call.\n\n``` zig\ntest \"@setRuntimeSafety\" {\n    // The builtin applies to the scope that it is called in. So here, integer overflow\n    // will not be caught in ReleaseFast and ReleaseSmall modes:\n    // var x: u8 = 255;\n    // x += 1; // undefined behavior in ReleaseFast/ReleaseSmall modes.\n    {\n        // However this block has safety enabled, so safety checks happen here,\n        // even in ReleaseFast and ReleaseSmall modes.\n        @setRuntimeSafety(true);\n        var x: u8 = 255;\n        x += 1;\n\n        {\n            // The value can be overridden at any scope. So here integer overflow\n            // would not be caught in any build mode.\n            @setRuntimeSafety(false);\n            // var x: u8 = 255;\n            // x += 1; // undefined behavior in all build modes.\n        }\n    }\n}\n```\n\ntest_setRuntimeSafety_builtin.zig\n\n    $ zig test test_setRuntimeSafety_builtin.zig -OReleaseFast\n    1/1 test_setRuntimeSafety_builtin.test.@setRuntimeSafety...thread 3579742 panic: integer overflow\n    /home/andy/src/zig/doc/langref/test_setRuntimeSafety_builtin.zig:11:11: 0x100ae54 in test.@setRuntimeSafety (test)\n            x += 1;\n              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x100c9b0 in main (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x100af44 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x100ae71 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/7c74a2939d84ddd0f45519d7a9f1c0f7/test\n\nShell\n\nNote: it is [planned](https://github.com/ziglang/zig/issues/978) to replace `@setRuntimeSafety` with `@optimizeFor`\n\n### @shlExact\n\n``` zig\n@shlExact(value: T, shift_amt: Log2T) T\n```\n\nPerforms the left shift operation (`<<`). For unsigned integers, the result is [undefined](#undefined) if any 1 bits are shifted out. For signed integers, the result is [undefined](#undefined) if any bits that disagree with the resultant sign bit are shifted out.\n\nThe type of `shift_amt` is an unsigned integer with `log2(``@typeInfo``(T).Int.bits)` bits. This is because `shift_amt >= ``@typeInfo``(T).Int.bits` is undefined behavior.\n\n`comptime_int` is modeled as an integer with an infinite number of bits, meaning that in such case, `@shlExact` always produces a result and cannot produce a compile error.\n\nSee also:\n\n- [@shrExact](#shrExact)\n- [@shlWithOverflow](#shlWithOverflow)\n\n### @shlWithOverflow\n\n``` zig\n@shlWithOverflow(a: anytype, shift_amt: Log2T) struct { @TypeOf(a), u1 }\n```\n\nPerforms `a << b` and returns a tuple with the result and a possible overflow bit.\n\nThe type of `shift_amt` is an unsigned integer with `log2(``@typeInfo``(``@TypeOf``(a)).Int.bits)` bits. This is because `shift_amt >= ``@typeInfo``(``@TypeOf``(a)).Int.bits` is undefined behavior.\n\nSee also:\n\n- [@shlExact](#shlExact)\n- [@shrExact](#shrExact)\n\n### @shrExact\n\n``` zig\n@shrExact(value: T, shift_amt: Log2T) T\n```\n\nPerforms the right shift operation (`>>`). Caller guarantees that the shift will not shift any 1 bits out.\n\nThe type of `shift_amt` is an unsigned integer with `log2(``@typeInfo``(T).Int.bits)` bits. This is because `shift_amt >= ``@typeInfo``(T).Int.bits` is undefined behavior.\n\nSee also:\n\n- [@shlExact](#shlExact)\n- [@shlWithOverflow](#shlWithOverflow)\n\n### @shuffle\n\n``` zig\n@shuffle(comptime E: type, a: @Vector(a_len, E), b: @Vector(b_len, E), comptime mask: @Vector(mask_len, i32)) @Vector(mask_len, E)\n```\n\nConstructs a new [vector](#Vectors) by selecting elements from `a` and `b` based on `mask`.\n\nEach element in `mask` selects an element from either `a` or `b`. Positive numbers select from `a` starting at 0. Negative values select from `b`, starting at `-``1` and going down. It is recommended to use the `~` operator for indexes from `b` so that both indexes can start from `0` (i.e. `~``@as``(``i32``, ``0``)` is `-``1`).\n\nFor each element of `mask`, if it or the selected value from `a` or `b` is `undefined`, then the resulting element is `undefined`.\n\n`a_len` and `b_len` may differ in length. Out-of-bounds element indexes in `mask` result in compile errors.\n\nIf `a` or `b` is `undefined`, it is equivalent to a vector of all `undefined` with the same length as the other vector. If both vectors are `undefined`, `@shuffle` returns a vector with all elements `undefined`.\n\n`E` must be an [integer](#Integers), [float](#Floats), [pointer](#Pointers), or `bool`. The mask may be any vector length, and its length determines the result length.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"vector @shuffle\" {\n    const a = @Vector(7, u8){ 'o', 'l', 'h', 'e', 'r', 'z', 'w' };\n    const b = @Vector(4, u8){ 'w', 'd', '!', 'x' };\n\n    // To shuffle within a single vector, pass undefined as the second argument.\n    // Notice that we can re-order, duplicate, or omit elements of the input vector\n    const mask1 = @Vector(5, i32){ 2, 3, 1, 1, 0 };\n    const res1: @Vector(5, u8) = @shuffle(u8, a, undefined, mask1);\n    try expect(std.mem.eql(u8, &@as([5]u8, res1), \"hello\"));\n\n    // Combining two vectors\n    const mask2 = @Vector(6, i32){ -1, 0, 4, 1, -2, -3 };\n    const res2: @Vector(6, u8) = @shuffle(u8, a, b, mask2);\n    try expect(std.mem.eql(u8, &@as([6]u8, res2), \"world!\"));\n}\n```\n\ntest_shuffle_builtin.zig\n\n    $ zig test test_shuffle_builtin.zig\n    1/1 test_shuffle_builtin.test.vector @shuffle...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [Vectors](#Vectors)\n\n### @sizeOf\n\n``` zig\n@sizeOf(comptime T: type) comptime_int\n```\n\nThis function returns the number of bytes it takes to store `T` in memory. The result is a target-specific compile time constant.\n\nThis size may contain padding bytes. If there were two consecutive T in memory, the padding would be the offset in bytes between element at index 0 and the element at index 1. For [integer](#Integers), consider whether you want to use `@sizeOf``(T)` or `@typeInfo``(T).Int.bits`.\n\nThis function measures the size at runtime. For types that are disallowed at runtime, such as `comptime_int` and `type`, the result is `0`.\n\nSee also:\n\n- [@bitSizeOf](#bitSizeOf)\n- [@typeInfo](#typeInfo)\n\n### @splat\n\n``` zig\n@splat(scalar: anytype) anytype\n```\n\nProduces a vector where each element is the value `scalar`. The return type and thus the length of the vector is inferred.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"vector @splat\" {\n    const scalar: u32 = 5;\n    const result: @Vector(4, u32) = @splat(scalar);\n    try expect(std.mem.eql(u32, &@as([4]u32, result), &[_]u32{ 5, 5, 5, 5 }));\n}\n```\n\ntest_splat_builtin.zig\n\n    $ zig test test_splat_builtin.zig\n    1/1 test_splat_builtin.test.vector @splat...OK\n    All 1 tests passed.\n\nShell\n\n`scalar` must be an [integer](#Integers), [bool](#Primitive-Types), [float](#Floats), or [pointer](#Pointers).\n\nSee also:\n\n- [Vectors](#Vectors)\n- [@shuffle](#shuffle)\n\n### @reduce\n\n``` zig\n@reduce(comptime op: std.builtin.ReduceOp, value: anytype) E\n```\n\nTransforms a [vector](#Vectors) into a scalar value (of type `E`) by performing a sequential horizontal reduction of its elements using the specified operator `op`.\n\nNot every operator is available for every vector element type:\n\n- Every operator is available for [integer](#Integers) vectors.\n- `.And`, `.Or`, `.Xor` are additionally available for `bool` vectors,\n- `.Min`, `.Max`, `.Add`, `.Mul` are additionally available for [floating point](#Floats) vectors,\n\nNote that `.Add` and `.Mul` reductions on integral types are wrapping; when applied on floating point types the operation associativity is preserved, unless the float mode is set to `Optimized`.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"vector @reduce\" {\n    const V = @Vector(4, i32);\n    const value = V{ 1, -1, 1, -1 };\n    const result = value > @as(V, @splat(0));\n    // result is { true, false, true, false };\n    try comptime expect(@TypeOf(result) == @Vector(4, bool));\n    const is_all_true = @reduce(.And, result);\n    try comptime expect(@TypeOf(is_all_true) == bool);\n    try expect(is_all_true == false);\n}\n```\n\ntest_reduce_builtin.zig\n\n    $ zig test test_reduce_builtin.zig\n    1/1 test_reduce_builtin.test.vector @reduce...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [Vectors](#Vectors)\n- [@setFloatMode](#setFloatMode)\n\n### @src\n\n``` zig\n@src() std.builtin.SourceLocation\n```\n\nReturns a `SourceLocation` struct representing the function's name and location in the source code. This must be called in a function.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"@src\" {\n    try doTheTest();\n}\n\nfn doTheTest() !void {\n    const src = @src();\n\n    try expect(src.line == 9);\n    try expect(src.column == 17);\n    try expect(std.mem.endsWith(u8, src.fn_name, \"doTheTest\"));\n    try expect(std.mem.endsWith(u8, src.file, \"test_src_builtin.zig\"));\n}\n```\n\ntest_src_builtin.zig\n\n    $ zig test test_src_builtin.zig\n    1/1 test_src_builtin.test.@src...OK\n    All 1 tests passed.\n\nShell\n\n### @sqrt\n\n``` zig\n@sqrt(value: anytype) @TypeOf(value)\n```\n\nPerforms the square root of a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @sin\n\n``` zig\n@sin(value: anytype) @TypeOf(value)\n```\n\nSine trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @cos\n\n``` zig\n@cos(value: anytype) @TypeOf(value)\n```\n\nCosine trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @tan\n\n``` zig\n@tan(value: anytype) @TypeOf(value)\n```\n\nTangent trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @exp\n\n``` zig\n@exp(value: anytype) @TypeOf(value)\n```\n\nBase-e exponential function on a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @exp2\n\n``` zig\n@exp2(value: anytype) @TypeOf(value)\n```\n\nBase-2 exponential function on a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @log\n\n``` zig\n@log(value: anytype) @TypeOf(value)\n```\n\nReturns the natural logarithm of a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @log2\n\n``` zig\n@log2(value: anytype) @TypeOf(value)\n```\n\nReturns the logarithm to the base 2 of a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @log10\n\n``` zig\n@log10(value: anytype) @TypeOf(value)\n```\n\nReturns the logarithm to the base 10 of a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @abs\n\n``` zig\n@abs(value: anytype) anytype\n```\n\nReturns the absolute value of an integer or a floating point number. Uses a dedicated hardware instruction when available. The return type is always an unsigned integer of the same bit width as the operand if the operand is an integer. Unsigned integer operands are supported. The builtin cannot overflow for signed integer operands.\n\nSupports [Floats](#Floats), [Integers](#Integers) and [Vectors](#Vectors) of floats or integers.\n\n### @floor\n\n``` zig\n@floor(value: anytype) @TypeOf(value)\n```\n\nReturns the largest integral value not greater than the given floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @ceil\n\n``` zig\n@ceil(value: anytype) @TypeOf(value)\n```\n\nReturns the smallest integral value not less than the given floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @trunc\n\n``` zig\n@trunc(value: anytype) @TypeOf(value)\n```\n\nRounds the given floating point number to an integer, towards zero. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @round\n\n``` zig\n@round(value: anytype) @TypeOf(value)\n```\n\nRounds the given floating point number to an integer, away from zero. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @subWithOverflow\n\n``` zig\n@subWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }\n```\n\nPerforms `a - b` and returns a tuple with the result and a possible overflow bit.\n\n### @tagName\n\n``` zig\n@tagName(value: anytype) [:0]const u8\n```\n\nConverts an enum value or union value to a string literal representing the name.\n\nIf the enum is non-exhaustive and the tag value does not map to a name, it invokes safety-checked [Undefined Behavior](#Undefined-Behavior).\n\n### @This\n\n``` zig\n@This() type\n```\n\nReturns the innermost struct, enum, or union that this function call is inside. This can be useful for an anonymous struct that needs to refer to itself:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"@This()\" {\n    var items = [_]i32{ 1, 2, 3, 4 };\n    const list = List(i32){ .items = items[0..] };\n    try expect(list.length() == 4);\n}\n\nfn List(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        items: []T,\n\n        fn length(self: Self) usize {\n            return self.items.len;\n        }\n    };\n}\n```\n\ntest_this_builtin.zig\n\n    $ zig test test_this_builtin.zig\n    1/1 test_this_builtin.test.@This()...OK\n    All 1 tests passed.\n\nShell\n\nWhen `@This``()` is used at file scope, it returns a reference to the struct that corresponds to the current file.\n\n### @trap\n\n``` zig\n@trap() noreturn\n```\n\nThis function inserts a platform-specific trap/jam instruction which can be used to exit the program abnormally. This may be implemented by explicitly emitting an invalid instruction which may cause an illegal instruction exception of some sort. Unlike for `@breakpoint``()`, execution does not continue after this point.\n\nOutside function scope, this builtin causes a compile error.\n\nSee also:\n\n- [@breakpoint](#breakpoint)\n\n### @truncate\n\n``` zig\n@truncate(integer: anytype) anytype\n```\n\nThis function truncates bits from an integer type, resulting in a smaller or same-sized integer type. The return type is the inferred result type.\n\nThis function always truncates the significant bits of the integer, regardless of endianness on the target platform.\n\nCalling `@truncate` on a number out of range of the destination type is well defined and working code:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"integer truncation\" {\n    const a: u16 = 0xabcd;\n    const b: u8 = @truncate(a);\n    try expect(b == 0xcd);\n}\n```\n\ntest_truncate_builtin.zig\n\n    $ zig test test_truncate_builtin.zig\n    1/1 test_truncate_builtin.test.integer truncation...OK\n    All 1 tests passed.\n\nShell\n\nUse [@intCast](#intCast) to convert numbers guaranteed to fit the destination type.\n\n### @Type\n\n``` zig\n@Type(comptime info: std.builtin.Type) type\n```\n\nThis function is the inverse of [@typeInfo](#typeInfo). It reifies type information into a `type`.\n\nIt is available for the following types:\n\n- `type`\n- `noreturn`\n- `void`\n- `bool`\n- [Integers](#Integers) - The maximum bit count for an integer type is `65535`.\n- [Floats](#Floats)\n- [Pointers](#Pointers)\n- `comptime_int`\n- `comptime_float`\n- `@TypeOf``(``undefined``)`\n- `@TypeOf``(``null``)`\n- [Arrays](#Arrays)\n- [Optionals](#Optionals)\n- [Error Set Type](#Error-Set-Type)\n- [Error Union Type](#Error-Union-Type)\n- [Vectors](#Vectors)\n- [opaque](#opaque)\n- `anyframe`\n- [struct](#struct)\n- [enum](#enum)\n- [Enum Literals](#Enum-Literals)\n- [union](#union)\n- [Functions](#Functions)\n\n### @typeInfo\n\n``` zig\n@typeInfo(comptime T: type) std.builtin.Type\n```\n\nProvides type reflection.\n\nType information of [structs](#struct), [unions](#union), [enums](#enum), and [error sets](#Error-Set-Type) has fields which are guaranteed to be in the same order as appearance in the source file.\n\nType information of [structs](#struct), [unions](#union), [enums](#enum), and [opaques](#opaque) has declarations, which are also guaranteed to be in the same order as appearance in the source file.\n\n### @typeName\n\n``` zig\n@typeName(T: type) *const [N:0]u8\n```\n\nThis function returns the string representation of a type, as an array. It is equivalent to a string literal of the type name. The returned type name is fully qualified with the parent namespace included as part of the type name with a series of dots.\n\n### @TypeOf\n\n``` zig\n@TypeOf(...) type\n```\n\n`@TypeOf` is a special builtin function that takes any (nonzero) number of expressions as parameters and returns the type of the result, using [Peer Type Resolution](#Peer-Type-Resolution).\n\nThe expressions are evaluated, however they are guaranteed to have no *runtime* side-effects:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"no runtime side effects\" {\n    var data: i32 = 0;\n    const T = @TypeOf(foo(i32, &data));\n    try comptime expect(T == i32);\n    try expect(data == 0);\n}\n\nfn foo(comptime T: type, ptr: *T) T {\n    ptr.* += 1;\n    return ptr.*;\n}\n```\n\ntest_TypeOf_builtin.zig\n\n    $ zig test test_TypeOf_builtin.zig\n    1/1 test_TypeOf_builtin.test.no runtime side effects...OK\n    All 1 tests passed.\n\nShell\n\n### @unionInit\n\n``` zig\n@unionInit(comptime Union: type, comptime active_field_name: []const u8, init_expr) Union\n```\n\nThis is the same thing as [union](#union) initialization syntax, except that the field name is a [comptime](#comptime)-known value rather than an identifier token.\n\n`@unionInit` forwards its [result location](#Result-Location-Semantics) to `init_expr`.\n\n### @Vector\n\n``` zig\n@Vector(len: comptime_int, Element: type) type\n```\n\nCreates [Vectors](#Vectors).\n\n### @volatileCast\n\n``` zig\n@volatileCast(value: anytype) DestType\n```\n\nRemove `volatile` qualifier from a pointer.\n\n### @workGroupId\n\n``` zig\n@workGroupId(comptime dimension: u32) u32\n```\n\nReturns the index of the work group in the current kernel invocation in dimension `dimension`.\n\n### @workGroupSize\n\n``` zig\n@workGroupSize(comptime dimension: u32) u32\n```\n\nReturns the number of work items that a work group has in dimension `dimension`.\n\n### @workItemId\n\n``` zig\n@workItemId(comptime dimension: u32) u32\n```\n\nReturns the index of the work item in the work group in dimension `dimension`. This function returns values between `0` (inclusive) and `@workGroupSize``(dimension)` (exclusive).\n\n## Build Mode\n\nZig has four build modes:\n\n- [Debug](#Debug) (default)\n- [ReleaseFast](#ReleaseFast)\n- [ReleaseSafe](#ReleaseSafe)\n- [ReleaseSmall](#ReleaseSmall)\n\nTo add standard build options to a `build.zig` file:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const optimize = b.standardOptimizeOption(.{});\n    const exe = b.addExecutable(.{\n        .name = \"example\",\n        .root_source_file = b.path(\"example.zig\"),\n        .optimize = optimize,\n    });\n    b.default_step.dependOn(&exe.step);\n}\n```\n\nbuild.zig\n\nThis causes these options to be available:\n\n-Doptimize=Debug  \nOptimizations off and safety on (default)\n\n-Doptimize=ReleaseSafe  \nOptimizations on and safety on\n\n-Doptimize=ReleaseFast  \nOptimizations on and safety off\n\n-Doptimize=ReleaseSmall  \nSize optimizations on and safety off\n\n### Debug\n\n    $ zig build-exe example.zig\n\nShell\n\n- Fast compilation speed\n- Safety checks enabled\n- Slow runtime performance\n- Large binary size\n- No reproducible build requirement\n\n### ReleaseFast\n\n    $ zig build-exe example.zig -O ReleaseFast\n\nShell\n\n- Fast runtime performance\n- Safety checks disabled\n- Slow compilation speed\n- Large binary size\n- Reproducible build\n\n### ReleaseSafe\n\n    $ zig build-exe example.zig -O ReleaseSafe\n\nShell\n\n- Medium runtime performance\n- Safety checks enabled\n- Slow compilation speed\n- Large binary size\n- Reproducible build\n\n### ReleaseSmall\n\n    $ zig build-exe example.zig -O ReleaseSmall\n\nShell\n\n- Medium runtime performance\n- Safety checks disabled\n- Slow compilation speed\n- Small binary size\n- Reproducible build\n\nSee also:\n\n- [Compile Variables](#Compile-Variables)\n- [Zig Build System](#Zig-Build-System)\n- [Undefined Behavior](#Undefined-Behavior)\n\n## Single Threaded Builds\n\nZig has a compile option -fsingle-threaded which has the following effects:\n\n- All [Thread Local Variables](#Thread-Local-Variables) are treated as regular [Container Level Variables](#Container-Level-Variables).\n- The overhead of [Async Functions](#Async-Functions) becomes equivalent to function call overhead.\n- The `@import``(``\"builtin\"``).single_threaded` becomes `true` and therefore various userland APIs which read this variable become more efficient. For example `std.Mutex` becomes an empty data structure and all of its functions become no-ops.\n\n## Undefined Behavior\n\nZig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with [@setRuntimeSafety](#setRuntimeSafety). The [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) build modes disable all safety checks (except where overridden by [@setRuntimeSafety](#setRuntimeSafety)) in order to facilitate optimizations.\n\nWhen a safety check fails, Zig crashes with a stack trace, like this:\n\n``` zig\ntest \"safety check\" {\n    unreachable;\n}\n```\n\ntest_undefined_behavior.zig\n\n    $ zig test test_undefined_behavior.zig\n    1/1 test_undefined_behavior.test.safety check...thread 3571226 panic: reached unreachable code\n    /home/andy/src/zig/doc/langref/test_undefined_behavior.zig:2:5: 0x103ce30 in test.safety check (test)\n        unreachable;\n        ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048260 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e21b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d359 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cec1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/a71f9f37afd5b3c603d2b9ea72373fa7/test\n\nShell\n\n### Reaching Unreachable Code\n\nAt compile-time:\n\n``` zig\ncomptime {\n    assert(false);\n}\nfn assert(ok: bool) void {\n    if (!ok) unreachable; // assertion failure\n}\n```\n\ntest_comptime_reaching_unreachable.zig\n\n    $ zig test test_comptime_reaching_unreachable.zig\n    doc/langref/test_comptime_reaching_unreachable.zig:5:14: error: reached unreachable code\n        if (!ok) unreachable; // assertion failure\n                 ^~~~~~~~~~~\n    doc/langref/test_comptime_reaching_unreachable.zig:2:11: note: called from here\n        assert(false);\n        ~~~~~~^~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    std.debug.assert(false);\n}\n```\n\nruntime_reaching_unreachable.zig\n\n    $ zig build-exe runtime_reaching_unreachable.zig\n    $ ./runtime_reaching_unreachable\n    thread 3575642 panic: reached unreachable code\n    /home/andy/src/zig/lib/std/debug.zig:412:14: 0x1036cdd in assert (runtime_reaching_unreachable)\n        if (!ok) unreachable; // assertion failure\n                 ^\n    /home/andy/src/zig/doc/langref/runtime_reaching_unreachable.zig:4:21: 0x103507a in main (runtime_reaching_unreachable)\n        std.debug.assert(false);\n                        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034929 in posixCallMainAndExit (runtime_reaching_unreachable)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034491 in _start (runtime_reaching_unreachable)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Index out of Bounds\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const array: [5]u8 = \"hello\".*;\n    const garbage = array[5];\n    _ = garbage;\n}\n```\n\ntest_comptime_index_out_of_bounds.zig\n\n    $ zig test test_comptime_index_out_of_bounds.zig\n    doc/langref/test_comptime_index_out_of_bounds.zig:3:27: error: index 5 outside array of length 5\n        const garbage = array[5];\n                              ^\n\nShell\n\nAt runtime:\n\n``` zig\npub fn main() void {\n    const x = foo(\"hello\");\n    _ = x;\n}\n\nfn foo(x: []const u8) u8 {\n    return x[5];\n}\n```\n\nruntime_index_out_of_bounds.zig\n\n    $ zig build-exe runtime_index_out_of_bounds.zig\n    $ ./runtime_index_out_of_bounds\n    thread 3567952 panic: index out of bounds: index 5, len 5\n    /home/andy/src/zig/doc/langref/runtime_index_out_of_bounds.zig:7:13: 0x1037169 in foo (runtime_index_out_of_bounds)\n        return x[5];\n                ^\n    /home/andy/src/zig/doc/langref/runtime_index_out_of_bounds.zig:2:18: 0x10350b6 in main (runtime_index_out_of_bounds)\n        const x = foo(\"hello\");\n                     ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034959 in posixCallMainAndExit (runtime_index_out_of_bounds)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10344c1 in _start (runtime_index_out_of_bounds)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Cast Negative Number to Unsigned Integer\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const value: i32 = -1;\n    const unsigned: u32 = @intCast(value);\n    _ = unsigned;\n}\n```\n\ntest_comptime_invalid_cast.zig\n\n    $ zig test test_comptime_invalid_cast.zig\n    doc/langref/test_comptime_invalid_cast.zig:3:36: error: type 'u32' cannot represent integer value '-1'\n        const unsigned: u32 = @intCast(value);\n                                       ^~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var value: i32 = -1; // runtime-known\n    _ = &value;\n    const unsigned: u32 = @intCast(value);\n    std.debug.print(\"value: {}\\n\", .{unsigned});\n}\n```\n\nruntime_invalid_cast.zig\n\n    $ zig build-exe runtime_invalid_cast.zig\n    $ ./runtime_invalid_cast\n    thread 3567914 panic: attempt to cast negative value to unsigned integer\n    /home/andy/src/zig/doc/langref/runtime_invalid_cast.zig:6:27: 0x10351e2 in main (runtime_invalid_cast)\n        const unsigned: u32 = @intCast(value);\n                              ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (runtime_invalid_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (runtime_invalid_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nTo obtain the maximum value of an unsigned integer, use `std.math.maxInt`.\n\n### Cast Truncates Data\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const spartan_count: u16 = 300;\n    const byte: u8 = @intCast(spartan_count);\n    _ = byte;\n}\n```\n\ntest_comptime_invalid_cast_truncate.zig\n\n    $ zig test test_comptime_invalid_cast_truncate.zig\n    doc/langref/test_comptime_invalid_cast_truncate.zig:3:31: error: type 'u8' cannot represent integer value '300'\n        const byte: u8 = @intCast(spartan_count);\n                                  ^~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var spartan_count: u16 = 300; // runtime-known\n    _ = &spartan_count;\n    const byte: u8 = @intCast(spartan_count);\n    std.debug.print(\"value: {}\\n\", .{byte});\n}\n```\n\nruntime_invalid_cast_truncate.zig\n\n    $ zig build-exe runtime_invalid_cast_truncate.zig\n    $ ./runtime_invalid_cast_truncate\n    thread 3576020 panic: integer cast truncated bits\n    /home/andy/src/zig/doc/langref/runtime_invalid_cast_truncate.zig:6:22: 0x1035275 in main (runtime_invalid_cast_truncate)\n        const byte: u8 = @intCast(spartan_count);\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ad9 in posixCallMainAndExit (runtime_invalid_cast_truncate)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034641 in _start (runtime_invalid_cast_truncate)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nTo truncate bits, use [@truncate](#truncate).\n\n### Integer Overflow\n\n#### [Default Operations](#toc-Default-Operations)\n\nThe following operators can cause integer overflow:\n\n- `+` (addition)\n- `-` (subtraction)\n- `-` (negation)\n- `*` (multiplication)\n- `/` (division)\n- [@divTrunc](#divTrunc) (division)\n- [@divFloor](#divFloor) (division)\n- [@divExact](#divExact) (division)\n\nExample with addition at compile-time:\n\n``` zig\ncomptime {\n    var byte: u8 = 255;\n    byte += 1;\n}\n```\n\ntest_comptime_overflow.zig\n\n    $ zig test test_comptime_overflow.zig\n    doc/langref/test_comptime_overflow.zig:3:10: error: overflow of integer type 'u8' with value '256'\n        byte += 1;\n        ~~~~~^~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var byte: u8 = 255;\n    byte += 1;\n    std.debug.print(\"value: {}\\n\", .{byte});\n}\n```\n\nruntime_overflow.zig\n\n    $ zig build-exe runtime_overflow.zig\n    $ ./runtime_overflow\n    thread 3574209 panic: integer overflow\n    /home/andy/src/zig/doc/langref/runtime_overflow.zig:5:10: 0x103525e in main (runtime_overflow)\n        byte += 1;\n             ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ad9 in posixCallMainAndExit (runtime_overflow)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034641 in _start (runtime_overflow)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n#### [Standard Library Math Functions](#toc-Standard-Library-Math-Functions)\n\nThese functions provided by the standard library return possible errors.\n\n- `@import``(``\"std\"``).math.add`\n- `@import``(``\"std\"``).math.sub`\n- `@import``(``\"std\"``).math.mul`\n- `@import``(``\"std\"``).math.divTrunc`\n- `@import``(``\"std\"``).math.divFloor`\n- `@import``(``\"std\"``).math.divExact`\n- `@import``(``\"std\"``).math.shl`\n\nExample of catching an overflow for addition:\n\n``` zig\nconst math = @import(\"std\").math;\nconst print = @import(\"std\").debug.print;\npub fn main() !void {\n    var byte: u8 = 255;\n\n    byte = if (math.add(u8, byte, 1)) |result| result else |err| {\n        print(\"unable to add one: {s}\\n\", .{@errorName(err)});\n        return err;\n    };\n\n    print(\"result: {}\\n\", .{byte});\n}\n```\n\nmath_add.zig\n\n    $ zig build-exe math_add.zig\n    $ ./math_add\n    unable to add one: Overflow\n    error: Overflow\n    /home/andy/src/zig/lib/std/math.zig:565:21: 0x10352a5 in add__anon_2592 (math_add)\n        if (ov[1] != 0) return error.Overflow;\n                        ^\n    /home/andy/src/zig/doc/langref/math_add.zig:8:9: 0x1035243 in main (math_add)\n            return err;\n            ^\n\nShell\n\n#### [Builtin Overflow Functions](#toc-Builtin-Overflow-Functions)\n\nThese builtins return a tuple containing whether there was an overflow (as a `u1`) and the possibly overflowed bits of the operation:\n\n- [@addWithOverflow](#addWithOverflow)\n- [@subWithOverflow](#subWithOverflow)\n- [@mulWithOverflow](#mulWithOverflow)\n- [@shlWithOverflow](#shlWithOverflow)\n\nExample of [@addWithOverflow](#addWithOverflow):\n\n``` zig\nconst print = @import(\"std\").debug.print;\npub fn main() void {\n    const byte: u8 = 255;\n\n    const ov = @addWithOverflow(byte, 10);\n    if (ov[1] != 0) {\n        print(\"overflowed result: {}\\n\", .{ov[0]});\n    } else {\n        print(\"result: {}\\n\", .{ov[0]});\n    }\n}\n```\n\naddWithOverflow_builtin.zig\n\n    $ zig build-exe addWithOverflow_builtin.zig\n    $ ./addWithOverflow_builtin\n    overflowed result: 9\n\nShell\n\n#### [Wrapping Operations](#toc-Wrapping-Operations)\n\nThese operations have guaranteed wraparound semantics.\n\n- `+%` (wraparound addition)\n- `-%` (wraparound subtraction)\n- `-%` (wraparound negation)\n- `*%` (wraparound multiplication)\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst minInt = std.math.minInt;\nconst maxInt = std.math.maxInt;\n\ntest \"wraparound addition and subtraction\" {\n    const x: i32 = maxInt(i32);\n    const min_val = x +% 1;\n    try expect(min_val == minInt(i32));\n    const max_val = min_val -% 1;\n    try expect(max_val == maxInt(i32));\n}\n```\n\ntest_wraparound_semantics.zig\n\n    $ zig test test_wraparound_semantics.zig\n    1/1 test_wraparound_semantics.test.wraparound addition and subtraction...OK\n    All 1 tests passed.\n\nShell\n\n### Exact Left Shift Overflow\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const x = @shlExact(@as(u8, 0b01010101), 2);\n    _ = x;\n}\n```\n\ntest_comptime_shlExact_overwlow.zig\n\n    $ zig test test_comptime_shlExact_overwlow.zig\n    doc/langref/test_comptime_shlExact_overwlow.zig:2:15: error: operation caused overflow\n        const x = @shlExact(@as(u8, 0b01010101), 2);\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var x: u8 = 0b01010101; // runtime-known\n    _ = &x;\n    const y = @shlExact(x, 2);\n    std.debug.print(\"value: {}\\n\", .{y});\n}\n```\n\nruntime_shlExact_overflow.zig\n\n    $ zig build-exe runtime_shlExact_overflow.zig\n    $ ./runtime_shlExact_overflow\n    thread 3577156 panic: left shift overflowed bits\n    /home/andy/src/zig/doc/langref/runtime_shlExact_overflow.zig:6:5: 0x10352bd in main (runtime_shlExact_overflow)\n        const y = @shlExact(x, 2);\n        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034b19 in posixCallMainAndExit (runtime_shlExact_overflow)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034681 in _start (runtime_shlExact_overflow)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Exact Right Shift Overflow\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const x = @shrExact(@as(u8, 0b10101010), 2);\n    _ = x;\n}\n```\n\ntest_comptime_shrExact_overflow.zig\n\n    $ zig test test_comptime_shrExact_overflow.zig\n    doc/langref/test_comptime_shrExact_overflow.zig:2:15: error: exact shift shifted out 1 bits\n        const x = @shrExact(@as(u8, 0b10101010), 2);\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var x: u8 = 0b10101010; // runtime-known\n    _ = &x;\n    const y = @shrExact(x, 2);\n    std.debug.print(\"value: {}\\n\", .{y});\n}\n```\n\nruntime_shrExact_overflow.zig\n\n    $ zig build-exe runtime_shrExact_overflow.zig\n    $ ./runtime_shrExact_overflow\n    thread 3579049 panic: right shift overflowed bits\n    /home/andy/src/zig/doc/langref/runtime_shrExact_overflow.zig:6:5: 0x10352b9 in main (runtime_shrExact_overflow)\n        const y = @shrExact(x, 2);\n        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034b19 in posixCallMainAndExit (runtime_shrExact_overflow)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034681 in _start (runtime_shrExact_overflow)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Division by Zero\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const a: i32 = 1;\n    const b: i32 = 0;\n    const c = a / b;\n    _ = c;\n}\n```\n\ntest_comptime_division_by_zero.zig\n\n    $ zig test test_comptime_division_by_zero.zig\n    doc/langref/test_comptime_division_by_zero.zig:4:19: error: division by zero here causes undefined behavior\n        const c = a / b;\n                      ^\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var a: u32 = 1;\n    var b: u32 = 0;\n    _ = .{ &a, &b };\n    const c = a / b;\n    std.debug.print(\"value: {}\\n\", .{c});\n}\n```\n\nruntime_division_by_zero.zig\n\n    $ zig build-exe runtime_division_by_zero.zig\n    $ ./runtime_division_by_zero\n    thread 3575479 panic: division by zero\n    /home/andy/src/zig/doc/langref/runtime_division_by_zero.zig:7:17: 0x10351f6 in main (runtime_division_by_zero)\n        const c = a / b;\n                    ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (runtime_division_by_zero)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (runtime_division_by_zero)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Remainder Division by Zero\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const a: i32 = 10;\n    const b: i32 = 0;\n    const c = a % b;\n    _ = c;\n}\n```\n\ntest_comptime_remainder_division_by_zero.zig\n\n    $ zig test test_comptime_remainder_division_by_zero.zig\n    doc/langref/test_comptime_remainder_division_by_zero.zig:4:19: error: division by zero here causes undefined behavior\n        const c = a % b;\n                      ^\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var a: u32 = 10;\n    var b: u32 = 0;\n    _ = .{ &a, &b };\n    const c = a % b;\n    std.debug.print(\"value: {}\\n\", .{c});\n}\n```\n\nruntime_remainder_division_by_zero.zig\n\n    $ zig build-exe runtime_remainder_division_by_zero.zig\n    $ ./runtime_remainder_division_by_zero\n    thread 3570535 panic: division by zero\n    /home/andy/src/zig/doc/langref/runtime_remainder_division_by_zero.zig:7:17: 0x10351f6 in main (runtime_remainder_division_by_zero)\n        const c = a % b;\n                    ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (runtime_remainder_division_by_zero)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (runtime_remainder_division_by_zero)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Exact Division Remainder\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const a: u32 = 10;\n    const b: u32 = 3;\n    const c = @divExact(a, b);\n    _ = c;\n}\n```\n\ntest_comptime_divExact_remainder.zig\n\n    $ zig test test_comptime_divExact_remainder.zig\n    doc/langref/test_comptime_divExact_remainder.zig:4:15: error: exact division produced remainder\n        const c = @divExact(a, b);\n                  ^~~~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var a: u32 = 10;\n    var b: u32 = 3;\n    _ = .{ &a, &b };\n    const c = @divExact(a, b);\n    std.debug.print(\"value: {}\\n\", .{c});\n}\n```\n\nruntime_divExact_remainder.zig\n\n    $ zig build-exe runtime_divExact_remainder.zig\n    $ ./runtime_divExact_remainder\n    thread 3570103 panic: exact division produced remainder\n    /home/andy/src/zig/doc/langref/runtime_divExact_remainder.zig:7:15: 0x103526b in main (runtime_divExact_remainder)\n        const c = @divExact(a, b);\n                  ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a89 in posixCallMainAndExit (runtime_divExact_remainder)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345f1 in _start (runtime_divExact_remainder)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Attempt to Unwrap Null\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const optional_number: ?i32 = null;\n    const number = optional_number.?;\n    _ = number;\n}\n```\n\ntest_comptime_unwrap_null.zig\n\n    $ zig test test_comptime_unwrap_null.zig\n    doc/langref/test_comptime_unwrap_null.zig:3:35: error: unable to unwrap null\n        const number = optional_number.?;\n                       ~~~~~~~~~~~~~~~^~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var optional_number: ?i32 = null;\n    _ = &optional_number;\n    const number = optional_number.?;\n    std.debug.print(\"value: {}\\n\", .{number});\n}\n```\n\nruntime_unwrap_null.zig\n\n    $ zig build-exe runtime_unwrap_null.zig\n    $ ./runtime_unwrap_null\n    thread 3570514 panic: attempt to use null value\n    /home/andy/src/zig/doc/langref/runtime_unwrap_null.zig:6:35: 0x1035272 in main (runtime_unwrap_null)\n        const number = optional_number.?;\n                                      ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ad9 in posixCallMainAndExit (runtime_unwrap_null)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034641 in _start (runtime_unwrap_null)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nOne way to avoid this crash is to test for null instead of assuming non-null, with the `if` expression:\n\n``` zig\nconst print = @import(\"std\").debug.print;\npub fn main() void {\n    const optional_number: ?i32 = null;\n\n    if (optional_number) |number| {\n        print(\"got number: {}\\n\", .{number});\n    } else {\n        print(\"it's null\\n\", .{});\n    }\n}\n```\n\ntesting_null_with_if.zig\n\n    $ zig build-exe testing_null_with_if.zig\n    $ ./testing_null_with_if\n    it's null\n\nShell\n\nSee also:\n\n- [Optionals](#Optionals)\n\n### Attempt to Unwrap Error\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const number = getNumberOrFail() catch unreachable;\n    _ = number;\n}\n\nfn getNumberOrFail() !i32 {\n    return error.UnableToReturnNumber;\n}\n```\n\ntest_comptime_unwrap_error.zig\n\n    $ zig test test_comptime_unwrap_error.zig\n    doc/langref/test_comptime_unwrap_error.zig:2:44: error: caught unexpected error 'UnableToReturnNumber'\n        const number = getNumberOrFail() catch unreachable;\n                                               ^~~~~~~~~~~\n    doc/langref/test_comptime_unwrap_error.zig:7:18: note: error returned here\n        return error.UnableToReturnNumber;\n                     ^~~~~~~~~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    const number = getNumberOrFail() catch unreachable;\n    std.debug.print(\"value: {}\\n\", .{number});\n}\n\nfn getNumberOrFail() !i32 {\n    return error.UnableToReturnNumber;\n}\n```\n\nruntime_unwrap_error.zig\n\n    $ zig build-exe runtime_unwrap_error.zig\n    $ ./runtime_unwrap_error\n    thread 3577877 panic: attempt to unwrap error: UnableToReturnNumber\n    /home/andy/src/zig/doc/langref/runtime_unwrap_error.zig:9:5: 0x103738f in getNumberOrFail (runtime_unwrap_error)\n        return error.UnableToReturnNumber;\n        ^\n    /home/andy/src/zig/doc/langref/runtime_unwrap_error.zig:4:44: 0x1035301 in main (runtime_unwrap_error)\n        const number = getNumberOrFail() catch unreachable;\n                                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034b49 in posixCallMainAndExit (runtime_unwrap_error)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10346b1 in _start (runtime_unwrap_error)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nOne way to avoid this crash is to test for an error instead of assuming a successful result, with the `if` expression:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    const result = getNumberOrFail();\n\n    if (result) |number| {\n        print(\"got number: {}\\n\", .{number});\n    } else |err| {\n        print(\"got error: {s}\\n\", .{@errorName(err)});\n    }\n}\n\nfn getNumberOrFail() !i32 {\n    return error.UnableToReturnNumber;\n}\n```\n\ntesting_error_with_if.zig\n\n    $ zig build-exe testing_error_with_if.zig\n    $ ./testing_error_with_if\n    got error: UnableToReturnNumber\n\nShell\n\nSee also:\n\n- [Errors](#Errors)\n\n### Invalid Error Code\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const err = error.AnError;\n    const number = @intFromError(err) + 10;\n    const invalid_err = @errorFromInt(number);\n    _ = invalid_err;\n}\n```\n\ntest_comptime_invalid_error_code.zig\n\n    $ zig test test_comptime_invalid_error_code.zig\n    doc/langref/test_comptime_invalid_error_code.zig:4:39: error: integer value '11' represents no error\n        const invalid_err = @errorFromInt(number);\n                                          ^~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    const err = error.AnError;\n    var number = @intFromError(err) + 500;\n    _ = &number;\n    const invalid_err = @errorFromInt(number);\n    std.debug.print(\"value: {}\\n\", .{invalid_err});\n}\n```\n\nruntime_invalid_error_code.zig\n\n    $ zig build-exe runtime_invalid_error_code.zig\n    $ ./runtime_invalid_error_code\n    thread 3570441 panic: invalid error code\n    /home/andy/src/zig/doc/langref/runtime_invalid_error_code.zig:7:5: 0x10352a0 in main (runtime_invalid_error_code)\n        const invalid_err = @errorFromInt(number);\n        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ae9 in posixCallMainAndExit (runtime_invalid_error_code)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034651 in _start (runtime_invalid_error_code)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Invalid Enum Cast\n\nAt compile-time:\n\n``` zig\nconst Foo = enum {\n    a,\n    b,\n    c,\n};\ncomptime {\n    const a: u2 = 3;\n    const b: Foo = @enumFromInt(a);\n    _ = b;\n}\n```\n\ntest_comptime_invalid_enum_cast.zig\n\n    $ zig test test_comptime_invalid_enum_cast.zig\n    doc/langref/test_comptime_invalid_enum_cast.zig:8:20: error: enum 'test_comptime_invalid_enum_cast.Foo' has no tag with value '3'\n        const b: Foo = @enumFromInt(a);\n                       ^~~~~~~~~~~~~~~\n    doc/langref/test_comptime_invalid_enum_cast.zig:1:13: note: enum declared here\n    const Foo = enum {\n                ^~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = enum {\n    a,\n    b,\n    c,\n};\n\npub fn main() void {\n    var a: u2 = 3;\n    _ = &a;\n    const b: Foo = @enumFromInt(a);\n    std.debug.print(\"value: {s}\\n\", .{@tagName(b)});\n}\n```\n\nruntime_invalid_enum_cast.zig\n\n    $ zig build-exe runtime_invalid_enum_cast.zig\n    $ ./runtime_invalid_enum_cast\n    thread 3568027 panic: invalid enum value\n    /home/andy/src/zig/doc/langref/runtime_invalid_enum_cast.zig:12:20: 0x1035297 in main (runtime_invalid_enum_cast)\n        const b: Foo = @enumFromInt(a);\n                       ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034af9 in posixCallMainAndExit (runtime_invalid_enum_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034661 in _start (runtime_invalid_enum_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Invalid Error Set Cast\n\nAt compile-time:\n\n``` zig\nconst Set1 = error{\n    A,\n    B,\n};\nconst Set2 = error{\n    A,\n    C,\n};\ncomptime {\n    _ = @as(Set2, @errorCast(Set1.B));\n}\n```\n\ntest_comptime_invalid_error_set_cast.zig\n\n    $ zig test test_comptime_invalid_error_set_cast.zig\n    doc/langref/test_comptime_invalid_error_set_cast.zig:10:19: error: 'error.B' not a member of error set 'error{A,C}'\n        _ = @as(Set2, @errorCast(Set1.B));\n                      ^~~~~~~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Set1 = error{\n    A,\n    B,\n};\nconst Set2 = error{\n    A,\n    C,\n};\npub fn main() void {\n    foo(Set1.B);\n}\nfn foo(set1: Set1) void {\n    const x: Set2 = @errorCast(set1);\n    std.debug.print(\"value: {}\\n\", .{x});\n}\n```\n\nruntime_invalid_error_set_cast.zig\n\n    $ zig build-exe runtime_invalid_error_set_cast.zig\n    $ ./runtime_invalid_error_set_cast\n    thread 3568026 panic: invalid error code\n    /home/andy/src/zig/doc/langref/runtime_invalid_error_set_cast.zig:15:21: 0x1037317 in foo (runtime_invalid_error_set_cast)\n        const x: Set2 = @errorCast(set1);\n                        ^\n    /home/andy/src/zig/doc/langref/runtime_invalid_error_set_cast.zig:12:8: 0x103523d in main (runtime_invalid_error_set_cast)\n        foo(Set1.B);\n           ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ae9 in posixCallMainAndExit (runtime_invalid_error_set_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034651 in _start (runtime_invalid_error_set_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Incorrect Pointer Alignment\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const ptr: *align(1) i32 = @ptrFromInt(0x1);\n    const aligned: *align(4) i32 = @alignCast(ptr);\n    _ = aligned;\n}\n```\n\ntest_comptime_incorrect_pointer_alignment.zig\n\n    $ zig test test_comptime_incorrect_pointer_alignment.zig\n    doc/langref/test_comptime_incorrect_pointer_alignment.zig:3:47: error: pointer address 0x1 is not aligned to 4 bytes\n        const aligned: *align(4) i32 = @alignCast(ptr);\n                                                  ^~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst mem = @import(\"std\").mem;\npub fn main() !void {\n    var array align(4) = [_]u32{ 0x11111111, 0x11111111 };\n    const bytes = mem.sliceAsBytes(array[0..]);\n    if (foo(bytes) != 0x11111111) return error.Wrong;\n}\nfn foo(bytes: []u8) u32 {\n    const slice4 = bytes[1..5];\n    const int_slice = mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n    return int_slice[0];\n}\n```\n\nruntime_incorrect_pointer_alignment.zig\n\n    $ zig build-exe runtime_incorrect_pointer_alignment.zig\n    $ ./runtime_incorrect_pointer_alignment\n    thread 3570122 panic: incorrect alignment\n    /home/andy/src/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:9:64: 0x1034f0a in foo (runtime_incorrect_pointer_alignment)\n        const int_slice = mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n                                                                   ^\n    /home/andy/src/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:5:12: 0x1034dc7 in main (runtime_incorrect_pointer_alignment)\n        if (foo(bytes) != 0x11111111) return error.Wrong;\n               ^\n    /home/andy/src/zig/lib/std/start.zig:524:37: 0x1034cc5 in posixCallMainAndExit (runtime_incorrect_pointer_alignment)\n                const result = root.main() catch |err| {\n                                        ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10347e1 in _start (runtime_incorrect_pointer_alignment)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Wrong Union Field Access\n\nAt compile-time:\n\n``` zig\ncomptime {\n    var f = Foo{ .int = 42 };\n    f.float = 12.34;\n}\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n```\n\ntest_comptime_wrong_union_field_access.zig\n\n    $ zig test test_comptime_wrong_union_field_access.zig\n    doc/langref/test_comptime_wrong_union_field_access.zig:3:6: error: access of union field 'float' while field 'int' is active\n        f.float = 12.34;\n        ~^~~~~~\n    doc/langref/test_comptime_wrong_union_field_access.zig:6:13: note: union declared here\n    const Foo = union {\n                ^~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n\npub fn main() void {\n    var f = Foo{ .int = 42 };\n    bar(&f);\n}\n\nfn bar(f: *Foo) void {\n    f.float = 12.34;\n    std.debug.print(\"value: {}\\n\", .{f.float});\n}\n```\n\nruntime_wrong_union_field_access.zig\n\n    $ zig build-exe runtime_wrong_union_field_access.zig\n    $ ./runtime_wrong_union_field_access\n    thread 3578787 panic: access of union field 'float' while field 'int' is active\n    /home/andy/src/zig/doc/langref/runtime_wrong_union_field_access.zig:14:6: 0x103cd20 in bar (runtime_wrong_union_field_access)\n        f.float = 12.34;\n         ^\n    /home/andy/src/zig/doc/langref/runtime_wrong_union_field_access.zig:10:8: 0x103ac5c in main (runtime_wrong_union_field_access)\n        bar(&f);\n           ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103a4f9 in posixCallMainAndExit (runtime_wrong_union_field_access)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103a061 in _start (runtime_wrong_union_field_access)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nThis safety is not available for `extern` or `packed` unions.\n\nTo change the active field of a union, assign the entire union, like this:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n\npub fn main() void {\n    var f = Foo{ .int = 42 };\n    bar(&f);\n}\n\nfn bar(f: *Foo) void {\n    f.* = Foo{ .float = 12.34 };\n    std.debug.print(\"value: {}\\n\", .{f.float});\n}\n```\n\nchange_active_union_field.zig\n\n    $ zig build-exe change_active_union_field.zig\n    $ ./change_active_union_field\n    value: 1.234e1\n\nShell\n\nTo change the active field of a union when a meaningful value for the field is not known, use [undefined](#undefined), like this:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n\npub fn main() void {\n    var f = Foo{ .int = 42 };\n    f = Foo{ .float = undefined };\n    bar(&f);\n    std.debug.print(\"value: {}\\n\", .{f.float});\n}\n\nfn bar(f: *Foo) void {\n    f.float = 12.34;\n}\n```\n\nundefined_active_union_field.zig\n\n    $ zig build-exe undefined_active_union_field.zig\n    $ ./undefined_active_union_field\n    value: 1.234e1\n\nShell\n\nSee also:\n\n- [union](#union)\n- [extern union](#extern-union)\n\n### Out of Bounds Float to Integer Cast\n\nThis happens when casting a float to an integer where the float has a value outside the integer type's range.\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const float: f32 = 4294967296;\n    const int: i32 = @intFromFloat(float);\n    _ = int;\n}\n```\n\ntest_comptime_out_of_bounds_float_to_integer_cast.zig\n\n    $ zig test test_comptime_out_of_bounds_float_to_integer_cast.zig\n    doc/langref/test_comptime_out_of_bounds_float_to_integer_cast.zig:3:36: error: float value '4294967296' cannot be stored in integer type 'i32'\n        const int: i32 = @intFromFloat(float);\n                                       ^~~~~\n\nShell\n\nAt runtime:\n\n``` zig\npub fn main() void {\n    var float: f32 = 4294967296; // runtime-known\n    _ = &float;\n    const int: i32 = @intFromFloat(float);\n    _ = int;\n}\n```\n\nruntime_out_of_bounds_float_to_integer_cast.zig\n\n    $ zig build-exe runtime_out_of_bounds_float_to_integer_cast.zig\n    $ ./runtime_out_of_bounds_float_to_integer_cast\n    thread 3570320 panic: integer part of floating point value out of bounds\n    /home/andy/src/zig/doc/langref/runtime_out_of_bounds_float_to_integer_cast.zig:4:22: 0x1035169 in main (runtime_out_of_bounds_float_to_integer_cast)\n        const int: i32 = @intFromFloat(float);\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10349a9 in posixCallMainAndExit (runtime_out_of_bounds_float_to_integer_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034511 in _start (runtime_out_of_bounds_float_to_integer_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Pointer Cast Invalid Null\n\nThis happens when casting a pointer with the address 0 to a pointer which may not have the address 0. For example, [C Pointers](#C-Pointers), [Optional Pointers](#Optional-Pointers), and [allowzero](#allowzero) pointers allow address zero, but normal [Pointers](#Pointers) do not.\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const opt_ptr: ?*i32 = null;\n    const ptr: *i32 = @ptrCast(opt_ptr);\n    _ = ptr;\n}\n```\n\ntest_comptime_invalid_null_pointer_cast.zig\n\n    $ zig test test_comptime_invalid_null_pointer_cast.zig\n    doc/langref/test_comptime_invalid_null_pointer_cast.zig:3:32: error: null pointer casted to type '*i32'\n        const ptr: *i32 = @ptrCast(opt_ptr);\n                                   ^~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\npub fn main() void {\n    var opt_ptr: ?*i32 = null;\n    _ = &opt_ptr;\n    const ptr: *i32 = @ptrCast(opt_ptr);\n    _ = ptr;\n}\n```\n\nruntime_invalid_null_pointer_cast.zig\n\n    $ zig build-exe runtime_invalid_null_pointer_cast.zig\n    $ ./runtime_invalid_null_pointer_cast\n    thread 3572791 panic: cast causes pointer to be null\n    /home/andy/src/zig/doc/langref/runtime_invalid_null_pointer_cast.zig:4:23: 0x10350bc in main (runtime_invalid_null_pointer_cast)\n        const ptr: *i32 = @ptrCast(opt_ptr);\n                          ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034929 in posixCallMainAndExit (runtime_invalid_null_pointer_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034491 in _start (runtime_invalid_null_pointer_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n## Memory\n\nThe Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question:\n\n[Where are the bytes?](#Where-are-the-bytes)\n\nLike Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - `malloc`, `realloc`, and `free`. When linking against libc, Zig exposes this allocator with `std.heap.c_allocator`. However, by convention, there is no default allocator in Zig. Instead, functions which need to allocate accept an `Allocator` parameter. Likewise, data structures such as `std.ArrayList` accept an `Allocator` parameter in their initialization functions:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nconst expect = std.testing.expect;\n\ntest \"using an allocator\" {\n    var buffer: [100]u8 = undefined;\n    var fba = std.heap.FixedBufferAllocator.init(&buffer);\n    const allocator = fba.allocator();\n    const result = try concat(allocator, \"foo\", \"bar\");\n    try expect(std.mem.eql(u8, \"foobar\", result));\n}\n\nfn concat(allocator: Allocator, a: []const u8, b: []const u8) ![]u8 {\n    const result = try allocator.alloc(u8, a.len + b.len);\n    @memcpy(result[0..a.len], a);\n    @memcpy(result[a.len..], b);\n    return result;\n}\n```\n\ntest_allocator.zig\n\n    $ zig test test_allocator.zig\n    1/1 test_allocator.test.using an allocator...OK\n    All 1 tests passed.\n\nShell\n\nIn the above example, 100 bytes of stack memory are used to initialize a `FixedBufferAllocator`, which is then passed to a function. As a convenience there is a global `FixedBufferAllocator` available for quick tests at `std.testing.allocator`, which will also perform basic leak detection.\n\nZig has a general purpose allocator available to be imported with `std.heap.GeneralPurposeAllocator`. However, it is still recommended to follow the [Choosing an Allocator](#Choosing-an-Allocator) guide.\n\n### Choosing an Allocator\n\nWhat allocator to use depends on a number of factors. Here is a flow chart to help you decide:\n\n1.  Are you making a library? In this case, best to accept an `Allocator` as a parameter and allow your library's users to decide what allocator to use.\n2.  Are you linking libc? In this case, `std.heap.c_allocator` is likely the right choice, at least for your main allocator.\n3.  Is the maximum number of bytes that you will need bounded by a number known at [comptime](#comptime)? In this case, use `std.heap.FixedBufferAllocator` or `std.heap.ThreadSafeFixedBufferAllocator` depending on whether you need thread-safety or not.\n4.  Is your program a command line application which runs from start to end without any fundamental cyclical pattern (such as a video game main loop, or a web server request handler), such that it would make sense to free everything at once at the end? In this case, it is recommended to follow this pattern:\n    ``` zig\n    const std = @import(\"std\");\n\n    pub fn main() !void {\n        var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n        defer arena.deinit();\n\n        const allocator = arena.allocator();\n\n        const ptr = try allocator.create(i32);\n        std.debug.print(\"ptr={*}\\n\", .{ptr});\n    }\n    ```\n\n    cli_allocation.zig\n\n        $ zig build-exe cli_allocation.zig\n        $ ./cli_allocation\n        ptr=i32@7f989ee8e010\n\n    Shell\n\n    When using this kind of allocator, there is no need to free anything manually. Everything gets freed at once with the call to `arena.deinit()`.\n5.  Are the allocations part of a cyclical pattern such as a video game main loop, or a web server request handler? If the allocations can all be freed at once, at the end of the cycle, for example once the video game frame has been fully rendered, or the web server request has been served, then `std.heap.ArenaAllocator` is a great candidate. As demonstrated in the previous bullet point, this allows you to free entire arenas at once. Note also that if an upper bound of memory can be established, then `std.heap.FixedBufferAllocator` can be used as a further optimization.\n6.  Are you writing a test, and you want to make sure `error``.OutOfMemory` is handled correctly? In this case, use `std.testing.FailingAllocator`.\n7.  Are you writing a test? In this case, use `std.testing.allocator`.\n8.  Finally, if none of the above apply, you need a general purpose allocator. Zig's general purpose allocator is available as a function that takes a [comptime](#comptime) [struct](#struct) of configuration options and returns a type. Generally, you will set up one `std.heap.GeneralPurposeAllocator` in your main function, and then pass it or sub-allocators around to various parts of your application.\n9.  You can also consider [Implementing an Allocator](#Implementing-an-Allocator).\n\n### Where are the bytes?\n\nString literals such as `\"hello\"` are in the global constant data section. This is why it is an error to pass a string literal to a mutable slice, like this:\n\n``` zig\nfn foo(s: []u8) void {\n    _ = s;\n}\n\ntest \"string literal to mutable slice\" {\n    foo(\"hello\");\n}\n```\n\ntest_string_literal_to_slice.zig\n\n    $ zig test test_string_literal_to_slice.zig\n    doc/langref/test_string_literal_to_slice.zig:6:9: error: expected type '[]u8', found '*const [5:0]u8'\n        foo(\"hello\");\n            ^~~~~~~\n    doc/langref/test_string_literal_to_slice.zig:6:9: note: cast discards const qualifier\n    doc/langref/test_string_literal_to_slice.zig:1:11: note: parameter type declared here\n    fn foo(s: []u8) void {\n              ^~~~\n\nShell\n\nHowever if you make the slice constant, then it works:\n\n``` zig\nfn foo(s: []const u8) void {\n    _ = s;\n}\n\ntest \"string literal to constant slice\" {\n    foo(\"hello\");\n}\n```\n\ntest_string_literal_to_const_slice.zig\n\n    $ zig test test_string_literal_to_const_slice.zig\n    1/1 test_string_literal_to_const_slice.test.string literal to constant slice...OK\n    All 1 tests passed.\n\nShell\n\nJust like string literals, `const` declarations, when the value is known at [comptime](#comptime), are stored in the global constant data section. Also [Compile Time Variables](#Compile-Time-Variables) are stored in the global constant data section.\n\n`var` declarations inside functions are stored in the function's stack frame. Once a function returns, any [Pointers](#Pointers) to variables in the function's stack frame become invalid references, and dereferencing them becomes unchecked [Undefined Behavior](#Undefined-Behavior).\n\n`var` declarations at the top level or in [struct](#struct) declarations are stored in the global data section.\n\nThe location of memory allocated with `allocator.alloc` or `allocator.create` is determined by the allocator's implementation.\n\nTODO: thread local variables\n\n### Implementing an Allocator\n\nZig programmers can implement their own allocators by fulfilling the Allocator interface. In order to do this one must read carefully the documentation comments in std/mem.zig and then supply a `allocFn` and a `resizeFn`.\n\nThere are many example allocators to look at for inspiration. Look at std/heap.zig and `std.heap.GeneralPurposeAllocator`.\n\n### Heap Allocation Failure\n\nMany programming languages choose to handle the possibility of heap allocation failure by unconditionally crashing. By convention, Zig programmers do not consider this to be a satisfactory solution. Instead, `error``.OutOfMemory` represents heap allocation failure, and Zig libraries return this error code whenever heap allocation failure prevented an operation from completing successfully.\n\nSome have argued that because some operating systems such as Linux have memory overcommit enabled by default, it is pointless to handle heap allocation failure. There are many problems with this reasoning:\n\n- Only some operating systems have an overcommit feature.\n  - Linux has it enabled by default, but it is configurable.\n  - Windows does not overcommit.\n  - Embedded systems do not have overcommit.\n  - Hobby operating systems may or may not have overcommit.\n- For real-time systems, not only is there no overcommit, but typically the maximum amount of memory per application is determined ahead of time.\n- When writing a library, one of the main goals is code reuse. By making code handle allocation failure correctly, a library becomes eligible to be reused in more contexts.\n- Although some software has grown to depend on overcommit being enabled, its existence is the source of countless user experience disasters. When a system with overcommit enabled, such as Linux on default settings, comes close to memory exhaustion, the system locks up and becomes unusable. At this point, the OOM Killer selects an application to kill based on heuristics. This non-deterministic decision often results in an important process being killed, and often fails to return the system back to working order.\n\n### Recursion\n\nRecursion is a fundamental tool in modeling software. However it has an often-overlooked problem: unbounded memory allocation.\n\nRecursion is an area of active experimentation in Zig and so the documentation here is not final. You can read a [summary of recursion status in the 0.3.0 release notes](https://ziglang.org/download/0.3.0/release-notes.html#recursion).\n\nThe short summary is that currently recursion works normally as you would expect. Although Zig code is not yet protected from stack overflow, it is planned that a future version of Zig will provide such protection, with some degree of cooperation from Zig code required.\n\n### Lifetime and Ownership\n\nIt is the Zig programmer's responsibility to ensure that a [pointer](#Pointers) is not accessed when the memory pointed to is no longer available. Note that a [slice](#Slices) is a form of pointer, in that it references other memory.\n\nIn order to prevent bugs, there are some helpful conventions to follow when dealing with pointers. In general, when a function returns a pointer, the documentation for the function should explain who \"owns\" the pointer. This concept helps the programmer decide when it is appropriate, if ever, to free the pointer.\n\nFor example, the function's documentation may say \"caller owns the returned memory\", in which case the code that calls the function must have a plan for when to free that memory. Probably in this situation, the function will accept an `Allocator` parameter.\n\nSometimes the lifetime of a pointer may be more complicated. For example, the `std.ArrayList(T).items` slice has a lifetime that remains valid until the next time the list is resized, such as by appending new elements.\n\nThe API documentation for functions and data structures should take great care to explain the ownership and lifetime semantics of pointers. Ownership determines whose responsibility it is to free the memory referenced by the pointer, and lifetime determines the point at which the memory becomes inaccessible (lest [Undefined Behavior](#Undefined-Behavior) occur).\n\n## Compile Variables\n\nCompile variables are accessible by importing the `\"builtin\"` package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode.\n\n``` zig\nconst builtin = @import(\"builtin\");\nconst separator = if (builtin.os.tag == .windows) '\\\\' else '/';\n```\n\ncompile_variables.zig\n\nExample of what is imported with `@import``(``\"builtin\"``)`:\n\n``` zig\nconst std = @import(\"std\");\n/// Zig version. When writing code that supports multiple versions of Zig, prefer\n/// feature detection (i.e. with `@hasDecl` or `@hasField`) over version checks.\npub const zig_version = std.SemanticVersion.parse(zig_version_string) catch unreachable;\npub const zig_version_string = \"0.13.0\";\npub const zig_backend = std.builtin.CompilerBackend.stage2_llvm;\n\npub const output_mode = std.builtin.OutputMode.Exe;\npub const link_mode = std.builtin.LinkMode.static;\npub const is_test = false;\npub const single_threaded = false;\npub const abi = std.Target.Abi.gnu;\npub const cpu: std.Target.Cpu = .{\n    .arch = .x86_64,\n    .model = &std.Target.x86.cpu.znver4,\n    .features = std.Target.x86.featureSet(&[_]std.Target.x86.Feature{\n        .@\"64bit\",\n        .adx,\n        .aes,\n        .allow_light_256_bit,\n        .avx,\n        .avx2,\n        .avx512bf16,\n        .avx512bitalg,\n        .avx512bw,\n        .avx512cd,\n        .avx512dq,\n        .avx512f,\n        .avx512ifma,\n        .avx512vbmi,\n        .avx512vbmi2,\n        .avx512vl,\n        .avx512vnni,\n        .avx512vpopcntdq,\n        .bmi,\n        .bmi2,\n        .branchfusion,\n        .clflushopt,\n        .clwb,\n        .clzero,\n        .cmov,\n        .crc32,\n        .cx16,\n        .cx8,\n        .evex512,\n        .f16c,\n        .fast_15bytenop,\n        .fast_bextr,\n        .fast_lzcnt,\n        .fast_movbe,\n        .fast_scalar_fsqrt,\n        .fast_scalar_shift_masks,\n        .fast_variable_perlane_shuffle,\n        .fast_vector_fsqrt,\n        .fma,\n        .fsgsbase,\n        .fsrm,\n        .fxsr,\n        .gfni,\n        .invpcid,\n        .lzcnt,\n        .macrofusion,\n        .mmx,\n        .movbe,\n        .mwaitx,\n        .nopl,\n        .pclmul,\n        .pku,\n        .popcnt,\n        .prfchw,\n        .rdpid,\n        .rdpru,\n        .rdrnd,\n        .rdseed,\n        .sahf,\n        .sbb_dep_breaking,\n        .sha,\n        .shstk,\n        .slow_shld,\n        .sse,\n        .sse2,\n        .sse3,\n        .sse4_1,\n        .sse4_2,\n        .sse4a,\n        .ssse3,\n        .vaes,\n        .vpclmulqdq,\n        .vzeroupper,\n        .wbnoinvd,\n        .x87,\n        .xsave,\n        .xsavec,\n        .xsaveopt,\n        .xsaves,\n    }),\n};\npub const os = std.Target.Os{\n    .tag = .linux,\n    .version_range = .{ .linux = .{\n        .range = .{\n            .min = .{\n                .major = 6,\n                .minor = 9,\n                .patch = 2,\n            },\n            .max = .{\n                .major = 6,\n                .minor = 9,\n                .patch = 2,\n            },\n        },\n        .glibc = .{\n            .major = 2,\n            .minor = 39,\n            .patch = 0,\n        },\n    }},\n};\npub const target: std.Target = .{\n    .cpu = cpu,\n    .os = os,\n    .abi = abi,\n    .ofmt = object_format,\n    .dynamic_linker = std.Target.DynamicLinker.init(\"/nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/ld-linux-x86-64.so.2\"),\n};\npub const object_format = std.Target.ObjectFormat.elf;\npub const mode = std.builtin.OptimizeMode.Debug;\npub const link_libc = false;\npub const link_libcpp = false;\npub const have_error_return_tracing = true;\npub const valgrind_support = true;\npub const sanitize_thread = false;\npub const position_independent_code = false;\npub const position_independent_executable = false;\npub const strip_debug_info = false;\npub const code_model = std.builtin.CodeModel.default;\npub const omit_frame_pointer = false;\n```\n\n@import(\"builtin\")\n\nSee also:\n\n- [Build Mode](#Build-Mode)\n\n## Root Source File\n\nTODO: explain how root source file finds other files\n\nTODO: pub fn main\n\nTODO: pub fn panic\n\nTODO: if linking with libc you can use export fn main\n\nTODO: order independent top level declarations\n\nTODO: lazy analysis\n\nTODO: using comptime { \\_ = @import() }\n\n## Zig Build System\n\nThe Zig Build System provides a cross-platform, dependency-free way to declare the logic required to build a project. With this system, the logic to build a project is written in a build.zig file, using the Zig Build System API to declare and configure build artifacts and other tasks.\n\nSome examples of tasks the build system can help with:\n\n- Performing tasks in parallel and caching the results.\n- Depending on other projects.\n- Providing a package for other projects to depend on.\n- Creating build artifacts by executing the Zig compiler. This includes building Zig source code as well as C and C++ source code.\n- Capturing user-configured options and using those options to configure the build.\n- Surfacing build configuration as [comptime](#comptime) values by providing a file that can be [imported](#import) by Zig code.\n- Caching build artifacts to avoid unnecessarily repeating steps.\n- Executing build artifacts or system-installed tools.\n- Running tests and verifying the output of executing a build artifact matches the expected value.\n- Running `zig fmt` on a codebase or a subset of it.\n- Custom tasks.\n\nTo use the build system, run zig build --help to see a command-line usage help menu. This will include project-specific options that were declared in the build.zig script.\n\nFor the time being, the build system documentation is hosted externally: [Build System Documentation](https://ziglang.org/learn/build-system/)\n\n## C\n\nAlthough Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code.\n\nThere are a few ways that Zig facilitates C interop.\n\n### C Type Primitives\n\nThese have guaranteed C ABI compatibility and can be used like any other type.\n\n- `c_char`\n- `c_short`\n- `c_ushort`\n- `c_int`\n- `c_uint`\n- `c_long`\n- `c_ulong`\n- `c_longlong`\n- `c_ulonglong`\n- `c_longdouble`\n\nTo interop with the C `void` type, use `anyopaque`.\n\nSee also:\n\n- [Primitive Types](#Primitive-Types)\n\n### Import from C Header File\n\nThe `@cImport` builtin function can be used to directly import symbols from `.h` files:\n\n``` zig\nconst c = @cImport({\n    // See https://github.com/ziglang/zig/issues/515\n    @cDefine(\"_NO_CRT_STDIO_INLINE\", \"1\");\n    @cInclude(\"stdio.h\");\n});\npub fn main() void {\n    _ = c.printf(\"hello\\n\");\n}\n```\n\ncImport_builtin.zig\n\n    $ zig build-exe cImport_builtin.zig -lc\n    $ ./cImport_builtin\n    hello\n\nShell\n\nThe `@cImport` function takes an expression as a parameter. This expression is evaluated at compile-time and is used to control preprocessor directives and include multiple `.h` files:\n\n``` zig\nconst builtin = @import(\"builtin\");\n\nconst c = @cImport({\n    @cDefine(\"NDEBUG\", builtin.mode == .ReleaseFast);\n    if (something) {\n        @cDefine(\"_GNU_SOURCE\", {});\n    }\n    @cInclude(\"stdlib.h\");\n    if (something) {\n        @cUndef(\"_GNU_SOURCE\");\n    }\n    @cInclude(\"soundio.h\");\n});\n```\n\n@cImport Expression\n\nSee also:\n\n- [@cImport](#cImport)\n- [@cInclude](#cInclude)\n- [@cDefine](#cDefine)\n- [@cUndef](#cUndef)\n- [@import](#import)\n\n### C Translation CLI\n\nZig's C translation capability is available as a CLI tool via zig translate-c. It requires a single filename as an argument. It may also take a set of optional flags that are forwarded to clang. It writes the translated file to stdout.\n\n#### [Command line flags](#toc-Command-line-flags)\n\n- -I: Specify a search directory for include files. May be used multiple times. Equivalent to [clang's -I flag](https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-i-dir). The current directory is *not* included by default; use -I. to include it.\n- -D: Define a preprocessor macro. Equivalent to [clang's -D flag](https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-d-macro).\n- -cflags \\[flags\\] --: Pass arbitrary additional [command line flags](https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html) to clang. Note: the list of flags must end with --\n- -target: The [target triple](#Targets) for the translated Zig code. If no target is specified, the current host target will be used.\n\n#### [Using -target and -cflags](#toc-Using--target-and--cflags)\n\n**Important!** When translating C code with zig translate-c, you **must** use the same -target triple that you will use when compiling the translated code. In addition, you **must** ensure that the -cflags used, if any, match the cflags used by code on the target system. Using the incorrect -target or -cflags could result in clang or Zig parse failures, or subtle ABI incompatibilities when linking with C code.\n\n``` zig\nlong FOO = __LONG_MAX__;\n```\n\nvarytarget.h\n\n    $ zig translate-c -target thumb-freestanding-gnueabihf varytarget.h|grep FOO\n    pub export var FOO: c_long = 2147483647;\n    $ zig translate-c -target x86_64-macos-gnu varytarget.h|grep FOO\n    pub export var FOO: c_long = 9223372036854775807;\n\nShell\n\n``` zig\nenum FOO { BAR };\nint do_something(enum FOO foo);\n```\n\nvarycflags.h\n\n    $ zig translate-c varycflags.h|grep -B1 do_something\n    pub const enum_FOO = c_uint;\n    pub extern fn do_something(foo: enum_FOO) c_int;\n    $ zig translate-c -cflags -fshort-enums -- varycflags.h|grep -B1 do_something\n    pub const enum_FOO = u8;\n    pub extern fn do_something(foo: enum_FOO) c_int;\n\nShell\n\n#### [@cImport vs translate-c](#toc-cImport-vs-translate-c)\n\n`@cImport` and zig translate-c use the same underlying C translation functionality, so on a technical level they are equivalent. In practice, `@cImport` is useful as a way to quickly and easily access numeric constants, typedefs, and record types without needing any extra setup. If you need to pass [cflags](#Using--target-and--cflags) to clang, or if you would like to edit the translated code, it is recommended to use zig translate-c and save the results to a file. Common reasons for editing the generated code include: changing `anytype` parameters in function-like macros to more specific types; changing `[*c]T` pointers to `[*]T` or `*T` pointers for improved type safety; and [enabling or disabling runtime safety](#setRuntimeSafety) within specific functions.\n\nSee also:\n\n- [Targets](#Targets)\n- [C Type Primitives](#C-Type-Primitives)\n- [Pointers](#Pointers)\n- [C Pointers](#C-Pointers)\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cInclude](#cInclude)\n- [@cImport](#cImport)\n- [@setRuntimeSafety](#setRuntimeSafety)\n\n### C Translation Caching\n\nThe C translation feature (whether used via zig translate-c or `@cImport`) integrates with the Zig caching system. Subsequent runs with the same source file, target, and cflags will use the cache instead of repeatedly translating the same code.\n\nTo see where the cached files are stored when compiling code that uses `@cImport`, use the --verbose-cimport flag:\n\n``` zig\nconst c = @cImport({\n    @cDefine(\"_NO_CRT_STDIO_INLINE\", \"1\");\n    @cInclude(\"stdio.h\");\n});\npub fn main() void {\n    _ = c;\n}\n```\n\nverbose_cimport_flag.zig\n\n    $ zig build-exe verbose_cimport_flag.zig -lc --verbose-cimport\n    info(compilation): C import source: /home/andy/src/zig/.zig-cache/o/f4e9c68cba40c97888f064d67b031021/cimport.h\n    info(compilation): C import .d file: /home/andy/src/zig/.zig-cache/o/f4e9c68cba40c97888f064d67b031021/cimport.h.d\n    info(compilation): C import output: /home/andy/src/zig/.zig-cache/o/1b63455e1d0d323f51bdc4909717e28b/cimport.zig\n    $ ./verbose_cimport_flag\n\nShell\n\n`cimport.h` contains the file to translate (constructed from calls to `@cInclude`, `@cDefine`, and `@cUndef`), `cimport.h.d` is the list of file dependencies, and `cimport.zig` contains the translated output.\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [C Translation CLI](#C-Translation-CLI)\n- [@cInclude](#cInclude)\n- [@cImport](#cImport)\n\n### Translation failures\n\nSome C constructs cannot be translated to Zig - for example, *goto*, structs with bitfields, and token-pasting macros. Zig employs *demotion* to allow translation to continue in the face of non-translatable entities.\n\nDemotion comes in three varieties - [opaque](#opaque), *extern*, and `@compileError`. C structs and unions that cannot be translated correctly will be translated as `opaque``{}`. Functions that contain opaque types or code constructs that cannot be translated will be demoted to `extern` declarations. Thus, non-translatable types can still be used as pointers, and non-translatable functions can be called so long as the linker is aware of the compiled function.\n\n`@compileError` is used when top-level definitions (global variables, function prototypes, macros) cannot be translated or demoted. Since Zig uses lazy analysis for top-level declarations, untranslatable entities will not cause a compile error in your code unless you actually use them.\n\nSee also:\n\n- [opaque](#opaque)\n- [extern](#extern)\n- [@compileError](#compileError)\n\n### C Macros\n\nC Translation makes a best-effort attempt to translate function-like macros into equivalent Zig functions. Since C macros operate at the level of lexical tokens, not all C macros can be translated to Zig. Macros that cannot be translated will be demoted to `@compileError`. Note that C code which *uses* macros will be translated without any additional issues (since Zig operates on the pre-processed source with macros expanded). It is merely the macros themselves which may not be translatable to Zig.\n\nConsider the following example:\n\n``` zig\n#define MAKELOCAL(NAME, INIT) int NAME = INIT\nint foo(void) {\n   MAKELOCAL(a, 1);\n   MAKELOCAL(b, 2);\n   return a + b;\n}\n```\n\nmacro.c\n\n    $ zig translate-c macro.c > macro.zig\n\nShell\n\n``` zig\npub export fn foo() c_int {\n    var a: c_int = 1;\n    _ = &a;\n    var b: c_int = 2;\n    _ = &b;\n    return a + b;\n}\npub const MAKELOCAL = @compileError(\"unable to translate C expr: unexpected token .Equal\"); // macro.c:1:9\n```\n\nmacro.zig\n\nNote that `foo` was translated correctly despite using a non-translatable macro. `MAKELOCAL` was demoted to `@compileError` since it cannot be expressed as a Zig function; this simply means that you cannot directly use `MAKELOCAL` from Zig.\n\nSee also:\n\n- [@compileError](#compileError)\n\n### C Pointers\n\nThis type is to be avoided whenever possible. The only valid reason for using a C pointer is in auto-generated code from translating C code.\n\nWhen importing C header files, it is ambiguous whether pointers should be translated as single-item pointers (`*T`) or many-item pointers (`[*]T`). C pointers are a compromise so that Zig code can utilize translated header files directly.\n\n`[*c]T` - C pointer.\n\n- Supports all the syntax of the other two pointer types (`*T`) and (`[*]T`).\n- Coerces to other pointer types, as well as [Optional Pointers](#Optional-Pointers). When a C pointer is coerced to a non-optional pointer, safety-checked [Undefined Behavior](#Undefined-Behavior) occurs if the address is 0.\n- Allows address 0. On non-freestanding targets, dereferencing address 0 is safety-checked [Undefined Behavior](#Undefined-Behavior). Optional C pointers introduce another bit to keep track of null, just like `?``usize`. Note that creating an optional C pointer is unnecessary as one can use normal [Optional Pointers](#Optional-Pointers).\n- Supports [Type Coercion](#Type-Coercion) to and from integers.\n- Supports comparison with integers.\n- Does not support Zig-only pointer attributes such as alignment. Use normal [Pointers](#Pointers) please!\n\nWhen a C pointer is pointing to a single struct (not an array), dereference the C pointer to access the struct's fields or member data. That syntax looks like this:\n\n`ptr_to_struct.*.struct_member`\n\nThis is comparable to doing `->` in C.\n\nWhen a C pointer is pointing to an array of structs, the syntax reverts to this:\n\n`ptr_to_struct_array[index].struct_member`\n\n### C Variadic Functions\n\nZig supports extern variadic functions.\n\n``` zig\nconst std = @import(\"std\");\nconst testing = std.testing;\n\npub extern \"c\" fn printf(format: [*:0]const u8, ...) c_int;\n\ntest \"variadic function\" {\n    try testing.expect(printf(\"Hello, world!\\n\") == 14);\n    try testing.expect(@typeInfo(@TypeOf(printf)).Fn.is_var_args);\n}\n```\n\ntest_variadic_function.zig\n\n    $ zig test test_variadic_function.zig -lc\n    1/1 test_variadic_function.test.variadic function...OK\n    All 1 tests passed.\n    Hello, world!\n\nShell\n\nVariadic functions can be implemented using [@cVaStart](#cVaStart), [@cVaEnd](#cVaEnd), [@cVaArg](#cVaArg) and [@cVaCopy](#cVaCopy).\n\n``` zig\nconst std = @import(\"std\");\nconst testing = std.testing;\nconst builtin = @import(\"builtin\");\n\nfn add(count: c_int, ...) callconv(.C) c_int {\n    var ap = @cVaStart();\n    defer @cVaEnd(&ap);\n    var i: usize = 0;\n    var sum: c_int = 0;\n    while (i < count) : (i += 1) {\n        sum += @cVaArg(&ap, c_int);\n    }\n    return sum;\n}\n\ntest \"defining a variadic function\" {\n    if (builtin.cpu.arch == .aarch64 and builtin.os.tag != .macos) {\n        // https://github.com/ziglang/zig/issues/14096\n        return error.SkipZigTest;\n    }\n    if (builtin.cpu.arch == .x86_64 and builtin.os.tag == .windows) {\n        // https://github.com/ziglang/zig/issues/16961\n        return error.SkipZigTest;\n    }\n\n    try std.testing.expectEqual(@as(c_int, 0), add(0));\n    try std.testing.expectEqual(@as(c_int, 1), add(1, @as(c_int, 1)));\n    try std.testing.expectEqual(@as(c_int, 3), add(2, @as(c_int, 1), @as(c_int, 2)));\n}\n```\n\ntest_defining_variadic_function.zig\n\n    $ zig test test_defining_variadic_function.zig\n    1/1 test_defining_variadic_function.test.defining a variadic function...OK\n    All 1 tests passed.\n\nShell\n\n### Exporting a C Library\n\nOne of the primary use cases for Zig is exporting a library with the C ABI for other programming languages to call into. The `export` keyword in front of functions, variables, and types causes them to be part of the library API:\n\n``` zig\nexport fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n```\n\nmathtest.zig\n\nTo make a static library:\n\n    $ zig build-lib mathtest.zig\n\nShell\n\nTo make a shared library:\n\n    $ zig build-lib mathtest.zig -dynamic\n\nShell\n\nHere is an example with the [Zig Build System](#Zig-Build-System):\n\n``` zig\n// This header is generated by zig from mathtest.zig\n#include \"mathtest.h\"\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    int32_t result = add(42, 1337);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n```\n\ntest.c\n\n``` zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const lib = b.addSharedLibrary(.{\n        .name = \"mathtest\",\n        .root_source_file = b.path(\"mathtest.zig\"),\n        .version = .{ .major = 1, .minor = 0, .patch = 0 },\n    });\n    const exe = b.addExecutable(.{\n        .name = \"test\",\n    });\n    exe.addCSourceFile(.{ .file = b.path(\"test.c\"), .flags = &.{\"-std=c99\"} });\n    exe.linkLibrary(lib);\n    exe.linkSystemLibrary(\"c\");\n\n    b.default_step.dependOn(&exe.step);\n\n    const run_cmd = exe.run();\n\n    const test_step = b.step(\"test\", \"Test the program\");\n    test_step.dependOn(&run_cmd.step);\n}\n```\n\nbuild_c.zig\n\n    $ zig build test\n    1379\n\nShell\n\nSee also:\n\n- [export](#export)\n\n### Mixing Object Files\n\nYou can mix Zig object files with any other object files that respect the C ABI. Example:\n\n``` zig\nconst base64 = @import(\"std\").base64;\n\nexport fn decode_base_64(\n    dest_ptr: [*]u8,\n    dest_len: usize,\n    source_ptr: [*]const u8,\n    source_len: usize,\n) usize {\n    const src = source_ptr[0..source_len];\n    const dest = dest_ptr[0..dest_len];\n    const base64_decoder = base64.standard.Decoder;\n    const decoded_size = base64_decoder.calcSizeForSlice(src) catch unreachable;\n    base64_decoder.decode(dest[0..decoded_size], src) catch unreachable;\n    return decoded_size;\n}\n```\n\nbase64.zig\n\n``` zig\n// This header is generated by zig from base64.zig\n#include \"base64.h\"\n\n#include <string.h>\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    const char *encoded = \"YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz\";\n    char buf[200];\n\n    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));\n    buf[len] = 0;\n    puts(buf);\n\n    return 0;\n}\n```\n\ntest.c\n\n``` zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const obj = b.addObject(.{\n        .name = \"base64\",\n        .root_source_file = b.path(\"base64.zig\"),\n    });\n\n    const exe = b.addExecutable(.{\n        .name = \"test\",\n    });\n    exe.addCSourceFile(.{ .file = b.path(\"test.c\"), .flags = &.{\"-std=c99\"} });\n    exe.addObject(obj);\n    exe.linkSystemLibrary(\"c\");\n    b.installArtifact(exe);\n}\n```\n\nbuild_object.zig\n\n    $ zig build\n    $ ./zig-out/bin/test\n    all your base are belong to us\n\nShell\n\nSee also:\n\n- [Targets](#Targets)\n- [Zig Build System](#Zig-Build-System)\n\n## WebAssembly\n\nZig supports building for WebAssembly out of the box.\n\n### Freestanding\n\nFor host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs.\n\n``` zig\nextern fn print(i32) void;\n\nexport fn add(a: i32, b: i32) void {\n    print(a + b);\n}\n```\n\nmath.zig\n\n    $ zig build-exe math.zig -target wasm32-freestanding -fno-entry --export=add\n\nShell\n\n``` zig\nconst fs = require('fs');\nconst source = fs.readFileSync(\"./math.wasm\");\nconst typedArray = new Uint8Array(source);\n\nWebAssembly.instantiate(typedArray, {\n  env: {\n    print: (result) => { console.log(`The result is ${result}`); }\n  }}).then(result => {\n  const add = result.instance.exports.add;\n  add(1, 2);\n});\n```\n\ntest.js\n\n    $ node test.js\n    The result is 3\n\nShell\n\n### WASI\n\nZig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};\n    const gpa = general_purpose_allocator.allocator();\n    const args = try std.process.argsAlloc(gpa);\n    defer std.process.argsFree(gpa, args);\n\n    for (args, 0..) |arg, i| {\n        std.debug.print(\"{}: {s}\\n\", .{ i, arg });\n    }\n}\n```\n\nwasi_args.zig\n\n    $ zig build-exe wasi_args.zig -target wasm32-wasi\n\nShell\n\n    $ wasmtime wasi_args.wasm 123 hello\n    0: wasi_args.wasm\n    1: 123\n    2: hello\n\nShell\n\nA more interesting example would be extracting the list of preopens from the runtime. This is now supported in the standard library via `std.fs.wasi.Preopens`:\n\n``` zig\nconst std = @import(\"std\");\nconst fs = std.fs;\n\npub fn main() !void {\n    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};\n    const gpa = general_purpose_allocator.allocator();\n\n    var arena_instance = std.heap.ArenaAllocator.init(gpa);\n    defer arena_instance.deinit();\n    const arena = arena_instance.allocator();\n\n    const preopens = try fs.wasi.preopensAlloc(arena);\n\n    for (preopens.names, 0..) |preopen, i| {\n        std.debug.print(\"{}: {s}\\n\", .{ i, preopen });\n    }\n}\n```\n\nwasi_preopens.zig\n\n    $ zig build-exe wasi_preopens.zig -target wasm32-wasi\n\nShell\n\n    $ wasmtime --dir=. wasi_preopens.wasm\n    0: stdin\n    1: stdout\n    2: stderr\n    3: .\n\nShell\n\n## Targets\n\n**Target** refers to the computer that will be used to run an executable. It is composed of the CPU architecture, the set of enabled CPU features, operating system, minimum and maximum operating system version, ABI, and ABI version.\n\nZig is a general-purpose programming language which means that it is designed to generate optimal code for a large set of targets. The command `zig targets` provides information about all of the targets the compiler is aware of.\n\nWhen no target option is provided to the compiler, the default choice is to target the **host computer**, meaning that the resulting executable will be *unsuitable for copying to a different computer*. In order to copy an executable to another computer, the compiler needs to know about the target requirements via the `-target` option.\n\nThe Zig Standard Library (`@import``(``\"std\"``)`) has cross-platform abstractions, making the same source code viable on many targets. Some code is more portable than other code. In general, Zig code is extremely portable compared to other programming languages.\n\nEach platform requires its own implementations to make Zig's cross-platform abstractions work. These implementations are at various degrees of completion. Each tagged release of the compiler comes with release notes that provide the full support table for each target.\n\n## Style Guide\n\nThese coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style.\n\n### Avoid Redundancy in Names\n\nAvoid these words in type names:\n\n- Value\n- Data\n- Context\n- Manager\n- utils, misc, or somebody's initials\n\nEverything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word that applies to all types.\n\nTemptation to use \"utilities\", \"miscellaneous\", or somebody's initials is a failure to categorize, or more commonly, overcategorization. Such declarations can live at the root of a module that needs them with no namespace needed.\n\n### Avoid Redundant Names in Fully-Qualified Namespaces\n\nEvery declaration is assigned a **fully qualified namespace** by the compiler, creating a tree structure. Choose names based on the fully-qualified namespace, and avoid redundant name segments.\n\n``` zig\nconst std = @import(\"std\");\n\npub const json = struct {\n    pub const JsonValue = union(enum) {\n        number: f64,\n        boolean: bool,\n        // ...\n    };\n};\n\npub fn main() void {\n    std.debug.print(\"{s}\\n\", .{@typeName(json.JsonValue)});\n}\n```\n\nredundant_fqn.zig\n\n    $ zig build-exe redundant_fqn.zig\n    $ ./redundant_fqn\n    redundant_fqn.json.JsonValue\n\nShell\n\nIn this example, \"json\" is repeated in the fully-qualified namespace. The solution is to delete `Json` from `JsonValue`. In this example we have an empty struct named `json` but remember that files also act as part of the fully-qualified namespace.\n\nThis example is an exception to the rule specified in [Avoid Redundancy in Names](#Avoid-Redundancy-in-Names). The meaning of the type has been reduced to its core: it is a json value. The name cannot be any more specific without being incorrect.\n\n### Whitespace\n\n- 4 space indentation\n- Open braces on same line, unless you need to wrap.\n- If a list of things is longer than 2, put each item on its own line and exercise the ability to put an extra comma at the end.\n- Line length: aim for 100; use common sense.\n\n### Names\n\nRoughly speaking: `camelCaseFunctionName`, `TitleCaseTypeName`, `snake_case_variable_name`. More precisely:\n\n- If `x` is a `type` then `x` should be `TitleCase`, unless it is a `struct` with 0 fields and is never meant to be instantiated, in which case it is considered to be a \"namespace\" and uses `snake_case`.\n- If `x` is callable, and `x`'s return type is `type`, then `x` should be `TitleCase`.\n- If `x` is otherwise callable, then `x` should be `camelCase`.\n- Otherwise, `x` should be `snake_case`.\n\nAcronyms, initialisms, proper nouns, or any other word that has capitalization rules in written English are subject to naming conventions just like any other word. Even acronyms that are only 2 letters long are subject to these conventions.\n\nFile names fall into two categories: types and namespaces. If the file (implicitly a struct) has top level fields, it should be named like any other struct with fields using `TitleCase`. Otherwise, it should use `snake_case`. Directory names should be `snake_case`.\n\nThese are general rules of thumb; if it makes sense to do something different, do what makes sense. For example, if there is an established convention such as `ENOENT`, follow the established convention.\n\n### Examples\n\n``` zig\nconst namespace_name = @import(\"dir_name/file_name.zig\");\nconst TypeName = @import(\"dir_name/TypeName.zig\");\nvar global_var: i32 = undefined;\nconst const_name = 42;\nconst primitive_type_alias = f32;\nconst string_alias = []u8;\n\nconst StructName = struct {\n    field: i32,\n};\nconst StructAlias = StructName;\n\nfn functionName(param_name: TypeName) void {\n    var functionPointer = functionName;\n    functionPointer();\n    functionPointer = otherFunction;\n    functionPointer();\n}\nconst functionAlias = functionName;\n\nfn ListTemplateFunction(comptime ChildType: type, comptime fixed_size: usize) type {\n    return List(ChildType, fixed_size);\n}\n\nfn ShortList(comptime T: type, comptime n: usize) type {\n    return struct {\n        field_name: [n]T,\n        fn methodName() void {}\n    };\n}\n\n// The word XML loses its casing when used in Zig identifiers.\nconst xml_document =\n    \\\\<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    \\\\<document>\n    \\\\</document>\n;\nconst XmlParser = struct {\n    field: i32,\n};\n\n// The initials BE (Big Endian) are just another word in Zig identifier names.\nfn readU32Be() u32 {}\n```\n\nstyle_example.zig\n\nSee the [Zig Standard Library](#Zig-Standard-Library) for more examples.\n\n### Doc Comment Guidance\n\n- Omit any information that is redundant based on the name of the thing being documented.\n- Duplicating information onto multiple similar functions is encouraged because it helps IDEs and other tools provide better help text.\n- Use the word **assume** to indicate invariants that cause [Undefined Behavior](#Undefined-Behavior) when violated.\n- Use the word **assert** to indicate invariants that cause *safety-checked* [Undefined Behavior](#Undefined-Behavior) when violated.\n\n## Source Encoding\n\nZig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error.\n\nThroughout all zig source code (including in comments), some code points are never allowed:\n\n- Ascii control characters, except for U+000a (LF), U+000d (CR), and U+0009 (HT): U+0000 - U+0008, U+000b - U+000c, U+000e - U+0001f, U+007f.\n- Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS).\n\nLF (byte value 0x0a, code point U+000a, `'\\n'`) is the line terminator in Zig source code. This byte value terminates every line of zig source code except the last line of the file. It is recommended that non-empty source files end with an empty line, which means the last byte would be 0x0a (LF).\n\nEach LF may be immediately preceded by a single CR (byte value 0x0d, code point U+000d, `'\\r'`) to form a Windows style line ending, but this is discouraged. Note that in multiline strings, CRLF sequences will be encoded as LF when compiled into a zig program. A CR in any other context is not allowed.\n\nHT hard tabs (byte value 0x09, code point U+0009, `'\\t'`) are interchangeable with SP spaces (byte value 0x20, code point U+0020, `' '`) as a token separator, but use of hard tabs is discouraged. See [Grammar](#Grammar).\n\nFor compatibility with other tools, the compiler ignores a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark is not allowed anywhere else in the source.\n\nNote that running zig fmt on a source file will implement all recommendations mentioned here.\n\nNote that a tool reading Zig source code can make assumptions if the source code is assumed to be correct Zig code. For example, when identifying the ends of lines, a tool can use a naive search such as `/\\n/`, or an [advanced](https://msdn.microsoft.com/en-us/library/dd409797.aspx) search such as `/\\r\\n?|[\\n\\u0085\\u2028\\u2029]/`, and in either case line endings will be correctly identified. For another example, when identifying the whitespace before the first token on a line, a tool can either use a naive search such as `/[ \\t]/`, or an [advanced](https://tc39.es/ecma262/#sec-characterclassescape) search such as `/\\s/`, and in either case whitespace will be correctly identified.\n\n## Keyword Reference\n\n[TABLE]\n\n## Appendix\n\n### Containers\n\nA *container* in Zig is any syntactical construct that acts as a namespace to hold [variable](#Container-Level-Variables) and [function](#Functions) declarations. Containers are also type definitions which can be instantiated. [Structs](#struct), [enums](#enum), [unions](#union), [opaques](#opaque), and even Zig source files themselves are containers.\n\nAlthough containers (except Zig source files) use curly braces to surround their definition, they should not be confused with [blocks](#Blocks) or functions. Containers do not contain statements.\n\n### Grammar\n\n``` zig\nRoot <- skip container_doc_comment? ContainerMembers eof\n\n# *** Top level ***\nContainerMembers <- ContainerDeclaration* (ContainerField COMMA)* (ContainerField / ContainerDeclaration*)\n\nContainerDeclaration <- TestDecl / ComptimeDecl / doc_comment? KEYWORD_pub? Decl\n\nTestDecl <- KEYWORD_test (STRINGLITERALSINGLE / IDENTIFIER)? Block\n\nComptimeDecl <- KEYWORD_comptime Block\n\nDecl\n    <- (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE? / KEYWORD_inline / KEYWORD_noinline)? FnProto (SEMICOLON / Block)\n     / (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE?)? KEYWORD_threadlocal? GlobalVarDecl\n     / KEYWORD_usingnamespace Expr SEMICOLON\n\nFnProto <- KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? AddrSpace? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr\n\nVarDeclProto <- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? AddrSpace? LinkSection?\n\nGlobalVarDecl <- VarDeclProto (EQUAL Expr)? SEMICOLON\n\nContainerField <- doc_comment? KEYWORD_comptime? !KEYWORD_fn (IDENTIFIER COLON)? TypeExpr ByteAlign? (EQUAL Expr)?\n\n# *** Block Level ***\nStatement\n    <- KEYWORD_comptime ComptimeStatement\n     / KEYWORD_nosuspend BlockExprStatement\n     / KEYWORD_suspend BlockExprStatement\n     / KEYWORD_defer BlockExprStatement\n     / KEYWORD_errdefer Payload? BlockExprStatement\n     / IfStatement\n     / LabeledStatement\n     / SwitchExpr\n     / VarDeclExprStatement\n\nComptimeStatement\n    <- BlockExpr\n     / VarDeclExprStatement\n\nIfStatement\n    <- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?\n     / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )\n\nLabeledStatement <- BlockLabel? (Block / LoopStatement)\n\nLoopStatement <- KEYWORD_inline? (ForStatement / WhileStatement)\n\nForStatement\n    <- ForPrefix BlockExpr ( KEYWORD_else Statement )?\n     / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )\n\nWhileStatement\n    <- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?\n     / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )\n\nBlockExprStatement\n    <- BlockExpr\n     / AssignExpr SEMICOLON\n\nBlockExpr <- BlockLabel? Block\n\n# An expression, assignment, or any destructure, as a statement.\nVarDeclExprStatement\n    <- VarDeclProto (COMMA (VarDeclProto / Expr))* EQUAL Expr SEMICOLON\n     / Expr (AssignOp Expr / (COMMA (VarDeclProto / Expr))+ EQUAL Expr)? SEMICOLON\n\n# *** Expression Level ***\n\n# An assignment or a destructure whose LHS are all lvalue expressions.\nAssignExpr <- Expr (AssignOp Expr / (COMMA Expr)+ EQUAL Expr)?\n\nSingleAssignExpr <- Expr (AssignOp Expr)?\n\nExpr <- BoolOrExpr\n\nBoolOrExpr <- BoolAndExpr (KEYWORD_or BoolAndExpr)*\n\nBoolAndExpr <- CompareExpr (KEYWORD_and CompareExpr)*\n\nCompareExpr <- BitwiseExpr (CompareOp BitwiseExpr)?\n\nBitwiseExpr <- BitShiftExpr (BitwiseOp BitShiftExpr)*\n\nBitShiftExpr <- AdditionExpr (BitShiftOp AdditionExpr)*\n\nAdditionExpr <- MultiplyExpr (AdditionOp MultiplyExpr)*\n\nMultiplyExpr <- PrefixExpr (MultiplyOp PrefixExpr)*\n\nPrefixExpr <- PrefixOp* PrimaryExpr\n\nPrimaryExpr\n    <- AsmExpr\n     / IfExpr\n     / KEYWORD_break BreakLabel? Expr?\n     / KEYWORD_comptime Expr\n     / KEYWORD_nosuspend Expr\n     / KEYWORD_continue BreakLabel?\n     / KEYWORD_resume Expr\n     / KEYWORD_return Expr?\n     / BlockLabel? LoopExpr\n     / Block\n     / CurlySuffixExpr\n\nIfExpr <- IfPrefix Expr (KEYWORD_else Payload? Expr)?\n\nBlock <- LBRACE Statement* RBRACE\n\nLoopExpr <- KEYWORD_inline? (ForExpr / WhileExpr)\n\nForExpr <- ForPrefix Expr (KEYWORD_else Expr)?\n\nWhileExpr <- WhilePrefix Expr (KEYWORD_else Payload? Expr)?\n\nCurlySuffixExpr <- TypeExpr InitList?\n\nInitList\n    <- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE\n     / LBRACE Expr (COMMA Expr)* COMMA? RBRACE\n     / LBRACE RBRACE\n\nTypeExpr <- PrefixTypeOp* ErrorUnionExpr\n\nErrorUnionExpr <- SuffixExpr (EXCLAMATIONMARK TypeExpr)?\n\nSuffixExpr\n    <- KEYWORD_async PrimaryTypeExpr SuffixOp* FnCallArguments\n     / PrimaryTypeExpr (SuffixOp / FnCallArguments)*\n\nPrimaryTypeExpr\n    <- BUILTINIDENTIFIER FnCallArguments\n     / CHAR_LITERAL\n     / ContainerDecl\n     / DOT IDENTIFIER\n     / DOT InitList\n     / ErrorSetDecl\n     / FLOAT\n     / FnProto\n     / GroupedExpr\n     / LabeledTypeExpr\n     / IDENTIFIER\n     / IfTypeExpr\n     / INTEGER\n     / KEYWORD_comptime TypeExpr\n     / KEYWORD_error DOT IDENTIFIER\n     / KEYWORD_anyframe\n     / KEYWORD_unreachable\n     / STRINGLITERAL\n     / SwitchExpr\n\nContainerDecl <- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto\n\nErrorSetDecl <- KEYWORD_error LBRACE IdentifierList RBRACE\n\nGroupedExpr <- LPAREN Expr RPAREN\n\nIfTypeExpr <- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?\n\nLabeledTypeExpr\n    <- BlockLabel Block\n     / BlockLabel? LoopTypeExpr\n\nLoopTypeExpr <- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)\n\nForTypeExpr <- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?\n\nWhileTypeExpr <- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?\n\nSwitchExpr <- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE\n\n# *** Assembly ***\nAsmExpr <- KEYWORD_asm KEYWORD_volatile? LPAREN Expr AsmOutput? RPAREN\n\nAsmOutput <- COLON AsmOutputList AsmInput?\n\nAsmOutputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN\n\nAsmInput <- COLON AsmInputList AsmClobbers?\n\nAsmInputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN\n\nAsmClobbers <- COLON StringList\n\n# *** Helper grammar ***\nBreakLabel <- COLON IDENTIFIER\n\nBlockLabel <- IDENTIFIER COLON\n\nFieldInit <- DOT IDENTIFIER EQUAL Expr\n\nWhileContinueExpr <- COLON LPAREN AssignExpr RPAREN\n\nLinkSection <- KEYWORD_linksection LPAREN Expr RPAREN\n\nAddrSpace <- KEYWORD_addrspace LPAREN Expr RPAREN\n\n# Fn specific\nCallConv <- KEYWORD_callconv LPAREN Expr RPAREN\n\nParamDecl\n    <- doc_comment? (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType\n     / DOT3\n\nParamType\n    <- KEYWORD_anytype\n     / TypeExpr\n\n# Control flow prefixes\nIfPrefix <- KEYWORD_if LPAREN Expr RPAREN PtrPayload?\n\nWhilePrefix <- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?\n\nForPrefix <- KEYWORD_for LPAREN ForArgumentsList RPAREN PtrListPayload\n\n# Payloads\nPayload <- PIPE IDENTIFIER PIPE\n\nPtrPayload <- PIPE ASTERISK? IDENTIFIER PIPE\n\nPtrIndexPayload <- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE\n\nPtrListPayload <- PIPE ASTERISK? IDENTIFIER (COMMA ASTERISK? IDENTIFIER)* COMMA? PIPE\n\n# Switch specific\nSwitchProng <- KEYWORD_inline? SwitchCase EQUALRARROW PtrIndexPayload? SingleAssignExpr\n\nSwitchCase\n    <- SwitchItem (COMMA SwitchItem)* COMMA?\n     / KEYWORD_else\n\nSwitchItem <- Expr (DOT3 Expr)?\n\n# For specific\nForArgumentsList <- ForItem (COMMA ForItem)* COMMA?\n\nForItem <- Expr (DOT2 Expr?)?\n\n# Operators\nAssignOp\n    <- ASTERISKEQUAL\n     / ASTERISKPIPEEQUAL\n     / SLASHEQUAL\n     / PERCENTEQUAL\n     / PLUSEQUAL\n     / PLUSPIPEEQUAL\n     / MINUSEQUAL\n     / MINUSPIPEEQUAL\n     / LARROW2EQUAL\n     / LARROW2PIPEEQUAL\n     / RARROW2EQUAL\n     / AMPERSANDEQUAL\n     / CARETEQUAL\n     / PIPEEQUAL\n     / ASTERISKPERCENTEQUAL\n     / PLUSPERCENTEQUAL\n     / MINUSPERCENTEQUAL\n     / EQUAL\n\nCompareOp\n    <- EQUALEQUAL\n     / EXCLAMATIONMARKEQUAL\n     / LARROW\n     / RARROW\n     / LARROWEQUAL\n     / RARROWEQUAL\n\nBitwiseOp\n    <- AMPERSAND\n     / CARET\n     / PIPE\n     / KEYWORD_orelse\n     / KEYWORD_catch Payload?\n\nBitShiftOp\n    <- LARROW2\n     / RARROW2\n     / LARROW2PIPE\n\nAdditionOp\n    <- PLUS\n     / MINUS\n     / PLUS2\n     / PLUSPERCENT\n     / MINUSPERCENT\n     / PLUSPIPE\n     / MINUSPIPE\n\nMultiplyOp\n    <- PIPE2\n     / ASTERISK\n     / SLASH\n     / PERCENT\n     / ASTERISK2\n     / ASTERISKPERCENT\n     / ASTERISKPIPE\n\nPrefixOp\n    <- EXCLAMATIONMARK\n     / MINUS\n     / TILDE\n     / MINUSPERCENT\n     / AMPERSAND\n     / KEYWORD_try\n     / KEYWORD_await\n\nPrefixTypeOp\n    <- QUESTIONMARK\n     / KEYWORD_anyframe MINUSRARROW\n     / SliceTypeStart (ByteAlign / AddrSpace / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*\n     / PtrTypeStart (AddrSpace / KEYWORD_align LPAREN Expr (COLON Expr COLON Expr)? RPAREN / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*\n     / ArrayTypeStart\n\nSuffixOp\n    <- LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET\n     / DOT IDENTIFIER\n     / DOTASTERISK\n     / DOTQUESTIONMARK\n\nFnCallArguments <- LPAREN ExprList RPAREN\n\n# Ptr specific\nSliceTypeStart <- LBRACKET (COLON Expr)? RBRACKET\n\nPtrTypeStart\n    <- ASTERISK\n     / ASTERISK2\n     / LBRACKET ASTERISK (LETTERC / COLON Expr)? RBRACKET\n\nArrayTypeStart <- LBRACKET Expr (COLON Expr)? RBRACKET\n\n# ContainerDecl specific\nContainerDeclAuto <- ContainerDeclType LBRACE container_doc_comment? ContainerMembers RBRACE\n\nContainerDeclType\n    <- KEYWORD_struct (LPAREN Expr RPAREN)?\n     / KEYWORD_opaque\n     / KEYWORD_enum (LPAREN Expr RPAREN)?\n     / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?\n\n# Alignment\nByteAlign <- KEYWORD_align LPAREN Expr RPAREN\n\n# Lists\nIdentifierList <- (doc_comment? IDENTIFIER COMMA)* (doc_comment? IDENTIFIER)?\n\nSwitchProngList <- (SwitchProng COMMA)* SwitchProng?\n\nAsmOutputList <- (AsmOutputItem COMMA)* AsmOutputItem?\n\nAsmInputList <- (AsmInputItem COMMA)* AsmInputItem?\n\nStringList <- (STRINGLITERAL COMMA)* STRINGLITERAL?\n\nParamDeclList <- (ParamDecl COMMA)* ParamDecl?\n\nExprList <- (Expr COMMA)* Expr?\n\n# *** Tokens ***\neof <- !.\nbin <- [01]\nbin_ <- '_'? bin\noct <- [0-7]\noct_ <- '_'? oct\nhex <- [0-9a-fA-F]\nhex_ <- '_'? hex\ndec <- [0-9]\ndec_ <- '_'? dec\n\nbin_int <- bin bin_*\noct_int <- oct oct_*\ndec_int <- dec dec_*\nhex_int <- hex hex_*\n\nox80_oxBF <- [\\200-\\277]\noxF4 <- '\\364'\nox80_ox8F <- [\\200-\\217]\noxF1_oxF3 <- [\\361-\\363]\noxF0 <- '\\360'\nox90_0xBF <- [\\220-\\277]\noxEE_oxEF <- [\\356-\\357]\noxED <- '\\355'\nox80_ox9F <- [\\200-\\237]\noxE1_oxEC <- [\\341-\\354]\noxE0 <- '\\340'\noxA0_oxBF <- [\\240-\\277]\noxC2_oxDF <- [\\302-\\337]\n\n# From https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/\n# First Byte      Second Byte     Third Byte      Fourth Byte\n# [0x00,0x7F]\n# [0xC2,0xDF]     [0x80,0xBF]\n#    0xE0         [0xA0,0xBF]     [0x80,0xBF]\n# [0xE1,0xEC]     [0x80,0xBF]     [0x80,0xBF]\n#    0xED         [0x80,0x9F]     [0x80,0xBF]\n# [0xEE,0xEF]     [0x80,0xBF]     [0x80,0xBF]\n#    0xF0         [0x90,0xBF]     [0x80,0xBF]     [0x80,0xBF]\n# [0xF1,0xF3]     [0x80,0xBF]     [0x80,0xBF]     [0x80,0xBF]\n#    0xF4         [0x80,0x8F]     [0x80,0xBF]     [0x80,0xBF]\n\nmb_utf8_literal <-\n       oxF4      ox80_ox8F ox80_oxBF ox80_oxBF\n     / oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF\n     / oxF0      ox90_0xBF ox80_oxBF ox80_oxBF\n     / oxEE_oxEF ox80_oxBF ox80_oxBF\n     / oxED      ox80_ox9F ox80_oxBF\n     / oxE1_oxEC ox80_oxBF ox80_oxBF\n     / oxE0      oxA0_oxBF ox80_oxBF\n     / oxC2_oxDF ox80_oxBF\n\nascii_char_not_nl_slash_squote <- [\\000-\\011\\013-\\046\\050-\\133\\135-\\177]\n\nchar_escape\n    <- \"\\\\x\" hex hex\n     / \"\\\\u{\" hex+ \"}\"\n     / \"\\\\\" [nr\\\\t'\"]\nchar_char\n    <- mb_utf8_literal\n     / char_escape\n     / ascii_char_not_nl_slash_squote\n\nstring_char\n    <- char_escape\n     / [^\\\\\"\\n]\n\ncontainer_doc_comment <- ('//!' [^\\n]* [ \\n]* skip)+\ndoc_comment <- ('///' [^\\n]* [ \\n]* skip)+\nline_comment <- '//' ![!/][^\\n]* / '////' [^\\n]*\nline_string <- (\"\\\\\\\\\" [^\\n]* [ \\n]*)+\nskip <- ([ \\n] / line_comment)*\n\nCHAR_LITERAL <- \"'\" char_char \"'\" skip\nFLOAT\n    <- \"0x\" hex_int \".\" hex_int ([pP] [-+]? dec_int)? skip\n     /      dec_int \".\" dec_int ([eE] [-+]? dec_int)? skip\n     / \"0x\" hex_int [pP] [-+]? dec_int skip\n     /      dec_int [eE] [-+]? dec_int skip\nINTEGER\n    <- \"0b\" bin_int skip\n     / \"0o\" oct_int skip\n     / \"0x\" hex_int skip\n     /      dec_int   skip\nSTRINGLITERALSINGLE <- \"\\\"\" string_char* \"\\\"\" skip\nSTRINGLITERAL\n    <- STRINGLITERALSINGLE\n     / (line_string                 skip)+\nIDENTIFIER\n    <- !keyword [A-Za-z_] [A-Za-z0-9_]* skip\n     / \"@\" STRINGLITERALSINGLE\nBUILTINIDENTIFIER <- \"@\"[A-Za-z_][A-Za-z0-9_]* skip\n\n\nAMPERSAND            <- '&'      ![=]      skip\nAMPERSANDEQUAL       <- '&='               skip\nASTERISK             <- '*'      ![*%=|]   skip\nASTERISK2            <- '**'               skip\nASTERISKEQUAL        <- '*='               skip\nASTERISKPERCENT      <- '*%'     ![=]      skip\nASTERISKPERCENTEQUAL <- '*%='              skip\nASTERISKPIPE         <- '*|'     ![=]      skip\nASTERISKPIPEEQUAL    <- '*|='              skip\nCARET                <- '^'      ![=]      skip\nCARETEQUAL           <- '^='               skip\nCOLON                <- ':'                skip\nCOMMA                <- ','                skip\nDOT                  <- '.'      ![*.?]    skip\nDOT2                 <- '..'     ![.]      skip\nDOT3                 <- '...'              skip\nDOTASTERISK          <- '.*'               skip\nDOTQUESTIONMARK      <- '.?'               skip\nEQUAL                <- '='      ![>=]     skip\nEQUALEQUAL           <- '=='               skip\nEQUALRARROW          <- '=>'               skip\nEXCLAMATIONMARK      <- '!'      ![=]      skip\nEXCLAMATIONMARKEQUAL <- '!='               skip\nLARROW               <- '<'      ![<=]     skip\nLARROW2              <- '<<'     ![=|]     skip\nLARROW2EQUAL         <- '<<='              skip\nLARROW2PIPE          <- '<<|'    ![=]      skip\nLARROW2PIPEEQUAL     <- '<<|='             skip\nLARROWEQUAL          <- '<='               skip\nLBRACE               <- '{'                skip\nLBRACKET             <- '['                skip\nLPAREN               <- '('                skip\nMINUS                <- '-'      ![%=>|]   skip\nMINUSEQUAL           <- '-='               skip\nMINUSPERCENT         <- '-%'     ![=]      skip\nMINUSPERCENTEQUAL    <- '-%='              skip\nMINUSPIPE            <- '-|'     ![=]      skip\nMINUSPIPEEQUAL       <- '-|='              skip\nMINUSRARROW          <- '->'               skip\nPERCENT              <- '%'      ![=]      skip\nPERCENTEQUAL         <- '%='               skip\nPIPE                 <- '|'      ![|=]     skip\nPIPE2                <- '||'               skip\nPIPEEQUAL            <- '|='               skip\nPLUS                 <- '+'      ![%+=|]   skip\nPLUS2                <- '++'               skip\nPLUSEQUAL            <- '+='               skip\nPLUSPERCENT          <- '+%'     ![=]      skip\nPLUSPERCENTEQUAL     <- '+%='              skip\nPLUSPIPE             <- '+|'     ![=]      skip\nPLUSPIPEEQUAL        <- '+|='              skip\nLETTERC              <- 'c'                skip\nQUESTIONMARK         <- '?'                skip\nRARROW               <- '>'      ![>=]     skip\nRARROW2              <- '>>'     ![=]      skip\nRARROW2EQUAL         <- '>>='              skip\nRARROWEQUAL          <- '>='               skip\nRBRACE               <- '}'                skip\nRBRACKET             <- ']'                skip\nRPAREN               <- ')'                skip\nSEMICOLON            <- ';'                skip\nSLASH                <- '/'      ![=]      skip\nSLASHEQUAL           <- '/='               skip\nTILDE                <- '~'                skip\n\nend_of_word <- ![a-zA-Z0-9_] skip\nKEYWORD_addrspace   <- 'addrspace'   end_of_word\nKEYWORD_align       <- 'align'       end_of_word\nKEYWORD_allowzero   <- 'allowzero'   end_of_word\nKEYWORD_and         <- 'and'         end_of_word\nKEYWORD_anyframe    <- 'anyframe'    end_of_word\nKEYWORD_anytype     <- 'anytype'     end_of_word\nKEYWORD_asm         <- 'asm'         end_of_word\nKEYWORD_async       <- 'async'       end_of_word\nKEYWORD_await       <- 'await'       end_of_word\nKEYWORD_break       <- 'break'       end_of_word\nKEYWORD_callconv    <- 'callconv'    end_of_word\nKEYWORD_catch       <- 'catch'       end_of_word\nKEYWORD_comptime    <- 'comptime'    end_of_word\nKEYWORD_const       <- 'const'       end_of_word\nKEYWORD_continue    <- 'continue'    end_of_word\nKEYWORD_defer       <- 'defer'       end_of_word\nKEYWORD_else        <- 'else'        end_of_word\nKEYWORD_enum        <- 'enum'        end_of_word\nKEYWORD_errdefer    <- 'errdefer'    end_of_word\nKEYWORD_error       <- 'error'       end_of_word\nKEYWORD_export      <- 'export'      end_of_word\nKEYWORD_extern      <- 'extern'      end_of_word\nKEYWORD_fn          <- 'fn'          end_of_word\nKEYWORD_for         <- 'for'         end_of_word\nKEYWORD_if          <- 'if'          end_of_word\nKEYWORD_inline      <- 'inline'      end_of_word\nKEYWORD_noalias     <- 'noalias'     end_of_word\nKEYWORD_nosuspend   <- 'nosuspend'   end_of_word\nKEYWORD_noinline    <- 'noinline'    end_of_word\nKEYWORD_opaque      <- 'opaque'      end_of_word\nKEYWORD_or          <- 'or'          end_of_word\nKEYWORD_orelse      <- 'orelse'      end_of_word\nKEYWORD_packed      <- 'packed'      end_of_word\nKEYWORD_pub         <- 'pub'         end_of_word\nKEYWORD_resume      <- 'resume'      end_of_word\nKEYWORD_return      <- 'return'      end_of_word\nKEYWORD_linksection <- 'linksection' end_of_word\nKEYWORD_struct      <- 'struct'      end_of_word\nKEYWORD_suspend     <- 'suspend'     end_of_word\nKEYWORD_switch      <- 'switch'      end_of_word\nKEYWORD_test        <- 'test'        end_of_word\nKEYWORD_threadlocal <- 'threadlocal' end_of_word\nKEYWORD_try         <- 'try'         end_of_word\nKEYWORD_union       <- 'union'       end_of_word\nKEYWORD_unreachable <- 'unreachable' end_of_word\nKEYWORD_usingnamespace <- 'usingnamespace' end_of_word\nKEYWORD_var         <- 'var'         end_of_word\nKEYWORD_volatile    <- 'volatile'    end_of_word\nKEYWORD_while       <- 'while'       end_of_word\n\nkeyword <- KEYWORD_addrspace / KEYWORD_align / KEYWORD_allowzero / KEYWORD_and\n         / KEYWORD_anyframe / KEYWORD_anytype / KEYWORD_asm / KEYWORD_async\n         / KEYWORD_await / KEYWORD_break / KEYWORD_callconv / KEYWORD_catch\n         / KEYWORD_comptime / KEYWORD_const / KEYWORD_continue / KEYWORD_defer\n         / KEYWORD_else / KEYWORD_enum / KEYWORD_errdefer / KEYWORD_error / KEYWORD_export\n         / KEYWORD_extern / KEYWORD_fn / KEYWORD_for / KEYWORD_if\n         / KEYWORD_inline / KEYWORD_noalias / KEYWORD_nosuspend / KEYWORD_noinline\n         / KEYWORD_opaque / KEYWORD_or / KEYWORD_orelse / KEYWORD_packed\n         / KEYWORD_pub / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection\n         / KEYWORD_struct / KEYWORD_suspend / KEYWORD_switch / KEYWORD_test\n         / KEYWORD_threadlocal / KEYWORD_try / KEYWORD_union / KEYWORD_unreachable\n         / KEYWORD_usingnamespace / KEYWORD_var / KEYWORD_volatile / KEYWORD_while\n```\n\ngrammar.y\n\n### Zen\n\n- Communicate intent precisely.\n- Edge cases matter.\n- Favor reading code over writing code.\n- Only one obvious way to do things.\n- Runtime crashes are better than bugs.\n- Compile errors are better than runtime crashes.\n- Incremental improvements.\n- Avoid local maximums.\n- Reduce the amount one must remember.\n- Focus on code rather than style.\n- Resource allocation may fail; resource deallocation must succeed.\n- Memory is a resource.\n- Together we serve the users.\n\n© 2015–2024, Zig contributors  \nLicensed under the MIT License.  \n[https://ziglang.org/documentation/0.13.0/](https://ziglang.org/documentation/0.13.0/)"
- name: Targets
  id: index#Targets
  summary: Target refers to the computer that will be used to run an executable
  description: |-
    ## Targets

    **Target** refers to the computer that will be used to run an executable. It is composed of the CPU architecture, the set of enabled CPU features, operating system, minimum and maximum operating system version, ABI, and ABI version.

    Zig is a general-purpose programming language which means that it is designed to generate optimal code for a large set of targets. The command `zig targets` provides information about all of the targets the compiler is aware of.

    When no target option is provided to the compiler, the default choice is to target the **host computer**, meaning that the resulting executable will be *unsuitable for copying to a different computer*. In order to copy an executable to another computer, the compiler needs to know about the target requirements via the `-target` option.

    The Zig Standard Library (`@import``(``"std"``)`) has cross-platform abstractions, making the same source code viable on many targets. Some code is more portable than other code. In general, Zig code is extremely portable compared to other programming languages.

    Each platform requires its own implementations to make Zig's cross-platform abstractions work. These implementations are at various degrees of completion. Each tagged release of the compiler comes with release notes that provide the full support table for each target.
- name: Undefined Behavior
  id: index#Undefined-Behavior
  summary: Zig has many instances of undefined behavior
  description: "## Undefined Behavior\n\nZig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with [@setRuntimeSafety](#setRuntimeSafety). The [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) build modes disable all safety checks (except where overridden by [@setRuntimeSafety](#setRuntimeSafety)) in order to facilitate optimizations.\n\nWhen a safety check fails, Zig crashes with a stack trace, like this:\n\n``` zig\ntest \"safety check\" {\n    unreachable;\n}\n```\n\ntest_undefined_behavior.zig\n\n            $ zig test test_undefined_behavior.zig\n    1/1 test_undefined_behavior.test.safety check...thread 3571226 panic: reached unreachable code\n    /home/andy/src/zig/doc/langref/test_undefined_behavior.zig:2:5: 0x103ce30 in test.safety check (test)\n        unreachable;\n        ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048260 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e21b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d359 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cec1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/a71f9f37afd5b3c603d2b9ea72373fa7/test\n\n          \n\nShell"
- name: 'Undefined Behavior: Attempt to Unwrap Error'
  id: index#Attempt-to-Unwrap-Error
  summary: null
  description: "### Attempt to Unwrap Error\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const number = getNumberOrFail() catch unreachable;\n    _ = number;\n}\n\nfn getNumberOrFail() !i32 {\n    return error.UnableToReturnNumber;\n}\n```\n\ntest_comptime_unwrap_error.zig\n\n            $ zig test test_comptime_unwrap_error.zig\n    doc/langref/test_comptime_unwrap_error.zig:2:44: error: caught unexpected error 'UnableToReturnNumber'\n        const number = getNumberOrFail() catch unreachable;\n                                               ^~~~~~~~~~~\n    doc/langref/test_comptime_unwrap_error.zig:7:18: note: error returned here\n        return error.UnableToReturnNumber;\n                     ^~~~~~~~~~~~~~~~~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    const number = getNumberOrFail() catch unreachable;\n    std.debug.print(\"value: {}\\n\", .{number});\n}\n\nfn getNumberOrFail() !i32 {\n    return error.UnableToReturnNumber;\n}\n```\n\nruntime_unwrap_error.zig\n\n            $ zig build-exe runtime_unwrap_error.zig\n    $ ./runtime_unwrap_error\n    thread 3577877 panic: attempt to unwrap error: UnableToReturnNumber\n    /home/andy/src/zig/doc/langref/runtime_unwrap_error.zig:9:5: 0x103738f in getNumberOrFail (runtime_unwrap_error)\n        return error.UnableToReturnNumber;\n        ^\n    /home/andy/src/zig/doc/langref/runtime_unwrap_error.zig:4:44: 0x1035301 in main (runtime_unwrap_error)\n        const number = getNumberOrFail() catch unreachable;\n                                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034b49 in posixCallMainAndExit (runtime_unwrap_error)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10346b1 in _start (runtime_unwrap_error)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell\n\nOne way to avoid this crash is to test for an error instead of assuming a successful result, with the `if` expression:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    const result = getNumberOrFail();\n\n    if (result) |number| {\n        print(\"got number: {}\\n\", .{number});\n    } else |err| {\n        print(\"got error: {s}\\n\", .{@errorName(err)});\n    }\n}\n\nfn getNumberOrFail() !i32 {\n    return error.UnableToReturnNumber;\n}\n```\n\ntesting_error_with_if.zig\n\n            $ zig build-exe testing_error_with_if.zig\n    $ ./testing_error_with_if\n    got error: UnableToReturnNumber\n\n          \n\nShell\n\nSee also:\n\n- [Errors](#Errors)\n\n&nbsp;"
- name: 'Undefined Behavior: Attempt to Unwrap Null'
  id: index#Attempt-to-Unwrap-Null
  summary: null
  description: "### Attempt to Unwrap Null\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const optional_number: ?i32 = null;\n    const number = optional_number.?;\n    _ = number;\n}\n```\n\ntest_comptime_unwrap_null.zig\n\n            $ zig test test_comptime_unwrap_null.zig\n    doc/langref/test_comptime_unwrap_null.zig:3:35: error: unable to unwrap null\n        const number = optional_number.?;\n                       ~~~~~~~~~~~~~~~^~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var optional_number: ?i32 = null;\n    _ = &optional_number;\n    const number = optional_number.?;\n    std.debug.print(\"value: {}\\n\", .{number});\n}\n```\n\nruntime_unwrap_null.zig\n\n            $ zig build-exe runtime_unwrap_null.zig\n    $ ./runtime_unwrap_null\n    thread 3570514 panic: attempt to use null value\n    /home/andy/src/zig/doc/langref/runtime_unwrap_null.zig:6:35: 0x1035272 in main (runtime_unwrap_null)\n        const number = optional_number.?;\n                                      ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ad9 in posixCallMainAndExit (runtime_unwrap_null)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034641 in _start (runtime_unwrap_null)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell\n\nOne way to avoid this crash is to test for null instead of assuming non-null, with the `if` expression:\n\n``` zig\nconst print = @import(\"std\").debug.print;\npub fn main() void {\n    const optional_number: ?i32 = null;\n\n    if (optional_number) |number| {\n        print(\"got number: {}\\n\", .{number});\n    } else {\n        print(\"it's null\\n\", .{});\n    }\n}\n```\n\ntesting_null_with_if.zig\n\n            $ zig build-exe testing_null_with_if.zig\n    $ ./testing_null_with_if\n    it's null\n\n          \n\nShell\n\nSee also:\n\n- [Optionals](#Optionals)\n\n&nbsp;"
- name: 'Undefined Behavior: Cast Negative Number to Unsigned Integer'
  id: index#Cast-Negative-Number-to-Unsigned-Integer
  summary: To obtain the maximum value of an unsigned integer, use std.math.maxInt
  description: "### Cast Negative Number to Unsigned Integer\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const value: i32 = -1;\n    const unsigned: u32 = @intCast(value);\n    _ = unsigned;\n}\n```\n\ntest_comptime_invalid_cast.zig\n\n            $ zig test test_comptime_invalid_cast.zig\n    doc/langref/test_comptime_invalid_cast.zig:3:36: error: type 'u32' cannot represent integer value '-1'\n        const unsigned: u32 = @intCast(value);\n                                       ^~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var value: i32 = -1; // runtime-known\n    _ = &value;\n    const unsigned: u32 = @intCast(value);\n    std.debug.print(\"value: {}\\n\", .{unsigned});\n}\n```\n\nruntime_invalid_cast.zig\n\n            $ zig build-exe runtime_invalid_cast.zig\n    $ ./runtime_invalid_cast\n    thread 3567914 panic: attempt to cast negative value to unsigned integer\n    /home/andy/src/zig/doc/langref/runtime_invalid_cast.zig:6:27: 0x10351e2 in main (runtime_invalid_cast)\n        const unsigned: u32 = @intCast(value);\n                              ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (runtime_invalid_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (runtime_invalid_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell\n\nTo obtain the maximum value of an unsigned integer, use `std.math.maxInt`."
- name: 'Undefined Behavior: Cast Truncates Data'
  id: index#Cast-Truncates-Data
  summary: To truncate bits, use @truncate
  description: "### Cast Truncates Data\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const spartan_count: u16 = 300;\n    const byte: u8 = @intCast(spartan_count);\n    _ = byte;\n}\n```\n\ntest_comptime_invalid_cast_truncate.zig\n\n            $ zig test test_comptime_invalid_cast_truncate.zig\n    doc/langref/test_comptime_invalid_cast_truncate.zig:3:31: error: type 'u8' cannot represent integer value '300'\n        const byte: u8 = @intCast(spartan_count);\n                                  ^~~~~~~~~~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var spartan_count: u16 = 300; // runtime-known\n    _ = &spartan_count;\n    const byte: u8 = @intCast(spartan_count);\n    std.debug.print(\"value: {}\\n\", .{byte});\n}\n```\n\nruntime_invalid_cast_truncate.zig\n\n            $ zig build-exe runtime_invalid_cast_truncate.zig\n    $ ./runtime_invalid_cast_truncate\n    thread 3576020 panic: integer cast truncated bits\n    /home/andy/src/zig/doc/langref/runtime_invalid_cast_truncate.zig:6:22: 0x1035275 in main (runtime_invalid_cast_truncate)\n        const byte: u8 = @intCast(spartan_count);\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ad9 in posixCallMainAndExit (runtime_invalid_cast_truncate)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034641 in _start (runtime_invalid_cast_truncate)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell\n\nTo truncate bits, use [@truncate](#truncate)."
- name: 'Undefined Behavior: Division by Zero'
  id: index#Division-by-Zero
  summary: null
  description: "### Division by Zero\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const a: i32 = 1;\n    const b: i32 = 0;\n    const c = a / b;\n    _ = c;\n}\n```\n\ntest_comptime_division_by_zero.zig\n\n            $ zig test test_comptime_division_by_zero.zig\n    doc/langref/test_comptime_division_by_zero.zig:4:19: error: division by zero here causes undefined behavior\n        const c = a / b;\n                      ^\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var a: u32 = 1;\n    var b: u32 = 0;\n    _ = .{ &a, &b };\n    const c = a / b;\n    std.debug.print(\"value: {}\\n\", .{c});\n}\n```\n\nruntime_division_by_zero.zig\n\n            $ zig build-exe runtime_division_by_zero.zig\n    $ ./runtime_division_by_zero\n    thread 3575479 panic: division by zero\n    /home/andy/src/zig/doc/langref/runtime_division_by_zero.zig:7:17: 0x10351f6 in main (runtime_division_by_zero)\n        const c = a / b;\n                    ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (runtime_division_by_zero)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (runtime_division_by_zero)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Exact Division Remainder'
  id: index#Exact-Division-Remainder
  summary: null
  description: "### Exact Division Remainder\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const a: u32 = 10;\n    const b: u32 = 3;\n    const c = @divExact(a, b);\n    _ = c;\n}\n```\n\ntest_comptime_divExact_remainder.zig\n\n            $ zig test test_comptime_divExact_remainder.zig\n    doc/langref/test_comptime_divExact_remainder.zig:4:15: error: exact division produced remainder\n        const c = @divExact(a, b);\n                  ^~~~~~~~~~~~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var a: u32 = 10;\n    var b: u32 = 3;\n    _ = .{ &a, &b };\n    const c = @divExact(a, b);\n    std.debug.print(\"value: {}\\n\", .{c});\n}\n```\n\nruntime_divExact_remainder.zig\n\n            $ zig build-exe runtime_divExact_remainder.zig\n    $ ./runtime_divExact_remainder\n    thread 3570103 panic: exact division produced remainder\n    /home/andy/src/zig/doc/langref/runtime_divExact_remainder.zig:7:15: 0x103526b in main (runtime_divExact_remainder)\n        const c = @divExact(a, b);\n                  ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a89 in posixCallMainAndExit (runtime_divExact_remainder)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345f1 in _start (runtime_divExact_remainder)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Exact Left Shift Overflow'
  id: index#Exact-Left-Shift-Overflow
  summary: null
  description: "### Exact Left Shift Overflow\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const x = @shlExact(@as(u8, 0b01010101), 2);\n    _ = x;\n}\n```\n\ntest_comptime_shlExact_overwlow.zig\n\n            $ zig test test_comptime_shlExact_overwlow.zig\n    doc/langref/test_comptime_shlExact_overwlow.zig:2:15: error: operation caused overflow\n        const x = @shlExact(@as(u8, 0b01010101), 2);\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var x: u8 = 0b01010101; // runtime-known\n    _ = &x;\n    const y = @shlExact(x, 2);\n    std.debug.print(\"value: {}\\n\", .{y});\n}\n```\n\nruntime_shlExact_overflow.zig\n\n            $ zig build-exe runtime_shlExact_overflow.zig\n    $ ./runtime_shlExact_overflow\n    thread 3577156 panic: left shift overflowed bits\n    /home/andy/src/zig/doc/langref/runtime_shlExact_overflow.zig:6:5: 0x10352bd in main (runtime_shlExact_overflow)\n        const y = @shlExact(x, 2);\n        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034b19 in posixCallMainAndExit (runtime_shlExact_overflow)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034681 in _start (runtime_shlExact_overflow)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Exact Right Shift Overflow'
  id: index#Exact-Right-Shift-Overflow
  summary: null
  description: "### Exact Right Shift Overflow\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const x = @shrExact(@as(u8, 0b10101010), 2);\n    _ = x;\n}\n```\n\ntest_comptime_shrExact_overflow.zig\n\n            $ zig test test_comptime_shrExact_overflow.zig\n    doc/langref/test_comptime_shrExact_overflow.zig:2:15: error: exact shift shifted out 1 bits\n        const x = @shrExact(@as(u8, 0b10101010), 2);\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var x: u8 = 0b10101010; // runtime-known\n    _ = &x;\n    const y = @shrExact(x, 2);\n    std.debug.print(\"value: {}\\n\", .{y});\n}\n```\n\nruntime_shrExact_overflow.zig\n\n            $ zig build-exe runtime_shrExact_overflow.zig\n    $ ./runtime_shrExact_overflow\n    thread 3579049 panic: right shift overflowed bits\n    /home/andy/src/zig/doc/langref/runtime_shrExact_overflow.zig:6:5: 0x10352b9 in main (runtime_shrExact_overflow)\n        const y = @shrExact(x, 2);\n        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034b19 in posixCallMainAndExit (runtime_shrExact_overflow)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034681 in _start (runtime_shrExact_overflow)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Incorrect Pointer Alignment'
  id: index#Incorrect-Pointer-Alignment
  summary: null
  description: "### Incorrect Pointer Alignment\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const ptr: *align(1) i32 = @ptrFromInt(0x1);\n    const aligned: *align(4) i32 = @alignCast(ptr);\n    _ = aligned;\n}\n```\n\ntest_comptime_incorrect_pointer_alignment.zig\n\n            $ zig test test_comptime_incorrect_pointer_alignment.zig\n    doc/langref/test_comptime_incorrect_pointer_alignment.zig:3:47: error: pointer address 0x1 is not aligned to 4 bytes\n        const aligned: *align(4) i32 = @alignCast(ptr);\n                                                  ^~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst mem = @import(\"std\").mem;\npub fn main() !void {\n    var array align(4) = [_]u32{ 0x11111111, 0x11111111 };\n    const bytes = mem.sliceAsBytes(array[0..]);\n    if (foo(bytes) != 0x11111111) return error.Wrong;\n}\nfn foo(bytes: []u8) u32 {\n    const slice4 = bytes[1..5];\n    const int_slice = mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n    return int_slice[0];\n}\n```\n\nruntime_incorrect_pointer_alignment.zig\n\n            $ zig build-exe runtime_incorrect_pointer_alignment.zig\n    $ ./runtime_incorrect_pointer_alignment\n    thread 3570122 panic: incorrect alignment\n    /home/andy/src/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:9:64: 0x1034f0a in foo (runtime_incorrect_pointer_alignment)\n        const int_slice = mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n                                                                   ^\n    /home/andy/src/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:5:12: 0x1034dc7 in main (runtime_incorrect_pointer_alignment)\n        if (foo(bytes) != 0x11111111) return error.Wrong;\n               ^\n    /home/andy/src/zig/lib/std/start.zig:524:37: 0x1034cc5 in posixCallMainAndExit (runtime_incorrect_pointer_alignment)\n                const result = root.main() catch |err| {\n                                        ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10347e1 in _start (runtime_incorrect_pointer_alignment)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Index out of Bounds'
  id: index#Index-out-of-Bounds
  summary: null
  description: "### Index out of Bounds\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const array: [5]u8 = \"hello\".*;\n    const garbage = array[5];\n    _ = garbage;\n}\n```\n\ntest_comptime_index_out_of_bounds.zig\n\n            $ zig test test_comptime_index_out_of_bounds.zig\n    doc/langref/test_comptime_index_out_of_bounds.zig:3:27: error: index 5 outside array of length 5\n        const garbage = array[5];\n                              ^\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\npub fn main() void {\n    const x = foo(\"hello\");\n    _ = x;\n}\n\nfn foo(x: []const u8) u8 {\n    return x[5];\n}\n```\n\nruntime_index_out_of_bounds.zig\n\n            $ zig build-exe runtime_index_out_of_bounds.zig\n    $ ./runtime_index_out_of_bounds\n    thread 3567952 panic: index out of bounds: index 5, len 5\n    /home/andy/src/zig/doc/langref/runtime_index_out_of_bounds.zig:7:13: 0x1037169 in foo (runtime_index_out_of_bounds)\n        return x[5];\n                ^\n    /home/andy/src/zig/doc/langref/runtime_index_out_of_bounds.zig:2:18: 0x10350b6 in main (runtime_index_out_of_bounds)\n        const x = foo(\"hello\");\n                     ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034959 in posixCallMainAndExit (runtime_index_out_of_bounds)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10344c1 in _start (runtime_index_out_of_bounds)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Integer Overflow'
  id: index#Integer-Overflow
  summary: These functions provided by the standard library return possible errors
  description: "### Integer Overflow\n\n#### [Default Operations](#toc-Default-Operations)\n\nThe following operators can cause integer overflow:\n\n- `+` (addition)\n- `-` (subtraction)\n- `-` (negation)\n- `*` (multiplication)\n- `/` (division)\n- [@divTrunc](#divTrunc) (division)\n- [@divFloor](#divFloor) (division)\n- [@divExact](#divExact) (division)\n\nExample with addition at compile-time:\n\n``` zig\ncomptime {\n    var byte: u8 = 255;\n    byte += 1;\n}\n```\n\ntest_comptime_overflow.zig\n\n            $ zig test test_comptime_overflow.zig\n    doc/langref/test_comptime_overflow.zig:3:10: error: overflow of integer type 'u8' with value '256'\n        byte += 1;\n        ~~~~~^~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var byte: u8 = 255;\n    byte += 1;\n    std.debug.print(\"value: {}\\n\", .{byte});\n}\n```\n\nruntime_overflow.zig\n\n            $ zig build-exe runtime_overflow.zig\n    $ ./runtime_overflow\n    thread 3574209 panic: integer overflow\n    /home/andy/src/zig/doc/langref/runtime_overflow.zig:5:10: 0x103525e in main (runtime_overflow)\n        byte += 1;\n             ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ad9 in posixCallMainAndExit (runtime_overflow)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034641 in _start (runtime_overflow)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell\n\n#### [Standard Library Math Functions](#toc-Standard-Library-Math-Functions)\n\nThese functions provided by the standard library return possible errors.\n\n- `@import``(``\"std\"``).math.add`\n- `@import``(``\"std\"``).math.sub`\n- `@import``(``\"std\"``).math.mul`\n- `@import``(``\"std\"``).math.divTrunc`\n- `@import``(``\"std\"``).math.divFloor`\n- `@import``(``\"std\"``).math.divExact`\n- `@import``(``\"std\"``).math.shl`\n\nExample of catching an overflow for addition:\n\n``` zig\nconst math = @import(\"std\").math;\nconst print = @import(\"std\").debug.print;\npub fn main() !void {\n    var byte: u8 = 255;\n\n    byte = if (math.add(u8, byte, 1)) |result| result else |err| {\n        print(\"unable to add one: {s}\\n\", .{@errorName(err)});\n        return err;\n    };\n\n    print(\"result: {}\\n\", .{byte});\n}\n```\n\nmath_add.zig\n\n            $ zig build-exe math_add.zig\n    $ ./math_add\n    unable to add one: Overflow\n    error: Overflow\n    /home/andy/src/zig/lib/std/math.zig:565:21: 0x10352a5 in add__anon_2592 (math_add)\n        if (ov[1] != 0) return error.Overflow;\n                        ^\n    /home/andy/src/zig/doc/langref/math_add.zig:8:9: 0x1035243 in main (math_add)\n            return err;\n            ^\n\n          \n\nShell\n\n#### [Builtin Overflow Functions](#toc-Builtin-Overflow-Functions)\n\nThese builtins return a tuple containing whether there was an overflow (as a `u1`) and the possibly overflowed bits of the operation:\n\n- [@addWithOverflow](#addWithOverflow)\n- [@subWithOverflow](#subWithOverflow)\n- [@mulWithOverflow](#mulWithOverflow)\n- [@shlWithOverflow](#shlWithOverflow)\n\nExample of [@addWithOverflow](#addWithOverflow):\n\n``` zig\nconst print = @import(\"std\").debug.print;\npub fn main() void {\n    const byte: u8 = 255;\n\n    const ov = @addWithOverflow(byte, 10);\n    if (ov[1] != 0) {\n        print(\"overflowed result: {}\\n\", .{ov[0]});\n    } else {\n        print(\"result: {}\\n\", .{ov[0]});\n    }\n}\n```\n\naddWithOverflow_builtin.zig\n\n            $ zig build-exe addWithOverflow_builtin.zig\n    $ ./addWithOverflow_builtin\n    overflowed result: 9\n\n          \n\nShell\n\n#### [Wrapping Operations](#toc-Wrapping-Operations)\n\nThese operations have guaranteed wraparound semantics.\n\n- `+%` (wraparound addition)\n- `-%` (wraparound subtraction)\n- `-%` (wraparound negation)\n- `*%` (wraparound multiplication)\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst minInt = std.math.minInt;\nconst maxInt = std.math.maxInt;\n\ntest \"wraparound addition and subtraction\" {\n    const x: i32 = maxInt(i32);\n    const min_val = x +% 1;\n    try expect(min_val == minInt(i32));\n    const max_val = min_val -% 1;\n    try expect(max_val == maxInt(i32));\n}\n```\n\ntest_wraparound_semantics.zig\n\n            $ zig test test_wraparound_semantics.zig\n    1/1 test_wraparound_semantics.test.wraparound addition and subtraction...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Undefined Behavior: Invalid Enum Cast'
  id: index#Invalid-Enum-Cast
  summary: null
  description: "### Invalid Enum Cast\n\nAt compile-time:\n\n``` zig\nconst Foo = enum {\n    a,\n    b,\n    c,\n};\ncomptime {\n    const a: u2 = 3;\n    const b: Foo = @enumFromInt(a);\n    _ = b;\n}\n```\n\ntest_comptime_invalid_enum_cast.zig\n\n            $ zig test test_comptime_invalid_enum_cast.zig\n    doc/langref/test_comptime_invalid_enum_cast.zig:8:20: error: enum 'test_comptime_invalid_enum_cast.Foo' has no tag with value '3'\n        const b: Foo = @enumFromInt(a);\n                       ^~~~~~~~~~~~~~~\n    doc/langref/test_comptime_invalid_enum_cast.zig:1:13: note: enum declared here\n    const Foo = enum {\n                ^~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = enum {\n    a,\n    b,\n    c,\n};\n\npub fn main() void {\n    var a: u2 = 3;\n    _ = &a;\n    const b: Foo = @enumFromInt(a);\n    std.debug.print(\"value: {s}\\n\", .{@tagName(b)});\n}\n```\n\nruntime_invalid_enum_cast.zig\n\n            $ zig build-exe runtime_invalid_enum_cast.zig\n    $ ./runtime_invalid_enum_cast\n    thread 3568027 panic: invalid enum value\n    /home/andy/src/zig/doc/langref/runtime_invalid_enum_cast.zig:12:20: 0x1035297 in main (runtime_invalid_enum_cast)\n        const b: Foo = @enumFromInt(a);\n                       ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034af9 in posixCallMainAndExit (runtime_invalid_enum_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034661 in _start (runtime_invalid_enum_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Invalid Error Code'
  id: index#Invalid-Error-Code
  summary: null
  description: "### Invalid Error Code\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const err = error.AnError;\n    const number = @intFromError(err) + 10;\n    const invalid_err = @errorFromInt(number);\n    _ = invalid_err;\n}\n```\n\ntest_comptime_invalid_error_code.zig\n\n            $ zig test test_comptime_invalid_error_code.zig\n    doc/langref/test_comptime_invalid_error_code.zig:4:39: error: integer value '11' represents no error\n        const invalid_err = @errorFromInt(number);\n                                          ^~~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    const err = error.AnError;\n    var number = @intFromError(err) + 500;\n    _ = &number;\n    const invalid_err = @errorFromInt(number);\n    std.debug.print(\"value: {}\\n\", .{invalid_err});\n}\n```\n\nruntime_invalid_error_code.zig\n\n            $ zig build-exe runtime_invalid_error_code.zig\n    $ ./runtime_invalid_error_code\n    thread 3570441 panic: invalid error code\n    /home/andy/src/zig/doc/langref/runtime_invalid_error_code.zig:7:5: 0x10352a0 in main (runtime_invalid_error_code)\n        const invalid_err = @errorFromInt(number);\n        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ae9 in posixCallMainAndExit (runtime_invalid_error_code)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034651 in _start (runtime_invalid_error_code)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Invalid Error Set Cast'
  id: index#Invalid-Error-Set-Cast
  summary: null
  description: "### Invalid Error Set Cast\n\nAt compile-time:\n\n``` zig\nconst Set1 = error{\n    A,\n    B,\n};\nconst Set2 = error{\n    A,\n    C,\n};\ncomptime {\n    _ = @as(Set2, @errorCast(Set1.B));\n}\n```\n\ntest_comptime_invalid_error_set_cast.zig\n\n            $ zig test test_comptime_invalid_error_set_cast.zig\n    doc/langref/test_comptime_invalid_error_set_cast.zig:10:19: error: 'error.B' not a member of error set 'error{A,C}'\n        _ = @as(Set2, @errorCast(Set1.B));\n                      ^~~~~~~~~~~~~~~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Set1 = error{\n    A,\n    B,\n};\nconst Set2 = error{\n    A,\n    C,\n};\npub fn main() void {\n    foo(Set1.B);\n}\nfn foo(set1: Set1) void {\n    const x: Set2 = @errorCast(set1);\n    std.debug.print(\"value: {}\\n\", .{x});\n}\n```\n\nruntime_invalid_error_set_cast.zig\n\n            $ zig build-exe runtime_invalid_error_set_cast.zig\n    $ ./runtime_invalid_error_set_cast\n    thread 3568026 panic: invalid error code\n    /home/andy/src/zig/doc/langref/runtime_invalid_error_set_cast.zig:15:21: 0x1037317 in foo (runtime_invalid_error_set_cast)\n        const x: Set2 = @errorCast(set1);\n                        ^\n    /home/andy/src/zig/doc/langref/runtime_invalid_error_set_cast.zig:12:8: 0x103523d in main (runtime_invalid_error_set_cast)\n        foo(Set1.B);\n           ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ae9 in posixCallMainAndExit (runtime_invalid_error_set_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034651 in _start (runtime_invalid_error_set_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Out of Bounds Float to Integer Cast'
  id: index#Out-of-Bounds-Float-to-Integer-Cast
  summary: This happens when casting a float to an integer where the float has a value outside the integer type's range
  description: "### Out of Bounds Float to Integer Cast\n\nThis happens when casting a float to an integer where the float has a value outside the integer type's range.\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const float: f32 = 4294967296;\n    const int: i32 = @intFromFloat(float);\n    _ = int;\n}\n```\n\ntest_comptime_out_of_bounds_float_to_integer_cast.zig\n\n            $ zig test test_comptime_out_of_bounds_float_to_integer_cast.zig\n    doc/langref/test_comptime_out_of_bounds_float_to_integer_cast.zig:3:36: error: float value '4294967296' cannot be stored in integer type 'i32'\n        const int: i32 = @intFromFloat(float);\n                                       ^~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\npub fn main() void {\n    var float: f32 = 4294967296; // runtime-known\n    _ = &float;\n    const int: i32 = @intFromFloat(float);\n    _ = int;\n}\n```\n\nruntime_out_of_bounds_float_to_integer_cast.zig\n\n            $ zig build-exe runtime_out_of_bounds_float_to_integer_cast.zig\n    $ ./runtime_out_of_bounds_float_to_integer_cast\n    thread 3570320 panic: integer part of floating point value out of bounds\n    /home/andy/src/zig/doc/langref/runtime_out_of_bounds_float_to_integer_cast.zig:4:22: 0x1035169 in main (runtime_out_of_bounds_float_to_integer_cast)\n        const int: i32 = @intFromFloat(float);\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10349a9 in posixCallMainAndExit (runtime_out_of_bounds_float_to_integer_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034511 in _start (runtime_out_of_bounds_float_to_integer_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Pointer Cast Invalid Null'
  id: index#Pointer-Cast-Invalid-Null
  summary: This happens when casting a pointer with the address 0 to a pointer which may not have the address 0
  description: "### Pointer Cast Invalid Null\n\nThis happens when casting a pointer with the address 0 to a pointer which may not have the address 0. For example, [C Pointers](#C-Pointers), [Optional Pointers](#Optional-Pointers), and [allowzero](#allowzero) pointers allow address zero, but normal [Pointers](#Pointers) do not.\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const opt_ptr: ?*i32 = null;\n    const ptr: *i32 = @ptrCast(opt_ptr);\n    _ = ptr;\n}\n```\n\ntest_comptime_invalid_null_pointer_cast.zig\n\n            $ zig test test_comptime_invalid_null_pointer_cast.zig\n    doc/langref/test_comptime_invalid_null_pointer_cast.zig:3:32: error: null pointer casted to type '*i32'\n        const ptr: *i32 = @ptrCast(opt_ptr);\n                                   ^~~~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\npub fn main() void {\n    var opt_ptr: ?*i32 = null;\n    _ = &opt_ptr;\n    const ptr: *i32 = @ptrCast(opt_ptr);\n    _ = ptr;\n}\n```\n\nruntime_invalid_null_pointer_cast.zig\n\n            $ zig build-exe runtime_invalid_null_pointer_cast.zig\n    $ ./runtime_invalid_null_pointer_cast\n    thread 3572791 panic: cast causes pointer to be null\n    /home/andy/src/zig/doc/langref/runtime_invalid_null_pointer_cast.zig:4:23: 0x10350bc in main (runtime_invalid_null_pointer_cast)\n        const ptr: *i32 = @ptrCast(opt_ptr);\n                          ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034929 in posixCallMainAndExit (runtime_invalid_null_pointer_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034491 in _start (runtime_invalid_null_pointer_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Reaching Unreachable Code'
  id: index#Reaching-Unreachable-Code
  summary: null
  description: "### Reaching Unreachable Code\n\nAt compile-time:\n\n``` zig\ncomptime {\n    assert(false);\n}\nfn assert(ok: bool) void {\n    if (!ok) unreachable; // assertion failure\n}\n```\n\ntest_comptime_reaching_unreachable.zig\n\n            $ zig test test_comptime_reaching_unreachable.zig\n    doc/langref/test_comptime_reaching_unreachable.zig:5:14: error: reached unreachable code\n        if (!ok) unreachable; // assertion failure\n                 ^~~~~~~~~~~\n    doc/langref/test_comptime_reaching_unreachable.zig:2:11: note: called from here\n        assert(false);\n        ~~~~~~^~~~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    std.debug.assert(false);\n}\n```\n\nruntime_reaching_unreachable.zig\n\n            $ zig build-exe runtime_reaching_unreachable.zig\n    $ ./runtime_reaching_unreachable\n    thread 3575642 panic: reached unreachable code\n    /home/andy/src/zig/lib/std/debug.zig:412:14: 0x1036cdd in assert (runtime_reaching_unreachable)\n        if (!ok) unreachable; // assertion failure\n                 ^\n    /home/andy/src/zig/doc/langref/runtime_reaching_unreachable.zig:4:21: 0x103507a in main (runtime_reaching_unreachable)\n        std.debug.assert(false);\n                        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034929 in posixCallMainAndExit (runtime_reaching_unreachable)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034491 in _start (runtime_reaching_unreachable)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Remainder Division by Zero'
  id: index#Remainder-Division-by-Zero
  summary: null
  description: "### Remainder Division by Zero\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const a: i32 = 10;\n    const b: i32 = 0;\n    const c = a % b;\n    _ = c;\n}\n```\n\ntest_comptime_remainder_division_by_zero.zig\n\n            $ zig test test_comptime_remainder_division_by_zero.zig\n    doc/langref/test_comptime_remainder_division_by_zero.zig:4:19: error: division by zero here causes undefined behavior\n        const c = a % b;\n                      ^\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var a: u32 = 10;\n    var b: u32 = 0;\n    _ = .{ &a, &b };\n    const c = a % b;\n    std.debug.print(\"value: {}\\n\", .{c});\n}\n```\n\nruntime_remainder_division_by_zero.zig\n\n            $ zig build-exe runtime_remainder_division_by_zero.zig\n    $ ./runtime_remainder_division_by_zero\n    thread 3570535 panic: division by zero\n    /home/andy/src/zig/doc/langref/runtime_remainder_division_by_zero.zig:7:17: 0x10351f6 in main (runtime_remainder_division_by_zero)\n        const c = a % b;\n                    ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (runtime_remainder_division_by_zero)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (runtime_remainder_division_by_zero)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell"
- name: 'Undefined Behavior: Wrong Union Field Access'
  id: index#Wrong-Union-Field-Access
  summary: This safety is not available for extern or packed unions
  description: "### Wrong Union Field Access\n\nAt compile-time:\n\n``` zig\ncomptime {\n    var f = Foo{ .int = 42 };\n    f.float = 12.34;\n}\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n```\n\ntest_comptime_wrong_union_field_access.zig\n\n            $ zig test test_comptime_wrong_union_field_access.zig\n    doc/langref/test_comptime_wrong_union_field_access.zig:3:6: error: access of union field 'float' while field 'int' is active\n        f.float = 12.34;\n        ~^~~~~~\n    doc/langref/test_comptime_wrong_union_field_access.zig:6:13: note: union declared here\n    const Foo = union {\n                ^~~~~\n\n\n          \n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n\npub fn main() void {\n    var f = Foo{ .int = 42 };\n    bar(&f);\n}\n\nfn bar(f: *Foo) void {\n    f.float = 12.34;\n    std.debug.print(\"value: {}\\n\", .{f.float});\n}\n```\n\nruntime_wrong_union_field_access.zig\n\n            $ zig build-exe runtime_wrong_union_field_access.zig\n    $ ./runtime_wrong_union_field_access\n    thread 3578787 panic: access of union field 'float' while field 'int' is active\n    /home/andy/src/zig/doc/langref/runtime_wrong_union_field_access.zig:14:6: 0x103cd20 in bar (runtime_wrong_union_field_access)\n        f.float = 12.34;\n         ^\n    /home/andy/src/zig/doc/langref/runtime_wrong_union_field_access.zig:10:8: 0x103ac5c in main (runtime_wrong_union_field_access)\n        bar(&f);\n           ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103a4f9 in posixCallMainAndExit (runtime_wrong_union_field_access)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103a061 in _start (runtime_wrong_union_field_access)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\n          \n\nShell\n\nThis safety is not available for `extern` or `packed` unions.\n\nTo change the active field of a union, assign the entire union, like this:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n\npub fn main() void {\n    var f = Foo{ .int = 42 };\n    bar(&f);\n}\n\nfn bar(f: *Foo) void {\n    f.* = Foo{ .float = 12.34 };\n    std.debug.print(\"value: {}\\n\", .{f.float});\n}\n```\n\nchange_active_union_field.zig\n\n            $ zig build-exe change_active_union_field.zig\n    $ ./change_active_union_field\n    value: 1.234e1\n\n          \n\nShell\n\nTo change the active field of a union when a meaningful value for the field is not known, use [undefined](#undefined), like this:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n\npub fn main() void {\n    var f = Foo{ .int = 42 };\n    f = Foo{ .float = undefined };\n    bar(&f);\n    std.debug.print(\"value: {}\\n\", .{f.float});\n}\n\nfn bar(f: *Foo) void {\n    f.float = 12.34;\n}\n```\n\nundefined_active_union_field.zig\n\n            $ zig build-exe undefined_active_union_field.zig\n    $ ./undefined_active_union_field\n    value: 1.234e1\n\n          \n\nShell\n\nSee also:\n\n- [union](#union)\n- [extern union](#extern-union)\n\n&nbsp;"
- name: union
  id: index#union
  summary: A bare union defines a set of possible types that a value can be as a list of fields
  description: "## union\n\nA bare `union` defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use [@ptrCast](#ptrCast), or use an [extern union](#extern-union) or a [packed union](#packed-union) which have guaranteed in-memory layout. [Accessing the non-active field](#Wrong-Union-Field-Access) is safety-checked [Undefined Behavior](#Undefined-Behavior):\n\n``` zig\nconst Payload = union {\n    int: i64,\n    float: f64,\n    boolean: bool,\n};\ntest \"simple union\" {\n    var payload = Payload{ .int = 1234 };\n    payload.float = 12.34;\n}\n```\n\ntest_wrong_union_access.zig\n\n            $ zig test test_wrong_union_access.zig\n    1/1 test_wrong_union_access.test.simple union...thread 3579408 panic: access of union field 'float' while field 'int' is active\n    /home/andy/src/zig/doc/langref/test_wrong_union_access.zig:8:12: 0x103ce87 in test.simple union (test)\n        payload.float = 12.34;\n               ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048070 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e08b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d419 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cf81 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/bb9968225995fac0bbc9f2116e8583c2/test\n\n          \n\nShell\n\nYou can activate another field by assigning the entire union:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Payload = union {\n    int: i64,\n    float: f64,\n    boolean: bool,\n};\ntest \"simple union\" {\n    var payload = Payload{ .int = 1234 };\n    try expect(payload.int == 1234);\n    payload = Payload{ .float = 12.34 };\n    try expect(payload.float == 12.34);\n}\n```\n\ntest_simple_union.zig\n\n            $ zig test test_simple_union.zig\n    1/1 test_simple_union.test.simple union...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nIn order to use [switch](#switch) with a union, it must be a [Tagged union](#Tagged-union).\n\nTo initialize a union when the tag is a [comptime](#comptime)-known name, see [@unionInit](#unionInit)."
- name: 'union: Anonymous Union Literals'
  id: index#Anonymous-Union-Literals
  summary: null
  description: "### Anonymous Union Literals\n\n[Anonymous Struct Literals](#Anonymous-Struct-Literals) syntax can be used to initialize unions without specifying the type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Number = union {\n    int: i32,\n    float: f64,\n};\n\ntest \"anonymous union literal syntax\" {\n    const i: Number = .{ .int = 42 };\n    const f = makeNumber();\n    try expect(i.int == 42);\n    try expect(f.float == 12.34);\n}\n\nfn makeNumber() Number {\n    return .{ .float = 12.34 };\n}\n```\n\ntest_anonymous_union.zig\n\n            $ zig test test_anonymous_union.zig\n    1/1 test_anonymous_union.test.anonymous union literal syntax...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'union: extern union'
  id: index#extern-union
  summary: An extern``union has memory layout guaranteed to be compatible with the target C ABI
  description: |-
    ### extern union

    An `extern``union` has memory layout guaranteed to be compatible with the target C ABI.

    See also:

    - [extern struct](#extern-struct)

    &nbsp;
- name: 'union: packed union'
  id: index#packed-union
  summary: A packed``union has well-defined in-memory layout and is eligible to be in a packed struct
  description: |-
    ### packed union

    A `packed``union` has well-defined in-memory layout and is eligible to be in a [packed struct](#packed-struct).
- name: 'union: Tagged union'
  id: index#Tagged-union
  summary: Unions can be declared with an enum tag type
  description: "### Tagged union\n\nUnions can be declared with an enum tag type. This turns the union into a *tagged* union, which makes it eligible to use with [switch](#switch) expressions. Tagged unions coerce to their tag type: [Type Coercion: Unions and Enums](#Type-Coercion-Unions-and-Enums).\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst ComplexTypeTag = enum {\n    ok,\n    not_ok,\n};\nconst ComplexType = union(ComplexTypeTag) {\n    ok: u8,\n    not_ok: void,\n};\n\ntest \"switch on tagged union\" {\n    const c = ComplexType{ .ok = 42 };\n    try expect(@as(ComplexTypeTag, c) == ComplexTypeTag.ok);\n\n    switch (c) {\n        ComplexTypeTag.ok => |value| try expect(value == 42),\n        ComplexTypeTag.not_ok => unreachable,\n    }\n}\n\ntest \"get tag type\" {\n    try expect(std.meta.Tag(ComplexType) == ComplexTypeTag);\n}\n```\n\ntest_tagged_union.zig\n\n            $ zig test test_tagged_union.zig\n    1/2 test_tagged_union.test.switch on tagged union...OK\n    2/2 test_tagged_union.test.get tag type...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nIn order to modify the payload of a tagged union in a switch expression, place a `*` before the variable name to make it a pointer:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst ComplexTypeTag = enum {\n    ok,\n    not_ok,\n};\nconst ComplexType = union(ComplexTypeTag) {\n    ok: u8,\n    not_ok: void,\n};\n\ntest \"modify tagged union in switch\" {\n    var c = ComplexType{ .ok = 42 };\n\n    switch (c) {\n        ComplexTypeTag.ok => |*value| value.* += 1,\n        ComplexTypeTag.not_ok => unreachable,\n    }\n\n    try expect(c.ok == 43);\n}\n```\n\ntest_switch_modify_tagged_union.zig\n\n            $ zig test test_switch_modify_tagged_union.zig\n    1/1 test_switch_modify_tagged_union.test.modify tagged union in switch...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nUnions can be made to infer the enum tag type. Further, unions can have methods just like structs and enums.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Variant = union(enum) {\n    int: i32,\n    boolean: bool,\n\n    // void can be omitted when inferring enum tag type.\n    none,\n\n    fn truthy(self: Variant) bool {\n        return switch (self) {\n            Variant.int => |x_int| x_int != 0,\n            Variant.boolean => |x_bool| x_bool,\n            Variant.none => false,\n        };\n    }\n};\n\ntest \"union method\" {\n    var v1 = Variant{ .int = 1 };\n    var v2 = Variant{ .boolean = false };\n\n    try expect(v1.truthy());\n    try expect(!v2.truthy());\n}\n```\n\ntest_union_method.zig\n\n            $ zig test test_union_method.zig\n    1/1 test_union_method.test.union method...OK\n    All 1 tests passed.\n\n          \n\nShell\n\n[@tagName](#tagName) can be used to return a [comptime](#comptime) `[:``0``]``const`` ``u8` value representing the field name:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Small2 = union(enum) {\n    a: i32,\n    b: bool,\n    c: u8,\n};\ntest \"@tagName\" {\n    try expect(std.mem.eql(u8, @tagName(Small2.a), \"a\"));\n}\n```\n\ntest_tagName.zig\n\n            $ zig test test_tagName.zig\n    1/1 test_tagName.test.@tagName...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: unreachable
  id: index#unreachable
  summary: In Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code
  description: |-
    ## unreachable

    In [Debug](#Debug) and [ReleaseSafe](#ReleaseSafe) mode `unreachable` emits a call to `panic` with the message `reached unreachable code`.

    In [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) mode, the optimizer uses the assumption that `unreachable` code will never be hit to perform optimizations.
- name: 'unreachable: At Compile-Time'
  id: index#At-Compile-Time
  summary: null
  description: "### At Compile-Time\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\n\ntest \"type of unreachable\" {\n    comptime {\n        // The type of unreachable is noreturn.\n\n        // However this assertion will still fail to compile because\n        // unreachable expressions are compile errors.\n\n        assert(@TypeOf(unreachable) == noreturn);\n    }\n}\n```\n\ntest_comptime_unreachable.zig\n\n            $ zig test test_comptime_unreachable.zig\n    doc/langref/test_comptime_unreachable.zig:10:16: error: unreachable code\n            assert(@TypeOf(unreachable) == noreturn);\n                   ^~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_comptime_unreachable.zig:10:24: note: control flow is diverted here\n            assert(@TypeOf(unreachable) == noreturn);\n                           ^~~~~~~~~~~\n\n\n          \n\nShell\n\nSee also:\n\n- [Zig Test](#Zig-Test)\n- [Build Mode](#Build-Mode)\n- [comptime](#comptime)\n\n&nbsp;"
- name: 'unreachable: Basics'
  id: index#Basics
  summary: null
  description: "### Basics\n\n``` zig\n// unreachable is used to assert that control flow will never reach a\n// particular location:\ntest \"basic math\" {\n    const x = 1;\n    const y = 2;\n    if (x + y != 3) {\n        unreachable;\n    }\n}\n```\n\ntest_unreachable.zig\n\n            $ zig test test_unreachable.zig\n    1/1 test_unreachable.test.basic math...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nIn fact, this is how `std.debug.assert` is implemented:\n\n``` zig\n// This is how std.debug.assert is implemented\nfn assert(ok: bool) void {\n    if (!ok) unreachable; // assertion failure\n}\n\n// This test will fail because we hit unreachable.\ntest \"this will fail\" {\n    assert(false);\n}\n```\n\ntest_assertion_failure.zig\n\n            $ zig test test_assertion_failure.zig\n    1/1 test_assertion_failure.test.this will fail...thread 3571599 panic: reached unreachable code\n    /home/andy/src/zig/doc/langref/test_assertion_failure.zig:3:14: 0x103cd9d in assert (test)\n        if (!ok) unreachable; // assertion failure\n                 ^\n    /home/andy/src/zig/doc/langref/test_assertion_failure.zig:8:11: 0x103cd5a in test.this will fail (test)\n        assert(false);\n              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x10479a0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103dbbb in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d249 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cdb1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/a6b3ce5875a9e285c15739b2a1b30733/test\n\n          \n\nShell"
- name: usingnamespace
  id: index#usingnamespace
  summary: usingnamespace has an important use case when organizing the public API of a file or package
  description: "## usingnamespace\n\n`usingnamespace` is a declaration that mixes all the public declarations of the operand, which must be a [struct](#struct), [union](#union), [enum](#enum), or [opaque](#opaque), into the namespace:\n\n``` zig\ntest \"using std namespace\" {\n    const S = struct {\n        usingnamespace @import(\"std\");\n    };\n    try S.testing.expect(true);\n}\n```\n\ntest_usingnamespace.zig\n\n            $ zig test test_usingnamespace.zig\n    1/1 test_usingnamespace.test.using std namespace...OK\n    All 1 tests passed.\n\n          \n\nShell\n\n`usingnamespace` has an important use case when organizing the public API of a file or package. For example, one might have `c.zig` with all of the [C imports](#Import-from-C-Header-File):\n\n``` zig\npub usingnamespace @cImport({\n    @cInclude(\"epoxy/gl.h\");\n    @cInclude(\"GLFW/glfw3.h\");\n    @cDefine(\"STBI_ONLY_PNG\", \"\");\n    @cDefine(\"STBI_NO_STDIO\", \"\");\n    @cInclude(\"stb_image.h\");\n});\n```\n\nc.zig\n\nThe above example demonstrates using `pub` to qualify the `usingnamespace` additionally makes the imported declarations `pub`. This can be used to forward declarations, giving precise control over what declarations a given file exposes."
- name: Values
  id: index#Values
  summary: null
  description: "## Values\n\n``` zig\n// Top-level declarations are order-independent:\nconst print = std.debug.print;\nconst std = @import(\"std\");\nconst os = std.os;\nconst assert = std.debug.assert;\n\npub fn main() void {\n    // integers\n    const one_plus_one: i32 = 1 + 1;\n    print(\"1 + 1 = {}\\n\", .{one_plus_one});\n\n    // floats\n    const seven_div_three: f32 = 7.0 / 3.0;\n    print(\"7.0 / 3.0 = {}\\n\", .{seven_div_three});\n\n    // boolean\n    print(\"{}\\n{}\\n{}\\n\", .{\n        true and false,\n        true or false,\n        !true,\n    });\n\n    // optional\n    var optional_value: ?[]const u8 = null;\n    assert(optional_value == null);\n\n    print(\"\\noptional 1\\ntype: {}\\nvalue: {?s}\\n\", .{\n        @TypeOf(optional_value), optional_value,\n    });\n\n    optional_value = \"hi\";\n    assert(optional_value != null);\n\n    print(\"\\noptional 2\\ntype: {}\\nvalue: {?s}\\n\", .{\n        @TypeOf(optional_value), optional_value,\n    });\n\n    // error union\n    var number_or_error: anyerror!i32 = error.ArgNotFound;\n\n    print(\"\\nerror union 1\\ntype: {}\\nvalue: {!}\\n\", .{\n        @TypeOf(number_or_error),\n        number_or_error,\n    });\n\n    number_or_error = 1234;\n\n    print(\"\\nerror union 2\\ntype: {}\\nvalue: {!}\\n\", .{\n        @TypeOf(number_or_error), number_or_error,\n    });\n}\n```\n\nvalues.zig\n\n            $ zig build-exe values.zig\n    $ ./values\n    1 + 1 = 2\n    7.0 / 3.0 = 2.3333333e0\n    false\n    true\n    false\n\n    optional 1\n    type: ?[]const u8\n    value: null\n\n    optional 2\n    type: ?[]const u8\n    value: hi\n\n    error union 1\n    type: anyerror!i32\n    value: error.ArgNotFound\n\n    error union 2\n    type: anyerror!i32\n    value: 1234\n\n          \n\nShell"
- name: 'Values: Assignment'
  id: index#Assignment
  summary: const applies to all of the bytes that the identifier immediately addresses
  description: "### Assignment\n\nUse the `const` keyword to assign a value to an identifier:\n\n``` zig\nconst x = 1234;\n\nfn foo() void {\n    // It works at file scope as well as inside functions.\n    const y = 5678;\n\n    // Once assigned, an identifier cannot be changed.\n    y += 1;\n}\n\npub fn main() void {\n    foo();\n}\n```\n\nconstant_identifier_cannot_change.zig\n\n            $ zig build-exe constant_identifier_cannot_change.zig\n    /home/andy/src/zig/doc/langref/constant_identifier_cannot_change.zig:8:7: error: cannot assign to constant\n        y += 1;\n        ~~^~~~\n    referenced by:\n        main: /home/andy/src/zig/doc/langref/constant_identifier_cannot_change.zig:12:5\n        callMain: /home/andy/src/zig/lib/std/start.zig:514:17\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\n\n          \n\nShell\n\n`const` applies to all of the bytes that the identifier immediately addresses. [Pointers](#Pointers) have their own const-ness.\n\nIf you need a variable that you can modify, use the `var` keyword:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    var y: i32 = 5678;\n\n    y += 1;\n\n    print(\"{d}\", .{y});\n}\n```\n\nmutable_var.zig\n\n            $ zig build-exe mutable_var.zig\n    $ ./mutable_var\n    5679\n\n          \n\nShell\n\nVariables must be initialized:\n\n``` zig\npub fn main() void {\n    var x: i32;\n\n    x = 1;\n}\n```\n\nvar_must_be_initialized.zig\n\n            $ zig build-exe var_must_be_initialized.zig\n    /home/andy/src/zig/doc/langref/var_must_be_initialized.zig:2:15: error: expected '=', found ';'\n        var x: i32;\n                  ^\n\n\n          \n\nShell\n\n#### [undefined](#toc-undefined)\n\nUse `undefined` to leave variables uninitialized:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    var x: i32 = undefined;\n    x = 1;\n    print(\"{d}\", .{x});\n}\n```\n\nassign_undefined.zig\n\n            $ zig build-exe assign_undefined.zig\n    $ ./assign_undefined\n    1\n\n          \n\nShell\n\n`undefined` can be [coerced](#Type-Coercion) to any type. Once this happens, it is no longer possible to detect that the value is `undefined`. `undefined` means the value could be anything, even something that is nonsense according to the type. Translated into English, `undefined` means \"Not a meaningful value. Using this value would be a bug. The value will be unused, or overwritten before being used.\"\n\nIn [Debug](#Debug) mode, Zig writes `0xaa` bytes to undefined memory. This is to catch bugs early, and to help detect use of undefined memory in a debugger. However, this behavior is only an implementation feature, not a language semantic, so it is not guaranteed to be observable to code."
- name: 'Values: Primitive Types'
  id: index#Primitive-Types
  summary: In addition to the integer types above, arbitrary bit-width integers can be referenced by using an identifier of i or u followed by digits
  description: |-
    ### Primitive Types

    | Type                   | C Equivalent          | Description                                                                                   |
    |------------------------|-----------------------|-----------------------------------------------------------------------------------------------|
    | ` ``i8`` `             | `int8_t`              | signed 8-bit integer                                                                          |
    | ` ``u8`` `             | `uint8_t`             | unsigned 8-bit integer                                                                        |
    | ` ``i16`` `            | `int16_t`             | signed 16-bit integer                                                                         |
    | ` ``u16`` `            | `uint16_t`            | unsigned 16-bit integer                                                                       |
    | ` ``i32`` `            | `int32_t`             | signed 32-bit integer                                                                         |
    | ` ``u32`` `            | `uint32_t`            | unsigned 32-bit integer                                                                       |
    | ` ``i64`` `            | `int64_t`             | signed 64-bit integer                                                                         |
    | ` ``u64`` `            | `uint64_t`            | unsigned 64-bit integer                                                                       |
    | ` ``i128`` `           | `__int128`            | signed 128-bit integer                                                                        |
    | ` ``u128`` `           | `unsigned __int128`   | unsigned 128-bit integer                                                                      |
    | ` ``isize`` `          | `intptr_t`            | signed pointer sized integer                                                                  |
    | ` ``usize`` `          | `uintptr_t`, `size_t` | unsigned pointer sized integer. Also see [\#5185](https://github.com/ziglang/zig/issues/5185) |
    | ` ``c_char`` `         | `char`                | for ABI compatibility with C                                                                  |
    | ` ``c_short`` `        | `short`               | for ABI compatibility with C                                                                  |
    | ` ``c_ushort`` `       | `unsigned short`      | for ABI compatibility with C                                                                  |
    | ` ``c_int`` `          | `int`                 | for ABI compatibility with C                                                                  |
    | ` ``c_uint`` `         | `unsigned int`        | for ABI compatibility with C                                                                  |
    | ` ``c_long`` `         | `long`                | for ABI compatibility with C                                                                  |
    | ` ``c_ulong`` `        | `unsigned long`       | for ABI compatibility with C                                                                  |
    | ` ``c_longlong`` `     | `long long`           | for ABI compatibility with C                                                                  |
    | ` ``c_ulonglong`` `    | `unsigned long long`  | for ABI compatibility with C                                                                  |
    | ` ``c_longdouble`` `   | `long double`         | for ABI compatibility with C                                                                  |
    | ` ``f16`` `            | `_Float16`            | 16-bit floating point (10-bit mantissa) IEEE-754-2008 binary16                                |
    | ` ``f32`` `            | `float`               | 32-bit floating point (23-bit mantissa) IEEE-754-2008 binary32                                |
    | ` ``f64`` `            | `double`              | 64-bit floating point (52-bit mantissa) IEEE-754-2008 binary64                                |
    | ` ``f80`` `            | `double`              | 80-bit floating point (64-bit mantissa) IEEE-754-2008 80-bit extended precision               |
    | ` ``f128`` `           | `_Float128`           | 128-bit floating point (112-bit mantissa) IEEE-754-2008 binary128                             |
    | ` ``bool`` `           | `bool`                | `true` or `false`                                                                             |
    | ` ``anyopaque`` `      | `void`                | Used for type-erased pointers.                                                                |
    | ` ``void`` `           | (none)                | Always the value `void``{}`                                                                   |
    | ` ``noreturn`` `       | (none)                | the type of `break`, `continue`, `return`, `unreachable`, and `while`` (``true``) {}`         |
    | ` ``type`` `           | (none)                | the type of types                                                                             |
    | ` ``anyerror`` `       | (none)                | an error code                                                                                 |
    | ` ``comptime_int`` `   | (none)                | Only allowed for [comptime](#comptime)-known values. The type of integer literals.            |
    | ` ``comptime_float`` ` | (none)                | Only allowed for [comptime](#comptime)-known values. The type of float literals.              |

    Primitive Types

    In addition to the integer types above, arbitrary bit-width integers can be referenced by using an identifier of `i` or `u` followed by digits. For example, the identifier `i7` refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is `65535`.

    See also:

    - [Integers](#Integers)
    - [Floats](#Floats)
    - [void](#void)
    - [Errors](#Errors)
    - [@Type](#Type)

    &nbsp;
- name: 'Values: Primitive Values'
  id: index#Primitive-Values
  summary: null
  description: |-
    ### Primitive Values

    | Name               | Description                            |
    |--------------------|----------------------------------------|
    | `true` and `false` | `bool` values                          |
    | ` ``null`` `       | used to set an optional type to `null` |
    | ` ``undefined`` `  | used to leave a value unspecified      |

    Primitive Values

    See also:

    - [Optionals](#Optionals)
    - [undefined](#undefined)

    &nbsp;
- name: 'Values: String Literals and Unicode Code Point Literals'
  id: index#String-Literals-and-Unicode-Code-Point-Literals
  summary: String literals are constant single-item Pointers to null-terminated byte arrays
  description: "### String Literals and Unicode Code Point Literals\n\nString literals are constant single-item [Pointers](#Pointers) to null-terminated byte arrays. The type of string literals encodes both the length, and the fact that they are null-terminated, and thus they can be [coerced](#Type-Coercion) to both [Slices](#Slices) and [Null-Terminated Pointers](#Sentinel-Terminated-Pointers). Dereferencing string literals converts them to [Arrays](#Arrays).\n\nBecause Zig source code is [UTF-8 encoded](#Source-Encoding), any non-ASCII bytes appearing within a string literal in source code carry their UTF-8 meaning into the content of the string in the Zig program; the bytes are not modified by the compiler. It is possible to embed non-UTF-8 bytes into a string literal using `\\xNN` notation.\n\nIndexing into a string containing non-ASCII bytes returns individual bytes, whether valid UTF-8 or not.\n\nUnicode code point literals have type `comptime_int`, the same as [Integer Literals](#Integer-Literals). All [Escape Sequences](#Escape-Sequences) are valid in both string literals and Unicode code point literals.\n\n``` zig\nconst print = @import(\"std\").debug.print;\nconst mem = @import(\"std\").mem; // will be used to compare bytes\n\npub fn main() void {\n    const bytes = \"hello\";\n    print(\"{}\\n\", .{@TypeOf(bytes)}); // *const [5:0]u8\n    print(\"{d}\\n\", .{bytes.len}); // 5\n    print(\"{c}\\n\", .{bytes[1]}); // 'e'\n    print(\"{d}\\n\", .{bytes[5]}); // 0\n    print(\"{}\\n\", .{'e' == '\\x65'}); // true\n    print(\"{d}\\n\", .{'\\u{1f4a9}'}); // 128169\n    print(\"{d}\\n\", .{'💯'}); // 128175\n    print(\"{u}\\n\", .{'⚡'});\n    print(\"{}\\n\", .{mem.eql(u8, \"hello\", \"h\\x65llo\")}); // true\n    print(\"{}\\n\", .{mem.eql(u8, \"💯\", \"\\xf0\\x9f\\x92\\xaf\")}); // also true\n    const invalid_utf8 = \"\\xff\\xfe\"; // non-UTF-8 strings are possible with \\xNN notation.\n    print(\"0x{x}\\n\", .{invalid_utf8[1]}); // indexing them returns individual bytes...\n    print(\"0x{x}\\n\", .{\"💯\"[1]}); // ...as does indexing part-way through non-ASCII characters\n}\n```\n\nstring_literals.zig\n\n            $ zig build-exe string_literals.zig\n    $ ./string_literals\n    *const [5:0]u8\n    5\n    e\n    0\n    true\n    128169\n    128175\n    ⚡\n    true\n    true\n    0xfe\n    0x9f\n\n          \n\nShell\n\nSee also:\n\n- [Arrays](#Arrays)\n- [Source Encoding](#Source-Encoding)\n\n#### [Escape Sequences](#toc-Escape-Sequences)\n\n| Escape Sequence | Name                                                            |\n|-----------------|-----------------------------------------------------------------|\n| `\\n`            | Newline                                                         |\n| `\\r`            | Carriage Return                                                 |\n| `\\t`            | Tab                                                             |\n| `\\\\`            | Backslash                                                       |\n| `\\'`            | Single Quote                                                    |\n| `\\\"`            | Double Quote                                                    |\n| `\\xNN`          | hexadecimal 8-bit byte value (2 digits)                         |\n| `\\u{NNNNNN}`    | hexadecimal Unicode code point UTF-8 encoded (1 or more digits) |\n\nEscape Sequences\n\nNote that the maximum valid Unicode point is `0x10ffff`.\n\n#### [Multiline String Literals](#toc-Multiline-String-Literals)\n\nMultiline string literals have no escapes and can span across multiple lines. To start a multiline string literal, use the `\\\\` token. Just like a comment, the string literal goes until the end of the line. The end of the line is not included in the string literal. However, if the next line begins with `\\\\` then a newline is appended and the string literal continues.\n\n``` zig\nconst hello_world_in_c =\n    \\\\#include <stdio.h>\n    \\\\\n    \\\\int main(int argc, char **argv) {\n    \\\\    printf(\"hello world\\n\");\n    \\\\    return 0;\n    \\\\}\n;\n```\n\nmultiline_string_literals.zig\n\nSee also:\n\n- [@embedFile](#embedFile)\n\n&nbsp;"
- name: Variables
  id: index#Variables
  summary: A variable is a unit of Memory storage
  description: |-
    ## Variables

    A variable is a unit of [Memory](#Memory) storage.

    It is generally preferable to use `const` rather than `var` when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities.

    The `extern` keyword or [@extern](#extern) builtin function can be used to link against a variable that is exported from another object. The `export` keyword or [@export](#export) builtin function can be used to make a variable available to other objects at link time. In both cases, the type of the variable must be C ABI compatible.

    See also:

    - [Exporting a C Library](#Exporting-a-C-Library)

    &nbsp;
- name: 'Variables: Container Level Variables'
  id: index#Container-Level-Variables
  summary: Container level variables have static lifetime and are order-independent and lazily analyzed
  description: "### Container Level Variables\n\n[Container](#Containers) level variables have static lifetime and are order-independent and lazily analyzed. The initialization value of container level variables is implicitly [comptime](#comptime). If a container level variable is `const` then its value is `comptime`-known, otherwise it is runtime-known.\n\n``` zig\nvar y: i32 = add(10, x);\nconst x: i32 = add(12, 34);\n\ntest \"container level variables\" {\n    try expect(x == 46);\n    try expect(y == 56);\n}\n\nfn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n```\n\ntest_container_level_variables.zig\n\n            $ zig test test_container_level_variables.zig\n    1/1 test_container_level_variables.test.container level variables...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nContainer level variables may be declared inside a [struct](#struct), [union](#union), [enum](#enum), or [opaque](#opaque):\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"namespaced container level variable\" {\n    try expect(foo() == 1235);\n    try expect(foo() == 1236);\n}\n\nconst S = struct {\n    var x: i32 = 1234;\n};\n\nfn foo() i32 {\n    S.x += 1;\n    return S.x;\n}\n```\n\ntest_namespaced_container_level_variable.zig\n\n            $ zig test test_namespaced_container_level_variable.zig\n    1/1 test_namespaced_container_level_variable.test.namespaced container level variable...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Variables: Identifiers'
  id: index#Identifiers
  summary: Variable identifiers are never allowed to shadow identifiers from an outer scope
  description: |-
    ### Identifiers

    Variable identifiers are never allowed to shadow identifiers from an outer scope.

    Identifiers must start with an alphabetic character or underscore and may be followed by any number of alphanumeric characters or underscores. They must not overlap with any keywords. See [Keyword Reference](#Keyword-Reference).

    If a name that does not fit these requirements is needed, such as for linking with external libraries, the `@""` syntax may be used.

    ``` zig
    const @"identifier with spaces in it" = 0xff;
    const @"1SmallStep4Man" = 112358;

    const c = @import("std").c;
    pub extern "c" fn @"error"() void;
    pub extern "c" fn @"fstat$INODE64"(fd: c.fd_t, buf: *c.Stat) c_int;

    const Color = enum {
        red,
        @"really red",
    };
    const color: Color = .@"really red";
    ```

    identifiers.zig
- name: 'Variables: Local Variables'
  id: index#Local-Variables
  summary: Local variables occur inside Functions, comptime blocks, and @cImport blocks
  description: "### Local Variables\n\nLocal variables occur inside [Functions](#Functions), [comptime](#comptime) blocks, and [@cImport](#cImport) blocks.\n\nWhen a local variable is `const`, it means that after initialization, the variable's value will not change. If the initialization value of a `const` variable is [comptime](#comptime)-known, then the variable is also `comptime`-known.\n\nA local variable may be qualified with the `comptime` keyword. This causes the variable's value to be `comptime`-known, and all loads and stores of the variable to happen during semantic analysis of the program, rather than at runtime. All variables declared in a `comptime` expression are implicitly `comptime` variables.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"comptime vars\" {\n    var x: i32 = 1;\n    comptime var y: i32 = 1;\n\n    x += 1;\n    y += 1;\n\n    try expect(x == 2);\n    try expect(y == 2);\n\n    if (y != 2) {\n        // This compile error never triggers because y is a comptime variable,\n        // and so `y != 2` is a comptime value, and this if is statically evaluated.\n        @compileError(\"wrong y value\");\n    }\n}\n```\n\ntest_comptime_variables.zig\n\n            $ zig test test_comptime_variables.zig\n    1/1 test_comptime_variables.test.comptime vars...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Variables: Static Local Variables'
  id: index#Static-Local-Variables
  summary: It is also possible to have local variables with static lifetime by using containers inside functions
  description: "### Static Local Variables\n\nIt is also possible to have local variables with static lifetime by using containers inside functions.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"static local variable\" {\n    try expect(foo() == 1235);\n    try expect(foo() == 1236);\n}\n\nfn foo() i32 {\n    const S = struct {\n        var x: i32 = 1234;\n    };\n    S.x += 1;\n    return S.x;\n}\n```\n\ntest_static_local_variable.zig\n\n            $ zig test test_static_local_variable.zig\n    1/1 test_static_local_variable.test.static local variable...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Variables: Thread Local Variables'
  id: index#Thread-Local-Variables
  summary: For Single Threaded Builds, all thread local variables are treated as regular Container Level Variables
  description: "### Thread Local Variables\n\nA variable may be specified to be a thread-local variable using the `threadlocal` keyword, which makes each thread work with a separate instance of the variable:\n\n``` zig\nconst std = @import(\"std\");\nconst assert = std.debug.assert;\n\nthreadlocal var x: i32 = 1234;\n\ntest \"thread local storage\" {\n    const thread1 = try std.Thread.spawn(.{}, testTls, .{});\n    const thread2 = try std.Thread.spawn(.{}, testTls, .{});\n    testTls();\n    thread1.join();\n    thread2.join();\n}\n\nfn testTls() void {\n    assert(x == 1234);\n    x += 1;\n    assert(x == 1235);\n}\n```\n\ntest_thread_local_variables.zig\n\n            $ zig test test_thread_local_variables.zig\n    1/1 test_thread_local_variables.test.thread local storage...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nFor [Single Threaded Builds](#Single-Threaded-Builds), all thread local variables are treated as regular [Container Level Variables](#Container-Level-Variables).\n\nThread local variables may not be `const`."
- name: Vectors
  id: index#Vectors
  summary: A vector is a group of booleans, Integers, Floats, or Pointers which are operated on in parallel, using SIMD instructions if possible
  description: "## Vectors\n\nA vector is a group of booleans, [Integers](#Integers), [Floats](#Floats), or [Pointers](#Pointers) which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function [@Vector](#Vector).\n\nVectors support the same builtin operators as their underlying base types. These operations are performed element-wise, and return a vector of the same length as the input vectors. This includes:\n\n- Arithmetic (`+`, `-`, `/`, `*`, `@divFloor`, `@sqrt`, `@ceil`, `@log`, etc.)\n- Bitwise operators (`>>`, `<<`, `&`, `|`, `~`, etc.)\n- Comparison operators (`<`, `>`, `==`, etc.)\n\nIt is prohibited to use a math operator on a mixture of scalars (individual numbers) and vectors. Zig provides the [@splat](#splat) builtin to easily convert from scalars to vectors, and it supports [@reduce](#reduce) and array indexing syntax to convert from vectors to scalars. Vectors also support assignment to and from fixed-length arrays with comptime-known length.\n\nFor rearranging elements within and between vectors, Zig provides the [@shuffle](#shuffle) and [@select](#select) functions.\n\nOperations on vectors shorter than the target machine's native SIMD size will typically compile to single SIMD instructions, while vectors longer than the target machine's native SIMD size will compile to multiple SIMD instructions. If a given operation doesn't have SIMD support on the target architecture, the compiler will default to operating on each vector element one at a time. Zig supports any comptime-known vector length up to 2^32-1, although small powers of two (2-64) are most typical. Note that excessively long vector lengths (e.g. 2^20) may result in compiler crashes on current versions of Zig.\n\n``` zig\nconst std = @import(\"std\");\nconst expectEqual = std.testing.expectEqual;\n\ntest \"Basic vector usage\" {\n    // Vectors have a compile-time known length and base type.\n    const a = @Vector(4, i32){ 1, 2, 3, 4 };\n    const b = @Vector(4, i32){ 5, 6, 7, 8 };\n\n    // Math operations take place element-wise.\n    const c = a + b;\n\n    // Individual vector elements can be accessed using array indexing syntax.\n    try expectEqual(6, c[0]);\n    try expectEqual(8, c[1]);\n    try expectEqual(10, c[2]);\n    try expectEqual(12, c[3]);\n}\n\ntest \"Conversion between vectors, arrays, and slices\" {\n    // Vectors and fixed-length arrays can be automatically assigned back and forth\n    const arr1: [4]f32 = [_]f32{ 1.1, 3.2, 4.5, 5.6 };\n    const vec: @Vector(4, f32) = arr1;\n    const arr2: [4]f32 = vec;\n    try expectEqual(arr1, arr2);\n\n    // You can also assign from a slice with comptime-known length to a vector using .*\n    const vec2: @Vector(2, f32) = arr1[1..3].*;\n\n    const slice: []const f32 = &arr1;\n    var offset: u32 = 1; // var to make it runtime-known\n    _ = &offset; // suppress 'var is never mutated' error\n    // To extract a comptime-known length from a runtime-known offset,\n    // first extract a new slice from the starting offset, then an array of\n    // comptime-known length\n    const vec3: @Vector(2, f32) = slice[offset..][0..2].*;\n    try expectEqual(slice[offset], vec2[0]);\n    try expectEqual(slice[offset + 1], vec2[1]);\n    try expectEqual(vec2, vec3);\n}\n```\n\ntest_vector.zig\n\n            $ zig test test_vector.zig\n    1/2 test_vector.test.Basic vector usage...OK\n    2/2 test_vector.test.Conversion between vectors, arrays, and slices...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nTODO talk about C ABI interop  \nTODO consider suggesting std.MultiArrayList\n\nSee also:\n\n- [@splat](#splat)\n- [@shuffle](#shuffle)\n- [@select](#select)\n- [@reduce](#reduce)\n\n&nbsp;"
- name: WebAssembly
  id: index#WebAssembly
  summary: Zig supports building for WebAssembly out of the box
  description: |-
    ## WebAssembly

    Zig supports building for WebAssembly out of the box.
- name: 'WebAssembly: Freestanding'
  id: index#Freestanding
  summary: For host environments like the web browser and nodejs, build as an executable using the freestanding OS target
  description: "### Freestanding\n\nFor host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs.\n\n``` zig\nextern fn print(i32) void;\n\nexport fn add(a: i32, b: i32) void {\n    print(a + b);\n}\n```\n\nmath.zig\n\n            $ zig build-exe math.zig -target wasm32-freestanding -fno-entry --export=add\n\n          \n\nShell\n\n``` zig\nconst fs = require('fs');\nconst source = fs.readFileSync(\"./math.wasm\");\nconst typedArray = new Uint8Array(source);\n\nWebAssembly.instantiate(typedArray, {\n  env: {\n    print: (result) => { console.log(`The result is ${result}`); }\n  }}).then(result => {\n  const add = result.instance.exports.add;\n  add(1, 2);\n});\n```\n\ntest.js\n\n            $ node test.js\n    The result is 3\n\n          \n\nShell"
- name: 'WebAssembly: WASI'
  id: index#WASI
  summary: Zig's support for WebAssembly System Interface (WASI) is under active development
  description: "### WASI\n\nZig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};\n    const gpa = general_purpose_allocator.allocator();\n    const args = try std.process.argsAlloc(gpa);\n    defer std.process.argsFree(gpa, args);\n\n    for (args, 0..) |arg, i| {\n        std.debug.print(\"{}: {s}\\n\", .{ i, arg });\n    }\n}\n```\n\nwasi_args.zig\n\n            $ zig build-exe wasi_args.zig -target wasm32-wasi\n\n          \n\nShell\n\n            $ wasmtime wasi_args.wasm 123 hello\n    0: wasi_args.wasm\n    1: 123\n    2: hello\n\n          \n\nShell\n\nA more interesting example would be extracting the list of preopens from the runtime. This is now supported in the standard library via `std.fs.wasi.Preopens`:\n\n``` zig\nconst std = @import(\"std\");\nconst fs = std.fs;\n\npub fn main() !void {\n    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};\n    const gpa = general_purpose_allocator.allocator();\n\n    var arena_instance = std.heap.ArenaAllocator.init(gpa);\n    defer arena_instance.deinit();\n    const arena = arena_instance.allocator();\n\n    const preopens = try fs.wasi.preopensAlloc(arena);\n\n    for (preopens.names, 0..) |preopen, i| {\n        std.debug.print(\"{}: {s}\\n\", .{ i, preopen });\n    }\n}\n```\n\nwasi_preopens.zig\n\n            $ zig build-exe wasi_preopens.zig -target wasm32-wasi\n\n          \n\nShell\n\n            $ wasmtime --dir=. wasi_preopens.wasm\n    0: stdin\n    1: stdout\n    2: stderr\n    3: .\n\n          \n\nShell"
- name: while
  id: index#while
  summary: A while loop is used to repeatedly execute an expression until some condition is no longer true
  description: "## while\n\nA while loop is used to repeatedly execute an expression until some condition is no longer true.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while basic\" {\n    var i: usize = 0;\n    while (i < 10) {\n        i += 1;\n    }\n    try expect(i == 10);\n}\n```\n\ntest_while.zig\n\n            $ zig test test_while.zig\n    1/1 test_while.test.while basic...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nUse `break` to exit a while loop early.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while break\" {\n    var i: usize = 0;\n    while (true) {\n        if (i == 10)\n            break;\n        i += 1;\n    }\n    try expect(i == 10);\n}\n```\n\ntest_while_break.zig\n\n            $ zig test test_while_break.zig\n    1/1 test_while_break.test.while break...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nUse `continue` to jump back to the beginning of the loop.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while continue\" {\n    var i: usize = 0;\n    while (true) {\n        i += 1;\n        if (i < 10)\n            continue;\n        break;\n    }\n    try expect(i == 10);\n}\n```\n\ntest_while_continue.zig\n\n            $ zig test test_while_continue.zig\n    1/1 test_while_continue.test.while continue...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nWhile loops support a continue expression which is executed when the loop is continued. The `continue` keyword respects this expression.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while loop continue expression\" {\n    var i: usize = 0;\n    while (i < 10) : (i += 1) {}\n    try expect(i == 10);\n}\n\ntest \"while loop continue expression, more complicated\" {\n    var i: usize = 1;\n    var j: usize = 1;\n    while (i * j < 2000) : ({\n        i *= 2;\n        j *= 3;\n    }) {\n        const my_ij = i * j;\n        try expect(my_ij < 2000);\n    }\n}\n```\n\ntest_while_continue_expression.zig\n\n            $ zig test test_while_continue_expression.zig\n    1/2 test_while_continue_expression.test.while loop continue expression...OK\n    2/2 test_while_continue_expression.test.while loop continue expression, more complicated...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nWhile loops are expressions. The result of the expression is the result of the `else` clause of a while loop, which is executed when the condition of the while loop is tested as false.\n\n`break`, like `return`, accepts a value parameter. This is the result of the `while` expression. When you `break` from a while loop, the `else` branch is not evaluated.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while else\" {\n    try expect(rangeHasNumber(0, 10, 5));\n    try expect(!rangeHasNumber(0, 10, 15));\n}\n\nfn rangeHasNumber(begin: usize, end: usize, number: usize) bool {\n    var i = begin;\n    return while (i < end) : (i += 1) {\n        if (i == number) {\n            break true;\n        }\n    } else false;\n}\n```\n\ntest_while_else.zig\n\n            $ zig test test_while_else.zig\n    1/1 test_while_else.test.while else...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'while: inline while'
  id: index#inline-while
  summary: While loops can be inlined
  description: "### inline while\n\nWhile loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"inline while loop\" {\n    comptime var i = 0;\n    var sum: usize = 0;\n    inline while (i < 3) : (i += 1) {\n        const T = switch (i) {\n            0 => f32,\n            1 => i8,\n            2 => bool,\n            else => unreachable,\n        };\n        sum += typeNameLength(T);\n    }\n    try expect(sum == 9);\n}\n\nfn typeNameLength(comptime T: type) usize {\n    return @typeName(T).len;\n}\n```\n\ntest_inline_while.zig\n\n            $ zig test test_inline_while.zig\n    1/1 test_inline_while.test.inline while loop...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nIt is recommended to use `inline` loops only for one of these reasons:\n\n- You need the loop to execute at [comptime](#comptime) for the semantics to work.\n- You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.\n\nSee also:\n\n- [if](#if)\n- [Optionals](#Optionals)\n- [Errors](#Errors)\n- [comptime](#comptime)\n- [unreachable](#unreachable)\n\n&nbsp;"
- name: 'while: Labeled while'
  id: index#Labeled-while
  summary: null
  description: "### Labeled while\n\nWhen a `while` loop is labeled, it can be referenced from a `break` or `continue` from within a nested loop:\n\n``` zig\ntest \"nested break\" {\n    outer: while (true) {\n        while (true) {\n            break :outer;\n        }\n    }\n}\n\ntest \"nested continue\" {\n    var i: usize = 0;\n    outer: while (i < 10) : (i += 1) {\n        while (true) {\n            continue :outer;\n        }\n    }\n}\n```\n\ntest_while_nested_break.zig\n\n            $ zig test test_while_nested_break.zig\n    1/2 test_while_nested_break.test.nested break...OK\n    2/2 test_while_nested_break.test.nested continue...OK\n    All 2 tests passed.\n\n          \n\nShell"
- name: 'while: while with Error Unions'
  id: index#while-with-Error-Unions
  summary: Just like if expressions, while loops can take an error union as the condition and capture the payload or the error code
  description: "### while with Error Unions\n\nJust like [if](#if) expressions, while loops can take an error union as the condition and capture the payload or the error code. When the condition results in an error code the else branch is evaluated and the loop is finished.\n\nWhen the `else`` |x|` syntax is present on a `while` expression, the while condition must have an [Error Union Type](#Error-Union-Type).\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while error union capture\" {\n    var sum1: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyErrorSequence()) |value| {\n        sum1 += value;\n    } else |err| {\n        try expect(err == error.ReachedZero);\n    }\n}\n\nvar numbers_left: u32 = undefined;\n\nfn eventuallyErrorSequence() anyerror!u32 {\n    return if (numbers_left == 0) error.ReachedZero else blk: {\n        numbers_left -= 1;\n        break :blk numbers_left;\n    };\n}\n```\n\ntest_while_error_capture.zig\n\n            $ zig test test_while_error_capture.zig\n    1/1 test_while_error_capture.test.while error union capture...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'while: while with Optionals'
  id: index#while-with-Optionals
  summary: Just like if expressions, while loops can take an optional as the condition and capture the payload
  description: "### while with Optionals\n\nJust like [if](#if) expressions, while loops can take an optional as the condition and capture the payload. When [null](#null) is encountered the loop exits.\n\nWhen the `|x|` syntax is present on a `while` expression, the while condition must have an [Optional Type](#Optional-Type).\n\nThe `else` branch is allowed on optional iteration. In this case, it will be executed on the first null value encountered.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while null capture\" {\n    var sum1: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyNullSequence()) |value| {\n        sum1 += value;\n    }\n    try expect(sum1 == 3);\n\n    // null capture with an else block\n    var sum2: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyNullSequence()) |value| {\n        sum2 += value;\n    } else {\n        try expect(sum2 == 3);\n    }\n\n    // null capture with a continue expression\n    var i: u32 = 0;\n    var sum3: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyNullSequence()) |value| : (i += 1) {\n        sum3 += value;\n    }\n    try expect(i == 3);\n}\n\nvar numbers_left: u32 = undefined;\nfn eventuallyNullSequence() ?u32 {\n    return if (numbers_left == 0) null else blk: {\n        numbers_left -= 1;\n        break :blk numbers_left;\n    };\n}\n```\n\ntest_while_null_capture.zig\n\n            $ zig test test_while_null_capture.zig\n    1/1 test_while_null_capture.test.while null capture...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: Zero Bit Types
  id: index#Zero-Bit-Types
  summary: These types can only ever have one possible value, and thus require 0 bits to represent
  description: "## Zero Bit Types\n\nFor some types, [@sizeOf](#sizeOf) is 0:\n\n- [void](#void)\n- The [Integers](#Integers) `u0` and `i0`.\n- [Arrays](#Arrays) and [Vectors](#Vectors) with len 0, or with an element type that is a zero bit type.\n- An [enum](#enum) with only 1 tag.\n- A [struct](#struct) with all fields being zero bit types.\n- A [union](#union) with only 1 field which is a zero bit type.\n\nThese types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code:\n\n``` zig\nexport fn entry() void {\n    var x: void = {};\n    var y: void = {};\n    x = y;\n    y = x;\n}\n```\n\nzero_bit_types.zig\n\nWhen this turns into machine code, there is no code generated in the body of `entry`, even in [Debug](#Debug) mode. For example, on x86_64:\n\n``` zig\n0000000000000010 <entry>:\n  10:   55                      push   %rbp\n  11:   48 89 e5                mov    %rsp,%rbp\n  14:   5d                      pop    %rbp\n  15:   c3                      retq   \n```\n\nThese assembly instructions do not have any code associated with the void values - they only perform the function call prologue and epilogue."
- name: 'Zero Bit Types: void'
  id: index#void
  summary: void can be useful for instantiating generic types
  description: "### void\n\n`void` can be useful for instantiating generic types. For example, given a `Map(Key, Value)`, one can pass `void` for the `Value` type to make it into a `Set`:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"turn HashMap into a set with void\" {\n    var map = std.AutoHashMap(i32, void).init(std.testing.allocator);\n    defer map.deinit();\n\n    try map.put(1, {});\n    try map.put(2, {});\n\n    try expect(map.contains(2));\n    try expect(!map.contains(3));\n\n    _ = map.remove(2);\n    try expect(!map.contains(2));\n}\n```\n\ntest_void_in_hashmap.zig\n\n            $ zig test test_void_in_hashmap.zig\n    1/1 test_void_in_hashmap.test.turn HashMap into a set with void...OK\n    All 1 tests passed.\n\n          \n\nShell\n\nNote that this is different from using a dummy value for the hash map value. By using `void` as the type of the value, the hash map entry type has no value field, and thus the hash map takes up less space. Further, all the code that deals with storing and loading the value is deleted, as seen above.\n\n`void` is distinct from `anyopaque`. `void` has a known size of 0 bytes, and `anyopaque` has an unknown, but non-zero, size.\n\nExpressions of type `void` are the only ones whose value can be ignored. For example, ignoring a non-`void` expression is a compile error:\n\n``` zig\ntest \"ignoring expression value\" {\n    foo();\n}\n\nfn foo() i32 {\n    return 1234;\n}\n```\n\ntest_expression_ignored.zig\n\n            $ zig test test_expression_ignored.zig\n    doc/langref/test_expression_ignored.zig:2:8: error: value of type 'i32' ignored\n        foo();\n        ~~~^~\n    doc/langref/test_expression_ignored.zig:2:8: note: all non-void values must be used\n    doc/langref/test_expression_ignored.zig:2:8: note: to discard the value, assign it to '_'\n\n\n          \n\nShell\n\nHowever, if the expression has type `void`, there will be no error. Expression results can be explicitly ignored by assigning them to `_`.\n\n``` zig\ntest \"void is ignored\" {\n    returnsVoid();\n}\n\ntest \"explicitly ignoring expression value\" {\n    _ = foo();\n}\n\nfn returnsVoid() void {}\n\nfn foo() i32 {\n    return 1234;\n}\n```\n\ntest_void_ignored.zig\n\n            $ zig test test_void_ignored.zig\n    1/2 test_void_ignored.test.void is ignored...OK\n    2/2 test_void_ignored.test.explicitly ignoring expression value...OK\n    All 2 tests passed.\n\n          \n\nShell"
- name: Zig Build System
  id: index#Zig-Build-System
  summary: The Zig Build System provides a cross-platform, dependency-free way to declare the logic required to build a project
  description: |-
    ## Zig Build System

    The Zig Build System provides a cross-platform, dependency-free way to declare the logic required to build a project. With this system, the logic to build a project is written in a build.zig file, using the Zig Build System API to declare and configure build artifacts and other tasks.

    Some examples of tasks the build system can help with:

    - Performing tasks in parallel and caching the results.
    - Depending on other projects.
    - Providing a package for other projects to depend on.
    - Creating build artifacts by executing the Zig compiler. This includes building Zig source code as well as C and C++ source code.
    - Capturing user-configured options and using those options to configure the build.
    - Surfacing build configuration as [comptime](#comptime) values by providing a file that can be [imported](#import) by Zig code.
    - Caching build artifacts to avoid unnecessarily repeating steps.
    - Executing build artifacts or system-installed tools.
    - Running tests and verifying the output of executing a build artifact matches the expected value.
    - Running `zig fmt` on a codebase or a subset of it.
    - Custom tasks.

    To use the build system, run zig build --help to see a command-line usage help menu. This will include project-specific options that were declared in the build.zig script.

    For the time being, the build system documentation is hosted externally: [Build System Documentation](https://ziglang.org/learn/build-system/)
- name: Zig Standard Library
  id: index#Zig-Standard-Library
  summary: The Zig Standard Library has its own documentation
  description: |-
    ## Zig Standard Library

    The [Zig Standard Library](https://ziglang.org/documentation/master/std/) has its own documentation.

    Zig's Standard Library contains commonly used algorithms, data structures, and definitions to help you build programs or libraries. You will see many examples of Zig's Standard Library used in this documentation. To learn more about the Zig Standard Library, visit the link above.
- name: Zig Test
  id: index#Zig-Test
  summary: The testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41
  description: "## Zig Test\n\nCode written within one or more `test` declarations can be used to ensure behavior meets expectations:\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"expect addOne adds one to 41\" {\n\n    // The Standard Library contains useful functions to help create tests.\n    // `expect` is a function that verifies its argument is true.\n    // It will return an error if its argument is false to indicate a failure.\n    // `try` is used to return an error to the test runner to notify it that the test failed.\n    try std.testing.expect(addOne(41) == 42);\n}\n\ntest addOne {\n    // A test name can also be written using an identifier.\n    // This is a doctest, and serves as documentation for `addOne`.\n    try std.testing.expect(addOne(41) == 42);\n}\n\n/// The function `addOne` adds one to the number given as its argument.\nfn addOne(number: i32) i32 {\n    return number + 1;\n}\n```\n\ntesting_introduction.zig\n\n            $ zig test testing_introduction.zig\n    1/2 testing_introduction.test.expect addOne adds one to 41...OK\n    2/2 testing_introduction.decltest.addOne...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nThe `testing_introduction.zig` code sample tests the [function](#Functions) `addOne` to ensure that it returns `42` given the input `41`. From this test's perspective, the `addOne` function is said to be *code under test*.\n\nzig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the *default test runner* provided by the [Zig Standard Library](#Zig-Standard-Library) as its main entry point. During the build, `test` declarations found while [resolving](#Root-Source-File) the given Zig source file are included for the default test runner to run and report on.\n\nThis documentation discusses the features of the default test runner as provided by the Zig Standard Library. Its source code is located in `lib/test_runner.zig`.\n\nThe shell output shown above displays two lines after the zig test command. These lines are printed to standard error by the default test runner:\n\n`1/2 testing_introduction.test.expect addOne adds one to 41...`\n\nLines like this indicate which test, out of the total number of tests, is being run. In this case, `1/2` indicates that the first test, out of a total of two tests, is being run. Note that, when the test runner program's standard error is output to the terminal, these lines are cleared when a test succeeds.\n\n`2/2 testing_introduction.decltest.addOne...`\n\nWhen the test name is an identifier, the default test runner uses the text decltest instead of test.\n\n`All 2 tests passed.`\n\nThis line indicates the total number of tests that have passed."
- name: 'Zig Test: Detecting Test Build'
  id: index#Detecting-Test-Build
  summary: null
  description: "### Detecting Test Build\n\nUse the [compile variable](#Compile-Variables) `@import``(``\"builtin\"``).is_test` to detect a test build:\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\n\ntest \"builtin.is_test\" {\n    try expect(isATest());\n}\n\nfn isATest() bool {\n    return builtin.is_test;\n}\n```\n\ntesting_detect_test.zig\n\n            $ zig test testing_detect_test.zig\n    1/1 testing_detect_test.test.builtin.is_test...OK\n    All 1 tests passed.\n\n          \n\nShell"
- name: 'Zig Test: Report Memory Leaks'
  id: index#Report-Memory-Leaks
  summary: null
  description: "### Report Memory Leaks\n\nWhen code allocates [Memory](#Memory) using the [Zig Standard Library](#Zig-Standard-Library)'s testing allocator, `std.testing.allocator`, the default test runner will report any leaks that are found from using the testing allocator:\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"detect leak\" {\n    var list = std.ArrayList(u21).init(std.testing.allocator);\n    // missing `defer list.deinit();`\n    try list.append('☔');\n\n    try std.testing.expect(list.items.len == 1);\n}\n```\n\ntesting_detect_leak.zig\n\n            $ zig test testing_detect_leak.zig\n    1/1 testing_detect_leak.test.detect leak...OK\n    [gpa] (err): memory address 0x7fdbea69e000 leaked:\n    /home/andy/src/zig/lib/std/array_list.zig:457:67: 0x104f76e in ensureTotalCapacityPrecise (test)\n                    const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);\n                                                                      ^\n    /home/andy/src/zig/lib/std/array_list.zig:434:51: 0x1045610 in ensureTotalCapacity (test)\n                return self.ensureTotalCapacityPrecise(better_capacity);\n                                                      ^\n    /home/andy/src/zig/lib/std/array_list.zig:483:41: 0x1041fe0 in addOne (test)\n                try self.ensureTotalCapacity(newlen);\n                                            ^\n    /home/andy/src/zig/lib/std/array_list.zig:262:49: 0x103ef2d in append (test)\n                const new_item_ptr = try self.addOne();\n                                                    ^\n    /home/andy/src/zig/doc/langref/testing_detect_leak.zig:6:20: 0x103d172 in test.detect leak (test)\n        try list.append('☔');\n                       ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104c6a0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x10428bb in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103f429 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103ef91 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    All 1 tests passed.\n    1 errors were logged.\n    1 tests leaked memory.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/4a17198138bf81bcfabd5652b0d6be24/test\n\n          \n\nShell\n\nSee also:\n\n- [defer](#defer)\n- [Memory](#Memory)\n\n&nbsp;"
- name: 'Zig Test: Skip Tests'
  id: index#Skip-Tests
  summary: One way to skip tests is to filter them out by using the zig test command line parameter --test-filter [text]
  description: "### Skip Tests\n\nOne way to skip tests is to filter them out by using the zig test command line parameter --test-filter \\[text\\]. This makes the test build only include tests whose name contains the supplied filter text. Note that non-named tests are run even when using the --test-filter \\[text\\] command line parameter.\n\nTo programmatically skip a test, make a `test` return the error `error``.SkipZigTest` and the default test runner will consider the test as being skipped. The total number of skipped tests will be reported after all tests have run.\n\n``` zig\ntest \"this will be skipped\" {\n    return error.SkipZigTest;\n}\n```\n\ntesting_skip.zig\n\n            $ zig test testing_skip.zig\n    1/1 testing_skip.test.this will be skipped...SKIP\n    0 passed; 1 skipped; 0 failed.\n\n          \n\nShell"
- name: 'Zig Test: Test Declarations'
  id: index#Test-Declarations
  summary: Test declarations contain the keyword test, followed by an optional name written as a string literal or an identifier, followed by a block containing any valid Zig code that is allowed in a function
  description: |-
    ### Test Declarations

    Test declarations contain the [keyword](#Keyword-Reference) `test`, followed by an optional name written as a [string literal](#String-Literals-and-Unicode-Code-Point-Literals) or an [identifier](#Identifiers), followed by a [block](#Blocks) containing any valid Zig code that is allowed in a [function](#Functions).

    Non-named test blocks always run during test builds and are exempt from [Skip Tests](#Skip-Tests).

    Test declarations are similar to [Functions](#Functions): they have a return type and a block of code. The implicit return type of `test` is the [Error Union Type](#Error-Union-Type) `anyerror``!``void`, and it cannot be changed. When a Zig source file is not built using the zig test tool, the test declarations are omitted from the build.

    Test declarations can be written in the same file, where code under test is written, or in a separate Zig source file. Since test declarations are top-level declarations, they are order-independent and can be written before or after the code under test.

    See also:

    - [The Global Error Set](#The-Global-Error-Set)
    - [Grammar](#Grammar)

    #### [Doctests](#toc-Doctests)

    Test declarations named using an identifier are *doctests*. The identifier must refer to another declaration in scope. A doctest, like a [doc comment](#Doc-Comments), serves as documentation for the associated declaration, and will appear in the generated documentation for the declaration.

    An effective doctest should be self-contained and focused on the declaration being tested, answering questions a new user might have about its interface or intended usage, while avoiding unnecessary or confusing details. A doctest is not a substitute for a doc comment, but rather a supplement and companion providing a testable, code-driven example, verified by zig test.
- name: 'Zig Test: Test Failure'
  id: index#Test-Failure
  summary: The default test runner checks for an error returned from a test
  description: "### Test Failure\n\nThe default test runner checks for an [error](#Errors) returned from a test. When a test returns an error, the test is considered a failure and its [error return trace](#Error-Return-Traces) is output to standard error. The total number of failures will be reported after all tests have run.\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"expect this to fail\" {\n    try std.testing.expect(false);\n}\n\ntest \"expect this to succeed\" {\n    try std.testing.expect(true);\n}\n```\n\ntesting_failure.zig\n\n            $ zig test testing_failure.zig\n    1/2 testing_failure.test.expect this to fail...FAIL (TestUnexpectedResult)\n    /home/andy/src/zig/lib/std/testing.zig:540:14: 0x103ce3f in expect (test)\n        if (!ok) return error.TestUnexpectedResult;\n                 ^\n    /home/andy/src/zig/doc/langref/testing_failure.zig:4:5: 0x103cf55 in test.expect this to fail (test)\n        try std.testing.expect(false);\n        ^\n    2/2 testing_failure.test.expect this to succeed...OK\n    1 passed; 0 skipped; 1 failed.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/054f0b6f088824f384d1b6c648523593/test\n\n          \n\nShell"
- name: 'Zig Test: Test Output and Logging'
  id: index#Test-Output-and-Logging
  summary: The default test runner and the Zig Standard Library's testing namespace output messages to standard error
  description: |-
    ### Test Output and Logging

    The default test runner and the Zig Standard Library's testing namespace output messages to standard error.
- name: 'Zig Test: Test Tool Documentation'
  id: index#Test-Tool-Documentation
  summary: zig test has a few command line parameters which affect the compilation
  description: |-
    ### Test Tool Documentation

    zig test has a few command line parameters which affect the compilation. See zig test --help for a full list.
- name: 'Zig Test: The Testing Namespace'
  id: index#The-Testing-Namespace
  summary: The Zig Standard Library's testing namespace contains useful functions to help you create tests
  description: "### The Testing Namespace\n\nThe Zig Standard Library's `testing` namespace contains useful functions to help you create tests. In addition to the `expect` function, this document uses a couple of more functions as exemplified here:\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"expectEqual demo\" {\n    const expected: i32 = 42;\n    const actual = 42;\n\n    // The first argument to `expectEqual` is the known, expected, result.\n    // The second argument is the result of some expression.\n    // The actual's type is casted to the type of expected.\n    try std.testing.expectEqual(expected, actual);\n}\n\ntest \"expectError demo\" {\n    const expected_error = error.DemoError;\n    const actual_error_union: anyerror!void = error.DemoError;\n\n    // `expectError` will fail when the actual error is different than\n    // the expected error.\n    try std.testing.expectError(expected_error, actual_error_union);\n}\n```\n\ntesting_namespace.zig\n\n            $ zig test testing_namespace.zig\n    1/2 testing_namespace.test.expectEqual demo...OK\n    2/2 testing_namespace.test.expectError demo...OK\n    All 2 tests passed.\n\n          \n\nShell\n\nThe Zig Standard Library also contains functions to compare [Slices](#Slices), strings, and more. See the rest of the `std.testing` namespace in the [Zig Standard Library](#Zig-Standard-Library) for more available functions."
- name: Zig Version
  id: index#zig-version
  summary: Zig is a general-purpose programming language and toolchain for maintaining robust, optimal, and reusable software
  description: "# Zig Language Reference\n\n## Introduction\n\n[Zig](https://ziglang.org) is a general-purpose programming language and toolchain for maintaining **robust**, **optimal**, and **reusable** software.\n\nRobust  \nBehavior is correct even for edge cases such as out of memory.\n\nOptimal  \nWrite programs the best way they can behave and perform.\n\nReusable  \nThe same code works in many environments which have different constraints.\n\nMaintainable  \nPrecisely communicate intent to the compiler and other programmers. The language imposes a low overhead to reading code and is resilient to changing requirements and environments.\n\nOften the most efficient way to learn something new is to see examples, so this documentation shows how to use each of Zig's features. It is all on one page so you can search with your browser's search tool.\n\nThe code samples in this document are compiled and tested as part of the main test suite of Zig.\n\nThis HTML document depends on no external files, so you can use it offline.\n\n## Zig Standard Library\n\nThe [Zig Standard Library](https://ziglang.org/documentation/master/std/) has its own documentation.\n\nZig's Standard Library contains commonly used algorithms, data structures, and definitions to help you build programs or libraries. You will see many examples of Zig's Standard Library used in this documentation. To learn more about the Zig Standard Library, visit the link above.\n\n## Hello World\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello, {s}!\\n\", .{\"world\"});\n}\n```\n\nhello.zig\n\n    $ zig build-exe hello.zig\n    $ ./hello\n    Hello, world!\n\nShell\n\nMost of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. For this common case, there is a simpler API:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    std.debug.print(\"Hello, world!\\n\", .{});\n}\n```\n\nhello_again.zig\n\n    $ zig build-exe hello_again.zig\n    $ ./hello_again\n    Hello, world!\n\nShell\n\nIn this case, the `!` may be omitted from the return type because no errors are returned from the function.\n\nSee also:\n\n- [Values](#Values)\n- [@import](#import)\n- [Errors](#Errors)\n- [Root Source File](#Root-Source-File)\n- [Source Encoding](#Source-Encoding)\n\n## Comments\n\nZig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation.\n\nThe generated documentation is still experimental, and can be produced with:\n\n    zig test -femit-docs main.zig\n\nShell\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    // Comments in Zig start with \"//\" and end at the next LF byte (end of line).\n    // The line below is a comment and won't be executed.\n\n    //print(\"Hello?\", .{});\n\n    print(\"Hello, world!\\n\", .{}); // another comment\n}\n```\n\ncomments.zig\n\n    $ zig build-exe comments.zig\n    $ ./comments\n    Hello, world!\n\nShell\n\nThere are no multiline comments in Zig (e.g. like `/* */` comments in C). This allows Zig to have the property that each line of code can be tokenized out of context.\n\n### Doc Comments\n\nA doc comment is one that begins with exactly three slashes (i.e. `///` but not `////`); multiple doc comments in a row are merged together to form a multiline doc comment. The doc comment documents whatever immediately follows it.\n\n``` zig\n/// A structure for storing a timestamp, with nanosecond precision (this is a\n/// multiline doc comment).\nconst Timestamp = struct {\n    /// The number of seconds since the epoch (this is also a doc comment).\n    seconds: i64, // signed so we can represent pre-1970 (not a doc comment)\n    /// The number of nanoseconds past the second (doc comment again).\n    nanos: u32,\n\n    /// Returns a `Timestamp` struct representing the Unix epoch; that is, the\n    /// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).\n    pub fn unixEpoch() Timestamp {\n        return Timestamp{\n            .seconds = 0,\n            .nanos = 0,\n        };\n    }\n};\n```\n\ndoc_comments.zig\n\nDoc comments are only allowed in certain places; it is a compile error to have a doc comment in an unexpected place, such as in the middle of an expression, or just before a non-doc comment.\n\n``` zig\n/// doc-comment\n//! top-level doc-comment\nconst std = @import(\"std\");\n```\n\ninvalid_doc-comment.zig\n\n    $ zig build-obj invalid_doc-comment.zig\n    doc/langref/invalid_doc-comment.zig:1:16: error: expected type expression, found 'a document comment'\n    /// doc-comment\n                   ^\n\nShell\n\n``` zig\npub fn main() void {}\n\n/// End of file\n```\n\nunattached_doc-comment.zig\n\n    $ zig build-obj unattached_doc-comment.zig\n    doc/langref/unattached_doc-comment.zig:3:1: error: unattached documentation comment\n    /// End of file\n    ^~~~~~~~~~~~~~~\n\nShell\n\nDoc comments can be interleaved with normal comments. Currently, when producing the package documentation, normal comments are merged with doc comments.\n\n### Top-Level Doc Comments\n\nA top-level doc comment is one that begins with two slashes and an exclamation point: `//!`; it documents the current module.\n\nIt is a compile error if a top-level doc comment is not placed at the start of a [container](#Containers), before any expressions.\n\n``` zig\n//! This module provides functions for retrieving the current date and\n//! time with varying degrees of precision and accuracy. It does not\n//! depend on libc, but will use functions from it if available.\n\nconst S = struct {\n    //! Top level comments are allowed inside a container other than a module,\n    //! but it is not very useful.  Currently, when producing the package\n    //! documentation, these comments are ignored.\n};\n```\n\ntldoc_comments.zig\n\n## Values\n\n``` zig\n// Top-level declarations are order-independent:\nconst print = std.debug.print;\nconst std = @import(\"std\");\nconst os = std.os;\nconst assert = std.debug.assert;\n\npub fn main() void {\n    // integers\n    const one_plus_one: i32 = 1 + 1;\n    print(\"1 + 1 = {}\\n\", .{one_plus_one});\n\n    // floats\n    const seven_div_three: f32 = 7.0 / 3.0;\n    print(\"7.0 / 3.0 = {}\\n\", .{seven_div_three});\n\n    // boolean\n    print(\"{}\\n{}\\n{}\\n\", .{\n        true and false,\n        true or false,\n        !true,\n    });\n\n    // optional\n    var optional_value: ?[]const u8 = null;\n    assert(optional_value == null);\n\n    print(\"\\noptional 1\\ntype: {}\\nvalue: {?s}\\n\", .{\n        @TypeOf(optional_value), optional_value,\n    });\n\n    optional_value = \"hi\";\n    assert(optional_value != null);\n\n    print(\"\\noptional 2\\ntype: {}\\nvalue: {?s}\\n\", .{\n        @TypeOf(optional_value), optional_value,\n    });\n\n    // error union\n    var number_or_error: anyerror!i32 = error.ArgNotFound;\n\n    print(\"\\nerror union 1\\ntype: {}\\nvalue: {!}\\n\", .{\n        @TypeOf(number_or_error),\n        number_or_error,\n    });\n\n    number_or_error = 1234;\n\n    print(\"\\nerror union 2\\ntype: {}\\nvalue: {!}\\n\", .{\n        @TypeOf(number_or_error), number_or_error,\n    });\n}\n```\n\nvalues.zig\n\n    $ zig build-exe values.zig\n    $ ./values\n    1 + 1 = 2\n    7.0 / 3.0 = 2.3333333e0\n    false\n    true\n    false\n\n    optional 1\n    type: ?[]const u8\n    value: null\n\n    optional 2\n    type: ?[]const u8\n    value: hi\n\n    error union 1\n    type: anyerror!i32\n    value: error.ArgNotFound\n\n    error union 2\n    type: anyerror!i32\n    value: 1234\n\nShell\n\n### Primitive Types\n\n| Type             | C Equivalent          | Description                                                                                   |\n|------------------|-----------------------|-----------------------------------------------------------------------------------------------|\n| `i8`             | `int8_t`              | signed 8-bit integer                                                                          |\n| `u8`             | `uint8_t`             | unsigned 8-bit integer                                                                        |\n| `i16`            | `int16_t`             | signed 16-bit integer                                                                         |\n| `u16`            | `uint16_t`            | unsigned 16-bit integer                                                                       |\n| `i32`            | `int32_t`             | signed 32-bit integer                                                                         |\n| `u32`            | `uint32_t`            | unsigned 32-bit integer                                                                       |\n| `i64`            | `int64_t`             | signed 64-bit integer                                                                         |\n| `u64`            | `uint64_t`            | unsigned 64-bit integer                                                                       |\n| `i128`           | `__int128`            | signed 128-bit integer                                                                        |\n| `u128`           | `unsigned __int128`   | unsigned 128-bit integer                                                                      |\n| `isize`          | `intptr_t`            | signed pointer sized integer                                                                  |\n| `usize`          | `uintptr_t`, `size_t` | unsigned pointer sized integer. Also see [\\#5185](https://github.com/ziglang/zig/issues/5185) |\n| `c_char`         | `char`                | for ABI compatibility with C                                                                  |\n| `c_short`        | `short`               | for ABI compatibility with C                                                                  |\n| `c_ushort`       | `unsigned short`      | for ABI compatibility with C                                                                  |\n| `c_int`          | `int`                 | for ABI compatibility with C                                                                  |\n| `c_uint`         | `unsigned int`        | for ABI compatibility with C                                                                  |\n| `c_long`         | `long`                | for ABI compatibility with C                                                                  |\n| `c_ulong`        | `unsigned long`       | for ABI compatibility with C                                                                  |\n| `c_longlong`     | `long long`           | for ABI compatibility with C                                                                  |\n| `c_ulonglong`    | `unsigned long long`  | for ABI compatibility with C                                                                  |\n| `c_longdouble`   | `long double`         | for ABI compatibility with C                                                                  |\n| `f16`            | `_Float16`            | 16-bit floating point (10-bit mantissa) IEEE-754-2008 binary16                                |\n| `f32`            | `float`               | 32-bit floating point (23-bit mantissa) IEEE-754-2008 binary32                                |\n| `f64`            | `double`              | 64-bit floating point (52-bit mantissa) IEEE-754-2008 binary64                                |\n| `f80`            | `double`              | 80-bit floating point (64-bit mantissa) IEEE-754-2008 80-bit extended precision               |\n| `f128`           | `_Float128`           | 128-bit floating point (112-bit mantissa) IEEE-754-2008 binary128                             |\n| `bool`           | `bool`                | `true` or `false`                                                                             |\n| `anyopaque`      | `void`                | Used for type-erased pointers.                                                                |\n| `void`           | (none)                | Always the value `void``{}`                                                                   |\n| `noreturn`       | (none)                | the type of `break`, `continue`, `return`, `unreachable`, and `while`` (``true``) {}`         |\n| `type`           | (none)                | the type of types                                                                             |\n| `anyerror`       | (none)                | an error code                                                                                 |\n| `comptime_int`   | (none)                | Only allowed for [comptime](#comptime)-known values. The type of integer literals.            |\n| `comptime_float` | (none)                | Only allowed for [comptime](#comptime)-known values. The type of float literals.              |\n\nPrimitive Types\n\nIn addition to the integer types above, arbitrary bit-width integers can be referenced by using an identifier of `i` or `u` followed by digits. For example, the identifier `i7` refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is `65535`.\n\nSee also:\n\n- [Integers](#Integers)\n- [Floats](#Floats)\n- [void](#void)\n- [Errors](#Errors)\n- [@Type](#Type)\n\n### Primitive Values\n\n| Name               | Description                            |\n|--------------------|----------------------------------------|\n| `true` and `false` | `bool` values                          |\n| `null`             | used to set an optional type to `null` |\n| `undefined`        | used to leave a value unspecified      |\n\nPrimitive Values\n\nSee also:\n\n- [Optionals](#Optionals)\n- [undefined](#undefined)\n\n### String Literals and Unicode Code Point Literals\n\nString literals are constant single-item [Pointers](#Pointers) to null-terminated byte arrays. The type of string literals encodes both the length, and the fact that they are null-terminated, and thus they can be [coerced](#Type-Coercion) to both [Slices](#Slices) and [Null-Terminated Pointers](#Sentinel-Terminated-Pointers). Dereferencing string literals converts them to [Arrays](#Arrays).\n\nBecause Zig source code is [UTF-8 encoded](#Source-Encoding), any non-ASCII bytes appearing within a string literal in source code carry their UTF-8 meaning into the content of the string in the Zig program; the bytes are not modified by the compiler. It is possible to embed non-UTF-8 bytes into a string literal using `\\xNN` notation.\n\nIndexing into a string containing non-ASCII bytes returns individual bytes, whether valid UTF-8 or not.\n\nUnicode code point literals have type `comptime_int`, the same as [Integer Literals](#Integer-Literals). All [Escape Sequences](#Escape-Sequences) are valid in both string literals and Unicode code point literals.\n\n``` zig\nconst print = @import(\"std\").debug.print;\nconst mem = @import(\"std\").mem; // will be used to compare bytes\n\npub fn main() void {\n    const bytes = \"hello\";\n    print(\"{}\\n\", .{@TypeOf(bytes)}); // *const [5:0]u8\n    print(\"{d}\\n\", .{bytes.len}); // 5\n    print(\"{c}\\n\", .{bytes[1]}); // 'e'\n    print(\"{d}\\n\", .{bytes[5]}); // 0\n    print(\"{}\\n\", .{'e' == '\\x65'}); // true\n    print(\"{d}\\n\", .{'\\u{1f4a9}'}); // 128169\n    print(\"{d}\\n\", .{'💯'}); // 128175\n    print(\"{u}\\n\", .{'⚡'});\n    print(\"{}\\n\", .{mem.eql(u8, \"hello\", \"h\\x65llo\")}); // true\n    print(\"{}\\n\", .{mem.eql(u8, \"💯\", \"\\xf0\\x9f\\x92\\xaf\")}); // also true\n    const invalid_utf8 = \"\\xff\\xfe\"; // non-UTF-8 strings are possible with \\xNN notation.\n    print(\"0x{x}\\n\", .{invalid_utf8[1]}); // indexing them returns individual bytes...\n    print(\"0x{x}\\n\", .{\"💯\"[1]}); // ...as does indexing part-way through non-ASCII characters\n}\n```\n\nstring_literals.zig\n\n    $ zig build-exe string_literals.zig\n    $ ./string_literals\n    *const [5:0]u8\n    5\n    e\n    0\n    true\n    128169\n    128175\n    ⚡\n    true\n    true\n    0xfe\n    0x9f\n\nShell\n\nSee also:\n\n- [Arrays](#Arrays)\n- [Source Encoding](#Source-Encoding)\n\n#### [Escape Sequences](#toc-Escape-Sequences)\n\n| Escape Sequence | Name                                                            |\n|-----------------|-----------------------------------------------------------------|\n| `\\n`            | Newline                                                         |\n| `\\r`            | Carriage Return                                                 |\n| `\\t`            | Tab                                                             |\n| `\\\\`            | Backslash                                                       |\n| `\\'`            | Single Quote                                                    |\n| `\\\"`            | Double Quote                                                    |\n| `\\xNN`          | hexadecimal 8-bit byte value (2 digits)                         |\n| `\\u{NNNNNN}`    | hexadecimal Unicode code point UTF-8 encoded (1 or more digits) |\n\nEscape Sequences\n\nNote that the maximum valid Unicode point is `0x10ffff`.\n\n#### [Multiline String Literals](#toc-Multiline-String-Literals)\n\nMultiline string literals have no escapes and can span across multiple lines. To start a multiline string literal, use the `\\\\` token. Just like a comment, the string literal goes until the end of the line. The end of the line is not included in the string literal. However, if the next line begins with `\\\\` then a newline is appended and the string literal continues.\n\n``` zig\nconst hello_world_in_c =\n    \\\\#include <stdio.h>\n    \\\\\n    \\\\int main(int argc, char **argv) {\n    \\\\    printf(\"hello world\\n\");\n    \\\\    return 0;\n    \\\\}\n;\n```\n\nmultiline_string_literals.zig\n\nSee also:\n\n- [@embedFile](#embedFile)\n\n### Assignment\n\nUse the `const` keyword to assign a value to an identifier:\n\n``` zig\nconst x = 1234;\n\nfn foo() void {\n    // It works at file scope as well as inside functions.\n    const y = 5678;\n\n    // Once assigned, an identifier cannot be changed.\n    y += 1;\n}\n\npub fn main() void {\n    foo();\n}\n```\n\nconstant_identifier_cannot_change.zig\n\n    $ zig build-exe constant_identifier_cannot_change.zig\n    /home/andy/src/zig/doc/langref/constant_identifier_cannot_change.zig:8:7: error: cannot assign to constant\n        y += 1;\n        ~~^~~~\n    referenced by:\n        main: /home/andy/src/zig/doc/langref/constant_identifier_cannot_change.zig:12:5\n        callMain: /home/andy/src/zig/lib/std/start.zig:514:17\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\n`const` applies to all of the bytes that the identifier immediately addresses. [Pointers](#Pointers) have their own const-ness.\n\nIf you need a variable that you can modify, use the `var` keyword:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    var y: i32 = 5678;\n\n    y += 1;\n\n    print(\"{d}\", .{y});\n}\n```\n\nmutable_var.zig\n\n    $ zig build-exe mutable_var.zig\n    $ ./mutable_var\n    5679\n\nShell\n\nVariables must be initialized:\n\n``` zig\npub fn main() void {\n    var x: i32;\n\n    x = 1;\n}\n```\n\nvar_must_be_initialized.zig\n\n    $ zig build-exe var_must_be_initialized.zig\n    /home/andy/src/zig/doc/langref/var_must_be_initialized.zig:2:15: error: expected '=', found ';'\n        var x: i32;\n                  ^\n\nShell\n\n#### [undefined](#toc-undefined)\n\nUse `undefined` to leave variables uninitialized:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    var x: i32 = undefined;\n    x = 1;\n    print(\"{d}\", .{x});\n}\n```\n\nassign_undefined.zig\n\n    $ zig build-exe assign_undefined.zig\n    $ ./assign_undefined\n    1\n\nShell\n\n`undefined` can be [coerced](#Type-Coercion) to any type. Once this happens, it is no longer possible to detect that the value is `undefined`. `undefined` means the value could be anything, even something that is nonsense according to the type. Translated into English, `undefined` means \"Not a meaningful value. Using this value would be a bug. The value will be unused, or overwritten before being used.\"\n\nIn [Debug](#Debug) mode, Zig writes `0xaa` bytes to undefined memory. This is to catch bugs early, and to help detect use of undefined memory in a debugger. However, this behavior is only an implementation feature, not a language semantic, so it is not guaranteed to be observable to code.\n\n## Zig Test\n\nCode written within one or more `test` declarations can be used to ensure behavior meets expectations:\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"expect addOne adds one to 41\" {\n\n    // The Standard Library contains useful functions to help create tests.\n    // `expect` is a function that verifies its argument is true.\n    // It will return an error if its argument is false to indicate a failure.\n    // `try` is used to return an error to the test runner to notify it that the test failed.\n    try std.testing.expect(addOne(41) == 42);\n}\n\ntest addOne {\n    // A test name can also be written using an identifier.\n    // This is a doctest, and serves as documentation for `addOne`.\n    try std.testing.expect(addOne(41) == 42);\n}\n\n/// The function `addOne` adds one to the number given as its argument.\nfn addOne(number: i32) i32 {\n    return number + 1;\n}\n```\n\ntesting_introduction.zig\n\n    $ zig test testing_introduction.zig\n    1/2 testing_introduction.test.expect addOne adds one to 41...OK\n    2/2 testing_introduction.decltest.addOne...OK\n    All 2 tests passed.\n\nShell\n\nThe `testing_introduction.zig` code sample tests the [function](#Functions) `addOne` to ensure that it returns `42` given the input `41`. From this test's perspective, the `addOne` function is said to be *code under test*.\n\nzig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the *default test runner* provided by the [Zig Standard Library](#Zig-Standard-Library) as its main entry point. During the build, `test` declarations found while [resolving](#Root-Source-File) the given Zig source file are included for the default test runner to run and report on.\n\nThis documentation discusses the features of the default test runner as provided by the Zig Standard Library. Its source code is located in `lib/test_runner.zig`.\n\nThe shell output shown above displays two lines after the zig test command. These lines are printed to standard error by the default test runner:\n\n`1/2 testing_introduction.test.expect addOne adds one to 41...`  \nLines like this indicate which test, out of the total number of tests, is being run. In this case, `1/2` indicates that the first test, out of a total of two tests, is being run. Note that, when the test runner program's standard error is output to the terminal, these lines are cleared when a test succeeds.\n\n`2/2 testing_introduction.decltest.addOne...`  \nWhen the test name is an identifier, the default test runner uses the text decltest instead of test.\n\n`All 2 tests passed.`  \nThis line indicates the total number of tests that have passed.\n\n### Test Declarations\n\nTest declarations contain the [keyword](#Keyword-Reference) `test`, followed by an optional name written as a [string literal](#String-Literals-and-Unicode-Code-Point-Literals) or an [identifier](#Identifiers), followed by a [block](#Blocks) containing any valid Zig code that is allowed in a [function](#Functions).\n\nNon-named test blocks always run during test builds and are exempt from [Skip Tests](#Skip-Tests).\n\nTest declarations are similar to [Functions](#Functions): they have a return type and a block of code. The implicit return type of `test` is the [Error Union Type](#Error-Union-Type) `anyerror``!``void`, and it cannot be changed. When a Zig source file is not built using the zig test tool, the test declarations are omitted from the build.\n\nTest declarations can be written in the same file, where code under test is written, or in a separate Zig source file. Since test declarations are top-level declarations, they are order-independent and can be written before or after the code under test.\n\nSee also:\n\n- [The Global Error Set](#The-Global-Error-Set)\n- [Grammar](#Grammar)\n\n#### [Doctests](#toc-Doctests)\n\nTest declarations named using an identifier are *doctests*. The identifier must refer to another declaration in scope. A doctest, like a [doc comment](#Doc-Comments), serves as documentation for the associated declaration, and will appear in the generated documentation for the declaration.\n\nAn effective doctest should be self-contained and focused on the declaration being tested, answering questions a new user might have about its interface or intended usage, while avoiding unnecessary or confusing details. A doctest is not a substitute for a doc comment, but rather a supplement and companion providing a testable, code-driven example, verified by zig test.\n\n### Test Failure\n\nThe default test runner checks for an [error](#Errors) returned from a test. When a test returns an error, the test is considered a failure and its [error return trace](#Error-Return-Traces) is output to standard error. The total number of failures will be reported after all tests have run.\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"expect this to fail\" {\n    try std.testing.expect(false);\n}\n\ntest \"expect this to succeed\" {\n    try std.testing.expect(true);\n}\n```\n\ntesting_failure.zig\n\n    $ zig test testing_failure.zig\n    1/2 testing_failure.test.expect this to fail...FAIL (TestUnexpectedResult)\n    /home/andy/src/zig/lib/std/testing.zig:540:14: 0x103ce3f in expect (test)\n        if (!ok) return error.TestUnexpectedResult;\n                 ^\n    /home/andy/src/zig/doc/langref/testing_failure.zig:4:5: 0x103cf55 in test.expect this to fail (test)\n        try std.testing.expect(false);\n        ^\n    2/2 testing_failure.test.expect this to succeed...OK\n    1 passed; 0 skipped; 1 failed.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/054f0b6f088824f384d1b6c648523593/test\n\nShell\n\n### Skip Tests\n\nOne way to skip tests is to filter them out by using the zig test command line parameter --test-filter \\[text\\]. This makes the test build only include tests whose name contains the supplied filter text. Note that non-named tests are run even when using the --test-filter \\[text\\] command line parameter.\n\nTo programmatically skip a test, make a `test` return the error `error``.SkipZigTest` and the default test runner will consider the test as being skipped. The total number of skipped tests will be reported after all tests have run.\n\n``` zig\ntest \"this will be skipped\" {\n    return error.SkipZigTest;\n}\n```\n\ntesting_skip.zig\n\n    $ zig test testing_skip.zig\n    1/1 testing_skip.test.this will be skipped...SKIP\n    0 passed; 1 skipped; 0 failed.\n\nShell\n\n### Report Memory Leaks\n\nWhen code allocates [Memory](#Memory) using the [Zig Standard Library](#Zig-Standard-Library)'s testing allocator, `std.testing.allocator`, the default test runner will report any leaks that are found from using the testing allocator:\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"detect leak\" {\n    var list = std.ArrayList(u21).init(std.testing.allocator);\n    // missing `defer list.deinit();`\n    try list.append('☔');\n\n    try std.testing.expect(list.items.len == 1);\n}\n```\n\ntesting_detect_leak.zig\n\n    $ zig test testing_detect_leak.zig\n    1/1 testing_detect_leak.test.detect leak...OK\n    [gpa] (err): memory address 0x7fdbea69e000 leaked:\n    /home/andy/src/zig/lib/std/array_list.zig:457:67: 0x104f76e in ensureTotalCapacityPrecise (test)\n                    const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);\n                                                                      ^\n    /home/andy/src/zig/lib/std/array_list.zig:434:51: 0x1045610 in ensureTotalCapacity (test)\n                return self.ensureTotalCapacityPrecise(better_capacity);\n                                                      ^\n    /home/andy/src/zig/lib/std/array_list.zig:483:41: 0x1041fe0 in addOne (test)\n                try self.ensureTotalCapacity(newlen);\n                                            ^\n    /home/andy/src/zig/lib/std/array_list.zig:262:49: 0x103ef2d in append (test)\n                const new_item_ptr = try self.addOne();\n                                                    ^\n    /home/andy/src/zig/doc/langref/testing_detect_leak.zig:6:20: 0x103d172 in test.detect leak (test)\n        try list.append('☔');\n                       ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104c6a0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x10428bb in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103f429 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103ef91 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    All 1 tests passed.\n    1 errors were logged.\n    1 tests leaked memory.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/4a17198138bf81bcfabd5652b0d6be24/test\n\nShell\n\nSee also:\n\n- [defer](#defer)\n- [Memory](#Memory)\n\n### Detecting Test Build\n\nUse the [compile variable](#Compile-Variables) `@import``(``\"builtin\"``).is_test` to detect a test build:\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\n\ntest \"builtin.is_test\" {\n    try expect(isATest());\n}\n\nfn isATest() bool {\n    return builtin.is_test;\n}\n```\n\ntesting_detect_test.zig\n\n    $ zig test testing_detect_test.zig\n    1/1 testing_detect_test.test.builtin.is_test...OK\n    All 1 tests passed.\n\nShell\n\n### Test Output and Logging\n\nThe default test runner and the Zig Standard Library's testing namespace output messages to standard error.\n\n### The Testing Namespace\n\nThe Zig Standard Library's `testing` namespace contains useful functions to help you create tests. In addition to the `expect` function, this document uses a couple of more functions as exemplified here:\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"expectEqual demo\" {\n    const expected: i32 = 42;\n    const actual = 42;\n\n    // The first argument to `expectEqual` is the known, expected, result.\n    // The second argument is the result of some expression.\n    // The actual's type is casted to the type of expected.\n    try std.testing.expectEqual(expected, actual);\n}\n\ntest \"expectError demo\" {\n    const expected_error = error.DemoError;\n    const actual_error_union: anyerror!void = error.DemoError;\n\n    // `expectError` will fail when the actual error is different than\n    // the expected error.\n    try std.testing.expectError(expected_error, actual_error_union);\n}\n```\n\ntesting_namespace.zig\n\n    $ zig test testing_namespace.zig\n    1/2 testing_namespace.test.expectEqual demo...OK\n    2/2 testing_namespace.test.expectError demo...OK\n    All 2 tests passed.\n\nShell\n\nThe Zig Standard Library also contains functions to compare [Slices](#Slices), strings, and more. See the rest of the `std.testing` namespace in the [Zig Standard Library](#Zig-Standard-Library) for more available functions.\n\n### Test Tool Documentation\n\nzig test has a few command line parameters which affect the compilation. See zig test --help for a full list.\n\n## Variables\n\nA variable is a unit of [Memory](#Memory) storage.\n\nIt is generally preferable to use `const` rather than `var` when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities.\n\nThe `extern` keyword or [@extern](#extern) builtin function can be used to link against a variable that is exported from another object. The `export` keyword or [@export](#export) builtin function can be used to make a variable available to other objects at link time. In both cases, the type of the variable must be C ABI compatible.\n\nSee also:\n\n- [Exporting a C Library](#Exporting-a-C-Library)\n\n### Identifiers\n\nVariable identifiers are never allowed to shadow identifiers from an outer scope.\n\nIdentifiers must start with an alphabetic character or underscore and may be followed by any number of alphanumeric characters or underscores. They must not overlap with any keywords. See [Keyword Reference](#Keyword-Reference).\n\nIf a name that does not fit these requirements is needed, such as for linking with external libraries, the `@\"\"` syntax may be used.\n\n``` zig\nconst @\"identifier with spaces in it\" = 0xff;\nconst @\"1SmallStep4Man\" = 112358;\n\nconst c = @import(\"std\").c;\npub extern \"c\" fn @\"error\"() void;\npub extern \"c\" fn @\"fstat$INODE64\"(fd: c.fd_t, buf: *c.Stat) c_int;\n\nconst Color = enum {\n    red,\n    @\"really red\",\n};\nconst color: Color = .@\"really red\";\n```\n\nidentifiers.zig\n\n### Container Level Variables\n\n[Container](#Containers) level variables have static lifetime and are order-independent and lazily analyzed. The initialization value of container level variables is implicitly [comptime](#comptime). If a container level variable is `const` then its value is `comptime`-known, otherwise it is runtime-known.\n\n``` zig\nvar y: i32 = add(10, x);\nconst x: i32 = add(12, 34);\n\ntest \"container level variables\" {\n    try expect(x == 46);\n    try expect(y == 56);\n}\n\nfn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n```\n\ntest_container_level_variables.zig\n\n    $ zig test test_container_level_variables.zig\n    1/1 test_container_level_variables.test.container level variables...OK\n    All 1 tests passed.\n\nShell\n\nContainer level variables may be declared inside a [struct](#struct), [union](#union), [enum](#enum), or [opaque](#opaque):\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"namespaced container level variable\" {\n    try expect(foo() == 1235);\n    try expect(foo() == 1236);\n}\n\nconst S = struct {\n    var x: i32 = 1234;\n};\n\nfn foo() i32 {\n    S.x += 1;\n    return S.x;\n}\n```\n\ntest_namespaced_container_level_variable.zig\n\n    $ zig test test_namespaced_container_level_variable.zig\n    1/1 test_namespaced_container_level_variable.test.namespaced container level variable...OK\n    All 1 tests passed.\n\nShell\n\n### Static Local Variables\n\nIt is also possible to have local variables with static lifetime by using containers inside functions.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"static local variable\" {\n    try expect(foo() == 1235);\n    try expect(foo() == 1236);\n}\n\nfn foo() i32 {\n    const S = struct {\n        var x: i32 = 1234;\n    };\n    S.x += 1;\n    return S.x;\n}\n```\n\ntest_static_local_variable.zig\n\n    $ zig test test_static_local_variable.zig\n    1/1 test_static_local_variable.test.static local variable...OK\n    All 1 tests passed.\n\nShell\n\n### Thread Local Variables\n\nA variable may be specified to be a thread-local variable using the `threadlocal` keyword, which makes each thread work with a separate instance of the variable:\n\n``` zig\nconst std = @import(\"std\");\nconst assert = std.debug.assert;\n\nthreadlocal var x: i32 = 1234;\n\ntest \"thread local storage\" {\n    const thread1 = try std.Thread.spawn(.{}, testTls, .{});\n    const thread2 = try std.Thread.spawn(.{}, testTls, .{});\n    testTls();\n    thread1.join();\n    thread2.join();\n}\n\nfn testTls() void {\n    assert(x == 1234);\n    x += 1;\n    assert(x == 1235);\n}\n```\n\ntest_thread_local_variables.zig\n\n    $ zig test test_thread_local_variables.zig\n    1/1 test_thread_local_variables.test.thread local storage...OK\n    All 1 tests passed.\n\nShell\n\nFor [Single Threaded Builds](#Single-Threaded-Builds), all thread local variables are treated as regular [Container Level Variables](#Container-Level-Variables).\n\nThread local variables may not be `const`.\n\n### Local Variables\n\nLocal variables occur inside [Functions](#Functions), [comptime](#comptime) blocks, and [@cImport](#cImport) blocks.\n\nWhen a local variable is `const`, it means that after initialization, the variable's value will not change. If the initialization value of a `const` variable is [comptime](#comptime)-known, then the variable is also `comptime`-known.\n\nA local variable may be qualified with the `comptime` keyword. This causes the variable's value to be `comptime`-known, and all loads and stores of the variable to happen during semantic analysis of the program, rather than at runtime. All variables declared in a `comptime` expression are implicitly `comptime` variables.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"comptime vars\" {\n    var x: i32 = 1;\n    comptime var y: i32 = 1;\n\n    x += 1;\n    y += 1;\n\n    try expect(x == 2);\n    try expect(y == 2);\n\n    if (y != 2) {\n        // This compile error never triggers because y is a comptime variable,\n        // and so `y != 2` is a comptime value, and this if is statically evaluated.\n        @compileError(\"wrong y value\");\n    }\n}\n```\n\ntest_comptime_variables.zig\n\n    $ zig test test_comptime_variables.zig\n    1/1 test_comptime_variables.test.comptime vars...OK\n    All 1 tests passed.\n\nShell\n\n## Integers\n\n### Integer Literals\n\n``` zig\nconst decimal_int = 98222;\nconst hex_int = 0xff;\nconst another_hex_int = 0xFF;\nconst octal_int = 0o755;\nconst binary_int = 0b11110000;\n\n// underscores may be placed between two digits as a visual separator\nconst one_billion = 1_000_000_000;\nconst binary_mask = 0b1_1111_1111;\nconst permissions = 0o7_5_5;\nconst big_address = 0xFF80_0000_0000_0000;\n```\n\ninteger_literals.zig\n\n### Runtime Integer Values\n\nInteger literals have no size limitation, and if any undefined behavior occurs, the compiler catches it.\n\nHowever, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to undefined behavior.\n\n``` zig\nfn divide(a: i32, b: i32) i32 {\n    return a / b;\n}\n```\n\nruntime_vs_comptime.zig\n\nIn this function, values `a` and `b` are known only at runtime, and thus this division operation is vulnerable to both [Integer Overflow](#Integer-Overflow) and [Division by Zero](#Division-by-Zero).\n\nOperators such as `+` and `-` cause undefined behavior on integer overflow. Alternative operators are provided for wrapping and saturating arithmetic on all targets. `+%` and `-%` perform wrapping arithmetic while `+|` and `-|` perform saturating arithmetic.\n\nZig supports arbitrary bit-width integers, referenced by using an identifier of `i` or `u` followed by digits. For example, the identifier `i7` refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is `65535`. For signed integer types, Zig uses a [two's complement](https://en.wikipedia.org/wiki/Two's_complement) representation.\n\nSee also:\n\n- [Wrapping Operations](#Wrapping-Operations)\n\n## Floats\n\nZig has the following floating point types:\n\n- `f16` - IEEE-754-2008 binary16\n- `f32` - IEEE-754-2008 binary32\n- `f64` - IEEE-754-2008 binary64\n- `f80` - IEEE-754-2008 80-bit extended precision\n- `f128` - IEEE-754-2008 binary128\n- `c_longdouble` - matches `long double` for the target C ABI\n\n### Float Literals\n\nFloat literals have type `comptime_float` which is guaranteed to have the same precision and operations of the largest other floating point type, which is `f128`.\n\nFloat literals [coerce](#Type-Coercion) to any floating point type, and to any [integer](#Integers) type when there is no fractional component.\n\n``` zig\nconst floating_point = 123.0E+77;\nconst another_float = 123.0;\nconst yet_another = 123.0e+77;\n\nconst hex_floating_point = 0x103.70p-5;\nconst another_hex_float = 0x103.70;\nconst yet_another_hex_float = 0x103.70P-5;\n\n// underscores may be placed between two digits as a visual separator\nconst lightspeed = 299_792_458.000_000;\nconst nanosecond = 0.000_000_001;\nconst more_hex = 0x1234_5678.9ABC_CDEFp-10;\n```\n\nfloat_literals.zig\n\nThere is no syntax for NaN, infinity, or negative infinity. For these special values, one must use the standard library:\n\n``` zig\nconst std = @import(\"std\");\n\nconst inf = std.math.inf(f32);\nconst negative_inf = -std.math.inf(f64);\nconst nan = std.math.nan(f128);\n```\n\nfloat_special_values.zig\n\n### Floating Point Operations\n\nBy default floating point operations use `Strict` mode, but you can switch to `Optimized` mode on a per-block basis:\n\n``` zig\nconst std = @import(\"std\");\nconst big = @as(f64, 1 << 40);\n\nexport fn foo_strict(x: f64) f64 {\n    return x + big - big;\n}\n\nexport fn foo_optimized(x: f64) f64 {\n    @setFloatMode(.optimized);\n    return x + big - big;\n}\n```\n\nfloat_mode_obj.zig\n\n    $ zig build-obj float_mode_obj.zig -O ReleaseFast\n\nShell\n\nFor this test we have to separate code into two object files - otherwise the optimizer figures out all the values at compile-time, which operates in strict mode.\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nextern fn foo_strict(x: f64) f64;\nextern fn foo_optimized(x: f64) f64;\n\npub fn main() void {\n    const x = 0.001;\n    print(\"optimized = {}\\n\", .{foo_optimized(x)});\n    print(\"strict = {}\\n\", .{foo_strict(x)});\n}\n```\n\nfloat_mode_exe.zig\n\nSee also:\n\n- [@setFloatMode](#setFloatMode)\n- [Division by Zero](#Division-by-Zero)\n\n## Operators\n\nThere is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else.\n\n### Table of Operators\n\n[TABLE]\n\n### Precedence\n\n``` zig\nx() x[] x.y x.* x.?\na!b\nx{}\n!x -x -%x ~x &x ?x\n* / % ** *% *| ||\n+ - ++ +% -% +| -|\n<< >> <<|\n& ^ | orelse catch\n== != < > <= >=\nand\nor\n= *= *%= *|= /= %= += +%= +|= -= -%= -|= <<= <<|= >>= &= ^= |=\n```\n\n## Arrays\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\nconst assert = @import(\"std\").debug.assert;\nconst mem = @import(\"std\").mem;\n\n// array literal\nconst message = [_]u8{ 'h', 'e', 'l', 'l', 'o' };\n\n// alternative initialization using result location\nconst alt_message: [5]u8 = .{ 'h', 'e', 'l', 'l', 'o' };\n\ncomptime {\n    assert(mem.eql(u8, &message, &alt_message));\n}\n\n// get the size of an array\ncomptime {\n    assert(message.len == 5);\n}\n\n// A string literal is a single-item pointer to an array.\nconst same_message = \"hello\";\n\ncomptime {\n    assert(mem.eql(u8, &message, same_message));\n}\n\ntest \"iterate over an array\" {\n    var sum: usize = 0;\n    for (message) |byte| {\n        sum += byte;\n    }\n    try expect(sum == 'h' + 'e' + 'l' * 2 + 'o');\n}\n\n// modifiable array\nvar some_integers: [100]i32 = undefined;\n\ntest \"modify an array\" {\n    for (&some_integers, 0..) |*item, i| {\n        item.* = @intCast(i);\n    }\n    try expect(some_integers[10] == 10);\n    try expect(some_integers[99] == 99);\n}\n\n// array concatenation works if the values are known\n// at compile time\nconst part_one = [_]i32{ 1, 2, 3, 4 };\nconst part_two = [_]i32{ 5, 6, 7, 8 };\nconst all_of_it = part_one ++ part_two;\ncomptime {\n    assert(mem.eql(i32, &all_of_it, &[_]i32{ 1, 2, 3, 4, 5, 6, 7, 8 }));\n}\n\n// remember that string literals are arrays\nconst hello = \"hello\";\nconst world = \"world\";\nconst hello_world = hello ++ \" \" ++ world;\ncomptime {\n    assert(mem.eql(u8, hello_world, \"hello world\"));\n}\n\n// ** does repeating patterns\nconst pattern = \"ab\" ** 3;\ncomptime {\n    assert(mem.eql(u8, pattern, \"ababab\"));\n}\n\n// initialize an array to zero\nconst all_zero = [_]u16{0} ** 10;\n\ncomptime {\n    assert(all_zero.len == 10);\n    assert(all_zero[5] == 0);\n}\n\n// use compile-time code to initialize an array\nvar fancy_array = init: {\n    var initial_value: [10]Point = undefined;\n    for (&initial_value, 0..) |*pt, i| {\n        pt.* = Point{\n            .x = @intCast(i),\n            .y = @intCast(i * 2),\n        };\n    }\n    break :init initial_value;\n};\nconst Point = struct {\n    x: i32,\n    y: i32,\n};\n\ntest \"compile-time array initialization\" {\n    try expect(fancy_array[4].x == 4);\n    try expect(fancy_array[4].y == 8);\n}\n\n// call a function to initialize an array\nvar more_points = [_]Point{makePoint(3)} ** 10;\nfn makePoint(x: i32) Point {\n    return Point{\n        .x = x,\n        .y = x * 2,\n    };\n}\ntest \"array initialization with function calls\" {\n    try expect(more_points[4].x == 3);\n    try expect(more_points[4].y == 6);\n    try expect(more_points.len == 10);\n}\n```\n\ntest_arrays.zig\n\n    $ zig test test_arrays.zig\n    1/4 test_arrays.test.iterate over an array...OK\n    2/4 test_arrays.test.modify an array...OK\n    3/4 test_arrays.test.compile-time array initialization...OK\n    4/4 test_arrays.test.array initialization with function calls...OK\n    All 4 tests passed.\n\nShell\n\nSee also:\n\n- [for](#for)\n- [Slices](#Slices)\n\n### Multidimensional Arrays\n\nMultidimensional arrays can be created by nesting arrays:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst mat4x4 = [4][4]f32{\n    [_]f32{ 1.0, 0.0, 0.0, 0.0 },\n    [_]f32{ 0.0, 1.0, 0.0, 1.0 },\n    [_]f32{ 0.0, 0.0, 1.0, 0.0 },\n    [_]f32{ 0.0, 0.0, 0.0, 1.0 },\n};\ntest \"multidimensional arrays\" {\n    // Access the 2D array by indexing the outer array, and then the inner array.\n    try expect(mat4x4[1][1] == 1.0);\n\n    // Here we iterate with for loops.\n    for (mat4x4, 0..) |row, row_index| {\n        for (row, 0..) |cell, column_index| {\n            if (row_index == column_index) {\n                try expect(cell == 1.0);\n            }\n        }\n    }\n}\n```\n\ntest_multidimensional_arrays.zig\n\n    $ zig test test_multidimensional_arrays.zig\n    1/1 test_multidimensional_arrays.test.multidimensional arrays...OK\n    All 1 tests passed.\n\nShell\n\n### Sentinel-Terminated Arrays\n\nThe syntax `[N:x]T` describes an array which has a sentinel element of value `x` at the index corresponding to the length `N`.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"0-terminated sentinel array\" {\n    const array = [_:0]u8{ 1, 2, 3, 4 };\n\n    try expect(@TypeOf(array) == [4:0]u8);\n    try expect(array.len == 4);\n    try expect(array[4] == 0);\n}\n\ntest \"extra 0s in 0-terminated sentinel array\" {\n    // The sentinel value may appear earlier, but does not influence the compile-time 'len'.\n    const array = [_:0]u8{ 1, 0, 0, 4 };\n\n    try expect(@TypeOf(array) == [4:0]u8);\n    try expect(array.len == 4);\n    try expect(array[4] == 0);\n}\n```\n\ntest_null_terminated_array.zig\n\n    $ zig test test_null_terminated_array.zig\n    1/2 test_null_terminated_array.test.0-terminated sentinel array...OK\n    2/2 test_null_terminated_array.test.extra 0s in 0-terminated sentinel array...OK\n    All 2 tests passed.\n\nShell\n\nSee also:\n\n- [Sentinel-Terminated Pointers](#Sentinel-Terminated-Pointers)\n- [Sentinel-Terminated Slices](#Sentinel-Terminated-Slices)\n\n## Vectors\n\nA vector is a group of booleans, [Integers](#Integers), [Floats](#Floats), or [Pointers](#Pointers) which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function [@Vector](#Vector).\n\nVectors support the same builtin operators as their underlying base types. These operations are performed element-wise, and return a vector of the same length as the input vectors. This includes:\n\n- Arithmetic (`+`, `-`, `/`, `*`, `@divFloor`, `@sqrt`, `@ceil`, `@log`, etc.)\n- Bitwise operators (`>>`, `<<`, `&`, `|`, `~`, etc.)\n- Comparison operators (`<`, `>`, `==`, etc.)\n\nIt is prohibited to use a math operator on a mixture of scalars (individual numbers) and vectors. Zig provides the [@splat](#splat) builtin to easily convert from scalars to vectors, and it supports [@reduce](#reduce) and array indexing syntax to convert from vectors to scalars. Vectors also support assignment to and from fixed-length arrays with comptime-known length.\n\nFor rearranging elements within and between vectors, Zig provides the [@shuffle](#shuffle) and [@select](#select) functions.\n\nOperations on vectors shorter than the target machine's native SIMD size will typically compile to single SIMD instructions, while vectors longer than the target machine's native SIMD size will compile to multiple SIMD instructions. If a given operation doesn't have SIMD support on the target architecture, the compiler will default to operating on each vector element one at a time. Zig supports any comptime-known vector length up to 2^32-1, although small powers of two (2-64) are most typical. Note that excessively long vector lengths (e.g. 2^20) may result in compiler crashes on current versions of Zig.\n\n``` zig\nconst std = @import(\"std\");\nconst expectEqual = std.testing.expectEqual;\n\ntest \"Basic vector usage\" {\n    // Vectors have a compile-time known length and base type.\n    const a = @Vector(4, i32){ 1, 2, 3, 4 };\n    const b = @Vector(4, i32){ 5, 6, 7, 8 };\n\n    // Math operations take place element-wise.\n    const c = a + b;\n\n    // Individual vector elements can be accessed using array indexing syntax.\n    try expectEqual(6, c[0]);\n    try expectEqual(8, c[1]);\n    try expectEqual(10, c[2]);\n    try expectEqual(12, c[3]);\n}\n\ntest \"Conversion between vectors, arrays, and slices\" {\n    // Vectors and fixed-length arrays can be automatically assigned back and forth\n    const arr1: [4]f32 = [_]f32{ 1.1, 3.2, 4.5, 5.6 };\n    const vec: @Vector(4, f32) = arr1;\n    const arr2: [4]f32 = vec;\n    try expectEqual(arr1, arr2);\n\n    // You can also assign from a slice with comptime-known length to a vector using .*\n    const vec2: @Vector(2, f32) = arr1[1..3].*;\n\n    const slice: []const f32 = &arr1;\n    var offset: u32 = 1; // var to make it runtime-known\n    _ = &offset; // suppress 'var is never mutated' error\n    // To extract a comptime-known length from a runtime-known offset,\n    // first extract a new slice from the starting offset, then an array of\n    // comptime-known length\n    const vec3: @Vector(2, f32) = slice[offset..][0..2].*;\n    try expectEqual(slice[offset], vec2[0]);\n    try expectEqual(slice[offset + 1], vec2[1]);\n    try expectEqual(vec2, vec3);\n}\n```\n\ntest_vector.zig\n\n    $ zig test test_vector.zig\n    1/2 test_vector.test.Basic vector usage...OK\n    2/2 test_vector.test.Conversion between vectors, arrays, and slices...OK\n    All 2 tests passed.\n\nShell\n\nTODO talk about C ABI interop  \nTODO consider suggesting std.MultiArrayList\n\nSee also:\n\n- [@splat](#splat)\n- [@shuffle](#shuffle)\n- [@select](#select)\n- [@reduce](#reduce)\n\n## Pointers\n\nZig has two kinds of pointers: single-item and many-item.\n\n- `*T` - single-item pointer to exactly one item.\n  - Supports deref syntax: `ptr.*`\n- `[*]T` - many-item pointer to unknown number of items.\n  - Supports index syntax: `ptr[i]`\n  - Supports slice syntax: `ptr[start..end]` and `ptr[start..]`\n  - Supports pointer arithmetic: `ptr + x`, `ptr - x`\n  - `T` must have a known size, which means that it cannot be `anyopaque` or any other [opaque type](#opaque).\n\nThese types are closely related to [Arrays](#Arrays) and [Slices](#Slices):\n\n- `*[N]T` - pointer to N items, same as single-item pointer to an array.\n  - Supports index syntax: `array_ptr[i]`\n  - Supports slice syntax: `array_ptr[start..end]`\n  - Supports len property: `array_ptr.len`\n\n- `[]T` - is a slice (a fat pointer, which contains a pointer of type `[*]T` and a length).\n  - Supports index syntax: `slice[i]`\n  - Supports slice syntax: `slice[start..end]`\n  - Supports len property: `slice.len`\n\nUse `&x` to obtain a single-item pointer:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"address of syntax\" {\n    // Get the address of a variable:\n    const x: i32 = 1234;\n    const x_ptr = &x;\n\n    // Dereference a pointer:\n    try expect(x_ptr.* == 1234);\n\n    // When you get the address of a const variable, you get a const single-item pointer.\n    try expect(@TypeOf(x_ptr) == *const i32);\n\n    // If you want to mutate the value, you'd need an address of a mutable variable:\n    var y: i32 = 5678;\n    const y_ptr = &y;\n    try expect(@TypeOf(y_ptr) == *i32);\n    y_ptr.* += 1;\n    try expect(y_ptr.* == 5679);\n}\n\ntest \"pointer array access\" {\n    // Taking an address of an individual element gives a\n    // single-item pointer. This kind of pointer\n    // does not support pointer arithmetic.\n    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    const ptr = &array[2];\n    try expect(@TypeOf(ptr) == *u8);\n\n    try expect(array[2] == 3);\n    ptr.* += 1;\n    try expect(array[2] == 4);\n}\n```\n\ntest_single_item_pointer.zig\n\n    $ zig test test_single_item_pointer.zig\n    1/2 test_single_item_pointer.test.address of syntax...OK\n    2/2 test_single_item_pointer.test.pointer array access...OK\n    All 2 tests passed.\n\nShell\n\nZig supports pointer arithmetic. It's better to assign the pointer to `[*]T` and increment that variable. For example, directly incrementing the pointer from a slice will corrupt it.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"pointer arithmetic with many-item pointer\" {\n    const array = [_]i32{ 1, 2, 3, 4 };\n    var ptr: [*]const i32 = &array;\n\n    try expect(ptr[0] == 1);\n    ptr += 1;\n    try expect(ptr[0] == 2);\n\n    // slicing a many-item pointer without an end is equivalent to\n    // pointer arithmetic: `ptr[start..] == ptr + start`\n    try expect(ptr[1..] == ptr + 1);\n}\n\ntest \"pointer arithmetic with slices\" {\n    var array = [_]i32{ 1, 2, 3, 4 };\n    var length: usize = 0; // var to make it runtime-known\n    _ = &length; // suppress 'var is never mutated' error\n    var slice = array[length..array.len];\n\n    try expect(slice[0] == 1);\n    try expect(slice.len == 4);\n\n    slice.ptr += 1;\n    // now the slice is in an bad state since len has not been updated\n\n    try expect(slice[0] == 2);\n    try expect(slice.len == 4);\n}\n```\n\ntest_pointer_arithmetic.zig\n\n    $ zig test test_pointer_arithmetic.zig\n    1/2 test_pointer_arithmetic.test.pointer arithmetic with many-item pointer...OK\n    2/2 test_pointer_arithmetic.test.pointer arithmetic with slices...OK\n    All 2 tests passed.\n\nShell\n\nIn Zig, we generally prefer [Slices](#Slices) rather than [Sentinel-Terminated Pointers](#Sentinel-Terminated-Pointers). You can turn an array or pointer into a slice using slice syntax.\n\nSlices have bounds checking and are therefore protected against this kind of undefined behavior. This is one reason we prefer slices to pointers.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"pointer slicing\" {\n    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    var start: usize = 2; // var to make it runtime-known\n    _ = &start; // suppress 'var is never mutated' error\n    const slice = array[start..4];\n    try expect(slice.len == 2);\n\n    try expect(array[3] == 4);\n    slice[1] += 1;\n    try expect(array[3] == 5);\n}\n```\n\ntest_slice_bounds.zig\n\n    $ zig test test_slice_bounds.zig\n    1/1 test_slice_bounds.test.pointer slicing...OK\n    All 1 tests passed.\n\nShell\n\nPointers work at compile-time too, as long as the code does not depend on an undefined memory layout:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"comptime pointers\" {\n    comptime {\n        var x: i32 = 1;\n        const ptr = &x;\n        ptr.* += 1;\n        x += 1;\n        try expect(ptr.* == 3);\n    }\n}\n```\n\ntest_comptime_pointers.zig\n\n    $ zig test test_comptime_pointers.zig\n    1/1 test_comptime_pointers.test.comptime pointers...OK\n    All 1 tests passed.\n\nShell\n\nTo convert an integer address into a pointer, use `@ptrFromInt`. To convert a pointer to an integer, use `@intFromPtr`:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"@intFromPtr and @ptrFromInt\" {\n    const ptr: *i32 = @ptrFromInt(0xdeadbee0);\n    const addr = @intFromPtr(ptr);\n    try expect(@TypeOf(addr) == usize);\n    try expect(addr == 0xdeadbee0);\n}\n```\n\ntest_integer_pointer_conversion.zig\n\n    $ zig test test_integer_pointer_conversion.zig\n    1/1 test_integer_pointer_conversion.test.@intFromPtr and @ptrFromInt...OK\n    All 1 tests passed.\n\nShell\n\nZig is able to preserve memory addresses in comptime code, as long as the pointer is never dereferenced:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"comptime @ptrFromInt\" {\n    comptime {\n        // Zig is able to do this at compile-time, as long as\n        // ptr is never dereferenced.\n        const ptr: *i32 = @ptrFromInt(0xdeadbee0);\n        const addr = @intFromPtr(ptr);\n        try expect(@TypeOf(addr) == usize);\n        try expect(addr == 0xdeadbee0);\n    }\n}\n```\n\ntest_comptime_pointer_conversion.zig\n\n    $ zig test test_comptime_pointer_conversion.zig\n    1/1 test_comptime_pointer_conversion.test.comptime @ptrFromInt...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [Optional Pointers](#Optional-Pointers)\n- [@ptrFromInt](#ptrFromInt)\n- [@intFromPtr](#intFromPtr)\n- [C Pointers](#C-Pointers)\n\n### volatile\n\nLoads and stores are assumed to not have side effects. If a given load or store should have side effects, such as Memory Mapped Input/Output (MMIO), use `volatile`. In the following code, loads and stores with `mmio_ptr` are guaranteed to all happen and in the same order as in source code:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"volatile\" {\n    const mmio_ptr: *volatile u8 = @ptrFromInt(0x12345678);\n    try expect(@TypeOf(mmio_ptr) == *volatile u8);\n}\n```\n\ntest_volatile.zig\n\n    $ zig test test_volatile.zig\n    1/1 test_volatile.test.volatile...OK\n    All 1 tests passed.\n\nShell\n\nNote that `volatile` is unrelated to concurrency and [Atomics](#Atomics). If you see code that is using `volatile` for something other than Memory Mapped Input/Output, it is probably a bug.\n\n[@ptrCast](#ptrCast) converts a pointer's element type to another. This creates a new pointer that can cause undetectable illegal behavior depending on the loads and stores that pass through it. Generally, other kinds of type conversions are preferable to `@ptrCast` if possible.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"pointer casting\" {\n    const bytes align(@alignOf(u32)) = [_]u8{ 0x12, 0x12, 0x12, 0x12 };\n    const u32_ptr: *const u32 = @ptrCast(&bytes);\n    try expect(u32_ptr.* == 0x12121212);\n\n    // Even this example is contrived - there are better ways to do the above than\n    // pointer casting. For example, using a slice narrowing cast:\n    const u32_value = std.mem.bytesAsSlice(u32, bytes[0..])[0];\n    try expect(u32_value == 0x12121212);\n\n    // And even another way, the most straightforward way to do it:\n    try expect(@as(u32, @bitCast(bytes)) == 0x12121212);\n}\n\ntest \"pointer child type\" {\n    // pointer types have a `child` field which tells you the type they point to.\n    try expect(@typeInfo(*u32).Pointer.child == u32);\n}\n```\n\ntest_pointer_casting.zig\n\n    $ zig test test_pointer_casting.zig\n    1/2 test_pointer_casting.test.pointer casting...OK\n    2/2 test_pointer_casting.test.pointer child type...OK\n    All 2 tests passed.\n\nShell\n\n### Alignment\n\nEach type has an **alignment** - a number of bytes such that, when a value of the type is loaded from or stored to memory, the memory address must be evenly divisible by this number. You can use [@alignOf](#alignOf) to find out this value for any type.\n\nAlignment depends on the CPU architecture, but is always a power of two, and less than `1`` << ``29`.\n\nIn Zig, a pointer type has an alignment value. If the value is equal to the alignment of the underlying type, it can be omitted from the type:\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\n\ntest \"variable alignment\" {\n    var x: i32 = 1234;\n    const align_of_i32 = @alignOf(@TypeOf(x));\n    try expect(@TypeOf(&x) == *i32);\n    try expect(*i32 == *align(align_of_i32) i32);\n    if (builtin.target.cpu.arch == .x86_64) {\n        try expect(@typeInfo(*i32).Pointer.alignment == 4);\n    }\n}\n```\n\ntest_variable_alignment.zig\n\n    $ zig test test_variable_alignment.zig\n    1/1 test_variable_alignment.test.variable alignment...OK\n    All 1 tests passed.\n\nShell\n\nIn the same way that a `*``i32` can be [coerced](#Type-Coercion) to a `*``const`` ``i32`, a pointer with a larger alignment can be implicitly cast to a pointer with a smaller alignment, but not vice versa.\n\nYou can specify alignment on variables and functions. If you do this, then pointers to them get the specified alignment:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nvar foo: u8 align(4) = 100;\n\ntest \"global variable alignment\" {\n    try expect(@typeInfo(@TypeOf(&foo)).Pointer.alignment == 4);\n    try expect(@TypeOf(&foo) == *align(4) u8);\n    const as_pointer_to_array: *align(4) [1]u8 = &foo;\n    const as_slice: []align(4) u8 = as_pointer_to_array;\n    const as_unaligned_slice: []u8 = as_slice;\n    try expect(as_unaligned_slice[0] == 100);\n}\n\nfn derp() align(@sizeOf(usize) * 2) i32 {\n    return 1234;\n}\nfn noop1() align(1) void {}\nfn noop4() align(4) void {}\n\ntest \"function alignment\" {\n    try expect(derp() == 1234);\n    try expect(@TypeOf(derp) == fn () i32);\n    try expect(@TypeOf(&derp) == *align(@sizeOf(usize) * 2) const fn () i32);\n\n    noop1();\n    try expect(@TypeOf(noop1) == fn () void);\n    try expect(@TypeOf(&noop1) == *align(1) const fn () void);\n\n    noop4();\n    try expect(@TypeOf(noop4) == fn () void);\n    try expect(@TypeOf(&noop4) == *align(4) const fn () void);\n}\n```\n\ntest_variable_func_alignment.zig\n\n    $ zig test test_variable_func_alignment.zig\n    1/2 test_variable_func_alignment.test.global variable alignment...OK\n    2/2 test_variable_func_alignment.test.function alignment...OK\n    All 2 tests passed.\n\nShell\n\nIf you have a pointer or a slice that has a small alignment, but you know that it actually has a bigger alignment, use [@alignCast](#alignCast) to change the pointer into a more aligned pointer. This is a no-op at runtime, but inserts a [safety check](#Incorrect-Pointer-Alignment):\n\n``` zig\nconst std = @import(\"std\");\n\ntest \"pointer alignment safety\" {\n    var array align(4) = [_]u32{ 0x11111111, 0x11111111 };\n    const bytes = std.mem.sliceAsBytes(array[0..]);\n    try std.testing.expect(foo(bytes) == 0x11111111);\n}\nfn foo(bytes: []u8) u32 {\n    const slice4 = bytes[1..5];\n    const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n    return int_slice[0];\n}\n```\n\ntest_incorrect_pointer_alignment.zig\n\n    $ zig test test_incorrect_pointer_alignment.zig\n    1/1 test_incorrect_pointer_alignment.test.pointer alignment safety...thread 3568823 panic: incorrect alignment\n    /home/andy/src/zig/doc/langref/test_incorrect_pointer_alignment.zig:10:68: 0x103d13a in foo (test)\n        const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n                                                                       ^\n    /home/andy/src/zig/doc/langref/test_incorrect_pointer_alignment.zig:6:31: 0x103cfd7 in test.pointer alignment safety (test)\n        try std.testing.expect(foo(bytes) == 0x11111111);\n                                  ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1047f10 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e28b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d609 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103d171 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/c771705677c0d2df24e00269a9189f97/test\n\nShell\n\n### allowzero\n\nThis pointer attribute allows a pointer to have address zero. This is only ever needed on the freestanding OS target, where the address zero is mappable. If you want to represent null pointers, use [Optional Pointers](#Optional-Pointers) instead. [Optional Pointers](#Optional-Pointers) with `allowzero` are not the same size as pointers. In this code example, if the pointer did not have the `allowzero` attribute, this would be a [Pointer Cast Invalid Null](#Pointer-Cast-Invalid-Null) panic:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"allowzero\" {\n    var zero: usize = 0; // var to make to runtime-known\n    _ = &zero; // suppress 'var is never mutated' error\n    const ptr: *allowzero i32 = @ptrFromInt(zero);\n    try expect(@intFromPtr(ptr) == 0);\n}\n```\n\ntest_allowzero.zig\n\n    $ zig test test_allowzero.zig\n    1/1 test_allowzero.test.allowzero...OK\n    All 1 tests passed.\n\nShell\n\n### Sentinel-Terminated Pointers\n\nThe syntax `[*:x]T` describes a pointer that has a length determined by a sentinel value. This provides protection against buffer overflow and overreads.\n\n``` zig\nconst std = @import(\"std\");\n\n// This is also available as `std.c.printf`.\npub extern \"c\" fn printf(format: [*:0]const u8, ...) c_int;\n\npub fn main() anyerror!void {\n    _ = printf(\"Hello, world!\\n\"); // OK\n\n    const msg = \"Hello, world!\\n\";\n    const non_null_terminated_msg: [msg.len]u8 = msg.*;\n    _ = printf(&non_null_terminated_msg);\n}\n```\n\nsentinel-terminated_pointer.zig\n\n    $ zig build-exe sentinel-terminated_pointer.zig -lc\n    /home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: error: expected type '[*:0]const u8', found '*const [14]u8'\n        _ = printf(&non_null_terminated_msg);\n                   ^~~~~~~~~~~~~~~~~~~~~~~~\n    /home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: note: destination pointer requires '0' sentinel\n    /home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:4:35: note: parameter type declared here\n    pub extern \"c\" fn printf(format: [*:0]const u8, ...) c_int;\n                                     ~^~~~~~~~~~~~\n    referenced by:\n        callMain: /home/andy/src/zig/lib/std/start.zig:524:32\n        callMainWithArgs: /home/andy/src/zig/lib/std/start.zig:482:12\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\nSee also:\n\n- [Sentinel-Terminated Slices](#Sentinel-Terminated-Slices)\n- [Sentinel-Terminated Arrays](#Sentinel-Terminated-Arrays)\n\n## Slices\n\nA slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the \\`len\\` field.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\nconst expectEqualSlices = @import(\"std\").testing.expectEqualSlices;\n\ntest \"basic slices\" {\n    var array = [_]i32{ 1, 2, 3, 4 };\n    var known_at_runtime_zero: usize = 0;\n    _ = &known_at_runtime_zero;\n    const slice = array[known_at_runtime_zero..array.len];\n\n    // alternative initialization using result location\n    const alt_slice: []const i32 = &.{ 1, 2, 3, 4 };\n\n    try expectEqualSlices(i32, slice, alt_slice);\n\n    try expect(@TypeOf(slice) == []i32);\n    try expect(&slice[0] == &array[0]);\n    try expect(slice.len == array.len);\n\n    // If you slice with comptime-known start and end positions, the result is\n    // a pointer to an array, rather than a slice.\n    const array_ptr = array[0..array.len];\n    try expect(@TypeOf(array_ptr) == *[array.len]i32);\n\n    // You can perform a slice-by-length by slicing twice. This allows the compiler\n    // to perform some optimisations like recognising a comptime-known length when\n    // the start position is only known at runtime.\n    var runtime_start: usize = 1;\n    _ = &runtime_start;\n    const length = 2;\n    const array_ptr_len = array[runtime_start..][0..length];\n    try expect(@TypeOf(array_ptr_len) == *[length]i32);\n\n    // Using the address-of operator on a slice gives a single-item pointer.\n    try expect(@TypeOf(&slice[0]) == *i32);\n    // Using the `ptr` field gives a many-item pointer.\n    try expect(@TypeOf(slice.ptr) == [*]i32);\n    try expect(@intFromPtr(slice.ptr) == @intFromPtr(&slice[0]));\n\n    // Slices have array bounds checking. If you try to access something out\n    // of bounds, you'll get a safety check failure:\n    slice[10] += 1;\n\n    // Note that `slice.ptr` does not invoke safety checking, while `&slice[0]`\n    // asserts that the slice has len > 0.\n}\n```\n\ntest_basic_slices.zig\n\n    $ zig test test_basic_slices.zig\n    1/1 test_basic_slices.test.basic slices...thread 3571722 panic: index out of bounds: index 10, len 4\n    /home/andy/src/zig/doc/langref/test_basic_slices.zig:41:10: 0x103f955 in test.basic slices (test)\n        slice[10] += 1;\n             ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104c800 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x104210b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103fe49 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103f9b1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/3c391d75c939ce98356b98dd812503b1/test\n\nShell\n\nThis is one reason we prefer slices to pointers.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\nconst fmt = std.fmt;\n\ntest \"using slices for strings\" {\n    // Zig has no concept of strings. String literals are const pointers\n    // to null-terminated arrays of u8, and by convention parameters\n    // that are \"strings\" are expected to be UTF-8 encoded slices of u8.\n    // Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8\n    const hello: []const u8 = \"hello\";\n    const world: []const u8 = \"世界\";\n\n    var all_together: [100]u8 = undefined;\n    // You can use slice syntax with at least one runtime-known index on an\n    // array to convert an array into a slice.\n    var start: usize = 0;\n    _ = &start;\n    const all_together_slice = all_together[start..];\n    // String concatenation example.\n    const hello_world = try fmt.bufPrint(all_together_slice, \"{s} {s}\", .{ hello, world });\n\n    // Generally, you can use UTF-8 and not worry about whether something is a\n    // string. If you don't need to deal with individual characters, no need\n    // to decode.\n    try expect(mem.eql(u8, hello_world, \"hello 世界\"));\n}\n\ntest \"slice pointer\" {\n    var array: [10]u8 = undefined;\n    const ptr = &array;\n    try expect(@TypeOf(ptr) == *[10]u8);\n\n    // A pointer to an array can be sliced just like an array:\n    var start: usize = 0;\n    var end: usize = 5;\n    _ = .{ &start, &end };\n    const slice = ptr[start..end];\n    // The slice is mutable because we sliced a mutable pointer.\n    try expect(@TypeOf(slice) == []u8);\n    slice[2] = 3;\n    try expect(array[2] == 3);\n\n    // Again, slicing with comptime-known indexes will produce another pointer\n    // to an array:\n    const ptr2 = slice[2..3];\n    try expect(ptr2.len == 1);\n    try expect(ptr2[0] == 3);\n    try expect(@TypeOf(ptr2) == *[1]u8);\n}\n```\n\ntest_slices.zig\n\n    $ zig test test_slices.zig\n    1/2 test_slices.test.using slices for strings...OK\n    2/2 test_slices.test.slice pointer...OK\n    All 2 tests passed.\n\nShell\n\nSee also:\n\n- [Pointers](#Pointers)\n- [for](#for)\n- [Arrays](#Arrays)\n\n### Sentinel-Terminated Slices\n\nThe syntax `[:x]T` is a slice which has a runtime-known length and also guarantees a sentinel value at the element indexed by the length. The type does not guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element access to the `len` index.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"0-terminated slice\" {\n    const slice: [:0]const u8 = \"hello\";\n\n    try expect(slice.len == 5);\n    try expect(slice[5] == 0);\n}\n```\n\ntest_null_terminated_slice.zig\n\n    $ zig test test_null_terminated_slice.zig\n    1/1 test_null_terminated_slice.test.0-terminated slice...OK\n    All 1 tests passed.\n\nShell\n\nSentinel-terminated slices can also be created using a variation of the slice syntax `data[start..end :x]`, where `data` is a many-item pointer, array or slice and `x` is the sentinel value.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"0-terminated slicing\" {\n    var array = [_]u8{ 3, 2, 1, 0, 3, 2, 1, 0 };\n    var runtime_length: usize = 3;\n    _ = &runtime_length;\n    const slice = array[0..runtime_length :0];\n\n    try expect(@TypeOf(slice) == [:0]u8);\n    try expect(slice.len == 3);\n}\n```\n\ntest_null_terminated_slicing.zig\n\n    $ zig test test_null_terminated_slicing.zig\n    1/1 test_null_terminated_slicing.test.0-terminated slicing...OK\n    All 1 tests passed.\n\nShell\n\nSentinel-terminated slicing asserts that the element in the sentinel position of the backing data is actually the sentinel value. If this is not the case, safety-protected [Undefined Behavior](#Undefined-Behavior) results.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"sentinel mismatch\" {\n    var array = [_]u8{ 3, 2, 1, 0 };\n\n    // Creating a sentinel-terminated slice from the array with a length of 2\n    // will result in the value `1` occupying the sentinel element position.\n    // This does not match the indicated sentinel value of `0` and will lead\n    // to a runtime panic.\n    var runtime_length: usize = 2;\n    _ = &runtime_length;\n    const slice = array[0..runtime_length :0];\n\n    _ = slice;\n}\n```\n\ntest_sentinel_mismatch.zig\n\n    $ zig test test_sentinel_mismatch.zig\n    1/1 test_sentinel_mismatch.test.sentinel mismatch...thread 3579807 panic: sentinel mismatch: expected 0, found 1\n    /home/andy/src/zig/doc/langref/test_sentinel_mismatch.zig:13:24: 0x103cf16 in test.sentinel mismatch (test)\n        const slice = array[0..runtime_length :0];\n                           ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048aa0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103eabb in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d4f9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103d061 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/2af8da0d34d396fbb50fa515cef10c72/test\n\nShell\n\nSee also:\n\n- [Sentinel-Terminated Pointers](#Sentinel-Terminated-Pointers)\n- [Sentinel-Terminated Arrays](#Sentinel-Terminated-Arrays)\n\n## struct\n\n``` zig\n// Declare a struct.\n// Zig gives no guarantees about the order of fields and the size of\n// the struct but the fields are guaranteed to be ABI-aligned.\nconst Point = struct {\n    x: f32,\n    y: f32,\n};\n\n// Maybe we want to pass it to OpenGL so we want to be particular about\n// how the bytes are arranged.\nconst Point2 = packed struct {\n    x: f32,\n    y: f32,\n};\n\n// Declare an instance of a struct.\nconst p = Point{\n    .x = 0.12,\n    .y = 0.34,\n};\n\n// Maybe we're not ready to fill out some of the fields.\nvar p2 = Point{\n    .x = 0.12,\n    .y = undefined,\n};\n\n// Structs can have methods\n// Struct methods are not special, they are only namespaced\n// functions that you can call with dot syntax.\nconst Vec3 = struct {\n    x: f32,\n    y: f32,\n    z: f32,\n\n    pub fn init(x: f32, y: f32, z: f32) Vec3 {\n        return Vec3{\n            .x = x,\n            .y = y,\n            .z = z,\n        };\n    }\n\n    pub fn dot(self: Vec3, other: Vec3) f32 {\n        return self.x * other.x + self.y * other.y + self.z * other.z;\n    }\n};\n\nconst expect = @import(\"std\").testing.expect;\ntest \"dot product\" {\n    const v1 = Vec3.init(1.0, 0.0, 0.0);\n    const v2 = Vec3.init(0.0, 1.0, 0.0);\n    try expect(v1.dot(v2) == 0.0);\n\n    // Other than being available to call with dot syntax, struct methods are\n    // not special. You can reference them as any other declaration inside\n    // the struct:\n    try expect(Vec3.dot(v1, v2) == 0.0);\n}\n\n// Structs can have declarations.\n// Structs can have 0 fields.\nconst Empty = struct {\n    pub const PI = 3.14;\n};\ntest \"struct namespaced variable\" {\n    try expect(Empty.PI == 3.14);\n    try expect(@sizeOf(Empty) == 0);\n\n    // you can still instantiate an empty struct\n    const does_nothing = Empty{};\n\n    _ = does_nothing;\n}\n\n// struct field order is determined by the compiler for optimal performance.\n// however, you can still calculate a struct base pointer given a field pointer:\nfn setYBasedOnX(x: *f32, y: f32) void {\n    const point: *Point = @fieldParentPtr(\"x\", x);\n    point.y = y;\n}\ntest \"field parent pointer\" {\n    var point = Point{\n        .x = 0.1234,\n        .y = 0.5678,\n    };\n    setYBasedOnX(&point.x, 0.9);\n    try expect(point.y == 0.9);\n}\n\n// You can return a struct from a function. This is how we do generics\n// in Zig:\nfn LinkedList(comptime T: type) type {\n    return struct {\n        pub const Node = struct {\n            prev: ?*Node,\n            next: ?*Node,\n            data: T,\n        };\n\n        first: ?*Node,\n        last: ?*Node,\n        len: usize,\n    };\n}\n\ntest \"linked list\" {\n    // Functions called at compile-time are memoized. This means you can\n    // do this:\n    try expect(LinkedList(i32) == LinkedList(i32));\n\n    const list = LinkedList(i32){\n        .first = null,\n        .last = null,\n        .len = 0,\n    };\n    try expect(list.len == 0);\n\n    // Since types are first class values you can instantiate the type\n    // by assigning it to a variable:\n    const ListOfInts = LinkedList(i32);\n    try expect(ListOfInts == LinkedList(i32));\n\n    var node = ListOfInts.Node{\n        .prev = null,\n        .next = null,\n        .data = 1234,\n    };\n    const list2 = LinkedList(i32){\n        .first = &node,\n        .last = &node,\n        .len = 1,\n    };\n\n    // When using a pointer to a struct, fields can be accessed directly,\n    // without explicitly dereferencing the pointer.\n    // So you can do\n    try expect(list2.first.?.data == 1234);\n    // instead of try expect(list2.first.?.*.data == 1234);\n}\n```\n\ntest_structs.zig\n\n    $ zig test test_structs.zig\n    1/4 test_structs.test.dot product...OK\n    2/4 test_structs.test.struct namespaced variable...OK\n    3/4 test_structs.test.field parent pointer...OK\n    4/4 test_structs.test.linked list...OK\n    All 4 tests passed.\n\nShell\n\n### Default Field Values\n\nEach struct field may have an expression indicating the default field value. Such expressions are executed at [comptime](#comptime), and allow the field to be omitted in a struct literal expression:\n\n``` zig\nconst Foo = struct {\n    a: i32 = 1234,\n    b: i32,\n};\n\ntest \"default struct initialization fields\" {\n    const x: Foo = .{\n        .b = 5,\n    };\n    if (x.a + x.b != 1239) {\n        comptime unreachable;\n    }\n}\n```\n\nstruct_default_field_values.zig\n\n    $ zig test struct_default_field_values.zig\n    1/1 struct_default_field_values.test.default struct initialization fields...OK\n    All 1 tests passed.\n\nShell\n\nDefault field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization.\n\nFor example, here is an inappropriate use of default struct field initialization:\n\n``` zig\nconst Threshold = struct {\n    minimum: f32 = 0.25,\n    maximum: f32 = 0.75,\n\n    const Category = enum { low, medium, high };\n\n    fn categorize(t: Threshold, value: f32) Category {\n        assert(t.maximum >= t.minimum);\n        if (value < t.minimum) return .low;\n        if (value > t.maximum) return .high;\n        return .medium;\n    }\n};\n\npub fn main() !void {\n    var threshold: Threshold = .{\n        .maximum = 0.20,\n    };\n    const category = threshold.categorize(0.90);\n    try std.io.getStdOut().writeAll(@tagName(category));\n}\n\nconst std = @import(\"std\");\nconst assert = std.debug.assert;\n```\n\nbad_default_value.zig\n\n    $ zig build-exe bad_default_value.zig\n    $ ./bad_default_value\n    thread 3570319 panic: reached unreachable code\n    /home/andy/src/zig/lib/std/debug.zig:412:14: 0x1037a6d in assert (bad_default_value)\n        if (!ok) unreachable; // assertion failure\n                 ^\n    /home/andy/src/zig/doc/langref/bad_default_value.zig:8:15: 0x1034f59 in categorize (bad_default_value)\n            assert(t.maximum >= t.minimum);\n                  ^\n    /home/andy/src/zig/doc/langref/bad_default_value.zig:19:42: 0x1034e8a in main (bad_default_value)\n        const category = threshold.categorize(0.90);\n                                             ^\n    /home/andy/src/zig/lib/std/start.zig:524:37: 0x1034da5 in posixCallMainAndExit (bad_default_value)\n                const result = root.main() catch |err| {\n                                        ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10348c1 in _start (bad_default_value)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nAbove you can see the danger of ignoring this principle. The default field values caused the data invariant to be violated, causing illegal behavior.\n\nTo fix this, remove the default values from all the struct fields, and provide a named default value:\n\n``` zig\nconst Threshold = struct {\n    minimum: f32,\n    maximum: f32,\n\n    const default: Threshold = .{\n        .minimum = 0.25,\n        .maximum = 0.75,\n    };\n};\n```\n\nstruct_default_value.zig\n\nIf a struct value requires a runtime-known value in order to be initialized without violating data invariants, then use an initialization method that accepts those runtime values, and populates the remaining fields.\n\n### extern struct\n\nAn `extern`` ``struct` has in-memory layout matching the C ABI for the target.\n\nIf well-defined in-memory layout is not required, [struct](#struct) is a better choice because it places fewer restrictions on the compiler.\n\nSee [packed struct](#packed-struct) for a struct that has the ABI of its backing integer, which can be useful for modeling flags.\n\nSee also:\n\n- [extern union](#extern-union)\n- [extern enum](#extern-enum)\n\n### packed struct\n\nUnlike normal structs, `packed` structs have guaranteed in-memory layout:\n\n- Fields remain in the order declared, least to most significant.\n- There is no padding between fields.\n- Zig supports arbitrary width [Integers](#Integers) and although normally, integers with fewer than 8 bits will still use 1 byte of memory, in packed structs, they use exactly their bit width.\n- `bool` fields use exactly 1 bit.\n- An [enum](#enum) field uses exactly the bit width of its integer tag type.\n- A [packed union](#packed-union) field uses exactly the bit width of the union field with the largest bit width.\n\nThis means that a `packed`` ``struct` can participate in a [@bitCast](#bitCast) or a [@ptrCast](#ptrCast) to reinterpret memory. This even works at [comptime](#comptime):\n\n``` zig\nconst std = @import(\"std\");\nconst native_endian = @import(\"builtin\").target.cpu.arch.endian();\nconst expect = std.testing.expect;\n\nconst Full = packed struct {\n    number: u16,\n};\nconst Divided = packed struct {\n    half1: u8,\n    quarter3: u4,\n    quarter4: u4,\n};\n\ntest \"@bitCast between packed structs\" {\n    try doTheTest();\n    try comptime doTheTest();\n}\n\nfn doTheTest() !void {\n    try expect(@sizeOf(Full) == 2);\n    try expect(@sizeOf(Divided) == 2);\n    const full = Full{ .number = 0x1234 };\n    const divided: Divided = @bitCast(full);\n    try expect(divided.half1 == 0x34);\n    try expect(divided.quarter3 == 0x2);\n    try expect(divided.quarter4 == 0x1);\n\n    const ordered: [2]u8 = @bitCast(full);\n    switch (native_endian) {\n        .big => {\n            try expect(ordered[0] == 0x12);\n            try expect(ordered[1] == 0x34);\n        },\n        .little => {\n            try expect(ordered[0] == 0x34);\n            try expect(ordered[1] == 0x12);\n        },\n    }\n}\n```\n\ntest_packed_structs.zig\n\n    $ zig test test_packed_structs.zig\n    1/1 test_packed_structs.test.@bitCast between packed structs...OK\n    All 1 tests passed.\n\nShell\n\nThe backing integer is inferred from the fields' total bit width. Optionally, it can be explicitly provided and enforced at compile time:\n\n``` zig\ntest \"missized packed struct\" {\n    const S = packed struct(u32) { a: u16, b: u8 };\n    _ = S{ .a = 4, .b = 2 };\n}\n```\n\ntest_missized_packed_struct.zig\n\n    $ zig test test_missized_packed_struct.zig\n    doc/langref/test_missized_packed_struct.zig:2:29: error: backing integer type 'u32' has bit size 32 but the struct fields have a total bit size of 24\n        const S = packed struct(u32) { a: u16, b: u8 };\n                                ^~~\n\nShell\n\nZig allows the address to be taken of a non-byte-aligned field:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\nvar foo = BitField{\n    .a = 1,\n    .b = 2,\n    .c = 3,\n};\n\ntest \"pointer to non-byte-aligned field\" {\n    const ptr = &foo.b;\n    try expect(ptr.* == 2);\n}\n```\n\ntest_pointer_to_non-byte_aligned_field.zig\n\n    $ zig test test_pointer_to_non-byte_aligned_field.zig\n    1/1 test_pointer_to_non-byte_aligned_field.test.pointer to non-byte-aligned field...OK\n    All 1 tests passed.\n\nShell\n\nHowever, the pointer to a non-byte-aligned field has special properties and cannot be passed when a normal pointer is expected:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\nvar bit_field = BitField{\n    .a = 1,\n    .b = 2,\n    .c = 3,\n};\n\ntest \"pointer to non-byte-aligned field\" {\n    try expect(bar(&bit_field.b) == 2);\n}\n\nfn bar(x: *const u3) u3 {\n    return x.*;\n}\n```\n\ntest_misaligned_pointer.zig\n\n    $ zig test test_misaligned_pointer.zig\n    doc/langref/test_misaligned_pointer.zig:17:20: error: expected type '*const u3', found '*align(1:3:1) u3'\n        try expect(bar(&bit_field.b) == 2);\n                       ^~~~~~~~~~~~\n    doc/langref/test_misaligned_pointer.zig:17:20: note: pointer host size '1' cannot cast into pointer host size '0'\n    doc/langref/test_misaligned_pointer.zig:17:20: note: pointer bit offset '3' cannot cast into pointer bit offset '0'\n    doc/langref/test_misaligned_pointer.zig:20:11: note: parameter type declared here\n    fn bar(x: *const u3) u3 {\n              ^~~~~~~~~\n\nShell\n\nIn this case, the function `bar` cannot be called because the pointer to the non-ABI-aligned field mentions the bit offset, but the function expects an ABI-aligned pointer.\n\nPointers to non-ABI-aligned fields share the same address as the other fields within their host integer:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\nvar bit_field = BitField{\n    .a = 1,\n    .b = 2,\n    .c = 3,\n};\n\ntest \"pointers of sub-byte-aligned fields share addresses\" {\n    try expect(@intFromPtr(&bit_field.a) == @intFromPtr(&bit_field.b));\n    try expect(@intFromPtr(&bit_field.a) == @intFromPtr(&bit_field.c));\n}\n```\n\ntest_packed_struct_field_address.zig\n\n    $ zig test test_packed_struct_field_address.zig\n    1/1 test_packed_struct_field_address.test.pointers of sub-byte-aligned fields share addresses...OK\n    All 1 tests passed.\n\nShell\n\nThis can be observed with [@bitOffsetOf](#bitOffsetOf) and [offsetOf](#offsetOf):\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst BitField = packed struct {\n    a: u3,\n    b: u3,\n    c: u2,\n};\n\ntest \"offsets of non-byte-aligned fields\" {\n    comptime {\n        try expect(@bitOffsetOf(BitField, \"a\") == 0);\n        try expect(@bitOffsetOf(BitField, \"b\") == 3);\n        try expect(@bitOffsetOf(BitField, \"c\") == 6);\n\n        try expect(@offsetOf(BitField, \"a\") == 0);\n        try expect(@offsetOf(BitField, \"b\") == 0);\n        try expect(@offsetOf(BitField, \"c\") == 0);\n    }\n}\n```\n\ntest_bitOffsetOf_offsetOf.zig\n\n    $ zig test test_bitOffsetOf_offsetOf.zig\n    1/1 test_bitOffsetOf_offsetOf.test.offsets of non-byte-aligned fields...OK\n    All 1 tests passed.\n\nShell\n\nPacked structs have the same alignment as their backing integer, however, overaligned pointers to packed structs can override this:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst S = packed struct {\n    a: u32,\n    b: u32,\n};\ntest \"overaligned pointer to packed struct\" {\n    var foo: S align(4) = .{ .a = 1, .b = 2 };\n    const ptr: *align(4) S = &foo;\n    const ptr_to_b: *u32 = &ptr.b;\n    try expect(ptr_to_b.* == 2);\n}\n```\n\ntest_overaligned_packed_struct.zig\n\n    $ zig test test_overaligned_packed_struct.zig\n    1/1 test_overaligned_packed_struct.test.overaligned pointer to packed struct...OK\n    All 1 tests passed.\n\nShell\n\nIt's also possible to set alignment of struct fields:\n\n``` zig\nconst std = @import(\"std\");\nconst expectEqual = std.testing.expectEqual;\n\ntest \"aligned struct fields\" {\n    const S = struct {\n        a: u32 align(2),\n        b: u32 align(64),\n    };\n    var foo = S{ .a = 1, .b = 2 };\n\n    try expectEqual(64, @alignOf(S));\n    try expectEqual(*align(2) u32, @TypeOf(&foo.a));\n    try expectEqual(*align(64) u32, @TypeOf(&foo.b));\n}\n```\n\ntest_aligned_struct_fields.zig\n\n    $ zig test test_aligned_struct_fields.zig\n    1/1 test_aligned_struct_fields.test.aligned struct fields...OK\n    All 1 tests passed.\n\nShell\n\nUsing packed structs with [volatile](#volatile) is problematic, and may be a compile error in the future. For details on this subscribe to [this issue](https://github.com/ziglang/zig/issues/1761). TODO update these docs with a recommendation on how to use packed structs with MMIO (the use case for volatile packed structs) once this issue is resolved. Don't worry, there will be a good solution for this use case in zig.\n\n### Struct Naming\n\nSince all structs are anonymous, Zig infers the type name based on a few rules.\n\n- If the struct is in the initialization expression of a variable, it gets named after that variable.\n- If the struct is in the `return` expression, it gets named after the function it is returning from, with the parameter values serialized.\n- Otherwise, the struct gets a name such as `(filename.funcname.__struct_ID)`.\n- If the struct is declared inside another struct, it gets named after both the parent struct and the name inferred by the previous rules, separated by a dot.\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    const Foo = struct {};\n    std.debug.print(\"variable: {s}\\n\", .{@typeName(Foo)});\n    std.debug.print(\"anonymous: {s}\\n\", .{@typeName(struct {})});\n    std.debug.print(\"function: {s}\\n\", .{@typeName(List(i32))});\n}\n\nfn List(comptime T: type) type {\n    return struct {\n        x: T,\n    };\n}\n```\n\nstruct_name.zig\n\n    $ zig build-exe struct_name.zig\n    $ ./struct_name\n    variable: struct_name.main.Foo\n    anonymous: struct_name.main__struct_3331\n    function: struct_name.List(i32)\n\nShell\n\n### Anonymous Struct Literals\n\nZig allows omitting the struct type of a literal. When the result is [coerced](#Type-Coercion), the struct literal will directly instantiate the [result location](#Result-Location-Semantics), with no copy:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Point = struct { x: i32, y: i32 };\n\ntest \"anonymous struct literal\" {\n    const pt: Point = .{\n        .x = 13,\n        .y = 67,\n    };\n    try expect(pt.x == 13);\n    try expect(pt.y == 67);\n}\n```\n\ntest_struct_result.zig\n\n    $ zig test test_struct_result.zig\n    1/1 test_struct_result.test.anonymous struct literal...OK\n    All 1 tests passed.\n\nShell\n\nThe struct type can be inferred. Here the [result location](#Result-Location-Semantics) does not include a type, and so Zig infers the type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"fully anonymous struct\" {\n    try check(.{\n        .int = @as(u32, 1234),\n        .float = @as(f64, 12.34),\n        .b = true,\n        .s = \"hi\",\n    });\n}\n\nfn check(args: anytype) !void {\n    try expect(args.int == 1234);\n    try expect(args.float == 12.34);\n    try expect(args.b);\n    try expect(args.s[0] == 'h');\n    try expect(args.s[1] == 'i');\n}\n```\n\ntest_anonymous_struct.zig\n\n    $ zig test test_anonymous_struct.zig\n    1/1 test_anonymous_struct.test.fully anonymous struct...OK\n    All 1 tests passed.\n\nShell\n\n### Tuples\n\nAnonymous structs can be created without specifying field names, and are referred to as \"tuples\".\n\nThe fields are implicitly named using numbers starting from 0. Because their names are integers, they cannot be accessed with `.` syntax without also wrapping them in `@\"\"`. Names inside `@\"\"` are always recognised as [identifiers](#Identifiers).\n\nLike arrays, tuples have a .len field, can be indexed (provided the index is comptime-known) and work with the ++ and \\*\\* operators. They can also be iterated over with [inline for](#inline-for).\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"tuple\" {\n    const values = .{\n        @as(u32, 1234),\n        @as(f64, 12.34),\n        true,\n        \"hi\",\n    } ++ .{false} ** 2;\n    try expect(values[0] == 1234);\n    try expect(values[4] == false);\n    inline for (values, 0..) |v, i| {\n        if (i != 2) continue;\n        try expect(v);\n    }\n    try expect(values.len == 6);\n    try expect(values.@\"3\"[0] == 'h');\n}\n```\n\ntest_tuples.zig\n\n    $ zig test test_tuples.zig\n    1/1 test_tuples.test.tuple...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [comptime](#comptime)\n- [@fieldParentPtr](#fieldParentPtr)\n\n## enum\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\nconst mem = @import(\"std\").mem;\n\n// Declare an enum.\nconst Type = enum {\n    ok,\n    not_ok,\n};\n\n// Declare a specific enum field.\nconst c = Type.ok;\n\n// If you want access to the ordinal value of an enum, you\n// can specify the tag type.\nconst Value = enum(u2) {\n    zero,\n    one,\n    two,\n};\n// Now you can cast between u2 and Value.\n// The ordinal value starts from 0, counting up by 1 from the previous member.\ntest \"enum ordinal value\" {\n    try expect(@intFromEnum(Value.zero) == 0);\n    try expect(@intFromEnum(Value.one) == 1);\n    try expect(@intFromEnum(Value.two) == 2);\n}\n\n// You can override the ordinal value for an enum.\nconst Value2 = enum(u32) {\n    hundred = 100,\n    thousand = 1000,\n    million = 1000000,\n};\ntest \"set enum ordinal value\" {\n    try expect(@intFromEnum(Value2.hundred) == 100);\n    try expect(@intFromEnum(Value2.thousand) == 1000);\n    try expect(@intFromEnum(Value2.million) == 1000000);\n}\n\n// You can also override only some values.\nconst Value3 = enum(u4) {\n    a,\n    b = 8,\n    c,\n    d = 4,\n    e,\n};\ntest \"enum implicit ordinal values and overridden values\" {\n    try expect(@intFromEnum(Value3.a) == 0);\n    try expect(@intFromEnum(Value3.b) == 8);\n    try expect(@intFromEnum(Value3.c) == 9);\n    try expect(@intFromEnum(Value3.d) == 4);\n    try expect(@intFromEnum(Value3.e) == 5);\n}\n\n// Enums can have methods, the same as structs and unions.\n// Enum methods are not special, they are only namespaced\n// functions that you can call with dot syntax.\nconst Suit = enum {\n    clubs,\n    spades,\n    diamonds,\n    hearts,\n\n    pub fn isClubs(self: Suit) bool {\n        return self == Suit.clubs;\n    }\n};\ntest \"enum method\" {\n    const p = Suit.spades;\n    try expect(!p.isClubs());\n}\n\n// An enum can be switched upon.\nconst Foo = enum {\n    string,\n    number,\n    none,\n};\ntest \"enum switch\" {\n    const p = Foo.number;\n    const what_is_it = switch (p) {\n        Foo.string => \"this is a string\",\n        Foo.number => \"this is a number\",\n        Foo.none => \"this is a none\",\n    };\n    try expect(mem.eql(u8, what_is_it, \"this is a number\"));\n}\n\n// @typeInfo can be used to access the integer tag type of an enum.\nconst Small = enum {\n    one,\n    two,\n    three,\n    four,\n};\ntest \"std.meta.Tag\" {\n    try expect(@typeInfo(Small).Enum.tag_type == u2);\n}\n\n// @typeInfo tells us the field count and the fields names:\ntest \"@typeInfo\" {\n    try expect(@typeInfo(Small).Enum.fields.len == 4);\n    try expect(mem.eql(u8, @typeInfo(Small).Enum.fields[1].name, \"two\"));\n}\n\n// @tagName gives a [:0]const u8 representation of an enum value:\ntest \"@tagName\" {\n    try expect(mem.eql(u8, @tagName(Small.three), \"three\"));\n}\n```\n\ntest_enums.zig\n\n    $ zig test test_enums.zig\n    1/8 test_enums.test.enum ordinal value...OK\n    2/8 test_enums.test.set enum ordinal value...OK\n    3/8 test_enums.test.enum implicit ordinal values and overridden values...OK\n    4/8 test_enums.test.enum method...OK\n    5/8 test_enums.test.enum switch...OK\n    6/8 test_enums.test.std.meta.Tag...OK\n    7/8 test_enums.test.@typeInfo...OK\n    8/8 test_enums.test.@tagName...OK\n    All 8 tests passed.\n\nShell\n\nSee also:\n\n- [@typeInfo](#typeInfo)\n- [@tagName](#tagName)\n- [@sizeOf](#sizeOf)\n\n### extern enum\n\nBy default, enums are not guaranteed to be compatible with the C ABI:\n\n``` zig\nconst Foo = enum { a, b, c };\nexport fn entry(foo: Foo) void {\n    _ = foo;\n}\n```\n\nenum_export_error.zig\n\n    $ zig build-obj enum_export_error.zig\n    doc/langref/enum_export_error.zig:2:17: error: parameter of type 'enum_export_error.Foo' not allowed in function with calling convention 'C'\n    export fn entry(foo: Foo) void {\n                    ^~~~~~~~\n    doc/langref/enum_export_error.zig:2:17: note: enum tag type 'u2' is not extern compatible\n    doc/langref/enum_export_error.zig:2:17: note: only integers with 0, 8, 16, 32, 64 and 128 bits are extern compatible\n    doc/langref/enum_export_error.zig:1:13: note: enum declared here\n    const Foo = enum { a, b, c };\n                ^~~~~~~~~~~~~~~~\n\nShell\n\nFor a C-ABI-compatible enum, provide an explicit tag type to the enum:\n\n``` zig\nconst Foo = enum(c_int) { a, b, c };\nexport fn entry(foo: Foo) void {\n    _ = foo;\n}\n```\n\nenum_export.zig\n\n    $ zig build-obj enum_export.zig\n\nShell\n\n### Enum Literals\n\nEnum literals allow specifying the name of an enum field without specifying the enum type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Color = enum {\n    auto,\n    off,\n    on,\n};\n\ntest \"enum literals\" {\n    const color1: Color = .auto;\n    const color2 = Color.auto;\n    try expect(color1 == color2);\n}\n\ntest \"switch using enum literals\" {\n    const color = Color.on;\n    const result = switch (color) {\n        .auto => false,\n        .on => true,\n        .off => false,\n    };\n    try expect(result);\n}\n```\n\ntest_enum_literals.zig\n\n    $ zig test test_enum_literals.zig\n    1/2 test_enum_literals.test.enum literals...OK\n    2/2 test_enum_literals.test.switch using enum literals...OK\n    All 2 tests passed.\n\nShell\n\n### Non-exhaustive enum\n\nA non-exhaustive enum can be created by adding a trailing `_` field. The enum must specify a tag type and cannot consume every enumeration value.\n\n[@enumFromInt](#enumFromInt) on a non-exhaustive enum involves the safety semantics of [@intCast](#intCast) to the integer tag type, but beyond that always results in a well-defined enum value.\n\nA switch on a non-exhaustive enum can include a `_` prong as an alternative to an `else` prong. With a `_` prong the compiler errors if all the known tag names are not handled by the switch.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Number = enum(u8) {\n    one,\n    two,\n    three,\n    _,\n};\n\ntest \"switch on non-exhaustive enum\" {\n    const number = Number.one;\n    const result = switch (number) {\n        .one => true,\n        .two, .three => false,\n        _ => false,\n    };\n    try expect(result);\n    const is_one = switch (number) {\n        .one => true,\n        else => false,\n    };\n    try expect(is_one);\n}\n```\n\ntest_switch_non-exhaustive.zig\n\n    $ zig test test_switch_non-exhaustive.zig\n    1/1 test_switch_non-exhaustive.test.switch on non-exhaustive enum...OK\n    All 1 tests passed.\n\nShell\n\n## union\n\nA bare `union` defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use [@ptrCast](#ptrCast), or use an [extern union](#extern-union) or a [packed union](#packed-union) which have guaranteed in-memory layout. [Accessing the non-active field](#Wrong-Union-Field-Access) is safety-checked [Undefined Behavior](#Undefined-Behavior):\n\n``` zig\nconst Payload = union {\n    int: i64,\n    float: f64,\n    boolean: bool,\n};\ntest \"simple union\" {\n    var payload = Payload{ .int = 1234 };\n    payload.float = 12.34;\n}\n```\n\ntest_wrong_union_access.zig\n\n    $ zig test test_wrong_union_access.zig\n    1/1 test_wrong_union_access.test.simple union...thread 3579408 panic: access of union field 'float' while field 'int' is active\n    /home/andy/src/zig/doc/langref/test_wrong_union_access.zig:8:12: 0x103ce87 in test.simple union (test)\n        payload.float = 12.34;\n               ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048070 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e08b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d419 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cf81 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/bb9968225995fac0bbc9f2116e8583c2/test\n\nShell\n\nYou can activate another field by assigning the entire union:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Payload = union {\n    int: i64,\n    float: f64,\n    boolean: bool,\n};\ntest \"simple union\" {\n    var payload = Payload{ .int = 1234 };\n    try expect(payload.int == 1234);\n    payload = Payload{ .float = 12.34 };\n    try expect(payload.float == 12.34);\n}\n```\n\ntest_simple_union.zig\n\n    $ zig test test_simple_union.zig\n    1/1 test_simple_union.test.simple union...OK\n    All 1 tests passed.\n\nShell\n\nIn order to use [switch](#switch) with a union, it must be a [Tagged union](#Tagged-union).\n\nTo initialize a union when the tag is a [comptime](#comptime)-known name, see [@unionInit](#unionInit).\n\n### Tagged union\n\nUnions can be declared with an enum tag type. This turns the union into a *tagged* union, which makes it eligible to use with [switch](#switch) expressions. Tagged unions coerce to their tag type: [Type Coercion: Unions and Enums](#Type-Coercion-Unions-and-Enums).\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst ComplexTypeTag = enum {\n    ok,\n    not_ok,\n};\nconst ComplexType = union(ComplexTypeTag) {\n    ok: u8,\n    not_ok: void,\n};\n\ntest \"switch on tagged union\" {\n    const c = ComplexType{ .ok = 42 };\n    try expect(@as(ComplexTypeTag, c) == ComplexTypeTag.ok);\n\n    switch (c) {\n        ComplexTypeTag.ok => |value| try expect(value == 42),\n        ComplexTypeTag.not_ok => unreachable,\n    }\n}\n\ntest \"get tag type\" {\n    try expect(std.meta.Tag(ComplexType) == ComplexTypeTag);\n}\n```\n\ntest_tagged_union.zig\n\n    $ zig test test_tagged_union.zig\n    1/2 test_tagged_union.test.switch on tagged union...OK\n    2/2 test_tagged_union.test.get tag type...OK\n    All 2 tests passed.\n\nShell\n\nIn order to modify the payload of a tagged union in a switch expression, place a `*` before the variable name to make it a pointer:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst ComplexTypeTag = enum {\n    ok,\n    not_ok,\n};\nconst ComplexType = union(ComplexTypeTag) {\n    ok: u8,\n    not_ok: void,\n};\n\ntest \"modify tagged union in switch\" {\n    var c = ComplexType{ .ok = 42 };\n\n    switch (c) {\n        ComplexTypeTag.ok => |*value| value.* += 1,\n        ComplexTypeTag.not_ok => unreachable,\n    }\n\n    try expect(c.ok == 43);\n}\n```\n\ntest_switch_modify_tagged_union.zig\n\n    $ zig test test_switch_modify_tagged_union.zig\n    1/1 test_switch_modify_tagged_union.test.modify tagged union in switch...OK\n    All 1 tests passed.\n\nShell\n\nUnions can be made to infer the enum tag type. Further, unions can have methods just like structs and enums.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Variant = union(enum) {\n    int: i32,\n    boolean: bool,\n\n    // void can be omitted when inferring enum tag type.\n    none,\n\n    fn truthy(self: Variant) bool {\n        return switch (self) {\n            Variant.int => |x_int| x_int != 0,\n            Variant.boolean => |x_bool| x_bool,\n            Variant.none => false,\n        };\n    }\n};\n\ntest \"union method\" {\n    var v1 = Variant{ .int = 1 };\n    var v2 = Variant{ .boolean = false };\n\n    try expect(v1.truthy());\n    try expect(!v2.truthy());\n}\n```\n\ntest_union_method.zig\n\n    $ zig test test_union_method.zig\n    1/1 test_union_method.test.union method...OK\n    All 1 tests passed.\n\nShell\n\n[@tagName](#tagName) can be used to return a [comptime](#comptime) `[:``0``]``const`` ``u8` value representing the field name:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Small2 = union(enum) {\n    a: i32,\n    b: bool,\n    c: u8,\n};\ntest \"@tagName\" {\n    try expect(std.mem.eql(u8, @tagName(Small2.a), \"a\"));\n}\n```\n\ntest_tagName.zig\n\n    $ zig test test_tagName.zig\n    1/1 test_tagName.test.@tagName...OK\n    All 1 tests passed.\n\nShell\n\n### extern union\n\nAn `extern`` ``union` has memory layout guaranteed to be compatible with the target C ABI.\n\nSee also:\n\n- [extern struct](#extern-struct)\n\n### packed union\n\nA `packed`` ``union` has well-defined in-memory layout and is eligible to be in a [packed struct](#packed-struct).\n\n### Anonymous Union Literals\n\n[Anonymous Struct Literals](#Anonymous-Struct-Literals) syntax can be used to initialize unions without specifying the type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Number = union {\n    int: i32,\n    float: f64,\n};\n\ntest \"anonymous union literal syntax\" {\n    const i: Number = .{ .int = 42 };\n    const f = makeNumber();\n    try expect(i.int == 42);\n    try expect(f.float == 12.34);\n}\n\nfn makeNumber() Number {\n    return .{ .float = 12.34 };\n}\n```\n\ntest_anonymous_union.zig\n\n    $ zig test test_anonymous_union.zig\n    1/1 test_anonymous_union.test.anonymous union literal syntax...OK\n    All 1 tests passed.\n\nShell\n\n## opaque\n\n`opaque`` {}` declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as [structs](#struct), [unions](#union), and [enums](#enum).\n\nThis is typically used for type safety when interacting with C code that does not expose struct details. Example:\n\n``` zig\nconst Derp = opaque {};\nconst Wat = opaque {};\n\nextern fn bar(d: *Derp) void;\nfn foo(w: *Wat) callconv(.C) void {\n    bar(w);\n}\n\ntest \"call foo\" {\n    foo(undefined);\n}\n```\n\ntest_opaque.zig\n\n    $ zig test test_opaque.zig\n    doc/langref/test_opaque.zig:6:9: error: expected type '*test_opaque.Derp', found '*test_opaque.Wat'\n        bar(w);\n            ^\n    doc/langref/test_opaque.zig:6:9: note: pointer type child 'test_opaque.Wat' cannot cast into pointer type child 'test_opaque.Derp'\n    doc/langref/test_opaque.zig:2:13: note: opaque declared here\n    const Wat = opaque {};\n                ^~~~~~~~~\n    doc/langref/test_opaque.zig:1:14: note: opaque declared here\n    const Derp = opaque {};\n                 ^~~~~~~~~\n    doc/langref/test_opaque.zig:4:18: note: parameter type declared here\n    extern fn bar(d: *Derp) void;\n                     ^~~~~\n    referenced by:\n        test.call foo: doc/langref/test_opaque.zig:10:5\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\n## Blocks\n\nBlocks are used to limit the scope of variable declarations:\n\n``` zig\ntest \"access variable after block scope\" {\n    {\n        var x: i32 = 1;\n        _ = &x;\n    }\n    x += 1;\n}\n```\n\ntest_blocks.zig\n\n    $ zig test test_blocks.zig\n    doc/langref/test_blocks.zig:6:5: error: use of undeclared identifier 'x'\n        x += 1;\n        ^\n\nShell\n\nBlocks are expressions. When labeled, `break` can be used to return a value from the block:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"labeled break from labeled block expression\" {\n    var y: i32 = 123;\n\n    const x = blk: {\n        y += 1;\n        break :blk y;\n    };\n    try expect(x == 124);\n    try expect(y == 124);\n}\n```\n\ntest_labeled_break.zig\n\n    $ zig test test_labeled_break.zig\n    1/1 test_labeled_break.test.labeled break from labeled block expression...OK\n    All 1 tests passed.\n\nShell\n\nHere, `blk` can be any name.\n\nSee also:\n\n- [Labeled while](#Labeled-while)\n- [Labeled for](#Labeled-for)\n\n### Shadowing\n\n[Identifiers](#Identifiers) are never allowed to \"hide\" other identifiers by using the same name:\n\n``` zig\nconst pi = 3.14;\n\ntest \"inside test block\" {\n    // Let's even go inside another block\n    {\n        var pi: i32 = 1234;\n    }\n}\n```\n\ntest_shadowing.zig\n\n    $ zig test test_shadowing.zig\n    doc/langref/test_shadowing.zig:6:13: error: local variable shadows declaration of 'pi'\n            var pi: i32 = 1234;\n                ^~\n    doc/langref/test_shadowing.zig:1:1: note: declared here\n    const pi = 3.14;\n    ^~~~~~~~~~~~~~~\n\nShell\n\nBecause of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing within the scope it is defined. Note that you can, however, use the same name if the scopes are separate:\n\n``` zig\ntest \"separate scopes\" {\n    {\n        const pi = 3.14;\n        _ = pi;\n    }\n    {\n        var pi: bool = true;\n        _ = &pi;\n    }\n}\n```\n\ntest_scopes.zig\n\n    $ zig test test_scopes.zig\n    1/1 test_scopes.test.separate scopes...OK\n    All 1 tests passed.\n\nShell\n\n### Empty Blocks\n\nAn empty block is equivalent to `void``{}`:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest {\n    const a = {};\n    const b = void{};\n    try expect(@TypeOf(a) == void);\n    try expect(@TypeOf(b) == void);\n    try expect(a == b);\n}\n```\n\ntest_empty_block.zig\n\n    $ zig test test_empty_block.zig\n    1/1 test_empty_block.test_0...OK\n    All 1 tests passed.\n\nShell\n\n## switch\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\n\ntest \"switch simple\" {\n    const a: u64 = 10;\n    const zz: u64 = 103;\n\n    // All branches of a switch expression must be able to be coerced to a\n    // common type.\n    //\n    // Branches cannot fallthrough. If fallthrough behavior is desired, combine\n    // the cases and use an if.\n    const b = switch (a) {\n        // Multiple cases can be combined via a ','\n        1, 2, 3 => 0,\n\n        // Ranges can be specified using the ... syntax. These are inclusive\n        // of both ends.\n        5...100 => 1,\n\n        // Branches can be arbitrarily complex.\n        101 => blk: {\n            const c: u64 = 5;\n            break :blk c * 2 + 1;\n        },\n\n        // Switching on arbitrary expressions is allowed as long as the\n        // expression is known at compile-time.\n        zz => zz,\n        blk: {\n            const d: u32 = 5;\n            const e: u32 = 100;\n            break :blk d + e;\n        } => 107,\n\n        // The else branch catches everything not already captured.\n        // Else branches are mandatory unless the entire range of values\n        // is handled.\n        else => 9,\n    };\n\n    try expect(b == 1);\n}\n\n// Switch expressions can be used outside a function:\nconst os_msg = switch (builtin.target.os.tag) {\n    .linux => \"we found a linux user\",\n    else => \"not a linux user\",\n};\n\n// Inside a function, switch statements implicitly are compile-time\n// evaluated if the target expression is compile-time known.\ntest \"switch inside function\" {\n    switch (builtin.target.os.tag) {\n        .fuchsia => {\n            // On an OS other than fuchsia, block is not even analyzed,\n            // so this compile error is not triggered.\n            // On fuchsia this compile error would be triggered.\n            @compileError(\"fuchsia not supported\");\n        },\n        else => {},\n    }\n}\n```\n\ntest_switch.zig\n\n    $ zig test test_switch.zig\n    1/2 test_switch.test.switch simple...OK\n    2/2 test_switch.test.switch inside function...OK\n    All 2 tests passed.\n\nShell\n\n`switch` can be used to capture the field values of a [Tagged union](#Tagged-union). Modifications to the field values can be done by placing a `*` before the capture variable name, turning it into a pointer.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"switch on tagged union\" {\n    const Point = struct {\n        x: u8,\n        y: u8,\n    };\n    const Item = union(enum) {\n        a: u32,\n        c: Point,\n        d,\n        e: u32,\n    };\n\n    var a = Item{ .c = Point{ .x = 1, .y = 2 } };\n\n    // Switching on more complex enums is allowed.\n    const b = switch (a) {\n        // A capture group is allowed on a match, and will return the enum\n        // value matched. If the payload types of both cases are the same\n        // they can be put into the same switch prong.\n        Item.a, Item.e => |item| item,\n\n        // A reference to the matched value can be obtained using `*` syntax.\n        Item.c => |*item| blk: {\n            item.*.x += 1;\n            break :blk 6;\n        },\n\n        // No else is required if the types cases was exhaustively handled\n        Item.d => 8,\n    };\n\n    try expect(b == 6);\n    try expect(a.c.x == 2);\n}\n```\n\ntest_switch_tagged_union.zig\n\n    $ zig test test_switch_tagged_union.zig\n    1/1 test_switch_tagged_union.test.switch on tagged union...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [comptime](#comptime)\n- [enum](#enum)\n- [@compileError](#compileError)\n- [Compile Variables](#Compile-Variables)\n\n### Exhaustive Switching\n\nWhen a `switch` expression does not have an `else` clause, it must exhaustively list all the possible values. Failure to do so is a compile error:\n\n``` zig\nconst Color = enum {\n    auto,\n    off,\n    on,\n};\n\ntest \"exhaustive switching\" {\n    const color = Color.off;\n    switch (color) {\n        Color.auto => {},\n        Color.on => {},\n    }\n}\n```\n\ntest_unhandled_enumeration_value.zig\n\n    $ zig test test_unhandled_enumeration_value.zig\n    doc/langref/test_unhandled_enumeration_value.zig:9:5: error: switch must handle all possibilities\n        switch (color) {\n        ^~~~~~\n    doc/langref/test_unhandled_enumeration_value.zig:3:5: note: unhandled enumeration value: 'off'\n        off,\n        ^~~\n    doc/langref/test_unhandled_enumeration_value.zig:1:15: note: enum 'test_unhandled_enumeration_value.Color' declared here\n    const Color = enum {\n                  ^~~~\n\nShell\n\n### Switching with Enum Literals\n\n[Enum Literals](#Enum-Literals) can be useful to use with `switch` to avoid repetitively specifying [enum](#enum) or [union](#union) types:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Color = enum {\n    auto,\n    off,\n    on,\n};\n\ntest \"enum literals with switch\" {\n    const color = Color.off;\n    const result = switch (color) {\n        .auto => false,\n        .on => false,\n        .off => true,\n    };\n    try expect(result);\n}\n```\n\ntest_exhaustive_switch.zig\n\n    $ zig test test_exhaustive_switch.zig\n    1/1 test_exhaustive_switch.test.enum literals with switch...OK\n    All 1 tests passed.\n\nShell\n\n### Inline Switch Prongs\n\nSwitch prongs can be marked as `inline` to generate the prong's body for each possible value it could have, making the captured value [comptime](#comptime).\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst expectError = std.testing.expectError;\n\nfn isFieldOptional(comptime T: type, field_index: usize) !bool {\n    const fields = @typeInfo(T).Struct.fields;\n    return switch (field_index) {\n        // This prong is analyzed twice with `idx` being a\n        // comptime-known value each time.\n        inline 0, 1 => |idx| @typeInfo(fields[idx].type) == .Optional,\n        else => return error.IndexOutOfBounds,\n    };\n}\n\nconst Struct1 = struct { a: u32, b: ?u32 };\n\ntest \"using @typeInfo with runtime values\" {\n    var index: usize = 0;\n    try expect(!try isFieldOptional(Struct1, index));\n    index += 1;\n    try expect(try isFieldOptional(Struct1, index));\n    index += 1;\n    try expectError(error.IndexOutOfBounds, isFieldOptional(Struct1, index));\n}\n\n// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent\n// of this function:\nfn isFieldOptionalUnrolled(field_index: usize) !bool {\n    return switch (field_index) {\n        0 => false,\n        1 => true,\n        else => return error.IndexOutOfBounds,\n    };\n}\n```\n\ntest_inline_switch.zig\n\n    $ zig test test_inline_switch.zig\n    1/1 test_inline_switch.test.using @typeInfo with runtime values...OK\n    All 1 tests passed.\n\nShell\n\nThe `inline` keyword may also be combined with ranges:\n\n``` zig\nfn isFieldOptional(comptime T: type, field_index: usize) !bool {\n    const fields = @typeInfo(T).Struct.fields;\n    return switch (field_index) {\n        inline 0...fields.len - 1 => |idx| @typeInfo(fields[idx].type) == .Optional,\n        else => return error.IndexOutOfBounds,\n    };\n}\n```\n\ninline_prong_range.zig\n\n`inline`` ``else` prongs can be used as a type safe alternative to `inline`` ``for` loops:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst SliceTypeA = extern struct {\n    len: usize,\n    ptr: [*]u32,\n};\nconst SliceTypeB = extern struct {\n    ptr: [*]SliceTypeA,\n    len: usize,\n};\nconst AnySlice = union(enum) {\n    a: SliceTypeA,\n    b: SliceTypeB,\n    c: []const u8,\n    d: []AnySlice,\n};\n\nfn withFor(any: AnySlice) usize {\n    const Tag = @typeInfo(AnySlice).Union.tag_type.?;\n    inline for (@typeInfo(Tag).Enum.fields) |field| {\n        // With `inline for` the function gets generated as\n        // a series of `if` statements relying on the optimizer\n        // to convert it to a switch.\n        if (field.value == @intFromEnum(any)) {\n            return @field(any, field.name).len;\n        }\n    }\n    // When using `inline for` the compiler doesn't know that every\n    // possible case has been handled requiring an explicit `unreachable`.\n    unreachable;\n}\n\nfn withSwitch(any: AnySlice) usize {\n    return switch (any) {\n        // With `inline else` the function is explicitly generated\n        // as the desired switch and the compiler can check that\n        // every possible case is handled.\n        inline else => |slice| slice.len,\n    };\n}\n\ntest \"inline for and inline else similarity\" {\n    const any = AnySlice{ .c = \"hello\" };\n    try expect(withFor(any) == 5);\n    try expect(withSwitch(any) == 5);\n}\n```\n\ntest_inline_else.zig\n\n    $ zig test test_inline_else.zig\n    1/1 test_inline_else.test.inline for and inline else similarity...OK\n    All 1 tests passed.\n\nShell\n\nWhen using an inline prong switching on an union an additional capture can be used to obtain the union's enum tag value.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst U = union(enum) {\n    a: u32,\n    b: f32,\n};\n\nfn getNum(u: U) u32 {\n    switch (u) {\n        // Here `num` is a runtime-known value that is either\n        // `u.a` or `u.b` and `tag` is `u`'s comptime-known tag value.\n        inline else => |num, tag| {\n            if (tag == .b) {\n                return @intFromFloat(num);\n            }\n            return num;\n        },\n    }\n}\n\ntest \"test\" {\n    const u = U{ .b = 42 };\n    try expect(getNum(u) == 42);\n}\n```\n\ntest_inline_switch_union_tag.zig\n\n    $ zig test test_inline_switch_union_tag.zig\n    1/1 test_inline_switch_union_tag.test.test...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [inline while](#inline-while)\n- [inline for](#inline-for)\n\n## while\n\nA while loop is used to repeatedly execute an expression until some condition is no longer true.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while basic\" {\n    var i: usize = 0;\n    while (i < 10) {\n        i += 1;\n    }\n    try expect(i == 10);\n}\n```\n\ntest_while.zig\n\n    $ zig test test_while.zig\n    1/1 test_while.test.while basic...OK\n    All 1 tests passed.\n\nShell\n\nUse `break` to exit a while loop early.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while break\" {\n    var i: usize = 0;\n    while (true) {\n        if (i == 10)\n            break;\n        i += 1;\n    }\n    try expect(i == 10);\n}\n```\n\ntest_while_break.zig\n\n    $ zig test test_while_break.zig\n    1/1 test_while_break.test.while break...OK\n    All 1 tests passed.\n\nShell\n\nUse `continue` to jump back to the beginning of the loop.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while continue\" {\n    var i: usize = 0;\n    while (true) {\n        i += 1;\n        if (i < 10)\n            continue;\n        break;\n    }\n    try expect(i == 10);\n}\n```\n\ntest_while_continue.zig\n\n    $ zig test test_while_continue.zig\n    1/1 test_while_continue.test.while continue...OK\n    All 1 tests passed.\n\nShell\n\nWhile loops support a continue expression which is executed when the loop is continued. The `continue` keyword respects this expression.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while loop continue expression\" {\n    var i: usize = 0;\n    while (i < 10) : (i += 1) {}\n    try expect(i == 10);\n}\n\ntest \"while loop continue expression, more complicated\" {\n    var i: usize = 1;\n    var j: usize = 1;\n    while (i * j < 2000) : ({\n        i *= 2;\n        j *= 3;\n    }) {\n        const my_ij = i * j;\n        try expect(my_ij < 2000);\n    }\n}\n```\n\ntest_while_continue_expression.zig\n\n    $ zig test test_while_continue_expression.zig\n    1/2 test_while_continue_expression.test.while loop continue expression...OK\n    2/2 test_while_continue_expression.test.while loop continue expression, more complicated...OK\n    All 2 tests passed.\n\nShell\n\nWhile loops are expressions. The result of the expression is the result of the `else` clause of a while loop, which is executed when the condition of the while loop is tested as false.\n\n`break`, like `return`, accepts a value parameter. This is the result of the `while` expression. When you `break` from a while loop, the `else` branch is not evaluated.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while else\" {\n    try expect(rangeHasNumber(0, 10, 5));\n    try expect(!rangeHasNumber(0, 10, 15));\n}\n\nfn rangeHasNumber(begin: usize, end: usize, number: usize) bool {\n    var i = begin;\n    return while (i < end) : (i += 1) {\n        if (i == number) {\n            break true;\n        }\n    } else false;\n}\n```\n\ntest_while_else.zig\n\n    $ zig test test_while_else.zig\n    1/1 test_while_else.test.while else...OK\n    All 1 tests passed.\n\nShell\n\n### Labeled while\n\nWhen a `while` loop is labeled, it can be referenced from a `break` or `continue` from within a nested loop:\n\n``` zig\ntest \"nested break\" {\n    outer: while (true) {\n        while (true) {\n            break :outer;\n        }\n    }\n}\n\ntest \"nested continue\" {\n    var i: usize = 0;\n    outer: while (i < 10) : (i += 1) {\n        while (true) {\n            continue :outer;\n        }\n    }\n}\n```\n\ntest_while_nested_break.zig\n\n    $ zig test test_while_nested_break.zig\n    1/2 test_while_nested_break.test.nested break...OK\n    2/2 test_while_nested_break.test.nested continue...OK\n    All 2 tests passed.\n\nShell\n\n### while with Optionals\n\nJust like [if](#if) expressions, while loops can take an optional as the condition and capture the payload. When [null](#null) is encountered the loop exits.\n\nWhen the `|x|` syntax is present on a `while` expression, the while condition must have an [Optional Type](#Optional-Type).\n\nThe `else` branch is allowed on optional iteration. In this case, it will be executed on the first null value encountered.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while null capture\" {\n    var sum1: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyNullSequence()) |value| {\n        sum1 += value;\n    }\n    try expect(sum1 == 3);\n\n    // null capture with an else block\n    var sum2: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyNullSequence()) |value| {\n        sum2 += value;\n    } else {\n        try expect(sum2 == 3);\n    }\n\n    // null capture with a continue expression\n    var i: u32 = 0;\n    var sum3: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyNullSequence()) |value| : (i += 1) {\n        sum3 += value;\n    }\n    try expect(i == 3);\n}\n\nvar numbers_left: u32 = undefined;\nfn eventuallyNullSequence() ?u32 {\n    return if (numbers_left == 0) null else blk: {\n        numbers_left -= 1;\n        break :blk numbers_left;\n    };\n}\n```\n\ntest_while_null_capture.zig\n\n    $ zig test test_while_null_capture.zig\n    1/1 test_while_null_capture.test.while null capture...OK\n    All 1 tests passed.\n\nShell\n\n### while with Error Unions\n\nJust like [if](#if) expressions, while loops can take an error union as the condition and capture the payload or the error code. When the condition results in an error code the else branch is evaluated and the loop is finished.\n\nWhen the `else`` |x|` syntax is present on a `while` expression, the while condition must have an [Error Union Type](#Error-Union-Type).\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"while error union capture\" {\n    var sum1: u32 = 0;\n    numbers_left = 3;\n    while (eventuallyErrorSequence()) |value| {\n        sum1 += value;\n    } else |err| {\n        try expect(err == error.ReachedZero);\n    }\n}\n\nvar numbers_left: u32 = undefined;\n\nfn eventuallyErrorSequence() anyerror!u32 {\n    return if (numbers_left == 0) error.ReachedZero else blk: {\n        numbers_left -= 1;\n        break :blk numbers_left;\n    };\n}\n```\n\ntest_while_error_capture.zig\n\n    $ zig test test_while_error_capture.zig\n    1/1 test_while_error_capture.test.while error union capture...OK\n    All 1 tests passed.\n\nShell\n\n### inline while\n\nWhile loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"inline while loop\" {\n    comptime var i = 0;\n    var sum: usize = 0;\n    inline while (i < 3) : (i += 1) {\n        const T = switch (i) {\n            0 => f32,\n            1 => i8,\n            2 => bool,\n            else => unreachable,\n        };\n        sum += typeNameLength(T);\n    }\n    try expect(sum == 9);\n}\n\nfn typeNameLength(comptime T: type) usize {\n    return @typeName(T).len;\n}\n```\n\ntest_inline_while.zig\n\n    $ zig test test_inline_while.zig\n    1/1 test_inline_while.test.inline while loop...OK\n    All 1 tests passed.\n\nShell\n\nIt is recommended to use `inline` loops only for one of these reasons:\n\n- You need the loop to execute at [comptime](#comptime) for the semantics to work.\n- You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.\n\nSee also:\n\n- [if](#if)\n- [Optionals](#Optionals)\n- [Errors](#Errors)\n- [comptime](#comptime)\n- [unreachable](#unreachable)\n\n## for\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"for basics\" {\n    const items = [_]i32{ 4, 5, 3, 4, 0 };\n    var sum: i32 = 0;\n\n    // For loops iterate over slices and arrays.\n    for (items) |value| {\n        // Break and continue are supported.\n        if (value == 0) {\n            continue;\n        }\n        sum += value;\n    }\n    try expect(sum == 16);\n\n    // To iterate over a portion of a slice, reslice.\n    for (items[0..1]) |value| {\n        sum += value;\n    }\n    try expect(sum == 20);\n\n    // To access the index of iteration, specify a second condition as well\n    // as a second capture value.\n    var sum2: i32 = 0;\n    for (items, 0..) |_, i| {\n        try expect(@TypeOf(i) == usize);\n        sum2 += @as(i32, @intCast(i));\n    }\n    try expect(sum2 == 10);\n\n    // To iterate over consecutive integers, use the range syntax.\n    // Unbounded range is always a compile error.\n    var sum3: usize = 0;\n    for (0..5) |i| {\n        sum3 += i;\n    }\n    try expect(sum3 == 10);\n}\n\ntest \"multi object for\" {\n    const items = [_]usize{ 1, 2, 3 };\n    const items2 = [_]usize{ 4, 5, 6 };\n    var count: usize = 0;\n\n    // Iterate over multiple objects.\n    // All lengths must be equal at the start of the loop, otherwise detectable\n    // illegal behavior occurs.\n    for (items, items2) |i, j| {\n        count += i + j;\n    }\n\n    try expect(count == 21);\n}\n\ntest \"for reference\" {\n    var items = [_]i32{ 3, 4, 2 };\n\n    // Iterate over the slice by reference by\n    // specifying that the capture value is a pointer.\n    for (&items) |*value| {\n        value.* += 1;\n    }\n\n    try expect(items[0] == 4);\n    try expect(items[1] == 5);\n    try expect(items[2] == 3);\n}\n\ntest \"for else\" {\n    // For allows an else attached to it, the same as a while loop.\n    const items = [_]?i32{ 3, 4, null, 5 };\n\n    // For loops can also be used as expressions.\n    // Similar to while loops, when you break from a for loop, the else branch is not evaluated.\n    var sum: i32 = 0;\n    const result = for (items) |value| {\n        if (value != null) {\n            sum += value.?;\n        }\n    } else blk: {\n        try expect(sum == 12);\n        break :blk sum;\n    };\n    try expect(result == 12);\n}\n```\n\ntest_for.zig\n\n    $ zig test test_for.zig\n    1/4 test_for.test.for basics...OK\n    2/4 test_for.test.multi object for...OK\n    3/4 test_for.test.for reference...OK\n    4/4 test_for.test.for else...OK\n    All 4 tests passed.\n\nShell\n\n### Labeled for\n\nWhen a `for` loop is labeled, it can be referenced from a `break` or `continue` from within a nested loop:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"nested break\" {\n    var count: usize = 0;\n    outer: for (1..6) |_| {\n        for (1..6) |_| {\n            count += 1;\n            break :outer;\n        }\n    }\n    try expect(count == 1);\n}\n\ntest \"nested continue\" {\n    var count: usize = 0;\n    outer: for (1..9) |_| {\n        for (1..6) |_| {\n            count += 1;\n            continue :outer;\n        }\n    }\n\n    try expect(count == 8);\n}\n```\n\ntest_for_nested_break.zig\n\n    $ zig test test_for_nested_break.zig\n    1/2 test_for_nested_break.test.nested break...OK\n    2/2 test_for_nested_break.test.nested continue...OK\n    All 2 tests passed.\n\nShell\n\n### inline for\n\nFor loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"inline for loop\" {\n    const nums = [_]i32{ 2, 4, 6 };\n    var sum: usize = 0;\n    inline for (nums) |i| {\n        const T = switch (i) {\n            2 => f32,\n            4 => i8,\n            6 => bool,\n            else => unreachable,\n        };\n        sum += typeNameLength(T);\n    }\n    try expect(sum == 9);\n}\n\nfn typeNameLength(comptime T: type) usize {\n    return @typeName(T).len;\n}\n```\n\ntest_inline_for.zig\n\n    $ zig test test_inline_for.zig\n    1/1 test_inline_for.test.inline for loop...OK\n    All 1 tests passed.\n\nShell\n\nIt is recommended to use `inline` loops only for one of these reasons:\n\n- You need the loop to execute at [comptime](#comptime) for the semantics to work.\n- You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.\n\nSee also:\n\n- [while](#while)\n- [comptime](#comptime)\n- [Arrays](#Arrays)\n- [Slices](#Slices)\n\n## if\n\n``` zig\n// If expressions have three uses, corresponding to the three types:\n// * bool\n// * ?T\n// * anyerror!T\n\nconst expect = @import(\"std\").testing.expect;\n\ntest \"if expression\" {\n    // If expressions are used instead of a ternary expression.\n    const a: u32 = 5;\n    const b: u32 = 4;\n    const result = if (a != b) 47 else 3089;\n    try expect(result == 47);\n}\n\ntest \"if boolean\" {\n    // If expressions test boolean conditions.\n    const a: u32 = 5;\n    const b: u32 = 4;\n    if (a != b) {\n        try expect(true);\n    } else if (a == 9) {\n        unreachable;\n    } else {\n        unreachable;\n    }\n}\n\ntest \"if error union\" {\n    // If expressions test for errors.\n    // Note the |err| capture on the else.\n\n    const a: anyerror!u32 = 0;\n    if (a) |value| {\n        try expect(value == 0);\n    } else |err| {\n        _ = err;\n        unreachable;\n    }\n\n    const b: anyerror!u32 = error.BadValue;\n    if (b) |value| {\n        _ = value;\n        unreachable;\n    } else |err| {\n        try expect(err == error.BadValue);\n    }\n\n    // The else and |err| capture is strictly required.\n    if (a) |value| {\n        try expect(value == 0);\n    } else |_| {}\n\n    // To check only the error value, use an empty block expression.\n    if (b) |_| {} else |err| {\n        try expect(err == error.BadValue);\n    }\n\n    // Access the value by reference using a pointer capture.\n    var c: anyerror!u32 = 3;\n    if (c) |*value| {\n        value.* = 9;\n    } else |_| {\n        unreachable;\n    }\n\n    if (c) |value| {\n        try expect(value == 9);\n    } else |_| {\n        unreachable;\n    }\n}\n```\n\ntest_if.zig\n\n    $ zig test test_if.zig\n    1/3 test_if.test.if expression...OK\n    2/3 test_if.test.if boolean...OK\n    3/3 test_if.test.if error union...OK\n    All 3 tests passed.\n\nShell\n\n### if with Optionals\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"if optional\" {\n    // If expressions test for null.\n\n    const a: ?u32 = 0;\n    if (a) |value| {\n        try expect(value == 0);\n    } else {\n        unreachable;\n    }\n\n    const b: ?u32 = null;\n    if (b) |_| {\n        unreachable;\n    } else {\n        try expect(true);\n    }\n\n    // The else is not required.\n    if (a) |value| {\n        try expect(value == 0);\n    }\n\n    // To test against null only, use the binary equality operator.\n    if (b == null) {\n        try expect(true);\n    }\n\n    // Access the value by reference using a pointer capture.\n    var c: ?u32 = 3;\n    if (c) |*value| {\n        value.* = 2;\n    }\n\n    if (c) |value| {\n        try expect(value == 2);\n    } else {\n        unreachable;\n    }\n}\n\ntest \"if error union with optional\" {\n    // If expressions test for errors before unwrapping optionals.\n    // The |optional_value| capture's type is ?u32.\n\n    const a: anyerror!?u32 = 0;\n    if (a) |optional_value| {\n        try expect(optional_value.? == 0);\n    } else |err| {\n        _ = err;\n        unreachable;\n    }\n\n    const b: anyerror!?u32 = null;\n    if (b) |optional_value| {\n        try expect(optional_value == null);\n    } else |_| {\n        unreachable;\n    }\n\n    const c: anyerror!?u32 = error.BadValue;\n    if (c) |optional_value| {\n        _ = optional_value;\n        unreachable;\n    } else |err| {\n        try expect(err == error.BadValue);\n    }\n\n    // Access the value by reference by using a pointer capture each time.\n    var d: anyerror!?u32 = 3;\n    if (d) |*optional_value| {\n        if (optional_value.*) |*value| {\n            value.* = 9;\n        }\n    } else |_| {\n        unreachable;\n    }\n\n    if (d) |optional_value| {\n        try expect(optional_value.? == 9);\n    } else |_| {\n        unreachable;\n    }\n}\n```\n\ntest_if_optionals.zig\n\n    $ zig test test_if_optionals.zig\n    1/2 test_if_optionals.test.if optional...OK\n    2/2 test_if_optionals.test.if error union with optional...OK\n    All 2 tests passed.\n\nShell\n\nSee also:\n\n- [Optionals](#Optionals)\n- [Errors](#Errors)\n\n## defer\n\nExecutes an expression unconditionally at scope exit.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst print = std.debug.print;\n\nfn deferExample() !usize {\n    var a: usize = 1;\n\n    {\n        defer a = 2;\n        a = 1;\n    }\n    try expect(a == 2);\n\n    a = 5;\n    return a;\n}\n\ntest \"defer basics\" {\n    try expect((try deferExample()) == 5);\n}\n```\n\ntest_defer.zig\n\n    $ zig test test_defer.zig\n    1/1 test_defer.test.defer basics...OK\n    All 1 tests passed.\n\nShell\n\nDefer expressions are evaluated in reverse order.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst print = std.debug.print;\n\ntest \"defer unwinding\" {\n    print(\"\\n\", .{});\n\n    defer {\n        print(\"1 \", .{});\n    }\n    defer {\n        print(\"2 \", .{});\n    }\n    if (false) {\n        // defers are not run if they are never executed.\n        defer {\n            print(\"3 \", .{});\n        }\n    }\n}\n```\n\ndefer_unwind.zig\n\n    $ zig test defer_unwind.zig\n    1/1 defer_unwind.test.defer unwinding...\n    2 1 OK\n    All 1 tests passed.\n\nShell\n\nInside a defer expression the return statement is not allowed.\n\n``` zig\nfn deferInvalidExample() !void {\n    defer {\n        return error.DeferError;\n    }\n\n    return error.DeferError;\n}\n```\n\ntest_invalid_defer.zig\n\n    $ zig test test_invalid_defer.zig\n    doc/langref/test_invalid_defer.zig:3:9: error: cannot return from defer expression\n            return error.DeferError;\n            ^~~~~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_invalid_defer.zig:2:5: note: defer expression here\n        defer {\n        ^~~~~\n\nShell\n\nSee also:\n\n- [Errors](#Errors)\n\n## unreachable\n\nIn [Debug](#Debug) and [ReleaseSafe](#ReleaseSafe) mode `unreachable` emits a call to `panic` with the message `reached unreachable code`.\n\nIn [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) mode, the optimizer uses the assumption that `unreachable` code will never be hit to perform optimizations.\n\n### Basics\n\n``` zig\n// unreachable is used to assert that control flow will never reach a\n// particular location:\ntest \"basic math\" {\n    const x = 1;\n    const y = 2;\n    if (x + y != 3) {\n        unreachable;\n    }\n}\n```\n\ntest_unreachable.zig\n\n    $ zig test test_unreachable.zig\n    1/1 test_unreachable.test.basic math...OK\n    All 1 tests passed.\n\nShell\n\nIn fact, this is how `std.debug.assert` is implemented:\n\n``` zig\n// This is how std.debug.assert is implemented\nfn assert(ok: bool) void {\n    if (!ok) unreachable; // assertion failure\n}\n\n// This test will fail because we hit unreachable.\ntest \"this will fail\" {\n    assert(false);\n}\n```\n\ntest_assertion_failure.zig\n\n    $ zig test test_assertion_failure.zig\n    1/1 test_assertion_failure.test.this will fail...thread 3571599 panic: reached unreachable code\n    /home/andy/src/zig/doc/langref/test_assertion_failure.zig:3:14: 0x103cd9d in assert (test)\n        if (!ok) unreachable; // assertion failure\n                 ^\n    /home/andy/src/zig/doc/langref/test_assertion_failure.zig:8:11: 0x103cd5a in test.this will fail (test)\n        assert(false);\n              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x10479a0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103dbbb in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d249 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cdb1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/a6b3ce5875a9e285c15739b2a1b30733/test\n\nShell\n\n### At Compile-Time\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\n\ntest \"type of unreachable\" {\n    comptime {\n        // The type of unreachable is noreturn.\n\n        // However this assertion will still fail to compile because\n        // unreachable expressions are compile errors.\n\n        assert(@TypeOf(unreachable) == noreturn);\n    }\n}\n```\n\ntest_comptime_unreachable.zig\n\n    $ zig test test_comptime_unreachable.zig\n    doc/langref/test_comptime_unreachable.zig:10:16: error: unreachable code\n            assert(@TypeOf(unreachable) == noreturn);\n                   ^~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_comptime_unreachable.zig:10:24: note: control flow is diverted here\n            assert(@TypeOf(unreachable) == noreturn);\n                           ^~~~~~~~~~~\n\nShell\n\nSee also:\n\n- [Zig Test](#Zig-Test)\n- [Build Mode](#Build-Mode)\n- [comptime](#comptime)\n\n## noreturn\n\n`noreturn` is the type of:\n\n- `break`\n- `continue`\n- `return`\n- `unreachable`\n- `while`` (``true``) {}`\n\nWhen resolving types together, such as `if` clauses or `switch` prongs, the `noreturn` type is compatible with every other type. Consider:\n\n``` zig\nfn foo(condition: bool, b: u32) void {\n    const a = if (condition) b else return;\n    _ = a;\n    @panic(\"do something with a\");\n}\ntest \"noreturn\" {\n    foo(false, 1);\n}\n```\n\ntest_noreturn.zig\n\n    $ zig test test_noreturn.zig\n    1/1 test_noreturn.test.noreturn...OK\n    All 1 tests passed.\n\nShell\n\nAnother use case for `noreturn` is the `exit` function:\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst native_arch = builtin.cpu.arch;\nconst expect = std.testing.expect;\n\nconst WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C;\nextern \"kernel32\" fn ExitProcess(exit_code: c_uint) callconv(WINAPI) noreturn;\n\ntest \"foo\" {\n    const value = bar() catch ExitProcess(1);\n    try expect(value == 1234);\n}\n\nfn bar() anyerror!u32 {\n    return 1234;\n}\n```\n\ntest_noreturn_from_exit.zig\n\n    $ zig test test_noreturn_from_exit.zig -target x86_64-windows --test-no-exec\n\nShell\n\n## Functions\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst native_arch = builtin.cpu.arch;\nconst expect = std.testing.expect;\n\n// Functions are declared like this\nfn add(a: i8, b: i8) i8 {\n    if (a == 0) {\n        return b;\n    }\n\n    return a + b;\n}\n\n// The export specifier makes a function externally visible in the generated\n// object file, and makes it use the C ABI.\nexport fn sub(a: i8, b: i8) i8 {\n    return a - b;\n}\n\n// The extern specifier is used to declare a function that will be resolved\n// at link time, when linking statically, or at runtime, when linking\n// dynamically. The quoted identifier after the extern keyword specifies\n// the library that has the function. (e.g. \"c\" -> libc.so)\n// The callconv specifier changes the calling convention of the function.\nconst WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C;\nextern \"kernel32\" fn ExitProcess(exit_code: u32) callconv(WINAPI) noreturn;\nextern \"c\" fn atan2(a: f64, b: f64) f64;\n\n// The @setCold builtin tells the optimizer that a function is rarely called.\nfn abort() noreturn {\n    @setCold(true);\n    while (true) {}\n}\n\n// The naked calling convention makes a function not have any function prologue or epilogue.\n// This can be useful when integrating with assembly.\nfn _start() callconv(.Naked) noreturn {\n    abort();\n}\n\n// The inline calling convention forces a function to be inlined at all call sites.\n// If the function cannot be inlined, it is a compile-time error.\ninline fn shiftLeftOne(a: u32) u32 {\n    return a << 1;\n}\n\n// The pub specifier allows the function to be visible when importing.\n// Another file can use @import and call sub2\npub fn sub2(a: i8, b: i8) i8 {\n    return a - b;\n}\n\n// Function pointers are prefixed with `*const `.\nconst Call2Op = *const fn (a: i8, b: i8) i8;\nfn doOp(fnCall: Call2Op, op1: i8, op2: i8) i8 {\n    return fnCall(op1, op2);\n}\n\ntest \"function\" {\n    try expect(doOp(add, 5, 6) == 11);\n    try expect(doOp(sub2, 5, 6) == -1);\n}\n```\n\ntest_functions.zig\n\n    $ zig test test_functions.zig\n    1/1 test_functions.test.function...OK\n    All 1 tests passed.\n\nShell\n\nThere is a difference between a function *body* and a function *pointer*. Function bodies are [comptime](#comptime)-only types while function [Pointers](#Pointers) may be runtime-known.\n\n### Pass-by-value Parameters\n\nPrimitive types such as [Integers](#Integers) and [Floats](#Floats) passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register.\n\nStructs, unions, and arrays can sometimes be more efficiently passed as a reference, since a copy could be arbitrarily expensive depending on the size. When these types are passed as parameters, Zig may choose to copy and pass by value, or pass by reference, whichever way Zig decides will be faster. This is made possible, in part, by the fact that parameters are immutable.\n\n``` zig\nconst Point = struct {\n    x: i32,\n    y: i32,\n};\n\nfn foo(point: Point) i32 {\n    // Here, `point` could be a reference, or a copy. The function body\n    // can ignore the difference and treat it as a value. Be very careful\n    // taking the address of the parameter - it should be treated as if\n    // the address will become invalid when the function returns.\n    return point.x + point.y;\n}\n\nconst expect = @import(\"std\").testing.expect;\n\ntest \"pass struct to function\" {\n    try expect(foo(Point{ .x = 1, .y = 2 }) == 3);\n}\n```\n\ntest_pass_by_reference_or_value.zig\n\n    $ zig test test_pass_by_reference_or_value.zig\n    1/1 test_pass_by_reference_or_value.test.pass struct to function...OK\n    All 1 tests passed.\n\nShell\n\nFor extern functions, Zig follows the C ABI for passing structs and unions by value.\n\n### Function Parameter Type Inference\n\nFunction parameters can be declared with `anytype` in place of the type. In this case the parameter types will be inferred when the function is called. Use [@TypeOf](#TypeOf) and [@typeInfo](#typeInfo) to get information about the inferred type.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nfn addFortyTwo(x: anytype) @TypeOf(x) {\n    return x + 42;\n}\n\ntest \"fn type inference\" {\n    try expect(addFortyTwo(1) == 43);\n    try expect(@TypeOf(addFortyTwo(1)) == comptime_int);\n    const y: i64 = 2;\n    try expect(addFortyTwo(y) == 44);\n    try expect(@TypeOf(addFortyTwo(y)) == i64);\n}\n```\n\ntest_fn_type_inference.zig\n\n    $ zig test test_fn_type_inference.zig\n    1/1 test_fn_type_inference.test.fn type inference...OK\n    All 1 tests passed.\n\nShell\n\n### inline fn\n\nAdding the `inline` keyword to a function definition makes that function become *semantically inlined* at the callsite. This is not a hint to be possibly observed by optimization passes, but has implications on the types and values involved in the function call.\n\nUnlike normal function calls, arguments at an inline function callsite which are compile-time known are treated as [Compile Time Parameters](#Compile-Time-Parameters). This can potentially propagate all the way to the return value:\n\n``` zig\ntest \"inline function call\" {\n    if (foo(1200, 34) != 1234) {\n        @compileError(\"bad\");\n    }\n}\n\ninline fn foo(a: i32, b: i32) i32 {\n    return a + b;\n}\n```\n\ninline_call.zig\n\n    $ zig test inline_call.zig\n    1/1 inline_call.test.inline function call...OK\n    All 1 tests passed.\n\nShell\n\nIf `inline` is removed, the test fails with the compile error instead of passing.\n\nIt is generally better to let the compiler decide when to inline a function, except for these scenarios:\n\n- To change how many stack frames are in the call stack, for debugging purposes.\n- To force comptime-ness of the arguments to propagate to the return value of the function, as in the above example.\n- Real world performance measurements demand it.\n\nNote that `inline` actually *restricts* what the compiler is allowed to do. This can harm binary size, compilation speed, and even runtime performance.\n\n### Function Reflection\n\n``` zig\nconst std = @import(\"std\");\nconst math = std.math;\nconst testing = std.testing;\n\ntest \"fn reflection\" {\n    try testing.expect(@typeInfo(@TypeOf(testing.expect)).Fn.params[0].type.? == bool);\n    try testing.expect(@typeInfo(@TypeOf(testing.tmpDir)).Fn.return_type.? == testing.TmpDir);\n\n    try testing.expect(@typeInfo(@TypeOf(math.Log2Int)).Fn.is_generic);\n}\n```\n\ntest_fn_reflection.zig\n\n    $ zig test test_fn_reflection.zig\n    1/1 test_fn_reflection.test.fn reflection...OK\n    All 1 tests passed.\n\nShell\n\n## Errors\n\n### Error Set Type\n\nAn error set is like an [enum](#enum). However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value.\n\nThe error set type defaults to a `u16`, though if the maximum number of distinct error values is provided via the --error-limit \\[num\\] command line parameter an integer type with the minimum number of bits required to represent all of the error values will be used.\n\nYou can [coerce](#Type-Coercion) an error from a subset to a superset:\n\n``` zig\nconst std = @import(\"std\");\n\nconst FileOpenError = error{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\nconst AllocationError = error{\n    OutOfMemory,\n};\n\ntest \"coerce subset to superset\" {\n    const err = foo(AllocationError.OutOfMemory);\n    try std.testing.expect(err == FileOpenError.OutOfMemory);\n}\n\nfn foo(err: AllocationError) FileOpenError {\n    return err;\n}\n```\n\ntest_coerce_error_subset_to_superset.zig\n\n    $ zig test test_coerce_error_subset_to_superset.zig\n    1/1 test_coerce_error_subset_to_superset.test.coerce subset to superset...OK\n    All 1 tests passed.\n\nShell\n\nBut you cannot [coerce](#Type-Coercion) an error from a superset to a subset:\n\n``` zig\nconst FileOpenError = error{\n    AccessDenied,\n    OutOfMemory,\n    FileNotFound,\n};\n\nconst AllocationError = error{\n    OutOfMemory,\n};\n\ntest \"coerce superset to subset\" {\n    foo(FileOpenError.OutOfMemory) catch {};\n}\n\nfn foo(err: FileOpenError) AllocationError {\n    return err;\n}\n```\n\ntest_coerce_error_superset_to_subset.zig\n\n    $ zig test test_coerce_error_superset_to_subset.zig\n    doc/langref/test_coerce_error_superset_to_subset.zig:16:12: error: expected type 'error{OutOfMemory}', found 'error{AccessDenied,OutOfMemory,FileNotFound}'\n        return err;\n               ^~~\n    doc/langref/test_coerce_error_superset_to_subset.zig:16:12: note: 'error.AccessDenied' not a member of destination error set\n    doc/langref/test_coerce_error_superset_to_subset.zig:16:12: note: 'error.FileNotFound' not a member of destination error set\n    doc/langref/test_coerce_error_superset_to_subset.zig:15:28: note: function return type declared here\n    fn foo(err: FileOpenError) AllocationError {\n                               ^~~~~~~~~~~~~~~\n    referenced by:\n        test.coerce superset to subset: doc/langref/test_coerce_error_superset_to_subset.zig:12:5\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\nThere is a shortcut for declaring an error set with only 1 value, and then getting that value:\n\n``` zig\nconst err = error.FileNotFound;\n```\n\nsingle_value_error_set_shortcut.zig\n\nThis is equivalent to:\n\n``` zig\nconst err = (error{FileNotFound}).FileNotFound;\n```\n\nsingle_value_error_set.zig\n\nThis becomes useful when using [Inferred Error Sets](#Inferred-Error-Sets).\n\n#### [The Global Error Set](#toc-The-Global-Error-Set)\n\n`anyerror` refers to the global error set. This is the error set that contains all errors in the entire compilation unit. It is a superset of all other error sets and a subset of none of them.\n\nYou can [coerce](#Type-Coercion) any error set to the global one, and you can explicitly cast an error of the global error set to a non-global one. This inserts a language-level assert to make sure the error value is in fact in the destination error set.\n\nThe global error set should generally be avoided because it prevents the compiler from knowing what errors are possible at compile-time. Knowing the error set at compile-time is better for generated documentation and helpful error messages, such as forgetting a possible error value in a [switch](#switch).\n\n### Error Union Type\n\nAn error set type and normal type can be combined with the `!` binary operator to form an error union type. You are likely to use an error union type more often than an error set type by itself.\n\nHere is a function to parse a string into a 64-bit integer:\n\n``` zig\nconst std = @import(\"std\");\nconst maxInt = std.math.maxInt;\n\npub fn parseU64(buf: []const u8, radix: u8) !u64 {\n    var x: u64 = 0;\n\n    for (buf) |c| {\n        const digit = charToDigit(c);\n\n        if (digit >= radix) {\n            return error.InvalidChar;\n        }\n\n        // x *= radix\n        var ov = @mulWithOverflow(x, radix);\n        if (ov[1] != 0) return error.OverFlow;\n\n        // x += digit\n        ov = @addWithOverflow(ov[0], digit);\n        if (ov[1] != 0) return error.OverFlow;\n        x = ov[0];\n    }\n\n    return x;\n}\n\nfn charToDigit(c: u8) u8 {\n    return switch (c) {\n        '0'...'9' => c - '0',\n        'A'...'Z' => c - 'A' + 10,\n        'a'...'z' => c - 'a' + 10,\n        else => maxInt(u8),\n    };\n}\n\ntest \"parse u64\" {\n    const result = try parseU64(\"1234\", 10);\n    try std.testing.expect(result == 1234);\n}\n```\n\nerror_union_parsing_u64.zig\n\n    $ zig test error_union_parsing_u64.zig\n    1/1 error_union_parsing_u64.test.parse u64...OK\n    All 1 tests passed.\n\nShell\n\nNotice the return type is `!``u64`. This means that the function either returns an unsigned 64 bit integer, or an error. We left off the error set to the left of the `!`, so the error set is inferred.\n\nWithin the function definition, you can see some return statements that return an error, and at the bottom a return statement that returns a `u64`. Both types [coerce](#Type-Coercion) to `anyerror``!``u64`.\n\nWhat it looks like to use this function varies depending on what you're trying to do. One of the following:\n\n- You want to provide a default value if it returned an error.\n- If it returned an error then you want to return the same error.\n- You know with complete certainty it will not return an error, so want to unconditionally unwrap it.\n- You want to take a different action for each possible error.\n\n#### [catch](#toc-catch)\n\nIf you want to provide a default value, you can use the `catch` binary operator:\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) void {\n    const number = parseU64(str, 10) catch 13;\n    _ = number; // ...\n}\n```\n\ncatch.zig\n\nIn this code, `number` will be equal to the successfully parsed string, or a default value of 13. The type of the right hand side of the binary `catch` operator must match the unwrapped error union type, or be of type `noreturn`.\n\nIf you want to provide a default value with `catch` after performing some logic, you can combine `catch` with named [Blocks](#Blocks):\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) void {\n    const number = parseU64(str, 10) catch blk: {\n        // do things\n        break :blk 13;\n    };\n    _ = number; // number is now initialized\n}\n```\n\nhandle_error_with_catch_block.zig.zig\n\n#### [try](#toc-try)\n\nLet's say you wanted to return the error if you got one, otherwise continue with the function logic:\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) !void {\n    const number = parseU64(str, 10) catch |err| return err;\n    _ = number; // ...\n}\n```\n\ncatch_err_return.zig\n\nThere is a shortcut for this. The `try` expression:\n\n``` zig\nconst parseU64 = @import(\"error_union_parsing_u64.zig\").parseU64;\n\nfn doAThing(str: []u8) !void {\n    const number = try parseU64(str, 10);\n    _ = number; // ...\n}\n```\n\ntry.zig\n\n`try` evaluates an error union expression. If it is an error, it returns from the current function with the same error. Otherwise, the expression results in the unwrapped value.\n\nMaybe you know with complete certainty that an expression will never be an error. In this case you can do this:\n\n`const`` number = parseU64(``\"1234\"``, ``10``) ``catch`` ``unreachable``;`\n\nHere we know for sure that \"1234\" will parse successfully. So we put the `unreachable` value on the right hand side. `unreachable` generates a panic in [Debug](#Debug) and [ReleaseSafe](#ReleaseSafe) modes and undefined behavior in [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) modes. So, while we're debugging the application, if there *was* a surprise error here, the application would crash appropriately.\n\nYou may want to take a different action for every situation. For that, we combine the [if](#if) and [switch](#switch) expression:\n\n``` zig\nfn doAThing(str: []u8) void {\n    if (parseU64(str, 10)) |number| {\n        doSomethingWithNumber(number);\n    } else |err| switch (err) {\n        error.Overflow => {\n            // handle overflow...\n        },\n        // we promise that InvalidChar won't happen (or crash in debug mode if it does)\n        error.InvalidChar => unreachable,\n    }\n}\n```\n\nhandle_all_error_scenarios.zig\n\nFinally, you may want to handle only some errors. For that, you can capture the unhandled errors in the `else` case, which now contains a narrower error set:\n\n``` zig\nfn doAnotherThing(str: []u8) error{InvalidChar}!void {\n    if (parseU64(str, 10)) |number| {\n        doSomethingWithNumber(number);\n    } else |err| switch (err) {\n        error.Overflow => {\n            // handle overflow...\n        },\n        else => |leftover_err| return leftover_err,\n    }\n}\n```\n\nhandle_some_error_scenarios.zig\n\nYou must use the variable capture syntax. If you don't need the variable, you can capture with `_` and avoid the `switch`.\n\n``` zig\nfn doADifferentThing(str: []u8) void {\n    if (parseU64(str, 10)) |number| {\n        doSomethingWithNumber(number);\n    } else |_| {\n        // do as you'd like\n    }\n}\n```\n\nhandle_no_error_scenarios.zig\n\n#### [errdefer](#toc-errdefer)\n\nThe other component to error handling is defer statements. In addition to an unconditional [defer](#defer), Zig has `errdefer`, which evaluates the deferred expression on block exit path if and only if the function returned with an error from the block.\n\nExample:\n\n``` zig\nfn createFoo(param: i32) !Foo {\n    const foo = try tryToAllocateFoo();\n    // now we have allocated foo. we need to free it if the function fails.\n    // but we want to return it if the function succeeds.\n    errdefer deallocateFoo(foo);\n\n    const tmp_buf = allocateTmpBuffer() orelse return error.OutOfMemory;\n    // tmp_buf is truly a temporary resource, and we for sure want to clean it up\n    // before this block leaves scope\n    defer deallocateTmpBuffer(tmp_buf);\n\n    if (param > 1337) return error.InvalidParam;\n\n    // here the errdefer will not run since we're returning success from the function.\n    // but the defer will run!\n    return foo;\n}\n```\n\nerrdefer_example.zig\n\nThe neat thing about this is that you get robust error handling without the verbosity and cognitive overhead of trying to make sure every exit path is covered. The deallocation code is always directly following the allocation code.\n\n#### [Common errdefer Slip-Ups](#toc-Common-errdefer-Slip-Ups)\n\nIt should be noted that `errdefer` statements only last until the end of the block they are written in, and therefore are not run if an error is returned outside of that block:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct {\n    data: u32,\n};\n\nfn tryToAllocateFoo(allocator: Allocator) !*Foo {\n    return allocator.create(Foo);\n}\n\nfn deallocateFoo(allocator: Allocator, foo: *Foo) void {\n    allocator.destroy(foo);\n}\n\nfn getFooData() !u32 {\n    return 666;\n}\n\nfn createFoo(allocator: Allocator, param: i32) !*Foo {\n    const foo = getFoo: {\n        var foo = try tryToAllocateFoo(allocator);\n        errdefer deallocateFoo(allocator, foo); // Only lasts until the end of getFoo\n\n        // Calls deallocateFoo on error\n        foo.data = try getFooData();\n\n        break :getFoo foo;\n    };\n\n    // Outside of the scope of the errdefer, so\n    // deallocateFoo will not be called here\n    if (param > 1337) return error.InvalidParam;\n\n    return foo;\n}\n\ntest \"createFoo\" {\n    try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));\n}\n```\n\ntest_errdefer_slip_ups.zig\n\n    $ zig test test_errdefer_slip_ups.zig\n    1/1 test_errdefer_slip_ups.test.createFoo...OK\n    [gpa] (err): memory address 0x7f11f521a000 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:9:28: 0x103d3cf in tryToAllocateFoo (test)\n        return allocator.create(Foo);\n                               ^\n    /home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:22:39: 0x103d5e5 in createFoo (test)\n            var foo = try tryToAllocateFoo(allocator);\n                                          ^\n    /home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:39:62: 0x103d82d in test.createFoo (test)\n        try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));\n                                                                 ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104d2a0 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x104340b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103f9f9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103f561 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    All 1 tests passed.\n    1 errors were logged.\n    1 tests leaked memory.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/58c079cb550addefaa354f72d736afd7/test\n\nShell\n\nTo ensure that `deallocateFoo` is properly called when returning an error, you must add an `errdefer` outside of the block:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct {\n    data: u32,\n};\n\nfn tryToAllocateFoo(allocator: Allocator) !*Foo {\n    return allocator.create(Foo);\n}\n\nfn deallocateFoo(allocator: Allocator, foo: *Foo) void {\n    allocator.destroy(foo);\n}\n\nfn getFooData() !u32 {\n    return 666;\n}\n\nfn createFoo(allocator: Allocator, param: i32) !*Foo {\n    const foo = getFoo: {\n        var foo = try tryToAllocateFoo(allocator);\n        errdefer deallocateFoo(allocator, foo);\n\n        foo.data = try getFooData();\n\n        break :getFoo foo;\n    };\n    // This lasts for the rest of the function\n    errdefer deallocateFoo(allocator, foo);\n\n    // Error is now properly handled by errdefer\n    if (param > 1337) return error.InvalidParam;\n\n    return foo;\n}\n\ntest \"createFoo\" {\n    try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));\n}\n```\n\ntest_errdefer_block.zig\n\n    $ zig test test_errdefer_block.zig\n    1/1 test_errdefer_block.test.createFoo...OK\n    All 1 tests passed.\n\nShell\n\nThe fact that errdefers only last for the block they are declared in is especially important when using loops:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct { data: *u32 };\n\nfn getData() !u32 {\n    return 666;\n}\n\nfn genFoos(allocator: Allocator, num: usize) ![]Foo {\n    const foos = try allocator.alloc(Foo, num);\n    errdefer allocator.free(foos);\n\n    for (foos, 0..) |*foo, i| {\n        foo.data = try allocator.create(u32);\n        // This errdefer does not last between iterations\n        errdefer allocator.destroy(foo.data);\n\n        // The data for the first 3 foos will be leaked\n        if (i >= 3) return error.TooManyFoos;\n\n        foo.data.* = try getData();\n    }\n\n    return foos;\n}\n\ntest \"genFoos\" {\n    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n}\n```\n\ntest_errdefer_loop_leak.zig\n\n    $ zig test test_errdefer_loop_leak.zig\n    1/1 test_errdefer_loop_leak.test.genFoos...OK\n    [gpa] (err): memory address 0x7f57c7578000 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)\n            foo.data = try allocator.create(u32);\n                                           ^\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)\n        try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n                                                              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    [gpa] (err): memory address 0x7f57c7578004 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)\n            foo.data = try allocator.create(u32);\n                                           ^\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)\n        try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n                                                              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    [gpa] (err): memory address 0x7f57c7578008 leaked:\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)\n            foo.data = try allocator.create(u32);\n                                           ^\n    /home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)\n        try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n                                                              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n\n    All 1 tests passed.\n    3 errors were logged.\n    1 tests leaked memory.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/29fcda275b7c426418534b679850fa2e/test\n\nShell\n\nSpecial care must be taken with code that allocates in a loop to make sure that no memory is leaked when returning an error:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst Foo = struct { data: *u32 };\n\nfn getData() !u32 {\n    return 666;\n}\n\nfn genFoos(allocator: Allocator, num: usize) ![]Foo {\n    const foos = try allocator.alloc(Foo, num);\n    errdefer allocator.free(foos);\n\n    // Used to track how many foos have been initialized\n    // (including their data being allocated)\n    var num_allocated: usize = 0;\n    errdefer for (foos[0..num_allocated]) |foo| {\n        allocator.destroy(foo.data);\n    };\n    for (foos, 0..) |*foo, i| {\n        foo.data = try allocator.create(u32);\n        num_allocated += 1;\n\n        if (i >= 3) return error.TooManyFoos;\n\n        foo.data.* = try getData();\n    }\n\n    return foos;\n}\n\ntest \"genFoos\" {\n    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));\n}\n```\n\ntest_errdefer_loop.zig\n\n    $ zig test test_errdefer_loop.zig\n    1/1 test_errdefer_loop.test.genFoos...OK\n    All 1 tests passed.\n\nShell\n\nA couple of other tidbits about error handling:\n\n- These primitives give enough expressiveness that it's completely practical to have failing to check for an error be a compile error. If you really want to ignore the error, you can add `catch`` ``unreachable` and get the added benefit of crashing in Debug and ReleaseSafe modes if your assumption was wrong.\n- Since Zig understands error types, it can pre-weight branches in favor of errors not occurring. Just a small optimization benefit that is not available in other languages.\n\nSee also:\n\n- [defer](#defer)\n- [if](#if)\n- [switch](#switch)\n\nAn error union is created with the `!` binary operator. You can use compile-time reflection to access the child type of an error union:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"error union\" {\n    var foo: anyerror!i32 = undefined;\n\n    // Coerce from child type of an error union:\n    foo = 1234;\n\n    // Coerce from an error set:\n    foo = error.SomeError;\n\n    // Use compile-time reflection to access the payload type of an error union:\n    try comptime expect(@typeInfo(@TypeOf(foo)).ErrorUnion.payload == i32);\n\n    // Use compile-time reflection to access the error set type of an error union:\n    try comptime expect(@typeInfo(@TypeOf(foo)).ErrorUnion.error_set == anyerror);\n}\n```\n\ntest_error_union.zig\n\n    $ zig test test_error_union.zig\n    1/1 test_error_union.test.error union...OK\n    All 1 tests passed.\n\nShell\n\n#### [Merging Error Sets](#toc-Merging-Error-Sets)\n\nUse the `||` operator to merge two error sets together. The resulting error set contains the errors of both error sets. Doc comments from the left-hand side override doc comments from the right-hand side. In this example, the doc comments for `C.PathNotFound` is `A doc comment`.\n\nThis is especially useful for functions which return different error sets depending on [comptime](#comptime) branches. For example, the Zig standard library uses `LinuxFileOpenError || WindowsFileOpenError` for the error set of opening files.\n\n``` zig\nconst A = error{\n    NotDir,\n\n    /// A doc comment\n    PathNotFound,\n};\nconst B = error{\n    OutOfMemory,\n\n    /// B doc comment\n    PathNotFound,\n};\n\nconst C = A || B;\n\nfn foo() C!void {\n    return error.NotDir;\n}\n\ntest \"merge error sets\" {\n    if (foo()) {\n        @panic(\"unexpected\");\n    } else |err| switch (err) {\n        error.OutOfMemory => @panic(\"unexpected\"),\n        error.PathNotFound => @panic(\"unexpected\"),\n        error.NotDir => {},\n    }\n}\n```\n\ntest_merging_error_sets.zig\n\n    $ zig test test_merging_error_sets.zig\n    1/1 test_merging_error_sets.test.merge error sets...OK\n    All 1 tests passed.\n\nShell\n\n#### [Inferred Error Sets](#toc-Inferred-Error-Sets)\n\nBecause many functions in Zig return a possible error, Zig supports inferring the error set. To infer the error set for a function, prepend the `!` operator to the function’s return type, like `!T`:\n\n``` zig\n// With an inferred error set\npub fn add_inferred(comptime T: type, a: T, b: T) !T {\n    const ov = @addWithOverflow(a, b);\n    if (ov[1] != 0) return error.Overflow;\n    return ov[0];\n}\n\n// With an explicit error set\npub fn add_explicit(comptime T: type, a: T, b: T) Error!T {\n    const ov = @addWithOverflow(a, b);\n    if (ov[1] != 0) return error.Overflow;\n    return ov[0];\n}\n\nconst Error = error{\n    Overflow,\n};\n\nconst std = @import(\"std\");\n\ntest \"inferred error set\" {\n    if (add_inferred(u8, 255, 1)) |_| unreachable else |err| switch (err) {\n        error.Overflow => {}, // ok\n    }\n}\n```\n\ntest_inferred_error_sets.zig\n\n    $ zig test test_inferred_error_sets.zig\n    1/1 test_inferred_error_sets.test.inferred error set...OK\n    All 1 tests passed.\n\nShell\n\nWhen a function has an inferred error set, that function becomes generic and thus it becomes trickier to do certain things with it, such as obtain a function pointer, or have an error set that is consistent across different build targets. Additionally, inferred error sets are incompatible with recursion.\n\nIn these situations, it is recommended to use an explicit error set. You can generally start with an empty error set and let compile errors guide you toward completing the set.\n\nThese limitations may be overcome in a future version of Zig.\n\n### Error Return Traces\n\nError Return Traces show all the points in the code that an error was returned to the calling function. This makes it practical to use [try](#try) everywhere and then still be able to know what happened if an error ends up bubbling all the way out of your application.\n\n``` zig\npub fn main() !void {\n    try foo(12);\n}\n\nfn foo(x: i32) !void {\n    if (x >= 5) {\n        try bar();\n    } else {\n        try bang2();\n    }\n}\n\nfn bar() !void {\n    if (baz()) {\n        try quux();\n    } else |err| switch (err) {\n        error.FileNotFound => try hello(),\n    }\n}\n\nfn baz() !void {\n    try bang1();\n}\n\nfn quux() !void {\n    try bang2();\n}\n\nfn hello() !void {\n    try bang2();\n}\n\nfn bang1() !void {\n    return error.FileNotFound;\n}\n\nfn bang2() !void {\n    return error.PermissionDenied;\n}\n```\n\nerror_return_trace.zig\n\n    $ zig build-exe error_return_trace.zig\n    $ ./error_return_trace\n    error: PermissionDenied\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:34:5: 0x1034e08 in bang1 (error_return_trace)\n        return error.FileNotFound;\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:22:5: 0x1034f13 in baz (error_return_trace)\n        try bang1();\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:38:5: 0x1034f38 in bang2 (error_return_trace)\n        return error.PermissionDenied;\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:30:5: 0x1034fa3 in hello (error_return_trace)\n        try bang2();\n        ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:17:31: 0x103505a in bar (error_return_trace)\n            error.FileNotFound => try hello(),\n                                  ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:7:9: 0x1035140 in foo (error_return_trace)\n            try bar();\n            ^\n    /home/andy/src/zig/doc/langref/error_return_trace.zig:2:5: 0x1035198 in main (error_return_trace)\n        try foo(12);\n        ^\n\nShell\n\nLook closely at this example. This is no stack trace.\n\nYou can see that the final error bubbled up was `PermissionDenied`, but the original error that started this whole thing was `FileNotFound`. In the `bar` function, the code handles the original error code, and then returns another one, from the switch statement. Error Return Traces make this clear, whereas a stack trace would look like this:\n\n``` zig\npub fn main() void {\n    foo(12);\n}\n\nfn foo(x: i32) void {\n    if (x >= 5) {\n        bar();\n    } else {\n        bang2();\n    }\n}\n\nfn bar() void {\n    if (baz()) {\n        quux();\n    } else {\n        hello();\n    }\n}\n\nfn baz() bool {\n    return bang1();\n}\n\nfn quux() void {\n    bang2();\n}\n\nfn hello() void {\n    bang2();\n}\n\nfn bang1() bool {\n    return false;\n}\n\nfn bang2() void {\n    @panic(\"PermissionDenied\");\n}\n```\n\nstack_trace.zig\n\n    $ zig build-exe stack_trace.zig\n    $ ./stack_trace\n    thread 3570764 panic: PermissionDenied\n    /home/andy/src/zig/doc/langref/stack_trace.zig:38:5: 0x1039320 in bang2 (stack_trace)\n        @panic(\"PermissionDenied\");\n        ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:30:10: 0x1068bd8 in hello (stack_trace)\n        bang2();\n             ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:17:14: 0x10392fc in bar (stack_trace)\n            hello();\n                 ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:7:12: 0x103721c in foo (stack_trace)\n            bar();\n               ^\n    /home/andy/src/zig/doc/langref/stack_trace.zig:2:8: 0x103519d in main (stack_trace)\n        foo(12);\n           ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (stack_trace)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (stack_trace)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nHere, the stack trace does not explain how the control flow in `bar` got to the `hello()` call. One would have to open a debugger or further instrument the application in order to find out. The error return trace, on the other hand, shows exactly how the error bubbled up.\n\nThis debugging feature makes it easier to iterate quickly on code that robustly handles all error conditions. This means that Zig developers will naturally find themselves writing correct, robust code in order to increase their development pace.\n\nError Return Traces are enabled by default in [Debug](#Debug) and [ReleaseSafe](#ReleaseSafe) builds and disabled by default in [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) builds.\n\nThere are a few ways to activate this error return tracing feature:\n\n- Return an error from main\n- An error makes its way to `catch`` ``unreachable` and you have not overridden the default panic handler\n- Use [errorReturnTrace](#errorReturnTrace) to access the current return trace. You can use `std.debug.dumpStackTrace` to print it. This function returns comptime-known [null](#null) when building without error return tracing support.\n\n#### [Implementation Details](#toc-Implementation-Details)\n\nTo analyze performance cost, there are two cases:\n\n- when no errors are returned\n- when returning errors\n\nFor the case when no errors are returned, the cost is a single memory write operation, only in the first non-failable function in the call graph that calls a failable function, i.e. when a function returning `void` calls a function returning `error`. This is to initialize this struct in the stack memory:\n\n``` zig\npub const StackTrace = struct {\n    index: usize,\n    instruction_addresses: [N]usize,\n};\n```\n\nstack_trace_struct.zig\n\nHere, N is the maximum function call depth as determined by call graph analysis. Recursion is ignored and counts for 2.\n\nA pointer to `StackTrace` is passed as a secret parameter to every function that can return an error, but it's always the first parameter, so it can likely sit in a register and stay there.\n\nThat's it for the path when no errors occur. It's practically free in terms of performance.\n\nWhen generating the code for a function that returns an error, just before the `return` statement (only for the `return` statements that return errors), Zig generates a call to this function:\n\n``` zig\n// marked as \"no-inline\" in LLVM IR\nfn __zig_return_error(stack_trace: *StackTrace) void {\n    stack_trace.instruction_addresses[stack_trace.index] = @returnAddress();\n    stack_trace.index = (stack_trace.index + 1) % N;\n}\n```\n\nzig_return_error_fn.zig\n\nThe cost is 2 math operations plus some memory reads and writes. The memory accessed is constrained and should remain cached for the duration of the error return bubbling.\n\nAs for code size cost, 1 function call before a return statement is no big deal. Even so, I have [a plan](https://github.com/ziglang/zig/issues/690) to make the call to `__zig_return_error` a tail call, which brings the code size cost down to actually zero. What is a return statement in code without error return tracing can become a jump instruction in code with error return tracing.\n\n## Optionals\n\nOne area that Zig provides safety without compromising efficiency or readability is with the optional type.\n\nThe question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this:\n\n``` zig\n// normal integer\nconst normal_int: i32 = 1234;\n\n// optional integer\nconst optional_int: ?i32 = 5678;\n```\n\noptional_integer.zig\n\nNow the variable `optional_int` could be an `i32`, or `null`.\n\nInstead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being [the worst mistake of computer science](https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/).\n\nZig does not have them.\n\nInstead, you can use an optional pointer. This secretly compiles down to a normal pointer, since we know we can use 0 as the null value for the optional type. But the compiler can check your work and make sure you don't assign null to something that can't be null.\n\nTypically the downside of not having null is that it makes the code more verbose to write. But, let's compare some equivalent C code and Zig code.\n\nTask: call malloc, if the result is null, return null.\n\nC code\n\n``` zig\n// malloc prototype included for reference\nvoid *malloc(size_t size);\n\nstruct Foo *do_a_thing(void) {\n    char *ptr = malloc(1234);\n    if (!ptr) return NULL;\n    // ...\n}\n```\n\ncall_malloc_in_c.c\n\nZig code\n\n``` zig\n// malloc prototype included for reference\nextern fn malloc(size: usize) ?[*]u8;\n\nfn doAThing() ?*Foo {\n    const ptr = malloc(1234) orelse return null;\n    _ = ptr; // ...\n}\n```\n\ncall_malloc_from_zig.zig\n\nHere, Zig is at least as convenient, if not more, than C. And, the type of \"ptr\" is `[*]``u8` *not* `?[*]``u8`. The `orelse` keyword unwrapped the optional type and therefore `ptr` is guaranteed to be non-null everywhere it is used in the function.\n\nThe other form of checking against NULL you might see looks like this:\n\n``` zig\nvoid do_a_thing(struct Foo *foo) {\n    // do some stuff\n\n    if (foo) {\n        do_something_with_foo(foo);\n    }\n\n    // do some stuff\n}\n```\n\nchecking_null_in_c.c\n\nIn Zig you can accomplish the same thing:\n\n``` zig\nconst Foo = struct {};\nfn doSomethingWithFoo(foo: *Foo) void {\n    _ = foo;\n}\n\nfn doAThing(optional_foo: ?*Foo) void {\n    // do some stuff\n\n    if (optional_foo) |foo| {\n        doSomethingWithFoo(foo);\n    }\n\n    // do some stuff\n}\n```\n\nchecking_null_in_zig.zig\n\nOnce again, the notable thing here is that inside the if block, `foo` is no longer an optional pointer, it is a pointer, which cannot be null.\n\nOne benefit to this is that functions which take pointers as arguments can be annotated with the \"nonnull\" attribute - `__attribute__((nonnull))` in [GCC](https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html). The optimizer can sometimes make better decisions knowing that pointer arguments cannot be null.\n\n### Optional Type\n\nAn optional is created by putting `?` in front of a type. You can use compile-time reflection to access the child type of an optional:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"optional type\" {\n    // Declare an optional and coerce from null:\n    var foo: ?i32 = null;\n\n    // Coerce from child type of an optional\n    foo = 1234;\n\n    // Use compile-time reflection to access the child type of the optional:\n    try comptime expect(@typeInfo(@TypeOf(foo)).Optional.child == i32);\n}\n```\n\ntest_optional_type.zig\n\n    $ zig test test_optional_type.zig\n    1/1 test_optional_type.test.optional type...OK\n    All 1 tests passed.\n\nShell\n\n### null\n\nJust like [undefined](#undefined), `null` has its own type, and the only way to use it is to cast it to a different type:\n\n``` zig\nconst optional_value: ?i32 = null;\n```\n\nnull.zig\n\n### Optional Pointers\n\nAn optional pointer is guaranteed to be the same size as a pointer. The `null` of the optional is guaranteed to be address 0.\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"optional pointers\" {\n    // Pointers cannot be null. If you want a null pointer, use the optional\n    // prefix `?` to make the pointer type optional.\n    var ptr: ?*i32 = null;\n\n    var x: i32 = 1;\n    ptr = &x;\n\n    try expect(ptr.?.* == 1);\n\n    // Optional pointers are the same size as normal pointers, because pointer\n    // value 0 is used as the null value.\n    try expect(@sizeOf(?*i32) == @sizeOf(*i32));\n}\n```\n\ntest_optional_pointer.zig\n\n    $ zig test test_optional_pointer.zig\n    1/1 test_optional_pointer.test.optional pointers...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [while with Optionals](#while-with-Optionals)\n- [if with Optionals](#if-with-Optionals)\n\n## Casting\n\nA **type cast** converts a value of one type to another. Zig has [Type Coercion](#Type-Coercion) for conversions that are known to be completely safe and unambiguous, and [Explicit Casts](#Explicit-Casts) for conversions that one would not want to happen on accident. There is also a third kind of type conversion called [Peer Type Resolution](#Peer-Type-Resolution) for the case when a result type must be decided given multiple operand types.\n\n### Type Coercion\n\nType coercion occurs when one type is expected, but different type is provided:\n\n``` zig\ntest \"type coercion - variable declaration\" {\n    const a: u8 = 1;\n    const b: u16 = a;\n    _ = b;\n}\n\ntest \"type coercion - function call\" {\n    const a: u8 = 1;\n    foo(a);\n}\n\nfn foo(b: u16) void {\n    _ = b;\n}\n\ntest \"type coercion - @as builtin\" {\n    const a: u8 = 1;\n    const b = @as(u16, a);\n    _ = b;\n}\n```\n\ntest_type_coercion.zig\n\n    $ zig test test_type_coercion.zig\n    1/3 test_type_coercion.test.type coercion - variable declaration...OK\n    2/3 test_type_coercion.test.type coercion - function call...OK\n    3/3 test_type_coercion.test.type coercion - @as builtin...OK\n    All 3 tests passed.\n\nShell\n\nType coercions are only allowed when it is completely unambiguous how to get from one type to another, and the transformation is guaranteed to be safe. There is one exception, which is [C Pointers](#C-Pointers).\n\n#### [Type Coercion: Stricter Qualification](#toc-Type-Coercion-Stricter-Qualification)\n\nValues which have the same representation at runtime can be cast to increase the strictness of the qualifiers, no matter how nested the qualifiers are:\n\n- `const` - non-const to const is allowed\n- `volatile` - non-volatile to volatile is allowed\n- `align` - bigger to smaller alignment is allowed\n- [error sets](#Error-Set-Type) to supersets is allowed\n\nThese casts are no-ops at runtime since the value representation does not change.\n\n``` zig\ntest \"type coercion - const qualification\" {\n    var a: i32 = 1;\n    const b: *i32 = &a;\n    foo(b);\n}\n\nfn foo(_: *const i32) void {}\n```\n\ntest_no_op_casts.zig\n\n    $ zig test test_no_op_casts.zig\n    1/1 test_no_op_casts.test.type coercion - const qualification...OK\n    All 1 tests passed.\n\nShell\n\nIn addition, pointers coerce to const optional pointers:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\n\ntest \"cast *[1][*]const u8 to [*]const ?[*]const u8\" {\n    const window_name = [1][*]const u8{\"window name\"};\n    const x: [*]const ?[*]const u8 = &window_name;\n    try expect(mem.eql(u8, std.mem.sliceTo(@as([*:0]const u8, @ptrCast(x[0].?)), 0), \"window name\"));\n}\n```\n\ntest_pointer_coerce_const_optional.zig\n\n    $ zig test test_pointer_coerce_const_optional.zig\n    1/1 test_pointer_coerce_const_optional.test.cast *[1][*]const u8 to [*]const ?[*]const u8...OK\n    All 1 tests passed.\n\nShell\n\n#### [Type Coercion: Integer and Float Widening](#toc-Type-Coercion-Integer-and-Float-Widening)\n\n[Integers](#Integers) coerce to integer types which can represent every value of the old type, and likewise [Floats](#Floats) coerce to float types which can represent every value of the old type.\n\n``` zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\n\ntest \"integer widening\" {\n    const a: u8 = 250;\n    const b: u16 = a;\n    const c: u32 = b;\n    const d: u64 = c;\n    const e: u64 = d;\n    const f: u128 = e;\n    try expect(f == a);\n}\n\ntest \"implicit unsigned integer to signed integer\" {\n    const a: u8 = 250;\n    const b: i16 = a;\n    try expect(b == 250);\n}\n\ntest \"float widening\" {\n    const a: f16 = 12.34;\n    const b: f32 = a;\n    const c: f64 = b;\n    const d: f128 = c;\n    try expect(d == a);\n}\n```\n\ntest_integer_widening.zig\n\n    $ zig test test_integer_widening.zig\n    1/3 test_integer_widening.test.integer widening...OK\n    2/3 test_integer_widening.test.implicit unsigned integer to signed integer...OK\n    3/3 test_integer_widening.test.float widening...OK\n    All 3 tests passed.\n\nShell\n\n#### [Type Coercion: Float to Int](#toc-Type-Coercion-Float-to-Int)\n\nA compiler error is appropriate because this ambiguous expression leaves the compiler two choices about the coercion.\n\n- Cast `54.0` to `comptime_int` resulting in `@as``(``comptime_int``, ``10``)`, which is casted to `@as``(``f32``, ``10``)`\n- Cast `5` to `comptime_float` resulting in `@as``(``comptime_float``, ``10.8``)`, which is casted to `@as``(``f32``, ``10.8``)`\n\n``` zig\n// Compile time coercion of float to int\ntest \"implicit cast to comptime_int\" {\n    const f: f32 = 54.0 / 5;\n    _ = f;\n}\n```\n\ntest_ambiguous_coercion.zig\n\n    $ zig test test_ambiguous_coercion.zig\n    doc/langref/test_ambiguous_coercion.zig:3:25: error: ambiguous coercion of division operands 'comptime_float' and 'comptime_int'; non-zero remainder '4'\n        const f: f32 = 54.0 / 5;\n                       ~~~~~^~~\n\nShell\n\n#### [Type Coercion: Slices, Arrays and Pointers](#toc-Type-Coercion-Slices-Arrays-and-Pointers)\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\n// You can assign constant pointers to arrays to a slice with\n// const modifier on the element type. Useful in particular for\n// String literals.\ntest \"*const [N]T to []const T\" {\n    const x1: []const u8 = \"hello\";\n    const x2: []const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };\n    try expect(std.mem.eql(u8, x1, x2));\n\n    const y: []const f32 = &[2]f32{ 1.2, 3.4 };\n    try expect(y[0] == 1.2);\n}\n\n// Likewise, it works when the destination type is an error union.\ntest \"*const [N]T to E![]const T\" {\n    const x1: anyerror![]const u8 = \"hello\";\n    const x2: anyerror![]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };\n    try expect(std.mem.eql(u8, try x1, try x2));\n\n    const y: anyerror![]const f32 = &[2]f32{ 1.2, 3.4 };\n    try expect((try y)[0] == 1.2);\n}\n\n// Likewise, it works when the destination type is an optional.\ntest \"*const [N]T to ?[]const T\" {\n    const x1: ?[]const u8 = \"hello\";\n    const x2: ?[]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };\n    try expect(std.mem.eql(u8, x1.?, x2.?));\n\n    const y: ?[]const f32 = &[2]f32{ 1.2, 3.4 };\n    try expect(y.?[0] == 1.2);\n}\n\n// In this cast, the array length becomes the slice length.\ntest \"*[N]T to []T\" {\n    var buf: [5]u8 = \"hello\".*;\n    const x: []u8 = &buf;\n    try expect(std.mem.eql(u8, x, \"hello\"));\n\n    const buf2 = [2]f32{ 1.2, 3.4 };\n    const x2: []const f32 = &buf2;\n    try expect(std.mem.eql(f32, x2, &[2]f32{ 1.2, 3.4 }));\n}\n\n// Single-item pointers to arrays can be coerced to many-item pointers.\ntest \"*[N]T to [*]T\" {\n    var buf: [5]u8 = \"hello\".*;\n    const x: [*]u8 = &buf;\n    try expect(x[4] == 'o');\n    // x[5] would be an uncaught out of bounds pointer dereference!\n}\n\n// Likewise, it works when the destination type is an optional.\ntest \"*[N]T to ?[*]T\" {\n    var buf: [5]u8 = \"hello\".*;\n    const x: ?[*]u8 = &buf;\n    try expect(x.?[4] == 'o');\n}\n\n// Single-item pointers can be cast to len-1 single-item arrays.\ntest \"*T to *[1]T\" {\n    var x: i32 = 1234;\n    const y: *[1]i32 = &x;\n    const z: [*]i32 = y;\n    try expect(z[0] == 1234);\n}\n```\n\ntest_coerce_slices_arrays_and_pointers.zig\n\n    $ zig test test_coerce_slices_arrays_and_pointers.zig\n    1/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to []const T...OK\n    2/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to E![]const T...OK\n    3/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to ?[]const T...OK\n    4/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to []T...OK\n    5/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to [*]T...OK\n    6/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to ?[*]T...OK\n    7/7 test_coerce_slices_arrays_and_pointers.test.*T to *[1]T...OK\n    All 7 tests passed.\n\nShell\n\nSee also:\n\n- [C Pointers](#C-Pointers)\n\n#### [Type Coercion: Optionals](#toc-Type-Coercion-Optionals)\n\nThe payload type of [Optionals](#Optionals), as well as [null](#null), coerce to the optional type.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coerce to optionals\" {\n    const x: ?i32 = 1234;\n    const y: ?i32 = null;\n\n    try expect(x.? == 1234);\n    try expect(y == null);\n}\n```\n\ntest_coerce_optionals.zig\n\n    $ zig test test_coerce_optionals.zig\n    1/1 test_coerce_optionals.test.coerce to optionals...OK\n    All 1 tests passed.\n\nShell\n\nOptionals work nested inside the [Error Union Type](#Error-Union-Type), too:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coerce to optionals wrapped in error union\" {\n    const x: anyerror!?i32 = 1234;\n    const y: anyerror!?i32 = null;\n\n    try expect((try x).? == 1234);\n    try expect((try y) == null);\n}\n```\n\ntest_coerce_optional_wrapped_error_union.zig\n\n    $ zig test test_coerce_optional_wrapped_error_union.zig\n    1/1 test_coerce_optional_wrapped_error_union.test.coerce to optionals wrapped in error union...OK\n    All 1 tests passed.\n\nShell\n\n#### [Type Coercion: Error Unions](#toc-Type-Coercion-Error-Unions)\n\nThe payload type of an [Error Union Type](#Error-Union-Type) as well as the [Error Set Type](#Error-Set-Type) coerce to the error union type:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coercion to error unions\" {\n    const x: anyerror!i32 = 1234;\n    const y: anyerror!i32 = error.Failure;\n\n    try expect((try x) == 1234);\n    try std.testing.expectError(error.Failure, y);\n}\n```\n\ntest_coerce_to_error_union.zig\n\n    $ zig test test_coerce_to_error_union.zig\n    1/1 test_coerce_to_error_union.test.coercion to error unions...OK\n    All 1 tests passed.\n\nShell\n\n#### [Type Coercion: Compile-Time Known Numbers](#toc-Type-Coercion-Compile-Time-Known-Numbers)\n\nWhen a number is [comptime](#comptime)-known to be representable in the destination type, it may be coerced:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"coercing large integer type to smaller one when value is comptime-known to fit\" {\n    const x: u64 = 255;\n    const y: u8 = x;\n    try expect(y == 255);\n}\n```\n\ntest_coerce_large_to_small.zig\n\n    $ zig test test_coerce_large_to_small.zig\n    1/1 test_coerce_large_to_small.test.coercing large integer type to smaller one when value is comptime-known to fit...OK\n    All 1 tests passed.\n\nShell\n\n#### [Type Coercion: Unions and Enums](#toc-Type-Coercion-Unions-and-Enums)\n\nTagged unions can be coerced to enums, and enums can be coerced to tagged unions when they are [comptime](#comptime)-known to be a field of the union that has only one possible value, such as [void](#void):\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst E = enum {\n    one,\n    two,\n    three,\n};\n\nconst U = union(E) {\n    one: i32,\n    two: f32,\n    three,\n};\n\nconst U2 = union(enum) {\n    a: void,\n    b: f32,\n\n    fn tag(self: U2) usize {\n        switch (self) {\n            .a => return 1,\n            .b => return 2,\n        }\n    }\n};\n\ntest \"coercion between unions and enums\" {\n    const u = U{ .two = 12.34 };\n    const e: E = u; // coerce union to enum\n    try expect(e == E.two);\n\n    const three = E.three;\n    const u_2: U = three; // coerce enum to union\n    try expect(u_2 == E.three);\n\n    const u_3: U = .three; // coerce enum literal to union\n    try expect(u_3 == E.three);\n\n    const u_4: U2 = .a; // coerce enum literal to union with inferred enum tag type.\n    try expect(u_4.tag() == 1);\n\n    // The following example is invalid.\n    // error: coercion from enum '@TypeOf(.enum_literal)' to union 'test_coerce_unions_enum.U2' must initialize 'f32' field 'b'\n    //var u_5: U2 = .b;\n    //try expect(u_5.tag() == 2);\n}\n```\n\ntest_coerce_unions_enums.zig\n\n    $ zig test test_coerce_unions_enums.zig\n    1/1 test_coerce_unions_enums.test.coercion between unions and enums...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [union](#union)\n- [enum](#enum)\n\n#### [Type Coercion: undefined](#toc-Type-Coercion-undefined)\n\n[undefined](#undefined) can be coerced to any type.\n\n#### [Type Coercion: Tuples to Arrays](#toc-Type-Coercion-Tuples-to-Arrays)\n\n[Tuples](#Tuples) can be coerced to arrays, if all of the fields have the same type.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Tuple = struct { u8, u8 };\ntest \"coercion from homogenous tuple to array\" {\n    const tuple: Tuple = .{ 5, 6 };\n    const array: [2]u8 = tuple;\n    _ = array;\n}\n```\n\ntest_coerce_tuples_arrays.zig\n\n    $ zig test test_coerce_tuples_arrays.zig\n    1/1 test_coerce_tuples_arrays.test.coercion from homogenous tuple to array...OK\n    All 1 tests passed.\n\nShell\n\n### Explicit Casts\n\nExplicit casts are performed via [Builtin Functions](#Builtin-Functions). Some explicit casts are safe; some are not. Some explicit casts perform language-level assertions; some do not. Some explicit casts are no-ops at runtime; some are not.\n\n- [@bitCast](#bitCast) - change type but maintain bit representation\n- [@alignCast](#alignCast) - make a pointer have more alignment\n- [@enumFromInt](#enumFromInt) - obtain an enum value based on its integer tag value\n- [@errorFromInt](#errorFromInt) - obtain an error code based on its integer value\n- [@errorCast](#errorCast) - convert to a smaller error set\n- [@floatCast](#floatCast) - convert a larger float to a smaller float\n- [@floatFromInt](#floatFromInt) - convert an integer to a float value\n- [@intCast](#intCast) - convert between integer types\n- [@intFromBool](#intFromBool) - convert true to 1 and false to 0\n- [@intFromEnum](#intFromEnum) - obtain the integer tag value of an enum or tagged union\n- [@intFromError](#intFromError) - obtain the integer value of an error code\n- [@intFromFloat](#intFromFloat) - obtain the integer part of a float value\n- [@intFromPtr](#intFromPtr) - obtain the address of a pointer\n- [@ptrFromInt](#ptrFromInt) - convert an address to a pointer\n- [@ptrCast](#ptrCast) - convert between pointer types\n- [@truncate](#truncate) - convert between integer types, chopping off bits\n\n### Peer Type Resolution\n\nPeer Type Resolution occurs in these places:\n\n- [switch](#switch) expressions\n- [if](#if) expressions\n- [while](#while) expressions\n- [for](#for) expressions\n- Multiple break statements in a block\n- Some [binary operations](#Table-of-Operators)\n\nThis kind of type resolution chooses a type that all peer types can coerce into. Here are some examples:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst mem = std.mem;\n\ntest \"peer resolve int widening\" {\n    const a: i8 = 12;\n    const b: i16 = 34;\n    const c = a + b;\n    try expect(c == 46);\n    try expect(@TypeOf(c) == i16);\n}\n\ntest \"peer resolve arrays of different size to const slice\" {\n    try expect(mem.eql(u8, boolToStr(true), \"true\"));\n    try expect(mem.eql(u8, boolToStr(false), \"false\"));\n    try comptime expect(mem.eql(u8, boolToStr(true), \"true\"));\n    try comptime expect(mem.eql(u8, boolToStr(false), \"false\"));\n}\nfn boolToStr(b: bool) []const u8 {\n    return if (b) \"true\" else \"false\";\n}\n\ntest \"peer resolve array and const slice\" {\n    try testPeerResolveArrayConstSlice(true);\n    try comptime testPeerResolveArrayConstSlice(true);\n}\nfn testPeerResolveArrayConstSlice(b: bool) !void {\n    const value1 = if (b) \"aoeu\" else @as([]const u8, \"zz\");\n    const value2 = if (b) @as([]const u8, \"zz\") else \"aoeu\";\n    try expect(mem.eql(u8, value1, \"aoeu\"));\n    try expect(mem.eql(u8, value2, \"zz\"));\n}\n\ntest \"peer type resolution: ?T and T\" {\n    try expect(peerTypeTAndOptionalT(true, false).? == 0);\n    try expect(peerTypeTAndOptionalT(false, false).? == 3);\n    comptime {\n        try expect(peerTypeTAndOptionalT(true, false).? == 0);\n        try expect(peerTypeTAndOptionalT(false, false).? == 3);\n    }\n}\nfn peerTypeTAndOptionalT(c: bool, b: bool) ?usize {\n    if (c) {\n        return if (b) null else @as(usize, 0);\n    }\n\n    return @as(usize, 3);\n}\n\ntest \"peer type resolution: *[0]u8 and []const u8\" {\n    try expect(peerTypeEmptyArrayAndSlice(true, \"hi\").len == 0);\n    try expect(peerTypeEmptyArrayAndSlice(false, \"hi\").len == 1);\n    comptime {\n        try expect(peerTypeEmptyArrayAndSlice(true, \"hi\").len == 0);\n        try expect(peerTypeEmptyArrayAndSlice(false, \"hi\").len == 1);\n    }\n}\nfn peerTypeEmptyArrayAndSlice(a: bool, slice: []const u8) []const u8 {\n    if (a) {\n        return &[_]u8{};\n    }\n\n    return slice[0..1];\n}\ntest \"peer type resolution: *[0]u8, []const u8, and anyerror![]u8\" {\n    {\n        var data = \"hi\".*;\n        const slice = data[0..];\n        try expect((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);\n        try expect((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);\n    }\n    comptime {\n        var data = \"hi\".*;\n        const slice = data[0..];\n        try expect((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);\n        try expect((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);\n    }\n}\nfn peerTypeEmptyArrayAndSliceAndError(a: bool, slice: []u8) anyerror![]u8 {\n    if (a) {\n        return &[_]u8{};\n    }\n\n    return slice[0..1];\n}\n\ntest \"peer type resolution: *const T and ?*T\" {\n    const a: *const usize = @ptrFromInt(0x123456780);\n    const b: ?*usize = @ptrFromInt(0x123456780);\n    try expect(a == b);\n    try expect(b == a);\n}\n\ntest \"peer type resolution: error union switch\" {\n    // The non-error and error cases are only peers if the error case is just a switch expression;\n    // the pattern `if (x) {...} else |err| blk: { switch (err) {...} }` does not consider the\n    // non-error and error case to be peers.\n    var a: error{ A, B, C }!u32 = 0;\n    _ = &a;\n    const b = if (a) |x|\n        x + 3\n    else |err| switch (err) {\n        error.A => 0,\n        error.B => 1,\n        error.C => null,\n    };\n    try expect(@TypeOf(b) == ?u32);\n\n    // The non-error and error cases are only peers if the error case is just a switch expression;\n    // the pattern `x catch |err| blk: { switch (err) {...} }` does not consider the unwrapped `x`\n    // and error case to be peers.\n    const c = a catch |err| switch (err) {\n        error.A => 0,\n        error.B => 1,\n        error.C => null,\n    };\n    try expect(@TypeOf(c) == ?u32);\n}\n```\n\ntest_peer_type_resolution.zig\n\n    $ zig test test_peer_type_resolution.zig\n    1/8 test_peer_type_resolution.test.peer resolve int widening...OK\n    2/8 test_peer_type_resolution.test.peer resolve arrays of different size to const slice...OK\n    3/8 test_peer_type_resolution.test.peer resolve array and const slice...OK\n    4/8 test_peer_type_resolution.test.peer type resolution: ?T and T...OK\n    5/8 test_peer_type_resolution.test.peer type resolution: *[0]u8 and []const u8...OK\n    6/8 test_peer_type_resolution.test.peer type resolution: *[0]u8, []const u8, and anyerror![]u8...OK\n    7/8 test_peer_type_resolution.test.peer type resolution: *const T and ?*T...OK\n    8/8 test_peer_type_resolution.test.peer type resolution: error union switch...OK\n    All 8 tests passed.\n\nShell\n\n## Zero Bit Types\n\nFor some types, [@sizeOf](#sizeOf) is 0:\n\n- [void](#void)\n- The [Integers](#Integers) `u0` and `i0`.\n- [Arrays](#Arrays) and [Vectors](#Vectors) with len 0, or with an element type that is a zero bit type.\n- An [enum](#enum) with only 1 tag.\n- A [struct](#struct) with all fields being zero bit types.\n- A [union](#union) with only 1 field which is a zero bit type.\n\nThese types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code:\n\n``` zig\nexport fn entry() void {\n    var x: void = {};\n    var y: void = {};\n    x = y;\n    y = x;\n}\n```\n\nzero_bit_types.zig\n\nWhen this turns into machine code, there is no code generated in the body of `entry`, even in [Debug](#Debug) mode. For example, on x86_64:\n\n``` zig\n0000000000000010 <entry>:\n  10:   55                      push   %rbp\n  11:   48 89 e5                mov    %rsp,%rbp\n  14:   5d                      pop    %rbp\n  15:   c3                      retq   \n```\n\nThese assembly instructions do not have any code associated with the void values - they only perform the function call prologue and epilogue.\n\n### void\n\n`void` can be useful for instantiating generic types. For example, given a `Map(Key, Value)`, one can pass `void` for the `Value` type to make it into a `Set`:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"turn HashMap into a set with void\" {\n    var map = std.AutoHashMap(i32, void).init(std.testing.allocator);\n    defer map.deinit();\n\n    try map.put(1, {});\n    try map.put(2, {});\n\n    try expect(map.contains(2));\n    try expect(!map.contains(3));\n\n    _ = map.remove(2);\n    try expect(!map.contains(2));\n}\n```\n\ntest_void_in_hashmap.zig\n\n    $ zig test test_void_in_hashmap.zig\n    1/1 test_void_in_hashmap.test.turn HashMap into a set with void...OK\n    All 1 tests passed.\n\nShell\n\nNote that this is different from using a dummy value for the hash map value. By using `void` as the type of the value, the hash map entry type has no value field, and thus the hash map takes up less space. Further, all the code that deals with storing and loading the value is deleted, as seen above.\n\n`void` is distinct from `anyopaque`. `void` has a known size of 0 bytes, and `anyopaque` has an unknown, but non-zero, size.\n\nExpressions of type `void` are the only ones whose value can be ignored. For example, ignoring a non-`void` expression is a compile error:\n\n``` zig\ntest \"ignoring expression value\" {\n    foo();\n}\n\nfn foo() i32 {\n    return 1234;\n}\n```\n\ntest_expression_ignored.zig\n\n    $ zig test test_expression_ignored.zig\n    doc/langref/test_expression_ignored.zig:2:8: error: value of type 'i32' ignored\n        foo();\n        ~~~^~\n    doc/langref/test_expression_ignored.zig:2:8: note: all non-void values must be used\n    doc/langref/test_expression_ignored.zig:2:8: note: to discard the value, assign it to '_'\n\nShell\n\nHowever, if the expression has type `void`, there will be no error. Expression results can be explicitly ignored by assigning them to `_`.\n\n``` zig\ntest \"void is ignored\" {\n    returnsVoid();\n}\n\ntest \"explicitly ignoring expression value\" {\n    _ = foo();\n}\n\nfn returnsVoid() void {}\n\nfn foo() i32 {\n    return 1234;\n}\n```\n\ntest_void_ignored.zig\n\n    $ zig test test_void_ignored.zig\n    1/2 test_void_ignored.test.void is ignored...OK\n    2/2 test_void_ignored.test.explicitly ignoring expression value...OK\n    All 2 tests passed.\n\nShell\n\n## Result Location Semantics\n\nDuring compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to `_`, for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory location to place it in.\n\nAs a motivating example, consider the statement `const`` x: ``u32`` = ``42``;`. The type annotation here provides a result type of `u32` to the initialization expression `42`, instructing the compiler to coerce this integer (initally of type `comptime_int`) to this type. We will see more examples shortly.\n\nThis is not an implementation detail: the logic outlined above is codified into the Zig language specification, and is the primary mechanism of type inference in the language. This system is collectively referred to as \"Result Location Semantics\".\n\n### Result Types\n\nResult types are propagated recursively through expressions where possible. For instance, if the expression `&e` has result type `*``u32`, then `e` is given a result type of `u32`, allowing the language to perform this coercion before taking a reference.\n\nThe result type mechanism is utilized by casting builtins such as `@intCast`. Rather than taking as an argument the type to cast to, these builtins use their result type to determine this information. The result type is often known from context; where it is not, the `@as` builtin can be used to explicitly provide a result type.\n\nWe can break down the result types for each component of a simple expression as follows:\n\n``` zig\nconst expectEqual = @import(\"std\").testing.expectEqual;\ntest \"result type propagates through struct initializer\" {\n    const S = struct { x: u32 };\n    const val: u64 = 123;\n    const s: S = .{ .x = @intCast(val) };\n    // .{ .x = @intCast(val) }   has result type `S` due to the type annotation\n    //         @intCast(val)     has result type `u32` due to the type of the field `S.x`\n    //                  val      has no result type, as it is permitted to be any integer type\n    try expectEqual(@as(u32, 123), s.x);\n}\n```\n\nresult_type_propagation.zig\n\n    $ zig test result_type_propagation.zig\n    1/1 result_type_propagation.test.result type propagates through struct initializer...OK\n    All 1 tests passed.\n\nShell\n\nThis result type information is useful for the aforementioned cast builtins, as well as to avoid the construction of pre-coercion values, and to avoid the need for explicit type coercions in some cases. The following table details how some common expressions propagate result types, where `x` and `y` are arbitrary sub-expressions.\n\n| Expression           | Parent Result Type | Sub-expression Result Type                      |\n|----------------------|--------------------|-------------------------------------------------|\n| `const`` val: T = x` | \\-                 | `x` is a `T`                                    |\n| `var`` val: T = x`   | \\-                 | `x` is a `T`                                    |\n| `val = x`            | \\-                 | `x` is a `@TypeOf``(val)`                       |\n| `@as``(T, x)`        | \\-                 | `x` is a `T`                                    |\n| `&x`                 | `*T`               | `x` is a `T`                                    |\n| `&x`                 | `[]T`              | `x` is some array of `T`                        |\n| `f(x)`               | \\-                 | `x` has the type of the first parameter of `f`  |\n| `.{x}`               | `T`                | `x` is a `std.meta.FieldType(T, .@\"0\")`         |\n| `.{ .a = x }`        | `T`                | `x` is a `std.meta.FieldType(T, .a)`            |\n| `T{x}`               | \\-                 | `x` is a `std.meta.FieldType(T, .@\"0\")`         |\n| `T{ .a = x }`        | \\-                 | `x` is a `std.meta.FieldType(T, .a)`            |\n| `@Type``(x)`         | \\-                 | `x` is a `std.builtin.Type`                     |\n| `@typeInfo``(x)`     | \\-                 | `x` is a `type`                                 |\n| `x << y`             | \\-                 | `y` is a `std.math.Log2IntCeil(``@TypeOf``(x))` |\n\n### Result Locations\n\nIn addition to result type information, every expression may be optionally assigned a result location: a pointer to which the value must be directly written. This system can be used to prevent intermediate copies when initializing data structures, which can be important for types which must have a fixed memory address (\"pinned\" types).\n\nWhen compiling the simple assignment expression `x = e`, many languages would create the temporary value `e` on the stack, and then assign it to `x`, potentially performing a type coercion in the process. Zig approaches this differently. The expression `e` is given a result type matching the type of `x`, and a result location of `&x`. For many syntactic forms of `e`, this has no practical impact. However, it can have important semantic effects when working with more complex syntax forms.\n\nFor instance, if the expression `.{ .a = x, .b = y }` has a result location of `ptr`, then `x` is given a result location of `&ptr.a`, and `y` a result location of `&ptr.b`. Without this system, this expression would construct a temporary struct value entirely on the stack, and only then copy it to the destination address. In essence, Zig desugars the assignment `foo = .{ .a = x, .b = y }` to the two statements `foo.a = x; foo.b = y;`.\n\nThis can sometimes be important when assigning an aggregate value where the initialization expression depends on the previous value of the aggregate. The easiest way to demonstrate this is by attempting to swap fields of a struct or array - the following logic looks sound, but in fact is not:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\ntest \"attempt to swap array elements with array initializer\" {\n    var arr: [2]u32 = .{ 1, 2 };\n    arr = .{ arr[1], arr[0] };\n    // The previous line is equivalent to the following two lines:\n    //   arr[0] = arr[1];\n    //   arr[1] = arr[0];\n    // So this fails!\n    try expect(arr[0] == 2); // succeeds\n    try expect(arr[1] == 1); // fails\n}\n```\n\nresult_location_interfering_with_swap.zig\n\n    $ zig test result_location_interfering_with_swap.zig\n    1/1 result_location_interfering_with_swap.test.attempt to swap array elements with array initializer...FAIL (TestUnexpectedResult)\n    /home/andy/src/zig/lib/std/testing.zig:540:14: 0x103ce1f in expect (test)\n        if (!ok) return error.TestUnexpectedResult;\n                 ^\n    /home/andy/src/zig/doc/langref/result_location_interfering_with_swap.zig:10:5: 0x103cf85 in test.attempt to swap array elements with array initializer (test)\n        try expect(arr[1] == 1); // fails\n        ^\n    0 passed; 0 skipped; 1 failed.\n    error: the following test command failed with exit code 1:\n    /home/andy/src/zig/.zig-cache/o/c42c6019fdf548f70655aafe3673a46e/test\n\nShell\n\nThe following table details how some common expressions propagate result locations, where `x` and `y` are arbitrary sub-expressions. Note that some expressions cannot provide meaningful result locations to sub-expressions, even if they themselves have a result location.\n\n| Expression           | Result Location | Sub-expression Result Locations                                                   |\n|----------------------|-----------------|-----------------------------------------------------------------------------------|\n| `const`` val: T = x` | \\-              | `x` has result location `&val`                                                    |\n| `var`` val: T = x`   | \\-              | `x` has result location `&val`                                                    |\n| `val = x`            | \\-              | `x` has result location `&val`                                                    |\n| `@as``(T, x)`        | `ptr`           | `x` has no result location                                                        |\n| `&x`                 | `ptr`           | `x` has no result location                                                        |\n| `f(x)`               | `ptr`           | `x` has no result location                                                        |\n| `.{x}`               | `ptr`           | `x` has result location `&ptr[``0``]`                                             |\n| `.{ .a = x }`        | `ptr`           | `x` has result location `&ptr.a`                                                  |\n| `T{x}`               | `ptr`           | `x` has no result location (typed initializers do not propagate result locations) |\n| `T{ .a = x }`        | `ptr`           | `x` has no result location (typed initializers do not propagate result locations) |\n| `@Type``(x)`         | `ptr`           | `x` has no result location                                                        |\n| `@typeInfo``(x)`     | `ptr`           | `x` has no result location                                                        |\n| `x << y`             | `ptr`           | `x` and `y` do not have result locations                                          |\n\n## usingnamespace\n\n`usingnamespace` is a declaration that mixes all the public declarations of the operand, which must be a [struct](#struct), [union](#union), [enum](#enum), or [opaque](#opaque), into the namespace:\n\n``` zig\ntest \"using std namespace\" {\n    const S = struct {\n        usingnamespace @import(\"std\");\n    };\n    try S.testing.expect(true);\n}\n```\n\ntest_usingnamespace.zig\n\n    $ zig test test_usingnamespace.zig\n    1/1 test_usingnamespace.test.using std namespace...OK\n    All 1 tests passed.\n\nShell\n\n`usingnamespace` has an important use case when organizing the public API of a file or package. For example, one might have `c.zig` with all of the [C imports](#Import-from-C-Header-File):\n\n``` zig\npub usingnamespace @cImport({\n    @cInclude(\"epoxy/gl.h\");\n    @cInclude(\"GLFW/glfw3.h\");\n    @cDefine(\"STBI_ONLY_PNG\", \"\");\n    @cDefine(\"STBI_NO_STDIO\", \"\");\n    @cInclude(\"stb_image.h\");\n});\n```\n\nc.zig\n\nThe above example demonstrates using `pub` to qualify the `usingnamespace` additionally makes the imported declarations `pub`. This can be used to forward declarations, giving precise control over what declarations a given file exposes.\n\n## comptime\n\nZig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful.\n\n### Introducing the Compile-Time Concept\n\n#### [Compile-Time Parameters](#toc-Compile-Time-Parameters)\n\nCompile-time parameters is how Zig implements generics. It is compile-time duck typing.\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a > b) a else b;\n}\nfn gimmeTheBiggerFloat(a: f32, b: f32) f32 {\n    return max(f32, a, b);\n}\nfn gimmeTheBiggerInteger(a: u64, b: u64) u64 {\n    return max(u64, a, b);\n}\n```\n\ncompile-time_duck_typing.zig\n\nIn Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions, and returned from functions. However, they can only be used in expressions which are known at *compile-time*, which is why the parameter `T` in the above snippet must be marked with `comptime`.\n\nA `comptime` parameter means that:\n\n- At the callsite, the value must be known at compile-time, or it is a compile error.\n- In the function definition, the value is known at compile-time.\n\nFor example, if we were to introduce another function to the above snippet:\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a > b) a else b;\n}\ntest \"try to pass a runtime type\" {\n    foo(false);\n}\nfn foo(condition: bool) void {\n    const result = max(if (condition) f32 else u64, 1234, 5678);\n    _ = result;\n}\n```\n\ntest_unresolved_comptime_value.zig\n\n    $ zig test test_unresolved_comptime_value.zig\n    doc/langref/test_unresolved_comptime_value.zig:8:28: error: unable to resolve comptime value\n        const result = max(if (condition) f32 else u64, 1234, 5678);\n                               ^~~~~~~~~\n    doc/langref/test_unresolved_comptime_value.zig:8:28: note: condition in comptime branch must be comptime-known\n    referenced by:\n        test.try to pass a runtime type: doc/langref/test_unresolved_comptime_value.zig:5:5\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\nThis is an error because the programmer attempted to pass a value only known at run-time to a function which expects a value known at compile-time.\n\nAnother way to get an error is if we pass a type that violates the type checker when the function is analyzed. This is what it means to have *compile-time duck typing*.\n\nFor example:\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    return if (a > b) a else b;\n}\ntest \"try to compare bools\" {\n    _ = max(bool, true, false);\n}\n```\n\ntest_comptime_mismatched_type.zig\n\n    $ zig test test_comptime_mismatched_type.zig\n    doc/langref/test_comptime_mismatched_type.zig:2:18: error: operator > not allowed for type 'bool'\n        return if (a > b) a else b;\n                   ~~^~~\n    referenced by:\n        test.try to compare bools: doc/langref/test_comptime_mismatched_type.zig:5:12\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\nOn the flip side, inside the function definition with the `comptime` parameter, the value is known at compile-time. This means that we actually could make this work for the bool type if we wanted to:\n\n``` zig\nfn max(comptime T: type, a: T, b: T) T {\n    if (T == bool) {\n        return a or b;\n    } else if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\ntest \"try to compare bools\" {\n    try @import(\"std\").testing.expect(max(bool, false, true) == true);\n}\n```\n\ntest_comptime_max_with_bool.zig\n\n    $ zig test test_comptime_max_with_bool.zig\n    1/1 test_comptime_max_with_bool.test.try to compare bools...OK\n    All 1 tests passed.\n\nShell\n\nThis works because Zig implicitly inlines `if` expressions when the condition is known at compile-time, and the compiler guarantees that it will skip analysis of the branch not taken.\n\nThis means that the actual function generated for `max` in this situation looks like this:\n\n``` zig\nfn max(a: bool, b: bool) bool {\n    {\n        return a or b;\n    }\n}\n```\n\ncompiler_generated_function.zig\n\nAll the code that dealt with compile-time known values is eliminated and we are left with only the necessary run-time code to accomplish the task.\n\nThis works the same way for `switch` expressions - they are implicitly inlined when the target expression is compile-time known.\n\n#### [Compile-Time Variables](#toc-Compile-Time-Variables)\n\nIn Zig, the programmer can label variables as `comptime`. This guarantees to the compiler that every load and store of the variable is performed at compile-time. Any violation of this results in a compile error.\n\nThis combined with the fact that we can `inline` loops allows us to write a function which is partially evaluated at compile-time and partially at run-time.\n\nFor example:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nconst CmdFn = struct {\n    name: []const u8,\n    func: fn (i32) i32,\n};\n\nconst cmd_fns = [_]CmdFn{\n    CmdFn{ .name = \"one\", .func = one },\n    CmdFn{ .name = \"two\", .func = two },\n    CmdFn{ .name = \"three\", .func = three },\n};\nfn one(value: i32) i32 {\n    return value + 1;\n}\nfn two(value: i32) i32 {\n    return value + 2;\n}\nfn three(value: i32) i32 {\n    return value + 3;\n}\n\nfn performFn(comptime prefix_char: u8, start_value: i32) i32 {\n    var result: i32 = start_value;\n    comptime var i = 0;\n    inline while (i < cmd_fns.len) : (i += 1) {\n        if (cmd_fns[i].name[0] == prefix_char) {\n            result = cmd_fns[i].func(result);\n        }\n    }\n    return result;\n}\n\ntest \"perform fn\" {\n    try expect(performFn('t', 1) == 6);\n    try expect(performFn('o', 0) == 1);\n    try expect(performFn('w', 99) == 99);\n}\n```\n\ntest_comptime_evaluation.zig\n\n    $ zig test test_comptime_evaluation.zig\n    1/1 test_comptime_evaluation.test.perform fn...OK\n    All 1 tests passed.\n\nShell\n\nThis example is a bit contrived, because the compile-time evaluation component is unnecessary; this code would work fine if it was all done at run-time. But it does end up generating different code. In this example, the function `performFn` is generated three different times, for the different values of `prefix_char` provided:\n\n``` zig\n// From the line:\n// expect(performFn('t', 1) == 6);\nfn performFn(start_value: i32) i32 {\n    var result: i32 = start_value;\n    result = two(result);\n    result = three(result);\n    return result;\n}\n```\n\nperformFn_1\n\n``` zig\n// From the line:\n// expect(performFn('o', 0) == 1);\nfn performFn(start_value: i32) i32 {\n    var result: i32 = start_value;\n    result = one(result);\n    return result;\n}\n```\n\nperformFn_2\n\n``` zig\n// From the line:\n// expect(performFn('w', 99) == 99);\nfn performFn(start_value: i32) i32 {\n    var result: i32 = start_value;\n    _ = &result;\n    return result;\n}\n```\n\nperformFn_3\n\nNote that this happens even in a debug build. This is not a way to write more optimized code, but it is a way to make sure that what *should* happen at compile-time, *does* happen at compile-time. This catches more errors and allows expressiveness that in other languages requires using macros, generated code, or a preprocessor to accomplish.\n\n#### [Compile-Time Expressions](#toc-Compile-Time-Expressions)\n\nIn Zig, it matters whether a given expression is known at compile-time or run-time. A programmer can use a `comptime` expression to guarantee that the expression will be evaluated at compile-time. If this cannot be accomplished, the compiler will emit an error. For example:\n\n``` zig\nextern fn exit() noreturn;\n\ntest \"foo\" {\n    comptime {\n        exit();\n    }\n}\n```\n\ntest_comptime_call_extern_function.zig\n\n    $ zig test test_comptime_call_extern_function.zig\n    doc/langref/test_comptime_call_extern_function.zig:5:13: error: comptime call of extern function\n            exit();\n            ~~~~^~\n\nShell\n\nIt doesn't make sense that a program could call `exit()` (or any other external function) at compile-time, so this is a compile error. However, a `comptime` expression does much more than sometimes cause a compile error.\n\nWithin a `comptime` expression:\n\n- All variables are `comptime` variables.\n- All `if`, `while`, `for`, and `switch` expressions are evaluated at compile-time, or emit a compile error if this is not possible.\n- All `return` and `try` expressions are invalid (unless the function itself is called at compile-time).\n- All code with runtime side effects or depending on runtime values emits a compile error.\n- All function calls cause the compiler to interpret the function at compile-time, emitting a compile error if the function tries to do something that has global runtime side effects.\n\nThis means that a programmer can create a function which is called both at compile-time and run-time, with no modification to the function required.\n\nLet's look at an example:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nfn fibonacci(index: u32) u32 {\n    if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    // test fibonacci at run-time\n    try expect(fibonacci(7) == 13);\n\n    // test fibonacci at compile-time\n    try comptime expect(fibonacci(7) == 13);\n}\n```\n\ntest_fibonacci_recursion.zig\n\n    $ zig test test_fibonacci_recursion.zig\n    1/1 test_fibonacci_recursion.test.fibonacci...OK\n    All 1 tests passed.\n\nShell\n\nImagine if we had forgotten the base case of the recursive function and tried to run the tests:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\nfn fibonacci(index: u32) u32 {\n    //if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    try comptime expect(fibonacci(7) == 13);\n}\n```\n\ntest_fibonacci_comptime_overflow.zig\n\n    $ zig test test_fibonacci_comptime_overflow.zig\n    doc/langref/test_fibonacci_comptime_overflow.zig:5:28: error: overflow of integer type 'u32' with value '-1'\n        return fibonacci(index - 1) + fibonacci(index - 2);\n                         ~~~~~~^~~\n    doc/langref/test_fibonacci_comptime_overflow.zig:5:21: note: called from here (7 times)\n        return fibonacci(index - 1) + fibonacci(index - 2);\n               ~~~~~~~~~^~~~~~~~~~~\n    doc/langref/test_fibonacci_comptime_overflow.zig:9:34: note: called from here\n        try comptime expect(fibonacci(7) == 13);\n                            ~~~~~~~~~^~~\n\nShell\n\nThe compiler produces an error which is a stack trace from trying to evaluate the function at compile-time.\n\nLuckily, we used an unsigned integer, and so when we tried to subtract 1 from 0, it triggered undefined behavior, which is always a compile error if the compiler knows it happened. But what would have happened if we used a signed integer?\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\n\nfn fibonacci(index: i32) i32 {\n    //if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    try comptime assert(fibonacci(7) == 13);\n}\n```\n\nfibonacci_comptime_infinite_recursion.zig\n\nThe compiler is supposed to notice that evaluating this function at compile-time took more than 1000 branches, and thus emits an error and gives up. If the programmer wants to increase the budget for compile-time computation, they can use a built-in function called [@setEvalBranchQuota](#setEvalBranchQuota) to change the default number 1000 to something else.\n\nHowever, there is a [design flaw in the compiler](https://github.com/ziglang/zig/issues/13724) causing it to stack overflow instead of having the proper behavior here. I'm terribly sorry about that. I hope to get this resolved before the next release.\n\nWhat if we fix the base case, but put the wrong value in the `expect` line?\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\n\nfn fibonacci(index: i32) i32 {\n    if (index < 2) return index;\n    return fibonacci(index - 1) + fibonacci(index - 2);\n}\n\ntest \"fibonacci\" {\n    try comptime assert(fibonacci(7) == 99999);\n}\n```\n\ntest_fibonacci_comptime_unreachable.zig\n\n    $ zig test test_fibonacci_comptime_unreachable.zig\n    lib/std/debug.zig:412:14: error: reached unreachable code\n        if (!ok) unreachable; // assertion failure\n                 ^~~~~~~~~~~\n    doc/langref/test_fibonacci_comptime_unreachable.zig:9:24: note: called from here\n        try comptime assert(fibonacci(7) == 99999);\n                     ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\nShell\n\nAt [container](#Containers) level (outside of any function), all expressions are implicitly `comptime` expressions. This means that we can use functions to initialize complex static data. For example:\n\n``` zig\nconst first_25_primes = firstNPrimes(25);\nconst sum_of_first_25_primes = sum(&first_25_primes);\n\nfn firstNPrimes(comptime n: usize) [n]i32 {\n    var prime_list: [n]i32 = undefined;\n    var next_index: usize = 0;\n    var test_number: i32 = 2;\n    while (next_index < prime_list.len) : (test_number += 1) {\n        var test_prime_index: usize = 0;\n        var is_prime = true;\n        while (test_prime_index < next_index) : (test_prime_index += 1) {\n            if (test_number % prime_list[test_prime_index] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            prime_list[next_index] = test_number;\n            next_index += 1;\n        }\n    }\n    return prime_list;\n}\n\nfn sum(numbers: []const i32) i32 {\n    var result: i32 = 0;\n    for (numbers) |x| {\n        result += x;\n    }\n    return result;\n}\n\ntest \"variable values\" {\n    try @import(\"std\").testing.expect(sum_of_first_25_primes == 1060);\n}\n```\n\ntest_container-level_comptime_expressions.zig\n\n    $ zig test test_container-level_comptime_expressions.zig\n    1/1 test_container-level_comptime_expressions.test.variable values...OK\n    All 1 tests passed.\n\nShell\n\nWhen we compile this program, Zig generates the constants with the answer pre-computed. Here are the lines from the generated LLVM IR:\n\n``` zig\n@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]\n@1 = internal unnamed_addr constant i32 1060\n```\n\nNote that we did not have to do anything special with the syntax of these functions. For example, we could call the `sum` function as is with a slice of numbers whose length and values were only known at run-time.\n\n### Generic Data Structures\n\nZig uses comptime capabilities to implement generic data structures without introducing any special-case syntax.\n\nHere is an example of a generic `List` data structure.\n\n``` zig\nfn List(comptime T: type) type {\n    return struct {\n        items: []T,\n        len: usize,\n    };\n}\n\n// The generic List data structure can be instantiated by passing in a type:\nvar buffer: [10]i32 = undefined;\nvar list = List(i32){\n    .items = &buffer,\n    .len = 0,\n};\n```\n\ngeneric_data_structure.zig\n\nThat's it. It's a function that returns an anonymous `struct`. For the purposes of error messages and debugging, Zig infers the name `\"List(i32)\"` from the function name and parameters invoked when creating the anonymous struct.\n\nTo explicitly give a type a name, we assign it to a constant.\n\n``` zig\nconst Node = struct {\n    next: ?*Node,\n    name: []const u8,\n};\n\nvar node_a = Node{\n    .next = null,\n    .name = \"Node A\",\n};\n\nvar node_b = Node{\n    .next = &node_a,\n    .name = \"Node B\",\n};\n```\n\nanonymous_struct_name.zig\n\nIn this example, the `Node` struct refers to itself. This works because all top level declarations are order-independent. As long as the compiler can determine the size of the struct, it is free to refer to itself. In this case, `Node` refers to itself as a pointer, which has a well-defined size at compile time, so it works fine.\n\n### Case Study: print in Zig\n\nPutting all of this together, let's see how `print` works in Zig.\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst a_number: i32 = 1234;\nconst a_string = \"foobar\";\n\npub fn main() void {\n    print(\"here is a string: '{s}' here is a number: {}\\n\", .{ a_string, a_number });\n}\n```\n\nprint.zig\n\n    $ zig build-exe print.zig\n    $ ./print\n    here is a string: 'foobar' here is a number: 1234\n\nShell\n\nLet's crack open the implementation of this and see how it works:\n\n``` zig\nconst Writer = struct {\n    /// Calls print and then flushes the buffer.\n    pub fn print(self: *Writer, comptime format: []const u8, args: anytype) anyerror!void {\n        const State = enum {\n            start,\n            open_brace,\n            close_brace,\n        };\n\n        comptime var start_index: usize = 0;\n        comptime var state = State.start;\n        comptime var next_arg: usize = 0;\n\n        inline for (format, 0..) |c, i| {\n            switch (state) {\n                State.start => switch (c) {\n                    '{' => {\n                        if (start_index < i) try self.write(format[start_index..i]);\n                        state = State.open_brace;\n                    },\n                    '}' => {\n                        if (start_index < i) try self.write(format[start_index..i]);\n                        state = State.close_brace;\n                    },\n                    else => {},\n                },\n                State.open_brace => switch (c) {\n                    '{' => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    '}' => {\n                        try self.printValue(args[next_arg]);\n                        next_arg += 1;\n                        state = State.start;\n                        start_index = i + 1;\n                    },\n                    's' => {\n                        continue;\n                    },\n                    else => @compileError(\"Unknown format character: \" ++ [1]u8{c}),\n                },\n                State.close_brace => switch (c) {\n                    '}' => {\n                        state = State.start;\n                        start_index = i;\n                    },\n                    else => @compileError(\"Single '}' encountered in format string\"),\n                },\n            }\n        }\n        comptime {\n            if (args.len != next_arg) {\n                @compileError(\"Unused arguments\");\n            }\n            if (state != State.start) {\n                @compileError(\"Incomplete format string: \" ++ format);\n            }\n        }\n        if (start_index < format.len) {\n            try self.write(format[start_index..format.len]);\n        }\n        try self.flush();\n    }\n\n    fn write(self: *Writer, value: []const u8) !void {\n        _ = self;\n        _ = value;\n    }\n    pub fn printValue(self: *Writer, value: anytype) !void {\n        _ = self;\n        _ = value;\n    }\n    fn flush(self: *Writer) !void {\n        _ = self;\n    }\n};\n```\n\npoc_print_fn.zig\n\nThis is a proof of concept implementation; the actual function in the standard library has more formatting capabilities.\n\nNote that this is not hard-coded into the Zig compiler; this is userland code in the standard library.\n\nWhen this function is analyzed from our example code above, Zig partially evaluates the function and emits a function that actually looks like this:\n\n``` zig\npub fn print(self: *Writer, arg0: []const u8, arg1: i32) !void {\n    try self.write(\"here is a string: '\");\n    try self.printValue(arg0);\n    try self.write(\"' here is a number: \");\n    try self.printValue(arg1);\n    try self.write(\"\\n\");\n    try self.flush();\n}\n```\n\nEmitted print Function\n\n`printValue` is a function that takes a parameter of any type, and does different things depending on the type:\n\n``` zig\nconst Writer = struct {\n    pub fn printValue(self: *Writer, value: anytype) !void {\n        switch (@typeInfo(@TypeOf(value))) {\n            .Int => {\n                return self.writeInt(value);\n            },\n            .Float => {\n                return self.writeFloat(value);\n            },\n            .Pointer => {\n                return self.write(value);\n            },\n            else => {\n                @compileError(\"Unable to print type '\" ++ @typeName(@TypeOf(value)) ++ \"'\");\n            },\n        }\n    }\n\n    fn write(self: *Writer, value: []const u8) !void {\n        _ = self;\n        _ = value;\n    }\n    fn writeInt(self: *Writer, value: anytype) !void {\n        _ = self;\n        _ = value;\n    }\n    fn writeFloat(self: *Writer, value: anytype) !void {\n        _ = self;\n        _ = value;\n    }\n};\n```\n\npoc_printValue_fn.zig\n\nAnd now, what happens if we give too many arguments to `print`?\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst a_number: i32 = 1234;\nconst a_string = \"foobar\";\n\ntest \"print too many arguments\" {\n    print(\"here is a string: '{s}' here is a number: {}\\n\", .{\n        a_string,\n        a_number,\n        a_number,\n    });\n}\n```\n\ntest_print_too_many_args.zig\n\n    $ zig test test_print_too_many_args.zig\n    lib/std/fmt.zig:203:18: error: unused argument in 'here is a string: '{s}' here is a number: {}\n                                   '\n                1 => @compileError(\"unused argument in '\" ++ fmt ++ \"'\"),\n                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    referenced by:\n        print__anon_2377: lib/std/io/Writer.zig:24:26\n        print: lib/std/io.zig:324:47\n        remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nShell\n\nZig gives programmers the tools needed to protect themselves against their own mistakes.\n\nZig doesn't care whether the format argument is a string literal, only that it is a compile-time known value that can be coerced to a `[]``const`` ``u8`:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst a_number: i32 = 1234;\nconst a_string = \"foobar\";\nconst fmt = \"here is a string: '{s}' here is a number: {}\\n\";\n\npub fn main() void {\n    print(fmt, .{ a_string, a_number });\n}\n```\n\nprint_comptime-known_format.zig\n\n    $ zig build-exe print_comptime-known_format.zig\n    $ ./print_comptime-known_format\n    here is a string: 'foobar' here is a number: 1234\n\nShell\n\nThis works fine.\n\nZig does not special case string formatting in the compiler and instead exposes enough power to accomplish this task in userland. It does so without introducing another language on top of Zig, such as a macro language or a preprocessor language. It's Zig all the way down.\n\nSee also:\n\n- [inline while](#inline-while)\n- [inline for](#inline-for)\n\n## Assembly\n\nFor some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly:\n\n``` zig\npub fn main() noreturn {\n    const msg = \"hello world\\n\";\n    _ = syscall3(SYS_write, STDOUT_FILENO, @intFromPtr(msg), msg.len);\n    _ = syscall1(SYS_exit, 0);\n    unreachable;\n}\n\npub const SYS_write = 1;\npub const SYS_exit = 60;\n\npub const STDOUT_FILENO = 1;\n\npub fn syscall1(number: usize, arg1: usize) usize {\n    return asm volatile (\"syscall\"\n        : [ret] \"={rax}\" (-> usize),\n        : [number] \"{rax}\" (number),\n          [arg1] \"{rdi}\" (arg1),\n        : \"rcx\", \"r11\"\n    );\n}\n\npub fn syscall3(number: usize, arg1: usize, arg2: usize, arg3: usize) usize {\n    return asm volatile (\"syscall\"\n        : [ret] \"={rax}\" (-> usize),\n        : [number] \"{rax}\" (number),\n          [arg1] \"{rdi}\" (arg1),\n          [arg2] \"{rsi}\" (arg2),\n          [arg3] \"{rdx}\" (arg3),\n        : \"rcx\", \"r11\"\n    );\n}\n```\n\ninline_assembly.zig\n\n    $ zig build-exe inline_assembly.zig -target x86_64-linux\n    $ ./inline_assembly\n    hello world\n\nShell\n\nDissecting the syntax:\n\n``` zig\npub fn syscall1(number: usize, arg1: usize) usize {\n    // Inline assembly is an expression which returns a value.\n    // the `asm` keyword begins the expression.\n    return asm\n    // `volatile` is an optional modifier that tells Zig this\n    // inline assembly expression has side-effects. Without\n    // `volatile`, Zig is allowed to delete the inline assembly\n    // code if the result is unused.\n    volatile (\n    // Next is a comptime string which is the assembly code.\n    // Inside this string one may use `%[ret]`, `%[number]`,\n    // or `%[arg1]` where a register is expected, to specify\n    // the register that Zig uses for the argument or return value,\n    // if the register constraint strings are used. However in\n    // the below code, this is not used. A literal `%` can be\n    // obtained by escaping it with a double percent: `%%`.\n    // Often multiline string syntax comes in handy here.\n        \\\\syscall\n        // Next is the output. It is possible in the future Zig will\n        // support multiple outputs, depending on how\n        // https://github.com/ziglang/zig/issues/215 is resolved.\n        // It is allowed for there to be no outputs, in which case\n        // this colon would be directly followed by the colon for the inputs.\n        :\n        // This specifies the name to be used in `%[ret]` syntax in\n        // the above assembly string. This example does not use it,\n        // but the syntax is mandatory.\n          [ret]\n          // Next is the output constraint string. This feature is still\n          // considered unstable in Zig, and so LLVM/GCC documentation\n          // must be used to understand the semantics.\n          // http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string\n          // https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html\n          // In this example, the constraint string means \"the result value of\n          // this inline assembly instruction is whatever is in $rax\".\n          \"={rax}\"\n          // Next is either a value binding, or `->` and then a type. The\n          // type is the result type of the inline assembly expression.\n          // If it is a value binding, then `%[ret]` syntax would be used\n          // to refer to the register bound to the value.\n          (-> usize),\n          // Next is the list of inputs.\n          // The constraint for these inputs means, \"when the assembly code is\n          // executed, $rax shall have the value of `number` and $rdi shall have\n          // the value of `arg1`\". Any number of input parameters is allowed,\n          // including none.\n        : [number] \"{rax}\" (number),\n          [arg1] \"{rdi}\" (arg1),\n          // Next is the list of clobbers. These declare a set of registers whose\n          // values will not be preserved by the execution of this assembly code.\n          // These do not include output or input registers. The special clobber\n          // value of \"memory\" means that the assembly writes to arbitrary undeclared\n          // memory locations - not only the memory pointed to by a declared indirect\n          // output. In this example we list $rcx and $r11 because it is known the\n          // kernel syscall does not preserve these registers.\n        : \"rcx\", \"r11\"\n    );\n}\n```\n\nAssembly Syntax Explained.zig\n\nFor x86 and x86_64 targets, the syntax is AT&T syntax, rather than the more popular Intel syntax. This is due to technical constraints; assembly parsing is provided by LLVM and its support for Intel syntax is buggy and not well tested.\n\nSome day Zig may have its own assembler. This would allow it to integrate more seamlessly into the language, as well as be compatible with the popular NASM syntax. This documentation section will be updated before 1.0.0 is released, with a conclusive statement about the status of AT&T vs Intel/NASM syntax.\n\n### Output Constraints\n\nOutput constraints are still considered to be unstable in Zig, and so [LLVM documentation](http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string) and [GCC documentation](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) must be used to understand the semantics.\n\nNote that some breaking changes to output constraints are planned with [issue \\#215](https://github.com/ziglang/zig/issues/215).\n\n### Input Constraints\n\nInput constraints are still considered to be unstable in Zig, and so [LLVM documentation](http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string) and [GCC documentation](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) must be used to understand the semantics.\n\nNote that some breaking changes to input constraints are planned with [issue \\#215](https://github.com/ziglang/zig/issues/215).\n\n### Clobbers\n\nClobbers are the set of registers whose values will not be preserved by the execution of the assembly code. These do not include output or input registers. The special clobber value of `\"memory\"` means that the assembly causes writes to arbitrary undeclared memory locations - not only the memory pointed to by a declared indirect output.\n\nFailure to declare the full set of clobbers for a given inline assembly expression is unchecked [Undefined Behavior](#Undefined-Behavior).\n\n### Global Assembly\n\nWhen an assembly expression occurs in a [container](#Containers) level [comptime](#comptime) block, this is **global assembly**.\n\nThis kind of assembly has different rules than inline assembly. First, `volatile` is not valid because all global assembly is unconditionally included. Second, there are no inputs, outputs, or clobbers. All global assembly is concatenated verbatim into one long string and assembled together. There are no template substitution rules regarding `%` as there are in inline assembly expressions.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ncomptime {\n    asm (\n        \\\\.global my_func;\n        \\\\.type my_func, @function;\n        \\\\my_func:\n        \\\\  lea (%rdi,%rsi,1),%eax\n        \\\\  retq\n    );\n}\n\nextern fn my_func(a: i32, b: i32) i32;\n\ntest \"global assembly\" {\n    try expect(my_func(12, 34) == 46);\n}\n```\n\ntest_global_assembly.zig\n\n    $ zig test test_global_assembly.zig -target x86_64-linux\n    1/1 test_global_assembly.test.global assembly...OK\n    All 1 tests passed.\n\nShell\n\n## Atomics\n\nTODO: @fence()\n\nTODO: @atomic rmw\n\nTODO: builtin atomic memory ordering enum\n\nSee also:\n\n- [@atomicLoad](#atomicLoad)\n- [@atomicStore](#atomicStore)\n- [@atomicRmw](#atomicRmw)\n- [@fence](#fence)\n- [@cmpxchgWeak](#cmpxchgWeak)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n## Async Functions\n\nAsync functions regressed with the release of 0.11.0. Their future in the Zig language is unclear due to multiple unsolved problems:\n\n- LLVM's lack of ability to optimize them.\n- Third-party debuggers' lack of ability to debug them.\n- [The cancellation problem](https://github.com/ziglang/zig/issues/5913).\n- Async function pointers preventing the stack size from being known.\n\nThese problems are surmountable, but it will take time. The Zig team is currently focused on other priorities.\n\n## Builtin Functions\n\nBuiltin functions are provided by the compiler and are prefixed with `@`. The `comptime` keyword on a parameter means that the parameter must be known at compile time.\n\n### @addrSpaceCast\n\n``` zig\n@addrSpaceCast(ptr: anytype) anytype\n```\n\nConverts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the pointer operand. It is always valid to cast a pointer between the same address spaces.\n\n### @addWithOverflow\n\n``` zig\n@addWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }\n```\n\nPerforms `a + b` and returns a tuple with the result and a possible overflow bit.\n\n### @alignCast\n\n``` zig\n@alignCast(ptr: anytype) anytype\n```\n\n`ptr` can be `*T`, `?*T`, or `[]T`. Changes the alignment of a pointer. The alignment to use is inferred based on the result type.\n\nA [pointer alignment safety check](#Incorrect-Pointer-Alignment) is added to the generated code to make sure the pointer is aligned as promised.\n\n### @alignOf\n\n``` zig\n@alignOf(comptime T: type) comptime_int\n```\n\nThis function returns the number of bytes that this type should be aligned to for the current target to match the C ABI. When the child type of a pointer has this alignment, the alignment can be omitted from the type.\n\n``` zig\nconst assert = @import(\"std\").debug.assert;\ncomptime {\n    assert(*u32 == *align(@alignOf(u32)) u32);\n}\n```\n\nThe result is a target-specific compile time constant. It is guaranteed to be less than or equal to [@sizeOf(T)](#sizeOf).\n\nSee also:\n\n- [Alignment](#Alignment)\n\n### @as\n\n``` zig\n@as(comptime T: type, expression) T\n```\n\nPerforms [Type Coercion](#Type-Coercion). This cast is allowed when the conversion is unambiguous and safe, and is the preferred way to convert between types, whenever possible.\n\n### @atomicLoad\n\n``` zig\n@atomicLoad(comptime T: type, ptr: *const T, comptime ordering: AtomicOrder) T\n```\n\nThis builtin function atomically dereferences a pointer to a `T` and returns the value.\n\n`T` must be a pointer, a `bool`, a float, an integer or an enum.\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\nSee also:\n\n- [@atomicStore](#atomicStore)\n- [@atomicRmw](#atomicRmw)\n- [@fence](#fence)\n- [@cmpxchgWeak](#cmpxchgWeak)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n### @atomicRmw\n\n``` zig\n@atomicRmw(comptime T: type, ptr: *T, comptime op: AtomicRmwOp, operand: T, comptime ordering: AtomicOrder) T\n```\n\nThis builtin function dereferences a pointer to a `T` and atomically modifies the value and returns the previous value.\n\n`T` must be a pointer, a `bool`, a float, an integer or an enum.\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\n`AtomicRmwOp` can be found with `@import``(``\"std\"``).builtin.AtomicRmwOp`.\n\nSee also:\n\n- [@atomicStore](#atomicStore)\n- [@atomicLoad](#atomicLoad)\n- [@fence](#fence)\n- [@cmpxchgWeak](#cmpxchgWeak)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n### @atomicStore\n\n``` zig\n@atomicStore(comptime T: type, ptr: *T, value: T, comptime ordering: AtomicOrder) void\n```\n\nThis builtin function dereferences a pointer to a `T` and atomically stores the given value.\n\n`T` must be a pointer, a `bool`, a float, an integer or an enum.\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\nSee also:\n\n- [@atomicLoad](#atomicLoad)\n- [@atomicRmw](#atomicRmw)\n- [@fence](#fence)\n- [@cmpxchgWeak](#cmpxchgWeak)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n### @bitCast\n\n``` zig\n@bitCast(value: anytype) anytype\n```\n\nConverts a value of one type to another type. The return type is the inferred result type.\n\nAsserts that `@sizeOf``(``@TypeOf``(value)) == ``@sizeOf``(DestType)`.\n\nAsserts that `@typeInfo``(DestType) != .Pointer`. Use `@ptrCast` or `@ptrFromInt` if you need this.\n\nCan be used for these things for example:\n\n- Convert `f32` to `u32` bits\n- Convert `i32` to `u32` preserving twos complement\n\nWorks at compile-time if `value` is known at compile time. It's a compile error to bitcast a value of undefined layout; this means that, besides the restriction from types which possess dedicated casting builtins (enums, pointers, error sets), bare structs, error unions, slices, optionals, and any other type without a well-defined memory layout, also cannot be used in this operation.\n\n### @bitOffsetOf\n\n``` zig\n@bitOffsetOf(comptime T: type, comptime field_name: []const u8) comptime_int\n```\n\nReturns the bit offset of a field relative to its containing struct.\n\nFor non [packed structs](#packed-struct), this will always be divisible by `8`. For packed structs, non-byte-aligned fields will share a byte offset, but they will have different bit offsets.\n\nSee also:\n\n- [@offsetOf](#offsetOf)\n\n### @bitSizeOf\n\n``` zig\n@bitSizeOf(comptime T: type) comptime_int\n```\n\nThis function returns the number of bits it takes to store `T` in memory if the type were a field in a packed struct/union. The result is a target-specific compile time constant.\n\nThis function measures the size at runtime. For types that are disallowed at runtime, such as `comptime_int` and `type`, the result is `0`.\n\nSee also:\n\n- [@sizeOf](#sizeOf)\n- [@typeInfo](#typeInfo)\n\n### @breakpoint\n\n``` zig\n@breakpoint() void\n```\n\nThis function inserts a platform-specific debug trap instruction which causes debuggers to break there. Unlike for `@trap``()`, execution may continue after this point if the program is resumed.\n\nThis function is only valid within function scope.\n\nSee also:\n\n- [@trap](#trap)\n\n### @mulAdd\n\n``` zig\n@mulAdd(comptime T: type, a: T, b: T, c: T) T\n```\n\nFused multiply-add, similar to `(a * b) + c`, except only rounds once, and is thus more accurate.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @byteSwap\n\n``` zig\n@byteSwap(operand: anytype) T\n```\n\n`@TypeOf``(operand)` must be an integer type or an integer vector type with bit count evenly divisible by 8.\n\n`operand` may be an [integer](#Integers) or [vector](#Vectors).\n\nSwaps the byte order of the integer. This converts a big endian integer to a little endian integer, and converts a little endian integer to a big endian integer.\n\nNote that for the purposes of memory layout with respect to endianness, the integer type should be related to the number of bytes reported by [@sizeOf](#sizeOf) bytes. This is demonstrated with `u24`. `@sizeOf``(``u24``) == ``4`, which means that a `u24` stored in memory takes 4 bytes, and those 4 bytes are what are swapped on a little vs big endian system. On the other hand, if `T` is specified to be `u24`, then only 3 bytes are reversed.\n\n### @bitReverse\n\n``` zig\n@bitReverse(integer: anytype) T\n```\n\n`@TypeOf``(``anytype``)` accepts any integer type or integer vector type.\n\nReverses the bitpattern of an integer value, including the sign bit if applicable.\n\nFor example 0b10110110 (`u8`` = ``182`, `i8`` = -``74`) becomes 0b01101101 (`u8`` = ``109`, `i8`` = ``109`).\n\n### @offsetOf\n\n``` zig\n@offsetOf(comptime T: type, comptime field_name: []const u8) comptime_int\n```\n\nReturns the byte offset of a field relative to its containing struct.\n\nSee also:\n\n- [@bitOffsetOf](#bitOffsetOf)\n\n### @call\n\n``` zig\n@call(modifier: std.builtin.CallModifier, function: anytype, args: anytype) anytype\n```\n\nCalls a function, in the same way that invoking an expression with parentheses does:\n\n``` zig\nconst expect = @import(\"std\").testing.expect;\n\ntest \"noinline function call\" {\n    try expect(@call(.auto, add, .{ 3, 9 }) == 12);\n}\n\nfn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n```\n\ntest_call_builtin.zig\n\n    $ zig test test_call_builtin.zig\n    1/1 test_call_builtin.test.noinline function call...OK\n    All 1 tests passed.\n\nShell\n\n`@call` allows more flexibility than normal function call syntax does. The `CallModifier` enum is reproduced here:\n\n``` zig\npub const CallModifier = enum {\n    /// Equivalent to function call syntax.\n    auto,\n\n    /// Equivalent to async keyword used with function call syntax.\n    async_kw,\n\n    /// Prevents tail call optimization. This guarantees that the return\n    /// address will point to the callsite, as opposed to the callsite's\n    /// callsite. If the call is otherwise required to be tail-called\n    /// or inlined, a compile error is emitted instead.\n    never_tail,\n\n    /// Guarantees that the call will not be inlined. If the call is\n    /// otherwise required to be inlined, a compile error is emitted instead.\n    never_inline,\n\n    /// Asserts that the function call will not suspend. This allows a\n    /// non-async function to call an async function.\n    no_async,\n\n    /// Guarantees that the call will be generated with tail call optimization.\n    /// If this is not possible, a compile error is emitted instead.\n    always_tail,\n\n    /// Guarantees that the call will inlined at the callsite.\n    /// If this is not possible, a compile error is emitted instead.\n    always_inline,\n\n    /// Evaluates the call at compile-time. If the call cannot be completed at\n    /// compile-time, a compile error is emitted instead.\n    compile_time,\n};\n```\n\nbuiltin.CallModifier struct.zig\n\n### @cDefine\n\n``` zig\n@cDefine(comptime name: []const u8, value) void\n```\n\nThis function can only occur inside `@cImport`.\n\nThis appends `#define $name $value` to the `@cImport` temporary buffer.\n\nTo define without a value, like this:\n\n``` zig\n#define _GNU_SOURCE\n```\n\nUse the void value, like this:\n\n``` zig\n@cDefine(\"_GNU_SOURCE\", {})\n```\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cInclude](#cInclude)\n- [@cImport](#cImport)\n- [@cUndef](#cUndef)\n- [void](#void)\n\n### @cImport\n\n``` zig\n@cImport(expression) type\n```\n\nThis function parses C code and imports the functions, types, variables, and compatible macro definitions into a new empty struct type, and then returns that type.\n\n`expression` is interpreted at compile time. The builtin functions `@cInclude`, `@cDefine`, and `@cUndef` work within this expression, appending to a temporary buffer which is then parsed as C code.\n\nUsually you should only have one `@cImport` in your entire application, because it saves the compiler from invoking clang multiple times, and prevents inline functions from being duplicated.\n\nReasons for having multiple `@cImport` expressions would be:\n\n- To avoid a symbol collision, for example if foo.h and bar.h both `#define CONNECTION_COUNT`\n- To analyze the C code with different preprocessor defines\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cInclude](#cInclude)\n- [@cDefine](#cDefine)\n- [@cUndef](#cUndef)\n\n### @cInclude\n\n``` zig\n@cInclude(comptime path: []const u8) void\n```\n\nThis function can only occur inside `@cImport`.\n\nThis appends `#include <$path>\\n` to the `c_import` temporary buffer.\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cImport](#cImport)\n- [@cDefine](#cDefine)\n- [@cUndef](#cUndef)\n\n### @clz\n\n``` zig\n@clz(operand: anytype) anytype\n```\n\n`@TypeOf``(operand)` must be an integer type or an integer vector type.\n\n`operand` may be an [integer](#Integers) or [vector](#Vectors).\n\nCounts the number of most-significant (leading in a big-endian sense) zeroes in an integer - \"count leading zeroes\".\n\nIf `operand` is a [comptime](#comptime)-known integer, the return type is `comptime_int`. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.\n\nIf `operand` is zero, `@clz` returns the bit width of integer type `T`.\n\nSee also:\n\n- [@ctz](#ctz)\n- [@popCount](#popCount)\n\n### @cmpxchgStrong\n\n``` zig\n@cmpxchgStrong(comptime T: type, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T\n```\n\nThis function performs a strong atomic compare-and-exchange operation, returning `null` if the current value is not the given expected value. It's the equivalent of this code, except atomic:\n\n``` zig\nfn cmpxchgStrongButNotAtomic(comptime T: type, ptr: *T, expected_value: T, new_value: T) ?T {\n    const old_value = ptr.*;\n    if (old_value == expected_value) {\n        ptr.* = new_value;\n        return null;\n    } else {\n        return old_value;\n    }\n}\n```\n\nnot_atomic_cmpxchgStrong.zig\n\nIf you are using cmpxchg in a retry loop, [@cmpxchgWeak](#cmpxchgWeak) is the better choice, because it can be implemented more efficiently in machine instructions.\n\n`T` must be a pointer, a `bool`, a float, an integer or an enum.\n\n`@typeInfo``(``@TypeOf``(ptr)).Pointer.alignment` must be `>= ``@sizeOf``(T).`\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\nSee also:\n\n- [@atomicStore](#atomicStore)\n- [@atomicLoad](#atomicLoad)\n- [@atomicRmw](#atomicRmw)\n- [@fence](#fence)\n- [@cmpxchgWeak](#cmpxchgWeak)\n\n### @cmpxchgWeak\n\n``` zig\n@cmpxchgWeak(comptime T: type, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T\n```\n\nThis function performs a weak atomic compare-and-exchange operation, returning `null` if the current value is not the given expected value. It's the equivalent of this code, except atomic:\n\n``` zig\nfn cmpxchgWeakButNotAtomic(comptime T: type, ptr: *T, expected_value: T, new_value: T) ?T {\n    const old_value = ptr.*;\n    if (old_value == expected_value and usuallyTrueButSometimesFalse()) {\n        ptr.* = new_value;\n        return null;\n    } else {\n        return old_value;\n    }\n}\n```\n\ncmpxchgWeakButNotAtomic\n\nIf you are using cmpxchg in a retry loop, the sporadic failure will be no problem, and `cmpxchgWeak` is the better choice, because it can be implemented more efficiently in machine instructions. However if you need a stronger guarantee, use [@cmpxchgStrong](#cmpxchgStrong).\n\n`T` must be a pointer, a `bool`, a float, an integer or an enum.\n\n`@typeInfo``(``@TypeOf``(ptr)).Pointer.alignment` must be `>= ``@sizeOf``(T).`\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\nSee also:\n\n- [@atomicStore](#atomicStore)\n- [@atomicLoad](#atomicLoad)\n- [@atomicRmw](#atomicRmw)\n- [@fence](#fence)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n### @compileError\n\n``` zig\n@compileError(comptime msg: []const u8) noreturn\n```\n\nThis function, when semantically analyzed, causes a compile error with the message `msg`.\n\nThere are several ways that code avoids being semantically checked, such as using `if` or `switch` with compile time constants, and `comptime` functions.\n\n### @compileLog\n\n``` zig\n@compileLog(args: ...) void\n```\n\nThis function prints the arguments passed to it at compile-time.\n\nTo prevent accidentally leaving compile log statements in a codebase, a compilation error is added to the build, pointing to the compile log statement. This error prevents code from being generated, but does not otherwise interfere with analysis.\n\nThis function can be used to do \"printf debugging\" on compile-time executing code.\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\nconst num1 = blk: {\n    var val1: i32 = 99;\n    @compileLog(\"comptime val1 = \", val1);\n    val1 = val1 + 1;\n    break :blk val1;\n};\n\ntest \"main\" {\n    @compileLog(\"comptime in main\");\n\n    print(\"Runtime in main, num1 = {}.\\n\", .{num1});\n}\n```\n\ntest_compileLog_builtin.zig\n\n    $ zig test test_compileLog_builtin.zig\n    doc/langref/test_compileLog_builtin.zig:11:5: error: found compile log statement\n        @compileLog(\"comptime in main\");\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_compileLog_builtin.zig:5:5: note: also here\n        @compileLog(\"comptime val1 = \", val1);\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Compile Log Output:\n    @as(*const [16:0]u8, \"comptime in main\")\n    @as(*const [16:0]u8, \"comptime val1 = \"), @as(i32, 99)\n\nShell\n\n### @constCast\n\n``` zig\n@constCast(value: anytype) DestType\n```\n\nRemove `const` qualifier from a pointer.\n\n### @ctz\n\n``` zig\n@ctz(operand: anytype) anytype\n```\n\n`@TypeOf``(operand)` must be an integer type or an integer vector type.\n\n`operand` may be an [integer](#Integers) or [vector](#Vectors).\n\nCounts the number of least-significant (trailing in a big-endian sense) zeroes in an integer - \"count trailing zeroes\".\n\nIf `operand` is a [comptime](#comptime)-known integer, the return type is `comptime_int`. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.\n\nIf `operand` is zero, `@ctz` returns the bit width of integer type `T`.\n\nSee also:\n\n- [@clz](#clz)\n- [@popCount](#popCount)\n\n### @cUndef\n\n``` zig\n@cUndef(comptime name: []const u8) void\n```\n\nThis function can only occur inside `@cImport`.\n\nThis appends `#undef $name` to the `@cImport` temporary buffer.\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cImport](#cImport)\n- [@cDefine](#cDefine)\n- [@cInclude](#cInclude)\n\n### @cVaArg\n\n``` zig\n@cVaArg(operand: *std.builtin.VaList, comptime T: type) T\n```\n\nImplements the C macro `va_arg`.\n\nSee also:\n\n- [@cVaCopy](#cVaCopy)\n- [@cVaEnd](#cVaEnd)\n- [@cVaStart](#cVaStart)\n\n### @cVaCopy\n\n``` zig\n@cVaCopy(src: *std.builtin.VaList) std.builtin.VaList\n```\n\nImplements the C macro `va_copy`.\n\nSee also:\n\n- [@cVaArg](#cVaArg)\n- [@cVaEnd](#cVaEnd)\n- [@cVaStart](#cVaStart)\n\n### @cVaEnd\n\n``` zig\n@cVaEnd(src: *std.builtin.VaList) void\n```\n\nImplements the C macro `va_end`.\n\nSee also:\n\n- [@cVaArg](#cVaArg)\n- [@cVaCopy](#cVaCopy)\n- [@cVaStart](#cVaStart)\n\n### @cVaStart\n\n``` zig\n@cVaStart() std.builtin.VaList\n```\n\nImplements the C macro `va_start`. Only valid inside a variadic function.\n\nSee also:\n\n- [@cVaArg](#cVaArg)\n- [@cVaCopy](#cVaCopy)\n- [@cVaEnd](#cVaEnd)\n\n### @divExact\n\n``` zig\n@divExact(numerator: T, denominator: T) T\n```\n\nExact division. Caller guarantees `denominator != ``0` and `@divTrunc``(numerator, denominator) * denominator == numerator`.\n\n- `@divExact``(``6``, ``3``) == ``2`\n- `@divExact``(a, b) * b == a`\n\nFor a function that returns a possible error code, use `@import``(``\"std\"``).math.divExact`.\n\nSee also:\n\n- [@divTrunc](#divTrunc)\n- [@divFloor](#divFloor)\n\n### @divFloor\n\n``` zig\n@divFloor(numerator: T, denominator: T) T\n```\n\nFloored division. Rounds toward negative infinity. For unsigned integers it is the same as `numerator / denominator`. Caller guarantees `denominator != ``0` and `!(``@typeInfo``(T) == .Int ``and`` T.is_signed ``and`` numerator == std.math.minInt(T) ``and`` denominator == -``1``)`.\n\n- `@divFloor``(-``5``, ``3``) == -``2`\n- `(``@divFloor``(a, b) * b) + ``@mod``(a, b) == a`\n\nFor a function that returns a possible error code, use `@import``(``\"std\"``).math.divFloor`.\n\nSee also:\n\n- [@divTrunc](#divTrunc)\n- [@divExact](#divExact)\n\n### @divTrunc\n\n``` zig\n@divTrunc(numerator: T, denominator: T) T\n```\n\nTruncated division. Rounds toward zero. For unsigned integers it is the same as `numerator / denominator`. Caller guarantees `denominator != ``0` and `!(``@typeInfo``(T) == .Int ``and`` T.is_signed ``and`` numerator == std.math.minInt(T) ``and`` denominator == -``1``)`.\n\n- `@divTrunc``(-``5``, ``3``) == -``1`\n- `(``@divTrunc``(a, b) * b) + ``@rem``(a, b) == a`\n\nFor a function that returns a possible error code, use `@import``(``\"std\"``).math.divTrunc`.\n\nSee also:\n\n- [@divFloor](#divFloor)\n- [@divExact](#divExact)\n\n### @embedFile\n\n``` zig\n@embedFile(comptime path: []const u8) *const [N:0]u8\n```\n\nThis function returns a compile time constant pointer to null-terminated, fixed-size array with length equal to the byte count of the file given by `path`. The contents of the array are the contents of the file. This is equivalent to a [string literal](#String-Literals-and-Unicode-Code-Point-Literals) with the file contents.\n\n`path` is absolute or relative to the current file, just like `@import`.\n\nSee also:\n\n- [@import](#import)\n\n### @enumFromInt\n\n``` zig\n@enumFromInt(integer: anytype) anytype\n```\n\nConverts an integer into an [enum](#enum) value. The return type is the inferred result type.\n\nAttempting to convert an integer which represents no value in the chosen enum type invokes safety-checked [Undefined Behavior](#Undefined-Behavior).\n\nSee also:\n\n- [@intFromEnum](#intFromEnum)\n\n### @errorFromInt\n\n``` zig\n@errorFromInt(value: std.meta.Int(.unsigned, @bitSizeOf(anyerror))) anyerror\n```\n\nConverts from the integer representation of an error into [The Global Error Set](#The-Global-Error-Set) type.\n\nIt is generally recommended to avoid this cast, as the integer representation of an error is not stable across source code changes.\n\nAttempting to convert an integer that does not correspond to any error results in safety-protected [Undefined Behavior](#Undefined-Behavior).\n\nSee also:\n\n- [@intFromError](#intFromError)\n\n### @errorName\n\n``` zig\n@errorName(err: anyerror) [:0]const u8\n```\n\nThis function returns the string representation of an error. The string representation of `error``.OutOfMem` is `\"OutOfMem\"`.\n\nIf there are no calls to `@errorName` in an entire application, or all calls have a compile-time known value for `err`, then no error name table will be generated.\n\n### @errorReturnTrace\n\n``` zig\n@errorReturnTrace() ?*builtin.StackTrace\n```\n\nIf the binary is built with error return tracing, and this function is invoked in a function that calls a function with an error or error union return type, returns a stack trace object. Otherwise returns [null](#null).\n\n### @errorCast\n\n``` zig\n@errorCast(value: anytype) anytype\n```\n\nConverts an error set or error union value from one error set to another error set. The return type is the inferred result type. Attempting to convert an error which is not in the destination error set results in safety-protected [Undefined Behavior](#Undefined-Behavior).\n\n### @export\n\n``` zig\n@export(declaration, comptime options: std.builtin.ExportOptions) void\n```\n\nCreates a symbol in the output object file.\n\n`declaration` must be one of two things:\n\n- An identifier (`x`) identifying a [function](#Functions) or a [variable](#Container-Level-Variables).\n- Field access (`x.y`) looking up a [function](#Functions) or a [variable](#Container-Level-Variables).\n\nThis builtin can be called from a [comptime](#comptime) block to conditionally export symbols. When `declaration` is a function with the C calling convention and `options.linkage` is `Strong`, this is equivalent to the `export` keyword used on a function:\n\n``` zig\ncomptime {\n    @export(internalName, .{ .name = \"foo\", .linkage = .strong });\n}\n\nfn internalName() callconv(.C) void {}\n```\n\nexport_builtin.zig\n\n    $ zig build-obj export_builtin.zig\n\nShell\n\nThis is equivalent to:\n\n``` zig\nexport fn foo() void {}\n```\n\nexport_builtin_equivalent_code.zig\n\n    $ zig build-obj export_builtin_equivalent_code.zig\n\nShell\n\nNote that even when using `export`, the `@\"foo\"` syntax for [identifiers](#Identifiers) can be used to choose any string for the symbol name:\n\n``` zig\nexport fn @\"A function name that is a complete sentence.\"() void {}\n```\n\nexport_any_symbol_name.zig\n\n    $ zig build-obj export_any_symbol_name.zig\n\nShell\n\nWhen looking at the resulting object, you can see the symbol is used verbatim:\n\n``` zig\n00000000000001f0 T A function name that is a complete sentence.\n```\n\nSee also:\n\n- [Exporting a C Library](#Exporting-a-C-Library)\n\n### @extern\n\n``` zig\n@extern(T: type, comptime options: std.builtin.ExternOptions) T\n```\n\nCreates a reference to an external symbol in the output object file. T must be a pointer type.\n\nSee also:\n\n- [@export](#export)\n\n### @fence\n\n``` zig\n@fence(order: AtomicOrder) void\n```\n\nThe `fence` function is used to introduce happens-before edges between operations.\n\n`AtomicOrder` can be found with `@import``(``\"std\"``).builtin.AtomicOrder`.\n\nSee also:\n\n- [@atomicStore](#atomicStore)\n- [@atomicLoad](#atomicLoad)\n- [@atomicRmw](#atomicRmw)\n- [@cmpxchgWeak](#cmpxchgWeak)\n- [@cmpxchgStrong](#cmpxchgStrong)\n\n### @field\n\n``` zig\n@field(lhs: anytype, comptime field_name: []const u8) (field)\n```\n\nPerforms field access by a compile-time string. Works on both fields and declarations.\n\n``` zig\nconst std = @import(\"std\");\n\nconst Point = struct {\n    x: u32,\n    y: u32,\n\n    pub var z: u32 = 1;\n};\n\ntest \"field access by string\" {\n    const expect = std.testing.expect;\n    var p = Point{ .x = 0, .y = 0 };\n\n    @field(p, \"x\") = 4;\n    @field(p, \"y\") = @field(p, \"x\") + 1;\n\n    try expect(@field(p, \"x\") == 4);\n    try expect(@field(p, \"y\") == 5);\n}\n\ntest \"decl access by string\" {\n    const expect = std.testing.expect;\n\n    try expect(@field(Point, \"z\") == 1);\n\n    @field(Point, \"z\") = 2;\n    try expect(@field(Point, \"z\") == 2);\n}\n```\n\ntest_field_builtin.zig\n\n    $ zig test test_field_builtin.zig\n    1/2 test_field_builtin.test.field access by string...OK\n    2/2 test_field_builtin.test.decl access by string...OK\n    All 2 tests passed.\n\nShell\n\n### @fieldParentPtr\n\n``` zig\n@fieldParentPtr(comptime field_name: []const u8, field_ptr: *T) anytype\n```\n\nGiven a pointer to a field, returns the base pointer of a struct.\n\n### @floatCast\n\n``` zig\n@floatCast(value: anytype) anytype\n```\n\nConvert from one float type to another. This cast is safe, but may cause the numeric value to lose precision. The return type is the inferred result type.\n\n### @floatFromInt\n\n``` zig\n@floatFromInt(int: anytype) anytype\n```\n\nConverts an integer to the closest floating point representation. The return type is the inferred result type. To convert the other way, use [@intFromFloat](#intFromFloat). This operation is legal for all values of all integer types.\n\n### @frameAddress\n\n``` zig\n@frameAddress() usize\n```\n\nThis function returns the base pointer of the current stack frame.\n\nThe implications of this are target-specific and not consistent across all platforms. The frame address may not be available in release mode due to aggressive optimizations.\n\nThis function is only valid within function scope.\n\n### @hasDecl\n\n``` zig\n@hasDecl(comptime Container: type, comptime name: []const u8) bool\n```\n\nReturns whether or not a [container](#Containers) has a declaration matching `name`.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\nconst Foo = struct {\n    nope: i32,\n\n    pub var blah = \"xxx\";\n    const hi = 1;\n};\n\ntest \"@hasDecl\" {\n    try expect(@hasDecl(Foo, \"blah\"));\n\n    // Even though `hi` is private, @hasDecl returns true because this test is\n    // in the same file scope as Foo. It would return false if Foo was declared\n    // in a different file.\n    try expect(@hasDecl(Foo, \"hi\"));\n\n    // @hasDecl is for declarations; not fields.\n    try expect(!@hasDecl(Foo, \"nope\"));\n    try expect(!@hasDecl(Foo, \"nope1234\"));\n}\n```\n\ntest_hasDecl_builtin.zig\n\n    $ zig test test_hasDecl_builtin.zig\n    1/1 test_hasDecl_builtin.test.@hasDecl...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [@hasField](#hasField)\n\n### @hasField\n\n``` zig\n@hasField(comptime Container: type, comptime name: []const u8) bool\n```\n\nReturns whether the field name of a struct, union, or enum exists.\n\nThe result is a compile time constant.\n\nIt does not include functions, variables, or constants.\n\nSee also:\n\n- [@hasDecl](#hasDecl)\n\n### @import\n\n``` zig\n@import(comptime path: []const u8) type\n```\n\nThis function finds a zig file corresponding to `path` and adds it to the build, if it is not already added.\n\nZig source files are implicitly structs, with a name equal to the file's basename with the extension truncated. `@import` returns the struct type corresponding to the file.\n\nDeclarations which have the `pub` keyword may be referenced from a different source file than the one they are declared in.\n\n`path` can be a relative path or it can be the name of a package. If it is a relative path, it is relative to the file that contains the `@import` function call.\n\nThe following packages are always available:\n\n- `@import``(``\"std\"``)` - Zig Standard Library\n- `@import``(``\"builtin\"``)` - Target-specific information The command `zig build-exe --show-builtin` outputs the source to stdout for reference.\n- `@import``(``\"root\"``)` - Root source file This is usually `src/main.zig` but depends on what file is built.\n\nSee also:\n\n- [Compile Variables](#Compile-Variables)\n- [@embedFile](#embedFile)\n\n### @inComptime\n\n``` zig\n@inComptime() bool\n```\n\nReturns whether the builtin was run in a `comptime` context. The result is a compile-time constant.\n\nThis can be used to provide alternative, comptime-friendly implementations of functions. It should not be used, for instance, to exclude certain functions from being evaluated at comptime.\n\nSee also:\n\n- [comptime](#comptime)\n\n### @intCast\n\n``` zig\n@intCast(int: anytype) anytype\n```\n\nConverts an integer to another integer while keeping the same numerical value. The return type is the inferred result type. Attempting to convert a number which is out of range of the destination type results in safety-protected [Undefined Behavior](#Undefined-Behavior).\n\n``` zig\ntest \"integer cast panic\" {\n    var a: u16 = 0xabcd; // runtime-known\n    _ = &a;\n    const b: u8 = @intCast(a);\n    _ = b;\n}\n```\n\ntest_intCast_builtin.zig\n\n    $ zig test test_intCast_builtin.zig\n    1/1 test_intCast_builtin.test.integer cast panic...thread 3573820 panic: integer cast truncated bits\n    /home/andy/src/zig/doc/langref/test_intCast_builtin.zig:4:19: 0x103ce6b in test.integer cast panic (test)\n        const b: u8 = @intCast(a);\n                      ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048290 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e24b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d389 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cef1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/a3b6539437d55800e891e62090700351/test\n\nShell\n\nTo truncate the significant bits of a number out of range of the destination type, use [@truncate](#truncate).\n\nIf `T` is `comptime_int`, then this is semantically equivalent to [Type Coercion](#Type-Coercion).\n\n### @intFromBool\n\n``` zig\n@intFromBool(value: bool) u1\n```\n\nConverts `true` to `@as``(``u1``, ``1``)` and `false` to `@as``(``u1``, ``0``)`.\n\n### @intFromEnum\n\n``` zig\n@intFromEnum(enum_or_tagged_union: anytype) anytype\n```\n\nConverts an enumeration value into its integer tag type. When a tagged union is passed, the tag value is used as the enumeration value.\n\nIf there is only one possible enum value, the result is a `comptime_int` known at [comptime](#comptime).\n\nSee also:\n\n- [@enumFromInt](#enumFromInt)\n\n### @intFromError\n\n``` zig\n@intFromError(err: anytype) std.meta.Int(.unsigned, @bitSizeOf(anyerror))\n```\n\nSupports the following types:\n\n- [The Global Error Set](#The-Global-Error-Set)\n- [Error Set Type](#Error-Set-Type)\n- [Error Union Type](#Error-Union-Type)\n\nConverts an error to the integer representation of an error.\n\nIt is generally recommended to avoid this cast, as the integer representation of an error is not stable across source code changes.\n\nSee also:\n\n- [@errorFromInt](#errorFromInt)\n\n### @intFromFloat\n\n``` zig\n@intFromFloat(float: anytype) anytype\n```\n\nConverts the integer part of a floating point number to the inferred result type.\n\nIf the integer part of the floating point number cannot fit in the destination type, it invokes safety-checked [Undefined Behavior](#Undefined-Behavior).\n\nSee also:\n\n- [@floatFromInt](#floatFromInt)\n\n### @intFromPtr\n\n``` zig\n@intFromPtr(value: anytype) usize\n```\n\nConverts `value` to a `usize` which is the address of the pointer. `value` can be `*T` or `?*T`.\n\nTo convert the other way, use [@ptrFromInt](#ptrFromInt)\n\n### @max\n\n``` zig\n@max(a: T, b: T) T\n```\n\nReturns the maximum value of `a` and `b`. This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise.\n\nNaNs are handled as follows: if one of the operands of a (pairwise) operation is NaN, the other operand is returned. If both operands are NaN, NaN is returned.\n\nSee also:\n\n- [@min](#min)\n- [Vectors](#Vectors)\n\n### @memcpy\n\n``` zig\n@memcpy(noalias dest, noalias source) void\n```\n\nThis function copies bytes from one region of memory to another.\n\n`dest` must be a mutable slice, a mutable pointer to an array, or a mutable many-item [pointer](#Pointers). It may have any alignment, and it may have any element type.\n\n`source` must be a slice, a pointer to an array, or a many-item [pointer](#Pointers). It may have any alignment, and it may have any element type.\n\nThe `source` element type must support [Type Coercion](#Type-Coercion) into the `dest` element type. The element types may have different ABI size, however, that may incur a performance penalty.\n\nSimilar to [for](#for) loops, at least one of `source` and `dest` must provide a length, and if two lengths are provided, they must be equal.\n\nFinally, the two memory regions must not overlap.\n\n### @memset\n\n``` zig\n@memset(dest, elem) void\n```\n\nThis function sets all the elements of a memory region to `elem`.\n\n`dest` must be a mutable slice or a mutable pointer to an array. It may have any alignment, and it may have any element type.\n\n`elem` is coerced to the element type of `dest`.\n\nFor securely zeroing out sensitive contents from memory, you should use `std.crypto.utils.secureZero`\n\n### @min\n\n``` zig\n@min(a: T, b: T) T\n```\n\nReturns the minimum value of `a` and `b`. This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise.\n\nNaNs are handled as follows: if one of the operands of a (pairwise) operation is NaN, the other operand is returned. If both operands are NaN, NaN is returned.\n\nSee also:\n\n- [@max](#max)\n- [Vectors](#Vectors)\n\n### @wasmMemorySize\n\n``` zig\n@wasmMemorySize(index: u32) usize\n```\n\nThis function returns the size of the Wasm memory identified by `index` as an unsigned value in units of Wasm pages. Note that each Wasm page is 64KB in size.\n\nThis function is a low level intrinsic with no safety mechanisms usually useful for allocator designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use something like `@import``(``\"std\"``).heap.WasmPageAllocator`.\n\nSee also:\n\n- [@wasmMemoryGrow](#wasmMemoryGrow)\n\n### @wasmMemoryGrow\n\n``` zig\n@wasmMemoryGrow(index: u32, delta: usize) isize\n```\n\nThis function increases the size of the Wasm memory identified by `index` by `delta` in units of unsigned number of Wasm pages. Note that each Wasm page is 64KB in size. On success, returns previous memory size; on failure, if the allocation fails, returns -1.\n\nThis function is a low level intrinsic with no safety mechanisms usually useful for allocator designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use something like `@import``(``\"std\"``).heap.WasmPageAllocator`.\n\n``` zig\nconst std = @import(\"std\");\nconst native_arch = @import(\"builtin\").target.cpu.arch;\nconst expect = std.testing.expect;\n\ntest \"@wasmMemoryGrow\" {\n    if (native_arch != .wasm32) return error.SkipZigTest;\n\n    const prev = @wasmMemorySize(0);\n    try expect(prev == @wasmMemoryGrow(0, 1));\n    try expect(prev + 1 == @wasmMemorySize(0));\n}\n```\n\ntest_wasmMemoryGrow_builtin.zig\n\n    $ zig test test_wasmMemoryGrow_builtin.zig\n    1/1 test_wasmMemoryGrow_builtin.test.@wasmMemoryGrow...SKIP\n    0 passed; 1 skipped; 0 failed.\n\nShell\n\nSee also:\n\n- [@wasmMemorySize](#wasmMemorySize)\n\n### @mod\n\n``` zig\n@mod(numerator: T, denominator: T) T\n```\n\nModulus division. For unsigned integers this is the same as `numerator % denominator`. Caller guarantees `denominator > ``0`, otherwise the operation will result in a [Remainder Division by Zero](#Remainder-Division-by-Zero) when runtime safety checks are enabled.\n\n- `@mod``(-``5``, ``3``) == ``1`\n- `(``@divFloor``(a, b) * b) + ``@mod``(a, b) == a`\n\nFor a function that returns an error code, see `@import``(``\"std\"``).math.mod`.\n\nSee also:\n\n- [@rem](#rem)\n\n### @mulWithOverflow\n\n``` zig\n@mulWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }\n```\n\nPerforms `a * b` and returns a tuple with the result and a possible overflow bit.\n\n### @panic\n\n``` zig\n@panic(message: []const u8) noreturn\n```\n\nInvokes the panic handler function. By default the panic handler function calls the public `panic` function exposed in the root source file, or if there is not one specified, the `std.builtin.default_panic` function from `std/builtin.zig`.\n\nGenerally it is better to use `@import``(``\"std\"``).debug.panic`. However, `@panic` can be useful for 2 scenarios:\n\n- From library code, calling the programmer's panic function if they exposed one in the root source file.\n- When mixing C and Zig code, calling the canonical panic implementation across multiple .o files.\n\nSee also:\n\n- [Root Source File](#Root-Source-File)\n\n### @popCount\n\n``` zig\n@popCount(operand: anytype) anytype\n```\n\n`@TypeOf``(operand)` must be an integer type.\n\n`operand` may be an [integer](#Integers) or [vector](#Vectors).\n\nCounts the number of bits set in an integer - \"population count\".\n\nIf `operand` is a [comptime](#comptime)-known integer, the return type is `comptime_int`. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.\n\nSee also:\n\n- [@ctz](#ctz)\n- [@clz](#clz)\n\n### @prefetch\n\n``` zig\n@prefetch(ptr: anytype, comptime options: PrefetchOptions) void\n```\n\nThis builtin tells the compiler to emit a prefetch instruction if supported by the target CPU. If the target CPU does not support the requested prefetch instruction, this builtin is a no-op. This function has no effect on the behavior of the program, only on the performance characteristics.\n\nThe `ptr` argument may be any pointer type and determines the memory address to prefetch. This function does not dereference the pointer, it is perfectly legal to pass a pointer to invalid memory to this function and no illegal behavior will result.\n\n`PrefetchOptions` can be found with `@import``(``\"std\"``).builtin.PrefetchOptions`.\n\n### @ptrCast\n\n``` zig\n@ptrCast(value: anytype) anytype\n```\n\nConverts a pointer of one type to a pointer of another type. The return type is the inferred result type.\n\n[Optional Pointers](#Optional-Pointers) are allowed. Casting an optional pointer which is [null](#null) to a non-optional pointer invokes safety-checked [Undefined Behavior](#Undefined-Behavior).\n\n`@ptrCast` cannot be used for:\n\n- Removing `const` qualifier, use [@constCast](#constCast).\n- Removing `volatile` qualifier, use [@volatileCast](#volatileCast).\n- Changing pointer address space, use [@addrSpaceCast](#addrSpaceCast).\n- Increasing pointer alignment, use [@alignCast](#alignCast).\n- Casting a non-slice pointer to a slice, use slicing syntax `ptr[start..end]`.\n\n### @ptrFromInt\n\n``` zig\n@ptrFromInt(address: usize) anytype\n```\n\nConverts an integer to a [pointer](#Pointers). The return type is the inferred result type. To convert the other way, use [@intFromPtr](#intFromPtr). Casting an address of 0 to a destination type which in not [optional](#Optional-Pointers) and does not have the `allowzero` attribute will result in a [Pointer Cast Invalid Null](#Pointer-Cast-Invalid-Null) panic when runtime safety checks are enabled.\n\nIf the destination pointer type does not allow address zero and `address` is zero, this invokes safety-checked [Undefined Behavior](#Undefined-Behavior).\n\n### @rem\n\n``` zig\n@rem(numerator: T, denominator: T) T\n```\n\nRemainder division. For unsigned integers this is the same as `numerator % denominator`. Caller guarantees `denominator > ``0`, otherwise the operation will result in a [Remainder Division by Zero](#Remainder-Division-by-Zero) when runtime safety checks are enabled.\n\n- `@rem``(-``5``, ``3``) == -``2`\n- `(``@divTrunc``(a, b) * b) + ``@rem``(a, b) == a`\n\nFor a function that returns an error code, see `@import``(``\"std\"``).math.rem`.\n\nSee also:\n\n- [@mod](#mod)\n\n### @returnAddress\n\n``` zig\n@returnAddress() usize\n```\n\nThis function returns the address of the next machine code instruction that will be executed when the current function returns.\n\nThe implications of this are target-specific and not consistent across all platforms.\n\nThis function is only valid within function scope. If the function gets inlined into a calling function, the returned address will apply to the calling function.\n\n### @select\n\n``` zig\n@select(comptime T: type, pred: @Vector(len, bool), a: @Vector(len, T), b: @Vector(len, T)) @Vector(len, T)\n```\n\nSelects values element-wise from `a` or `b` based on `pred`. If `pred[i]` is `true`, the corresponding element in the result will be `a[i]` and otherwise `b[i]`.\n\nSee also:\n\n- [Vectors](#Vectors)\n\n### @setAlignStack\n\n``` zig\n@setAlignStack(comptime alignment: u29) void\n```\n\nEnsures that a function will have a stack alignment of at least `alignment` bytes.\n\n### @setCold\n\n``` zig\n@setCold(comptime is_cold: bool) void\n```\n\nTells the optimizer that the current function is (or is not) rarely called. This function is only valid within function scope.\n\n### @setEvalBranchQuota\n\n``` zig\n@setEvalBranchQuota(comptime new_quota: u32) void\n```\n\nIncrease the maximum number of backwards branches that compile-time code execution can use before giving up and making a compile error.\n\nIf the `new_quota` is smaller than the default quota (`1000`) or a previously explicitly set quota, it is ignored.\n\nExample:\n\n``` zig\ntest \"foo\" {\n    comptime {\n        var i = 0;\n        while (i < 1001) : (i += 1) {}\n    }\n}\n```\n\ntest_without_setEvalBranchQuota_builtin.zig\n\n    $ zig test test_without_setEvalBranchQuota_builtin.zig\n    doc/langref/test_without_setEvalBranchQuota_builtin.zig:4:9: error: evaluation exceeded 1000 backwards branches\n            while (i < 1001) : (i += 1) {}\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    doc/langref/test_without_setEvalBranchQuota_builtin.zig:4:9: note: use @setEvalBranchQuota() to raise the branch limit from 1000\n\nShell\n\nNow we use `@setEvalBranchQuota`:\n\n``` zig\ntest \"foo\" {\n    comptime {\n        @setEvalBranchQuota(1001);\n        var i = 0;\n        while (i < 1001) : (i += 1) {}\n    }\n}\n```\n\ntest_setEvalBranchQuota_builtin.zig\n\n    $ zig test test_setEvalBranchQuota_builtin.zig\n    1/1 test_setEvalBranchQuota_builtin.test.foo...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [comptime](#comptime)\n\n### @setFloatMode\n\n``` zig\n@setFloatMode(comptime mode: FloatMode) void\n```\n\nChanges the current scope's rules about how floating point operations are defined.\n\n- `Strict` (default) - Floating point operations follow strict IEEE compliance.\n- `Optimized` - Floating point operations may do all of the following:\n  - Assume the arguments and result are not NaN. Optimizations are required to retain defined behavior over NaNs, but the value of the result is undefined.\n  - Assume the arguments and result are not +/-Inf. Optimizations are required to retain defined behavior over +/-Inf, but the value of the result is undefined.\n  - Treat the sign of a zero argument or result as insignificant.\n  - Use the reciprocal of an argument rather than perform division.\n  - Perform floating-point contraction (e.g. fusing a multiply followed by an addition into a fused multiply-add).\n  - Perform algebraically equivalent transformations that may change results in floating point (e.g. reassociate).\n\n  This is equivalent to `-ffast-math` in GCC.\n\nThe floating point mode is inherited by child scopes, and can be overridden in any scope. You can set the floating point mode in a struct or module scope by using a comptime block.\n\n`FloatMode` can be found with `@import``(``\"std\"``).builtin.FloatMode`.\n\nSee also:\n\n- [Floating Point Operations](#Floating-Point-Operations)\n\n### @setRuntimeSafety\n\n``` zig\n@setRuntimeSafety(comptime safety_on: bool) void\n```\n\nSets whether runtime safety checks are enabled for the scope that contains the function call.\n\n``` zig\ntest \"@setRuntimeSafety\" {\n    // The builtin applies to the scope that it is called in. So here, integer overflow\n    // will not be caught in ReleaseFast and ReleaseSmall modes:\n    // var x: u8 = 255;\n    // x += 1; // undefined behavior in ReleaseFast/ReleaseSmall modes.\n    {\n        // However this block has safety enabled, so safety checks happen here,\n        // even in ReleaseFast and ReleaseSmall modes.\n        @setRuntimeSafety(true);\n        var x: u8 = 255;\n        x += 1;\n\n        {\n            // The value can be overridden at any scope. So here integer overflow\n            // would not be caught in any build mode.\n            @setRuntimeSafety(false);\n            // var x: u8 = 255;\n            // x += 1; // undefined behavior in all build modes.\n        }\n    }\n}\n```\n\ntest_setRuntimeSafety_builtin.zig\n\n    $ zig test test_setRuntimeSafety_builtin.zig -OReleaseFast\n    1/1 test_setRuntimeSafety_builtin.test.@setRuntimeSafety...thread 3579742 panic: integer overflow\n    /home/andy/src/zig/doc/langref/test_setRuntimeSafety_builtin.zig:11:11: 0x100ae54 in test.@setRuntimeSafety (test)\n            x += 1;\n              ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x100c9b0 in main (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x100af44 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x100ae71 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/7c74a2939d84ddd0f45519d7a9f1c0f7/test\n\nShell\n\nNote: it is [planned](https://github.com/ziglang/zig/issues/978) to replace `@setRuntimeSafety` with `@optimizeFor`\n\n### @shlExact\n\n``` zig\n@shlExact(value: T, shift_amt: Log2T) T\n```\n\nPerforms the left shift operation (`<<`). For unsigned integers, the result is [undefined](#undefined) if any 1 bits are shifted out. For signed integers, the result is [undefined](#undefined) if any bits that disagree with the resultant sign bit are shifted out.\n\nThe type of `shift_amt` is an unsigned integer with `log2(``@typeInfo``(T).Int.bits)` bits. This is because `shift_amt >= ``@typeInfo``(T).Int.bits` is undefined behavior.\n\n`comptime_int` is modeled as an integer with an infinite number of bits, meaning that in such case, `@shlExact` always produces a result and cannot produce a compile error.\n\nSee also:\n\n- [@shrExact](#shrExact)\n- [@shlWithOverflow](#shlWithOverflow)\n\n### @shlWithOverflow\n\n``` zig\n@shlWithOverflow(a: anytype, shift_amt: Log2T) struct { @TypeOf(a), u1 }\n```\n\nPerforms `a << b` and returns a tuple with the result and a possible overflow bit.\n\nThe type of `shift_amt` is an unsigned integer with `log2(``@typeInfo``(``@TypeOf``(a)).Int.bits)` bits. This is because `shift_amt >= ``@typeInfo``(``@TypeOf``(a)).Int.bits` is undefined behavior.\n\nSee also:\n\n- [@shlExact](#shlExact)\n- [@shrExact](#shrExact)\n\n### @shrExact\n\n``` zig\n@shrExact(value: T, shift_amt: Log2T) T\n```\n\nPerforms the right shift operation (`>>`). Caller guarantees that the shift will not shift any 1 bits out.\n\nThe type of `shift_amt` is an unsigned integer with `log2(``@typeInfo``(T).Int.bits)` bits. This is because `shift_amt >= ``@typeInfo``(T).Int.bits` is undefined behavior.\n\nSee also:\n\n- [@shlExact](#shlExact)\n- [@shlWithOverflow](#shlWithOverflow)\n\n### @shuffle\n\n``` zig\n@shuffle(comptime E: type, a: @Vector(a_len, E), b: @Vector(b_len, E), comptime mask: @Vector(mask_len, i32)) @Vector(mask_len, E)\n```\n\nConstructs a new [vector](#Vectors) by selecting elements from `a` and `b` based on `mask`.\n\nEach element in `mask` selects an element from either `a` or `b`. Positive numbers select from `a` starting at 0. Negative values select from `b`, starting at `-``1` and going down. It is recommended to use the `~` operator for indexes from `b` so that both indexes can start from `0` (i.e. `~``@as``(``i32``, ``0``)` is `-``1`).\n\nFor each element of `mask`, if it or the selected value from `a` or `b` is `undefined`, then the resulting element is `undefined`.\n\n`a_len` and `b_len` may differ in length. Out-of-bounds element indexes in `mask` result in compile errors.\n\nIf `a` or `b` is `undefined`, it is equivalent to a vector of all `undefined` with the same length as the other vector. If both vectors are `undefined`, `@shuffle` returns a vector with all elements `undefined`.\n\n`E` must be an [integer](#Integers), [float](#Floats), [pointer](#Pointers), or `bool`. The mask may be any vector length, and its length determines the result length.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"vector @shuffle\" {\n    const a = @Vector(7, u8){ 'o', 'l', 'h', 'e', 'r', 'z', 'w' };\n    const b = @Vector(4, u8){ 'w', 'd', '!', 'x' };\n\n    // To shuffle within a single vector, pass undefined as the second argument.\n    // Notice that we can re-order, duplicate, or omit elements of the input vector\n    const mask1 = @Vector(5, i32){ 2, 3, 1, 1, 0 };\n    const res1: @Vector(5, u8) = @shuffle(u8, a, undefined, mask1);\n    try expect(std.mem.eql(u8, &@as([5]u8, res1), \"hello\"));\n\n    // Combining two vectors\n    const mask2 = @Vector(6, i32){ -1, 0, 4, 1, -2, -3 };\n    const res2: @Vector(6, u8) = @shuffle(u8, a, b, mask2);\n    try expect(std.mem.eql(u8, &@as([6]u8, res2), \"world!\"));\n}\n```\n\ntest_shuffle_builtin.zig\n\n    $ zig test test_shuffle_builtin.zig\n    1/1 test_shuffle_builtin.test.vector @shuffle...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [Vectors](#Vectors)\n\n### @sizeOf\n\n``` zig\n@sizeOf(comptime T: type) comptime_int\n```\n\nThis function returns the number of bytes it takes to store `T` in memory. The result is a target-specific compile time constant.\n\nThis size may contain padding bytes. If there were two consecutive T in memory, the padding would be the offset in bytes between element at index 0 and the element at index 1. For [integer](#Integers), consider whether you want to use `@sizeOf``(T)` or `@typeInfo``(T).Int.bits`.\n\nThis function measures the size at runtime. For types that are disallowed at runtime, such as `comptime_int` and `type`, the result is `0`.\n\nSee also:\n\n- [@bitSizeOf](#bitSizeOf)\n- [@typeInfo](#typeInfo)\n\n### @splat\n\n``` zig\n@splat(scalar: anytype) anytype\n```\n\nProduces a vector where each element is the value `scalar`. The return type and thus the length of the vector is inferred.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"vector @splat\" {\n    const scalar: u32 = 5;\n    const result: @Vector(4, u32) = @splat(scalar);\n    try expect(std.mem.eql(u32, &@as([4]u32, result), &[_]u32{ 5, 5, 5, 5 }));\n}\n```\n\ntest_splat_builtin.zig\n\n    $ zig test test_splat_builtin.zig\n    1/1 test_splat_builtin.test.vector @splat...OK\n    All 1 tests passed.\n\nShell\n\n`scalar` must be an [integer](#Integers), [bool](#Primitive-Types), [float](#Floats), or [pointer](#Pointers).\n\nSee also:\n\n- [Vectors](#Vectors)\n- [@shuffle](#shuffle)\n\n### @reduce\n\n``` zig\n@reduce(comptime op: std.builtin.ReduceOp, value: anytype) E\n```\n\nTransforms a [vector](#Vectors) into a scalar value (of type `E`) by performing a sequential horizontal reduction of its elements using the specified operator `op`.\n\nNot every operator is available for every vector element type:\n\n- Every operator is available for [integer](#Integers) vectors.\n- `.And`, `.Or`, `.Xor` are additionally available for `bool` vectors,\n- `.Min`, `.Max`, `.Add`, `.Mul` are additionally available for [floating point](#Floats) vectors,\n\nNote that `.Add` and `.Mul` reductions on integral types are wrapping; when applied on floating point types the operation associativity is preserved, unless the float mode is set to `Optimized`.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"vector @reduce\" {\n    const V = @Vector(4, i32);\n    const value = V{ 1, -1, 1, -1 };\n    const result = value > @as(V, @splat(0));\n    // result is { true, false, true, false };\n    try comptime expect(@TypeOf(result) == @Vector(4, bool));\n    const is_all_true = @reduce(.And, result);\n    try comptime expect(@TypeOf(is_all_true) == bool);\n    try expect(is_all_true == false);\n}\n```\n\ntest_reduce_builtin.zig\n\n    $ zig test test_reduce_builtin.zig\n    1/1 test_reduce_builtin.test.vector @reduce...OK\n    All 1 tests passed.\n\nShell\n\nSee also:\n\n- [Vectors](#Vectors)\n- [@setFloatMode](#setFloatMode)\n\n### @src\n\n``` zig\n@src() std.builtin.SourceLocation\n```\n\nReturns a `SourceLocation` struct representing the function's name and location in the source code. This must be called in a function.\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"@src\" {\n    try doTheTest();\n}\n\nfn doTheTest() !void {\n    const src = @src();\n\n    try expect(src.line == 9);\n    try expect(src.column == 17);\n    try expect(std.mem.endsWith(u8, src.fn_name, \"doTheTest\"));\n    try expect(std.mem.endsWith(u8, src.file, \"test_src_builtin.zig\"));\n}\n```\n\ntest_src_builtin.zig\n\n    $ zig test test_src_builtin.zig\n    1/1 test_src_builtin.test.@src...OK\n    All 1 tests passed.\n\nShell\n\n### @sqrt\n\n``` zig\n@sqrt(value: anytype) @TypeOf(value)\n```\n\nPerforms the square root of a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @sin\n\n``` zig\n@sin(value: anytype) @TypeOf(value)\n```\n\nSine trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @cos\n\n``` zig\n@cos(value: anytype) @TypeOf(value)\n```\n\nCosine trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @tan\n\n``` zig\n@tan(value: anytype) @TypeOf(value)\n```\n\nTangent trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @exp\n\n``` zig\n@exp(value: anytype) @TypeOf(value)\n```\n\nBase-e exponential function on a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @exp2\n\n``` zig\n@exp2(value: anytype) @TypeOf(value)\n```\n\nBase-2 exponential function on a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @log\n\n``` zig\n@log(value: anytype) @TypeOf(value)\n```\n\nReturns the natural logarithm of a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @log2\n\n``` zig\n@log2(value: anytype) @TypeOf(value)\n```\n\nReturns the logarithm to the base 2 of a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @log10\n\n``` zig\n@log10(value: anytype) @TypeOf(value)\n```\n\nReturns the logarithm to the base 10 of a floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @abs\n\n``` zig\n@abs(value: anytype) anytype\n```\n\nReturns the absolute value of an integer or a floating point number. Uses a dedicated hardware instruction when available. The return type is always an unsigned integer of the same bit width as the operand if the operand is an integer. Unsigned integer operands are supported. The builtin cannot overflow for signed integer operands.\n\nSupports [Floats](#Floats), [Integers](#Integers) and [Vectors](#Vectors) of floats or integers.\n\n### @floor\n\n``` zig\n@floor(value: anytype) @TypeOf(value)\n```\n\nReturns the largest integral value not greater than the given floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @ceil\n\n``` zig\n@ceil(value: anytype) @TypeOf(value)\n```\n\nReturns the smallest integral value not less than the given floating point number. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @trunc\n\n``` zig\n@trunc(value: anytype) @TypeOf(value)\n```\n\nRounds the given floating point number to an integer, towards zero. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @round\n\n``` zig\n@round(value: anytype) @TypeOf(value)\n```\n\nRounds the given floating point number to an integer, away from zero. Uses a dedicated hardware instruction when available.\n\nSupports [Floats](#Floats) and [Vectors](#Vectors) of floats.\n\n### @subWithOverflow\n\n``` zig\n@subWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }\n```\n\nPerforms `a - b` and returns a tuple with the result and a possible overflow bit.\n\n### @tagName\n\n``` zig\n@tagName(value: anytype) [:0]const u8\n```\n\nConverts an enum value or union value to a string literal representing the name.\n\nIf the enum is non-exhaustive and the tag value does not map to a name, it invokes safety-checked [Undefined Behavior](#Undefined-Behavior).\n\n### @This\n\n``` zig\n@This() type\n```\n\nReturns the innermost struct, enum, or union that this function call is inside. This can be useful for an anonymous struct that needs to refer to itself:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"@This()\" {\n    var items = [_]i32{ 1, 2, 3, 4 };\n    const list = List(i32){ .items = items[0..] };\n    try expect(list.length() == 4);\n}\n\nfn List(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        items: []T,\n\n        fn length(self: Self) usize {\n            return self.items.len;\n        }\n    };\n}\n```\n\ntest_this_builtin.zig\n\n    $ zig test test_this_builtin.zig\n    1/1 test_this_builtin.test.@This()...OK\n    All 1 tests passed.\n\nShell\n\nWhen `@This``()` is used at file scope, it returns a reference to the struct that corresponds to the current file.\n\n### @trap\n\n``` zig\n@trap() noreturn\n```\n\nThis function inserts a platform-specific trap/jam instruction which can be used to exit the program abnormally. This may be implemented by explicitly emitting an invalid instruction which may cause an illegal instruction exception of some sort. Unlike for `@breakpoint``()`, execution does not continue after this point.\n\nOutside function scope, this builtin causes a compile error.\n\nSee also:\n\n- [@breakpoint](#breakpoint)\n\n### @truncate\n\n``` zig\n@truncate(integer: anytype) anytype\n```\n\nThis function truncates bits from an integer type, resulting in a smaller or same-sized integer type. The return type is the inferred result type.\n\nThis function always truncates the significant bits of the integer, regardless of endianness on the target platform.\n\nCalling `@truncate` on a number out of range of the destination type is well defined and working code:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"integer truncation\" {\n    const a: u16 = 0xabcd;\n    const b: u8 = @truncate(a);\n    try expect(b == 0xcd);\n}\n```\n\ntest_truncate_builtin.zig\n\n    $ zig test test_truncate_builtin.zig\n    1/1 test_truncate_builtin.test.integer truncation...OK\n    All 1 tests passed.\n\nShell\n\nUse [@intCast](#intCast) to convert numbers guaranteed to fit the destination type.\n\n### @Type\n\n``` zig\n@Type(comptime info: std.builtin.Type) type\n```\n\nThis function is the inverse of [@typeInfo](#typeInfo). It reifies type information into a `type`.\n\nIt is available for the following types:\n\n- `type`\n- `noreturn`\n- `void`\n- `bool`\n- [Integers](#Integers) - The maximum bit count for an integer type is `65535`.\n- [Floats](#Floats)\n- [Pointers](#Pointers)\n- `comptime_int`\n- `comptime_float`\n- `@TypeOf``(``undefined``)`\n- `@TypeOf``(``null``)`\n- [Arrays](#Arrays)\n- [Optionals](#Optionals)\n- [Error Set Type](#Error-Set-Type)\n- [Error Union Type](#Error-Union-Type)\n- [Vectors](#Vectors)\n- [opaque](#opaque)\n- `anyframe`\n- [struct](#struct)\n- [enum](#enum)\n- [Enum Literals](#Enum-Literals)\n- [union](#union)\n- [Functions](#Functions)\n\n### @typeInfo\n\n``` zig\n@typeInfo(comptime T: type) std.builtin.Type\n```\n\nProvides type reflection.\n\nType information of [structs](#struct), [unions](#union), [enums](#enum), and [error sets](#Error-Set-Type) has fields which are guaranteed to be in the same order as appearance in the source file.\n\nType information of [structs](#struct), [unions](#union), [enums](#enum), and [opaques](#opaque) has declarations, which are also guaranteed to be in the same order as appearance in the source file.\n\n### @typeName\n\n``` zig\n@typeName(T: type) *const [N:0]u8\n```\n\nThis function returns the string representation of a type, as an array. It is equivalent to a string literal of the type name. The returned type name is fully qualified with the parent namespace included as part of the type name with a series of dots.\n\n### @TypeOf\n\n``` zig\n@TypeOf(...) type\n```\n\n`@TypeOf` is a special builtin function that takes any (nonzero) number of expressions as parameters and returns the type of the result, using [Peer Type Resolution](#Peer-Type-Resolution).\n\nThe expressions are evaluated, however they are guaranteed to have no *runtime* side-effects:\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\n\ntest \"no runtime side effects\" {\n    var data: i32 = 0;\n    const T = @TypeOf(foo(i32, &data));\n    try comptime expect(T == i32);\n    try expect(data == 0);\n}\n\nfn foo(comptime T: type, ptr: *T) T {\n    ptr.* += 1;\n    return ptr.*;\n}\n```\n\ntest_TypeOf_builtin.zig\n\n    $ zig test test_TypeOf_builtin.zig\n    1/1 test_TypeOf_builtin.test.no runtime side effects...OK\n    All 1 tests passed.\n\nShell\n\n### @unionInit\n\n``` zig\n@unionInit(comptime Union: type, comptime active_field_name: []const u8, init_expr) Union\n```\n\nThis is the same thing as [union](#union) initialization syntax, except that the field name is a [comptime](#comptime)-known value rather than an identifier token.\n\n`@unionInit` forwards its [result location](#Result-Location-Semantics) to `init_expr`.\n\n### @Vector\n\n``` zig\n@Vector(len: comptime_int, Element: type) type\n```\n\nCreates [Vectors](#Vectors).\n\n### @volatileCast\n\n``` zig\n@volatileCast(value: anytype) DestType\n```\n\nRemove `volatile` qualifier from a pointer.\n\n### @workGroupId\n\n``` zig\n@workGroupId(comptime dimension: u32) u32\n```\n\nReturns the index of the work group in the current kernel invocation in dimension `dimension`.\n\n### @workGroupSize\n\n``` zig\n@workGroupSize(comptime dimension: u32) u32\n```\n\nReturns the number of work items that a work group has in dimension `dimension`.\n\n### @workItemId\n\n``` zig\n@workItemId(comptime dimension: u32) u32\n```\n\nReturns the index of the work item in the work group in dimension `dimension`. This function returns values between `0` (inclusive) and `@workGroupSize``(dimension)` (exclusive).\n\n## Build Mode\n\nZig has four build modes:\n\n- [Debug](#Debug) (default)\n- [ReleaseFast](#ReleaseFast)\n- [ReleaseSafe](#ReleaseSafe)\n- [ReleaseSmall](#ReleaseSmall)\n\nTo add standard build options to a `build.zig` file:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const optimize = b.standardOptimizeOption(.{});\n    const exe = b.addExecutable(.{\n        .name = \"example\",\n        .root_source_file = b.path(\"example.zig\"),\n        .optimize = optimize,\n    });\n    b.default_step.dependOn(&exe.step);\n}\n```\n\nbuild.zig\n\nThis causes these options to be available:\n\n-Doptimize=Debug  \nOptimizations off and safety on (default)\n\n-Doptimize=ReleaseSafe  \nOptimizations on and safety on\n\n-Doptimize=ReleaseFast  \nOptimizations on and safety off\n\n-Doptimize=ReleaseSmall  \nSize optimizations on and safety off\n\n### Debug\n\n    $ zig build-exe example.zig\n\nShell\n\n- Fast compilation speed\n- Safety checks enabled\n- Slow runtime performance\n- Large binary size\n- No reproducible build requirement\n\n### ReleaseFast\n\n    $ zig build-exe example.zig -O ReleaseFast\n\nShell\n\n- Fast runtime performance\n- Safety checks disabled\n- Slow compilation speed\n- Large binary size\n- Reproducible build\n\n### ReleaseSafe\n\n    $ zig build-exe example.zig -O ReleaseSafe\n\nShell\n\n- Medium runtime performance\n- Safety checks enabled\n- Slow compilation speed\n- Large binary size\n- Reproducible build\n\n### ReleaseSmall\n\n    $ zig build-exe example.zig -O ReleaseSmall\n\nShell\n\n- Medium runtime performance\n- Safety checks disabled\n- Slow compilation speed\n- Small binary size\n- Reproducible build\n\nSee also:\n\n- [Compile Variables](#Compile-Variables)\n- [Zig Build System](#Zig-Build-System)\n- [Undefined Behavior](#Undefined-Behavior)\n\n## Single Threaded Builds\n\nZig has a compile option -fsingle-threaded which has the following effects:\n\n- All [Thread Local Variables](#Thread-Local-Variables) are treated as regular [Container Level Variables](#Container-Level-Variables).\n- The overhead of [Async Functions](#Async-Functions) becomes equivalent to function call overhead.\n- The `@import``(``\"builtin\"``).single_threaded` becomes `true` and therefore various userland APIs which read this variable become more efficient. For example `std.Mutex` becomes an empty data structure and all of its functions become no-ops.\n\n## Undefined Behavior\n\nZig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with [@setRuntimeSafety](#setRuntimeSafety). The [ReleaseFast](#ReleaseFast) and [ReleaseSmall](#ReleaseSmall) build modes disable all safety checks (except where overridden by [@setRuntimeSafety](#setRuntimeSafety)) in order to facilitate optimizations.\n\nWhen a safety check fails, Zig crashes with a stack trace, like this:\n\n``` zig\ntest \"safety check\" {\n    unreachable;\n}\n```\n\ntest_undefined_behavior.zig\n\n    $ zig test test_undefined_behavior.zig\n    1/1 test_undefined_behavior.test.safety check...thread 3571226 panic: reached unreachable code\n    /home/andy/src/zig/doc/langref/test_undefined_behavior.zig:2:5: 0x103ce30 in test.safety check (test)\n        unreachable;\n        ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048260 in mainTerminal (test)\n            if (test_fn.func()) |_| {\n                            ^\n    /home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e21b in main (test)\n            return mainTerminal();\n                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103d359 in posixCallMainAndExit (test)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103cec1 in _start (test)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    error: the following test command crashed:\n    /home/andy/src/zig/.zig-cache/o/a71f9f37afd5b3c603d2b9ea72373fa7/test\n\nShell\n\n### Reaching Unreachable Code\n\nAt compile-time:\n\n``` zig\ncomptime {\n    assert(false);\n}\nfn assert(ok: bool) void {\n    if (!ok) unreachable; // assertion failure\n}\n```\n\ntest_comptime_reaching_unreachable.zig\n\n    $ zig test test_comptime_reaching_unreachable.zig\n    doc/langref/test_comptime_reaching_unreachable.zig:5:14: error: reached unreachable code\n        if (!ok) unreachable; // assertion failure\n                 ^~~~~~~~~~~\n    doc/langref/test_comptime_reaching_unreachable.zig:2:11: note: called from here\n        assert(false);\n        ~~~~~~^~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    std.debug.assert(false);\n}\n```\n\nruntime_reaching_unreachable.zig\n\n    $ zig build-exe runtime_reaching_unreachable.zig\n    $ ./runtime_reaching_unreachable\n    thread 3575642 panic: reached unreachable code\n    /home/andy/src/zig/lib/std/debug.zig:412:14: 0x1036cdd in assert (runtime_reaching_unreachable)\n        if (!ok) unreachable; // assertion failure\n                 ^\n    /home/andy/src/zig/doc/langref/runtime_reaching_unreachable.zig:4:21: 0x103507a in main (runtime_reaching_unreachable)\n        std.debug.assert(false);\n                        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034929 in posixCallMainAndExit (runtime_reaching_unreachable)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034491 in _start (runtime_reaching_unreachable)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Index out of Bounds\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const array: [5]u8 = \"hello\".*;\n    const garbage = array[5];\n    _ = garbage;\n}\n```\n\ntest_comptime_index_out_of_bounds.zig\n\n    $ zig test test_comptime_index_out_of_bounds.zig\n    doc/langref/test_comptime_index_out_of_bounds.zig:3:27: error: index 5 outside array of length 5\n        const garbage = array[5];\n                              ^\n\nShell\n\nAt runtime:\n\n``` zig\npub fn main() void {\n    const x = foo(\"hello\");\n    _ = x;\n}\n\nfn foo(x: []const u8) u8 {\n    return x[5];\n}\n```\n\nruntime_index_out_of_bounds.zig\n\n    $ zig build-exe runtime_index_out_of_bounds.zig\n    $ ./runtime_index_out_of_bounds\n    thread 3567952 panic: index out of bounds: index 5, len 5\n    /home/andy/src/zig/doc/langref/runtime_index_out_of_bounds.zig:7:13: 0x1037169 in foo (runtime_index_out_of_bounds)\n        return x[5];\n                ^\n    /home/andy/src/zig/doc/langref/runtime_index_out_of_bounds.zig:2:18: 0x10350b6 in main (runtime_index_out_of_bounds)\n        const x = foo(\"hello\");\n                     ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034959 in posixCallMainAndExit (runtime_index_out_of_bounds)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10344c1 in _start (runtime_index_out_of_bounds)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Cast Negative Number to Unsigned Integer\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const value: i32 = -1;\n    const unsigned: u32 = @intCast(value);\n    _ = unsigned;\n}\n```\n\ntest_comptime_invalid_cast.zig\n\n    $ zig test test_comptime_invalid_cast.zig\n    doc/langref/test_comptime_invalid_cast.zig:3:36: error: type 'u32' cannot represent integer value '-1'\n        const unsigned: u32 = @intCast(value);\n                                       ^~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var value: i32 = -1; // runtime-known\n    _ = &value;\n    const unsigned: u32 = @intCast(value);\n    std.debug.print(\"value: {}\\n\", .{unsigned});\n}\n```\n\nruntime_invalid_cast.zig\n\n    $ zig build-exe runtime_invalid_cast.zig\n    $ ./runtime_invalid_cast\n    thread 3567914 panic: attempt to cast negative value to unsigned integer\n    /home/andy/src/zig/doc/langref/runtime_invalid_cast.zig:6:27: 0x10351e2 in main (runtime_invalid_cast)\n        const unsigned: u32 = @intCast(value);\n                              ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (runtime_invalid_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (runtime_invalid_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nTo obtain the maximum value of an unsigned integer, use `std.math.maxInt`.\n\n### Cast Truncates Data\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const spartan_count: u16 = 300;\n    const byte: u8 = @intCast(spartan_count);\n    _ = byte;\n}\n```\n\ntest_comptime_invalid_cast_truncate.zig\n\n    $ zig test test_comptime_invalid_cast_truncate.zig\n    doc/langref/test_comptime_invalid_cast_truncate.zig:3:31: error: type 'u8' cannot represent integer value '300'\n        const byte: u8 = @intCast(spartan_count);\n                                  ^~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var spartan_count: u16 = 300; // runtime-known\n    _ = &spartan_count;\n    const byte: u8 = @intCast(spartan_count);\n    std.debug.print(\"value: {}\\n\", .{byte});\n}\n```\n\nruntime_invalid_cast_truncate.zig\n\n    $ zig build-exe runtime_invalid_cast_truncate.zig\n    $ ./runtime_invalid_cast_truncate\n    thread 3576020 panic: integer cast truncated bits\n    /home/andy/src/zig/doc/langref/runtime_invalid_cast_truncate.zig:6:22: 0x1035275 in main (runtime_invalid_cast_truncate)\n        const byte: u8 = @intCast(spartan_count);\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ad9 in posixCallMainAndExit (runtime_invalid_cast_truncate)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034641 in _start (runtime_invalid_cast_truncate)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nTo truncate bits, use [@truncate](#truncate).\n\n### Integer Overflow\n\n#### [Default Operations](#toc-Default-Operations)\n\nThe following operators can cause integer overflow:\n\n- `+` (addition)\n- `-` (subtraction)\n- `-` (negation)\n- `*` (multiplication)\n- `/` (division)\n- [@divTrunc](#divTrunc) (division)\n- [@divFloor](#divFloor) (division)\n- [@divExact](#divExact) (division)\n\nExample with addition at compile-time:\n\n``` zig\ncomptime {\n    var byte: u8 = 255;\n    byte += 1;\n}\n```\n\ntest_comptime_overflow.zig\n\n    $ zig test test_comptime_overflow.zig\n    doc/langref/test_comptime_overflow.zig:3:10: error: overflow of integer type 'u8' with value '256'\n        byte += 1;\n        ~~~~~^~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var byte: u8 = 255;\n    byte += 1;\n    std.debug.print(\"value: {}\\n\", .{byte});\n}\n```\n\nruntime_overflow.zig\n\n    $ zig build-exe runtime_overflow.zig\n    $ ./runtime_overflow\n    thread 3574209 panic: integer overflow\n    /home/andy/src/zig/doc/langref/runtime_overflow.zig:5:10: 0x103525e in main (runtime_overflow)\n        byte += 1;\n             ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ad9 in posixCallMainAndExit (runtime_overflow)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034641 in _start (runtime_overflow)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n#### [Standard Library Math Functions](#toc-Standard-Library-Math-Functions)\n\nThese functions provided by the standard library return possible errors.\n\n- `@import``(``\"std\"``).math.add`\n- `@import``(``\"std\"``).math.sub`\n- `@import``(``\"std\"``).math.mul`\n- `@import``(``\"std\"``).math.divTrunc`\n- `@import``(``\"std\"``).math.divFloor`\n- `@import``(``\"std\"``).math.divExact`\n- `@import``(``\"std\"``).math.shl`\n\nExample of catching an overflow for addition:\n\n``` zig\nconst math = @import(\"std\").math;\nconst print = @import(\"std\").debug.print;\npub fn main() !void {\n    var byte: u8 = 255;\n\n    byte = if (math.add(u8, byte, 1)) |result| result else |err| {\n        print(\"unable to add one: {s}\\n\", .{@errorName(err)});\n        return err;\n    };\n\n    print(\"result: {}\\n\", .{byte});\n}\n```\n\nmath_add.zig\n\n    $ zig build-exe math_add.zig\n    $ ./math_add\n    unable to add one: Overflow\n    error: Overflow\n    /home/andy/src/zig/lib/std/math.zig:565:21: 0x10352a5 in add__anon_2592 (math_add)\n        if (ov[1] != 0) return error.Overflow;\n                        ^\n    /home/andy/src/zig/doc/langref/math_add.zig:8:9: 0x1035243 in main (math_add)\n            return err;\n            ^\n\nShell\n\n#### [Builtin Overflow Functions](#toc-Builtin-Overflow-Functions)\n\nThese builtins return a tuple containing whether there was an overflow (as a `u1`) and the possibly overflowed bits of the operation:\n\n- [@addWithOverflow](#addWithOverflow)\n- [@subWithOverflow](#subWithOverflow)\n- [@mulWithOverflow](#mulWithOverflow)\n- [@shlWithOverflow](#shlWithOverflow)\n\nExample of [@addWithOverflow](#addWithOverflow):\n\n``` zig\nconst print = @import(\"std\").debug.print;\npub fn main() void {\n    const byte: u8 = 255;\n\n    const ov = @addWithOverflow(byte, 10);\n    if (ov[1] != 0) {\n        print(\"overflowed result: {}\\n\", .{ov[0]});\n    } else {\n        print(\"result: {}\\n\", .{ov[0]});\n    }\n}\n```\n\naddWithOverflow_builtin.zig\n\n    $ zig build-exe addWithOverflow_builtin.zig\n    $ ./addWithOverflow_builtin\n    overflowed result: 9\n\nShell\n\n#### [Wrapping Operations](#toc-Wrapping-Operations)\n\nThese operations have guaranteed wraparound semantics.\n\n- `+%` (wraparound addition)\n- `-%` (wraparound subtraction)\n- `-%` (wraparound negation)\n- `*%` (wraparound multiplication)\n\n``` zig\nconst std = @import(\"std\");\nconst expect = std.testing.expect;\nconst minInt = std.math.minInt;\nconst maxInt = std.math.maxInt;\n\ntest \"wraparound addition and subtraction\" {\n    const x: i32 = maxInt(i32);\n    const min_val = x +% 1;\n    try expect(min_val == minInt(i32));\n    const max_val = min_val -% 1;\n    try expect(max_val == maxInt(i32));\n}\n```\n\ntest_wraparound_semantics.zig\n\n    $ zig test test_wraparound_semantics.zig\n    1/1 test_wraparound_semantics.test.wraparound addition and subtraction...OK\n    All 1 tests passed.\n\nShell\n\n### Exact Left Shift Overflow\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const x = @shlExact(@as(u8, 0b01010101), 2);\n    _ = x;\n}\n```\n\ntest_comptime_shlExact_overwlow.zig\n\n    $ zig test test_comptime_shlExact_overwlow.zig\n    doc/langref/test_comptime_shlExact_overwlow.zig:2:15: error: operation caused overflow\n        const x = @shlExact(@as(u8, 0b01010101), 2);\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var x: u8 = 0b01010101; // runtime-known\n    _ = &x;\n    const y = @shlExact(x, 2);\n    std.debug.print(\"value: {}\\n\", .{y});\n}\n```\n\nruntime_shlExact_overflow.zig\n\n    $ zig build-exe runtime_shlExact_overflow.zig\n    $ ./runtime_shlExact_overflow\n    thread 3577156 panic: left shift overflowed bits\n    /home/andy/src/zig/doc/langref/runtime_shlExact_overflow.zig:6:5: 0x10352bd in main (runtime_shlExact_overflow)\n        const y = @shlExact(x, 2);\n        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034b19 in posixCallMainAndExit (runtime_shlExact_overflow)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034681 in _start (runtime_shlExact_overflow)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Exact Right Shift Overflow\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const x = @shrExact(@as(u8, 0b10101010), 2);\n    _ = x;\n}\n```\n\ntest_comptime_shrExact_overflow.zig\n\n    $ zig test test_comptime_shrExact_overflow.zig\n    doc/langref/test_comptime_shrExact_overflow.zig:2:15: error: exact shift shifted out 1 bits\n        const x = @shrExact(@as(u8, 0b10101010), 2);\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var x: u8 = 0b10101010; // runtime-known\n    _ = &x;\n    const y = @shrExact(x, 2);\n    std.debug.print(\"value: {}\\n\", .{y});\n}\n```\n\nruntime_shrExact_overflow.zig\n\n    $ zig build-exe runtime_shrExact_overflow.zig\n    $ ./runtime_shrExact_overflow\n    thread 3579049 panic: right shift overflowed bits\n    /home/andy/src/zig/doc/langref/runtime_shrExact_overflow.zig:6:5: 0x10352b9 in main (runtime_shrExact_overflow)\n        const y = @shrExact(x, 2);\n        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034b19 in posixCallMainAndExit (runtime_shrExact_overflow)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034681 in _start (runtime_shrExact_overflow)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Division by Zero\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const a: i32 = 1;\n    const b: i32 = 0;\n    const c = a / b;\n    _ = c;\n}\n```\n\ntest_comptime_division_by_zero.zig\n\n    $ zig test test_comptime_division_by_zero.zig\n    doc/langref/test_comptime_division_by_zero.zig:4:19: error: division by zero here causes undefined behavior\n        const c = a / b;\n                      ^\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var a: u32 = 1;\n    var b: u32 = 0;\n    _ = .{ &a, &b };\n    const c = a / b;\n    std.debug.print(\"value: {}\\n\", .{c});\n}\n```\n\nruntime_division_by_zero.zig\n\n    $ zig build-exe runtime_division_by_zero.zig\n    $ ./runtime_division_by_zero\n    thread 3575479 panic: division by zero\n    /home/andy/src/zig/doc/langref/runtime_division_by_zero.zig:7:17: 0x10351f6 in main (runtime_division_by_zero)\n        const c = a / b;\n                    ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (runtime_division_by_zero)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (runtime_division_by_zero)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Remainder Division by Zero\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const a: i32 = 10;\n    const b: i32 = 0;\n    const c = a % b;\n    _ = c;\n}\n```\n\ntest_comptime_remainder_division_by_zero.zig\n\n    $ zig test test_comptime_remainder_division_by_zero.zig\n    doc/langref/test_comptime_remainder_division_by_zero.zig:4:19: error: division by zero here causes undefined behavior\n        const c = a % b;\n                      ^\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var a: u32 = 10;\n    var b: u32 = 0;\n    _ = .{ &a, &b };\n    const c = a % b;\n    std.debug.print(\"value: {}\\n\", .{c});\n}\n```\n\nruntime_remainder_division_by_zero.zig\n\n    $ zig build-exe runtime_remainder_division_by_zero.zig\n    $ ./runtime_remainder_division_by_zero\n    thread 3570535 panic: division by zero\n    /home/andy/src/zig/doc/langref/runtime_remainder_division_by_zero.zig:7:17: 0x10351f6 in main (runtime_remainder_division_by_zero)\n        const c = a % b;\n                    ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (runtime_remainder_division_by_zero)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (runtime_remainder_division_by_zero)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Exact Division Remainder\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const a: u32 = 10;\n    const b: u32 = 3;\n    const c = @divExact(a, b);\n    _ = c;\n}\n```\n\ntest_comptime_divExact_remainder.zig\n\n    $ zig test test_comptime_divExact_remainder.zig\n    doc/langref/test_comptime_divExact_remainder.zig:4:15: error: exact division produced remainder\n        const c = @divExact(a, b);\n                  ^~~~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var a: u32 = 10;\n    var b: u32 = 3;\n    _ = .{ &a, &b };\n    const c = @divExact(a, b);\n    std.debug.print(\"value: {}\\n\", .{c});\n}\n```\n\nruntime_divExact_remainder.zig\n\n    $ zig build-exe runtime_divExact_remainder.zig\n    $ ./runtime_divExact_remainder\n    thread 3570103 panic: exact division produced remainder\n    /home/andy/src/zig/doc/langref/runtime_divExact_remainder.zig:7:15: 0x103526b in main (runtime_divExact_remainder)\n        const c = @divExact(a, b);\n                  ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a89 in posixCallMainAndExit (runtime_divExact_remainder)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10345f1 in _start (runtime_divExact_remainder)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Attempt to Unwrap Null\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const optional_number: ?i32 = null;\n    const number = optional_number.?;\n    _ = number;\n}\n```\n\ntest_comptime_unwrap_null.zig\n\n    $ zig test test_comptime_unwrap_null.zig\n    doc/langref/test_comptime_unwrap_null.zig:3:35: error: unable to unwrap null\n        const number = optional_number.?;\n                       ~~~~~~~~~~~~~~~^~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    var optional_number: ?i32 = null;\n    _ = &optional_number;\n    const number = optional_number.?;\n    std.debug.print(\"value: {}\\n\", .{number});\n}\n```\n\nruntime_unwrap_null.zig\n\n    $ zig build-exe runtime_unwrap_null.zig\n    $ ./runtime_unwrap_null\n    thread 3570514 panic: attempt to use null value\n    /home/andy/src/zig/doc/langref/runtime_unwrap_null.zig:6:35: 0x1035272 in main (runtime_unwrap_null)\n        const number = optional_number.?;\n                                      ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ad9 in posixCallMainAndExit (runtime_unwrap_null)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034641 in _start (runtime_unwrap_null)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nOne way to avoid this crash is to test for null instead of assuming non-null, with the `if` expression:\n\n``` zig\nconst print = @import(\"std\").debug.print;\npub fn main() void {\n    const optional_number: ?i32 = null;\n\n    if (optional_number) |number| {\n        print(\"got number: {}\\n\", .{number});\n    } else {\n        print(\"it's null\\n\", .{});\n    }\n}\n```\n\ntesting_null_with_if.zig\n\n    $ zig build-exe testing_null_with_if.zig\n    $ ./testing_null_with_if\n    it's null\n\nShell\n\nSee also:\n\n- [Optionals](#Optionals)\n\n### Attempt to Unwrap Error\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const number = getNumberOrFail() catch unreachable;\n    _ = number;\n}\n\nfn getNumberOrFail() !i32 {\n    return error.UnableToReturnNumber;\n}\n```\n\ntest_comptime_unwrap_error.zig\n\n    $ zig test test_comptime_unwrap_error.zig\n    doc/langref/test_comptime_unwrap_error.zig:2:44: error: caught unexpected error 'UnableToReturnNumber'\n        const number = getNumberOrFail() catch unreachable;\n                                               ^~~~~~~~~~~\n    doc/langref/test_comptime_unwrap_error.zig:7:18: note: error returned here\n        return error.UnableToReturnNumber;\n                     ^~~~~~~~~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    const number = getNumberOrFail() catch unreachable;\n    std.debug.print(\"value: {}\\n\", .{number});\n}\n\nfn getNumberOrFail() !i32 {\n    return error.UnableToReturnNumber;\n}\n```\n\nruntime_unwrap_error.zig\n\n    $ zig build-exe runtime_unwrap_error.zig\n    $ ./runtime_unwrap_error\n    thread 3577877 panic: attempt to unwrap error: UnableToReturnNumber\n    /home/andy/src/zig/doc/langref/runtime_unwrap_error.zig:9:5: 0x103738f in getNumberOrFail (runtime_unwrap_error)\n        return error.UnableToReturnNumber;\n        ^\n    /home/andy/src/zig/doc/langref/runtime_unwrap_error.zig:4:44: 0x1035301 in main (runtime_unwrap_error)\n        const number = getNumberOrFail() catch unreachable;\n                                               ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034b49 in posixCallMainAndExit (runtime_unwrap_error)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10346b1 in _start (runtime_unwrap_error)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nOne way to avoid this crash is to test for an error instead of assuming a successful result, with the `if` expression:\n\n``` zig\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    const result = getNumberOrFail();\n\n    if (result) |number| {\n        print(\"got number: {}\\n\", .{number});\n    } else |err| {\n        print(\"got error: {s}\\n\", .{@errorName(err)});\n    }\n}\n\nfn getNumberOrFail() !i32 {\n    return error.UnableToReturnNumber;\n}\n```\n\ntesting_error_with_if.zig\n\n    $ zig build-exe testing_error_with_if.zig\n    $ ./testing_error_with_if\n    got error: UnableToReturnNumber\n\nShell\n\nSee also:\n\n- [Errors](#Errors)\n\n### Invalid Error Code\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const err = error.AnError;\n    const number = @intFromError(err) + 10;\n    const invalid_err = @errorFromInt(number);\n    _ = invalid_err;\n}\n```\n\ntest_comptime_invalid_error_code.zig\n\n    $ zig test test_comptime_invalid_error_code.zig\n    doc/langref/test_comptime_invalid_error_code.zig:4:39: error: integer value '11' represents no error\n        const invalid_err = @errorFromInt(number);\n                                          ^~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    const err = error.AnError;\n    var number = @intFromError(err) + 500;\n    _ = &number;\n    const invalid_err = @errorFromInt(number);\n    std.debug.print(\"value: {}\\n\", .{invalid_err});\n}\n```\n\nruntime_invalid_error_code.zig\n\n    $ zig build-exe runtime_invalid_error_code.zig\n    $ ./runtime_invalid_error_code\n    thread 3570441 panic: invalid error code\n    /home/andy/src/zig/doc/langref/runtime_invalid_error_code.zig:7:5: 0x10352a0 in main (runtime_invalid_error_code)\n        const invalid_err = @errorFromInt(number);\n        ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ae9 in posixCallMainAndExit (runtime_invalid_error_code)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034651 in _start (runtime_invalid_error_code)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Invalid Enum Cast\n\nAt compile-time:\n\n``` zig\nconst Foo = enum {\n    a,\n    b,\n    c,\n};\ncomptime {\n    const a: u2 = 3;\n    const b: Foo = @enumFromInt(a);\n    _ = b;\n}\n```\n\ntest_comptime_invalid_enum_cast.zig\n\n    $ zig test test_comptime_invalid_enum_cast.zig\n    doc/langref/test_comptime_invalid_enum_cast.zig:8:20: error: enum 'test_comptime_invalid_enum_cast.Foo' has no tag with value '3'\n        const b: Foo = @enumFromInt(a);\n                       ^~~~~~~~~~~~~~~\n    doc/langref/test_comptime_invalid_enum_cast.zig:1:13: note: enum declared here\n    const Foo = enum {\n                ^~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = enum {\n    a,\n    b,\n    c,\n};\n\npub fn main() void {\n    var a: u2 = 3;\n    _ = &a;\n    const b: Foo = @enumFromInt(a);\n    std.debug.print(\"value: {s}\\n\", .{@tagName(b)});\n}\n```\n\nruntime_invalid_enum_cast.zig\n\n    $ zig build-exe runtime_invalid_enum_cast.zig\n    $ ./runtime_invalid_enum_cast\n    thread 3568027 panic: invalid enum value\n    /home/andy/src/zig/doc/langref/runtime_invalid_enum_cast.zig:12:20: 0x1035297 in main (runtime_invalid_enum_cast)\n        const b: Foo = @enumFromInt(a);\n                       ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034af9 in posixCallMainAndExit (runtime_invalid_enum_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034661 in _start (runtime_invalid_enum_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Invalid Error Set Cast\n\nAt compile-time:\n\n``` zig\nconst Set1 = error{\n    A,\n    B,\n};\nconst Set2 = error{\n    A,\n    C,\n};\ncomptime {\n    _ = @as(Set2, @errorCast(Set1.B));\n}\n```\n\ntest_comptime_invalid_error_set_cast.zig\n\n    $ zig test test_comptime_invalid_error_set_cast.zig\n    doc/langref/test_comptime_invalid_error_set_cast.zig:10:19: error: 'error.B' not a member of error set 'error{A,C}'\n        _ = @as(Set2, @errorCast(Set1.B));\n                      ^~~~~~~~~~~~~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Set1 = error{\n    A,\n    B,\n};\nconst Set2 = error{\n    A,\n    C,\n};\npub fn main() void {\n    foo(Set1.B);\n}\nfn foo(set1: Set1) void {\n    const x: Set2 = @errorCast(set1);\n    std.debug.print(\"value: {}\\n\", .{x});\n}\n```\n\nruntime_invalid_error_set_cast.zig\n\n    $ zig build-exe runtime_invalid_error_set_cast.zig\n    $ ./runtime_invalid_error_set_cast\n    thread 3568026 panic: invalid error code\n    /home/andy/src/zig/doc/langref/runtime_invalid_error_set_cast.zig:15:21: 0x1037317 in foo (runtime_invalid_error_set_cast)\n        const x: Set2 = @errorCast(set1);\n                        ^\n    /home/andy/src/zig/doc/langref/runtime_invalid_error_set_cast.zig:12:8: 0x103523d in main (runtime_invalid_error_set_cast)\n        foo(Set1.B);\n           ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034ae9 in posixCallMainAndExit (runtime_invalid_error_set_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034651 in _start (runtime_invalid_error_set_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Incorrect Pointer Alignment\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const ptr: *align(1) i32 = @ptrFromInt(0x1);\n    const aligned: *align(4) i32 = @alignCast(ptr);\n    _ = aligned;\n}\n```\n\ntest_comptime_incorrect_pointer_alignment.zig\n\n    $ zig test test_comptime_incorrect_pointer_alignment.zig\n    doc/langref/test_comptime_incorrect_pointer_alignment.zig:3:47: error: pointer address 0x1 is not aligned to 4 bytes\n        const aligned: *align(4) i32 = @alignCast(ptr);\n                                                  ^~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst mem = @import(\"std\").mem;\npub fn main() !void {\n    var array align(4) = [_]u32{ 0x11111111, 0x11111111 };\n    const bytes = mem.sliceAsBytes(array[0..]);\n    if (foo(bytes) != 0x11111111) return error.Wrong;\n}\nfn foo(bytes: []u8) u32 {\n    const slice4 = bytes[1..5];\n    const int_slice = mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n    return int_slice[0];\n}\n```\n\nruntime_incorrect_pointer_alignment.zig\n\n    $ zig build-exe runtime_incorrect_pointer_alignment.zig\n    $ ./runtime_incorrect_pointer_alignment\n    thread 3570122 panic: incorrect alignment\n    /home/andy/src/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:9:64: 0x1034f0a in foo (runtime_incorrect_pointer_alignment)\n        const int_slice = mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));\n                                                                   ^\n    /home/andy/src/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:5:12: 0x1034dc7 in main (runtime_incorrect_pointer_alignment)\n        if (foo(bytes) != 0x11111111) return error.Wrong;\n               ^\n    /home/andy/src/zig/lib/std/start.zig:524:37: 0x1034cc5 in posixCallMainAndExit (runtime_incorrect_pointer_alignment)\n                const result = root.main() catch |err| {\n                                        ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x10347e1 in _start (runtime_incorrect_pointer_alignment)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Wrong Union Field Access\n\nAt compile-time:\n\n``` zig\ncomptime {\n    var f = Foo{ .int = 42 };\n    f.float = 12.34;\n}\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n```\n\ntest_comptime_wrong_union_field_access.zig\n\n    $ zig test test_comptime_wrong_union_field_access.zig\n    doc/langref/test_comptime_wrong_union_field_access.zig:3:6: error: access of union field 'float' while field 'int' is active\n        f.float = 12.34;\n        ~^~~~~~\n    doc/langref/test_comptime_wrong_union_field_access.zig:6:13: note: union declared here\n    const Foo = union {\n                ^~~~~\n\nShell\n\nAt runtime:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n\npub fn main() void {\n    var f = Foo{ .int = 42 };\n    bar(&f);\n}\n\nfn bar(f: *Foo) void {\n    f.float = 12.34;\n    std.debug.print(\"value: {}\\n\", .{f.float});\n}\n```\n\nruntime_wrong_union_field_access.zig\n\n    $ zig build-exe runtime_wrong_union_field_access.zig\n    $ ./runtime_wrong_union_field_access\n    thread 3578787 panic: access of union field 'float' while field 'int' is active\n    /home/andy/src/zig/doc/langref/runtime_wrong_union_field_access.zig:14:6: 0x103cd20 in bar (runtime_wrong_union_field_access)\n        f.float = 12.34;\n         ^\n    /home/andy/src/zig/doc/langref/runtime_wrong_union_field_access.zig:10:8: 0x103ac5c in main (runtime_wrong_union_field_access)\n        bar(&f);\n           ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x103a4f9 in posixCallMainAndExit (runtime_wrong_union_field_access)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x103a061 in _start (runtime_wrong_union_field_access)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\nThis safety is not available for `extern` or `packed` unions.\n\nTo change the active field of a union, assign the entire union, like this:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n\npub fn main() void {\n    var f = Foo{ .int = 42 };\n    bar(&f);\n}\n\nfn bar(f: *Foo) void {\n    f.* = Foo{ .float = 12.34 };\n    std.debug.print(\"value: {}\\n\", .{f.float});\n}\n```\n\nchange_active_union_field.zig\n\n    $ zig build-exe change_active_union_field.zig\n    $ ./change_active_union_field\n    value: 1.234e1\n\nShell\n\nTo change the active field of a union when a meaningful value for the field is not known, use [undefined](#undefined), like this:\n\n``` zig\nconst std = @import(\"std\");\n\nconst Foo = union {\n    float: f32,\n    int: u32,\n};\n\npub fn main() void {\n    var f = Foo{ .int = 42 };\n    f = Foo{ .float = undefined };\n    bar(&f);\n    std.debug.print(\"value: {}\\n\", .{f.float});\n}\n\nfn bar(f: *Foo) void {\n    f.float = 12.34;\n}\n```\n\nundefined_active_union_field.zig\n\n    $ zig build-exe undefined_active_union_field.zig\n    $ ./undefined_active_union_field\n    value: 1.234e1\n\nShell\n\nSee also:\n\n- [union](#union)\n- [extern union](#extern-union)\n\n### Out of Bounds Float to Integer Cast\n\nThis happens when casting a float to an integer where the float has a value outside the integer type's range.\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const float: f32 = 4294967296;\n    const int: i32 = @intFromFloat(float);\n    _ = int;\n}\n```\n\ntest_comptime_out_of_bounds_float_to_integer_cast.zig\n\n    $ zig test test_comptime_out_of_bounds_float_to_integer_cast.zig\n    doc/langref/test_comptime_out_of_bounds_float_to_integer_cast.zig:3:36: error: float value '4294967296' cannot be stored in integer type 'i32'\n        const int: i32 = @intFromFloat(float);\n                                       ^~~~~\n\nShell\n\nAt runtime:\n\n``` zig\npub fn main() void {\n    var float: f32 = 4294967296; // runtime-known\n    _ = &float;\n    const int: i32 = @intFromFloat(float);\n    _ = int;\n}\n```\n\nruntime_out_of_bounds_float_to_integer_cast.zig\n\n    $ zig build-exe runtime_out_of_bounds_float_to_integer_cast.zig\n    $ ./runtime_out_of_bounds_float_to_integer_cast\n    thread 3570320 panic: integer part of floating point value out of bounds\n    /home/andy/src/zig/doc/langref/runtime_out_of_bounds_float_to_integer_cast.zig:4:22: 0x1035169 in main (runtime_out_of_bounds_float_to_integer_cast)\n        const int: i32 = @intFromFloat(float);\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x10349a9 in posixCallMainAndExit (runtime_out_of_bounds_float_to_integer_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034511 in _start (runtime_out_of_bounds_float_to_integer_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n### Pointer Cast Invalid Null\n\nThis happens when casting a pointer with the address 0 to a pointer which may not have the address 0. For example, [C Pointers](#C-Pointers), [Optional Pointers](#Optional-Pointers), and [allowzero](#allowzero) pointers allow address zero, but normal [Pointers](#Pointers) do not.\n\nAt compile-time:\n\n``` zig\ncomptime {\n    const opt_ptr: ?*i32 = null;\n    const ptr: *i32 = @ptrCast(opt_ptr);\n    _ = ptr;\n}\n```\n\ntest_comptime_invalid_null_pointer_cast.zig\n\n    $ zig test test_comptime_invalid_null_pointer_cast.zig\n    doc/langref/test_comptime_invalid_null_pointer_cast.zig:3:32: error: null pointer casted to type '*i32'\n        const ptr: *i32 = @ptrCast(opt_ptr);\n                                   ^~~~~~~\n\nShell\n\nAt runtime:\n\n``` zig\npub fn main() void {\n    var opt_ptr: ?*i32 = null;\n    _ = &opt_ptr;\n    const ptr: *i32 = @ptrCast(opt_ptr);\n    _ = ptr;\n}\n```\n\nruntime_invalid_null_pointer_cast.zig\n\n    $ zig build-exe runtime_invalid_null_pointer_cast.zig\n    $ ./runtime_invalid_null_pointer_cast\n    thread 3572791 panic: cast causes pointer to be null\n    /home/andy/src/zig/doc/langref/runtime_invalid_null_pointer_cast.zig:4:23: 0x10350bc in main (runtime_invalid_null_pointer_cast)\n        const ptr: *i32 = @ptrCast(opt_ptr);\n                          ^\n    /home/andy/src/zig/lib/std/start.zig:514:22: 0x1034929 in posixCallMainAndExit (runtime_invalid_null_pointer_cast)\n                root.main();\n                         ^\n    /home/andy/src/zig/lib/std/start.zig:266:5: 0x1034491 in _start (runtime_invalid_null_pointer_cast)\n        asm volatile (switch (native_arch) {\n        ^\n    ???:?:?: 0x0 in ??? (???)\n    (process terminated by signal)\n\nShell\n\n## Memory\n\nThe Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question:\n\n[Where are the bytes?](#Where-are-the-bytes)\n\nLike Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - `malloc`, `realloc`, and `free`. When linking against libc, Zig exposes this allocator with `std.heap.c_allocator`. However, by convention, there is no default allocator in Zig. Instead, functions which need to allocate accept an `Allocator` parameter. Likewise, data structures such as `std.ArrayList` accept an `Allocator` parameter in their initialization functions:\n\n``` zig\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\nconst expect = std.testing.expect;\n\ntest \"using an allocator\" {\n    var buffer: [100]u8 = undefined;\n    var fba = std.heap.FixedBufferAllocator.init(&buffer);\n    const allocator = fba.allocator();\n    const result = try concat(allocator, \"foo\", \"bar\");\n    try expect(std.mem.eql(u8, \"foobar\", result));\n}\n\nfn concat(allocator: Allocator, a: []const u8, b: []const u8) ![]u8 {\n    const result = try allocator.alloc(u8, a.len + b.len);\n    @memcpy(result[0..a.len], a);\n    @memcpy(result[a.len..], b);\n    return result;\n}\n```\n\ntest_allocator.zig\n\n    $ zig test test_allocator.zig\n    1/1 test_allocator.test.using an allocator...OK\n    All 1 tests passed.\n\nShell\n\nIn the above example, 100 bytes of stack memory are used to initialize a `FixedBufferAllocator`, which is then passed to a function. As a convenience there is a global `FixedBufferAllocator` available for quick tests at `std.testing.allocator`, which will also perform basic leak detection.\n\nZig has a general purpose allocator available to be imported with `std.heap.GeneralPurposeAllocator`. However, it is still recommended to follow the [Choosing an Allocator](#Choosing-an-Allocator) guide.\n\n### Choosing an Allocator\n\nWhat allocator to use depends on a number of factors. Here is a flow chart to help you decide:\n\n1.  Are you making a library? In this case, best to accept an `Allocator` as a parameter and allow your library's users to decide what allocator to use.\n2.  Are you linking libc? In this case, `std.heap.c_allocator` is likely the right choice, at least for your main allocator.\n3.  Is the maximum number of bytes that you will need bounded by a number known at [comptime](#comptime)? In this case, use `std.heap.FixedBufferAllocator` or `std.heap.ThreadSafeFixedBufferAllocator` depending on whether you need thread-safety or not.\n4.  Is your program a command line application which runs from start to end without any fundamental cyclical pattern (such as a video game main loop, or a web server request handler), such that it would make sense to free everything at once at the end? In this case, it is recommended to follow this pattern:\n    ``` zig\n    const std = @import(\"std\");\n\n    pub fn main() !void {\n        var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n        defer arena.deinit();\n\n        const allocator = arena.allocator();\n\n        const ptr = try allocator.create(i32);\n        std.debug.print(\"ptr={*}\\n\", .{ptr});\n    }\n    ```\n\n    cli_allocation.zig\n\n        $ zig build-exe cli_allocation.zig\n        $ ./cli_allocation\n        ptr=i32@7f989ee8e010\n\n    Shell\n\n    When using this kind of allocator, there is no need to free anything manually. Everything gets freed at once with the call to `arena.deinit()`.\n5.  Are the allocations part of a cyclical pattern such as a video game main loop, or a web server request handler? If the allocations can all be freed at once, at the end of the cycle, for example once the video game frame has been fully rendered, or the web server request has been served, then `std.heap.ArenaAllocator` is a great candidate. As demonstrated in the previous bullet point, this allows you to free entire arenas at once. Note also that if an upper bound of memory can be established, then `std.heap.FixedBufferAllocator` can be used as a further optimization.\n6.  Are you writing a test, and you want to make sure `error``.OutOfMemory` is handled correctly? In this case, use `std.testing.FailingAllocator`.\n7.  Are you writing a test? In this case, use `std.testing.allocator`.\n8.  Finally, if none of the above apply, you need a general purpose allocator. Zig's general purpose allocator is available as a function that takes a [comptime](#comptime) [struct](#struct) of configuration options and returns a type. Generally, you will set up one `std.heap.GeneralPurposeAllocator` in your main function, and then pass it or sub-allocators around to various parts of your application.\n9.  You can also consider [Implementing an Allocator](#Implementing-an-Allocator).\n\n### Where are the bytes?\n\nString literals such as `\"hello\"` are in the global constant data section. This is why it is an error to pass a string literal to a mutable slice, like this:\n\n``` zig\nfn foo(s: []u8) void {\n    _ = s;\n}\n\ntest \"string literal to mutable slice\" {\n    foo(\"hello\");\n}\n```\n\ntest_string_literal_to_slice.zig\n\n    $ zig test test_string_literal_to_slice.zig\n    doc/langref/test_string_literal_to_slice.zig:6:9: error: expected type '[]u8', found '*const [5:0]u8'\n        foo(\"hello\");\n            ^~~~~~~\n    doc/langref/test_string_literal_to_slice.zig:6:9: note: cast discards const qualifier\n    doc/langref/test_string_literal_to_slice.zig:1:11: note: parameter type declared here\n    fn foo(s: []u8) void {\n              ^~~~\n\nShell\n\nHowever if you make the slice constant, then it works:\n\n``` zig\nfn foo(s: []const u8) void {\n    _ = s;\n}\n\ntest \"string literal to constant slice\" {\n    foo(\"hello\");\n}\n```\n\ntest_string_literal_to_const_slice.zig\n\n    $ zig test test_string_literal_to_const_slice.zig\n    1/1 test_string_literal_to_const_slice.test.string literal to constant slice...OK\n    All 1 tests passed.\n\nShell\n\nJust like string literals, `const` declarations, when the value is known at [comptime](#comptime), are stored in the global constant data section. Also [Compile Time Variables](#Compile-Time-Variables) are stored in the global constant data section.\n\n`var` declarations inside functions are stored in the function's stack frame. Once a function returns, any [Pointers](#Pointers) to variables in the function's stack frame become invalid references, and dereferencing them becomes unchecked [Undefined Behavior](#Undefined-Behavior).\n\n`var` declarations at the top level or in [struct](#struct) declarations are stored in the global data section.\n\nThe location of memory allocated with `allocator.alloc` or `allocator.create` is determined by the allocator's implementation.\n\nTODO: thread local variables\n\n### Implementing an Allocator\n\nZig programmers can implement their own allocators by fulfilling the Allocator interface. In order to do this one must read carefully the documentation comments in std/mem.zig and then supply a `allocFn` and a `resizeFn`.\n\nThere are many example allocators to look at for inspiration. Look at std/heap.zig and `std.heap.GeneralPurposeAllocator`.\n\n### Heap Allocation Failure\n\nMany programming languages choose to handle the possibility of heap allocation failure by unconditionally crashing. By convention, Zig programmers do not consider this to be a satisfactory solution. Instead, `error``.OutOfMemory` represents heap allocation failure, and Zig libraries return this error code whenever heap allocation failure prevented an operation from completing successfully.\n\nSome have argued that because some operating systems such as Linux have memory overcommit enabled by default, it is pointless to handle heap allocation failure. There are many problems with this reasoning:\n\n- Only some operating systems have an overcommit feature.\n  - Linux has it enabled by default, but it is configurable.\n  - Windows does not overcommit.\n  - Embedded systems do not have overcommit.\n  - Hobby operating systems may or may not have overcommit.\n- For real-time systems, not only is there no overcommit, but typically the maximum amount of memory per application is determined ahead of time.\n- When writing a library, one of the main goals is code reuse. By making code handle allocation failure correctly, a library becomes eligible to be reused in more contexts.\n- Although some software has grown to depend on overcommit being enabled, its existence is the source of countless user experience disasters. When a system with overcommit enabled, such as Linux on default settings, comes close to memory exhaustion, the system locks up and becomes unusable. At this point, the OOM Killer selects an application to kill based on heuristics. This non-deterministic decision often results in an important process being killed, and often fails to return the system back to working order.\n\n### Recursion\n\nRecursion is a fundamental tool in modeling software. However it has an often-overlooked problem: unbounded memory allocation.\n\nRecursion is an area of active experimentation in Zig and so the documentation here is not final. You can read a [summary of recursion status in the 0.3.0 release notes](https://ziglang.org/download/0.3.0/release-notes.html#recursion).\n\nThe short summary is that currently recursion works normally as you would expect. Although Zig code is not yet protected from stack overflow, it is planned that a future version of Zig will provide such protection, with some degree of cooperation from Zig code required.\n\n### Lifetime and Ownership\n\nIt is the Zig programmer's responsibility to ensure that a [pointer](#Pointers) is not accessed when the memory pointed to is no longer available. Note that a [slice](#Slices) is a form of pointer, in that it references other memory.\n\nIn order to prevent bugs, there are some helpful conventions to follow when dealing with pointers. In general, when a function returns a pointer, the documentation for the function should explain who \"owns\" the pointer. This concept helps the programmer decide when it is appropriate, if ever, to free the pointer.\n\nFor example, the function's documentation may say \"caller owns the returned memory\", in which case the code that calls the function must have a plan for when to free that memory. Probably in this situation, the function will accept an `Allocator` parameter.\n\nSometimes the lifetime of a pointer may be more complicated. For example, the `std.ArrayList(T).items` slice has a lifetime that remains valid until the next time the list is resized, such as by appending new elements.\n\nThe API documentation for functions and data structures should take great care to explain the ownership and lifetime semantics of pointers. Ownership determines whose responsibility it is to free the memory referenced by the pointer, and lifetime determines the point at which the memory becomes inaccessible (lest [Undefined Behavior](#Undefined-Behavior) occur).\n\n## Compile Variables\n\nCompile variables are accessible by importing the `\"builtin\"` package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode.\n\n``` zig\nconst builtin = @import(\"builtin\");\nconst separator = if (builtin.os.tag == .windows) '\\\\' else '/';\n```\n\ncompile_variables.zig\n\nExample of what is imported with `@import``(``\"builtin\"``)`:\n\n``` zig\nconst std = @import(\"std\");\n/// Zig version. When writing code that supports multiple versions of Zig, prefer\n/// feature detection (i.e. with `@hasDecl` or `@hasField`) over version checks.\npub const zig_version = std.SemanticVersion.parse(zig_version_string) catch unreachable;\npub const zig_version_string = \"0.13.0\";\npub const zig_backend = std.builtin.CompilerBackend.stage2_llvm;\n\npub const output_mode = std.builtin.OutputMode.Exe;\npub const link_mode = std.builtin.LinkMode.static;\npub const is_test = false;\npub const single_threaded = false;\npub const abi = std.Target.Abi.gnu;\npub const cpu: std.Target.Cpu = .{\n    .arch = .x86_64,\n    .model = &std.Target.x86.cpu.znver4,\n    .features = std.Target.x86.featureSet(&[_]std.Target.x86.Feature{\n        .@\"64bit\",\n        .adx,\n        .aes,\n        .allow_light_256_bit,\n        .avx,\n        .avx2,\n        .avx512bf16,\n        .avx512bitalg,\n        .avx512bw,\n        .avx512cd,\n        .avx512dq,\n        .avx512f,\n        .avx512ifma,\n        .avx512vbmi,\n        .avx512vbmi2,\n        .avx512vl,\n        .avx512vnni,\n        .avx512vpopcntdq,\n        .bmi,\n        .bmi2,\n        .branchfusion,\n        .clflushopt,\n        .clwb,\n        .clzero,\n        .cmov,\n        .crc32,\n        .cx16,\n        .cx8,\n        .evex512,\n        .f16c,\n        .fast_15bytenop,\n        .fast_bextr,\n        .fast_lzcnt,\n        .fast_movbe,\n        .fast_scalar_fsqrt,\n        .fast_scalar_shift_masks,\n        .fast_variable_perlane_shuffle,\n        .fast_vector_fsqrt,\n        .fma,\n        .fsgsbase,\n        .fsrm,\n        .fxsr,\n        .gfni,\n        .invpcid,\n        .lzcnt,\n        .macrofusion,\n        .mmx,\n        .movbe,\n        .mwaitx,\n        .nopl,\n        .pclmul,\n        .pku,\n        .popcnt,\n        .prfchw,\n        .rdpid,\n        .rdpru,\n        .rdrnd,\n        .rdseed,\n        .sahf,\n        .sbb_dep_breaking,\n        .sha,\n        .shstk,\n        .slow_shld,\n        .sse,\n        .sse2,\n        .sse3,\n        .sse4_1,\n        .sse4_2,\n        .sse4a,\n        .ssse3,\n        .vaes,\n        .vpclmulqdq,\n        .vzeroupper,\n        .wbnoinvd,\n        .x87,\n        .xsave,\n        .xsavec,\n        .xsaveopt,\n        .xsaves,\n    }),\n};\npub const os = std.Target.Os{\n    .tag = .linux,\n    .version_range = .{ .linux = .{\n        .range = .{\n            .min = .{\n                .major = 6,\n                .minor = 9,\n                .patch = 2,\n            },\n            .max = .{\n                .major = 6,\n                .minor = 9,\n                .patch = 2,\n            },\n        },\n        .glibc = .{\n            .major = 2,\n            .minor = 39,\n            .patch = 0,\n        },\n    }},\n};\npub const target: std.Target = .{\n    .cpu = cpu,\n    .os = os,\n    .abi = abi,\n    .ofmt = object_format,\n    .dynamic_linker = std.Target.DynamicLinker.init(\"/nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/ld-linux-x86-64.so.2\"),\n};\npub const object_format = std.Target.ObjectFormat.elf;\npub const mode = std.builtin.OptimizeMode.Debug;\npub const link_libc = false;\npub const link_libcpp = false;\npub const have_error_return_tracing = true;\npub const valgrind_support = true;\npub const sanitize_thread = false;\npub const position_independent_code = false;\npub const position_independent_executable = false;\npub const strip_debug_info = false;\npub const code_model = std.builtin.CodeModel.default;\npub const omit_frame_pointer = false;\n```\n\n@import(\"builtin\")\n\nSee also:\n\n- [Build Mode](#Build-Mode)\n\n## Root Source File\n\nTODO: explain how root source file finds other files\n\nTODO: pub fn main\n\nTODO: pub fn panic\n\nTODO: if linking with libc you can use export fn main\n\nTODO: order independent top level declarations\n\nTODO: lazy analysis\n\nTODO: using comptime { \\_ = @import() }\n\n## Zig Build System\n\nThe Zig Build System provides a cross-platform, dependency-free way to declare the logic required to build a project. With this system, the logic to build a project is written in a build.zig file, using the Zig Build System API to declare and configure build artifacts and other tasks.\n\nSome examples of tasks the build system can help with:\n\n- Performing tasks in parallel and caching the results.\n- Depending on other projects.\n- Providing a package for other projects to depend on.\n- Creating build artifacts by executing the Zig compiler. This includes building Zig source code as well as C and C++ source code.\n- Capturing user-configured options and using those options to configure the build.\n- Surfacing build configuration as [comptime](#comptime) values by providing a file that can be [imported](#import) by Zig code.\n- Caching build artifacts to avoid unnecessarily repeating steps.\n- Executing build artifacts or system-installed tools.\n- Running tests and verifying the output of executing a build artifact matches the expected value.\n- Running `zig fmt` on a codebase or a subset of it.\n- Custom tasks.\n\nTo use the build system, run zig build --help to see a command-line usage help menu. This will include project-specific options that were declared in the build.zig script.\n\nFor the time being, the build system documentation is hosted externally: [Build System Documentation](https://ziglang.org/learn/build-system/)\n\n## C\n\nAlthough Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code.\n\nThere are a few ways that Zig facilitates C interop.\n\n### C Type Primitives\n\nThese have guaranteed C ABI compatibility and can be used like any other type.\n\n- `c_char`\n- `c_short`\n- `c_ushort`\n- `c_int`\n- `c_uint`\n- `c_long`\n- `c_ulong`\n- `c_longlong`\n- `c_ulonglong`\n- `c_longdouble`\n\nTo interop with the C `void` type, use `anyopaque`.\n\nSee also:\n\n- [Primitive Types](#Primitive-Types)\n\n### Import from C Header File\n\nThe `@cImport` builtin function can be used to directly import symbols from `.h` files:\n\n``` zig\nconst c = @cImport({\n    // See https://github.com/ziglang/zig/issues/515\n    @cDefine(\"_NO_CRT_STDIO_INLINE\", \"1\");\n    @cInclude(\"stdio.h\");\n});\npub fn main() void {\n    _ = c.printf(\"hello\\n\");\n}\n```\n\ncImport_builtin.zig\n\n    $ zig build-exe cImport_builtin.zig -lc\n    $ ./cImport_builtin\n    hello\n\nShell\n\nThe `@cImport` function takes an expression as a parameter. This expression is evaluated at compile-time and is used to control preprocessor directives and include multiple `.h` files:\n\n``` zig\nconst builtin = @import(\"builtin\");\n\nconst c = @cImport({\n    @cDefine(\"NDEBUG\", builtin.mode == .ReleaseFast);\n    if (something) {\n        @cDefine(\"_GNU_SOURCE\", {});\n    }\n    @cInclude(\"stdlib.h\");\n    if (something) {\n        @cUndef(\"_GNU_SOURCE\");\n    }\n    @cInclude(\"soundio.h\");\n});\n```\n\n@cImport Expression\n\nSee also:\n\n- [@cImport](#cImport)\n- [@cInclude](#cInclude)\n- [@cDefine](#cDefine)\n- [@cUndef](#cUndef)\n- [@import](#import)\n\n### C Translation CLI\n\nZig's C translation capability is available as a CLI tool via zig translate-c. It requires a single filename as an argument. It may also take a set of optional flags that are forwarded to clang. It writes the translated file to stdout.\n\n#### [Command line flags](#toc-Command-line-flags)\n\n- -I: Specify a search directory for include files. May be used multiple times. Equivalent to [clang's -I flag](https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-i-dir). The current directory is *not* included by default; use -I. to include it.\n- -D: Define a preprocessor macro. Equivalent to [clang's -D flag](https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-d-macro).\n- -cflags \\[flags\\] --: Pass arbitrary additional [command line flags](https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html) to clang. Note: the list of flags must end with --\n- -target: The [target triple](#Targets) for the translated Zig code. If no target is specified, the current host target will be used.\n\n#### [Using -target and -cflags](#toc-Using--target-and--cflags)\n\n**Important!** When translating C code with zig translate-c, you **must** use the same -target triple that you will use when compiling the translated code. In addition, you **must** ensure that the -cflags used, if any, match the cflags used by code on the target system. Using the incorrect -target or -cflags could result in clang or Zig parse failures, or subtle ABI incompatibilities when linking with C code.\n\n``` zig\nlong FOO = __LONG_MAX__;\n```\n\nvarytarget.h\n\n    $ zig translate-c -target thumb-freestanding-gnueabihf varytarget.h|grep FOO\n    pub export var FOO: c_long = 2147483647;\n    $ zig translate-c -target x86_64-macos-gnu varytarget.h|grep FOO\n    pub export var FOO: c_long = 9223372036854775807;\n\nShell\n\n``` zig\nenum FOO { BAR };\nint do_something(enum FOO foo);\n```\n\nvarycflags.h\n\n    $ zig translate-c varycflags.h|grep -B1 do_something\n    pub const enum_FOO = c_uint;\n    pub extern fn do_something(foo: enum_FOO) c_int;\n    $ zig translate-c -cflags -fshort-enums -- varycflags.h|grep -B1 do_something\n    pub const enum_FOO = u8;\n    pub extern fn do_something(foo: enum_FOO) c_int;\n\nShell\n\n#### [@cImport vs translate-c](#toc-cImport-vs-translate-c)\n\n`@cImport` and zig translate-c use the same underlying C translation functionality, so on a technical level they are equivalent. In practice, `@cImport` is useful as a way to quickly and easily access numeric constants, typedefs, and record types without needing any extra setup. If you need to pass [cflags](#Using--target-and--cflags) to clang, or if you would like to edit the translated code, it is recommended to use zig translate-c and save the results to a file. Common reasons for editing the generated code include: changing `anytype` parameters in function-like macros to more specific types; changing `[*c]T` pointers to `[*]T` or `*T` pointers for improved type safety; and [enabling or disabling runtime safety](#setRuntimeSafety) within specific functions.\n\nSee also:\n\n- [Targets](#Targets)\n- [C Type Primitives](#C-Type-Primitives)\n- [Pointers](#Pointers)\n- [C Pointers](#C-Pointers)\n- [Import from C Header File](#Import-from-C-Header-File)\n- [@cInclude](#cInclude)\n- [@cImport](#cImport)\n- [@setRuntimeSafety](#setRuntimeSafety)\n\n### C Translation Caching\n\nThe C translation feature (whether used via zig translate-c or `@cImport`) integrates with the Zig caching system. Subsequent runs with the same source file, target, and cflags will use the cache instead of repeatedly translating the same code.\n\nTo see where the cached files are stored when compiling code that uses `@cImport`, use the --verbose-cimport flag:\n\n``` zig\nconst c = @cImport({\n    @cDefine(\"_NO_CRT_STDIO_INLINE\", \"1\");\n    @cInclude(\"stdio.h\");\n});\npub fn main() void {\n    _ = c;\n}\n```\n\nverbose_cimport_flag.zig\n\n    $ zig build-exe verbose_cimport_flag.zig -lc --verbose-cimport\n    info(compilation): C import source: /home/andy/src/zig/.zig-cache/o/f4e9c68cba40c97888f064d67b031021/cimport.h\n    info(compilation): C import .d file: /home/andy/src/zig/.zig-cache/o/f4e9c68cba40c97888f064d67b031021/cimport.h.d\n    info(compilation): C import output: /home/andy/src/zig/.zig-cache/o/1b63455e1d0d323f51bdc4909717e28b/cimport.zig\n    $ ./verbose_cimport_flag\n\nShell\n\n`cimport.h` contains the file to translate (constructed from calls to `@cInclude`, `@cDefine`, and `@cUndef`), `cimport.h.d` is the list of file dependencies, and `cimport.zig` contains the translated output.\n\nSee also:\n\n- [Import from C Header File](#Import-from-C-Header-File)\n- [C Translation CLI](#C-Translation-CLI)\n- [@cInclude](#cInclude)\n- [@cImport](#cImport)\n\n### Translation failures\n\nSome C constructs cannot be translated to Zig - for example, *goto*, structs with bitfields, and token-pasting macros. Zig employs *demotion* to allow translation to continue in the face of non-translatable entities.\n\nDemotion comes in three varieties - [opaque](#opaque), *extern*, and `@compileError`. C structs and unions that cannot be translated correctly will be translated as `opaque``{}`. Functions that contain opaque types or code constructs that cannot be translated will be demoted to `extern` declarations. Thus, non-translatable types can still be used as pointers, and non-translatable functions can be called so long as the linker is aware of the compiled function.\n\n`@compileError` is used when top-level definitions (global variables, function prototypes, macros) cannot be translated or demoted. Since Zig uses lazy analysis for top-level declarations, untranslatable entities will not cause a compile error in your code unless you actually use them.\n\nSee also:\n\n- [opaque](#opaque)\n- [extern](#extern)\n- [@compileError](#compileError)\n\n### C Macros\n\nC Translation makes a best-effort attempt to translate function-like macros into equivalent Zig functions. Since C macros operate at the level of lexical tokens, not all C macros can be translated to Zig. Macros that cannot be translated will be demoted to `@compileError`. Note that C code which *uses* macros will be translated without any additional issues (since Zig operates on the pre-processed source with macros expanded). It is merely the macros themselves which may not be translatable to Zig.\n\nConsider the following example:\n\n``` zig\n#define MAKELOCAL(NAME, INIT) int NAME = INIT\nint foo(void) {\n   MAKELOCAL(a, 1);\n   MAKELOCAL(b, 2);\n   return a + b;\n}\n```\n\nmacro.c\n\n    $ zig translate-c macro.c > macro.zig\n\nShell\n\n``` zig\npub export fn foo() c_int {\n    var a: c_int = 1;\n    _ = &a;\n    var b: c_int = 2;\n    _ = &b;\n    return a + b;\n}\npub const MAKELOCAL = @compileError(\"unable to translate C expr: unexpected token .Equal\"); // macro.c:1:9\n```\n\nmacro.zig\n\nNote that `foo` was translated correctly despite using a non-translatable macro. `MAKELOCAL` was demoted to `@compileError` since it cannot be expressed as a Zig function; this simply means that you cannot directly use `MAKELOCAL` from Zig.\n\nSee also:\n\n- [@compileError](#compileError)\n\n### C Pointers\n\nThis type is to be avoided whenever possible. The only valid reason for using a C pointer is in auto-generated code from translating C code.\n\nWhen importing C header files, it is ambiguous whether pointers should be translated as single-item pointers (`*T`) or many-item pointers (`[*]T`). C pointers are a compromise so that Zig code can utilize translated header files directly.\n\n`[*c]T` - C pointer.\n\n- Supports all the syntax of the other two pointer types (`*T`) and (`[*]T`).\n- Coerces to other pointer types, as well as [Optional Pointers](#Optional-Pointers). When a C pointer is coerced to a non-optional pointer, safety-checked [Undefined Behavior](#Undefined-Behavior) occurs if the address is 0.\n- Allows address 0. On non-freestanding targets, dereferencing address 0 is safety-checked [Undefined Behavior](#Undefined-Behavior). Optional C pointers introduce another bit to keep track of null, just like `?``usize`. Note that creating an optional C pointer is unnecessary as one can use normal [Optional Pointers](#Optional-Pointers).\n- Supports [Type Coercion](#Type-Coercion) to and from integers.\n- Supports comparison with integers.\n- Does not support Zig-only pointer attributes such as alignment. Use normal [Pointers](#Pointers) please!\n\nWhen a C pointer is pointing to a single struct (not an array), dereference the C pointer to access the struct's fields or member data. That syntax looks like this:\n\n`ptr_to_struct.*.struct_member`\n\nThis is comparable to doing `->` in C.\n\nWhen a C pointer is pointing to an array of structs, the syntax reverts to this:\n\n`ptr_to_struct_array[index].struct_member`\n\n### C Variadic Functions\n\nZig supports extern variadic functions.\n\n``` zig\nconst std = @import(\"std\");\nconst testing = std.testing;\n\npub extern \"c\" fn printf(format: [*:0]const u8, ...) c_int;\n\ntest \"variadic function\" {\n    try testing.expect(printf(\"Hello, world!\\n\") == 14);\n    try testing.expect(@typeInfo(@TypeOf(printf)).Fn.is_var_args);\n}\n```\n\ntest_variadic_function.zig\n\n    $ zig test test_variadic_function.zig -lc\n    1/1 test_variadic_function.test.variadic function...OK\n    All 1 tests passed.\n    Hello, world!\n\nShell\n\nVariadic functions can be implemented using [@cVaStart](#cVaStart), [@cVaEnd](#cVaEnd), [@cVaArg](#cVaArg) and [@cVaCopy](#cVaCopy).\n\n``` zig\nconst std = @import(\"std\");\nconst testing = std.testing;\nconst builtin = @import(\"builtin\");\n\nfn add(count: c_int, ...) callconv(.C) c_int {\n    var ap = @cVaStart();\n    defer @cVaEnd(&ap);\n    var i: usize = 0;\n    var sum: c_int = 0;\n    while (i < count) : (i += 1) {\n        sum += @cVaArg(&ap, c_int);\n    }\n    return sum;\n}\n\ntest \"defining a variadic function\" {\n    if (builtin.cpu.arch == .aarch64 and builtin.os.tag != .macos) {\n        // https://github.com/ziglang/zig/issues/14096\n        return error.SkipZigTest;\n    }\n    if (builtin.cpu.arch == .x86_64 and builtin.os.tag == .windows) {\n        // https://github.com/ziglang/zig/issues/16961\n        return error.SkipZigTest;\n    }\n\n    try std.testing.expectEqual(@as(c_int, 0), add(0));\n    try std.testing.expectEqual(@as(c_int, 1), add(1, @as(c_int, 1)));\n    try std.testing.expectEqual(@as(c_int, 3), add(2, @as(c_int, 1), @as(c_int, 2)));\n}\n```\n\ntest_defining_variadic_function.zig\n\n    $ zig test test_defining_variadic_function.zig\n    1/1 test_defining_variadic_function.test.defining a variadic function...OK\n    All 1 tests passed.\n\nShell\n\n### Exporting a C Library\n\nOne of the primary use cases for Zig is exporting a library with the C ABI for other programming languages to call into. The `export` keyword in front of functions, variables, and types causes them to be part of the library API:\n\n``` zig\nexport fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n```\n\nmathtest.zig\n\nTo make a static library:\n\n    $ zig build-lib mathtest.zig\n\nShell\n\nTo make a shared library:\n\n    $ zig build-lib mathtest.zig -dynamic\n\nShell\n\nHere is an example with the [Zig Build System](#Zig-Build-System):\n\n``` zig\n// This header is generated by zig from mathtest.zig\n#include \"mathtest.h\"\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    int32_t result = add(42, 1337);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n```\n\ntest.c\n\n``` zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const lib = b.addSharedLibrary(.{\n        .name = \"mathtest\",\n        .root_source_file = b.path(\"mathtest.zig\"),\n        .version = .{ .major = 1, .minor = 0, .patch = 0 },\n    });\n    const exe = b.addExecutable(.{\n        .name = \"test\",\n    });\n    exe.addCSourceFile(.{ .file = b.path(\"test.c\"), .flags = &.{\"-std=c99\"} });\n    exe.linkLibrary(lib);\n    exe.linkSystemLibrary(\"c\");\n\n    b.default_step.dependOn(&exe.step);\n\n    const run_cmd = exe.run();\n\n    const test_step = b.step(\"test\", \"Test the program\");\n    test_step.dependOn(&run_cmd.step);\n}\n```\n\nbuild_c.zig\n\n    $ zig build test\n    1379\n\nShell\n\nSee also:\n\n- [export](#export)\n\n### Mixing Object Files\n\nYou can mix Zig object files with any other object files that respect the C ABI. Example:\n\n``` zig\nconst base64 = @import(\"std\").base64;\n\nexport fn decode_base_64(\n    dest_ptr: [*]u8,\n    dest_len: usize,\n    source_ptr: [*]const u8,\n    source_len: usize,\n) usize {\n    const src = source_ptr[0..source_len];\n    const dest = dest_ptr[0..dest_len];\n    const base64_decoder = base64.standard.Decoder;\n    const decoded_size = base64_decoder.calcSizeForSlice(src) catch unreachable;\n    base64_decoder.decode(dest[0..decoded_size], src) catch unreachable;\n    return decoded_size;\n}\n```\n\nbase64.zig\n\n``` zig\n// This header is generated by zig from base64.zig\n#include \"base64.h\"\n\n#include <string.h>\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    const char *encoded = \"YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz\";\n    char buf[200];\n\n    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));\n    buf[len] = 0;\n    puts(buf);\n\n    return 0;\n}\n```\n\ntest.c\n\n``` zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const obj = b.addObject(.{\n        .name = \"base64\",\n        .root_source_file = b.path(\"base64.zig\"),\n    });\n\n    const exe = b.addExecutable(.{\n        .name = \"test\",\n    });\n    exe.addCSourceFile(.{ .file = b.path(\"test.c\"), .flags = &.{\"-std=c99\"} });\n    exe.addObject(obj);\n    exe.linkSystemLibrary(\"c\");\n    b.installArtifact(exe);\n}\n```\n\nbuild_object.zig\n\n    $ zig build\n    $ ./zig-out/bin/test\n    all your base are belong to us\n\nShell\n\nSee also:\n\n- [Targets](#Targets)\n- [Zig Build System](#Zig-Build-System)\n\n## WebAssembly\n\nZig supports building for WebAssembly out of the box.\n\n### Freestanding\n\nFor host environments like the web browser and nodejs, build as an executable using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs.\n\n``` zig\nextern fn print(i32) void;\n\nexport fn add(a: i32, b: i32) void {\n    print(a + b);\n}\n```\n\nmath.zig\n\n    $ zig build-exe math.zig -target wasm32-freestanding -fno-entry --export=add\n\nShell\n\n``` zig\nconst fs = require('fs');\nconst source = fs.readFileSync(\"./math.wasm\");\nconst typedArray = new Uint8Array(source);\n\nWebAssembly.instantiate(typedArray, {\n  env: {\n    print: (result) => { console.log(`The result is ${result}`); }\n  }}).then(result => {\n  const add = result.instance.exports.add;\n  add(1, 2);\n});\n```\n\ntest.js\n\n    $ node test.js\n    The result is 3\n\nShell\n\n### WASI\n\nZig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments:\n\n``` zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};\n    const gpa = general_purpose_allocator.allocator();\n    const args = try std.process.argsAlloc(gpa);\n    defer std.process.argsFree(gpa, args);\n\n    for (args, 0..) |arg, i| {\n        std.debug.print(\"{}: {s}\\n\", .{ i, arg });\n    }\n}\n```\n\nwasi_args.zig\n\n    $ zig build-exe wasi_args.zig -target wasm32-wasi\n\nShell\n\n    $ wasmtime wasi_args.wasm 123 hello\n    0: wasi_args.wasm\n    1: 123\n    2: hello\n\nShell\n\nA more interesting example would be extracting the list of preopens from the runtime. This is now supported in the standard library via `std.fs.wasi.Preopens`:\n\n``` zig\nconst std = @import(\"std\");\nconst fs = std.fs;\n\npub fn main() !void {\n    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};\n    const gpa = general_purpose_allocator.allocator();\n\n    var arena_instance = std.heap.ArenaAllocator.init(gpa);\n    defer arena_instance.deinit();\n    const arena = arena_instance.allocator();\n\n    const preopens = try fs.wasi.preopensAlloc(arena);\n\n    for (preopens.names, 0..) |preopen, i| {\n        std.debug.print(\"{}: {s}\\n\", .{ i, preopen });\n    }\n}\n```\n\nwasi_preopens.zig\n\n    $ zig build-exe wasi_preopens.zig -target wasm32-wasi\n\nShell\n\n    $ wasmtime --dir=. wasi_preopens.wasm\n    0: stdin\n    1: stdout\n    2: stderr\n    3: .\n\nShell\n\n## Targets\n\n**Target** refers to the computer that will be used to run an executable. It is composed of the CPU architecture, the set of enabled CPU features, operating system, minimum and maximum operating system version, ABI, and ABI version.\n\nZig is a general-purpose programming language which means that it is designed to generate optimal code for a large set of targets. The command `zig targets` provides information about all of the targets the compiler is aware of.\n\nWhen no target option is provided to the compiler, the default choice is to target the **host computer**, meaning that the resulting executable will be *unsuitable for copying to a different computer*. In order to copy an executable to another computer, the compiler needs to know about the target requirements via the `-target` option.\n\nThe Zig Standard Library (`@import``(``\"std\"``)`) has cross-platform abstractions, making the same source code viable on many targets. Some code is more portable than other code. In general, Zig code is extremely portable compared to other programming languages.\n\nEach platform requires its own implementations to make Zig's cross-platform abstractions work. These implementations are at various degrees of completion. Each tagged release of the compiler comes with release notes that provide the full support table for each target.\n\n## Style Guide\n\nThese coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style.\n\n### Avoid Redundancy in Names\n\nAvoid these words in type names:\n\n- Value\n- Data\n- Context\n- Manager\n- utils, misc, or somebody's initials\n\nEverything is a value, all types are data, everything is context, all logic manages state. Nothing is communicated by using a word that applies to all types.\n\nTemptation to use \"utilities\", \"miscellaneous\", or somebody's initials is a failure to categorize, or more commonly, overcategorization. Such declarations can live at the root of a module that needs them with no namespace needed.\n\n### Avoid Redundant Names in Fully-Qualified Namespaces\n\nEvery declaration is assigned a **fully qualified namespace** by the compiler, creating a tree structure. Choose names based on the fully-qualified namespace, and avoid redundant name segments.\n\n``` zig\nconst std = @import(\"std\");\n\npub const json = struct {\n    pub const JsonValue = union(enum) {\n        number: f64,\n        boolean: bool,\n        // ...\n    };\n};\n\npub fn main() void {\n    std.debug.print(\"{s}\\n\", .{@typeName(json.JsonValue)});\n}\n```\n\nredundant_fqn.zig\n\n    $ zig build-exe redundant_fqn.zig\n    $ ./redundant_fqn\n    redundant_fqn.json.JsonValue\n\nShell\n\nIn this example, \"json\" is repeated in the fully-qualified namespace. The solution is to delete `Json` from `JsonValue`. In this example we have an empty struct named `json` but remember that files also act as part of the fully-qualified namespace.\n\nThis example is an exception to the rule specified in [Avoid Redundancy in Names](#Avoid-Redundancy-in-Names). The meaning of the type has been reduced to its core: it is a json value. The name cannot be any more specific without being incorrect.\n\n### Whitespace\n\n- 4 space indentation\n- Open braces on same line, unless you need to wrap.\n- If a list of things is longer than 2, put each item on its own line and exercise the ability to put an extra comma at the end.\n- Line length: aim for 100; use common sense.\n\n### Names\n\nRoughly speaking: `camelCaseFunctionName`, `TitleCaseTypeName`, `snake_case_variable_name`. More precisely:\n\n- If `x` is a `type` then `x` should be `TitleCase`, unless it is a `struct` with 0 fields and is never meant to be instantiated, in which case it is considered to be a \"namespace\" and uses `snake_case`.\n- If `x` is callable, and `x`'s return type is `type`, then `x` should be `TitleCase`.\n- If `x` is otherwise callable, then `x` should be `camelCase`.\n- Otherwise, `x` should be `snake_case`.\n\nAcronyms, initialisms, proper nouns, or any other word that has capitalization rules in written English are subject to naming conventions just like any other word. Even acronyms that are only 2 letters long are subject to these conventions.\n\nFile names fall into two categories: types and namespaces. If the file (implicitly a struct) has top level fields, it should be named like any other struct with fields using `TitleCase`. Otherwise, it should use `snake_case`. Directory names should be `snake_case`.\n\nThese are general rules of thumb; if it makes sense to do something different, do what makes sense. For example, if there is an established convention such as `ENOENT`, follow the established convention.\n\n### Examples\n\n``` zig\nconst namespace_name = @import(\"dir_name/file_name.zig\");\nconst TypeName = @import(\"dir_name/TypeName.zig\");\nvar global_var: i32 = undefined;\nconst const_name = 42;\nconst primitive_type_alias = f32;\nconst string_alias = []u8;\n\nconst StructName = struct {\n    field: i32,\n};\nconst StructAlias = StructName;\n\nfn functionName(param_name: TypeName) void {\n    var functionPointer = functionName;\n    functionPointer();\n    functionPointer = otherFunction;\n    functionPointer();\n}\nconst functionAlias = functionName;\n\nfn ListTemplateFunction(comptime ChildType: type, comptime fixed_size: usize) type {\n    return List(ChildType, fixed_size);\n}\n\nfn ShortList(comptime T: type, comptime n: usize) type {\n    return struct {\n        field_name: [n]T,\n        fn methodName() void {}\n    };\n}\n\n// The word XML loses its casing when used in Zig identifiers.\nconst xml_document =\n    \\\\<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    \\\\<document>\n    \\\\</document>\n;\nconst XmlParser = struct {\n    field: i32,\n};\n\n// The initials BE (Big Endian) are just another word in Zig identifier names.\nfn readU32Be() u32 {}\n```\n\nstyle_example.zig\n\nSee the [Zig Standard Library](#Zig-Standard-Library) for more examples.\n\n### Doc Comment Guidance\n\n- Omit any information that is redundant based on the name of the thing being documented.\n- Duplicating information onto multiple similar functions is encouraged because it helps IDEs and other tools provide better help text.\n- Use the word **assume** to indicate invariants that cause [Undefined Behavior](#Undefined-Behavior) when violated.\n- Use the word **assert** to indicate invariants that cause *safety-checked* [Undefined Behavior](#Undefined-Behavior) when violated.\n\n## Source Encoding\n\nZig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error.\n\nThroughout all zig source code (including in comments), some code points are never allowed:\n\n- Ascii control characters, except for U+000a (LF), U+000d (CR), and U+0009 (HT): U+0000 - U+0008, U+000b - U+000c, U+000e - U+0001f, U+007f.\n- Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS).\n\nLF (byte value 0x0a, code point U+000a, `'\\n'`) is the line terminator in Zig source code. This byte value terminates every line of zig source code except the last line of the file. It is recommended that non-empty source files end with an empty line, which means the last byte would be 0x0a (LF).\n\nEach LF may be immediately preceded by a single CR (byte value 0x0d, code point U+000d, `'\\r'`) to form a Windows style line ending, but this is discouraged. Note that in multiline strings, CRLF sequences will be encoded as LF when compiled into a zig program. A CR in any other context is not allowed.\n\nHT hard tabs (byte value 0x09, code point U+0009, `'\\t'`) are interchangeable with SP spaces (byte value 0x20, code point U+0020, `' '`) as a token separator, but use of hard tabs is discouraged. See [Grammar](#Grammar).\n\nFor compatibility with other tools, the compiler ignores a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark is not allowed anywhere else in the source.\n\nNote that running zig fmt on a source file will implement all recommendations mentioned here.\n\nNote that a tool reading Zig source code can make assumptions if the source code is assumed to be correct Zig code. For example, when identifying the ends of lines, a tool can use a naive search such as `/\\n/`, or an [advanced](https://msdn.microsoft.com/en-us/library/dd409797.aspx) search such as `/\\r\\n?|[\\n\\u0085\\u2028\\u2029]/`, and in either case line endings will be correctly identified. For another example, when identifying the whitespace before the first token on a line, a tool can either use a naive search such as `/[ \\t]/`, or an [advanced](https://tc39.es/ecma262/#sec-characterclassescape) search such as `/\\s/`, and in either case whitespace will be correctly identified.\n\n## Keyword Reference\n\n[TABLE]\n\n## Appendix\n\n### Containers\n\nA *container* in Zig is any syntactical construct that acts as a namespace to hold [variable](#Container-Level-Variables) and [function](#Functions) declarations. Containers are also type definitions which can be instantiated. [Structs](#struct), [enums](#enum), [unions](#union), [opaques](#opaque), and even Zig source files themselves are containers.\n\nAlthough containers (except Zig source files) use curly braces to surround their definition, they should not be confused with [blocks](#Blocks) or functions. Containers do not contain statements.\n\n### Grammar\n\n``` zig\nRoot <- skip container_doc_comment? ContainerMembers eof\n\n# *** Top level ***\nContainerMembers <- ContainerDeclaration* (ContainerField COMMA)* (ContainerField / ContainerDeclaration*)\n\nContainerDeclaration <- TestDecl / ComptimeDecl / doc_comment? KEYWORD_pub? Decl\n\nTestDecl <- KEYWORD_test (STRINGLITERALSINGLE / IDENTIFIER)? Block\n\nComptimeDecl <- KEYWORD_comptime Block\n\nDecl\n    <- (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE? / KEYWORD_inline / KEYWORD_noinline)? FnProto (SEMICOLON / Block)\n     / (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE?)? KEYWORD_threadlocal? GlobalVarDecl\n     / KEYWORD_usingnamespace Expr SEMICOLON\n\nFnProto <- KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? AddrSpace? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr\n\nVarDeclProto <- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? AddrSpace? LinkSection?\n\nGlobalVarDecl <- VarDeclProto (EQUAL Expr)? SEMICOLON\n\nContainerField <- doc_comment? KEYWORD_comptime? !KEYWORD_fn (IDENTIFIER COLON)? TypeExpr ByteAlign? (EQUAL Expr)?\n\n# *** Block Level ***\nStatement\n    <- KEYWORD_comptime ComptimeStatement\n     / KEYWORD_nosuspend BlockExprStatement\n     / KEYWORD_suspend BlockExprStatement\n     / KEYWORD_defer BlockExprStatement\n     / KEYWORD_errdefer Payload? BlockExprStatement\n     / IfStatement\n     / LabeledStatement\n     / SwitchExpr\n     / VarDeclExprStatement\n\nComptimeStatement\n    <- BlockExpr\n     / VarDeclExprStatement\n\nIfStatement\n    <- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?\n     / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )\n\nLabeledStatement <- BlockLabel? (Block / LoopStatement)\n\nLoopStatement <- KEYWORD_inline? (ForStatement / WhileStatement)\n\nForStatement\n    <- ForPrefix BlockExpr ( KEYWORD_else Statement )?\n     / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )\n\nWhileStatement\n    <- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?\n     / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )\n\nBlockExprStatement\n    <- BlockExpr\n     / AssignExpr SEMICOLON\n\nBlockExpr <- BlockLabel? Block\n\n# An expression, assignment, or any destructure, as a statement.\nVarDeclExprStatement\n    <- VarDeclProto (COMMA (VarDeclProto / Expr))* EQUAL Expr SEMICOLON\n     / Expr (AssignOp Expr / (COMMA (VarDeclProto / Expr))+ EQUAL Expr)? SEMICOLON\n\n# *** Expression Level ***\n\n# An assignment or a destructure whose LHS are all lvalue expressions.\nAssignExpr <- Expr (AssignOp Expr / (COMMA Expr)+ EQUAL Expr)?\n\nSingleAssignExpr <- Expr (AssignOp Expr)?\n\nExpr <- BoolOrExpr\n\nBoolOrExpr <- BoolAndExpr (KEYWORD_or BoolAndExpr)*\n\nBoolAndExpr <- CompareExpr (KEYWORD_and CompareExpr)*\n\nCompareExpr <- BitwiseExpr (CompareOp BitwiseExpr)?\n\nBitwiseExpr <- BitShiftExpr (BitwiseOp BitShiftExpr)*\n\nBitShiftExpr <- AdditionExpr (BitShiftOp AdditionExpr)*\n\nAdditionExpr <- MultiplyExpr (AdditionOp MultiplyExpr)*\n\nMultiplyExpr <- PrefixExpr (MultiplyOp PrefixExpr)*\n\nPrefixExpr <- PrefixOp* PrimaryExpr\n\nPrimaryExpr\n    <- AsmExpr\n     / IfExpr\n     / KEYWORD_break BreakLabel? Expr?\n     / KEYWORD_comptime Expr\n     / KEYWORD_nosuspend Expr\n     / KEYWORD_continue BreakLabel?\n     / KEYWORD_resume Expr\n     / KEYWORD_return Expr?\n     / BlockLabel? LoopExpr\n     / Block\n     / CurlySuffixExpr\n\nIfExpr <- IfPrefix Expr (KEYWORD_else Payload? Expr)?\n\nBlock <- LBRACE Statement* RBRACE\n\nLoopExpr <- KEYWORD_inline? (ForExpr / WhileExpr)\n\nForExpr <- ForPrefix Expr (KEYWORD_else Expr)?\n\nWhileExpr <- WhilePrefix Expr (KEYWORD_else Payload? Expr)?\n\nCurlySuffixExpr <- TypeExpr InitList?\n\nInitList\n    <- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE\n     / LBRACE Expr (COMMA Expr)* COMMA? RBRACE\n     / LBRACE RBRACE\n\nTypeExpr <- PrefixTypeOp* ErrorUnionExpr\n\nErrorUnionExpr <- SuffixExpr (EXCLAMATIONMARK TypeExpr)?\n\nSuffixExpr\n    <- KEYWORD_async PrimaryTypeExpr SuffixOp* FnCallArguments\n     / PrimaryTypeExpr (SuffixOp / FnCallArguments)*\n\nPrimaryTypeExpr\n    <- BUILTINIDENTIFIER FnCallArguments\n     / CHAR_LITERAL\n     / ContainerDecl\n     / DOT IDENTIFIER\n     / DOT InitList\n     / ErrorSetDecl\n     / FLOAT\n     / FnProto\n     / GroupedExpr\n     / LabeledTypeExpr\n     / IDENTIFIER\n     / IfTypeExpr\n     / INTEGER\n     / KEYWORD_comptime TypeExpr\n     / KEYWORD_error DOT IDENTIFIER\n     / KEYWORD_anyframe\n     / KEYWORD_unreachable\n     / STRINGLITERAL\n     / SwitchExpr\n\nContainerDecl <- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto\n\nErrorSetDecl <- KEYWORD_error LBRACE IdentifierList RBRACE\n\nGroupedExpr <- LPAREN Expr RPAREN\n\nIfTypeExpr <- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?\n\nLabeledTypeExpr\n    <- BlockLabel Block\n     / BlockLabel? LoopTypeExpr\n\nLoopTypeExpr <- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)\n\nForTypeExpr <- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?\n\nWhileTypeExpr <- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?\n\nSwitchExpr <- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE\n\n# *** Assembly ***\nAsmExpr <- KEYWORD_asm KEYWORD_volatile? LPAREN Expr AsmOutput? RPAREN\n\nAsmOutput <- COLON AsmOutputList AsmInput?\n\nAsmOutputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN\n\nAsmInput <- COLON AsmInputList AsmClobbers?\n\nAsmInputItem <- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN\n\nAsmClobbers <- COLON StringList\n\n# *** Helper grammar ***\nBreakLabel <- COLON IDENTIFIER\n\nBlockLabel <- IDENTIFIER COLON\n\nFieldInit <- DOT IDENTIFIER EQUAL Expr\n\nWhileContinueExpr <- COLON LPAREN AssignExpr RPAREN\n\nLinkSection <- KEYWORD_linksection LPAREN Expr RPAREN\n\nAddrSpace <- KEYWORD_addrspace LPAREN Expr RPAREN\n\n# Fn specific\nCallConv <- KEYWORD_callconv LPAREN Expr RPAREN\n\nParamDecl\n    <- doc_comment? (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType\n     / DOT3\n\nParamType\n    <- KEYWORD_anytype\n     / TypeExpr\n\n# Control flow prefixes\nIfPrefix <- KEYWORD_if LPAREN Expr RPAREN PtrPayload?\n\nWhilePrefix <- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?\n\nForPrefix <- KEYWORD_for LPAREN ForArgumentsList RPAREN PtrListPayload\n\n# Payloads\nPayload <- PIPE IDENTIFIER PIPE\n\nPtrPayload <- PIPE ASTERISK? IDENTIFIER PIPE\n\nPtrIndexPayload <- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE\n\nPtrListPayload <- PIPE ASTERISK? IDENTIFIER (COMMA ASTERISK? IDENTIFIER)* COMMA? PIPE\n\n# Switch specific\nSwitchProng <- KEYWORD_inline? SwitchCase EQUALRARROW PtrIndexPayload? SingleAssignExpr\n\nSwitchCase\n    <- SwitchItem (COMMA SwitchItem)* COMMA?\n     / KEYWORD_else\n\nSwitchItem <- Expr (DOT3 Expr)?\n\n# For specific\nForArgumentsList <- ForItem (COMMA ForItem)* COMMA?\n\nForItem <- Expr (DOT2 Expr?)?\n\n# Operators\nAssignOp\n    <- ASTERISKEQUAL\n     / ASTERISKPIPEEQUAL\n     / SLASHEQUAL\n     / PERCENTEQUAL\n     / PLUSEQUAL\n     / PLUSPIPEEQUAL\n     / MINUSEQUAL\n     / MINUSPIPEEQUAL\n     / LARROW2EQUAL\n     / LARROW2PIPEEQUAL\n     / RARROW2EQUAL\n     / AMPERSANDEQUAL\n     / CARETEQUAL\n     / PIPEEQUAL\n     / ASTERISKPERCENTEQUAL\n     / PLUSPERCENTEQUAL\n     / MINUSPERCENTEQUAL\n     / EQUAL\n\nCompareOp\n    <- EQUALEQUAL\n     / EXCLAMATIONMARKEQUAL\n     / LARROW\n     / RARROW\n     / LARROWEQUAL\n     / RARROWEQUAL\n\nBitwiseOp\n    <- AMPERSAND\n     / CARET\n     / PIPE\n     / KEYWORD_orelse\n     / KEYWORD_catch Payload?\n\nBitShiftOp\n    <- LARROW2\n     / RARROW2\n     / LARROW2PIPE\n\nAdditionOp\n    <- PLUS\n     / MINUS\n     / PLUS2\n     / PLUSPERCENT\n     / MINUSPERCENT\n     / PLUSPIPE\n     / MINUSPIPE\n\nMultiplyOp\n    <- PIPE2\n     / ASTERISK\n     / SLASH\n     / PERCENT\n     / ASTERISK2\n     / ASTERISKPERCENT\n     / ASTERISKPIPE\n\nPrefixOp\n    <- EXCLAMATIONMARK\n     / MINUS\n     / TILDE\n     / MINUSPERCENT\n     / AMPERSAND\n     / KEYWORD_try\n     / KEYWORD_await\n\nPrefixTypeOp\n    <- QUESTIONMARK\n     / KEYWORD_anyframe MINUSRARROW\n     / SliceTypeStart (ByteAlign / AddrSpace / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*\n     / PtrTypeStart (AddrSpace / KEYWORD_align LPAREN Expr (COLON Expr COLON Expr)? RPAREN / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*\n     / ArrayTypeStart\n\nSuffixOp\n    <- LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET\n     / DOT IDENTIFIER\n     / DOTASTERISK\n     / DOTQUESTIONMARK\n\nFnCallArguments <- LPAREN ExprList RPAREN\n\n# Ptr specific\nSliceTypeStart <- LBRACKET (COLON Expr)? RBRACKET\n\nPtrTypeStart\n    <- ASTERISK\n     / ASTERISK2\n     / LBRACKET ASTERISK (LETTERC / COLON Expr)? RBRACKET\n\nArrayTypeStart <- LBRACKET Expr (COLON Expr)? RBRACKET\n\n# ContainerDecl specific\nContainerDeclAuto <- ContainerDeclType LBRACE container_doc_comment? ContainerMembers RBRACE\n\nContainerDeclType\n    <- KEYWORD_struct (LPAREN Expr RPAREN)?\n     / KEYWORD_opaque\n     / KEYWORD_enum (LPAREN Expr RPAREN)?\n     / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?\n\n# Alignment\nByteAlign <- KEYWORD_align LPAREN Expr RPAREN\n\n# Lists\nIdentifierList <- (doc_comment? IDENTIFIER COMMA)* (doc_comment? IDENTIFIER)?\n\nSwitchProngList <- (SwitchProng COMMA)* SwitchProng?\n\nAsmOutputList <- (AsmOutputItem COMMA)* AsmOutputItem?\n\nAsmInputList <- (AsmInputItem COMMA)* AsmInputItem?\n\nStringList <- (STRINGLITERAL COMMA)* STRINGLITERAL?\n\nParamDeclList <- (ParamDecl COMMA)* ParamDecl?\n\nExprList <- (Expr COMMA)* Expr?\n\n# *** Tokens ***\neof <- !.\nbin <- [01]\nbin_ <- '_'? bin\noct <- [0-7]\noct_ <- '_'? oct\nhex <- [0-9a-fA-F]\nhex_ <- '_'? hex\ndec <- [0-9]\ndec_ <- '_'? dec\n\nbin_int <- bin bin_*\noct_int <- oct oct_*\ndec_int <- dec dec_*\nhex_int <- hex hex_*\n\nox80_oxBF <- [\\200-\\277]\noxF4 <- '\\364'\nox80_ox8F <- [\\200-\\217]\noxF1_oxF3 <- [\\361-\\363]\noxF0 <- '\\360'\nox90_0xBF <- [\\220-\\277]\noxEE_oxEF <- [\\356-\\357]\noxED <- '\\355'\nox80_ox9F <- [\\200-\\237]\noxE1_oxEC <- [\\341-\\354]\noxE0 <- '\\340'\noxA0_oxBF <- [\\240-\\277]\noxC2_oxDF <- [\\302-\\337]\n\n# From https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/\n# First Byte      Second Byte     Third Byte      Fourth Byte\n# [0x00,0x7F]\n# [0xC2,0xDF]     [0x80,0xBF]\n#    0xE0         [0xA0,0xBF]     [0x80,0xBF]\n# [0xE1,0xEC]     [0x80,0xBF]     [0x80,0xBF]\n#    0xED         [0x80,0x9F]     [0x80,0xBF]\n# [0xEE,0xEF]     [0x80,0xBF]     [0x80,0xBF]\n#    0xF0         [0x90,0xBF]     [0x80,0xBF]     [0x80,0xBF]\n# [0xF1,0xF3]     [0x80,0xBF]     [0x80,0xBF]     [0x80,0xBF]\n#    0xF4         [0x80,0x8F]     [0x80,0xBF]     [0x80,0xBF]\n\nmb_utf8_literal <-\n       oxF4      ox80_ox8F ox80_oxBF ox80_oxBF\n     / oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF\n     / oxF0      ox90_0xBF ox80_oxBF ox80_oxBF\n     / oxEE_oxEF ox80_oxBF ox80_oxBF\n     / oxED      ox80_ox9F ox80_oxBF\n     / oxE1_oxEC ox80_oxBF ox80_oxBF\n     / oxE0      oxA0_oxBF ox80_oxBF\n     / oxC2_oxDF ox80_oxBF\n\nascii_char_not_nl_slash_squote <- [\\000-\\011\\013-\\046\\050-\\133\\135-\\177]\n\nchar_escape\n    <- \"\\\\x\" hex hex\n     / \"\\\\u{\" hex+ \"}\"\n     / \"\\\\\" [nr\\\\t'\"]\nchar_char\n    <- mb_utf8_literal\n     / char_escape\n     / ascii_char_not_nl_slash_squote\n\nstring_char\n    <- char_escape\n     / [^\\\\\"\\n]\n\ncontainer_doc_comment <- ('//!' [^\\n]* [ \\n]* skip)+\ndoc_comment <- ('///' [^\\n]* [ \\n]* skip)+\nline_comment <- '//' ![!/][^\\n]* / '////' [^\\n]*\nline_string <- (\"\\\\\\\\\" [^\\n]* [ \\n]*)+\nskip <- ([ \\n] / line_comment)*\n\nCHAR_LITERAL <- \"'\" char_char \"'\" skip\nFLOAT\n    <- \"0x\" hex_int \".\" hex_int ([pP] [-+]? dec_int)? skip\n     /      dec_int \".\" dec_int ([eE] [-+]? dec_int)? skip\n     / \"0x\" hex_int [pP] [-+]? dec_int skip\n     /      dec_int [eE] [-+]? dec_int skip\nINTEGER\n    <- \"0b\" bin_int skip\n     / \"0o\" oct_int skip\n     / \"0x\" hex_int skip\n     /      dec_int   skip\nSTRINGLITERALSINGLE <- \"\\\"\" string_char* \"\\\"\" skip\nSTRINGLITERAL\n    <- STRINGLITERALSINGLE\n     / (line_string                 skip)+\nIDENTIFIER\n    <- !keyword [A-Za-z_] [A-Za-z0-9_]* skip\n     / \"@\" STRINGLITERALSINGLE\nBUILTINIDENTIFIER <- \"@\"[A-Za-z_][A-Za-z0-9_]* skip\n\n\nAMPERSAND            <- '&'      ![=]      skip\nAMPERSANDEQUAL       <- '&='               skip\nASTERISK             <- '*'      ![*%=|]   skip\nASTERISK2            <- '**'               skip\nASTERISKEQUAL        <- '*='               skip\nASTERISKPERCENT      <- '*%'     ![=]      skip\nASTERISKPERCENTEQUAL <- '*%='              skip\nASTERISKPIPE         <- '*|'     ![=]      skip\nASTERISKPIPEEQUAL    <- '*|='              skip\nCARET                <- '^'      ![=]      skip\nCARETEQUAL           <- '^='               skip\nCOLON                <- ':'                skip\nCOMMA                <- ','                skip\nDOT                  <- '.'      ![*.?]    skip\nDOT2                 <- '..'     ![.]      skip\nDOT3                 <- '...'              skip\nDOTASTERISK          <- '.*'               skip\nDOTQUESTIONMARK      <- '.?'               skip\nEQUAL                <- '='      ![>=]     skip\nEQUALEQUAL           <- '=='               skip\nEQUALRARROW          <- '=>'               skip\nEXCLAMATIONMARK      <- '!'      ![=]      skip\nEXCLAMATIONMARKEQUAL <- '!='               skip\nLARROW               <- '<'      ![<=]     skip\nLARROW2              <- '<<'     ![=|]     skip\nLARROW2EQUAL         <- '<<='              skip\nLARROW2PIPE          <- '<<|'    ![=]      skip\nLARROW2PIPEEQUAL     <- '<<|='             skip\nLARROWEQUAL          <- '<='               skip\nLBRACE               <- '{'                skip\nLBRACKET             <- '['                skip\nLPAREN               <- '('                skip\nMINUS                <- '-'      ![%=>|]   skip\nMINUSEQUAL           <- '-='               skip\nMINUSPERCENT         <- '-%'     ![=]      skip\nMINUSPERCENTEQUAL    <- '-%='              skip\nMINUSPIPE            <- '-|'     ![=]      skip\nMINUSPIPEEQUAL       <- '-|='              skip\nMINUSRARROW          <- '->'               skip\nPERCENT              <- '%'      ![=]      skip\nPERCENTEQUAL         <- '%='               skip\nPIPE                 <- '|'      ![|=]     skip\nPIPE2                <- '||'               skip\nPIPEEQUAL            <- '|='               skip\nPLUS                 <- '+'      ![%+=|]   skip\nPLUS2                <- '++'               skip\nPLUSEQUAL            <- '+='               skip\nPLUSPERCENT          <- '+%'     ![=]      skip\nPLUSPERCENTEQUAL     <- '+%='              skip\nPLUSPIPE             <- '+|'     ![=]      skip\nPLUSPIPEEQUAL        <- '+|='              skip\nLETTERC              <- 'c'                skip\nQUESTIONMARK         <- '?'                skip\nRARROW               <- '>'      ![>=]     skip\nRARROW2              <- '>>'     ![=]      skip\nRARROW2EQUAL         <- '>>='              skip\nRARROWEQUAL          <- '>='               skip\nRBRACE               <- '}'                skip\nRBRACKET             <- ']'                skip\nRPAREN               <- ')'                skip\nSEMICOLON            <- ';'                skip\nSLASH                <- '/'      ![=]      skip\nSLASHEQUAL           <- '/='               skip\nTILDE                <- '~'                skip\n\nend_of_word <- ![a-zA-Z0-9_] skip\nKEYWORD_addrspace   <- 'addrspace'   end_of_word\nKEYWORD_align       <- 'align'       end_of_word\nKEYWORD_allowzero   <- 'allowzero'   end_of_word\nKEYWORD_and         <- 'and'         end_of_word\nKEYWORD_anyframe    <- 'anyframe'    end_of_word\nKEYWORD_anytype     <- 'anytype'     end_of_word\nKEYWORD_asm         <- 'asm'         end_of_word\nKEYWORD_async       <- 'async'       end_of_word\nKEYWORD_await       <- 'await'       end_of_word\nKEYWORD_break       <- 'break'       end_of_word\nKEYWORD_callconv    <- 'callconv'    end_of_word\nKEYWORD_catch       <- 'catch'       end_of_word\nKEYWORD_comptime    <- 'comptime'    end_of_word\nKEYWORD_const       <- 'const'       end_of_word\nKEYWORD_continue    <- 'continue'    end_of_word\nKEYWORD_defer       <- 'defer'       end_of_word\nKEYWORD_else        <- 'else'        end_of_word\nKEYWORD_enum        <- 'enum'        end_of_word\nKEYWORD_errdefer    <- 'errdefer'    end_of_word\nKEYWORD_error       <- 'error'       end_of_word\nKEYWORD_export      <- 'export'      end_of_word\nKEYWORD_extern      <- 'extern'      end_of_word\nKEYWORD_fn          <- 'fn'          end_of_word\nKEYWORD_for         <- 'for'         end_of_word\nKEYWORD_if          <- 'if'          end_of_word\nKEYWORD_inline      <- 'inline'      end_of_word\nKEYWORD_noalias     <- 'noalias'     end_of_word\nKEYWORD_nosuspend   <- 'nosuspend'   end_of_word\nKEYWORD_noinline    <- 'noinline'    end_of_word\nKEYWORD_opaque      <- 'opaque'      end_of_word\nKEYWORD_or          <- 'or'          end_of_word\nKEYWORD_orelse      <- 'orelse'      end_of_word\nKEYWORD_packed      <- 'packed'      end_of_word\nKEYWORD_pub         <- 'pub'         end_of_word\nKEYWORD_resume      <- 'resume'      end_of_word\nKEYWORD_return      <- 'return'      end_of_word\nKEYWORD_linksection <- 'linksection' end_of_word\nKEYWORD_struct      <- 'struct'      end_of_word\nKEYWORD_suspend     <- 'suspend'     end_of_word\nKEYWORD_switch      <- 'switch'      end_of_word\nKEYWORD_test        <- 'test'        end_of_word\nKEYWORD_threadlocal <- 'threadlocal' end_of_word\nKEYWORD_try         <- 'try'         end_of_word\nKEYWORD_union       <- 'union'       end_of_word\nKEYWORD_unreachable <- 'unreachable' end_of_word\nKEYWORD_usingnamespace <- 'usingnamespace' end_of_word\nKEYWORD_var         <- 'var'         end_of_word\nKEYWORD_volatile    <- 'volatile'    end_of_word\nKEYWORD_while       <- 'while'       end_of_word\n\nkeyword <- KEYWORD_addrspace / KEYWORD_align / KEYWORD_allowzero / KEYWORD_and\n         / KEYWORD_anyframe / KEYWORD_anytype / KEYWORD_asm / KEYWORD_async\n         / KEYWORD_await / KEYWORD_break / KEYWORD_callconv / KEYWORD_catch\n         / KEYWORD_comptime / KEYWORD_const / KEYWORD_continue / KEYWORD_defer\n         / KEYWORD_else / KEYWORD_enum / KEYWORD_errdefer / KEYWORD_error / KEYWORD_export\n         / KEYWORD_extern / KEYWORD_fn / KEYWORD_for / KEYWORD_if\n         / KEYWORD_inline / KEYWORD_noalias / KEYWORD_nosuspend / KEYWORD_noinline\n         / KEYWORD_opaque / KEYWORD_or / KEYWORD_orelse / KEYWORD_packed\n         / KEYWORD_pub / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection\n         / KEYWORD_struct / KEYWORD_suspend / KEYWORD_switch / KEYWORD_test\n         / KEYWORD_threadlocal / KEYWORD_try / KEYWORD_union / KEYWORD_unreachable\n         / KEYWORD_usingnamespace / KEYWORD_var / KEYWORD_volatile / KEYWORD_while\n```\n\ngrammar.y\n\n### Zen\n\n- Communicate intent precisely.\n- Edge cases matter.\n- Favor reading code over writing code.\n- Only one obvious way to do things.\n- Runtime crashes are better than bugs.\n- Compile errors are better than runtime crashes.\n- Incremental improvements.\n- Avoid local maximums.\n- Reduce the amount one must remember.\n- Focus on code rather than style.\n- Resource allocation may fail; resource deallocation must succeed.\n- Memory is a resource.\n- Together we serve the users.\n\n© 2015–2024, Zig contributors  \nLicensed under the MIT License.  \n[https://ziglang.org/documentation/0.13.0/](https://ziglang.org/documentation/0.13.0/)"
