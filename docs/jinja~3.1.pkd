---
name: Jinja
slug: jinja~3.1
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: '3.1'
copyright: |-
  © 2007–2021 Pallets
  Licensed under the BSD 3-clause License.
  https://jinja.palletsprojects.com/en/3.1.x/index.html
homepage: https://palletsprojects.com/p/jinja/

---
- name: _FilterTestCommon
  id: extensions/index#jinja2.nodes._FilterTestCommon
  summary: null
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes._FilterTestCommon(node, name, args, kwargs, dyn_args, dyn_kwargs)`

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: abs()
  id: templates/index#jinja-filters.abs
  summary: Return the absolute value of the argument
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.abs(x, /)`

    Return the absolute value of the argument.
- name: Add
  id: extensions/index#jinja2.nodes.Add
  summary: Add the left to the right node
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Add(left, right)`

    Add the left to the right node.

    Node type:

    [`BinExpr`](#jinja2.nodes.BinExpr "jinja2.nodes.BinExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: And
  id: extensions/index#jinja2.nodes.And
  summary: Short circuited AND
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.And(left, right)`

    Short circuited AND.

    Node type:

    [`BinExpr`](#jinja2.nodes.BinExpr "jinja2.nodes.BinExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Assign
  id: extensions/index#jinja2.nodes.Assign
  summary: Assigns an expression to a target
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Assign(target, node)`

    Assigns an expression to a target.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: AssignBlock
  id: extensions/index#jinja2.nodes.AssignBlock
  summary: Assigns a block to a target
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.AssignBlock(target, filter, body)`

    Assigns a block to a target.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: attr()
  id: templates/index#jinja-filters.attr
  summary: Get an attribute of an object
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.attr(obj: Any, name: str) → jinja2.runtime.Undefined | Any`

    Get an attribute of an object. `foo|attr("bar")` works like `foo.bar` just that always an attribute is returned and items are not looked up.

    See [Notes on subscriptions](#notes-on-subscriptions) for more details.
- name: BaseLoader
  id: api/index#jinja2.BaseLoader
  summary: Baseclass for all loaders
  description: |-
    `class jinja2.BaseLoader`

    Baseclass for all loaders. Subclass this and override `get_source` to implement a custom loading mechanism. The environment provides a `get_template` method that calls the loader’s `load` method to get the [`Template`](#jinja2.Template "jinja2.Template") object.

    A very basic example for a loader that looks up templates on the file system could look like this:

    ``` python
    from jinja2 import BaseLoader, TemplateNotFound
    from os.path import join, exists, getmtime

    class MyLoader(BaseLoader):

        def __init__(self, path):
            self.path = path

        def get_source(self, environment, template):
            path = join(self.path, template)
            if not exists(path):
                raise TemplateNotFound(template)
            mtime = getmtime(path)
            with open(path) as f:
                source = f.read()
            return source, path, lambda: mtime == getmtime(path)
    ```
- name: BaseLoader.get_source()
  id: api/index#jinja2.BaseLoader.get_source
  summary: Get the template source, filename and reload helper for a template
  description: |-
    `get_source(environment, template)`

    Get the template source, filename and reload helper for a template. It’s passed the environment and template name and has to return a tuple in the form `(source, filename, uptodate)` or raise a `TemplateNotFound` error if it can’t locate the template.

    The source part of the returned tuple must be the source of the template as a string. The filename should be the name of the file on the filesystem if it was loaded from there, otherwise `None`. The filename is used by Python for the tracebacks if no loader extension is used.

    The last item in the tuple is the `uptodate` function. If auto reloading is enabled it’s always called to check if the template changed. No arguments are passed so the function must store the old state somewhere (for example in a closure). If it returns `False` the template will be reloaded.

    Parameters:

    - **environment** ([Environment](#jinja2.Environment "jinja2.Environment")) –
    - **template** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") \| None, [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[\], [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")\] \| None\]
- name: BaseLoader.load()
  id: api/index#jinja2.BaseLoader.load
  summary: Loads a template
  description: |-
    `load(environment, name, globals=None)`

    Loads a template. This method looks up the template in the cache or loads one by calling [`get_source()`](#jinja2.BaseLoader.get_source "jinja2.BaseLoader.get_source"). Subclasses should not override this method as loaders working on collections of other loaders (such as [`PrefixLoader`](#jinja2.PrefixLoader "jinja2.PrefixLoader") or [`ChoiceLoader`](#jinja2.ChoiceLoader "jinja2.ChoiceLoader")) will not call this method but `get_source` directly.

    Parameters:

    - **environment** ([Environment](#jinja2.Environment "jinja2.Environment")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **globals** ([MutableMapping](https://docs.python.org/3/library/typing.html#typing.MutableMapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –

    Return type:

    [Template](#jinja2.Template "jinja2.Template")

    Here a list of the builtin loaders Jinja provides:
- name: batch()
  id: templates/index#jinja-filters.batch
  summary: A filter that batches items
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.batch(value: 't.Iterable[V]', linecount: int, fill_with: 't.Optional[V]' = None) → 't.Iterator[t.List[V]]'`

    A filter that batches items. It works pretty much like `slice` just the other way round. It returns a list of lists with the given number of items. If you provide a second parameter this is used to fill up missing items. See this example:

    ``` html+jinja
    <table>
    {%- for row in items|batch(3, '&nbsp;') %}
      <tr>
      {%- for column in row %}
        <td>{{ column }}</td>
      {%- endfor %}
      </tr>
    {%- endfor %}
    </table>
    ```
- name: BinExpr
  id: extensions/index#jinja2.nodes.BinExpr
  summary: Baseclass for all binary expressions
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.BinExpr(left, right)`

    Baseclass for all binary expressions.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Block
  id: extensions/index#jinja2.nodes.Block
  summary: A node that represents a block
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Block(name, body, scoped, required)`

    A node that represents a block.

    Changelog

    Changed in version 3.0.0: the `required` field was added.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: boolean()
  id: templates/index#jinja-tests.boolean
  summary: Return true if the object is a boolean value
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.boolean(value: Any) → bool`

    Return true if the object is a boolean value.

    Changelog

    New in version 2.11.
- name: Break
  id: extensions/index#jinja2.nodes.Break
  summary: Break a loop
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Break`

    Break a loop.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: BSD-3-Clause License
  id: license/index
  summary: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED
  description: "# BSD-3-Clause License\n\nCopyright 2007 Pallets\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1.  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n2.  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n3.  Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/license/](https://jinja.palletsprojects.com/en/3.1.x/license/)"
- name: Bucket
  id: api/index#jinja2.bccache.Bucket
  summary: Buckets are used to store the bytecode for one template
  description: |-
    `class jinja2.bccache.Bucket(environment, key, checksum)`

    Buckets are used to store the bytecode for one template. It’s created and initialized by the bytecode cache and passed to the loading functions.

    The buckets get an internal checksum from the cache assigned and use this to automatically reject outdated cache material. Individual bytecode cache subclasses don’t have to care about cache invalidation.

    Parameters:

    - **environment** ([Environment](#jinja2.Environment "jinja2.Environment")) –
    - **key** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **checksum** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
- name: Bucket.bytecode_from_string()
  id: api/index#jinja2.bccache.Bucket.bytecode_from_string
  summary: Load bytecode from bytes
  description: |-
    `bytecode_from_string(string)`

    Load bytecode from bytes.

    Parameters:

    **string** ([bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")) –

    Return type:

    None
- name: Bucket.bytecode_to_string()
  id: api/index#jinja2.bccache.Bucket.bytecode_to_string
  summary: Return the bytecode as bytes
  description: |-
    `bytecode_to_string()`

    Return the bytecode as bytes.

    Return type:

    [bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")
- name: Bucket.code
  id: api/index#jinja2.bccache.Bucket.code
  summary: The bytecode if it’s loaded, otherwise None
  description: |-
    `code`

    The bytecode if it’s loaded, otherwise `None`.
- name: Bucket.environment
  id: api/index#jinja2.bccache.Bucket.environment
  summary: The Environment that created the bucket
  description: |-
    `environment`

    The `Environment` that created the bucket.
- name: Bucket.key
  id: api/index#jinja2.bccache.Bucket.key
  summary: null
  description: |-
    `key`

    The unique cache key for this bucket
- name: Bucket.load_bytecode()
  id: api/index#jinja2.bccache.Bucket.load_bytecode
  summary: Loads bytecode from a file or file like object
  description: |-
    `load_bytecode(f)`

    Loads bytecode from a file or file like object.

    Parameters:

    **f** ([BinaryIO](https://docs.python.org/3/library/typing.html#typing.BinaryIO "(in Python v3.11)")) –

    Return type:

    None
- name: Bucket.reset()
  id: api/index#jinja2.bccache.Bucket.reset
  summary: Resets the bucket (unloads the bytecode)
  description: |-
    `reset()`

    Resets the bucket (unloads the bytecode).

    Return type:

    None
- name: Bucket.write_bytecode()
  id: api/index#jinja2.bccache.Bucket.write_bytecode
  summary: Dump the bytecode into the file or file like object passed
  description: |-
    `write_bytecode(f)`

    Dump the bytecode into the file or file like object passed.

    Parameters:

    **f** ([IO](https://docs.python.org/3/library/typing.html#typing.IO "(in Python v3.11)")*\[*[bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")*\]*) –

    Return type:

    None

    Builtin bytecode caches:
- name: BytecodeCache
  id: api/index#jinja2.BytecodeCache
  summary: To implement your own bytecode cache you have to subclass this class and override load_bytecode() and dump_bytecode()
  description: |-
    `class jinja2.BytecodeCache`

    To implement your own bytecode cache you have to subclass this class and override [`load_bytecode()`](#jinja2.BytecodeCache.load_bytecode "jinja2.BytecodeCache.load_bytecode") and [`dump_bytecode()`](#jinja2.BytecodeCache.dump_bytecode "jinja2.BytecodeCache.dump_bytecode"). Both of these methods are passed a [`Bucket`](#jinja2.bccache.Bucket "jinja2.bccache.Bucket").

    A very basic bytecode cache that saves the bytecode on the file system:

    ``` python
    from os import path

    class MyCache(BytecodeCache):

        def __init__(self, directory):
            self.directory = directory

        def load_bytecode(self, bucket):
            filename = path.join(self.directory, bucket.key)
            if path.exists(filename):
                with open(filename, 'rb') as f:
                    bucket.load_bytecode(f)

        def dump_bytecode(self, bucket):
            filename = path.join(self.directory, bucket.key)
            with open(filename, 'wb') as f:
                bucket.write_bytecode(f)
    ```

    A more advanced version of a filesystem based bytecode cache is part of Jinja.
- name: BytecodeCache.clear()
  id: api/index#jinja2.BytecodeCache.clear
  summary: Clears the cache
  description: |-
    `clear()`

    Clears the cache. This method is not used by Jinja but should be implemented to allow applications to clear the bytecode cache used by a particular environment.

    Return type:

    None
- name: BytecodeCache.dump_bytecode()
  id: api/index#jinja2.BytecodeCache.dump_bytecode
  summary: Subclasses have to override this method to write the bytecode from a bucket back to the cache
  description: |-
    `dump_bytecode(bucket)`

    Subclasses have to override this method to write the bytecode from a bucket back to the cache. If it unable to do so it must not fail silently but raise an exception.

    Parameters:

    **bucket** ([Bucket](#jinja2.bccache.Bucket "jinja2.bccache.Bucket")) –

    Return type:

    None
- name: BytecodeCache.load_bytecode()
  id: api/index#jinja2.BytecodeCache.load_bytecode
  summary: Subclasses have to override this method to load bytecode into a bucket
  description: |-
    `load_bytecode(bucket)`

    Subclasses have to override this method to load bytecode into a bucket. If they are not able to find code in the cache for the bucket, it must not do anything.

    Parameters:

    **bucket** ([Bucket](#jinja2.bccache.Bucket "jinja2.bccache.Bucket")) –

    Return type:

    None
- name: Call
  id: extensions/index#jinja2.nodes.Call
  summary: Calls an expression
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Call(node, args, kwargs, dyn_args, dyn_kwargs)`

    Calls an expression. `args` is a list of arguments, `kwargs` a list of keyword arguments (list of [`Keyword`](#jinja2.nodes.Keyword "jinja2.nodes.Keyword") nodes), and `dyn_args` and `dyn_kwargs` has to be either `None` or a node that is used as node for dynamic positional (`*args`) or keyword (`**kwargs`) arguments.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: callable()
  id: templates/index#jinja-tests.callable
  summary: Return whether the object is callable (i.e., some kind of function)
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.callable(obj, /)`

    Return whether the object is callable (i.e., some kind of function).

    Note that classes are callable, as are instances of classes with a \_\_call\_\_() method.
- name: CallBlock
  id: extensions/index#jinja2.nodes.CallBlock
  summary: Like a macro without a name but a call instead
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.CallBlock(call, args, defaults, body)`

    Like a macro without a name but a call instead. `call` is called with the unnamed macro as `caller` argument this node holds.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: capitalize()
  id: templates/index#jinja-filters.capitalize
  summary: Capitalize a value
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.capitalize(s: str) → str`

    Capitalize a value. The first character will be uppercase, all others lowercase.
- name: center()
  id: templates/index#jinja-filters.center
  summary: Centers the value in a field of a given width
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.center(value: str, width: int = 80) → str`

    Centers the value in a field of a given width.
- name: ChainableUndefined
  id: api/index#jinja2.ChainableUndefined
  summary: An undefined that is chainable, where both __getattr__ and __getitem__ return itself rather than raising an UndefinedError
  description: |-
    `class jinja2.ChainableUndefined`

    An undefined that is chainable, where both `__getattr__` and `__getitem__` return itself rather than raising an [`UndefinedError`](#jinja2.UndefinedError "jinja2.UndefinedError").

    ``` python
    >>> foo = ChainableUndefined(name='foo')
    >>> str(foo.bar['baz'])
    ''
    >>> foo.bar['baz'] + 42
    Traceback (most recent call last):
      ...
    jinja2.exceptions.UndefinedError: 'foo' is undefined
    ```

    Changelog

    New in version 2.11.0.

    Parameters:

    - **hint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **exc** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[TemplateRuntimeError](#jinja2.TemplateRuntimeError "jinja2.exceptions.TemplateRuntimeError")*\]*) –
- name: Changes
  id: changes/index
  summary: Drop support for Python 3.6
  description: "# Changes\n\n## Version 3.1.3\n\nUnreleased\n\n- Fix compiler error when checking if required blocks in parent templates are empty. [\\#1858](https://github.com/pallets/jinja/pull/1858)\n\n## Version 3.1.2\n\nReleased 2022-04-28\n\n- Add parameters to `Environment.overlay` to match `__init__`. [\\#1645](https://github.com/pallets/jinja/issues/1645)\n- Handle race condition in `FileSystemBytecodeCache`. [\\#1654](https://github.com/pallets/jinja/issues/1654)\n\n## Version 3.1.1\n\nReleased 2022-03-25\n\n- The template filename on Windows uses the primary path separator. [\\#1637](https://github.com/pallets/jinja/issues/1637)\n\n## Version 3.1.0\n\nReleased 2022-03-24\n\n- Drop support for Python 3.6. [\\#1534](https://github.com/pallets/jinja/pull/1534)\n\n- Remove previously deprecated code. [\\#1544](https://github.com/pallets/jinja/pull/1544)\n\n  - `WithExtension` and `AutoEscapeExtension` are built-in now.\n  - `contextfilter` and `contextfunction` are replaced by `pass_context`. `evalcontextfilter` and `evalcontextfunction` are replaced by `pass_eval_context`. `environmentfilter` and `environmentfunction` are replaced by `pass_environment`.\n  - `Markup` and `escape` should be imported from MarkupSafe.\n  - Compiled templates from very old Jinja versions may need to be recompiled.\n  - Legacy resolve mode for `Context` subclasses is no longer supported. Override `resolve_or_missing` instead of `resolve`.\n  - `unicode_urlencode` is renamed to `url_quote`.\n\n- Add support for native types in macros. [\\#1510](https://github.com/pallets/jinja/issues/1510)\n\n- The `{% trans %}` tag can use `pgettext` and `npgettext` by passing a context string as the first token in the tag, like `{% trans \"title\" %}`. [\\#1430](https://github.com/pallets/jinja/issues/1430)\n\n- Update valid identifier characters from Python 3.6 to 3.7. [\\#1571](https://github.com/pallets/jinja/pull/1571)\n\n- Filters and tests decorated with `@async_variant` are pickleable. [\\#1612](https://github.com/pallets/jinja/pull/1612)\n\n- Add `items` filter. [\\#1561](https://github.com/pallets/jinja/issues/1561)\n\n- Subscriptions (`[0]`, etc.) can be used after filters, tests, and calls when the environment is in async mode. [\\#1573](https://github.com/pallets/jinja/issues/1573)\n\n- The `groupby` filter is case-insensitive by default, matching other comparison filters. Added the `case_sensitive` parameter to control this. [\\#1463](https://github.com/pallets/jinja/issues/1463)\n\n- Windows drive-relative path segments in template names will not result in `FileSystemLoader` and `PackageLoader` loading from drive-relative paths. [\\#1621](https://github.com/pallets/jinja/pull/1621)\n\n## Version 3.0.3\n\nReleased 2021-11-09\n\n- Fix traceback rewriting internals for Python 3.10 and 3.11. [\\#1535](https://github.com/pallets/jinja/issues/1535)\n- Fix how the native environment treats leading and trailing spaces when parsing values on Python 3.10. [\\#1537](https://github.com/pallets/jinja/pull/1537)\n- Improve async performance by avoiding checks for common types. [\\#1514](https://github.com/pallets/jinja/issues/1514)\n- Revert change to `hash(Node)` behavior. Nodes are hashed by id again [\\#1521](https://github.com/pallets/jinja/issues/1521)\n- `PackageLoader` works when the package is a single module file. [\\#1512](https://github.com/pallets/jinja/issues/1512)\n\n## Version 3.0.2\n\nReleased 2021-10-04\n\n- Fix a loop scoping bug that caused assignments in nested loops to still be referenced outside of it. [\\#1427](https://github.com/pallets/jinja/issues/1427)\n- Make `compile_templates` deterministic for filter and import names. [\\#1452](https://github.com/pallets/jinja/issues/1452), [\\#1453](https://github.com/pallets/jinja/issues/1453)\n- Revert an unintended change that caused `Undefined` to act like `StrictUndefined` for the `in` operator. [\\#1448](https://github.com/pallets/jinja/issues/1448)\n- Imported macros have access to the current template globals in async environments. [\\#1494](https://github.com/pallets/jinja/issues/1494)\n- `PackageLoader` will not include a current directory (.) path segment. This allows loading templates from the root of a zip import. [\\#1467](https://github.com/pallets/jinja/issues/1467)\n\n## Version 3.0.1\n\nReleased 2021-05-18\n\n- Update MarkupSafe dependency to \\>= 2.0. [\\#1418](https://github.com/pallets/jinja/pull/1418)\n- Mark top-level names as exported so type checking understands imports in user projects. [\\#1426](https://github.com/pallets/jinja/issues/1426)\n- Fix some types that weren’t available in Python 3.6.0. [\\#1433](https://github.com/pallets/jinja/issues/1433)\n- The deprecation warning for unneeded `autoescape` and `with_` extensions shows more relevant context. [\\#1429](https://github.com/pallets/jinja/issues/1429)\n- Fixed calling deprecated `jinja2.Markup` without an argument. Use `markupsafe.Markup` instead. [\\#1438](https://github.com/pallets/jinja/issues/1438)\n- Calling sync `render` for an async template uses `asyncio.run` on Python \\>= 3.7. This fixes a deprecation that Python 3.10 introduces. [\\#1443](https://github.com/pallets/jinja/issues/1443)\n\n## Version 3.0.0\n\nReleased 2021-05-11\n\n- Drop support for Python 2.7 and 3.5.\n\n- Bump MarkupSafe dependency to \\>=1.1.\n\n- Bump Babel optional dependency to \\>=2.1.\n\n- Remove code that was marked deprecated.\n\n- Add type hinting. [\\#1412](https://github.com/pallets/jinja/pull/1412)\n\n- Use [**PEP 451**](https://peps.python.org/pep-0451/) API to load templates with [`PackageLoader`](../api/index#jinja2.PackageLoader \"jinja2.loaders.PackageLoader\"). [\\#1168](https://github.com/pallets/jinja/issues/1168)\n\n- Fix a bug that caused imported macros to not have access to the current template’s globals. [\\#688](https://github.com/pallets/jinja/issues/688)\n\n- Add ability to ignore `trim_blocks` using `+%}`. [\\#1036](https://github.com/pallets/jinja/issues/1036)\n\n- Fix a bug that caused custom async-only filters to fail with constant input. [\\#1279](https://github.com/pallets/jinja/issues/1279)\n\n- Fix UndefinedError incorrectly being thrown on an undefined variable instead of `Undefined` being returned on `NativeEnvironment` on Python 3.10. [\\#1335](https://github.com/pallets/jinja/issues/1335)\n\n- Blocks can be marked as `required`. They must be overridden at some point, but not necessarily by the direct child. [\\#1147](https://github.com/pallets/jinja/issues/1147)\n\n- Deprecate the `autoescape` and `with` extensions, they are built-in to the compiler. [\\#1203](https://github.com/pallets/jinja/issues/1203)\n\n- The `urlize` filter recognizes `mailto:` links and takes `extra_schemes` (or `env.policies[\"urlize.extra_schemes\"]`) to recognize other schemes. It tries to balance parentheses within a URL instead of ignoring trailing characters. The parsing in general has been updated to be more efficient and match more cases. URLs without a scheme are linked as `https://` instead of `http://`. [\\#522](https://github.com/pallets/jinja/issues/522), [\\#827](https://github.com/pallets/jinja/issues/827), [\\#1172](https://github.com/pallets/jinja/issues/1172), [\\#1195](https://github.com/pallets/jinja/pull/1195)\n\n- Filters that get attributes, such as `map` and `groupby`, can use a false or empty value as a default. [\\#1331](https://github.com/pallets/jinja/issues/1331)\n\n- Fix a bug that prevented variables set in blocks or loops from being accessed in custom context functions. [\\#768](https://github.com/pallets/jinja/issues/768)\n\n- Fix a bug that caused scoped blocks from accessing special loop variables. [\\#1088](https://github.com/pallets/jinja/issues/1088)\n\n- Update the template globals when calling `Environment.get_template(globals=...)` even if the template was already loaded. [\\#295](https://github.com/pallets/jinja/issues/295)\n\n- Do not raise an error for undefined filters in unexecuted if-statements and conditional expressions. [\\#842](https://github.com/pallets/jinja/issues/842)\n\n- Add `is filter` and `is test` tests to test if a name is a registered filter or test. This allows checking if a filter is available in a template before using it. Test functions can be decorated with `@pass_environment`, `@pass_eval_context`, or `@pass_context`. [\\#842](https://github.com/pallets/jinja/issues/842), [\\#1248](https://github.com/pallets/jinja/pull/1248)\n\n- Support `pgettext` and `npgettext` (message contexts) in i18n extension. [\\#441](https://github.com/pallets/jinja/issues/441)\n\n- The `|indent` filter’s `width` argument can be a string to indent by. [\\#1167](https://github.com/pallets/jinja/pull/1167)\n\n- The parser understands hex, octal, and binary integer literals. [\\#1170](https://github.com/pallets/jinja/issues/1170)\n\n- `Undefined.__contains__` (`in`) raises an `UndefinedError` instead of a `TypeError`. [\\#1198](https://github.com/pallets/jinja/issues/1198)\n\n- `Undefined` is iterable in an async environment. [\\#1294](https://github.com/pallets/jinja/issues/1294)\n\n- `NativeEnvironment` supports async mode. [\\#1362](https://github.com/pallets/jinja/issues/1362)\n\n- Template rendering only treats `\\n`, `\\r\\n` and `\\r` as line breaks. Other characters are left unchanged. [\\#769](https://github.com/pallets/jinja/issues/769), [\\#952](https://github.com/pallets/jinja/issues/952), [\\#1313](https://github.com/pallets/jinja/issues/1313)\n\n- `|groupby` filter takes an optional `default` argument. [\\#1359](https://github.com/pallets/jinja/issues/1359)\n\n- The function and filter decorators have been renamed and unified. The old names are deprecated. [\\#1381](https://github.com/pallets/jinja/issues/1381)\n\n  - `pass_context` replaces `contextfunction` and `contextfilter`.\n  - `pass_eval_context` replaces `evalcontextfunction` and `evalcontextfilter`\n  - `pass_environment` replaces `environmentfunction` and `environmentfilter`.\n\n- Async support no longer requires Jinja to patch itself. It must still be enabled with `Environment(enable_async=True)`. [\\#1390](https://github.com/pallets/jinja/issues/1390)\n\n- Overriding `Context.resolve` is deprecated, override `resolve_or_missing` instead. [\\#1380](https://github.com/pallets/jinja/issues/1380)\n\n## Version 2.11.3\n\nReleased 2021-01-31\n\n- Improve the speed of the `urlize` filter by reducing regex backtracking. Email matching requires a word character at the start of the domain part, and only word characters in the TLD. [\\#1343](https://github.com/pallets/jinja/pull/1343)\n\n## Version 2.11.2\n\nReleased 2020-04-13\n\n- Fix a bug that caused callable objects with `__getattr__`, like [`Mock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock \"(in Python v3.11)\") to be treated as a `contextfunction()`. [\\#1145](https://github.com/pallets/jinja/issues/1145)\n- Update `wordcount` filter to trigger [`Undefined`](../api/index#jinja2.Undefined \"jinja2.Undefined\") methods by wrapping the input in `soft_str()`. [\\#1160](https://github.com/pallets/jinja/pull/1160)\n- Fix a hang when displaying tracebacks on Python 32-bit. [\\#1162](https://github.com/pallets/jinja/issues/1162)\n- Showing an undefined error for an object that raises `AttributeError` on access doesn’t cause a recursion error. [\\#1177](https://github.com/pallets/jinja/issues/1177)\n- Revert changes to [`PackageLoader`](../api/index#jinja2.PackageLoader \"jinja2.loaders.PackageLoader\") from 2.10 which removed the dependency on setuptools and pkg_resources, and added limited support for namespace packages. The changes caused issues when using Pytest. Due to the difficulty in supporting Python 2 and [**PEP 451**](https://peps.python.org/pep-0451/) simultaneously, the changes are reverted until 3.0. [\\#1182](https://github.com/pallets/jinja/pull/1182)\n- Fix line numbers in error messages when newlines are stripped. [\\#1178](https://github.com/pallets/jinja/pull/1178)\n- The special `namespace()` assignment object in templates works in async environments. [\\#1180](https://github.com/pallets/jinja/issues/1180)\n- Fix whitespace being removed before tags in the middle of lines when `lstrip_blocks` is enabled. [\\#1138](https://github.com/pallets/jinja/issues/1138)\n- [`NativeEnvironment`](../nativetypes/index#jinja2.nativetypes.NativeEnvironment \"jinja2.nativetypes.NativeEnvironment\") doesn’t evaluate intermediate strings during rendering. This prevents early evaluation which could change the value of an expression. [\\#1186](https://github.com/pallets/jinja/issues/1186)\n\n## Version 2.11.1\n\nReleased 2020-01-30\n\n- Fix a bug that prevented looking up a key after an attribute (`{{ data.items[1:] }}`) in an async template. [\\#1141](https://github.com/pallets/jinja/issues/1141)\n\n## Version 2.11.0\n\nReleased 2020-01-27\n\n- Drop support for Python 2.6, 3.3, and 3.4. This will be the last version to support Python 2.7 and 3.5.\n- Added a new `ChainableUndefined` class to support getitem and getattr on an undefined object. [\\#977](https://github.com/pallets/jinja/issues/977)\n- Allow `{%+` syntax (with NOP behavior) when `lstrip_blocks` is disabled. [\\#748](https://github.com/pallets/jinja/issues/748)\n- Added a `default` parameter for the `map` filter. [\\#557](https://github.com/pallets/jinja/issues/557)\n- Exclude environment globals from [`meta.find_undeclared_variables()`](../api/index#jinja2.meta.find_undeclared_variables \"jinja2.meta.find_undeclared_variables\"). [\\#931](https://github.com/pallets/jinja/issues/931)\n- Float literals can be written with scientific notation, like 2.56e-3. [\\#912](https://github.com/pallets/jinja/issues/912), [\\#922](https://github.com/pallets/jinja/pull/922)\n- Int and float literals can be written with the ‘\\_’ separator for legibility, like 12_345. [\\#923](https://github.com/pallets/jinja/pull/923)\n- Fix a bug causing deadlocks in `LRUCache.setdefault`. [\\#1000](https://github.com/pallets/jinja/pull/1000)\n- The `trim` filter takes an optional string of characters to trim. [\\#828](https://github.com/pallets/jinja/pull/828)\n- A new `jinja2.ext.debug` extension adds a `{% debug %}` tag to quickly dump the current context and available filters and tests. [\\#174](https://github.com/pallets/jinja/issues/174), [\\#798](https://github.com/pallets/jinja/pull/798), [\\#983](https://github.com/pallets/jinja/pull/983)\n- Lexing templates with large amounts of whitespace is much faster. [\\#857](https://github.com/pallets/jinja/issues/857), [\\#858](https://github.com/pallets/jinja/pull/858)\n- Parentheses around comparisons are preserved, so `{{ 2 * (3 < 5) }}` outputs “2” instead of “False”. [\\#755](https://github.com/pallets/jinja/issues/755), [\\#938](https://github.com/pallets/jinja/pull/938)\n- Add new `boolean`, `false`, `true`, `integer` and `float` tests. [\\#824](https://github.com/pallets/jinja/pull/824)\n- The environment’s `finalize` function is only applied to the output of expressions (constant or not), not static template data. [\\#63](https://github.com/pallets/jinja/issues/63)\n- When providing multiple paths to `FileSystemLoader`, a template can have the same name as a directory. [\\#821](https://github.com/pallets/jinja/issues/821)\n- Always return [`Undefined`](../api/index#jinja2.Undefined \"jinja2.Undefined\") when omitting the `else` clause in a `{{ 'foo' if bar }}` expression, regardless of the environment’s `undefined` class. Omitting the `else` clause is a valid shortcut and should not raise an error when using [`StrictUndefined`](../api/index#jinja2.StrictUndefined \"jinja2.StrictUndefined\"). [\\#710](https://github.com/pallets/jinja/issues/710), [\\#1079](https://github.com/pallets/jinja/pull/1079)\n- Fix behavior of `loop` control variables such as `length` and `revindex0` when looping over a generator. [\\#459](https://github.com/pallets/jinja/issues/459), [\\#751](https://github.com/pallets/jinja/issues/751), [\\#794](https://github.com/pallets/jinja/issues/794), [\\#993](https://github.com/pallets/jinja/pull/993)\n- Async support is only loaded the first time an environment enables it, in order to avoid a slow initial import. [\\#765](https://github.com/pallets/jinja/issues/765)\n- In async environments, the `|map` filter will await the filter call if needed. [\\#913](https://github.com/pallets/jinja/pull/913)\n- In for loops that access `loop` attributes, the iterator is not advanced ahead of the current iteration unless `length`, `revindex`, `nextitem`, or `last` are accessed. This makes it less likely to break `groupby` results. [\\#555](https://github.com/pallets/jinja/issues/555), [\\#1101](https://github.com/pallets/jinja/pull/1101)\n- In async environments, the `loop` attributes `length` and `revindex` work for async iterators. [\\#1101](https://github.com/pallets/jinja/pull/1101)\n- In async environments, values from attribute/property access will be awaited if needed. [\\#1101](https://github.com/pallets/jinja/pull/1101)\n- `PackageLoader` doesn’t depend on setuptools or pkg_resources. [\\#970](https://github.com/pallets/jinja/issues/970)\n- `PackageLoader` has limited support for [**PEP 420**](https://peps.python.org/pep-0420/) namespace packages. [\\#1097](https://github.com/pallets/jinja/issues/1097)\n- Support [`os.PathLike`](https://docs.python.org/3/library/os.html#os.PathLike \"(in Python v3.11)\") objects in `FileSystemLoader` and `ModuleLoader`. [\\#870](https://github.com/pallets/jinja/issues/870)\n- [`NativeTemplate`](../nativetypes/index#jinja2.nativetypes.NativeTemplate \"jinja2.nativetypes.NativeTemplate\") correctly handles quotes between expressions. `\"'{{ a }}', '{{ b }}'\"` renders as the tuple `('1', '2')` rather than the string `'1, 2'`. [\\#1020](https://github.com/pallets/jinja/issues/1020)\n- Creating a [`NativeTemplate`](../nativetypes/index#jinja2.nativetypes.NativeTemplate \"jinja2.nativetypes.NativeTemplate\") directly creates a [`NativeEnvironment`](../nativetypes/index#jinja2.nativetypes.NativeEnvironment \"jinja2.nativetypes.NativeEnvironment\") instead of a default [`Environment`](../api/index#jinja2.Environment \"jinja2.Environment\"). [\\#1091](https://github.com/pallets/jinja/issues/1091)\n- After calling `LRUCache.copy()`, the copy’s queue methods point to the correct queue. [\\#843](https://github.com/pallets/jinja/issues/843)\n- Compiling templates always writes UTF-8 instead of defaulting to the system encoding. [\\#889](https://github.com/pallets/jinja/issues/889)\n- `|wordwrap` filter treats existing newlines as separate paragraphs to be wrapped individually, rather than creating short intermediate lines. [\\#175](https://github.com/pallets/jinja/issues/175)\n- Add `break_on_hyphens` parameter to `|wordwrap` filter. [\\#550](https://github.com/pallets/jinja/issues/550)\n- Cython compiled functions decorated as context functions will be passed the context. [\\#1108](https://github.com/pallets/jinja/pull/1108)\n- When chained comparisons of constants are evaluated at compile time, the result follows Python’s behavior of returning `False` if any comparison returns `False`, rather than only the last one. [\\#1102](https://github.com/pallets/jinja/issues/1102)\n- Tracebacks for exceptions in templates show the correct line numbers and source for Python \\>= 3.7. [\\#1104](https://github.com/pallets/jinja/issues/1104)\n- Tracebacks for template syntax errors in Python 3 no longer show internal compiler frames. [\\#763](https://github.com/pallets/jinja/issues/763)\n- Add a `DerivedContextReference` node that can be used by extensions to get the current context and local variables such as `loop`. [\\#860](https://github.com/pallets/jinja/issues/860)\n- Constant folding during compilation is applied to some node types that were previously overlooked. [\\#733](https://github.com/pallets/jinja/issues/733)\n- `TemplateSyntaxError.source` is not empty when raised from an included template. [\\#457](https://github.com/pallets/jinja/issues/457)\n- Passing an `Undefined` value to `get_template` (such as through `extends`, `import`, or `include`), raises an `UndefinedError` consistently. `select_template` will show the undefined message in the list of attempts rather than the empty string. [\\#1037](https://github.com/pallets/jinja/issues/1037)\n- `TemplateSyntaxError` can be pickled. [\\#1117](https://github.com/pallets/jinja/pull/1117)\n\n## Version 2.10.3\n\nReleased 2019-10-04\n\n- Fix a typo in Babel entry point in `setup.py` that was preventing installation.\n\n## Version 2.10.2\n\nReleased 2019-10-04\n\n- Fix Python 3.7 deprecation warnings.\n- Using `range` in the sandboxed environment uses `xrange` on Python 2 to avoid memory use. [\\#933](https://github.com/pallets/jinja/issues/933)\n- Use Python 3.7’s better traceback support to avoid a core dump when using debug builds of Python 3.7. [\\#1050](https://github.com/pallets/jinja/issues/1050)\n\n## Version 2.10.1\n\nReleased 2019-04-06\n\n- `SandboxedEnvironment` securely handles `str.format_map` in order to prevent code execution through untrusted format strings. The sandbox already handled `str.format`.\n\n## Version 2.10\n\nReleased 2017-11-08\n\n- Added a new extension node called `OverlayScope` which can be used to create an unoptimized scope that will look up all variables from a derived context.\n- Added an `in` test that works like the in operator. This can be used in combination with `reject` and `select`.\n- Added `previtem` and `nextitem` to loop contexts, providing access to the previous/next item in the loop. If such an item does not exist, the value is undefined.\n- Added `changed(*values)` to loop contexts, providing an easy way of checking whether a value has changed since the last iteration (or rather since the last call of the method)\n- Added a `namespace` function that creates a special object which allows attribute assignment using the `set` tag. This can be used to carry data across scopes, e.g. from a loop body to code that comes after the loop.\n- Added a `trimmed` modifier to `{% trans %}` to strip linebreaks and surrounding whitespace. Also added a new policy to enable this for all `trans` blocks.\n- The `random` filter is no longer incorrectly constant folded and will produce a new random choice each time the template is rendered. [\\#478](https://github.com/pallets/jinja/pull/478)\n- Added a `unique` filter. [\\#469](https://github.com/pallets/jinja/pull/469)\n- Added `min` and `max` filters. [\\#475](https://github.com/pallets/jinja/pull/475)\n- Added tests for all comparison operators: `eq`, `ne`, `lt`, `le`, `gt`, `ge`. [\\#665](https://github.com/pallets/jinja/pull/665)\n- `import` statement cannot end with a trailing comma. [\\#617](https://github.com/pallets/jinja/pull/617), [\\#618](https://github.com/pallets/jinja/pull/618)\n- `indent` filter will not indent blank lines by default. [\\#685](https://github.com/pallets/jinja/pull/685)\n- Add `reverse` argument for `dictsort` filter. [\\#692](https://github.com/pallets/jinja/pull/692)\n- Add a `NativeEnvironment` that renders templates to native Python types instead of strings. [\\#708](https://github.com/pallets/jinja/pull/708)\n- Added filter support to the block `set` tag. [\\#489](https://github.com/pallets/jinja/pull/489)\n- `tojson` filter marks output as safe to match documented behavior. [\\#718](https://github.com/pallets/jinja/pull/718)\n- Resolved a bug where getting debug locals for tracebacks could modify template context.\n- Fixed a bug where having many `{% elif ... %}` blocks resulted in a “too many levels of indentation” error. These blocks now compile to native `elif ..:` instead of `else: if ..:` [\\#759](https://github.com/pallets/jinja/issues/759)\n\n## Version 2.9.6\n\nReleased 2017-04-03\n\n- Fixed custom context behavior in fast resolve mode [\\#675](https://github.com/pallets/jinja/issues/675)\n\n## Version 2.9.5\n\nReleased 2017-01-28\n\n- Restored the original repr of the internal `_GroupTuple` because this caused issues with ansible and it was an unintended change. [\\#654](https://github.com/pallets/jinja/issues/654)\n- Added back support for custom contexts that override the old `resolve` method since it was hard for people to spot that this could cause a regression.\n- Correctly use the buffer for the else block of for loops. This caused invalid syntax errors to be caused on 2.x and completely wrong behavior on Python 3 [\\#669](https://github.com/pallets/jinja/issues/669)\n- Resolve an issue where the `{% extends %}` tag could not be used with async environments. [\\#668](https://github.com/pallets/jinja/issues/668)\n- Reduce memory footprint slightly by reducing our unicode database dump we use for identifier matching on Python 3 [\\#666](https://github.com/pallets/jinja/issues/666)\n- Fixed autoescaping not working for macros in async compilation mode. [\\#671](https://github.com/pallets/jinja/issues/671)\n\n## Version 2.9.4\n\nReleased 2017-01-10\n\n- Solved some warnings for string literals. [\\#646](https://github.com/pallets/jinja/issues/646)\n- Increment the bytecode cache version which was not done due to an oversight before.\n- Corrected bad code generation and scoping for filtered loops. [\\#649](https://github.com/pallets/jinja/issues/649)\n- Resolved an issue where top-level output silencing after known extend blocks could generate invalid code when blocks where contained in if statements. [\\#651](https://github.com/pallets/jinja/issues/651)\n- Made the `truncate.leeway` default configurable to improve compatibility with older templates.\n\n## Version 2.9.3\n\nReleased 2017-01-08\n\n- Restored the use of blocks in macros to the extend that was possible before. On Python 3 it would render a generator repr instead of the block contents. [\\#645](https://github.com/pallets/jinja/issues/645)\n- Set a consistent behavior for assigning of variables in inner scopes when the variable is also read from an outer scope. This now sets the intended behavior in all situations however it does not restore the old behavior where limited assignments to outer scopes was possible. For more information and a discussion see [\\#641](https://github.com/pallets/jinja/issues/641)\n- Resolved an issue where `block scoped` would not take advantage of the new scoping rules. In some more exotic cases a variable overridden in a local scope would not make it into a block.\n- Change the code generation of the `with` statement to be in line with the new scoping rules. This resolves some unlikely bugs in edge cases. This also introduces a new internal `With` node that can be used by extensions.\n\n## Version 2.9.2\n\nReleased 2017-01-08\n\n- Fixed a regression that caused for loops to not be able to use the same variable for the target as well as source iterator. [\\#640](https://github.com/pallets/jinja/issues/640)\n- Add support for a previously unknown behavior of macros. It used to be possible in some circumstances to explicitly provide a caller argument to macros. While badly buggy and unintended it turns out that this is a common case that gets copy pasted around. To not completely break backwards compatibility with the most common cases it’s now possible to provide an explicit keyword argument for caller if it’s given an explicit default. [\\#642](https://github.com/pallets/jinja/issues/642)\n\n## Version 2.9.1\n\nReleased 2017-01-07\n\n- Resolved a regression with call block scoping for macros. Nested caller blocks that used the same identifiers as outer macros could refer to the wrong variable incorrectly.\n\n## Version 2.9\n\nReleased 2017-01-07, codename Derivation\n\n- Change cache key definition in environment. This fixes a performance regression introduced in 2.8.\n- Added support for `generator_stop` on supported Python versions (Python 3.5 and later)\n- Corrected a long standing issue with operator precedence of math operations not being what was expected.\n- Added support for Python 3.6 async iterators through a new async mode.\n- Added policies for filter defaults and similar things.\n- Urlize now sets “rel noopener” by default.\n- Support attribute fallback for old-style classes in 2.x.\n- Support toplevel set statements in extend situations.\n- Restored behavior of Cycler for Python 3 users.\n- Subtraction now follows the same behavior as other operators on undefined values.\n- `map` and friends will now give better error messages if you forgot to quote the parameter.\n- Depend on MarkupSafe 0.23 or higher.\n- Improved the `truncate` filter to support better truncation in case the string is barely truncated at all.\n- Change the logic for macro autoescaping to be based on the runtime autoescaping information at call time instead of macro define time.\n- Ported a modified version of the `tojson` filter from Flask to Jinja and hooked it up with the new policy framework.\n- Block sets are now marked `safe` by default.\n- On Python 2 the asciification of ASCII strings can now be disabled with the `compiler.ascii_str` policy.\n- Tests now no longer accept an arbitrary expression as first argument but a restricted one. This means that you can now properly use multiple tests in one expression without extra parentheses. In particular you can now write `foo is divisibleby 2 or foo is divisibleby 3` as you would expect.\n- Greatly changed the scoping system to be more consistent with what template designers and developers expect. There is now no more magic difference between the different include and import constructs. Context is now always propagated the same way. The only remaining differences is the defaults for `with context` and `without context`.\n- The `with` and `autoescape` tags are now built-in.\n- Added the new `select_autoescape` function which helps configuring better autoescaping easier.\n- Fixed a runtime error in the sandbox when attributes of async generators were accessed.\n\n## Version 2.8.1\n\nReleased 2016-12-29\n\n- Fixed the `for_qs` flag for `urlencode`.\n- Fixed regression when applying `int` to non-string values.\n- SECURITY: if the sandbox mode is used format expressions are now sandboxed with the same rules as in Jinja. This solves various information leakage problems that can occur with format strings.\n\n## Version 2.8\n\nReleased 2015-07-26, codename Replacement\n\n- Added `target` parameter to urlize function.\n- Added support for `followsymlinks` to the file system loader.\n- The truncate filter now counts the length.\n- Added equalto filter that helps with select filters.\n- Changed cache keys to use absolute file names if available instead of load names.\n- Fixed loop length calculation for some iterators.\n- Changed how Jinja enforces strings to be native strings in Python 2 to work when people break their default encoding.\n- Added `make_logging_undefined` which returns an undefined object that logs failures into a logger.\n- If unmarshalling of cached data fails the template will be reloaded now.\n- Implemented a block `set` tag.\n- Default cache size was increased to 400 from a low 50.\n- Fixed `is number` test to accept long integers in all Python versions.\n- Changed `is number` to accept Decimal as a number.\n- Added a check for default arguments followed by non-default arguments. This change makes `{% macro m(x, y=1, z) %}` a syntax error. The previous behavior for this code was broken anyway (resulting in the default value being applied to `y`).\n- Add ability to use custom subclasses of `jinja2.compiler.CodeGenerator` and `jinja2.runtime.Context` by adding two new attributes to the environment (`code_generator_class` and `context_class`). [\\#404](https://github.com/pallets/jinja/pull/404)\n- Added support for context/environment/evalctx decorator functions on the finalize callback of the environment.\n- Escape query strings for urlencode properly. Previously slashes were not escaped in that place.\n- Add ‘base’ parameter to ‘int’ filter.\n\n## Version 2.7.3\n\nReleased 2014-06-06\n\n- Security issue: Corrected the security fix for the cache folder. This fix was provided by RedHat.\n\n## Version 2.7.2\n\nReleased 2014-01-10\n\n- Prefix loader was not forwarding the locals properly to inner loaders. This is now fixed.\n- Security issue: Changed the default folder for the filesystem cache to be user specific and read and write protected on UNIX systems. See [Debian bug 734747](https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=734747) for more information.\n\n## Version 2.7.1\n\nReleased 2013-08-07\n\n- Fixed a bug with `call_filter` not working properly on environment and context filters.\n- Fixed lack of Python 3 support for bytecode caches.\n- Reverted support for defining blocks in included templates as this broke existing templates for users.\n- Fixed some warnings with hashing of undefineds and nodes if Python is run with warnings for Python 3.\n- Added support for properly hashing undefined objects.\n- Fixed a bug with the title filter not working on already uppercase strings.\n\n## Version 2.7\n\nReleased 2013-05-20, codename Translation\n\n- Choice and prefix loaders now dispatch source and template lookup separately in order to work in combination with module loaders as advertised.\n- Fixed filesizeformat.\n- Added a non-silent option for babel extraction.\n- Added `urlencode` filter that automatically quotes values for URL safe usage with utf-8 as only supported encoding. If applications want to change this encoding they can override the filter.\n- Added `keep-trailing-newline` configuration to environments and templates to optionally preserve the final trailing newline.\n- Accessing `last` on the loop context no longer causes the iterator to be consumed into a list.\n- Python requirement changed: 2.6, 2.7 or \\>= 3.3 are required now, supported by same source code, using the “six” compatibility library.\n- Allow `contextfunction` and other decorators to be applied to `__call__`.\n- Added support for changing from newline to different signs in the `wordwrap` filter.\n- Added support for ignoring memcache errors silently.\n- Added support for keeping the trailing newline in templates.\n- Added finer grained support for stripping whitespace on the left side of blocks.\n- Added `map`, `select`, `reject`, `selectattr` and `rejectattr` filters.\n- Added support for `loop.depth` to figure out how deep inside a recursive loop the code is.\n- Disabled py_compile for pypy and python 3.\n\n## Version 2.6\n\nReleased 2011-07-24, codename Convolution\n\n- Internal attributes now raise an internal attribute error now instead of returning an undefined. This fixes problems when passing undefined objects to Python semantics expecting APIs.\n- Traceback support now works properly for PyPy. (Tested with 1.4)\n- Implemented operator intercepting for sandboxed environments. This allows application developers to disable builtin operators for better security. (For instance limit the mathematical operators to actual integers instead of longs)\n- Groupby filter now supports dotted notation for grouping by attributes of attributes.\n- Scoped blocks now properly treat toplevel assignments and imports. Previously an import suddenly “disappeared” in a scoped block.\n- Automatically detect newer Python interpreter versions before loading code from bytecode caches to prevent segfaults on invalid opcodes. The segfault in earlier Jinja versions here was not a Jinja bug but a limitation in the underlying Python interpreter. If you notice Jinja segfaulting in earlier versions after an upgrade of the Python interpreter you don’t have to upgrade, it’s enough to flush the bytecode cache. This just no longer makes this necessary, Jinja will automatically detect these cases now.\n- The sum filter can now sum up values by attribute. This is a backwards incompatible change. The argument to the filter previously was the optional starting index which defaults to zero. This now became the second argument to the function because it’s rarely used.\n- Like sum, sort now also makes it possible to order items by attribute.\n- Like sum and sort, join now also is able to join attributes of objects as string.\n- The internal eval context now has a reference to the environment.\n- Added a mapping test to see if an object is a dict or an object with a similar interface.\n\n## Version 2.5.5\n\nReleased 2010-10-18\n\n- Built documentation is no longer part of release.\n\n## Version 2.5.4\n\nReleased 2010-10-17\n\n- Fixed extensions not loading properly with overlays.\n- Work around a bug in cpython for the debugger that causes segfaults on 64bit big-endian architectures.\n\n## Version 2.5.3\n\nReleased 2010-10-17\n\n- Fixed an operator precedence error introduced in 2.5.2. Statements like “-foo.bar” had their implicit parentheses applied around the first part of the expression (“(-foo).bar”) instead of the more correct “-(foo.bar)”.\n\n## Version 2.5.2\n\nReleased 2010-08-18\n\n- Improved setup.py script to better work with assumptions people might still have from it (`--with-speedups`).\n- Fixed a packaging error that excluded the new debug support.\n\n## Version 2.5.1\n\nReleased 2010-08-17\n\n- StopIteration exceptions raised by functions called from templates are now intercepted and converted to undefineds. This solves a lot of debugging grief. (StopIteration is used internally to abort template execution)\n- Improved performance of macro calls slightly.\n- Babel extraction can now properly extract newstyle gettext calls.\n- Using the variable `num` in newstyle gettext for something else than the pluralize count will no longer raise a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError \"(in Python v3.11)\").\n- Removed builtin markup class and switched to markupsafe. For backwards compatibility the pure Python implementation still exists but is pulled from markupsafe by the Jinja developers. The debug support went into a separate feature called “debugsupport” and is disabled by default because it is only relevant for Python 2.4\n- Fixed an issue with unary operators having the wrong precedence.\n\n## Version 2.5\n\nReleased 2010-05-29, codename Incoherence\n\n- Improved the sort filter (should have worked like this for a long time) by adding support for case insensitive searches.\n- Fixed a bug for getattribute constant folding.\n- Support for newstyle gettext translations which result in a nicer in-template user interface and more consistent catalogs.\n- It’s now possible to register extensions after an environment was created.\n\n## Version 2.4.1\n\nReleased 2010-04-20\n\n- Fixed an error reporting bug for undefined.\n\n## Version 2.4\n\nReleased 2010-04-13, codename Correlation\n\n- The environment template loading functions now transparently pass through a template object if it was passed to it. This makes it possible to import or extend from a template object that was passed to the template.\n- Added a `ModuleLoader` that can load templates from precompiled sources. The environment now features a method to compile the templates from a configured loader into a zip file or folder.\n- The \\_speedups C extension now supports Python 3.\n- Added support for autoescaping toggling sections and support for evaluation contexts.\n- Extensions have a priority now.\n\n## Version 2.3.1\n\nReleased 2010-02-19\n\n- Fixed an error reporting bug on all python versions\n- Fixed an error reporting bug on Python 2.4\n\n## Version 2.3\n\nReleased 2010-02-10, codename 3000 Pythons\n\n- Fixes issue with code generator that causes unbound variables to be generated if set was used in if-blocks and other small identifier problems.\n- Include tags are now able to select between multiple templates and take the first that exists, if a list of templates is given.\n- Fixed a problem with having call blocks in outer scopes that have an argument that is also used as local variable in an inner frame [\\#360](https://github.com/pallets/jinja/issues/360).\n- Greatly improved error message reporting [\\#339](https://github.com/pallets/jinja/pull/339)\n- Implicit tuple expressions can no longer be totally empty. This change makes `{% if %}` a syntax error now. [\\#364](https://github.com/pallets/jinja/issues/364)\n- Added support for translator comments if extracted via babel.\n- Added with-statement extension.\n- Experimental Python 3 support.\n\n## Version 2.2.1\n\nReleased 2009-09-14\n\n- Fixes some smaller problems for Jinja on Jython.\n\n## Version 2.2\n\nReleased 2009-09-13, codename Kong\n\n- Include statements can now be marked with `ignore missing` to skip non existing templates.\n- Priority of `not` raised. It’s now possible to write `not foo in bar` as an alias to `foo not in bar` like in python. Previously the grammar required parentheses (`not (foo in bar)`) which was odd.\n- Fixed a bug that caused syntax errors when defining macros or using the `{% call %}` tag inside loops.\n- Fixed a bug in the parser that made `{{ foo[1, 2] }}` impossible.\n- Made it possible to refer to names from outer scopes in included templates that were unused in the callers frame [\\#327](https://github.com/pallets/jinja/issues/327)\n- Fixed a bug that caused internal errors if names where used as iteration variable and regular variable *after* the loop if that variable was unused *before* the loop. [\\#331](https://github.com/pallets/jinja/pull/331)\n- Added support for optional `scoped` modifier to blocks.\n- Added support for line-comments.\n- Added the `meta` module.\n- Renamed (undocumented) attribute “overlay” to “overlayed” on the environment because it was clashing with a method of the same name.\n- Speedup extension is now disabled by default.\n\n## Version 2.1.1\n\nReleased 2008-12-25\n\n- Fixed a translation error caused by looping over empty recursive loops.\n\n## Version 2.1\n\nReleased 2008-11-23, codename Yasuzō\n\n- Fixed a bug with nested loops and the special loop variable. Before the change an inner loop overwrote the loop variable from the outer one after iteration.\n- Fixed a bug with the i18n extension that caused the explicit pluralization block to look up the wrong variable.\n- Fixed a limitation in the lexer that made `{{ foo.0.0 }}` impossible.\n- Index based subscribing of variables with a constant value returns an undefined object now instead of raising an index error. This was a bug caused by eager optimizing.\n- The i18n extension looks up `foo.ugettext` now followed by `foo.gettext` if an translations object is installed. This makes dealing with custom translations classes easier.\n- Fixed a confusing behavior with conditional extending. loops were partially executed under some conditions even though they were not part of a visible area.\n- Added `sort` filter that works like `dictsort` but for arbitrary sequences.\n- Fixed a bug with empty statements in macros.\n- Implemented a bytecode cache system.\n- The template context is now weakref-able\n- Inclusions and imports “with context” forward all variables now, not only the initial context.\n- Added a cycle helper called `cycler`.\n- Added a joining helper called `joiner`.\n- Added a `compile_expression` method to the environment that allows compiling of Jinja expressions into callable Python objects.\n- Fixed an escaping bug in urlize\n\n## Version 2.0\n\nReleased 2008-07-17, codename Jinjavitus\n\n- The subscribing of objects (looking up attributes and items) changed from slightly. It’s now possible to give attributes or items a higher priority by either using dot-notation lookup or the bracket syntax. This also changed the AST slightly. `Subscript` is gone and was replaced with `Getitem` and `Getattr`.\n- Added support for preprocessing and token stream filtering for extensions. This would allow extensions to allow simplified gettext calls in template data and something similar.\n- Added `TemplateStream.dump`.\n- Added missing support for implicit string literal concatenation. `{{ \"foo\" \"bar\" }}` is equivalent to `{{ \"foobar\" }}`\n- `else` is optional for conditional expressions. If not given it evaluates to `false`.\n- Improved error reporting for undefined values by providing a position.\n- `filesizeformat` filter uses decimal prefixes now per default and can be set to binary mode with the second parameter.\n- Fixed bug in finalizer\n\n## Version 2.0rc1\n\nReleased 2008-06-09\n\n- First release of Jinja 2.\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/changes/](https://jinja.palletsprojects.com/en/3.1.x/changes/)"
- name: ChoiceLoader
  id: api/index#jinja2.ChoiceLoader
  summary: This loader works like the PrefixLoader just that no prefix is specified
  description: |-
    `class jinja2.ChoiceLoader(loaders)`

    This loader works like the `PrefixLoader` just that no prefix is specified. If a template could not be found by one loader the next one is tried.

    ``` python
    >>> loader = ChoiceLoader([
    ...     FileSystemLoader('/path/to/user/templates'),
    ...     FileSystemLoader('/path/to/system/templates')
    ... ])
    ```

    This is useful if you want to allow users to override builtin templates from a different location.

    Parameters:

    **loaders** ([Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.11)")*\[*[BaseLoader](#jinja2.BaseLoader "jinja2.loaders.BaseLoader")*\]*) –
- name: clear_caches()
  id: api/index#jinja2.clear_caches
  summary: Jinja keeps internal caches for environments and lexers
  description: |-
    `jinja2.clear_caches()`

    Jinja keeps internal caches for environments and lexers. These are used so that Jinja doesn’t have to recreate environments and lexers all the time. Normally you don’t have to care about that but if you are measuring memory consumption you may want to clean the caches.

    Return type:

    None
- name: Compare
  id: extensions/index#jinja2.nodes.Compare
  summary: Compares an expression with some other expressions
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Compare(expr, ops)`

    Compares an expression with some other expressions. `ops` must be a list of [`Operand`](#jinja2.nodes.Operand "jinja2.nodes.Operand")s.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Concat
  id: extensions/index#jinja2.nodes.Concat
  summary: Concatenates the list of expressions provided after converting them to strings
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Concat(nodes)`

    Concatenates the list of expressions provided after converting them to strings.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: CondExpr
  id: extensions/index#jinja2.nodes.CondExpr
  summary: A conditional expression (inline if expression)
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.CondExpr(test, expr1, expr2)`

    A conditional expression (inline if expression). (`{{ foo if bar else baz }}`)

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Const
  id: extensions/index#jinja2.nodes.Const
  summary: All constant values
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Const(value)`

    All constant values. The parser will return this node for simple constants such as `42` or `"foo"` but it can be used to store more complex values such as lists too. Only constants with a safe representation (objects where `eval(repr(x)) == x` is true).

    Node type:

    [`Literal`](#jinja2.nodes.Literal "jinja2.nodes.Literal")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Context
  id: api/index#jinja2.runtime.Context
  summary: The template context holds the variables of a template
  description: |-
    `class jinja2.runtime.Context`

    The template context holds the variables of a template. It stores the values passed to the template and also the names the template exports. Creating instances is neither supported nor useful as it’s created automatically at various stages of the template evaluation and should not be created by hand.

    The context is immutable. Modifications on [`parent`](#jinja2.runtime.Context.parent "jinja2.runtime.Context.parent") **must not** happen and modifications on [`vars`](#jinja2.runtime.Context.vars "jinja2.runtime.Context.vars") are allowed from generated template code only. Template filters and global functions marked as `pass_context()` get the active context passed as first argument and are allowed to access the context read-only.

    The template context supports read only dict operations (`get`, `keys`, `values`, `items`, `iterkeys`, `itervalues`, `iteritems`, `__getitem__`, `__contains__`). Additionally there is a [`resolve()`](#jinja2.runtime.Context.resolve "jinja2.runtime.Context.resolve") method that doesn’t fail with a `KeyError` but returns an [`Undefined`](#jinja2.Undefined "jinja2.runtime.Undefined") object for missing variables.

    Parameters:

    - **environment** ([Environment](#jinja2.Environment "jinja2.Environment")) –
    - **parent** ([Dict](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]*) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **blocks** ([Dict](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[Context](#jinja2.runtime.Context "jinja2.runtime.Context")*\],* [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]\]\]*) –
    - **globals** ([MutableMapping](https://docs.python.org/3/library/typing.html#typing.MutableMapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –
- name: Context.blocks
  id: api/index#jinja2.runtime.Context.blocks
  summary: A dict with the current mapping of blocks in the template
  description: |-
    `blocks`

    A dict with the current mapping of blocks in the template. The keys in this dict are the names of the blocks, and the values a list of blocks registered. The last item in each list is the current active block (latest in the inheritance chain).
- name: Context.call()
  id: api/index#jinja2.runtime.Context.call
  summary: Call the callable with the arguments and keyword arguments provided but inject the active context or environment as first argument if the callable has pass_context() or pass_environment()
  description: |-
    `call(callable, \*args, \**kwargs)`

    Call the callable with the arguments and keyword arguments provided but inject the active context or environment as first argument if the callable has `pass_context()` or `pass_environment()`.

    Parameters:

    - **\_Context\_\_obj** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")) –
    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") \| [Undefined](#jinja2.Undefined "jinja2.runtime.Undefined")
- name: Context.environment
  id: api/index#jinja2.runtime.Context.environment
  summary: The environment that loaded the template
  description: |-
    `environment`

    The environment that loaded the template.
- name: Context.eval_ctx
  id: api/index#jinja2.runtime.Context.eval_ctx
  summary: The current Evaluation Context
  description: |-
    `eval_ctx`

    The current [Evaluation Context](#eval-context).
- name: Context.exported_vars
  id: api/index#jinja2.runtime.Context.exported_vars
  summary: This set contains all the names the template exports
  description: |-
    `exported_vars`

    This set contains all the names the template exports. The values for the names are in the [`vars`](#jinja2.runtime.Context.vars "jinja2.runtime.Context.vars") dict. In order to get a copy of the exported variables as dict, [`get_exported()`](#jinja2.runtime.Context.get_exported "jinja2.runtime.Context.get_exported") can be used.
- name: Context.get()
  id: api/index#jinja2.runtime.Context.get
  summary: Look up a variable by name, or return a default if the key is not found
  description: |-
    `get(key, default=None)`

    Look up a variable by name, or return a default if the key is not found.

    Parameters:

    - **key** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The variable name to look up.
    - **default** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") *\|* *None*) – The value to return if the key is not found.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: Context.get_all()
  id: api/index#jinja2.runtime.Context.get_all
  summary: Return the complete context as dict including the exported variables
  description: |-
    `get_all()`

    Return the complete context as dict including the exported variables. For optimizations reasons this might not return an actual copy so be careful with using it.

    Return type:

    [Dict](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")\]
- name: Context.get_exported()
  id: api/index#jinja2.runtime.Context.get_exported
  summary: Get a new dict with the exported variables
  description: |-
    `get_exported()`

    Get a new dict with the exported variables.

    Return type:

    [Dict](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")\]
- name: Context.name
  id: api/index#jinja2.runtime.Context.name
  summary: The load name of the template owning this context
  description: |-
    `name`

    The load name of the template owning this context.
- name: Context.parent
  id: api/index#jinja2.runtime.Context.parent
  summary: A dict of read only, global variables the template looks up
  description: |-
    `parent`

    A dict of read only, global variables the template looks up. These can either come from another [`Context`](#jinja2.runtime.Context "jinja2.runtime.Context"), from the `Environment.globals` or `Template.globals` or points to a dict created by combining the globals with the variables passed to the render function. It must not be altered.
- name: Context.resolve()
  id: api/index#jinja2.runtime.Context.resolve
  summary: Look up a variable by name, or return an Undefined object if the key is not found
  description: |-
    `resolve(key)`

    Look up a variable by name, or return an [`Undefined`](#jinja2.Undefined "jinja2.runtime.Undefined") object if the key is not found.

    If you need to add custom behavior, override [`resolve_or_missing()`](#jinja2.runtime.Context.resolve_or_missing "jinja2.runtime.Context.resolve_or_missing"), not this method. The various lookup functions use that method, not this one.

    Parameters:

    **key** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The variable name to look up.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") \| [Undefined](#jinja2.Undefined "jinja2.runtime.Undefined")
- name: Context.resolve_or_missing()
  id: api/index#jinja2.runtime.Context.resolve_or_missing
  summary: Look up a variable by name, or return a missing sentinel if the key is not found
  description: |-
    `resolve_or_missing(key)`

    Look up a variable by name, or return a `missing` sentinel if the key is not found.

    Override this method to add custom lookup behavior. [`resolve()`](#jinja2.runtime.Context.resolve "jinja2.runtime.Context.resolve"), [`get()`](#jinja2.runtime.Context.get "jinja2.runtime.Context.get"), and `__getitem__()` use this method. Don’t call this method directly.

    Parameters:

    **key** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The variable name to look up.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    The context is immutable, it prevents modifications, and if it is modified somehow despite that those changes may not show up. For performance, Jinja does not use the context as data storage for, only as a primary data source. Variables that the template does not define are looked up in the context, but variables the template does define are stored locally.

    Instead of modifying the context directly, a function should return a value that can be assigned to a variable within the template itself.

    ``` jinja
    {% set comments = get_latest_comments() %}
    ```

    ## Loaders

    Loaders are responsible for loading templates from a resource such as the file system. The environment will keep the compiled modules in memory like Python’s `sys.modules`. Unlike `sys.modules` however this cache is limited in size by default and templates are automatically reloaded. All loaders are subclasses of [`BaseLoader`](#jinja2.BaseLoader "jinja2.BaseLoader"). If you want to create your own loader, subclass [`BaseLoader`](#jinja2.BaseLoader "jinja2.BaseLoader") and override `get_source`.
- name: Context.vars
  id: api/index#jinja2.runtime.Context.vars
  summary: The template local variables
  description: |-
    `vars`

    The template local variables. This list contains environment and context functions from the [`parent`](#jinja2.runtime.Context.parent "jinja2.runtime.Context.parent") scope as well as local modifications and exported variables from the template. The template will modify this dict during template evaluation but filters and context functions are not allowed to modify it.
- name: ContextReference
  id: extensions/index#jinja2.nodes.ContextReference
  summary: Returns the current template context
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.ContextReference`

    Returns the current template context. It can be used like a [`Name`](#jinja2.nodes.Name "jinja2.nodes.Name") node, with a `'load'` ctx and will return the current [`Context`](../api/index#jinja2.runtime.Context "jinja2.runtime.Context") object.

    Here an example that assigns the current template name to a variable named `foo`:

    ``` python
    Assign(Name('foo', ctx='store'),
           Getattr(ContextReference(), 'name'))
    ```

    This is basically equivalent to using the [`pass_context()`](../api/index#jinja2.pass_context "jinja2.pass_context") decorator when using the high-level API, which causes a reference to the context to be passed as the first argument to a function.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Continue
  id: extensions/index#jinja2.nodes.Continue
  summary: Continue a loop
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Continue`

    Continue a loop.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: count_newlines()
  id: extensions/index#jinja2.lexer.count_newlines
  summary: Count the number of newline characters in the string
  belongs_to: Extensions
  description: |-
    `jinja2.lexer.count_newlines(value)`

    Count the number of newline characters in the string. This is useful for extensions that filter a stream.

    Parameters:

    **value** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")

    ### AST

    The AST (Abstract Syntax Tree) is used to represent a template after parsing. It’s build of nodes that the compiler then converts into executable Python code objects. Extensions that provide custom statements can return nodes to execute custom Python code.

    The list below describes all nodes that are currently available. The AST may change between Jinja versions but will stay backwards compatible.

    For more information have a look at the repr of [`jinja2.Environment.parse()`](../api/index#jinja2.Environment.parse "jinja2.Environment.parse").
- name: cycler
  id: templates/index#jinja-globals.cycler
  summary: Cycle through values by yielding them one at a time, then restarting once the end is reached
  belongs_to: Template Designer Documentation
  description: |-
    `class jinja-globals.cycler(\*items)`

    Cycle through values by yielding them one at a time, then restarting once the end is reached.

    Similar to `loop.cycle`, but can be used outside loops or across multiple loops. For example, render a list of folders and files in a list, alternating giving them “odd” and “even” classes.

    ``` html+jinja
    {% set row_class = cycler("odd", "even") %}
    <ul class="browser">
    {% for folder in folders %}
      <li class="folder {{ row_class.next() }}">{{ folder }}
    {% endfor %}
    {% for file in files %}
      <li class="file {{ row_class.next() }}">{{ file }}
    {% endfor %}
    </ul>
    ```

    Parameters:

    **items** – Each positional argument will be yielded in the order given for each cycle.

    Changelog

    New in version 2.1.
- name: cycler.current
  id: templates/index#jinja-globals.cycler.current
  summary: Return the current item
  belongs_to: Template Designer Documentation
  description: |-
    `property current`

    Return the current item. Equivalent to the item that will be returned next time [`next()`](#jinja-globals.cycler.next "jinja-globals.cycler.next") is called.
- name: cycler.next()
  id: templates/index#jinja-globals.cycler.next
  summary: Return the current item, then advance current to the next item
  belongs_to: Template Designer Documentation
  description: |-
    `next()`

    Return the current item, then advance [`current`](#jinja-globals.cycler.current "jinja-globals.cycler.current") to the next item.
- name: cycler.reset()
  id: templates/index#jinja-globals.cycler.reset
  summary: Resets the current item to the first item
  belongs_to: Template Designer Documentation
  description: |-
    `reset()`

    Resets the current item to the first item.
- name: DebugUndefined
  id: api/index#jinja2.DebugUndefined
  summary: An undefined that returns the debug info when printed
  description: |-
    `class jinja2.DebugUndefined`

    An undefined that returns the debug info when printed.

    ``` python
    >>> foo = DebugUndefined(name='foo')
    >>> str(foo)
    '{{ foo }}'
    >>> not foo
    True
    >>> foo + 42
    Traceback (most recent call last):
      ...
    jinja2.exceptions.UndefinedError: 'foo' is undefined
    ```

    Parameters:

    - **hint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **exc** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[TemplateRuntimeError](#jinja2.TemplateRuntimeError "jinja2.exceptions.TemplateRuntimeError")*\]*) –
- name: default()
  id: templates/index#jinja-filters.default
  summary: 'Changed in version 2.11: It’s now possible to configure the Environment with ChainableUndefined to make the default filter work on nested elements and attributes that may contain undefined values in the chain without getting an UndefinedError'
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.default(value: V, default_value: V = '', boolean: bool = False) → V`

    If the value is undefined it will return the passed default value, otherwise the value of the variable:

    ``` jinja
    {{ my_variable|default('my_variable is not defined') }}
    ```

    This will output the value of `my_variable` if the variable was defined, otherwise `'my_variable is not defined'`. If you want to use default with variables that evaluate to false you have to set the second parameter to `true`:

    ``` jinja
    {{ ''|default('the string was empty', true) }}
    ```

    Changelog

    Changed in version 2.11: It’s now possible to configure the [`Environment`](../api/index#jinja2.Environment "jinja2.Environment") with [`ChainableUndefined`](../api/index#jinja2.ChainableUndefined "jinja2.ChainableUndefined") to make the `default` filter work on nested elements and attributes that may contain undefined values in the chain without getting an [`UndefinedError`](../api/index#jinja2.UndefinedError "jinja2.UndefinedError").

    Aliases:

    `d`
- name: defined()
  id: templates/index#jinja-tests.defined
  summary: See the default() filter for a simple way to set undefined variables
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.defined(value: Any) → bool`

    Return true if the variable is defined:

    ``` jinja
    {% if variable is defined %}
        value of variable: {{ variable }}
    {% else %}
        variable is not defined
    {% endif %}
    ```

    See the `default()` filter for a simple way to set undefined variables.
- name: DerivedContextReference
  id: extensions/index#jinja2.nodes.DerivedContextReference
  summary: Return the current template context including locals
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.DerivedContextReference`

    Return the current template context including locals. Behaves exactly like [`ContextReference`](#jinja2.nodes.ContextReference "jinja2.nodes.ContextReference"), but includes local variables, such as from a `for` loop.

    Changelog

    New in version 2.11.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Dict
  id: extensions/index#jinja2.nodes.Dict
  summary: 'Any dict literal such as {1: 2, 3: 4}. The items must be a list of Pair nodes'
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Dict(items)`

    Any dict literal such as `{1: 2, 3: 4}`. The items must be a list of [`Pair`](#jinja2.nodes.Pair "jinja2.nodes.Pair") nodes.

    Node type:

    [`Literal`](#jinja2.nodes.Literal "jinja2.nodes.Literal")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: dict()
  id: templates/index#jinja-globals.dict
  summary: A convenient alternative to dict literals
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-globals.dict(\**items)`

    A convenient alternative to dict literals. `{'foo': 'bar'}` is the same as `dict(foo='bar')`.
- name: DictLoader
  id: api/index#jinja2.DictLoader
  summary: Loads a template from a Python dict mapping template names to template source
  description: |-
    `class jinja2.DictLoader(mapping)`

    Loads a template from a Python dict mapping template names to template source. This loader is useful for unittesting:

    ``` python
    >>> loader = DictLoader({'index.html': 'source here'})
    ```

    Because auto reloading is rarely useful this is disabled per default.

    Parameters:

    **mapping** ([Mapping](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]*) –
- name: dictsort()
  id: templates/index#jinja-filters.dictsort
  summary: Sort a dict and yield (key, value) pairs
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.dictsort(value: Mapping[K, V], case_sensitive: bool = False, by: 'te.Literal["key", "value"]' = 'key', reverse: bool = False) → List[Tuple[K, V]]`

    Sort a dict and yield (key, value) pairs. Python dicts may not be in the order you want to display them in, so sort them first.

    ``` jinja
    {% for key, value in mydict|dictsort %}
        sort the dict by key, case insensitive

    {% for key, value in mydict|dictsort(reverse=true) %}
        sort the dict by key, case insensitive, reverse order

    {% for key, value in mydict|dictsort(true) %}
        sort the dict by key, case sensitive

    {% for key, value in mydict|dictsort(false, 'value') %}
        sort the dict by value, case insensitive
    ```
- name: Div
  id: extensions/index#jinja2.nodes.Div
  summary: Divides the left by the right node
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Div(left, right)`

    Divides the left by the right node.

    Node type:

    [`BinExpr`](#jinja2.nodes.BinExpr "jinja2.nodes.BinExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: divisibleby()
  id: templates/index#jinja-tests.divisibleby
  summary: Check if a variable is divisible by a number
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.divisibleby(value: int, num: int) → bool`

    Check if a variable is divisible by a number.
- name: Environment
  id: api/index#jinja2.Environment
  summary: The core component of Jinja is the Environment
  description: |-
    `class jinja2.Environment([options])`

    The core component of Jinja is the `Environment`. It contains important shared variables like configuration, filters, tests, globals and others. Instances of this class may be modified if they are not shared and if no template was loaded so far. Modifications on environments after the first template was loaded will lead to surprising effects and undefined behavior.

    Here are the possible initialization parameters:

    `block_start_string`

    The string marking the beginning of a block. Defaults to `'{%'`.

    `block_end_string`

    The string marking the end of a block. Defaults to `'%}'`.

    `variable_start_string`

    The string marking the beginning of a print statement. Defaults to `'{{'`.

    `variable_end_string`

    The string marking the end of a print statement. Defaults to `'}}'`.

    `comment_start_string`

    The string marking the beginning of a comment. Defaults to `'{#'`.

    `comment_end_string`

    The string marking the end of a comment. Defaults to `'#}'`.

    `line_statement_prefix`

    If given and a string, this will be used as prefix for line based statements. See also [Line Statements](../templates/index#line-statements).

    `line_comment_prefix`

    If given and a string, this will be used as prefix for line based comments. See also [Line Statements](../templates/index#line-statements).

    Changelog

    New in version 2.2.

    `trim_blocks`

    If this is set to `True` the first newline after a block is removed (block, not variable tag!). Defaults to `False`.

    `lstrip_blocks`

    If this is set to `True` leading spaces and tabs are stripped from the start of a line to a block. Defaults to `False`.

    `newline_sequence`

    The sequence that starts a newline. Must be one of `'\r'`, `'\n'` or `'\r\n'`. The default is `'\n'` which is a useful default for Linux and OS X systems as well as web applications.

    `keep_trailing_newline`

    Preserve the trailing newline when rendering templates. The default is `False`, which causes a single newline, if present, to be stripped from the end of the template.

    Changelog

    New in version 2.7.

    `extensions`

    List of Jinja extensions to use. This can either be import paths as strings or extension classes. For more information have a look at [the extensions documentation](../extensions/index#jinja-extensions).

    `optimized`

    should the optimizer be enabled? Default is `True`.

    `undefined`

    [`Undefined`](#jinja2.Undefined "jinja2.Undefined") or a subclass of it that is used to represent undefined values in the template.

    `finalize`

    A callable that can be used to process the result of a variable expression before it is output. For example one can convert `None` implicitly into an empty string here.

    `autoescape`

    If set to `True` the XML/HTML autoescaping feature is enabled by default. For more details about autoescaping see `Markup`. As of Jinja 2.4 this can also be a callable that is passed the template name and has to return `True` or `False` depending on autoescape should be enabled by default.

    Changelog

    Changed in version 2.4: `autoescape` can now be a function

    `loader`

    The template loader for this environment.

    `cache_size`

    The size of the cache. Per default this is `400` which means that if more than 400 templates are loaded the loader will clean out the least recently used template. If the cache size is set to `0` templates are recompiled all the time, if the cache size is `-1` the cache will not be cleaned.

    Changelog

    Changed in version 2.8: The cache size was increased to 400 from a low 50.

    `auto_reload`

    Some loaders load templates from locations where the template sources may change (ie: file system or database). If `auto_reload` is set to `True` (default) every time a template is requested the loader checks if the source changed and if yes, it will reload the template. For higher performance it’s possible to disable that.

    `bytecode_cache`

    If set to a bytecode cache object, this object will provide a cache for the internal Jinja bytecode so that templates don’t have to be parsed if they were not changed.

    See [Bytecode Cache](#bytecode-cache) for more information.

    `enable_async`

    If set to true this enables async template execution which allows using async functions and generators.

    Parameters:

    - **block_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **block_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **variable_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **variable_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **comment_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **comment_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **line_statement_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **line_comment_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **trim_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **lstrip_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **newline_sequence** (*te.Literal\['\n',* *'\r\n',* *'\r'\]*) –
    - **keep_trailing_newline** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **extensions** ([Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Extension](../extensions/index#jinja2.ext.Extension "jinja2.ext.Extension")*\]\]*) –
    - **optimized** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **undefined** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Undefined](#jinja2.Undefined "jinja2.runtime.Undefined")*\]*) –
    - **finalize** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –
    - **autoescape** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None\],* [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")*\]*) –
    - **loader** ([BaseLoader](#jinja2.BaseLoader "jinja2.BaseLoader") *\|* *None*) –
    - **cache_size** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –
    - **auto_reload** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **bytecode_cache** ([BytecodeCache](#jinja2.BytecodeCache "jinja2.BytecodeCache") *\|* *None*) –
    - **enable_async** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
- name: Environment.add_extension()
  id: api/index#jinja2.Environment.add_extension
  summary: Adds an extension after the environment was created
  description: |-
    `add_extension(extension)`

    Adds an extension after the environment was created.

    Changelog

    New in version 2.5.

    Parameters:

    **extension** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Extension](../extensions/index#jinja2.ext.Extension "jinja2.ext.Extension")*\]*) –

    Return type:

    None
- name: Environment.code_generator_class
  id: api/index#jinja2.Environment.code_generator_class
  summary: The class used for code generation
  description: |-
    `code_generator_class`

    The class used for code generation. This should not be changed in most cases, unless you need to modify the Python code a template compiles to.
- name: Environment.compile_expression()
  id: api/index#jinja2.Environment.compile_expression
  summary: A handy helper method that returns a callable that accepts keyword arguments that appear as variables in the expression
  description: |-
    `compile_expression(source, undefined_to_none=True)`

    A handy helper method that returns a callable that accepts keyword arguments that appear as variables in the expression. If called it returns the result of the expression.

    This is useful if applications want to use the same rules as Jinja in template “configuration files” or similar situations.

    Example usage:

    ``` python
    >>> env = Environment()
    >>> expr = env.compile_expression('foo == 42')
    >>> expr(foo=23)
    False
    >>> expr(foo=42)
    True
    ```

    Per default the return value is converted to `None` if the expression returns an undefined value. This can be changed by setting `undefined_to_none` to `False`.

    ``` python
    >>> env.compile_expression('var')() is None
    True
    >>> env.compile_expression('var', undefined_to_none=False)()
    Undefined
    ```

    Changelog

    New in version 2.1.

    Parameters:

    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **undefined_to_none** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    *TemplateExpression*
- name: Environment.compile_templates()
  id: api/index#jinja2.Environment.compile_templates
  summary: Finds all the templates the loader can find, compiles them and stores them in target
  description: |-
    `compile_templates(target, extensions=None, filter_func=None, zip='deflated', log_function=None, ignore_errors=True)`

    Finds all the templates the loader can find, compiles them and stores them in `target`. If `zip` is `None`, instead of in a zipfile, the templates will be stored in a directory. By default a deflate zip algorithm is used. To switch to the stored algorithm, `zip` can be set to `'stored'`.

    `extensions` and `filter_func` are passed to [`list_templates()`](#jinja2.Environment.list_templates "jinja2.Environment.list_templates"). Each template returned will be compiled to the target folder or zipfile.

    By default template compilation errors are ignored. In case a log function is provided, errors are logged. If you want template syntax errors to abort the compilation you can set `ignore_errors` to `False` and you will get an exception on syntax errors.

    Changelog

    New in version 2.4.

    Parameters:

    - **target** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)")) –
    - **extensions** ([Collection](https://docs.python.org/3/library/typing.html#typing.Collection "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]* *\|* *None*) –
    - **filter_func** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\],* [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")*\]* *\|* *None*) –
    - **zip** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **log_function** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\],* *None\]* *\|* *None*) –
    - **ignore_errors** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    None
- name: Environment.context_class
  id: api/index#jinja2.Environment.context_class
  summary: The context used for templates
  description: |-
    `context_class`

    The context used for templates. This should not be changed in most cases, unless you need to modify internals of how template variables are handled. For details, see [`Context`](#jinja2.runtime.Context "jinja2.runtime.Context").
- name: Environment.extend()
  id: api/index#jinja2.Environment.extend
  summary: Add the items to the instance of the environment if they do not exist yet
  description: |-
    `extend(**attributes)`

    Add the items to the instance of the environment if they do not exist yet. This is used by [extensions](../extensions/index#writing-extensions) to register callbacks and configuration values without breaking inheritance.

    Parameters:

    **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    None
- name: Environment.extract_translations()
  id: extensions/index#jinja2.Environment.extract_translations
  summary: Extract localizable strings from the given template node or source
  belongs_to: Extensions
  description: |-
    `jinja2.Environment.extract_translations(source)`

    Extract localizable strings from the given template node or source.

    For every string found this function yields a `(lineno, function, message)` tuple, where:

    - `lineno` is the number of the line on which the string was found.
    - `function` is the name of the `gettext` function used (if the string was extracted from embedded Python code).
    - `message` is the string itself, or a tuple of strings for functions with multiple arguments.

    If [Babel](https://babel.pocoo.org/) is installed, see [Babel](https://jinja.palletsprojects.com/en/3.1.x/integration/#babel-integration) to extract the strings.

    For a web application that is available in multiple languages but gives all the users the same language (for example, multilingual forum software installed for a French community), the translation may be installed when the environment is created.

    ``` python
    translations = get_gettext_translations()
    env = Environment(extensions=["jinja2.ext.i18n"])
    env.install_gettext_translations(translations)
    ```

    The `get_gettext_translations` function would return the translator for the current configuration, for example by using `gettext.find`.

    The usage of the `i18n` extension for template designers is covered in [the template documentation](../templates/index#i18n-in-templates).

    ### Whitespace Trimming

    Changelog

    New in version 2.10.

    Within `{% trans %}` blocks, it can be useful to trim line breaks and whitespace so that the block of text looks like a simple string with single spaces in the translation file.

    Linebreaks and surrounding whitespace can be automatically trimmed by enabling the `ext.i18n.trimmed` [policy](../api/index#ext-i18n-trimmed).

    ### New Style Gettext

    Changelog

    New in version 2.5.

    New style gettext calls are less to type, less error prone, and support autoescaping better.

    You can use “new style” gettext calls by setting `env.newstyle_gettext = True` or passing `newstyle=True` to `env.install_translations`. They are fully supported by the Babel extraction tool, but might not work as expected with other extraction tools.

    With standard `gettext` calls, string formatting is a separate step done with the `|format` filter. This requires duplicating work for `ngettext` calls.

    ``` jinja
    {{ gettext("Hello, World!") }}
    {{ gettext("Hello, %(name)s!")|format(name=name) }}
    {{ ngettext(
           "%(num)d apple", "%(num)d apples", apples|count
       )|format(num=apples|count) }}
    {{ pgettext("greeting", "Hello, World!") }}
    {{ npgettext(
           "fruit", "%(num)d apple", "%(num)d apples", apples|count
       )|format(num=apples|count) }}
    ```

    New style `gettext` make formatting part of the call, and behind the scenes enforce more consistency.

    ``` jinja
    {{ gettext("Hello, World!") }}
    {{ gettext("Hello, %(name)s!", name=name) }}
    {{ ngettext("%(num)d apple", "%(num)d apples", apples|count) }}
    {{ pgettext("greeting", "Hello, World!") }}
    {{ npgettext("fruit", "%(num)d apple", "%(num)d apples", apples|count) }}
    ```

    The advantages of newstyle gettext are:

    - There’s no separate formatting step, you don’t have to remember to use the `|format` filter.
    - Only named placeholders are allowed. This solves a common problem translators face because positional placeholders can’t switch positions meaningfully. Named placeholders always carry semantic information about what value goes where.
    - String formatting is used even if no placeholders are used, which makes all strings use a consistent format. Remember to escape any raw percent signs as `%%`, such as `100%%`.
    - The translated string is marked safe, formatting performs escaping as needed. Mark a parameter as `|safe` if it has already been escaped.

    ## Expression Statement

    **Import name:** `jinja2.ext.do`

    The “do” aka expression-statement extension adds a simple `do` tag to the template engine that works like a variable expression but ignores the return value.

    ## Loop Controls

    **Import name:** `jinja2.ext.loopcontrols`

    This extension adds support for `break` and `continue` in loops. After enabling, Jinja provides those two keywords which work exactly like in Python.

    ## With Statement

    **Import name:** `jinja2.ext.with_`

    Changelog

    Changed in version 2.9: This extension is now built-in and no longer does anything.

    ## Autoescape Extension

    **Import name:** `jinja2.ext.autoescape`

    Changelog

    Changed in version 2.9: This extension was removed and is now built-in. Enabling the extension no longer does anything.

    ## Debug Extension

    **Import name:** `jinja2.ext.debug`

    Adds a `{% debug %}` tag to dump the current context as well as the available filters and tests. This is useful to see what’s available to use in the template without setting up a debugger.

    ## Writing Extensions

    By writing extensions you can add custom tags to Jinja. This is a non-trivial task and usually not needed as the default tags and expressions cover all common use cases. The i18n extension is a good example of why extensions are useful. Another one would be fragment caching.

    When writing extensions you have to keep in mind that you are working with the Jinja template compiler which does not validate the node tree you are passing to it. If the AST is malformed you will get all kinds of compiler or runtime errors that are horrible to debug. Always make sure you are using the nodes you create correctly. The API documentation below shows which nodes exist and how to use them.

    ## Example Extensions

    ### Cache

    The following example implements a `cache` tag for Jinja by using the [cachelib](https://github.com/pallets/cachelib) library:

    ``` python
    from jinja2 import nodes
    from jinja2.ext import Extension


    class FragmentCacheExtension(Extension):
        # a set of names that trigger the extension.
        tags = {"cache"}

        def __init__(self, environment):
            super().__init__(environment)

            # add the defaults to the environment
            environment.extend(fragment_cache_prefix="", fragment_cache=None)

        def parse(self, parser):
            # the first token is the token that started the tag.  In our case
            # we only listen to ``'cache'`` so this will be a name token with
            # `cache` as value.  We get the line number so that we can give
            # that line number to the nodes we create by hand.
            lineno = next(parser.stream).lineno

            # now we parse a single expression that is used as cache key.
            args = [parser.parse_expression()]

            # if there is a comma, the user provided a timeout.  If not use
            # None as second parameter.
            if parser.stream.skip_if("comma"):
                args.append(parser.parse_expression())
            else:
                args.append(nodes.Const(None))

            # now we parse the body of the cache block up to `endcache` and
            # drop the needle (which would always be `endcache` in that case)
            body = parser.parse_statements(["name:endcache"], drop_needle=True)

            # now return a `CallBlock` node that calls our _cache_support
            # helper method on this extension.
            return nodes.CallBlock(
                self.call_method("_cache_support", args), [], [], body
            ).set_lineno(lineno)

        def _cache_support(self, name, timeout, caller):
            """Helper callback."""
            key = self.environment.fragment_cache_prefix + name

            # try to load the block from the cache
            # if there is no fragment in the cache, render it and store
            # it in the cache.
            rv = self.environment.fragment_cache.get(key)
            if rv is not None:
                return rv
            rv = caller()
            self.environment.fragment_cache.add(key, rv, timeout)
            return rv
    ```

    And here is how you use it in an environment:

    ``` python
    from jinja2 import Environment
    from cachelib import SimpleCache

    env = Environment(extensions=[FragmentCacheExtension])
    env.fragment_cache = SimpleCache()
    ```

    Inside the template it’s then possible to mark blocks as cacheable. The following example caches a sidebar for 300 seconds:

    ``` html+jinja
    {% cache 'sidebar', 300 %}
    <div class="sidebar">
        ...
    </div>
    {% endcache %}
    ```

    ### Inline `gettext`

    The following example demonstrates using [`Extension.filter_stream()`](#jinja2.ext.Extension.filter_stream "jinja2.ext.Extension.filter_stream") to parse calls to the `_()` gettext function inline with static data without needing Jinja blocks.

    ``` html
    <h1>_(Welcome)</h1>
    <p>_(This is a paragraph)</p>
    ```

    It requires the i18n extension to be loaded and configured.

    ``` python
    import re

    from jinja2.exceptions import TemplateSyntaxError
    from jinja2.ext import Extension
    from jinja2.lexer import count_newlines
    from jinja2.lexer import Token


    _outside_re = re.compile(r"\\?(gettext|_)\(")
    _inside_re = re.compile(r"\\?[()]")


    class InlineGettext(Extension):
        """This extension implements support for inline gettext blocks::

            <h1>_(Welcome)</h1>
            <p>_(This is a paragraph)</p>

        Requires the i18n extension to be loaded and configured.
        """

        def filter_stream(self, stream):
            paren_stack = 0

            for token in stream:
                if token.type != "data":
                    yield token
                    continue

                pos = 0
                lineno = token.lineno

                while True:
                    if not paren_stack:
                        match = _outside_re.search(token.value, pos)
                    else:
                        match = _inside_re.search(token.value, pos)
                    if match is None:
                        break
                    new_pos = match.start()
                    if new_pos > pos:
                        preval = token.value[pos:new_pos]
                        yield Token(lineno, "data", preval)
                        lineno += count_newlines(preval)
                    gtok = match.group()
                    if gtok[0] == "\\":
                        yield Token(lineno, "data", gtok[1:])
                    elif not paren_stack:
                        yield Token(lineno, "block_begin", None)
                        yield Token(lineno, "name", "trans")
                        yield Token(lineno, "block_end", None)
                        paren_stack = 1
                    else:
                        if gtok == "(" or paren_stack > 1:
                            yield Token(lineno, "data", gtok)
                        paren_stack += -1 if gtok == ")" else 1
                        if not paren_stack:
                            yield Token(lineno, "block_begin", None)
                            yield Token(lineno, "name", "endtrans")
                            yield Token(lineno, "block_end", None)
                    pos = match.end()

                if pos < len(token.value):
                    yield Token(lineno, "data", token.value[pos:])

            if paren_stack:
                raise TemplateSyntaxError(
                    "unclosed gettext expression",
                    token.lineno,
                    stream.name,
                    stream.filename,
                )
    ```

    ## Extension API

    ### Extension

    Extensions always have to extend the [`jinja2.ext.Extension`](#jinja2.ext.Extension "jinja2.ext.Extension") class:
- name: Environment.filters
  id: api/index#jinja2.Environment.filters
  summary: A dict of filters for this environment
  description: |-
    `filters`

    A dict of filters for this environment. As long as no template was loaded it’s safe to add new filters or remove old. For custom filters see [Custom Filters](#writing-filters). For valid filter names have a look at [Notes on Identifiers](#identifier-naming).
- name: Environment.from_string()
  id: api/index#jinja2.Environment.from_string
  summary: Load a template from a source string without using loader
  description: |-
    `from_string(source, globals=None, template_class=None)`

    Load a template from a source string without using `loader`.

    Parameters:

    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Template](../extensions/index#jinja2.nodes.Template "jinja2.nodes.Template")) – Jinja source to compile into a template.
    - **globals** ([MutableMapping](https://docs.python.org/3/library/typing.html#typing.MutableMapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) – Extend the environment [`globals`](#jinja2.Environment.globals "jinja2.Environment.globals") with these extra variables available for all renders of this template. If the template has already been loaded and cached, its globals are updated with any new items.
    - **template_class** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Template](#jinja2.Template "jinja2.environment.Template")*\]* *\|* *None*) – Return an instance of this [`Template`](#jinja2.Template "jinja2.Template") class.

    Return type:

    [Template](#jinja2.Template "jinja2.environment.Template")
- name: Environment.get_or_select_template()
  id: api/index#jinja2.Environment.get_or_select_template
  summary: Use select_template() if an iterable of template names is given, or get_template() if one name is given
  description: |-
    `get_or_select_template(template_name_or_list, parent=None, globals=None)`

    Use [`select_template()`](#jinja2.Environment.select_template "jinja2.Environment.select_template") if an iterable of template names is given, or [`get_template()`](#jinja2.Environment.get_template "jinja2.Environment.get_template") if one name is given.

    Changelog

    New in version 2.3.

    Parameters:

    - **template_name_or_list** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Template](#jinja2.Template "jinja2.environment.Template") *\|* [List](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Template](#jinja2.Template "jinja2.environment.Template")*\]*) –
    - **parent** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **globals** ([MutableMapping](https://docs.python.org/3/library/typing.html#typing.MutableMapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –

    Return type:

    [Template](#jinja2.Template "jinja2.environment.Template")
- name: Environment.get_template()
  id: api/index#jinja2.Environment.get_template
  summary: Load a template by name with loader and return a Template
  description: |-
    `get_template(name, parent=None, globals=None)`

    Load a template by name with `loader` and return a [`Template`](#jinja2.Template "jinja2.Template"). If the template does not exist a [`TemplateNotFound`](#jinja2.TemplateNotFound "jinja2.TemplateNotFound") exception is raised.

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Template](#jinja2.Template "jinja2.environment.Template")) – Name of the template to load. When loading templates from the filesystem, “/” is used as the path separator, even on Windows.
    - **parent** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – The name of the parent template importing this template. [`join_path()`](#jinja2.Environment.join_path "jinja2.Environment.join_path") can be used to implement name transformations with this.
    - **globals** ([MutableMapping](https://docs.python.org/3/library/typing.html#typing.MutableMapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) – Extend the environment [`globals`](#jinja2.Environment.globals "jinja2.Environment.globals") with these extra variables available for all renders of this template. If the template has already been loaded and cached, its globals are updated with any new items.

    Return type:

    [Template](#jinja2.Template "jinja2.environment.Template")

    Changelog

    Changed in version 3.0: If a template is loaded from cache, `globals` will update the template’s globals instead of ignoring the new values.

    Changed in version 2.4: If `name` is a [`Template`](#jinja2.Template "jinja2.Template") object it is returned unchanged.
- name: Environment.globals
  id: api/index#jinja2.Environment.globals
  summary: A dict of variables that are available in every template loaded by the environment
  description: |-
    `globals`

    A dict of variables that are available in every template loaded by the environment. As long as no template was loaded it’s safe to modify this. For more details see [The Global Namespace](#global-namespace). For valid object names see [Notes on Identifiers](#identifier-naming).
- name: Environment.install_gettext_callables()
  id: extensions/index#jinja2.Environment.install_gettext_callables
  summary: Install the given gettext, ngettext, pgettext, and npgettext callables into the environment
  belongs_to: Extensions
  description: |-
    `jinja2.Environment.install_gettext_callables(gettext, ngettext, newstyle=False, pgettext=None, npgettext=None)`

    Install the given `gettext`, `ngettext`, `pgettext`, and `npgettext` callables into the environment. They should behave exactly like [`gettext.gettext()`](https://docs.python.org/3/library/gettext.html#gettext.gettext "(in Python v3.11)"), [`gettext.ngettext()`](https://docs.python.org/3/library/gettext.html#gettext.ngettext "(in Python v3.11)"), [`gettext.pgettext()`](https://docs.python.org/3/library/gettext.html#gettext.pgettext "(in Python v3.11)") and [`gettext.npgettext()`](https://docs.python.org/3/library/gettext.html#gettext.npgettext "(in Python v3.11)").

    If `newstyle` is activated, the callables are wrapped to work like newstyle callables. See [New Style Gettext](#newstyle-gettext) for more information.

    Changelog

    Changed in version 3.0: Added `pgettext` and `npgettext`.

    New in version 2.5: Added new-style gettext support.
- name: Environment.install_gettext_translations()
  id: extensions/index#jinja2.Environment.install_gettext_translations
  summary: Installs a translation globally for the environment
  belongs_to: Extensions
  description: |-
    `jinja2.Environment.install_gettext_translations(translations, newstyle=False)`

    Installs a translation globally for the environment. The `translations` object must implement `gettext`, `ngettext`, and optionally `pgettext` and `npgettext`. [`gettext.NullTranslations`](https://docs.python.org/3/library/gettext.html#gettext.NullTranslations "(in Python v3.11)"), [`gettext.GNUTranslations`](https://docs.python.org/3/library/gettext.html#gettext.GNUTranslations "(in Python v3.11)"), and [Babel](https://babel.pocoo.org/)s `Translations` are supported.

    Changelog

    Changed in version 3.0: Added `pgettext` and `npgettext`.

    Changed in version 2.5: Added new-style gettext support.
- name: Environment.install_null_translations()
  id: extensions/index#jinja2.Environment.install_null_translations
  summary: Install no-op gettext functions
  belongs_to: Extensions
  description: |-
    `jinja2.Environment.install_null_translations(newstyle=False)`

    Install no-op gettext functions. This is useful if you want to prepare the application for internationalization but don’t want to implement the full system yet.

    Changelog

    Changed in version 2.5: Added new-style gettext support.
- name: Environment.join_path()
  id: api/index#jinja2.Environment.join_path
  summary: Join a template with the parent
  description: |-
    `join_path(template, parent)`

    Join a template with the parent. By default all the lookups are relative to the loader root so this method returns the `template` parameter unchanged, but if the paths should be relative to the parent template, this function can be used to calculate the real template name.

    Subclasses may override this method and implement template path joining here.

    Parameters:

    - **template** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **parent** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: Environment.lex()
  id: api/index#jinja2.Environment.lex
  summary: Lex the given sourcecode and return a generator that yields tokens as tuples in the form (lineno, token_type, value)
  description: |-
    `Environment.lex(source, name=None, filename=None)`

    Lex the given sourcecode and return a generator that yields tokens as tuples in the form `(lineno, token_type, value)`. This can be useful for [extension development](../extensions/index#writing-extensions) and debugging templates.

    This does not perform preprocessing. If you want the preprocessing of the extensions to be applied you have to filter source through the [`preprocess()`](#jinja2.Environment.preprocess "jinja2.Environment.preprocess") method.

    Parameters:

    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")\[[Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.11)")\[[int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\]\]
- name: Environment.list_templates()
  id: api/index#jinja2.Environment.list_templates
  summary: Returns a list of templates for this environment
  description: |-
    `list_templates(extensions=None, filter_func=None)`

    Returns a list of templates for this environment. This requires that the loader supports the loader’s `list_templates()` method.

    If there are other files in the template folder besides the actual templates, the returned list can be filtered. There are two ways: either `extensions` is set to a list of file extensions for templates, or a `filter_func` can be provided which is a callable that is passed a template name and should return `True` if it should end up in the result list.

    If the loader does not support that, a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "(in Python v3.11)") is raised.

    Changelog

    New in version 2.4.

    Parameters:

    - **extensions** ([Collection](https://docs.python.org/3/library/typing.html#typing.Collection "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]* *\|* *None*) –
    - **filter_func** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\],* [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")*\]* *\|* *None*) –

    Return type:

    [List](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\]
- name: Environment.overlay()
  id: api/index#jinja2.Environment.overlay
  summary: Create a new overlay environment that shares all the data with the current environment except for cache and the overridden attributes
  description: |-
    `overlay([options])`

    Create a new overlay environment that shares all the data with the current environment except for cache and the overridden attributes. Extensions cannot be removed for an overlayed environment. An overlayed environment automatically gets all the extensions of the environment it is linked to plus optional extra extensions.

    Creating overlays should happen after the initial environment was set up completely. Not all attributes are truly linked, some are just copied over so modifications on the original environment may not shine through.

    Changed in version 3.1.2: Added the `newline_sequence`,, `keep_trailing_newline`, and `enable_async` parameters to match `__init__`.

    Parameters:

    - **block_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **block_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **variable_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **variable_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **comment_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **comment_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **line_statement_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **line_comment_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **trim_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **lstrip_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **newline_sequence** (*te.Literal\['\n',* *'\r\n',* *'\r'\]*) –
    - **keep_trailing_newline** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **extensions** ([Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Extension](../extensions/index#jinja2.ext.Extension "jinja2.ext.Extension")*\]\]*) –
    - **optimized** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **undefined** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Undefined](#jinja2.Undefined "jinja2.runtime.Undefined")*\]*) –
    - **finalize** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –
    - **autoescape** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None\],* [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")*\]*) –
    - **loader** ([BaseLoader](#jinja2.BaseLoader "jinja2.BaseLoader") *\|* *None*) –
    - **cache_size** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –
    - **auto_reload** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **bytecode_cache** ([BytecodeCache](#jinja2.BytecodeCache "jinja2.BytecodeCache") *\|* *None*) –
    - **enable_async** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [Environment](#jinja2.Environment "jinja2.Environment")
- name: Environment.parse()
  id: api/index#jinja2.Environment.parse
  summary: Parse the sourcecode and return the abstract syntax tree
  description: |-
    `Environment.parse(source, name=None, filename=None)`

    Parse the sourcecode and return the abstract syntax tree. This tree of nodes is used by the compiler to convert the template into executable source- or bytecode. This is useful for debugging or to extract information from templates.

    If you are [developing Jinja extensions](../extensions/index#writing-extensions) this gives you a good overview of the node tree generated.

    Parameters:

    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    [Template](../extensions/index#jinja2.nodes.Template "jinja2.nodes.Template")
- name: Environment.policies
  id: api/index#jinja2.Environment.policies
  summary: A dictionary with Policies
  description: |-
    `policies`

    A dictionary with [Policies](#policies). These can be reconfigured to change the runtime behavior or certain template features. Usually these are security related.
- name: Environment.preprocess()
  id: api/index#jinja2.Environment.preprocess
  summary: Preprocesses the source with all extensions
  description: |-
    `Environment.preprocess(source, name=None, filename=None)`

    Preprocesses the source with all extensions. This is automatically called for all parsing and compiling methods but *not* for [`lex()`](#jinja2.Environment.lex "jinja2.Environment.lex") because there you usually only want the actual source tokenized.

    Parameters:

    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: Environment.sandboxed
  id: api/index#jinja2.Environment.sandboxed
  summary: If the environment is sandboxed this attribute is True
  description: |-
    `sandboxed`

    If the environment is sandboxed this attribute is `True`. For the sandbox mode have a look at the documentation for the [`SandboxedEnvironment`](../sandbox/index#jinja2.sandbox.SandboxedEnvironment "jinja2.sandbox.SandboxedEnvironment").
- name: Environment.select_template()
  id: api/index#jinja2.Environment.select_template
  summary: Like get_template(), but tries loading multiple names
  description: |-
    `select_template(names, parent=None, globals=None)`

    Like [`get_template()`](#jinja2.Environment.get_template "jinja2.Environment.get_template"), but tries loading multiple names. If none of the names can be loaded a [`TemplatesNotFound`](#jinja2.TemplatesNotFound "jinja2.TemplatesNotFound") exception is raised.

    Parameters:

    - **names** ([Iterable](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Template](#jinja2.Template "jinja2.environment.Template")*\]*) – List of template names to try loading in order.
    - **parent** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – The name of the parent template importing this template. [`join_path()`](#jinja2.Environment.join_path "jinja2.Environment.join_path") can be used to implement name transformations with this.
    - **globals** ([MutableMapping](https://docs.python.org/3/library/typing.html#typing.MutableMapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) – Extend the environment [`globals`](#jinja2.Environment.globals "jinja2.Environment.globals") with these extra variables available for all renders of this template. If the template has already been loaded and cached, its globals are updated with any new items.

    Return type:

    [Template](#jinja2.Template "jinja2.environment.Template")

    Changelog

    Changed in version 3.0: If a template is loaded from cache, `globals` will update the template’s globals instead of ignoring the new values.

    Changed in version 2.11: If `names` is [`Undefined`](#jinja2.Undefined "jinja2.Undefined"), an [`UndefinedError`](#jinja2.UndefinedError "jinja2.UndefinedError") is raised instead. If no templates were found and `names` contains [`Undefined`](#jinja2.Undefined "jinja2.Undefined"), the message is more helpful.

    Changed in version 2.4: If `names` contains a [`Template`](#jinja2.Template "jinja2.Template") object it is returned unchanged.

    New in version 2.3.
- name: Environment.shared
  id: api/index#jinja2.Environment.shared
  summary: If a template was created by using the Template constructor an environment is created automatically
  description: |-
    `shared`

    If a template was created by using the [`Template`](#jinja2.Template "jinja2.Template") constructor an environment is created automatically. These environments are created as shared environments which means that multiple templates may have the same anonymous environment. For all shared environments this attribute is `True`, else `False`.
- name: Environment.tests
  id: api/index#jinja2.Environment.tests
  summary: A dict of test functions for this environment
  description: |-
    `tests`

    A dict of test functions for this environment. As long as no template was loaded it’s safe to modify this dict. For custom tests see [Custom Tests](#writing-tests). For valid test names have a look at [Notes on Identifiers](#identifier-naming).
- name: Environment.undefined()
  id: api/index#jinja2.Environment.undefined
  summary: Creates a new Undefined object for name
  description: |-
    `undefined([hint, obj, name, exc])`

    Creates a new [`Undefined`](#jinja2.Undefined "jinja2.Undefined") object for `name`. This is useful for filters or functions that may return undefined objects for some operations. All parameters except of `hint` should be provided as keyword parameters for better readability. The `hint` is used as error message for the exception if provided, otherwise the error message will be generated from `obj` and `name` automatically. The exception provided as `exc` is raised if something with the generated undefined object is done that the undefined object does not allow. The default exception is [`UndefinedError`](#jinja2.UndefinedError "jinja2.UndefinedError"). If a `hint` is provided the `name` may be omitted.

    The most common way to create an undefined object is by providing a name only:

    ``` python
    return environment.undefined(name='some_name')
    ```

    This means that the name `some_name` is not defined. If the name was from an attribute of an object it makes sense to tell the undefined object the holder object to improve the error message:

    ``` python
    if not hasattr(obj, 'attr'):
        return environment.undefined(obj=obj, name='attr')
    ```

    For a more complex example you can provide a hint. For example the `first()` filter creates an undefined object that way:

    ``` python
    return environment.undefined('no first item, sequence was empty')
    ```

    If it the `name` or `obj` is known (for example because an attribute was accessed) it should be passed to the undefined object, even if a custom `hint` is provided. This gives undefined objects the possibility to enhance the error message.
- name: Environment.uninstall_gettext_translations()
  id: extensions/index#jinja2.Environment.uninstall_gettext_translations
  summary: Uninstall the environment’s globally installed translation
  belongs_to: Extensions
  description: |-
    `jinja2.Environment.uninstall_gettext_translations()`

    Uninstall the environment’s globally installed translation.
- name: EnvironmentAttribute
  id: extensions/index#jinja2.nodes.EnvironmentAttribute
  summary: Loads an attribute from the environment object
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.EnvironmentAttribute(name)`

    Loads an attribute from the environment object. This is useful for extensions that want to call a callback stored on the environment.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: eq()
  id: templates/index#jinja-tests.eq
  summary: Same as a == b
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.eq(a, b, /)`

    Same as a == b.

    Aliases:

    `==`, `equalto`
- name: escape()
  id: templates/index#jinja-filters.escape
  summary: Replace the characters &, <, >, ', and " in the string with HTML-safe sequences
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.escape(value)`

    Replace the characters `&`, `<`, `>`, `'`, and `"` in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML.

    If the object has an `__html__` method, it is called and the return value is assumed to already be safe for HTML.

    Parameters:

    **s** – An object to be converted to a string and escaped.

    Returns:

    A `Markup` string with the escaped text.

    Aliases:

    `e`
- name: escaped()
  id: templates/index#jinja-tests.escaped
  summary: Check if the value is escaped
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.escaped(value: Any) → bool`

    Check if the value is escaped.
- name: EvalContext
  id: api/index#jinja2.nodes.EvalContext
  summary: Holds evaluation time information
  description: |-
    `class jinja2.nodes.EvalContext(environment, template_name=None)`

    Holds evaluation time information. Custom attributes can be attached to it in extensions.

    Parameters:

    - **environment** ([Environment](#jinja2.Environment "jinja2.Environment")) –
    - **template_name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
- name: EvalContext.autoescape
  id: api/index#jinja2.nodes.EvalContext.autoescape
  summary: True or False depending on if autoescaping is active or not
  description: |-
    `autoescape`

    `True` or `False` depending on if autoescaping is active or not.
- name: EvalContext.volatile
  id: api/index#jinja2.nodes.EvalContext.volatile
  summary: True if the compiler cannot evaluate some expressions at compile time
  description: |-
    `volatile`

    `True` if the compiler cannot evaluate some expressions at compile time. At runtime this should always be `False`.

    ## The Global Namespace

    The global namespace stores variables and functions that should be available without needing to pass them to [`Template.render()`](#jinja2.Template.render "jinja2.Template.render"). They are also available to templates that are imported or included without context. Most applications should only use [`Environment.globals`](#jinja2.Environment.globals "jinja2.Environment.globals").

    [`Environment.globals`](#jinja2.Environment.globals "jinja2.Environment.globals") are intended for data that is common to all templates loaded by that environment. [`Template.globals`](#jinja2.Template.globals "jinja2.Template.globals") are intended for data that is common to all renders of that template, and default to [`Environment.globals`](#jinja2.Environment.globals "jinja2.Environment.globals") unless they’re given in [`Environment.get_template()`](#jinja2.Environment.get_template "jinja2.Environment.get_template"), etc. Data that is specific to a render should be passed as context to [`Template.render()`](#jinja2.Template.render "jinja2.Template.render").

    Only one set of globals is used during any specific rendering. If templates A and B both have template globals, and B extends A, then only B’s globals are used for both when using `b.render()`.

    Environment globals should not be changed after loading any templates, and template globals should not be changed at any time after loading the template. Changing globals after loading a template will result in unexpected behavior as they may be shared between the environment and other templates.

    ## Low Level API

    The low level API exposes functionality that can be useful to understand some implementation details, debugging purposes or advanced [extension](../extensions/index#jinja-extensions) techniques. Unless you know exactly what you are doing we don’t recommend using any of those.
- name: EvalContextModifier
  id: extensions/index#jinja2.nodes.EvalContextModifier
  summary: Modifies the eval context
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.EvalContextModifier(options)`

    Modifies the eval context. For each option that should be modified, a [`Keyword`](#jinja2.nodes.Keyword "jinja2.nodes.Keyword") has to be added to the `options` list.

    Example to change the `autoescape` setting:

    ``` python
    EvalContextModifier(options=[Keyword('autoescape', Const(True))])
    ```

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: even()
  id: templates/index#jinja-tests.even
  summary: Return true if the variable is even
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.even(value: int) → bool`

    Return true if the variable is even.
- name: Expr
  id: extensions/index#jinja2.nodes.Expr
  summary: Baseclass for all expressions
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Expr`

    Baseclass for all expressions.

    Node type:

    [`Node`](#jinja2.nodes.Node "jinja2.nodes.Node")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Expr.as_const()
  id: extensions/index#jinja2.nodes.Expr.as_const
  summary: Return the value of the expression as constant or raise Impossible if this was not possible
  belongs_to: Extensions
  description: |-
    `as_const(eval_ctx=None)`

    Return the value of the expression as constant or raise [`Impossible`](#jinja2.nodes.Impossible "jinja2.nodes.Impossible") if this was not possible.

    An [`EvalContext`](../api/index#jinja2.nodes.EvalContext "jinja2.nodes.EvalContext") can be provided, if none is given a default context is created which requires the nodes to have an attached environment.

    Changelog

    Changed in version 2.4: the `eval_ctx` parameter was added.

    Parameters:

    **eval_ctx** ([EvalContext](../api/index#jinja2.nodes.EvalContext "jinja2.nodes.EvalContext") *\|* *None*) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: Expr.can_assign()
  id: extensions/index#jinja2.nodes.Expr.can_assign
  summary: Check if it’s possible to assign something to this node
  belongs_to: Extensions
  description: |-
    `can_assign()`

    Check if it’s possible to assign something to this node.

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: ExprStmt
  id: extensions/index#jinja2.nodes.ExprStmt
  summary: A statement that evaluates an expression and discards the result
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.ExprStmt(node)`

    A statement that evaluates an expression and discards the result.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Extends
  id: extensions/index#jinja2.nodes.Extends
  summary: Represents an extends statement
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Extends(template)`

    Represents an extends statement.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Extension
  id: extensions/index#jinja2.ext.Extension
  summary: Extensions can be used to add extra functionality to the Jinja template system at the parser level
  belongs_to: Extensions
  description: |-
    `class jinja2.ext.Extension(environment)`

    Extensions can be used to add extra functionality to the Jinja template system at the parser level. Custom extensions are bound to an environment but may not store environment specific data on `self`. The reason for this is that an extension can be bound to another environment (for overlays) by creating a copy and reassigning the `environment` attribute.

    As extensions are created by the environment they cannot accept any arguments for configuration. One may want to work around that by using a factory function, but that is not possible as extensions are identified by their import name. The correct way to configure the extension is storing the configuration values on the environment. Because this way the environment ends up acting as central configuration storage the attributes may clash which is why extensions have to ensure that the names they choose for configuration are not too generic. `prefix` for example is a terrible name, `fragment_cache_prefix` on the other hand is a good name as includes the name of the extension (fragment cache).

    Parameters:

    **environment** ([Environment](../api/index#jinja2.Environment "jinja2.environment.Environment")) –
- name: Extension.attr()
  id: extensions/index#jinja2.ext.Extension.attr
  summary: Return an attribute node for the current extension
  belongs_to: Extensions
  description: |-
    `attr(name, lineno=None)`

    Return an attribute node for the current extension. This is useful to pass constants on extensions to generated template code.

    ``` python
    self.attr('_my_attribute', lineno=lineno)
    ```

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **lineno** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *None*) –

    Return type:

    [ExtensionAttribute](#jinja2.nodes.ExtensionAttribute "jinja2.nodes.ExtensionAttribute")
- name: Extension.call_method()
  id: extensions/index#jinja2.ext.Extension.call_method
  summary: Call a method of the extension
  belongs_to: Extensions
  description: |-
    `call_method(name, args=None, kwargs=None, dyn_args=None, dyn_kwargs=None, lineno=None)`

    Call a method of the extension. This is a shortcut for [`attr()`](#jinja2.ext.Extension.attr "jinja2.ext.Extension.attr") + [`jinja2.nodes.Call`](#jinja2.nodes.Call "jinja2.nodes.Call").

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **args** ([List](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.11)")*\[*[Expr](#jinja2.nodes.Expr "jinja2.nodes.Expr")*\]* *\|* *None*) –
    - **kwargs** ([List](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.11)")*\[*[Keyword](#jinja2.nodes.Keyword "jinja2.nodes.Keyword")*\]* *\|* *None*) –
    - **dyn_args** ([Expr](#jinja2.nodes.Expr "jinja2.nodes.Expr") *\|* *None*) –
    - **dyn_kwargs** ([Expr](#jinja2.nodes.Expr "jinja2.nodes.Expr") *\|* *None*) –
    - **lineno** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *None*) –

    Return type:

    [Call](#jinja2.nodes.Call "jinja2.nodes.Call")
- name: Extension.filter_stream()
  id: extensions/index#jinja2.ext.Extension.filter_stream
  summary: It’s passed a TokenStream that can be used to filter tokens returned
  belongs_to: Extensions
  description: |-
    `filter_stream(stream)`

    It’s passed a [`TokenStream`](#jinja2.lexer.TokenStream "jinja2.lexer.TokenStream") that can be used to filter tokens returned. This method has to return an iterable of [`Token`](#jinja2.lexer.Token "jinja2.lexer.Token")s, but it doesn’t have to return a [`TokenStream`](#jinja2.lexer.TokenStream "jinja2.lexer.TokenStream").

    Parameters:

    **stream** ([TokenStream](#jinja2.lexer.TokenStream "jinja2.lexer.TokenStream")) –

    Return type:

    [TokenStream](#jinja2.lexer.TokenStream "jinja2.lexer.TokenStream") \| [Iterable](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.11)")\[[Token](#jinja2.lexer.Token "jinja2.lexer.Token")\]
- name: Extension.identifier
  id: extensions/index#jinja2.ext.Extension.identifier
  summary: The identifier of the extension
  belongs_to: Extensions
  description: |-
    `identifier`

    The identifier of the extension. This is always the true import name of the extension class and must not be changed.
- name: Extension.parse()
  id: extensions/index#jinja2.ext.Extension.parse
  summary: If any of the tags matched this method is called with the parser as first argument
  belongs_to: Extensions
  description: |-
    `parse(parser)`

    If any of the [`tags`](#jinja2.ext.Extension.tags "jinja2.ext.Extension.tags") matched this method is called with the parser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes.

    Parameters:

    **parser** ([Parser](#jinja2.parser.Parser "jinja2.parser.Parser")) –

    Return type:

    [Node](#jinja2.nodes.Node "jinja2.nodes.Node") \| [List](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.11)")\[[Node](#jinja2.nodes.Node "jinja2.nodes.Node")\]
- name: Extension.preprocess()
  id: extensions/index#jinja2.ext.Extension.preprocess
  summary: This method is called before the actual lexing and can be used to preprocess the source
  belongs_to: Extensions
  description: |-
    `preprocess(source, name, filename=None)`

    This method is called before the actual lexing and can be used to preprocess the source. The `filename` is optional. The return value must be the preprocessed source.

    Parameters:

    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")

    ### Parser

    The parser passed to [`Extension.parse()`](#jinja2.ext.Extension.parse "jinja2.ext.Extension.parse") provides ways to parse expressions of different types. The following methods may be used by extensions:
- name: Extension.tags
  id: extensions/index#jinja2.ext.Extension.tags
  summary: If the extension implements custom tags this is a set of tag names the extension is listening for
  belongs_to: Extensions
  description: |-
    `tags`

    If the extension implements custom tags this is a set of tag names the extension is listening for.
- name: ExtensionAttribute
  id: extensions/index#jinja2.nodes.ExtensionAttribute
  summary: Returns the attribute of an extension bound to the environment
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.ExtensionAttribute(identifier, name)`

    Returns the attribute of an extension bound to the environment. The identifier is the identifier of the `Extension`.

    This node is usually constructed by calling the [`attr()`](#jinja2.ext.Extension.attr "jinja2.ext.Extension.attr") method on an extension.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Extensions
  id: extensions/index
  summary: Jinja supports extensions that can add extra filters, tests, globals or even extend the parser
  description: "# Extensions\n\nJinja supports extensions that can add extra filters, tests, globals or even extend the parser. The main motivation of extensions is to move often used code into a reusable class like adding support for internationalization.\n\n## Adding Extensions\n\nExtensions are added to the Jinja environment at creation time. To add an extension pass a list of extension classes or import paths to the `extensions` parameter of the [`Environment`](../api/index#jinja2.Environment \"jinja2.Environment\") constructor. The following example creates a Jinja environment with the i18n extension loaded:\n\n``` python\njinja_env = Environment(extensions=['jinja2.ext.i18n'])\n```\n\nTo add extensions after creation time, use the [`add_extension()`](../api/index#jinja2.Environment.add_extension \"jinja2.Environment.add_extension\") method:\n\n``` python\njinja_env.add_extension('jinja2.ext.debug')\n```\n\n## i18n Extension\n\n**Import name:** `jinja2.ext.i18n`\n\nThe i18n extension can be used in combination with [gettext](https://docs.python.org/3/library/gettext.html) or [Babel](https://babel.pocoo.org/). When it’s enabled, Jinja provides a `trans` statement that marks a block as translatable and calls `gettext`.\n\nAfter enabling, an application has to provide functions for `gettext`, `ngettext`, and optionally `pgettext` and `npgettext`, either globally or when rendering. A `_()` function is added as an alias to the `gettext` function.\n\n### Environment Methods\n\nAfter enabling the extension, the environment provides the following additional methods:\n\n`jinja2.Environment.install_gettext_translations(translations, newstyle=False)`  \nInstalls a translation globally for the environment. The `translations` object must implement `gettext`, `ngettext`, and optionally `pgettext` and `npgettext`. [`gettext.NullTranslations`](https://docs.python.org/3/library/gettext.html#gettext.NullTranslations \"(in Python v3.11)\"), [`gettext.GNUTranslations`](https://docs.python.org/3/library/gettext.html#gettext.GNUTranslations \"(in Python v3.11)\"), and [Babel](https://babel.pocoo.org/)s `Translations` are supported.\n\nChangelog\n\nChanged in version 3.0: Added `pgettext` and `npgettext`.\n\nChanged in version 2.5: Added new-style gettext support.\n\n`jinja2.Environment.install_null_translations(newstyle=False)`  \nInstall no-op gettext functions. This is useful if you want to prepare the application for internationalization but don’t want to implement the full system yet.\n\nChangelog\n\nChanged in version 2.5: Added new-style gettext support.\n\n&nbsp;\n\n`jinja2.Environment.install_gettext_callables(gettext, ngettext, newstyle=False, pgettext=None, npgettext=None)`  \nInstall the given `gettext`, `ngettext`, `pgettext`, and `npgettext` callables into the environment. They should behave exactly like [`gettext.gettext()`](https://docs.python.org/3/library/gettext.html#gettext.gettext \"(in Python v3.11)\"), [`gettext.ngettext()`](https://docs.python.org/3/library/gettext.html#gettext.ngettext \"(in Python v3.11)\"), [`gettext.pgettext()`](https://docs.python.org/3/library/gettext.html#gettext.pgettext \"(in Python v3.11)\") and [`gettext.npgettext()`](https://docs.python.org/3/library/gettext.html#gettext.npgettext \"(in Python v3.11)\").\n\nIf `newstyle` is activated, the callables are wrapped to work like newstyle callables. See [New Style Gettext](#newstyle-gettext) for more information.\n\nChangelog\n\nChanged in version 3.0: Added `pgettext` and `npgettext`.\n\nNew in version 2.5: Added new-style gettext support.\n\n&nbsp;\n\n`jinja2.Environment.uninstall_gettext_translations()`  \nUninstall the environment’s globally installed translation.\n\n&nbsp;\n\n`jinja2.Environment.extract_translations(source)`  \nExtract localizable strings from the given template node or source.\n\nFor every string found this function yields a `(lineno, function, message)` tuple, where:\n\n- `lineno` is the number of the line on which the string was found.\n- `function` is the name of the `gettext` function used (if the string was extracted from embedded Python code).\n- `message` is the string itself, or a tuple of strings for functions with multiple arguments.\n\nIf [Babel](https://babel.pocoo.org/) is installed, see [Babel](https://jinja.palletsprojects.com/en/3.1.x/integration/#babel-integration) to extract the strings.\n\nFor a web application that is available in multiple languages but gives all the users the same language (for example, multilingual forum software installed for a French community), the translation may be installed when the environment is created.\n\n``` python\ntranslations = get_gettext_translations()\nenv = Environment(extensions=[\"jinja2.ext.i18n\"])\nenv.install_gettext_translations(translations)\n```\n\nThe `get_gettext_translations` function would return the translator for the current configuration, for example by using `gettext.find`.\n\nThe usage of the `i18n` extension for template designers is covered in [the template documentation](../templates/index#i18n-in-templates).\n\n### Whitespace Trimming\n\nChangelog\n\nNew in version 2.10.\n\nWithin `{% trans %}` blocks, it can be useful to trim line breaks and whitespace so that the block of text looks like a simple string with single spaces in the translation file.\n\nLinebreaks and surrounding whitespace can be automatically trimmed by enabling the `ext.i18n.trimmed` [policy](../api/index#ext-i18n-trimmed).\n\n### New Style Gettext\n\nChangelog\n\nNew in version 2.5.\n\nNew style gettext calls are less to type, less error prone, and support autoescaping better.\n\nYou can use “new style” gettext calls by setting `env.newstyle_gettext = True` or passing `newstyle=True` to `env.install_translations`. They are fully supported by the Babel extraction tool, but might not work as expected with other extraction tools.\n\nWith standard `gettext` calls, string formatting is a separate step done with the `|format` filter. This requires duplicating work for `ngettext` calls.\n\n``` jinja\n{{ gettext(\"Hello, World!\") }}\n{{ gettext(\"Hello, %(name)s!\")|format(name=name) }}\n{{ ngettext(\n       \"%(num)d apple\", \"%(num)d apples\", apples|count\n   )|format(num=apples|count) }}\n{{ pgettext(\"greeting\", \"Hello, World!\") }}\n{{ npgettext(\n       \"fruit\", \"%(num)d apple\", \"%(num)d apples\", apples|count\n   )|format(num=apples|count) }}\n```\n\nNew style `gettext` make formatting part of the call, and behind the scenes enforce more consistency.\n\n``` jinja\n{{ gettext(\"Hello, World!\") }}\n{{ gettext(\"Hello, %(name)s!\", name=name) }}\n{{ ngettext(\"%(num)d apple\", \"%(num)d apples\", apples|count) }}\n{{ pgettext(\"greeting\", \"Hello, World!\") }}\n{{ npgettext(\"fruit\", \"%(num)d apple\", \"%(num)d apples\", apples|count) }}\n```\n\nThe advantages of newstyle gettext are:\n\n- There’s no separate formatting step, you don’t have to remember to use the `|format` filter.\n- Only named placeholders are allowed. This solves a common problem translators face because positional placeholders can’t switch positions meaningfully. Named placeholders always carry semantic information about what value goes where.\n- String formatting is used even if no placeholders are used, which makes all strings use a consistent format. Remember to escape any raw percent signs as `%%`, such as `100%%`.\n- The translated string is marked safe, formatting performs escaping as needed. Mark a parameter as `|safe` if it has already been escaped.\n\n## Expression Statement\n\n**Import name:** `jinja2.ext.do`\n\nThe “do” aka expression-statement extension adds a simple `do` tag to the template engine that works like a variable expression but ignores the return value.\n\n## Loop Controls\n\n**Import name:** `jinja2.ext.loopcontrols`\n\nThis extension adds support for `break` and `continue` in loops. After enabling, Jinja provides those two keywords which work exactly like in Python.\n\n## With Statement\n\n**Import name:** `jinja2.ext.with_`\n\nChangelog\n\nChanged in version 2.9: This extension is now built-in and no longer does anything.\n\n## Autoescape Extension\n\n**Import name:** `jinja2.ext.autoescape`\n\nChangelog\n\nChanged in version 2.9: This extension was removed and is now built-in. Enabling the extension no longer does anything.\n\n## Debug Extension\n\n**Import name:** `jinja2.ext.debug`\n\nAdds a `{% debug %}` tag to dump the current context as well as the available filters and tests. This is useful to see what’s available to use in the template without setting up a debugger.\n\n## Writing Extensions\n\nBy writing extensions you can add custom tags to Jinja. This is a non-trivial task and usually not needed as the default tags and expressions cover all common use cases. The i18n extension is a good example of why extensions are useful. Another one would be fragment caching.\n\nWhen writing extensions you have to keep in mind that you are working with the Jinja template compiler which does not validate the node tree you are passing to it. If the AST is malformed you will get all kinds of compiler or runtime errors that are horrible to debug. Always make sure you are using the nodes you create correctly. The API documentation below shows which nodes exist and how to use them.\n\n## Example Extensions\n\n### Cache\n\nThe following example implements a `cache` tag for Jinja by using the [cachelib](https://github.com/pallets/cachelib) library:\n\n``` python\nfrom jinja2 import nodes\nfrom jinja2.ext import Extension\n\n\nclass FragmentCacheExtension(Extension):\n    # a set of names that trigger the extension.\n    tags = {\"cache\"}\n\n    def __init__(self, environment):\n        super().__init__(environment)\n\n        # add the defaults to the environment\n        environment.extend(fragment_cache_prefix=\"\", fragment_cache=None)\n\n    def parse(self, parser):\n        # the first token is the token that started the tag.  In our case\n        # we only listen to ``'cache'`` so this will be a name token with\n        # `cache` as value.  We get the line number so that we can give\n        # that line number to the nodes we create by hand.\n        lineno = next(parser.stream).lineno\n\n        # now we parse a single expression that is used as cache key.\n        args = [parser.parse_expression()]\n\n        # if there is a comma, the user provided a timeout.  If not use\n        # None as second parameter.\n        if parser.stream.skip_if(\"comma\"):\n            args.append(parser.parse_expression())\n        else:\n            args.append(nodes.Const(None))\n\n        # now we parse the body of the cache block up to `endcache` and\n        # drop the needle (which would always be `endcache` in that case)\n        body = parser.parse_statements([\"name:endcache\"], drop_needle=True)\n\n        # now return a `CallBlock` node that calls our _cache_support\n        # helper method on this extension.\n        return nodes.CallBlock(\n            self.call_method(\"_cache_support\", args), [], [], body\n        ).set_lineno(lineno)\n\n    def _cache_support(self, name, timeout, caller):\n        \"\"\"Helper callback.\"\"\"\n        key = self.environment.fragment_cache_prefix + name\n\n        # try to load the block from the cache\n        # if there is no fragment in the cache, render it and store\n        # it in the cache.\n        rv = self.environment.fragment_cache.get(key)\n        if rv is not None:\n            return rv\n        rv = caller()\n        self.environment.fragment_cache.add(key, rv, timeout)\n        return rv\n```\n\nAnd here is how you use it in an environment:\n\n``` python\nfrom jinja2 import Environment\nfrom cachelib import SimpleCache\n\nenv = Environment(extensions=[FragmentCacheExtension])\nenv.fragment_cache = SimpleCache()\n```\n\nInside the template it’s then possible to mark blocks as cacheable. The following example caches a sidebar for 300 seconds:\n\n``` html+jinja\n{% cache 'sidebar', 300 %}\n<div class=\"sidebar\">\n    ...\n</div>\n{% endcache %}\n```\n\n### Inline `gettext`\n\nThe following example demonstrates using [`Extension.filter_stream()`](#jinja2.ext.Extension.filter_stream \"jinja2.ext.Extension.filter_stream\") to parse calls to the `_()` gettext function inline with static data without needing Jinja blocks.\n\n``` html\n<h1>_(Welcome)</h1>\n<p>_(This is a paragraph)</p>\n```\n\nIt requires the i18n extension to be loaded and configured.\n\n``` python\nimport re\n\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom jinja2.ext import Extension\nfrom jinja2.lexer import count_newlines\nfrom jinja2.lexer import Token\n\n\n_outside_re = re.compile(r\"\\\\?(gettext|_)\\(\")\n_inside_re = re.compile(r\"\\\\?[()]\")\n\n\nclass InlineGettext(Extension):\n    \"\"\"This extension implements support for inline gettext blocks::\n\n        <h1>_(Welcome)</h1>\n        <p>_(This is a paragraph)</p>\n\n    Requires the i18n extension to be loaded and configured.\n    \"\"\"\n\n    def filter_stream(self, stream):\n        paren_stack = 0\n\n        for token in stream:\n            if token.type != \"data\":\n                yield token\n                continue\n\n            pos = 0\n            lineno = token.lineno\n\n            while True:\n                if not paren_stack:\n                    match = _outside_re.search(token.value, pos)\n                else:\n                    match = _inside_re.search(token.value, pos)\n                if match is None:\n                    break\n                new_pos = match.start()\n                if new_pos > pos:\n                    preval = token.value[pos:new_pos]\n                    yield Token(lineno, \"data\", preval)\n                    lineno += count_newlines(preval)\n                gtok = match.group()\n                if gtok[0] == \"\\\\\":\n                    yield Token(lineno, \"data\", gtok[1:])\n                elif not paren_stack:\n                    yield Token(lineno, \"block_begin\", None)\n                    yield Token(lineno, \"name\", \"trans\")\n                    yield Token(lineno, \"block_end\", None)\n                    paren_stack = 1\n                else:\n                    if gtok == \"(\" or paren_stack > 1:\n                        yield Token(lineno, \"data\", gtok)\n                    paren_stack += -1 if gtok == \")\" else 1\n                    if not paren_stack:\n                        yield Token(lineno, \"block_begin\", None)\n                        yield Token(lineno, \"name\", \"endtrans\")\n                        yield Token(lineno, \"block_end\", None)\n                pos = match.end()\n\n            if pos < len(token.value):\n                yield Token(lineno, \"data\", token.value[pos:])\n\n        if paren_stack:\n            raise TemplateSyntaxError(\n                \"unclosed gettext expression\",\n                token.lineno,\n                stream.name,\n                stream.filename,\n            )\n```\n\n## Extension API\n\n### Extension\n\nExtensions always have to extend the [`jinja2.ext.Extension`](#jinja2.ext.Extension \"jinja2.ext.Extension\") class:\n\n`class jinja2.ext.Extension(environment)`  \nExtensions can be used to add extra functionality to the Jinja template system at the parser level. Custom extensions are bound to an environment but may not store environment specific data on `self`. The reason for this is that an extension can be bound to another environment (for overlays) by creating a copy and reassigning the `environment` attribute.\n\nAs extensions are created by the environment they cannot accept any arguments for configuration. One may want to work around that by using a factory function, but that is not possible as extensions are identified by their import name. The correct way to configure the extension is storing the configuration values on the environment. Because this way the environment ends up acting as central configuration storage the attributes may clash which is why extensions have to ensure that the names they choose for configuration are not too generic. `prefix` for example is a terrible name, `fragment_cache_prefix` on the other hand is a good name as includes the name of the extension (fragment cache).\n\nParameters:  \n**environment** ([Environment](../api/index#jinja2.Environment \"jinja2.environment.Environment\")) –\n\n`identifier`  \nThe identifier of the extension. This is always the true import name of the extension class and must not be changed.\n\n`tags`  \nIf the extension implements custom tags this is a set of tag names the extension is listening for.\n\n`attr(name, lineno=None)`  \nReturn an attribute node for the current extension. This is useful to pass constants on extensions to generated template code.\n\n``` python\nself.attr('_my_attribute', lineno=lineno)\n```\n\nParameters:  \n- **name** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **lineno** ([int](https://docs.python.org/3/library/functions.html#int \"(in Python v3.11)\") *\\|* *None*) –\n\nReturn type:  \n[ExtensionAttribute](#jinja2.nodes.ExtensionAttribute \"jinja2.nodes.ExtensionAttribute\")\n\n`call_method(name, args=None, kwargs=None, dyn_args=None, dyn_kwargs=None, lineno=None)`  \nCall a method of the extension. This is a shortcut for [`attr()`](#jinja2.ext.Extension.attr \"jinja2.ext.Extension.attr\") + [`jinja2.nodes.Call`](#jinja2.nodes.Call \"jinja2.nodes.Call\").\n\nParameters:  \n- **name** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **args** ([List](https://docs.python.org/3/library/typing.html#typing.List \"(in Python v3.11)\")*\\[*[Expr](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")*\\]* *\\|* *None*) –\n- **kwargs** ([List](https://docs.python.org/3/library/typing.html#typing.List \"(in Python v3.11)\")*\\[*[Keyword](#jinja2.nodes.Keyword \"jinja2.nodes.Keyword\")*\\]* *\\|* *None*) –\n- **dyn_args** ([Expr](#jinja2.nodes.Expr \"jinja2.nodes.Expr\") *\\|* *None*) –\n- **dyn_kwargs** ([Expr](#jinja2.nodes.Expr \"jinja2.nodes.Expr\") *\\|* *None*) –\n- **lineno** ([int](https://docs.python.org/3/library/functions.html#int \"(in Python v3.11)\") *\\|* *None*) –\n\nReturn type:  \n[Call](#jinja2.nodes.Call \"jinja2.nodes.Call\")\n\n`filter_stream(stream)`  \nIt’s passed a [`TokenStream`](#jinja2.lexer.TokenStream \"jinja2.lexer.TokenStream\") that can be used to filter tokens returned. This method has to return an iterable of [`Token`](#jinja2.lexer.Token \"jinja2.lexer.Token\")s, but it doesn’t have to return a [`TokenStream`](#jinja2.lexer.TokenStream \"jinja2.lexer.TokenStream\").\n\nParameters:  \n**stream** ([TokenStream](#jinja2.lexer.TokenStream \"jinja2.lexer.TokenStream\")) –\n\nReturn type:  \n[TokenStream](#jinja2.lexer.TokenStream \"jinja2.lexer.TokenStream\") \\| [Iterable](https://docs.python.org/3/library/typing.html#typing.Iterable \"(in Python v3.11)\")\\[[Token](#jinja2.lexer.Token \"jinja2.lexer.Token\")\\]\n\n`parse(parser)`  \nIf any of the [`tags`](#jinja2.ext.Extension.tags \"jinja2.ext.Extension.tags\") matched this method is called with the parser as first argument. The token the parser stream is pointing at is the name token that matched. This method has to return one or a list of multiple nodes.\n\nParameters:  \n**parser** ([Parser](#jinja2.parser.Parser \"jinja2.parser.Parser\")) –\n\nReturn type:  \n[Node](#jinja2.nodes.Node \"jinja2.nodes.Node\") \\| [List](https://docs.python.org/3/library/typing.html#typing.List \"(in Python v3.11)\")\\[[Node](#jinja2.nodes.Node \"jinja2.nodes.Node\")\\]\n\n`preprocess(source, name, filename=None)`  \nThis method is called before the actual lexing and can be used to preprocess the source. The `filename` is optional. The return value must be the preprocessed source.\n\nParameters:  \n- **source** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **name** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n- **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n\nReturn type:  \n[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")\n\n### Parser\n\nThe parser passed to [`Extension.parse()`](#jinja2.ext.Extension.parse \"jinja2.ext.Extension.parse\") provides ways to parse expressions of different types. The following methods may be used by extensions:\n\n`class jinja2.parser.Parser(environment, source, name=None, filename=None, state=None)`  \nThis is the central parsing class Jinja uses. It’s passed to extensions and can be used to parse expressions or statements.\n\nParameters:  \n- **environment** ([Environment](../api/index#jinja2.Environment \"jinja2.Environment\")) –\n- **source** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **name** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n- **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n- **state** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n\n`filename`  \nThe filename of the template the parser processes. This is **not** the load name of the template. For the load name see [`name`](#jinja2.parser.Parser.name \"jinja2.parser.Parser.name\"). For templates that were not loaded form the file system this is `None`.\n\n`name`  \nThe load name of the template.\n\n`stream`  \nThe current [`TokenStream`](#jinja2.lexer.TokenStream \"jinja2.lexer.TokenStream\")\n\n`fail(msg, lineno=None, exc=<class 'jinja2.exceptions.TemplateSyntaxError'>)`  \nConvenience method that raises `exc` with the message, passed line number or last line number as well as the current name and filename.\n\nParameters:  \n- **msg** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **lineno** ([int](https://docs.python.org/3/library/functions.html#int \"(in Python v3.11)\") *\\|* *None*) –\n- **exc** ([Type](https://docs.python.org/3/library/typing.html#typing.Type \"(in Python v3.11)\")*\\[*[TemplateSyntaxError](../api/index#jinja2.TemplateSyntaxError \"jinja2.exceptions.TemplateSyntaxError\")*\\]*) –\n\nReturn type:  \nte.NoReturn\n\n`free_identifier(lineno=None)`  \nReturn a new free identifier as [`InternalName`](#jinja2.nodes.InternalName \"jinja2.nodes.InternalName\").\n\nParameters:  \n**lineno** ([int](https://docs.python.org/3/library/functions.html#int \"(in Python v3.11)\") *\\|* *None*) –\n\nReturn type:  \n[InternalName](#jinja2.nodes.InternalName \"jinja2.nodes.InternalName\")\n\n`parse_assign_target(with_tuple=True, name_only=False, extra_end_rules=None, with_namespace=False)`  \nParse an assignment target. As Jinja allows assignments to tuples, this function can parse all allowed assignment targets. Per default assignments to tuples are parsed, that can be disable however by setting `with_tuple` to `False`. If only assignments to names are wanted `name_only` can be set to `True`. The `extra_end_rules` parameter is forwarded to the tuple parsing function. If `with_namespace` is enabled, a namespace assignment may be parsed.\n\nParameters:  \n- **with_tuple** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **name_only** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **extra_end_rules** ([Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple \"(in Python v3.11)\")*\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")*,* *...\\]* *\\|* *None*) –\n- **with_namespace** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n\nReturn type:  \n[NSRef](#jinja2.nodes.NSRef \"jinja2.nodes.NSRef\") \\| [Name](#jinja2.nodes.Name \"jinja2.nodes.Name\") \\| [Tuple](#jinja2.nodes.Tuple \"jinja2.nodes.Tuple\")\n\n`parse_expression(with_condexpr=True)`  \nParse an expression. Per default all expressions are parsed, if the optional `with_condexpr` parameter is set to `False` conditional expressions are not parsed.\n\nParameters:  \n**with_condexpr** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n\nReturn type:  \n[Expr](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\n`parse_statements(end_tokens, drop_needle=False)`  \nParse multiple statements into a list until one of the end tokens is reached. This is used to parse the body of statements as it also parses template data if appropriate. The parser checks first if the current token is a colon and skips it if there is one. Then it checks for the block end and parses until if one of the `end_tokens` is reached. Per default the active token in the stream at the end of the call is the matched end token. If this is not wanted `drop_needle` can be set to `True` and the end token is removed.\n\nParameters:  \n- **end_tokens** ([Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple \"(in Python v3.11)\")*\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")*,* *...\\]*) –\n- **drop_needle** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n\nReturn type:  \n[List](https://docs.python.org/3/library/typing.html#typing.List \"(in Python v3.11)\")\\[[Node](#jinja2.nodes.Node \"jinja2.nodes.Node\")\\]\n\n`parse_tuple(simplified=False, with_condexpr=True, extra_end_rules=None, explicit_parentheses=False)`  \nWorks like `parse_expression` but if multiple expressions are delimited by a comma a [`Tuple`](#jinja2.nodes.Tuple \"jinja2.nodes.Tuple\") node is created. This method could also return a regular expression instead of a tuple if no commas where found.\n\nThe default parsing mode is a full tuple. If `simplified` is `True` only names and literals are parsed. The `no_condexpr` parameter is forwarded to [`parse_expression()`](#jinja2.parser.Parser.parse_expression \"jinja2.parser.Parser.parse_expression\").\n\nBecause tuples do not require delimiters and may end in a bogus comma an extra hint is needed that marks the end of a tuple. For example for loops support tuples between `for` and `in`. In that case the `extra_end_rules` is set to `['name:in']`.\n\n`explicit_parentheses` is true if the parsing was triggered by an expression in parentheses. This is used to figure out if an empty tuple is a valid expression or not.\n\nParameters:  \n- **simplified** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **with_condexpr** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **extra_end_rules** ([Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple \"(in Python v3.11)\")*\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")*,* *...\\]* *\\|* *None*) –\n- **explicit_parentheses** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n\nReturn type:  \n[Tuple](#jinja2.nodes.Tuple \"jinja2.nodes.Tuple\") \\| [Expr](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\n&nbsp;\n\n`class jinja2.lexer.TokenStream(generator, name, filename)`  \nA token stream is an iterable that yields [`Token`](#jinja2.lexer.Token \"jinja2.lexer.Token\")s. The parser however does not iterate over it but calls `next()` to go one token ahead. The current active token is stored as [`current`](#jinja2.lexer.TokenStream.current \"jinja2.lexer.TokenStream.current\").\n\nParameters:  \n- **generator** ([Iterable](https://docs.python.org/3/library/typing.html#typing.Iterable \"(in Python v3.11)\")*\\[*[Token](#jinja2.lexer.Token \"jinja2.lexer.Token\")*\\]*) –\n- **name** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n- **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n\n`current`  \nThe current [`Token`](#jinja2.lexer.Token \"jinja2.lexer.Token\").\n\n`__next__()`  \nGo one token ahead and return the old one.\n\nUse the built-in [`next()`](https://docs.python.org/3/library/functions.html#next \"(in Python v3.11)\") instead of calling this directly.\n\nReturn type:  \n[Token](#jinja2.lexer.Token \"jinja2.lexer.Token\")\n\n`property eos: bool`  \nAre we at the end of the stream?\n\n`expect(expr)`  \nExpect a given token type and return it. This accepts the same argument as [`jinja2.lexer.Token.test()`](#jinja2.lexer.Token.test \"jinja2.lexer.Token.test\").\n\nParameters:  \n**expr** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\nReturn type:  \n[Token](#jinja2.lexer.Token \"jinja2.lexer.Token\")\n\n`look()`  \nLook at the next token.\n\nReturn type:  \n[Token](#jinja2.lexer.Token \"jinja2.lexer.Token\")\n\n`next_if(expr)`  \nPerform the token test and return the token if it matched. Otherwise the return value is `None`.\n\nParameters:  \n**expr** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\nReturn type:  \n[Token](#jinja2.lexer.Token \"jinja2.lexer.Token\") \\| None\n\n`push(token)`  \nPush a token back to the stream.\n\nParameters:  \n**token** ([Token](#jinja2.lexer.Token \"jinja2.lexer.Token\")) –\n\nReturn type:  \nNone\n\n`skip(n=1)`  \nGot n tokens ahead.\n\nParameters:  \n**n** ([int](https://docs.python.org/3/library/functions.html#int \"(in Python v3.11)\")) –\n\nReturn type:  \nNone\n\n`skip_if(expr)`  \nLike [`next_if()`](#jinja2.lexer.TokenStream.next_if \"jinja2.lexer.TokenStream.next_if\") but only returns `True` or `False`.\n\nParameters:  \n**expr** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\nReturn type:  \n[bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")\n\n&nbsp;\n\n`class jinja2.lexer.Token(lineno, type, value)`  \nParameters:  \n- **lineno** ([int](https://docs.python.org/3/library/functions.html#int \"(in Python v3.11)\")) –\n- **type** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **value** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\n`lineno`  \nThe line number of the token\n\n`type`  \nThe type of the token. This string is interned so you may compare it with arbitrary strings using the `is` operator.\n\n`value`  \nThe value of the token.\n\n`test(expr)`  \nTest a token against a token expression. This can either be a token type or `'token_type:token_value'`. This can only test against string values and types.\n\nParameters:  \n**expr** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\nReturn type:  \n[bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")\n\n`test_any(*iterable)`  \nTest against multiple token expressions.\n\nParameters:  \n**iterable** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\nReturn type:  \n[bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")\n\nThere is also a utility function in the lexer module that can count newline characters in strings:\n\n`jinja2.lexer.count_newlines(value)`  \nCount the number of newline characters in the string. This is useful for extensions that filter a stream.\n\nParameters:  \n**value** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\nReturn type:  \n[int](https://docs.python.org/3/library/functions.html#int \"(in Python v3.11)\")\n\n### AST\n\nThe AST (Abstract Syntax Tree) is used to represent a template after parsing. It’s build of nodes that the compiler then converts into executable Python code objects. Extensions that provide custom statements can return nodes to execute custom Python code.\n\nThe list below describes all nodes that are currently available. The AST may change between Jinja versions but will stay backwards compatible.\n\nFor more information have a look at the repr of [`jinja2.Environment.parse()`](../api/index#jinja2.Environment.parse \"jinja2.Environment.parse\").\n\n`class jinja2.nodes.Node`  \nBaseclass for all Jinja nodes. There are a number of nodes available of different types. There are four major types:\n\n- [`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\"): statements\n- [`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\"): expressions\n- [`Helper`](#jinja2.nodes.Helper \"jinja2.nodes.Helper\"): helper nodes\n- [`Template`](#jinja2.nodes.Template \"jinja2.nodes.Template\"): the outermost wrapper node\n\nAll nodes have fields and attributes. Fields may be other nodes, lists, or arbitrary values. Fields are passed to the constructor as regular positional arguments, attributes as keyword arguments. Each node has two attributes: `lineno` (the line number of the node) and `environment`. The `environment` attribute is set at the end of the parsing process for all nodes automatically.\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n`find(node_type)`  \nFind the first node of a given type. If no such node exists the return value is `None`.\n\nParameters:  \n**node_type** ([Type](https://docs.python.org/3/library/typing.html#typing.Type \"(in Python v3.11)\")*\\[\\_NodeBound\\]*) –\n\nReturn type:  \n*\\_NodeBound* \\| None\n\n`find_all(node_type)`  \nFind all the nodes of a given type. If the type is a tuple, the check is performed for any of the tuple items.\n\nParameters:  \n**node_type** ([Type](https://docs.python.org/3/library/typing.html#typing.Type \"(in Python v3.11)\")*\\[\\_NodeBound\\]* *\\|* [Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple \"(in Python v3.11)\")*\\[*[Type](https://docs.python.org/3/library/typing.html#typing.Type \"(in Python v3.11)\")*\\[\\_NodeBound\\],* *...\\]*) –\n\nReturn type:  \n[Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator \"(in Python v3.11)\")\\[*\\_NodeBound*\\]\n\n`iter_child_nodes(exclude=None, only=None)`  \nIterates over all direct child nodes of the node. This iterates over all fields and yields the values of they are nodes. If the value of a field is a list all the nodes in that list are returned.\n\nParameters:  \n- **exclude** ([Container](https://docs.python.org/3/library/typing.html#typing.Container \"(in Python v3.11)\")*\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")*\\]* *\\|* *None*) –\n- **only** ([Container](https://docs.python.org/3/library/typing.html#typing.Container \"(in Python v3.11)\")*\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")*\\]* *\\|* *None*) –\n\nReturn type:  \n[Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator \"(in Python v3.11)\")\\[[Node](#jinja2.nodes.Node \"jinja2.nodes.Node\")\\]\n\n`iter_fields(exclude=None, only=None)`  \nThis method iterates over all fields that are defined and yields `(key, value)` tuples. Per default all fields are returned, but it’s possible to limit that to some fields by providing the `only` parameter or to exclude some using the `exclude` parameter. Both should be sets or tuples of field names.\n\nParameters:  \n- **exclude** ([Container](https://docs.python.org/3/library/typing.html#typing.Container \"(in Python v3.11)\")*\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")*\\]* *\\|* *None*) –\n- **only** ([Container](https://docs.python.org/3/library/typing.html#typing.Container \"(in Python v3.11)\")*\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")*\\]* *\\|* *None*) –\n\nReturn type:  \n[Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator \"(in Python v3.11)\")\\[[Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple \"(in Python v3.11)\")\\[[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\"), [Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")\\]\\]\n\n`set_ctx(ctx)`  \nReset the context of a node and all child nodes. Per default the parser will all generate nodes that have a ‘load’ context as it’s the most common one. This method is used in the parser to set assignment targets and other nodes to a store context.\n\nParameters:  \n**ctx** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\nReturn type:  \n[Node](#jinja2.nodes.Node \"jinja2.nodes.Node\")\n\n`set_environment(environment)`  \nSet the environment for all nodes.\n\nParameters:  \n**environment** ([Environment](../api/index#jinja2.Environment \"jinja2.Environment\")) –\n\nReturn type:  \n[Node](#jinja2.nodes.Node \"jinja2.nodes.Node\")\n\n`set_lineno(lineno, override=False)`  \nSet the line numbers of the node and children.\n\nParameters:  \n- **lineno** ([int](https://docs.python.org/3/library/functions.html#int \"(in Python v3.11)\")) –\n- **override** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n\nReturn type:  \n[Node](#jinja2.nodes.Node \"jinja2.nodes.Node\")\n\n&nbsp;\n\n`class jinja2.nodes.Expr`  \nBaseclass for all expressions.\n\nNode type:  \n[`Node`](#jinja2.nodes.Node \"jinja2.nodes.Node\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n`as_const(eval_ctx=None)`  \nReturn the value of the expression as constant or raise [`Impossible`](#jinja2.nodes.Impossible \"jinja2.nodes.Impossible\") if this was not possible.\n\nAn [`EvalContext`](../api/index#jinja2.nodes.EvalContext \"jinja2.nodes.EvalContext\") can be provided, if none is given a default context is created which requires the nodes to have an attached environment.\n\nChangelog\n\nChanged in version 2.4: the `eval_ctx` parameter was added.\n\nParameters:  \n**eval_ctx** ([EvalContext](../api/index#jinja2.nodes.EvalContext \"jinja2.nodes.EvalContext\") *\\|* *None*) –\n\nReturn type:  \n[Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")\n\n`can_assign()`  \nCheck if it’s possible to assign something to this node.\n\nReturn type:  \n[bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")\n\n&nbsp;\n\n`class jinja2.nodes._FilterTestCommon(node, name, args, kwargs, dyn_args, dyn_kwargs)`  \nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Filter(node, name, args, kwargs, dyn_args, dyn_kwargs)`  \nApply a filter to an expression. `name` is the name of the filter, the other fields are the same as [`Call`](#jinja2.nodes.Call \"jinja2.nodes.Call\").\n\nIf `node` is `None`, the filter is being used in a filter block and is applied to the content of the block.\n\nNode type:  \n[`_FilterTestCommon`](#jinja2.nodes._FilterTestCommon \"jinja2.nodes._FilterTestCommon\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Test(node, name, args, kwargs, dyn_args, dyn_kwargs)`  \nApply a test to an expression. `name` is the name of the test, the other field are the same as [`Call`](#jinja2.nodes.Call \"jinja2.nodes.Call\").\n\nChangelog\n\nChanged in version 3.0: `as_const` shares the same logic for filters and tests. Tests check for volatile, async, and `@pass_context` etc. decorators.\n\nNode type:  \n[`_FilterTestCommon`](#jinja2.nodes._FilterTestCommon \"jinja2.nodes._FilterTestCommon\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.BinExpr(left, right)`  \nBaseclass for all binary expressions.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Add(left, right)`  \nAdd the left to the right node.\n\nNode type:  \n[`BinExpr`](#jinja2.nodes.BinExpr \"jinja2.nodes.BinExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.And(left, right)`  \nShort circuited AND.\n\nNode type:  \n[`BinExpr`](#jinja2.nodes.BinExpr \"jinja2.nodes.BinExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Div(left, right)`  \nDivides the left by the right node.\n\nNode type:  \n[`BinExpr`](#jinja2.nodes.BinExpr \"jinja2.nodes.BinExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.FloorDiv(left, right)`  \nDivides the left by the right node and converts the result into an integer by truncating.\n\nNode type:  \n[`BinExpr`](#jinja2.nodes.BinExpr \"jinja2.nodes.BinExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Mod(left, right)`  \nLeft modulo right.\n\nNode type:  \n[`BinExpr`](#jinja2.nodes.BinExpr \"jinja2.nodes.BinExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Mul(left, right)`  \nMultiplies the left with the right node.\n\nNode type:  \n[`BinExpr`](#jinja2.nodes.BinExpr \"jinja2.nodes.BinExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Or(left, right)`  \nShort circuited OR.\n\nNode type:  \n[`BinExpr`](#jinja2.nodes.BinExpr \"jinja2.nodes.BinExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Pow(left, right)`  \nLeft to the power of right.\n\nNode type:  \n[`BinExpr`](#jinja2.nodes.BinExpr \"jinja2.nodes.BinExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Sub(left, right)`  \nSubtract the right from the left node.\n\nNode type:  \n[`BinExpr`](#jinja2.nodes.BinExpr \"jinja2.nodes.BinExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Call(node, args, kwargs, dyn_args, dyn_kwargs)`  \nCalls an expression. `args` is a list of arguments, `kwargs` a list of keyword arguments (list of [`Keyword`](#jinja2.nodes.Keyword \"jinja2.nodes.Keyword\") nodes), and `dyn_args` and `dyn_kwargs` has to be either `None` or a node that is used as node for dynamic positional (`*args`) or keyword (`**kwargs`) arguments.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Compare(expr, ops)`  \nCompares an expression with some other expressions. `ops` must be a list of [`Operand`](#jinja2.nodes.Operand \"jinja2.nodes.Operand\")s.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Concat(nodes)`  \nConcatenates the list of expressions provided after converting them to strings.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.CondExpr(test, expr1, expr2)`  \nA conditional expression (inline if expression). (`{{ foo if bar else baz }}`)\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.ContextReference`  \nReturns the current template context. It can be used like a [`Name`](#jinja2.nodes.Name \"jinja2.nodes.Name\") node, with a `'load'` ctx and will return the current [`Context`](../api/index#jinja2.runtime.Context \"jinja2.runtime.Context\") object.\n\nHere an example that assigns the current template name to a variable named `foo`:\n\n``` python\nAssign(Name('foo', ctx='store'),\n       Getattr(ContextReference(), 'name'))\n```\n\nThis is basically equivalent to using the [`pass_context()`](../api/index#jinja2.pass_context \"jinja2.pass_context\") decorator when using the high-level API, which causes a reference to the context to be passed as the first argument to a function.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.DerivedContextReference`  \nReturn the current template context including locals. Behaves exactly like [`ContextReference`](#jinja2.nodes.ContextReference \"jinja2.nodes.ContextReference\"), but includes local variables, such as from a `for` loop.\n\nChangelog\n\nNew in version 2.11.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.EnvironmentAttribute(name)`  \nLoads an attribute from the environment object. This is useful for extensions that want to call a callback stored on the environment.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.ExtensionAttribute(identifier, name)`  \nReturns the attribute of an extension bound to the environment. The identifier is the identifier of the `Extension`.\n\nThis node is usually constructed by calling the [`attr()`](#jinja2.ext.Extension.attr \"jinja2.ext.Extension.attr\") method on an extension.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Getattr(node, attr, ctx)`  \nGet an attribute or item from an expression that is a ascii-only bytestring and prefer the attribute.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Getitem(node, arg, ctx)`  \nGet an attribute or item from an expression and prefer the item.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.ImportedName(importname)`  \nIf created with an import name the import name is returned on node access. For example `ImportedName('cgi.escape')` returns the `escape` function from the cgi module on evaluation. Imports are optimized by the compiler so there is no need to assign them to local variables.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.InternalName(name)`  \nAn internal name in the compiler. You cannot create these nodes yourself but the parser provides a [`free_identifier()`](#jinja2.parser.Parser.free_identifier \"jinja2.parser.Parser.free_identifier\") method that creates a new identifier for you. This identifier is not available from the template and is not treated specially by the compiler.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\n&nbsp;\n\n`class jinja2.nodes.Literal`  \nBaseclass for literals.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Const(value)`  \nAll constant values. The parser will return this node for simple constants such as `42` or `\"foo\"` but it can be used to store more complex values such as lists too. Only constants with a safe representation (objects where `eval(repr(x)) == x` is true).\n\nNode type:  \n[`Literal`](#jinja2.nodes.Literal \"jinja2.nodes.Literal\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Dict(items)`  \nAny dict literal such as `{1: 2, 3: 4}`. The items must be a list of [`Pair`](#jinja2.nodes.Pair \"jinja2.nodes.Pair\") nodes.\n\nNode type:  \n[`Literal`](#jinja2.nodes.Literal \"jinja2.nodes.Literal\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.List(items)`  \nAny list literal such as `[1, 2, 3]`\n\nNode type:  \n[`Literal`](#jinja2.nodes.Literal \"jinja2.nodes.Literal\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.TemplateData(data)`  \nA constant template string.\n\nNode type:  \n[`Literal`](#jinja2.nodes.Literal \"jinja2.nodes.Literal\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Tuple(items, ctx)`  \nFor loop unpacking and some other things like multiple arguments for subscripts. Like for [`Name`](#jinja2.nodes.Name \"jinja2.nodes.Name\") `ctx` specifies if the tuple is used for loading the names or storing.\n\nNode type:  \n[`Literal`](#jinja2.nodes.Literal \"jinja2.nodes.Literal\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.MarkSafe(expr)`  \nMark the wrapped expression as safe (wrap it as `Markup`).\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.MarkSafeIfAutoescape(expr)`  \nMark the wrapped expression as safe (wrap it as `Markup`) but only if autoescaping is active.\n\nChangelog\n\nNew in version 2.5.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Name(name, ctx)`  \nLooks up a name or stores a value in a name. The `ctx` of the node can be one of the following values:\n\n- `store`: store a value in the name\n- `load`: load that name\n- `param`: like `store` but if the name was defined as function parameter.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.NSRef(name, attr)`  \nReference to a namespace value assignment\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Slice(start, stop, step)`  \nRepresents a slice object. This must only be used as argument for `Subscript`.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.UnaryExpr(node)`  \nBaseclass for all unary expressions.\n\nNode type:  \n[`Expr`](#jinja2.nodes.Expr \"jinja2.nodes.Expr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Neg(node)`  \nMake the expression negative.\n\nNode type:  \n[`UnaryExpr`](#jinja2.nodes.UnaryExpr \"jinja2.nodes.UnaryExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Not(node)`  \nNegate the expression.\n\nNode type:  \n[`UnaryExpr`](#jinja2.nodes.UnaryExpr \"jinja2.nodes.UnaryExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Pos(node)`  \nMake the expression positive (noop for most expressions)\n\nNode type:  \n[`UnaryExpr`](#jinja2.nodes.UnaryExpr \"jinja2.nodes.UnaryExpr\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Helper`  \nNodes that exist in a specific context only.\n\nNode type:  \n[`Node`](#jinja2.nodes.Node \"jinja2.nodes.Node\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Keyword(key, value)`  \nA key, value pair for keyword arguments where key is a string.\n\nNode type:  \n[`Helper`](#jinja2.nodes.Helper \"jinja2.nodes.Helper\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Operand(op, expr)`  \nHolds an operator and an expression.\n\nNode type:  \n[`Helper`](#jinja2.nodes.Helper \"jinja2.nodes.Helper\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Pair(key, value)`  \nA key, value pair for dicts.\n\nNode type:  \n[`Helper`](#jinja2.nodes.Helper \"jinja2.nodes.Helper\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Stmt`  \nBase node for all statements.\n\nNode type:  \n[`Node`](#jinja2.nodes.Node \"jinja2.nodes.Node\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Assign(target, node)`  \nAssigns an expression to a target.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.AssignBlock(target, filter, body)`  \nAssigns a block to a target.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Block(name, body, scoped, required)`  \nA node that represents a block.\n\nChangelog\n\nChanged in version 3.0.0: the `required` field was added.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Break`  \nBreak a loop.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.CallBlock(call, args, defaults, body)`  \nLike a macro without a name but a call instead. `call` is called with the unnamed macro as `caller` argument this node holds.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Continue`  \nContinue a loop.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.EvalContextModifier(options)`  \nModifies the eval context. For each option that should be modified, a [`Keyword`](#jinja2.nodes.Keyword \"jinja2.nodes.Keyword\") has to be added to the `options` list.\n\nExample to change the `autoescape` setting:\n\n``` python\nEvalContextModifier(options=[Keyword('autoescape', Const(True))])\n```\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.ScopedEvalContextModifier(options, body)`  \nModifies the eval context and reverts it later. Works exactly like [`EvalContextModifier`](#jinja2.nodes.EvalContextModifier \"jinja2.nodes.EvalContextModifier\") but will only modify the [`EvalContext`](../api/index#jinja2.nodes.EvalContext \"jinja2.nodes.EvalContext\") for nodes in the `body`.\n\nNode type:  \n[`EvalContextModifier`](#jinja2.nodes.EvalContextModifier \"jinja2.nodes.EvalContextModifier\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.ExprStmt(node)`  \nA statement that evaluates an expression and discards the result.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Extends(template)`  \nRepresents an extends statement.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.FilterBlock(body, filter)`  \nNode for filter sections.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.For(target, iter, body, else_, test, recursive)`  \nThe for loop. `target` is the target for the iteration (usually a [`Name`](#jinja2.nodes.Name \"jinja2.nodes.Name\") or [`Tuple`](#jinja2.nodes.Tuple \"jinja2.nodes.Tuple\")), `iter` the iterable. `body` is a list of nodes that are used as loop-body, and `else_` a list of nodes for the `else` block. If no else node exists it has to be an empty list.\n\nFor filtered nodes an expression can be stored as `test`, otherwise `None`.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.FromImport(template, names, with_context)`  \nA node that represents the from import tag. It’s important to not pass unsafe names to the name attribute. The compiler translates the attribute lookups directly into getattr calls and does *not* use the subscript callback of the interface. As exported variables may not start with double underscores (which the parser asserts) this is not a problem for regular Jinja code, but if this node is used in an extension extra care must be taken.\n\nThe list of names may contain tuples if aliases are wanted.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.If(test, body, elif_, else_)`  \nIf `test` is true, `body` is rendered, else `else_`.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Import(template, target, with_context)`  \nA node that represents the import tag.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Include(template, with_context, ignore_missing)`  \nA node that represents the include tag.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Macro(name, args, defaults, body)`  \nA macro definition. `name` is the name of the macro, `args` a list of arguments and `defaults` a list of defaults if there are any. `body` is a list of nodes for the macro body.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Output(nodes)`  \nA node that holds multiple expressions which are then printed out. This is used both for the `print` statement and the regular template data.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.OverlayScope(context, body)`  \nAn overlay scope for extensions. This is a largely unoptimized scope that however can be used to introduce completely arbitrary variables into a sub scope from a dictionary or dictionary like object. The `context` field has to evaluate to a dictionary object.\n\nExample usage:\n\n``` python\nOverlayScope(context=self.call_method('get_context'),\n             body=[...])\n```\n\nChangelog\n\nNew in version 2.10.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Scope(body)`  \nAn artificial scope.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.With(targets, values, body)`  \nSpecific node for with statements. In older versions of Jinja the with statement was implemented on the base of the `Scope` node instead.\n\nChangelog\n\nNew in version 2.9.3.\n\nNode type:  \n[`Stmt`](#jinja2.nodes.Stmt \"jinja2.nodes.Stmt\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`class jinja2.nodes.Template(body)`  \nNode that represents a template. This must be the outermost node that is passed to the compiler.\n\nNode type:  \n[`Node`](#jinja2.nodes.Node \"jinja2.nodes.Node\")\n\nParameters:  \n- **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`exception jinja2.nodes.Impossible`  \nRaised if the node could not perform a requested action.\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/extensions/](https://jinja.palletsprojects.com/en/3.1.x/extensions/)"
- name: false()
  id: templates/index#jinja-tests.false
  summary: Return true if the object is False
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.false(value: Any) → bool`

    Return true if the object is False.

    Changelog

    New in version 2.11.
- name: filesizeformat()
  id: templates/index#jinja-filters.filesizeformat
  summary: Format the value like a ‘human-readable’ file size (i.e
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.filesizeformat(value: str | float | int, binary: bool = False) → str`

    Format the value like a ‘human-readable’ file size (i.e. 13 kB, 4.1 MB, 102 Bytes, etc). Per default decimal prefixes are used (Mega, Giga, etc.), if the second parameter is set to `True` the binary prefixes are used (Mebi, Gibi).
- name: FileSystemBytecodeCache
  id: api/index#jinja2.FileSystemBytecodeCache
  summary: A bytecode cache that stores bytecode on the filesystem
  description: |-
    `class jinja2.FileSystemBytecodeCache(directory=None, pattern='__jinja2_%s.cache')`

    A bytecode cache that stores bytecode on the filesystem. It accepts two arguments: The directory where the cache items are stored and a pattern string that is used to build the filename.

    If no directory is specified a default cache directory is selected. On Windows the user’s temp directory is used, on UNIX systems a directory is created for the user in the system temp directory.

    The pattern can be used to have multiple separate caches operate on the same directory. The default pattern is `'__jinja2_%s.cache'`. `%s` is replaced with the cache key.

    ``` python
    >>> bcc = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')
    ```

    This bytecode cache supports clearing of the cache using the clear method.

    Parameters:

    - **directory** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **pattern** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
- name: FileSystemLoader
  id: api/index#jinja2.FileSystemLoader
  summary: Load templates from a directory in the file system
  description: |-
    `class jinja2.FileSystemLoader(searchpath, encoding='utf-8', followlinks=False)`

    Load templates from a directory in the file system.

    The path can be relative or absolute. Relative paths are relative to the current working directory.

    ``` python
    loader = FileSystemLoader("templates")
    ```

    A list of paths can be given. The directories will be searched in order, stopping at the first matching template.

    ``` python
    loader = FileSystemLoader(["/override/templates", "/default/templates"])
    ```

    Parameters:

    - **searchpath** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") *\|* [Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)")*\]*) – A path, or list of paths, to the directory that contains the templates.
    - **encoding** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Use this encoding to read the text from template files.
    - **followlinks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Follow symbolic links in the path.

    Changelog

    Changed in version 2.8: Added the `followlinks` parameter.
- name: Filter
  id: extensions/index#jinja2.nodes.Filter
  summary: Apply a filter to an expression
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Filter(node, name, args, kwargs, dyn_args, dyn_kwargs)`

    Apply a filter to an expression. `name` is the name of the filter, the other fields are the same as [`Call`](#jinja2.nodes.Call "jinja2.nodes.Call").

    If `node` is `None`, the filter is being used in a filter block and is applied to the content of the block.

    Node type:

    [`_FilterTestCommon`](#jinja2.nodes._FilterTestCommon "jinja2.nodes._FilterTestCommon")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: filter()
  id: templates/index#jinja-tests.filter
  summary: Check if a filter exists by name
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.filter(value: str) → bool`

    Check if a filter exists by name. Useful if a filter may be optionally available.

    ``` jinja
    {% if 'markdown' is filter %}
        {{ value | markdown }}
    {% else %}
        {{ value }}
    {% endif %}
    ```

    Changelog

    New in version 3.0.
- name: FilterBlock
  id: extensions/index#jinja2.nodes.FilterBlock
  summary: Node for filter sections
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.FilterBlock(body, filter)`

    Node for filter sections.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: find_referenced_templates()
  id: api/index#jinja2.meta.find_referenced_templates
  summary: Finds all the referenced templates from the AST
  description: "`jinja2.meta.find_referenced_templates(ast)`\n\nFinds all the referenced templates from the AST. This will return an iterator over all the hardcoded template extensions, inclusions and imports. If dynamic inheritance or inclusion is used, `None` will be yielded.\n\n``` python\n>>> from jinja2 import Environment, meta\n>>> env = Environment()\n>>> ast = env.parse('{% extends \"layout.html\" %}{% include helper %}')\n>>> list(meta.find_referenced_templates(ast))\n['layout.html', None]\n```\n\nThis function is useful for dependency tracking. For example if you want to rebuild parts of the website after a layout template has changed.\n\nParameters:\n\n**ast** ([Template](../extensions/index#jinja2.nodes.Template \"jinja2.nodes.Template\")) –\n\nReturn type:\n\n[Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator \"(in Python v3.11)\")\\[[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") \\| None\\]\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/api/](https://jinja.palletsprojects.com/en/3.1.x/api/)"
- name: find_undeclared_variables()
  id: api/index#jinja2.meta.find_undeclared_variables
  summary: Returns a set of all variables in the AST that will be looked up from the context at runtime
  description: |-
    `jinja2.meta.find_undeclared_variables(ast)`

    Returns a set of all variables in the AST that will be looked up from the context at runtime. Because at compile time it’s not known which variables will be used depending on the path the execution takes at runtime, all variables are returned.

    ``` python
    >>> from jinja2 import Environment, meta
    >>> env = Environment()
    >>> ast = env.parse('{% set foo = 42 %}{{ bar + foo }}')
    >>> meta.find_undeclared_variables(ast) == {'bar'}
    True
    ```

    Implementation

    Internally the code generator is used for finding undeclared variables. This is good to know because the code generator might raise a `TemplateAssertionError` during compilation and as a matter of fact this function can currently raise that exception as well.

    Parameters:

    **ast** ([Template](../extensions/index#jinja2.nodes.Template "jinja2.nodes.Template")) –

    Return type:

    [Set](https://docs.python.org/3/library/typing.html#typing.Set "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\]
- name: first()
  id: templates/index#jinja-filters.first
  summary: Return the first item of a sequence
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.first(seq: 't.Iterable[V]') → 't.Union[V, Undefined]'`

    Return the first item of a sequence.
- name: float()
  id: templates/index#jinja-tests.float
  summary: Return true if the object is a float
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.float(value: Any) → bool`

    Return true if the object is a float.

    Changelog

    New in version 2.11.
- name: float()
  id: templates/index#jinja-filters.float
  summary: Convert the value into a floating point number
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.float(value: Any, default: float = 0.0) → float`

    Convert the value into a floating point number. If the conversion doesn’t work it will return `0.0`. You can override this default using the first parameter.
- name: FloorDiv
  id: extensions/index#jinja2.nodes.FloorDiv
  summary: Divides the left by the right node and converts the result into an integer by truncating
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.FloorDiv(left, right)`

    Divides the left by the right node and converts the result into an integer by truncating.

    Node type:

    [`BinExpr`](#jinja2.nodes.BinExpr "jinja2.nodes.BinExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: For
  id: extensions/index#jinja2.nodes.For
  summary: The for loop
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.For(target, iter, body, else_, test, recursive)`

    The for loop. `target` is the target for the iteration (usually a [`Name`](#jinja2.nodes.Name "jinja2.nodes.Name") or [`Tuple`](#jinja2.nodes.Tuple "jinja2.nodes.Tuple")), `iter` the iterable. `body` is a list of nodes that are used as loop-body, and `else_` a list of nodes for the `else` block. If no else node exists it has to be an empty list.

    For filtered nodes an expression can be stored as `test`, otherwise `None`.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: forceescape()
  id: templates/index#jinja-filters.forceescape
  summary: Enforce HTML escaping
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.forceescape(value: 't.Union[str, HasHTML]') → markupsafe.Markup`

    Enforce HTML escaping. This will probably double escape variables.
- name: format()
  id: templates/index#jinja-filters.format
  summary: Apply the given values to a printf-style format string, like string % values
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.format(value: str, *args: Any, **kwargs: Any) → str`

    Apply the given values to a [printf-style](https://docs.python.org/library/stdtypes.html#printf-style-string-formatting) format string, like `string % values`.

    ``` jinja
    {{ "%s, %s!"|format(greeting, name) }}
    Hello, World!
    ```

    In most cases it should be more convenient and efficient to use the `%` operator or [`str.format()`](https://docs.python.org/3/library/stdtypes.html#str.format "(in Python v3.11)").

    ``` text
    {{ "%s, %s!" % (greeting, name) }}
    {{ "{}, {}!".format(greeting, name) }}
    ```
- name: FromImport
  id: extensions/index#jinja2.nodes.FromImport
  summary: A node that represents the from import tag
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.FromImport(template, names, with_context)`

    A node that represents the from import tag. It’s important to not pass unsafe names to the name attribute. The compiler translates the attribute lookups directly into getattr calls and does *not* use the subscript callback of the interface. As exported variables may not start with double underscores (which the parser asserts) this is not a problem for regular Jinja code, but if this node is used in an extension extra care must be taken.

    The list of names may contain tuples if aliases are wanted.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: FunctionLoader
  id: api/index#jinja2.FunctionLoader
  summary: A loader that is passed a function which does the loading
  description: |-
    `class jinja2.FunctionLoader(load_func)`

    A loader that is passed a function which does the loading. The function receives the name of the template and has to return either a string with the template source, a tuple in the form `(source, filename, uptodatefunc)` or `None` if the template does not exist.

    ``` python
    >>> def load_template(name):
    ...     if name == 'index.html':
    ...         return '...'
    ...
    >>> loader = FunctionLoader(load_template)
    ```

    The `uptodatefunc` is a function that is called if autoreload is enabled and has to return `True` if the template is still up to date. For more details have a look at [`BaseLoader.get_source()`](#jinja2.BaseLoader.get_source "jinja2.BaseLoader.get_source") which has the same return value.

    Parameters:

    **load_func** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\],* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None,* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[\],* [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")*\]* *\|* *None\]* *\|* *None\]*) –
- name: ge()
  id: templates/index#jinja-tests.ge
  summary: Same as a >= b
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.ge(a, b, /)`

    Same as a \>= b.

    Aliases:

    `>=`
- name: Getattr
  id: extensions/index#jinja2.nodes.Getattr
  summary: Get an attribute or item from an expression that is a ascii-only bytestring and prefer the attribute
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Getattr(node, attr, ctx)`

    Get an attribute or item from an expression that is a ascii-only bytestring and prefer the attribute.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Getitem
  id: extensions/index#jinja2.nodes.Getitem
  summary: Get an attribute or item from an expression and prefer the item
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Getitem(node, arg, ctx)`

    Get an attribute or item from an expression and prefer the item.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: groupby()
  id: templates/index#jinja-filters.groupby
  summary: Group a sequence of objects by an attribute using Python’s itertools.groupby()
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.groupby(value: 't.Iterable[V]', attribute: str | int, default: Any | None = None, case_sensitive: bool = False) → 't.List[_GroupTuple]'`

    Group a sequence of objects by an attribute using Python’s [`itertools.groupby()`](https://docs.python.org/3/library/itertools.html#itertools.groupby "(in Python v3.11)"). The attribute can use dot notation for nested access, like `"address.city"`. Unlike Python’s `groupby`, the values are sorted first so only one group is returned for each unique value.

    For example, a list of `User` objects with a `city` attribute can be rendered in groups. In this example, `grouper` refers to the `city` value of the group.

    ``` html+jinja
    <ul>{% for city, items in users|groupby("city") %}
      <li>{{ city }}
        <ul>{% for user in items %}
          <li>{{ user.name }}
        {% endfor %}</ul>
      </li>
    {% endfor %}</ul>
    ```

    `groupby` yields namedtuples of `(grouper, list)`, which can be used instead of the tuple unpacking above. `grouper` is the value of the attribute, and `list` is the items with that value.

    ``` html+jinja
    <ul>{% for group in users|groupby("city") %}
      <li>{{ group.grouper }}: {{ group.list|join(", ") }}
    {% endfor %}</ul>
    ```

    You can specify a `default` value to use if an object in the list does not have the given attribute.

    ``` jinja
    <ul>{% for city, items in users|groupby("city", default="NY") %}
      <li>{{ city }}: {{ items|map(attribute="name")|join(", ") }}</li>
    {% endfor %}</ul>
    ```

    Like the [`sort()`](#jinja-filters.sort "jinja-filters.sort") filter, sorting and grouping is case-insensitive by default. The `key` for each group will have the case of the first item in that group of values. For example, if a list of users has cities `["CA", "NY", "ca"]`, the “CA” group will have two values. This can be disabled by passing `case_sensitive=True`.

    Changed in version 3.1: Added the `case_sensitive` parameter. Sorting and grouping is case-insensitive by default, matching other filters that do comparisons.

    Changelog

    Changed in version 3.0: Added the `default` parameter.

    Changed in version 2.6: The attribute supports dot notation for nested access.
- name: gt()
  id: templates/index#jinja-tests.gt
  summary: Same as a > b
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.gt(a, b, /)`

    Same as a \> b.

    Aliases:

    `>`, `greaterthan`
- name: Helper
  id: extensions/index#jinja2.nodes.Helper
  summary: Nodes that exist in a specific context only
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Helper`

    Nodes that exist in a specific context only.

    Node type:

    [`Node`](#jinja2.nodes.Node "jinja2.nodes.Node")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: If
  id: extensions/index#jinja2.nodes.If
  summary: null
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.If(test, body, elif_, else_)`

    If `test` is true, `body` is rendered, else `else_`.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: ImmutableSandboxedEnvironment
  id: sandbox/index#jinja2.sandbox.ImmutableSandboxedEnvironment
  summary: Works exactly like the regular SandboxedEnvironment but does not permit modifications on the builtin mutable objects list, set, and dict by using the modifies_known_mutable() function
  belongs_to: Sandbox
  description: |-
    `class jinja2.sandbox.ImmutableSandboxedEnvironment([options])`

    Works exactly like the regular `SandboxedEnvironment` but does not permit modifications on the builtin mutable objects `list`, `set`, and `dict` by using the [`modifies_known_mutable()`](#jinja2.sandbox.modifies_known_mutable "jinja2.sandbox.modifies_known_mutable") function.

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Import
  id: extensions/index#jinja2.nodes.Import
  summary: A node that represents the import tag
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Import(template, target, with_context)`

    A node that represents the import tag.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: ImportedName
  id: extensions/index#jinja2.nodes.ImportedName
  summary: If created with an import name the import name is returned on node access
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.ImportedName(importname)`

    If created with an import name the import name is returned on node access. For example `ImportedName('cgi.escape')` returns the `escape` function from the cgi module on evaluation. Imports are optimized by the compiler so there is no need to assign them to local variables.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Impossible
  id: extensions/index#jinja2.nodes.Impossible
  summary: Raised if the node could not perform a requested action
  belongs_to: Extensions
  description: "`exception jinja2.nodes.Impossible`\n\nRaised if the node could not perform a requested action.\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/extensions/](https://jinja.palletsprojects.com/en/3.1.x/extensions/)"
- name: in()
  id: templates/index#jinja-tests.in
  summary: Check if value is in seq
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.in(value: Any, seq: Container) → bool`

    Check if value is in seq.

    Changelog

    New in version 2.10.
- name: Include
  id: extensions/index#jinja2.nodes.Include
  summary: A node that represents the include tag
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Include(template, with_context, ignore_missing)`

    A node that represents the include tag.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: indent()
  id: templates/index#jinja-filters.indent
  summary: Return a copy of the string with each line indented by 4 spaces
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.indent(s: str, width: int | str = 4, first: bool = False, blank: bool = False) → str`

    Return a copy of the string with each line indented by 4 spaces. The first line and blank lines are not indented by default.

    Parameters:

    - **width** – Number of spaces, or a string, to indent by.
    - **first** – Don’t skip indenting the first line.
    - **blank** – Don’t skip indenting empty lines.

    Changelog

    Changed in version 3.0: `width` can be a string.

    Changed in version 2.10: Blank lines are not indented by default.

    Rename the `indentfirst` argument to `first`.
- name: int()
  id: templates/index#jinja-filters.int
  summary: Convert the value into an integer
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.int(value: Any, default: int = 0, base: int = 10) → int`

    Convert the value into an integer. If the conversion doesn’t work it will return `0`. You can override this default using the first parameter. You can also override the default base (10) in the second parameter, which handles input with prefixes such as 0b, 0o and 0x for bases 2, 8 and 16 respectively. The base is ignored for decimal numbers and non-string values.
- name: integer()
  id: templates/index#jinja-tests.integer
  summary: Return true if the object is an integer
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.integer(value: Any) → bool`

    Return true if the object is an integer.

    Changelog

    New in version 2.11.
- name: InternalName
  id: extensions/index#jinja2.nodes.InternalName
  summary: An internal name in the compiler
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.InternalName(name)`

    An internal name in the compiler. You cannot create these nodes yourself but the parser provides a [`free_identifier()`](#jinja2.parser.Parser.free_identifier "jinja2.parser.Parser.free_identifier") method that creates a new identifier for you. This identifier is not available from the template and is not treated specially by the compiler.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")
- name: Introduction
  id: intro/index
  summary: Jinja is a fast, expressive, extensible templating engine
  description: "# Introduction\n\nJinja is a fast, expressive, extensible templating engine. Special placeholders in the template allow writing code similar to Python syntax. Then the template is passed data to render the final document.\n\nIt includes:\n\n- Template inheritance and inclusion.\n- Define and import macros within templates.\n- HTML templates can use autoescaping to prevent XSS from untrusted user input.\n- A sandboxed environment can safely render untrusted templates.\n- Async support for generating templates that automatically handle sync and async functions without extra syntax.\n- I18N support with Babel.\n- Templates are compiled to optimized Python code just-in-time and cached, or can be compiled ahead-of-time.\n- Exceptions point to the correct line in templates to make debugging easier.\n- Extensible filters, tests, functions, and even syntax.\n\nJinja’s philosophy is that while application logic belongs in Python if possible, it shouldn’t make the template designer’s job difficult by restricting functionality too much.\n\n## Installation\n\nWe recommend using the latest version of Python. Jinja supports Python 3.7 and newer. We also recommend using a [virtual environment](https://packaging.python.org/tutorials/installing-packages/#creating-virtual-environments) in order to isolate your project dependencies from other projects and the system.\n\nInstall the most recent Jinja version using pip:\n\n``` text\n$ pip install Jinja2\n```\n\n### Dependencies\n\nThese will be installed automatically when installing Jinja.\n\n- [MarkupSafe](https://markupsafe.palletsprojects.com/) escapes untrusted input when rendering templates to avoid injection attacks.\n\n### Optional Dependencies\n\nThese distributions will not be installed automatically.\n\n- [Babel](https://babel.pocoo.org/) provides translation support in templates.\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/intro/](https://jinja.palletsprojects.com/en/3.1.x/intro/)"
- name: is_internal_attribute()
  id: sandbox/index#jinja2.sandbox.is_internal_attribute
  summary: Test if the attribute given is an internal python attribute
  belongs_to: Sandbox
  description: |-
    `jinja2.sandbox.is_internal_attribute(obj, attr)`

    Test if the attribute given is an internal python attribute. For example this function returns `True` for the `func_code` attribute of python objects. This is useful if the environment method [`is_safe_attribute()`](#jinja2.sandbox.SandboxedEnvironment.is_safe_attribute "jinja2.sandbox.SandboxedEnvironment.is_safe_attribute") is overridden.

    ``` python
    >>> from jinja2.sandbox import is_internal_attribute
    >>> is_internal_attribute(str, "mro")
    True
    >>> is_internal_attribute(str, "upper")
    False
    ```

    Parameters:

    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attr** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: is_undefined()
  id: api/index#jinja2.is_undefined
  summary: Check if the object passed is undefined
  description: |-
    `jinja2.is_undefined(obj)`

    Check if the object passed is undefined. This does nothing more than performing an instance check against [`Undefined`](#jinja2.Undefined "jinja2.Undefined") but looks nicer. This can be used for custom filters or tests that want to react to undefined variables. For example a custom default filter can look like this:

    ``` python
    def default(var, default=''):
        if is_undefined(var):
            return default
        return var
    ```

    Parameters:

    **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")

    ## Exceptions
- name: items()
  id: templates/index#jinja-filters.items
  summary: Return an iterator over the (key, value) items of a mapping
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.items(value: Mapping[K, V] | jinja2.runtime.Undefined) → Iterator[Tuple[K, V]]`

    Return an iterator over the `(key, value)` items of a mapping.

    `x|items` is the same as `x.items()`, except if `x` is undefined an empty iterator is returned.

    This filter is useful if you expect the template to be rendered with an implementation of Jinja in another programming language that does not have a `.items()` method on its mapping type.

    ``` html+jinja
    <dl>
    {% for key, value in my_dict|items %}
        <dt>{{ key }}
        <dd>{{ value }}
    {% endfor %}
    </dl>
    ```

    New in version 3.1.
- name: iterable()
  id: templates/index#jinja-tests.iterable
  summary: Check if it’s possible to iterate over an object
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.iterable(value: Any) → bool`

    Check if it’s possible to iterate over an object.
- name: join()
  id: templates/index#jinja-filters.join
  summary: Return a string which is the concatenation of the strings in the sequence
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.join(value: Iterable, d: str = '', attribute: str | int | NoneType = None) → str`

    Return a string which is the concatenation of the strings in the sequence. The separator between elements is an empty string per default, you can define it with the optional parameter:

    ``` jinja
    {{ [1, 2, 3]|join('|') }}
        -> 1|2|3

    {{ [1, 2, 3]|join }}
        -> 123
    ```

    It is also possible to join certain attributes of an object:

    ``` jinja
    {{ users|join(', ', attribute='username') }}
    ```

    Changelog

    New in version 2.6: The `attribute` parameter was added.
- name: joiner
  id: templates/index#jinja-globals.joiner
  summary: A tiny helper that can be used to “join” multiple sections
  belongs_to: Template Designer Documentation
  description: |-
    `class jinja-globals.joiner(sep=', ')`

    A tiny helper that can be used to “join” multiple sections. A joiner is passed a string and will return that string every time it’s called, except the first time (in which case it returns an empty string). You can use this to join things:

    ``` html+jinja
    {% set pipe = joiner("|") %}
    {% if categories %} {{ pipe() }}
        Categories: {{ categories|join(", ") }}
    {% endif %}
    {% if author %} {{ pipe() }}
        Author: {{ author() }}
    {% endif %}
    {% if can_edit %} {{ pipe() }}
        <a href="?action=edit">Edit</a>
    {% endif %}
    ```

    Changelog

    New in version 2.1.
- name: Keyword
  id: extensions/index#jinja2.nodes.Keyword
  summary: A key, value pair for keyword arguments where key is a string
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Keyword(key, value)`

    A key, value pair for keyword arguments where key is a string.

    Node type:

    [`Helper`](#jinja2.nodes.Helper "jinja2.nodes.Helper")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: last()
  id: templates/index#jinja-filters.last
  summary: Return the last item of a sequence
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.last(seq: 't.Reversible[V]') → 't.Union[V, Undefined]'`

    Return the last item of a sequence.

    Note: Does not work with generators. You may want to explicitly convert it to a list:

    ``` jinja
    {{ data | selectattr('name', '==', 'Jinja') | list | last }}
    ```
- name: le()
  id: templates/index#jinja-tests.le
  summary: Same as a <= b
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.le(a, b, /)`

    Same as a \<= b.

    Aliases:

    `<=`
- name: length()
  id: templates/index#jinja-filters.length
  summary: Return the number of items in a container
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.length(obj, /)`

    Return the number of items in a container.

    Aliases:

    `count`
- name: lipsum()
  id: templates/index#jinja-globals.lipsum
  summary: Generates some lorem ipsum for the template
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-globals.lipsum(n=5, html=True, min=20, max=100)`

    Generates some lorem ipsum for the template. By default, five paragraphs of HTML are generated with each paragraph between 20 and 100 words. If html is False, regular text is returned. This is useful to generate simple contents for layout testing.
- name: List
  id: extensions/index#jinja2.nodes.List
  summary: null
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.List(items)`

    Any list literal such as `[1, 2, 3]`

    Node type:

    [`Literal`](#jinja2.nodes.Literal "jinja2.nodes.Literal")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: list()
  id: templates/index#jinja-filters.list
  summary: Convert the value into a list
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.list(value: 't.Iterable[V]') → 't.List[V]'`

    Convert the value into a list. If it was a string the returned list will be a list of characters.
- name: Literal
  id: extensions/index#jinja2.nodes.Literal
  summary: Baseclass for literals
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Literal`

    Baseclass for literals.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: lower()
  id: templates/index#jinja-tests.lower
  summary: Return true if the variable is lowercased
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.lower(value: str) → bool`

    Return true if the variable is lowercased.
- name: lower()
  id: templates/index#jinja-filters.lower
  summary: Convert a value to lowercase
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.lower(s: str) → str`

    Convert a value to lowercase.
- name: lt()
  id: templates/index#jinja-tests.lt
  summary: Same as a < b
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.lt(a, b, /)`

    Same as a \< b.

    Aliases:

    `<`, `lessthan`
- name: Macro
  id: extensions/index#jinja2.nodes.Macro
  summary: A macro definition
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Macro(name, args, defaults, body)`

    A macro definition. `name` is the name of the macro, `args` a list of arguments and `defaults` a list of defaults if there are any. `body` is a list of nodes for the macro body.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: make_logging_undefined()
  id: api/index#jinja2.make_logging_undefined
  summary: Given a logger object this returns a new undefined class that will log certain failures
  description: |-
    `jinja2.make_logging_undefined(logger=None, base=<class 'jinja2.runtime.Undefined'>)`

    Given a logger object this returns a new undefined class that will log certain failures. It will log iterations and printing. If no logger is given a default logger is created.

    Example:

    ``` python
    logger = logging.getLogger(__name__)
    LoggingUndefined = make_logging_undefined(
        logger=logger,
        base=Undefined
    )
    ```

    Changelog

    New in version 2.8.

    Parameters:

    - **logger** ([logging.Logger](https://docs.python.org/3/library/logging.html#logging.Logger "(in Python v3.11)") *\|* *None*) – the logger to use. If not provided, a default logger is created.
    - **base** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Undefined](#jinja2.Undefined "jinja2.runtime.Undefined")*\]*) – the base class to add logging functionality to. This defaults to [`Undefined`](#jinja2.Undefined "jinja2.Undefined").

    Return type:

    [Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")\[[Undefined](#jinja2.Undefined "jinja2.runtime.Undefined")\]

    Undefined objects are created by calling `undefined`.

    Implementation

    [`Undefined`](#jinja2.Undefined "jinja2.Undefined") is implemented by overriding the special `__underscore__` methods. For example the default [`Undefined`](#jinja2.Undefined "jinja2.Undefined") class implements `__str__` to returns an empty string, while `__int__` and others fail with an exception. To allow conversion to int by returning `0` you can implement your own subclass.

    ``` python
    class NullUndefined(Undefined):
        def __int__(self):
            return 0

        def __float__(self):
            return 0.0
    ```

    To disallow a method, override it and raise [`_undefined_exception`](#jinja2.Undefined._undefined_exception "jinja2.Undefined._undefined_exception"). Because this is very common there is the helper method [`_fail_with_undefined_error()`](#jinja2.Undefined._fail_with_undefined_error "jinja2.Undefined._fail_with_undefined_error") that raises the error with the correct information. Here’s a class that works like the regular [`Undefined`](#jinja2.Undefined "jinja2.Undefined") but fails on iteration:

    ``` python
    class NonIterableUndefined(Undefined):
        def __iter__(self):
            self._fail_with_undefined_error()
    ```

    ## The Context
- name: map()
  id: templates/index#jinja-filters.map
  summary: Applies a filter on a sequence of objects or looks up an attribute
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.map(value: Iterable, *args: Any, **kwargs: Any) → Iterable`

    Applies a filter on a sequence of objects or looks up an attribute. This is useful when dealing with lists of objects but you are really only interested in a certain value of it.

    The basic usage is mapping on an attribute. Imagine you have a list of users but you are only interested in a list of usernames:

    ``` jinja
    Users on this page: {{ users|map(attribute='username')|join(', ') }}
    ```

    You can specify a `default` value to use if an object in the list does not have the given attribute.

    ``` jinja
    {{ users|map(attribute="username", default="Anonymous")|join(", ") }}
    ```

    Alternatively you can let it invoke a filter by passing the name of the filter and the arguments afterwards. A good example would be applying a text conversion filter on a sequence:

    ``` jinja
    Users on this page: {{ titles|map('lower')|join(', ') }}
    ```

    Similar to a generator comprehension such as:

    ``` python
    (u.username for u in users)
    (getattr(u, "username", "Anonymous") for u in users)
    (do_lower(x) for x in titles)
    ```

    Changelog

    Changed in version 2.11.0: Added the `default` parameter.

    New in version 2.7.
- name: mapping()
  id: templates/index#jinja-tests.mapping
  summary: Return true if the object is a mapping (dict etc.)
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.mapping(value: Any) → bool`

    Return true if the object is a mapping (dict etc.).

    Changelog

    New in version 2.6.
- name: MarkSafe
  id: extensions/index#jinja2.nodes.MarkSafe
  summary: Mark the wrapped expression as safe (wrap it as Markup)
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.MarkSafe(expr)`

    Mark the wrapped expression as safe (wrap it as `Markup`).

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: MarkSafeIfAutoescape
  id: extensions/index#jinja2.nodes.MarkSafeIfAutoescape
  summary: Mark the wrapped expression as safe (wrap it as Markup) but only if autoescaping is active
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.MarkSafeIfAutoescape(expr)`

    Mark the wrapped expression as safe (wrap it as `Markup`) but only if autoescaping is active.

    Changelog

    New in version 2.5.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: max()
  id: templates/index#jinja-filters.max
  summary: Return the largest item from the sequence
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.max(value: 't.Iterable[V]', case_sensitive: bool = False, attribute: str | int | NoneType = None) → 't.Union[V, Undefined]'`

    Return the largest item from the sequence.

    ``` jinja
    {{ [1, 2, 3]|max }}
        -> 3
    ```

    Parameters:

    - **case_sensitive** – Treat upper and lower case strings as distinct.
    - **attribute** – Get the object with the max value of this attribute.
- name: MemcachedBytecodeCache
  id: api/index#jinja2.MemcachedBytecodeCache
  summary: This class implements a bytecode cache that uses a memcache cache for storing the information
  description: |-
    `class jinja2.MemcachedBytecodeCache(client, prefix='jinja2/bytecode/', timeout=None, ignore_memcache_errors=True)`

    This class implements a bytecode cache that uses a memcache cache for storing the information. It does not enforce a specific memcache library (tummy’s memcache or cmemcache) but will accept any class that provides the minimal interface required.

    Libraries compatible with this class:

    - [cachelib](https://github.com/pallets/cachelib)
    - [python-memcached](https://pypi.org/project/python-memcached/)

    (Unfortunately the django cache interface is not compatible because it does not support storing binary data, only text. You can however pass the underlying cache client to the bytecode cache which is available as `django.core.cache.cache._client`.)

    The minimal interface for the client passed to the constructor is this:

    Parameters:

    - **client** (*\_MemcachedClient*) –
    - **prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **timeout** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *None*) –
    - **ignore_memcache_errors** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
- name: min()
  id: templates/index#jinja-filters.min
  summary: Return the smallest item from the sequence
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.min(value: 't.Iterable[V]', case_sensitive: bool = False, attribute: str | int | NoneType = None) → 't.Union[V, Undefined]'`

    Return the smallest item from the sequence.

    ``` jinja
    {{ [1, 2, 3]|min }}
        -> 1
    ```

    Parameters:

    - **case_sensitive** – Treat upper and lower case strings as distinct.
    - **attribute** – Get the object with the min value of this attribute.
- name: MinimalClientInterface
  id: api/index#jinja2.MemcachedBytecodeCache.MinimalClientInterface
  summary: null
  description: '`class MinimalClientInterface`'
- name: MinimalClientInterface.get()
  id: api/index#jinja2.MemcachedBytecodeCache.MinimalClientInterface.get
  summary: Returns the value for the cache key
  description: |-
    `get(key)`

    Returns the value for the cache key. If the item does not exist in the cache the return value must be `None`.

    The other arguments to the constructor are the prefix for all keys that is added before the actual cache key and the timeout for the bytecode in the cache system. We recommend a high (or no) timeout.

    This bytecode cache does not support clearing of used items in the cache. The clear method is a no-operation function.

    Changelog

    New in version 2.7: Added support for ignoring memcache errors through the `ignore_memcache_errors` parameter.

    ## Async Support

    Changelog

    New in version 2.9.

    Jinja supports the Python `async` and `await` syntax. For the template designer, this support (when enabled) is entirely transparent, templates continue to look exactly the same. However, developers should be aware of the implementation as it affects what types of APIs you can use.

    By default, async support is disabled. Enabling it will cause the environment to compile different code behind the scenes in order to handle async and sync code in an asyncio event loop. This has the following implications:

    - Template rendering requires an event loop to be available to the current thread. [`asyncio.get_running_loop()`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_running_loop "(in Python v3.11)") must return an event loop.
    - The compiled code uses `await` for functions and attributes, and uses `async for` loops. In order to support using both async and sync functions in this context, a small wrapper is placed around all calls and access, which adds overhead compared to purely async code.
    - Sync methods and filters become wrappers around their corresponding async implementations where needed. For example, `render` invokes `async_render`, and `|map` supports async iterables.

    Awaitable objects can be returned from functions in templates and any function call in a template will automatically await the result. The `await` you would normally add in Python is implied. For example, you can provide a method that asynchronously loads data from a database, and from the template designer’s point of view it can be called like any other function.

    ## Policies

    Starting with Jinja 2.9 policies can be configured on the environment which can slightly influence how filters and other template constructs behave. They can be configured with the [`policies`](#jinja2.Environment.policies "jinja2.Environment.policies") attribute.

    Example:

    ``` python
    env.policies['urlize.rel'] = 'nofollow noopener'
    ```

    `truncate.leeway:`

    Configures the leeway default for the `truncate` filter. Leeway as introduced in 2.9 but to restore compatibility with older templates it can be configured to `0` to get the old behavior back. The default is `5`.

    `urlize.rel:`

    A string that defines the items for the `rel` attribute of generated links with the `urlize` filter. These items are always added. The default is `noopener`.

    `urlize.target:`

    The default target that is issued for links from the `urlize` filter if no other target is defined by the call explicitly.

    `urlize.extra_schemes:`

    Recognize URLs that start with these schemes in addition to the default `http://`, `https://`, and `mailto:`.

    `json.dumps_function:`

    If this is set to a value other than `None` then the `tojson` filter will dump with this function instead of the default one. Note that this function should accept arbitrary extra arguments which might be passed in the future from the filter. Currently the only argument that might be passed is `indent`. The default dump function is `json.dumps`.

    `json.dumps_kwargs:`

    Keyword arguments to be passed to the dump function. The default is `{'sort_keys': True}`.

    `ext.i18n.trimmed:`

    If this is set to `True`, `{% trans %}` blocks of the [i18n Extension](../extensions/index#i18n-extension) will always unify linebreaks and surrounding whitespace as if the `trimmed` modifier was used.

    ## Utilities

    These helper functions and classes are useful if you add custom filters or functions to a Jinja environment.
- name: MinimalClientInterface.set()
  id: api/index#jinja2.MemcachedBytecodeCache.MinimalClientInterface.set
  summary: Stores the bytecode in the cache
  description: |-
    `set(key, value[, timeout])`

    Stores the bytecode in the cache. `value` is a string and `timeout` the timeout of the key. If timeout is not provided a default timeout or no timeout should be assumed, if it’s provided it’s an integer with the number of seconds the cache item should exist.
- name: Mod
  id: extensions/index#jinja2.nodes.Mod
  summary: Left modulo right
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Mod(left, right)`

    Left modulo right.

    Node type:

    [`BinExpr`](#jinja2.nodes.BinExpr "jinja2.nodes.BinExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: modifies_known_mutable()
  id: sandbox/index#jinja2.sandbox.modifies_known_mutable
  summary: This function checks if an attribute on a builtin mutable object (list, dict, set or deque) or the corresponding ABCs would modify it if called
  belongs_to: Sandbox
  description: "`jinja2.sandbox.modifies_known_mutable(obj, attr)`\n\nThis function checks if an attribute on a builtin mutable object (list, dict, set or deque) or the corresponding ABCs would modify it if called.\n\n``` python\n>>> modifies_known_mutable({}, \"clear\")\nTrue\n>>> modifies_known_mutable({}, \"keys\")\nFalse\n>>> modifies_known_mutable([], \"append\")\nTrue\n>>> modifies_known_mutable([], \"index\")\nFalse\n```\n\nIf called with an unsupported object, `False` is returned.\n\n``` python\n>>> modifies_known_mutable(\"foo\", \"upper\")\nFalse\n```\n\nParameters:\n\n- **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attr** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\nReturn type:\n\n[bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")\n\n## Operator Intercepting\n\nFor performance, Jinja outputs operators directly when compiling. This means it’s not possible to intercept operator behavior by overriding `SandboxEnvironment.call` by default, because operator special methods are handled by the Python interpreter, and might not correspond with exactly one method depending on the operator’s use.\n\nThe sandbox can instruct the compiler to output a function to intercept certain operators instead. Override [`SandboxedEnvironment.intercepted_binops`](#jinja2.sandbox.SandboxedEnvironment.intercepted_binops \"jinja2.sandbox.SandboxedEnvironment.intercepted_binops\") and [`SandboxedEnvironment.intercepted_unops`](#jinja2.sandbox.SandboxedEnvironment.intercepted_unops \"jinja2.sandbox.SandboxedEnvironment.intercepted_unops\") with the operator symbols you want to intercept. The compiler will replace the symbols with calls to [`SandboxedEnvironment.call_binop()`](#jinja2.sandbox.SandboxedEnvironment.call_binop \"jinja2.sandbox.SandboxedEnvironment.call_binop\") and [`SandboxedEnvironment.call_unop()`](#jinja2.sandbox.SandboxedEnvironment.call_unop \"jinja2.sandbox.SandboxedEnvironment.call_unop\") instead. The default implementation of those methods will use `SandboxedEnvironment.binop_table` and `SandboxedEnvironment.unop_table` to translate operator symbols into [`operator`](https://docs.python.org/3/library/operator.html#module-operator \"(in Python v3.11)\") functions.\n\nFor example, the power (`**`) operator can be disabled:\n\n``` python\nfrom jinja2.sandbox import SandboxedEnvironment\n\nclass MyEnvironment(SandboxedEnvironment):\n    intercepted_binops = frozenset([\"**\"])\n\n    def call_binop(self, context, operator, left, right):\n        if operator == \"**\":\n            return self.undefined(\"The power (**) operator is unavailable.\")\n\n        return super().call_binop(self, context, operator, left, right)\n```\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/sandbox/](https://jinja.palletsprojects.com/en/3.1.x/sandbox/)"
- name: ModuleLoader
  id: api/index#jinja2.ModuleLoader
  summary: This loader loads templates from precompiled templates
  description: |-
    `class jinja2.ModuleLoader(path)`

    This loader loads templates from precompiled templates.

    Example usage:

    ``` python
    >>> loader = ChoiceLoader([
    ...     ModuleLoader('/path/to/compiled/templates'),
    ...     FileSystemLoader('/path/to/templates')
    ... ])
    ```

    Templates can be precompiled with [`Environment.compile_templates()`](#jinja2.Environment.compile_templates "jinja2.Environment.compile_templates").

    Parameters:

    **path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") *\|* [Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)")*\]*) –

    ## Bytecode Cache

    Jinja 2.1 and higher support external bytecode caching. Bytecode caches make it possible to store the generated bytecode on the file system or a different location to avoid parsing the templates on first use.

    This is especially useful if you have a web application that is initialized on the first request and Jinja compiles many templates at once which slows down the application.

    To use a bytecode cache, instantiate it and pass it to the [`Environment`](#jinja2.Environment "jinja2.Environment").
- name: Mul
  id: extensions/index#jinja2.nodes.Mul
  summary: Multiplies the left with the right node
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Mul(left, right)`

    Multiplies the left with the right node.

    Node type:

    [`BinExpr`](#jinja2.nodes.BinExpr "jinja2.nodes.BinExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Name
  id: extensions/index#jinja2.nodes.Name
  summary: Looks up a name or stores a value in a name
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Name(name, ctx)`

    Looks up a name or stores a value in a name. The `ctx` of the node can be one of the following values:

    - `store`: store a value in the name
    - `load`: load that name
    - `param`: like `store` but if the name was defined as function parameter.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: namespace
  id: templates/index#jinja-globals.namespace
  summary: The main purpose of this is to allow carrying a value from within a loop body to an outer scope
  belongs_to: Template Designer Documentation
  description: "`class jinja-globals.namespace(...)`\n\nCreates a new container that allows attribute assignment using the `{% set %}` tag:\n\n``` html+jinja\n{% set ns = namespace() %}\n{% set ns.foo = 'bar' %}\n```\n\nThe main purpose of this is to allow carrying a value from within a loop body to an outer scope. Initial values can be provided as a dict, as keyword arguments, or both (same behavior as Python’s `dict` constructor):\n\n``` html+jinja\n{% set ns = namespace(found=false) %}\n{% for item in items %}\n    {% if item.check_something() %}\n        {% set ns.found = true %}\n    {% endif %}\n    * {{ item.title }}\n{% endfor %}\nFound item having something: {{ ns.found }}\n```\n\nChangelog\n\nNew in version 2.10.\n\n## Extensions\n\nThe following sections cover the built-in Jinja extensions that may be enabled by an application. An application could also provide further extensions not covered by this documentation; in which case there should be a separate document explaining said [extensions](../extensions/index#jinja-extensions).\n\n### i18n\n\nIf the [i18n Extension](../extensions/index#i18n-extension) is enabled, it’s possible to mark text in the template as translatable. To mark a section as translatable, use a `trans` block:\n\n``` jinja\n{% trans %}Hello, {{ user }}!{% endtrans %}\n```\n\nInside the block, no statements are allowed, only text and simple variable tags.\n\nVariable tags can only be a name, not attribute access, filters, or other expressions. To use an expression, bind it to a name in the `trans` tag for use in the block.\n\n``` jinja\n{% trans user=user.username %}Hello, {{ user }}!{% endtrans %}\n```\n\nTo bind more than one expression, separate each with a comma (`,`).\n\n``` jinja\n{% trans book_title=book.title, author=author.name %}\nThis is {{ book_title }} by {{ author }}\n{% endtrans %}\n```\n\nTo pluralize, specify both the singular and plural forms separated by the `pluralize` tag.\n\n``` jinja\n{% trans count=list|length %}\nThere is {{ count }} {{ name }} object.\n{% pluralize %}\nThere are {{ count }} {{ name }} objects.\n{% endtrans %}\n```\n\nBy default, the first variable in a block is used to determine whether to use singular or plural form. If that isn’t correct, specify the variable used for pluralizing as a parameter to `pluralize`.\n\n``` jinja\n{% trans ..., user_count=users|length %}...\n{% pluralize user_count %}...{% endtrans %}\n```\n\nWhen translating blocks of text, whitespace and linebreaks result in hard to read and error-prone translation strings. To avoid this, a trans block can be marked as trimmed, which will replace all linebreaks and the whitespace surrounding them with a single space and remove leading and trailing whitespace.\n\n``` jinja\n{% trans trimmed book_title=book.title %}\n    This is {{ book_title }}.\n    You should read it!\n{% endtrans %}\n```\n\nThis results in `This is %(book_title)s. You should read it!` in the translation file.\n\nIf trimming is enabled globally, the `notrimmed` modifier can be used to disable it for a block.\n\nChangelog\n\nNew in version 2.10: The `trimmed` and `notrimmed` modifiers have been added.\n\nIf the translation depends on the context that the message appears in, the `pgettext` and `npgettext` functions take a `context` string as the first argument, which is used to select the appropriate translation. To specify a context with the `{% trans %}` tag, provide a string as the first token after `trans`.\n\n``` jinja\n{% trans \"fruit\" %}apple{% endtrans %}\n{% trans \"fruit\" trimmed count -%}\n    1 apple\n{%- pluralize -%}\n    {{ count }} apples\n{%- endtrans %}\n```\n\nNew in version 3.1: A context can be passed to the `trans` tag to use `pgettext` and `npgettext`.\n\nIt’s possible to translate strings in expressions with these functions:\n\n- `_(message)`: Alias for `gettext`.\n- `gettext(message)`: Translate a message.\n- `ngettext(singluar, plural, n)`: Translate a singular or plural message based on a count variable.\n- `pgettext(context, message)`: Like `gettext()`, but picks the translation based on the context string.\n- `npgettext(context, singular, plural, n)`: Like `npgettext()`, but picks the translation based on the context string.\n\nYou can print a translated string like this:\n\n``` jinja\n{{ _(\"Hello, World!\") }}\n```\n\nTo use placeholders, use the `format` filter.\n\n``` jinja\n{{ _(\"Hello, %(user)s!\")|format(user=user.username) }}\n```\n\nAlways use keyword arguments to `format`, as other languages may not use the words in the same order.\n\nIf [New Style Gettext](../extensions/index#newstyle-gettext) calls are activated, using placeholders is easier. Formatting is part of the `gettext` call instead of using the `format` filter.\n\n``` jinja\n{{ gettext('Hello World!') }}\n{{ gettext('Hello %(name)s!', name='World') }}\n{{ ngettext('%(num)d apple', '%(num)d apples', apples|count) }}\n```\n\nThe `ngettext` function’s format string automatically receives the count as a `num` parameter in addition to the given parameters.\n\n### Expression Statement\n\nIf the expression-statement extension is loaded, a tag called `do` is available that works exactly like the regular variable expression (`{{ ... }}`); except it doesn’t print anything. This can be used to modify lists:\n\n``` html+jinja\n{% do navigation.append('a string') %}\n```\n\n### Loop Controls\n\nIf the application enables the [Loop Controls](../extensions/index#loopcontrols-extension), it’s possible to use `break` and `continue` in loops. When `break` is reached, the loop is terminated; if `continue` is reached, the processing is stopped and continues with the next iteration.\n\nHere’s a loop that skips every second item:\n\n``` html+jinja\n{% for user in users %}\n    {%- if loop.index is even %}{% continue %}{% endif %}\n    ...\n{% endfor %}\n```\n\nLikewise, a loop that stops processing after the 10th iteration:\n\n``` html+jinja\n{% for user in users %}\n    {%- if loop.index >= 10 %}{% break %}{% endif %}\n{%- endfor %}\n```\n\nNote that `loop.index` starts with 1, and `loop.index0` starts with 0 (See: [For](#for-loop)).\n\n### Debug Statement\n\nIf the [Debug Extension](../extensions/index#debug-extension) is enabled, a `{% debug %}` tag will be available to dump the current context as well as the available filters and tests. This is useful to see what’s available to use in the template without setting up a debugger.\n\n``` html+jinja\n<pre>{% debug %}</pre>\n```\n\n``` text\n{'context': {'cycler': <class 'jinja2.utils.Cycler'>,\n             ...,\n             'namespace': <class 'jinja2.utils.Namespace'>},\n 'filters': ['abs', 'attr', 'batch', 'capitalize', 'center', 'count', 'd',\n             ..., 'urlencode', 'urlize', 'wordcount', 'wordwrap', 'xmlattr'],\n 'tests': ['!=', '<', '<=', '==', '>', '>=', 'callable', 'defined',\n           ..., 'odd', 'sameas', 'sequence', 'string', 'undefined', 'upper']}\n```\n\n### With Statement\n\nChangelog\n\nNew in version 2.3.\n\nThe with statement makes it possible to create a new inner scope. Variables set within this scope are not visible outside of the scope.\n\nWith in a nutshell:\n\n``` html+jinja\n{% with %}\n    {% set foo = 42 %}\n    {{ foo }}           foo is 42 here\n{% endwith %}\nfoo is not visible here any longer\n```\n\nBecause it is common to set variables at the beginning of the scope, you can do that within the `with` statement. The following two examples are equivalent:\n\n``` html+jinja\n{% with foo = 42 %}\n    {{ foo }}\n{% endwith %}\n\n{% with %}\n    {% set foo = 42 %}\n    {{ foo }}\n{% endwith %}\n```\n\nAn important note on scoping here. In Jinja versions before 2.9 the behavior of referencing one variable to another had some unintended consequences. In particular one variable could refer to another defined in the same with block’s opening statement. This caused issues with the cleaned up scoping behavior and has since been improved. In particular in newer Jinja versions the following code always refers to the variable `a` from outside the `with` block:\n\n``` html+jinja\n{% with a={}, b=a.attribute %}...{% endwith %}\n```\n\nIn earlier Jinja versions the `b` attribute would refer to the results of the first attribute. If you depend on this behavior you can rewrite it to use the `set` tag:\n\n``` html+jinja\n{% with a={} %}\n    {% set b = a.attribute %}\n{% endwith %}\n```\n\nExtension\n\nIn older versions of Jinja (before 2.9) it was required to enable this feature with an extension. It’s now enabled by default.\n\n## Autoescape Overrides\n\nChangelog\n\nNew in version 2.4.\n\nIf you want you can activate and deactivate the autoescaping from within the templates.\n\nExample:\n\n``` html+jinja\n{% autoescape true %}\n    Autoescaping is active within this block\n{% endautoescape %}\n\n{% autoescape false %}\n    Autoescaping is inactive within this block\n{% endautoescape %}\n```\n\nAfter an `endautoescape` the behavior is reverted to what it was before.\n\nExtension\n\nIn older versions of Jinja (before 2.9) it was required to enable this feature with an extension. It’s now enabled by default.\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/templates/](https://jinja.palletsprojects.com/en/3.1.x/templates/)"
- name: Native Python Types
  id: nativetypes/index
  summary: The default Environment renders templates to strings
  description: "# Native Python Types\n\nThe default [`Environment`](../api/index#jinja2.Environment \"jinja2.Environment\") renders templates to strings. With [`NativeEnvironment`](#jinja2.nativetypes.NativeEnvironment \"jinja2.nativetypes.NativeEnvironment\"), rendering a template produces a native Python type. This is useful if you are using Jinja outside the context of creating text files. For example, your code may have an intermediate step where users may use templates to define values that will then be passed to a traditional string environment.\n\n## Examples\n\nAdding two values results in an integer, not a string with a number:\n\n``` python\n>>> env = NativeEnvironment()\n>>> t = env.from_string('{{ x + y }}')\n>>> result = t.render(x=4, y=2)\n>>> print(result)\n6\n>>> print(type(result))\nint\n```\n\nRendering list syntax produces a list:\n\n``` python\n>>> t = env.from_string('[{% for item in data %}{{ item + 1 }},{% endfor %}]')\n>>> result = t.render(data=range(5))\n>>> print(result)\n[1, 2, 3, 4, 5]\n>>> print(type(result))\nlist\n```\n\nRendering something that doesn’t look like a Python literal produces a string:\n\n``` python\n>>> t = env.from_string('{{ x }} * {{ y }}')\n>>> result = t.render(x=4, y=2)\n>>> print(result)\n4 * 2\n>>> print(type(result))\nstr\n```\n\nRendering a Python object produces that object as long as it is the only node:\n\n``` python\n>>> class Foo:\n...     def __init__(self, value):\n...         self.value = value\n...\n>>> result = env.from_string('{{ x }}').render(x=Foo(15))\n>>> print(type(result).__name__)\nFoo\n>>> print(result.value)\n15\n```\n\n## API\n\n`class jinja2.nativetypes.NativeEnvironment([options])`  \nAn environment that renders templates to native Python types.\n\nParameters:  \n- **block_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **block_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **variable_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **variable_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **comment_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **comment_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **line_statement_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n- **line_comment_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n- **trim_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **lstrip_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **newline_sequence** (*te.Literal\\['\\n',* *'\\r\\n',* *'\\r'\\]*) –\n- **keep_trailing_newline** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **extensions** ([Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence \"(in Python v3.11)\")*\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* [Type](https://docs.python.org/3/library/typing.html#typing.Type \"(in Python v3.11)\")*\\[*[Extension](../extensions/index#jinja2.ext.Extension \"jinja2.ext.Extension\")*\\]\\]*) –\n- **optimized** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **undefined** ([Type](https://docs.python.org/3/library/typing.html#typing.Type \"(in Python v3.11)\")*\\[*[Undefined](../api/index#jinja2.Undefined \"jinja2.runtime.Undefined\")*\\]*) –\n- **finalize** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable \"(in Python v3.11)\")*\\[\\[...\\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")*\\]* *\\|* *None*) –\n- **autoescape** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\") *\\|* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable \"(in Python v3.11)\")*\\[\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None\\],* [bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")*\\]*) –\n- **loader** ([BaseLoader](../api/index#jinja2.BaseLoader \"jinja2.BaseLoader\") *\\|* *None*) –\n- **cache_size** ([int](https://docs.python.org/3/library/functions.html#int \"(in Python v3.11)\")) –\n- **auto_reload** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **bytecode_cache** ([BytecodeCache](../api/index#jinja2.BytecodeCache \"jinja2.BytecodeCache\") *\\|* *None*) –\n- **enable_async** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n\n`class jinja2.nativetypes.NativeTemplate([options])`  \nParameters:  \n- **source** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* [Template](../extensions/index#jinja2.nodes.Template \"jinja2.nodes.Template\")) –\n- **block_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **block_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **variable_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **variable_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **comment_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **comment_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **line_statement_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n- **line_comment_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n- **trim_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **lstrip_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **newline_sequence** (*te.Literal\\['\\n',* *'\\r\\n',* *'\\r'\\]*) –\n- **keep_trailing_newline** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **extensions** ([Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence \"(in Python v3.11)\")*\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* [Type](https://docs.python.org/3/library/typing.html#typing.Type \"(in Python v3.11)\")*\\[*[Extension](../extensions/index#jinja2.ext.Extension \"jinja2.ext.Extension\")*\\]\\]*) –\n- **optimized** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n- **undefined** ([Type](https://docs.python.org/3/library/typing.html#typing.Type \"(in Python v3.11)\")*\\[*[Undefined](../api/index#jinja2.Undefined \"jinja2.runtime.Undefined\")*\\]*) –\n- **finalize** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable \"(in Python v3.11)\")*\\[\\[...\\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")*\\]* *\\|* *None*) –\n- **autoescape** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\") *\\|* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable \"(in Python v3.11)\")*\\[\\[*[str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None\\],* [bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")*\\]*) –\n- **enable_async** ([bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")) –\n\nReturn type:  \n[Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")\n\n`render(*args, **kwargs)`  \nRender the template to produce a native Python type. If the result is a single node, its value is returned. Otherwise, the nodes are concatenated as strings. If the result can be parsed with [`ast.literal_eval()`](https://docs.python.org/3/library/ast.html#ast.literal_eval \"(in Python v3.11)\"), the parsed value is returned. Otherwise, the string is returned.\n\nParameters:  \n- **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\nReturn type:  \n[Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/nativetypes/](https://jinja.palletsprojects.com/en/3.1.x/nativetypes/)"
- name: NativeEnvironment
  id: nativetypes/index#jinja2.nativetypes.NativeEnvironment
  summary: An environment that renders templates to native Python types
  belongs_to: Native Python Types
  description: |-
    `class jinja2.nativetypes.NativeEnvironment([options])`

    An environment that renders templates to native Python types.

    Parameters:

    - **block_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **block_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **variable_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **variable_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **comment_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **comment_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **line_statement_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **line_comment_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **trim_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **lstrip_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **newline_sequence** (*te.Literal\['\n',* *'\r\n',* *'\r'\]*) –
    - **keep_trailing_newline** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **extensions** ([Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Extension](../extensions/index#jinja2.ext.Extension "jinja2.ext.Extension")*\]\]*) –
    - **optimized** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **undefined** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Undefined](../api/index#jinja2.Undefined "jinja2.runtime.Undefined")*\]*) –
    - **finalize** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –
    - **autoescape** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None\],* [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")*\]*) –
    - **loader** ([BaseLoader](../api/index#jinja2.BaseLoader "jinja2.BaseLoader") *\|* *None*) –
    - **cache_size** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –
    - **auto_reload** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **bytecode_cache** ([BytecodeCache](../api/index#jinja2.BytecodeCache "jinja2.BytecodeCache") *\|* *None*) –
    - **enable_async** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
- name: NativeTemplate
  id: nativetypes/index#jinja2.nativetypes.NativeTemplate
  summary: null
  belongs_to: Native Python Types
  description: |-
    `class jinja2.nativetypes.NativeTemplate([options])`

    Parameters:

    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Template](../extensions/index#jinja2.nodes.Template "jinja2.nodes.Template")) –
    - **block_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **block_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **variable_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **variable_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **comment_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **comment_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **line_statement_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **line_comment_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **trim_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **lstrip_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **newline_sequence** (*te.Literal\['\n',* *'\r\n',* *'\r'\]*) –
    - **keep_trailing_newline** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **extensions** ([Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Extension](../extensions/index#jinja2.ext.Extension "jinja2.ext.Extension")*\]\]*) –
    - **optimized** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **undefined** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Undefined](../api/index#jinja2.Undefined "jinja2.runtime.Undefined")*\]*) –
    - **finalize** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –
    - **autoescape** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None\],* [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")*\]*) –
    - **enable_async** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: NativeTemplate.render()
  id: nativetypes/index#jinja2.nativetypes.NativeTemplate.render
  summary: Render the template to produce a native Python type
  belongs_to: Native Python Types
  description: "`render(*args, **kwargs)`\n\nRender the template to produce a native Python type. If the result is a single node, its value is returned. Otherwise, the nodes are concatenated as strings. If the result can be parsed with [`ast.literal_eval()`](https://docs.python.org/3/library/ast.html#ast.literal_eval \"(in Python v3.11)\"), the parsed value is returned. Otherwise, the string is returned.\n\nParameters:\n\n- **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\nReturn type:\n\n[Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/nativetypes/](https://jinja.palletsprojects.com/en/3.1.x/nativetypes/)"
- name: ne()
  id: templates/index#jinja-tests.ne
  summary: Same as a != b
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.ne(a, b, /)`

    Same as a != b.

    Aliases:

    `!=`
- name: Neg
  id: extensions/index#jinja2.nodes.Neg
  summary: Make the expression negative
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Neg(node)`

    Make the expression negative.

    Node type:

    [`UnaryExpr`](#jinja2.nodes.UnaryExpr "jinja2.nodes.UnaryExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Node
  id: extensions/index#jinja2.nodes.Node
  summary: Baseclass for all Jinja nodes
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Node`

    Baseclass for all Jinja nodes. There are a number of nodes available of different types. There are four major types:

    - [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt"): statements
    - [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr"): expressions
    - [`Helper`](#jinja2.nodes.Helper "jinja2.nodes.Helper"): helper nodes
    - [`Template`](#jinja2.nodes.Template "jinja2.nodes.Template"): the outermost wrapper node

    All nodes have fields and attributes. Fields may be other nodes, lists, or arbitrary values. Fields are passed to the constructor as regular positional arguments, attributes as keyword arguments. Each node has two attributes: `lineno` (the line number of the node) and `environment`. The `environment` attribute is set at the end of the parsing process for all nodes automatically.

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Node.find()
  id: extensions/index#jinja2.nodes.Node.find
  summary: Find the first node of a given type
  belongs_to: Extensions
  description: |-
    `find(node_type)`

    Find the first node of a given type. If no such node exists the return value is `None`.

    Parameters:

    **node_type** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[\_NodeBound\]*) –

    Return type:

    *\_NodeBound* \| None
- name: Node.find_all()
  id: extensions/index#jinja2.nodes.Node.find_all
  summary: Find all the nodes of a given type
  belongs_to: Extensions
  description: |-
    `find_all(node_type)`

    Find all the nodes of a given type. If the type is a tuple, the check is performed for any of the tuple items.

    Parameters:

    **node_type** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[\_NodeBound\]* *\|* [Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.11)")*\[*[Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[\_NodeBound\],* *...\]*) –

    Return type:

    [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")\[*\_NodeBound*\]
- name: Node.iter_child_nodes()
  id: extensions/index#jinja2.nodes.Node.iter_child_nodes
  summary: Iterates over all direct child nodes of the node
  belongs_to: Extensions
  description: |-
    `iter_child_nodes(exclude=None, only=None)`

    Iterates over all direct child nodes of the node. This iterates over all fields and yields the values of they are nodes. If the value of a field is a list all the nodes in that list are returned.

    Parameters:

    - **exclude** ([Container](https://docs.python.org/3/library/typing.html#typing.Container "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]* *\|* *None*) –
    - **only** ([Container](https://docs.python.org/3/library/typing.html#typing.Container "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]* *\|* *None*) –

    Return type:

    [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")\[[Node](#jinja2.nodes.Node "jinja2.nodes.Node")\]
- name: Node.iter_fields()
  id: extensions/index#jinja2.nodes.Node.iter_fields
  summary: This method iterates over all fields that are defined and yields (key, value) tuples
  belongs_to: Extensions
  description: |-
    `iter_fields(exclude=None, only=None)`

    This method iterates over all fields that are defined and yields `(key, value)` tuples. Per default all fields are returned, but it’s possible to limit that to some fields by providing the `only` parameter or to exclude some using the `exclude` parameter. Both should be sets or tuples of field names.

    Parameters:

    - **exclude** ([Container](https://docs.python.org/3/library/typing.html#typing.Container "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]* *\|* *None*) –
    - **only** ([Container](https://docs.python.org/3/library/typing.html#typing.Container "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]* *\|* *None*) –

    Return type:

    [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")\[[Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")\]\]
- name: Node.set_ctx()
  id: extensions/index#jinja2.nodes.Node.set_ctx
  summary: Reset the context of a node and all child nodes
  belongs_to: Extensions
  description: |-
    `set_ctx(ctx)`

    Reset the context of a node and all child nodes. Per default the parser will all generate nodes that have a ‘load’ context as it’s the most common one. This method is used in the parser to set assignment targets and other nodes to a store context.

    Parameters:

    **ctx** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [Node](#jinja2.nodes.Node "jinja2.nodes.Node")
- name: Node.set_environment()
  id: extensions/index#jinja2.nodes.Node.set_environment
  summary: Set the environment for all nodes
  belongs_to: Extensions
  description: |-
    `set_environment(environment)`

    Set the environment for all nodes.

    Parameters:

    **environment** ([Environment](../api/index#jinja2.Environment "jinja2.Environment")) –

    Return type:

    [Node](#jinja2.nodes.Node "jinja2.nodes.Node")
- name: Node.set_lineno()
  id: extensions/index#jinja2.nodes.Node.set_lineno
  summary: Set the line numbers of the node and children
  belongs_to: Extensions
  description: |-
    `set_lineno(lineno, override=False)`

    Set the line numbers of the node and children.

    Parameters:

    - **lineno** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –
    - **override** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [Node](#jinja2.nodes.Node "jinja2.nodes.Node")
- name: none()
  id: templates/index#jinja-tests.none
  summary: Return true if the variable is none
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.none(value: Any) → bool`

    Return true if the variable is none.
- name: Not
  id: extensions/index#jinja2.nodes.Not
  summary: Negate the expression
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Not(node)`

    Negate the expression.

    Node type:

    [`UnaryExpr`](#jinja2.nodes.UnaryExpr "jinja2.nodes.UnaryExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: NSRef
  id: extensions/index#jinja2.nodes.NSRef
  summary: null
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.NSRef(name, attr)`

    Reference to a namespace value assignment

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: number()
  id: templates/index#jinja-tests.number
  summary: Return true if the variable is a number
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.number(value: Any) → bool`

    Return true if the variable is a number.
- name: odd()
  id: templates/index#jinja-tests.odd
  summary: Return true if the variable is odd
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.odd(value: int) → bool`

    Return true if the variable is odd.
- name: Operand
  id: extensions/index#jinja2.nodes.Operand
  summary: Holds an operator and an expression
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Operand(op, expr)`

    Holds an operator and an expression.

    Node type:

    [`Helper`](#jinja2.nodes.Helper "jinja2.nodes.Helper")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Or
  id: extensions/index#jinja2.nodes.Or
  summary: Short circuited OR
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Or(left, right)`

    Short circuited OR.

    Node type:

    [`BinExpr`](#jinja2.nodes.BinExpr "jinja2.nodes.BinExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Output
  id: extensions/index#jinja2.nodes.Output
  summary: A node that holds multiple expressions which are then printed out
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Output(nodes)`

    A node that holds multiple expressions which are then printed out. This is used both for the `print` statement and the regular template data.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: OverlayScope
  id: extensions/index#jinja2.nodes.OverlayScope
  summary: An overlay scope for extensions
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.OverlayScope(context, body)`

    An overlay scope for extensions. This is a largely unoptimized scope that however can be used to introduce completely arbitrary variables into a sub scope from a dictionary or dictionary like object. The `context` field has to evaluate to a dictionary object.

    Example usage:

    ``` python
    OverlayScope(context=self.call_method('get_context'),
                 body=[...])
    ```

    Changelog

    New in version 2.10.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: PackageLoader
  id: api/index#jinja2.PackageLoader
  summary: Load templates from a directory in a Python package
  description: |-
    `class jinja2.PackageLoader(package_name, package_path='templates', encoding='utf-8')`

    Load templates from a directory in a Python package.

    Parameters:

    - **package_name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Import name of the package that contains the template directory.
    - **package_path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Directory within the imported package that contains the templates.
    - **encoding** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Encoding of template files.

    The following example looks up templates in the `pages` directory within the `project.ui` package.

    ``` python
    loader = PackageLoader("project.ui", "pages")
    ```

    Only packages installed as directories (standard pip behavior) or zip/egg files (less common) are supported. The Python API for introspecting data in packages is too limited to support other installation methods the way this loader requires.

    There is limited support for [**PEP 420**](https://peps.python.org/pep-0420/) namespace packages. The template directory is assumed to only be in one namespace contributor. Zip files contributing to a namespace are not supported.

    Changelog

    Changed in version 3.0: No longer uses `setuptools` as a dependency.

    Changed in version 3.0: Limited PEP 420 namespace package support.
- name: Pair
  id: extensions/index#jinja2.nodes.Pair
  summary: A key, value pair for dicts
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Pair(key, value)`

    A key, value pair for dicts.

    Node type:

    [`Helper`](#jinja2.nodes.Helper "jinja2.nodes.Helper")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Parser
  id: extensions/index#jinja2.parser.Parser
  summary: This is the central parsing class Jinja uses
  belongs_to: Extensions
  description: |-
    `class jinja2.parser.Parser(environment, source, name=None, filename=None, state=None)`

    This is the central parsing class Jinja uses. It’s passed to extensions and can be used to parse expressions or statements.

    Parameters:

    - **environment** ([Environment](../api/index#jinja2.Environment "jinja2.Environment")) –
    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **state** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
- name: Parser.fail()
  id: extensions/index#jinja2.parser.Parser.fail
  summary: Convenience method that raises exc with the message, passed line number or last line number as well as the current name and filename
  belongs_to: Extensions
  description: |-
    `fail(msg, lineno=None, exc=<class 'jinja2.exceptions.TemplateSyntaxError'>)`

    Convenience method that raises `exc` with the message, passed line number or last line number as well as the current name and filename.

    Parameters:

    - **msg** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **lineno** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *None*) –
    - **exc** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[TemplateSyntaxError](../api/index#jinja2.TemplateSyntaxError "jinja2.exceptions.TemplateSyntaxError")*\]*) –

    Return type:

    te.NoReturn
- name: Parser.filename
  id: extensions/index#jinja2.parser.Parser.filename
  summary: The filename of the template the parser processes
  belongs_to: Extensions
  description: |-
    `filename`

    The filename of the template the parser processes. This is **not** the load name of the template. For the load name see [`name`](#jinja2.parser.Parser.name "jinja2.parser.Parser.name"). For templates that were not loaded form the file system this is `None`.
- name: Parser.free_identifier()
  id: extensions/index#jinja2.parser.Parser.free_identifier
  summary: Return a new free identifier as InternalName
  belongs_to: Extensions
  description: |-
    `free_identifier(lineno=None)`

    Return a new free identifier as [`InternalName`](#jinja2.nodes.InternalName "jinja2.nodes.InternalName").

    Parameters:

    **lineno** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *None*) –

    Return type:

    [InternalName](#jinja2.nodes.InternalName "jinja2.nodes.InternalName")
- name: Parser.name
  id: extensions/index#jinja2.parser.Parser.name
  summary: The load name of the template
  belongs_to: Extensions
  description: |-
    `name`

    The load name of the template.
- name: Parser.parse_assign_target()
  id: extensions/index#jinja2.parser.Parser.parse_assign_target
  summary: Parse an assignment target
  belongs_to: Extensions
  description: |-
    `parse_assign_target(with_tuple=True, name_only=False, extra_end_rules=None, with_namespace=False)`

    Parse an assignment target. As Jinja allows assignments to tuples, this function can parse all allowed assignment targets. Per default assignments to tuples are parsed, that can be disable however by setting `with_tuple` to `False`. If only assignments to names are wanted `name_only` can be set to `True`. The `extra_end_rules` parameter is forwarded to the tuple parsing function. If `with_namespace` is enabled, a namespace assignment may be parsed.

    Parameters:

    - **with_tuple** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **name_only** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **extra_end_rules** ([Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* *...\]* *\|* *None*) –
    - **with_namespace** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [NSRef](#jinja2.nodes.NSRef "jinja2.nodes.NSRef") \| [Name](#jinja2.nodes.Name "jinja2.nodes.Name") \| [Tuple](#jinja2.nodes.Tuple "jinja2.nodes.Tuple")
- name: Parser.parse_expression()
  id: extensions/index#jinja2.parser.Parser.parse_expression
  summary: Parse an expression
  belongs_to: Extensions
  description: |-
    `parse_expression(with_condexpr=True)`

    Parse an expression. Per default all expressions are parsed, if the optional `with_condexpr` parameter is set to `False` conditional expressions are not parsed.

    Parameters:

    **with_condexpr** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [Expr](#jinja2.nodes.Expr "jinja2.nodes.Expr")
- name: Parser.parse_statements()
  id: extensions/index#jinja2.parser.Parser.parse_statements
  summary: Parse multiple statements into a list until one of the end tokens is reached
  belongs_to: Extensions
  description: |-
    `parse_statements(end_tokens, drop_needle=False)`

    Parse multiple statements into a list until one of the end tokens is reached. This is used to parse the body of statements as it also parses template data if appropriate. The parser checks first if the current token is a colon and skips it if there is one. Then it checks for the block end and parses until if one of the `end_tokens` is reached. Per default the active token in the stream at the end of the call is the matched end token. If this is not wanted `drop_needle` can be set to `True` and the end token is removed.

    Parameters:

    - **end_tokens** ([Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* *...\]*) –
    - **drop_needle** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [List](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.11)")\[[Node](#jinja2.nodes.Node "jinja2.nodes.Node")\]
- name: Parser.parse_tuple()
  id: extensions/index#jinja2.parser.Parser.parse_tuple
  summary: Works like parse_expression but if multiple expressions are delimited by a comma a Tuple node is created
  belongs_to: Extensions
  description: |-
    `parse_tuple(simplified=False, with_condexpr=True, extra_end_rules=None, explicit_parentheses=False)`

    Works like `parse_expression` but if multiple expressions are delimited by a comma a [`Tuple`](#jinja2.nodes.Tuple "jinja2.nodes.Tuple") node is created. This method could also return a regular expression instead of a tuple if no commas where found.

    The default parsing mode is a full tuple. If `simplified` is `True` only names and literals are parsed. The `no_condexpr` parameter is forwarded to [`parse_expression()`](#jinja2.parser.Parser.parse_expression "jinja2.parser.Parser.parse_expression").

    Because tuples do not require delimiters and may end in a bogus comma an extra hint is needed that marks the end of a tuple. For example for loops support tuples between `for` and `in`. In that case the `extra_end_rules` is set to `['name:in']`.

    `explicit_parentheses` is true if the parsing was triggered by an expression in parentheses. This is used to figure out if an empty tuple is a valid expression or not.

    Parameters:

    - **simplified** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **with_condexpr** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **extra_end_rules** ([Tuple](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* *...\]* *\|* *None*) –
    - **explicit_parentheses** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [Tuple](#jinja2.nodes.Tuple "jinja2.nodes.Tuple") \| [Expr](#jinja2.nodes.Expr "jinja2.nodes.Expr")
- name: Parser.stream
  id: extensions/index#jinja2.parser.Parser.stream
  summary: null
  belongs_to: Extensions
  description: |-
    `stream`

    The current [`TokenStream`](#jinja2.lexer.TokenStream "jinja2.lexer.TokenStream")
- name: pass_context()
  id: api/index#jinja2.pass_context
  summary: Pass the Context as the first argument to the decorated function when called while rendering a template
  description: |-
    `jinja2.pass_context(f)`

    Pass the [`Context`](#jinja2.runtime.Context "jinja2.runtime.Context") as the first argument to the decorated function when called while rendering a template.

    Can be used on functions, filters, and tests.

    If only `Context.eval_context` is needed, use [`pass_eval_context()`](#jinja2.pass_eval_context "jinja2.pass_eval_context"). If only `Context.environment` is needed, use [`pass_environment()`](#jinja2.pass_environment "jinja2.pass_environment").

    Changelog

    New in version 3.0.0: Replaces `contextfunction` and `contextfilter`.

    Parameters:

    **f** (*F*) –

    Return type:

    *F*
- name: pass_environment()
  id: api/index#jinja2.pass_environment
  summary: Pass the Environment as the first argument to the decorated function when called while rendering a template
  description: |-
    `jinja2.pass_environment(f)`

    Pass the [`Environment`](#jinja2.Environment "jinja2.Environment") as the first argument to the decorated function when called while rendering a template.

    Can be used on functions, filters, and tests.

    Changelog

    New in version 3.0.0: Replaces `environmentfunction` and `environmentfilter`.

    Parameters:

    **f** (*F*) –

    Return type:

    *F*
- name: pass_eval_context()
  id: api/index#jinja2.pass_eval_context
  summary: Pass the EvalContext as the first argument to the decorated function when called while rendering a template
  description: |-
    `jinja2.pass_eval_context(f)`

    Pass the [`EvalContext`](#jinja2.nodes.EvalContext "jinja2.nodes.EvalContext") as the first argument to the decorated function when called while rendering a template. See [Evaluation Context](#eval-context).

    Can be used on functions, filters, and tests.

    If only `EvalContext.environment` is needed, use [`pass_environment()`](#jinja2.pass_environment "jinja2.pass_environment").

    Changelog

    New in version 3.0.0: Replaces `evalcontextfunction` and `evalcontextfilter`.

    Parameters:

    **f** (*F*) –

    Return type:

    *F*
- name: Pos
  id: extensions/index#jinja2.nodes.Pos
  summary: null
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Pos(node)`

    Make the expression positive (noop for most expressions)

    Node type:

    [`UnaryExpr`](#jinja2.nodes.UnaryExpr "jinja2.nodes.UnaryExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Pow
  id: extensions/index#jinja2.nodes.Pow
  summary: Left to the power of right
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Pow(left, right)`

    Left to the power of right.

    Node type:

    [`BinExpr`](#jinja2.nodes.BinExpr "jinja2.nodes.BinExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: pprint()
  id: templates/index#jinja-filters.pprint
  summary: Pretty print a variable
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.pprint(value: Any) → str`

    Pretty print a variable. Useful for debugging.
- name: PrefixLoader
  id: api/index#jinja2.PrefixLoader
  summary: A loader that is passed a dict of loaders where each loader is bound to a prefix
  description: |-
    `class jinja2.PrefixLoader(mapping, delimiter='/')`

    A loader that is passed a dict of loaders where each loader is bound to a prefix. The prefix is delimited from the template by a slash per default, which can be changed by setting the `delimiter` argument to something else:

    ``` python
    loader = PrefixLoader({
        'app1':     PackageLoader('mypackage.app1'),
        'app2':     PackageLoader('mypackage.app2')
    })
    ```

    By loading `'app1/index.html'` the file from the app1 package is loaded, by loading `'app2/index.html'` the file from the second.

    Parameters:

    - **mapping** ([Mapping](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [BaseLoader](#jinja2.BaseLoader "jinja2.loaders.BaseLoader")*\]*) –
    - **delimiter** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
- name: random()
  id: templates/index#jinja-filters.random
  summary: Return a random item from the sequence
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.random(seq: 't.Sequence[V]') → 't.Union[V, Undefined]'`

    Return a random item from the sequence.
- name: range()
  id: templates/index#jinja-globals.range
  summary: Return a list containing an arithmetic progression of integers
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-globals.range([start, ]stop[, step])`

    Return a list containing an arithmetic progression of integers. `range(i, j)` returns `[i, i+1, i+2, ..., j-1]`; start (!) defaults to `0`. When step is given, it specifies the increment (or decrement). For example, `range(4)` and `range(0, 4, 1)` return `[0, 1, 2, 3]`. The end point is omitted! These are exactly the valid indices for a list of 4 elements.

    This is useful to repeat a template block multiple times, e.g. to fill a list. Imagine you have 7 users in the list but you want to render three empty items to enforce a height with CSS:

    ``` html+jinja
    <ul>
    {% for user in users %}
        <li>{{ user.username }}</li>
    {% endfor %}
    {% for number in range(10 - users|count) %}
        <li class="empty"><span>...</span></li>
    {% endfor %}
    </ul>
    ```
- name: reject()
  id: templates/index#jinja-filters.reject
  summary: Filters a sequence of objects by applying a test to each object, and rejecting the objects with the test succeeding
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.reject(value: 't.Iterable[V]', *args: Any, **kwargs: Any) → 't.Iterator[V]'`

    Filters a sequence of objects by applying a test to each object, and rejecting the objects with the test succeeding.

    If no test is specified, each object will be evaluated as a boolean.

    Example usage:

    ``` jinja
    {{ numbers|reject("odd") }}
    ```

    Similar to a generator comprehension such as:

    ``` python
    (n for n in numbers if not test_odd(n))
    ```

    Changelog

    New in version 2.7.
- name: rejectattr()
  id: templates/index#jinja-filters.rejectattr
  summary: Filters a sequence of objects by applying a test to the specified attribute of each object, and rejecting the objects with the test succeeding
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.rejectattr(value: 't.Iterable[V]', *args: Any, **kwargs: Any) → 't.Iterator[V]'`

    Filters a sequence of objects by applying a test to the specified attribute of each object, and rejecting the objects with the test succeeding.

    If no test is specified, the attribute’s value will be evaluated as a boolean.

    ``` jinja
    {{ users|rejectattr("is_active") }}
    {{ users|rejectattr("email", "none") }}
    ```

    Similar to a generator comprehension such as:

    ``` python
    (u for user in users if not user.is_active)
    (u for user in users if not test_none(user.email))
    ```

    Changelog

    New in version 2.7.
- name: replace()
  id: templates/index#jinja-filters.replace
  summary: Return a copy of the value with all occurrences of a substring replaced with a new one
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.replace(s: str, old: str, new: str, count: int | None = None) → str`

    Return a copy of the value with all occurrences of a substring replaced with a new one. The first argument is the substring that should be replaced, the second is the replacement string. If the optional third argument `count` is given, only the first `count` occurrences are replaced:

    ``` jinja
    {{ "Hello World"|replace("Hello", "Goodbye") }}
        -> Goodbye World

    {{ "aaaaargh"|replace("a", "d'oh, ", 2) }}
        -> d'oh, d'oh, aaargh
    ```
- name: reverse()
  id: templates/index#jinja-filters.reverse
  summary: Reverse the object or return an iterator that iterates over it the other way round
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.reverse(value: str | Iterable[V]) → str | Iterable[V]`

    Reverse the object or return an iterator that iterates over it the other way round.
- name: round()
  id: templates/index#jinja-filters.round
  summary: Round the number to a given precision
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.round(value: float, precision: int = 0, method: 'te.Literal["common", "ceil", "floor"]' = 'common') → float`

    Round the number to a given precision. The first parameter specifies the precision (default is `0`), the second the rounding method:

    - `'common'` rounds either up or down
    - `'ceil'` always rounds up
    - `'floor'` always rounds down

    If you don’t specify a method `'common'` is used.

    ``` jinja
    {{ 42.55|round }}
        -> 43.0
    {{ 42.55|round(1, 'floor') }}
        -> 42.5
    ```

    Note that even if rounded to 0 precision, a float is returned. If you need a real integer, pipe it through `int`:

    ``` jinja
    {{ 42.55|round|int }}
        -> 43
    ```
- name: safe()
  id: templates/index#jinja-filters.safe
  summary: Mark the value as safe which means that in an environment with automatic escaping enabled this variable will not be escaped
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.safe(value: str) → markupsafe.Markup`

    Mark the value as safe which means that in an environment with automatic escaping enabled this variable will not be escaped.
- name: sameas()
  id: templates/index#jinja-tests.sameas
  summary: null
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.sameas(value: Any, other: Any) → bool`

    Check if an object points to the same memory address than another object:

    ``` jinja
    {% if foo.attribute is sameas false %}
        the foo attribute really is the `False` singleton
    {% endif %}
    ```
- name: Sandbox
  id: sandbox/index
  summary: The Jinja sandbox can be used to render untrusted templates
  description: "# Sandbox\n\nThe Jinja sandbox can be used to render untrusted templates. Access to attributes, method calls, operators, mutating data structures, and string formatting can be intercepted and prohibited.\n\n``` pycon\n>>> from jinja2.sandbox import SandboxedEnvironment\n>>> env = SandboxedEnvironment()\n>>> func = lambda: \"Hello, Sandbox!\"\n>>> env.from_string(\"{{ func() }}\").render(func=func)\n'Hello, Sandbox!'\n>>> env.from_string(\"{{ func.__code__.co_code }}\").render(func=func)\nTraceback (most recent call last):\n  ...\nSecurityError: access to attribute '__code__' of 'function' object is unsafe.\n```\n\nA sandboxed environment can be useful, for example, to allow users of an internal reporting system to create custom emails. You would document what data is available in the templates, then the user would write a template using that information. Your code would generate the report data and pass it to the user’s sandboxed template to render.\n\n## Security Considerations\n\nThe sandbox alone is not a solution for perfect security. Keep these things in mind when using the sandbox.\n\nTemplates can still raise errors when compiled or rendered. Your code should attempt to catch errors instead of crashing.\n\nIt is possible to construct a relatively small template that renders to a very large amount of output, which could correspond to a high use of CPU or memory. You should run your application with limits on resources such as CPU and memory to mitigate this.\n\nJinja only renders text, it does not understand, for example, JavaScript code. Depending on how the rendered template will be used, you may need to do other postprocessing to restrict the output.\n\nPass only the data that is relevant to the template. Avoid passing global data, or objects with methods that have side effects. By default the sandbox prevents private and internal attribute access. You can override `is_safe_attribute()` to further restrict attributes access. Decorate methods with `unsafe()` to prevent calling them from templates when passing objects as data. Use `ImmutableSandboxedEnvironment` to prevent modifying lists and dictionaries.\n\n## API\n\n`class jinja2.sandbox.SandboxedEnvironment([options])`  \nThe sandboxed environment. It works like the regular environment but tells the compiler to generate sandboxed code. Additionally subclasses of this environment may override the methods that tell the runtime what attributes or functions are safe to access.\n\nIf the template tries to access insecure code a [`SecurityError`](#jinja2.sandbox.SecurityError \"jinja2.sandbox.SecurityError\") is raised. However also other exceptions may occur during the rendering so the caller has to ensure that all exceptions are caught.\n\nParameters:  \n- **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n`call_binop(context, operator, left, right)`  \nFor intercepted binary operator calls ([`intercepted_binops()`](#jinja2.sandbox.SandboxedEnvironment.intercepted_binops \"jinja2.sandbox.SandboxedEnvironment.intercepted_binops\")) this function is executed instead of the builtin operator. This can be used to fine tune the behavior of certain operators.\n\nChangelog\n\nNew in version 2.6.\n\nParameters:  \n- **context** ([Context](../api/index#jinja2.runtime.Context \"jinja2.runtime.Context\")) –\n- **operator** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **left** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **right** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\nReturn type:  \n[Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")\n\n`call_unop(context, operator, arg)`  \nFor intercepted unary operator calls ([`intercepted_unops()`](#jinja2.sandbox.SandboxedEnvironment.intercepted_unops \"jinja2.sandbox.SandboxedEnvironment.intercepted_unops\")) this function is executed instead of the builtin operator. This can be used to fine tune the behavior of certain operators.\n\nChangelog\n\nNew in version 2.6.\n\nParameters:  \n- **context** ([Context](../api/index#jinja2.runtime.Context \"jinja2.runtime.Context\")) –\n- **operator** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **arg** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\nReturn type:  \n[Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")\n\n`default_binop_table: Dict[str, Callable[[Any, Any], Any]] = {'%': <built-in function mod>, '*': <built-in function mul>, '**': <built-in function pow>, '+': <built-in function add>, '-': <built-in function sub>, '/': <built-in function truediv>, '//': <built-in function floordiv>}`  \ndefault callback table for the binary operators. A copy of this is available on each instance of a sandboxed environment as `binop_table`\n\n`default_unop_table: Dict[str, Callable[[Any], Any]] = {'+': <built-in function pos>, '-': <built-in function neg>}`  \ndefault callback table for the unary operators. A copy of this is available on each instance of a sandboxed environment as `unop_table`\n\n`intercepted_binops: FrozenSet[str] = frozenset({})`  \na set of binary operators that should be intercepted. Each operator that is added to this set (empty by default) is delegated to the [`call_binop()`](#jinja2.sandbox.SandboxedEnvironment.call_binop \"jinja2.sandbox.SandboxedEnvironment.call_binop\") method that will perform the operator. The default operator callback is specified by `binop_table`.\n\nThe following binary operators are interceptable: `//`, `%`, `+`, `*`, `-`, `/`, and `**`\n\nThe default operation form the operator table corresponds to the builtin function. Intercepted calls are always slower than the native operator call, so make sure only to intercept the ones you are interested in.\n\nChangelog\n\nNew in version 2.6.\n\n`intercepted_unops: FrozenSet[str] = frozenset({})`  \na set of unary operators that should be intercepted. Each operator that is added to this set (empty by default) is delegated to the [`call_unop()`](#jinja2.sandbox.SandboxedEnvironment.call_unop \"jinja2.sandbox.SandboxedEnvironment.call_unop\") method that will perform the operator. The default operator callback is specified by `unop_table`.\n\nThe following unary operators are interceptable: `+`, `-`\n\nThe default operation form the operator table corresponds to the builtin function. Intercepted calls are always slower than the native operator call, so make sure only to intercept the ones you are interested in.\n\nChangelog\n\nNew in version 2.6.\n\n`is_safe_attribute(obj, attr, value)`  \nThe sandboxed environment will call this method to check if the attribute of an object is safe to access. Per default all attributes starting with an underscore are considered private as well as the special attributes of internal python objects as returned by the [`is_internal_attribute()`](#jinja2.sandbox.is_internal_attribute \"jinja2.sandbox.is_internal_attribute\") function.\n\nParameters:  \n- **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attr** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n- **value** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\nReturn type:  \n[bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")\n\n`is_safe_callable(obj)`  \nCheck if an object is safely callable. By default callables are considered safe unless decorated with [`unsafe()`](#jinja2.sandbox.unsafe \"jinja2.sandbox.unsafe\").\n\nThis also recognizes the Django convention of setting `func.alters_data = True`.\n\nParameters:  \n**obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\nReturn type:  \n[bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")\n\n`class jinja2.sandbox.ImmutableSandboxedEnvironment([options])`  \nWorks exactly like the regular `SandboxedEnvironment` but does not permit modifications on the builtin mutable objects `list`, `set`, and `dict` by using the [`modifies_known_mutable()`](#jinja2.sandbox.modifies_known_mutable \"jinja2.sandbox.modifies_known_mutable\") function.\n\nParameters:  \n- **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\n&nbsp;\n\n`exception jinja2.sandbox.SecurityError(message=None)`  \nRaised if a template tries to do something insecure if the sandbox is enabled.\n\nParameters:  \n**message** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\") *\\|* *None*) –\n\nReturn type:  \nNone\n\n&nbsp;\n\n`jinja2.sandbox.unsafe(f)`  \nMarks a function or method as unsafe.\n\nParameters:  \n**f** (*F*) –\n\nReturn type:  \n*F*\n\n&nbsp;\n\n`jinja2.sandbox.is_internal_attribute(obj, attr)`  \nTest if the attribute given is an internal python attribute. For example this function returns `True` for the `func_code` attribute of python objects. This is useful if the environment method [`is_safe_attribute()`](#jinja2.sandbox.SandboxedEnvironment.is_safe_attribute \"jinja2.sandbox.SandboxedEnvironment.is_safe_attribute\") is overridden.\n\n``` python\n>>> from jinja2.sandbox import is_internal_attribute\n>>> is_internal_attribute(str, \"mro\")\nTrue\n>>> is_internal_attribute(str, \"upper\")\nFalse\n```\n\nParameters:  \n- **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attr** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\nReturn type:  \n[bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")\n\n&nbsp;\n\n`jinja2.sandbox.modifies_known_mutable(obj, attr)`  \nThis function checks if an attribute on a builtin mutable object (list, dict, set or deque) or the corresponding ABCs would modify it if called.\n\n``` python\n>>> modifies_known_mutable({}, \"clear\")\nTrue\n>>> modifies_known_mutable({}, \"keys\")\nFalse\n>>> modifies_known_mutable([], \"append\")\nTrue\n>>> modifies_known_mutable([], \"index\")\nFalse\n```\n\nIf called with an unsupported object, `False` is returned.\n\n``` python\n>>> modifies_known_mutable(\"foo\", \"upper\")\nFalse\n```\n\nParameters:  \n- **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **attr** ([str](https://docs.python.org/3/library/stdtypes.html#str \"(in Python v3.11)\")) –\n\nReturn type:  \n[bool](https://docs.python.org/3/library/functions.html#bool \"(in Python v3.11)\")\n\n## Operator Intercepting\n\nFor performance, Jinja outputs operators directly when compiling. This means it’s not possible to intercept operator behavior by overriding `SandboxEnvironment.call` by default, because operator special methods are handled by the Python interpreter, and might not correspond with exactly one method depending on the operator’s use.\n\nThe sandbox can instruct the compiler to output a function to intercept certain operators instead. Override [`SandboxedEnvironment.intercepted_binops`](#jinja2.sandbox.SandboxedEnvironment.intercepted_binops \"jinja2.sandbox.SandboxedEnvironment.intercepted_binops\") and [`SandboxedEnvironment.intercepted_unops`](#jinja2.sandbox.SandboxedEnvironment.intercepted_unops \"jinja2.sandbox.SandboxedEnvironment.intercepted_unops\") with the operator symbols you want to intercept. The compiler will replace the symbols with calls to [`SandboxedEnvironment.call_binop()`](#jinja2.sandbox.SandboxedEnvironment.call_binop \"jinja2.sandbox.SandboxedEnvironment.call_binop\") and [`SandboxedEnvironment.call_unop()`](#jinja2.sandbox.SandboxedEnvironment.call_unop \"jinja2.sandbox.SandboxedEnvironment.call_unop\") instead. The default implementation of those methods will use `SandboxedEnvironment.binop_table` and `SandboxedEnvironment.unop_table` to translate operator symbols into [`operator`](https://docs.python.org/3/library/operator.html#module-operator \"(in Python v3.11)\") functions.\n\nFor example, the power (`**`) operator can be disabled:\n\n``` python\nfrom jinja2.sandbox import SandboxedEnvironment\n\nclass MyEnvironment(SandboxedEnvironment):\n    intercepted_binops = frozenset([\"**\"])\n\n    def call_binop(self, context, operator, left, right):\n        if operator == \"**\":\n            return self.undefined(\"The power (**) operator is unavailable.\")\n\n        return super().call_binop(self, context, operator, left, right)\n```\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/sandbox/](https://jinja.palletsprojects.com/en/3.1.x/sandbox/)"
- name: SandboxedEnvironment
  id: sandbox/index#jinja2.sandbox.SandboxedEnvironment
  summary: The sandboxed environment
  belongs_to: Sandbox
  description: |-
    `class jinja2.sandbox.SandboxedEnvironment([options])`

    The sandboxed environment. It works like the regular environment but tells the compiler to generate sandboxed code. Additionally subclasses of this environment may override the methods that tell the runtime what attributes or functions are safe to access.

    If the template tries to access insecure code a [`SecurityError`](#jinja2.sandbox.SecurityError "jinja2.sandbox.SecurityError") is raised. However also other exceptions may occur during the rendering so the caller has to ensure that all exceptions are caught.

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: SandboxedEnvironment.call_binop()
  id: sandbox/index#jinja2.sandbox.SandboxedEnvironment.call_binop
  summary: For intercepted binary operator calls (intercepted_binops()) this function is executed instead of the builtin operator
  belongs_to: Sandbox
  description: |-
    `call_binop(context, operator, left, right)`

    For intercepted binary operator calls ([`intercepted_binops()`](#jinja2.sandbox.SandboxedEnvironment.intercepted_binops "jinja2.sandbox.SandboxedEnvironment.intercepted_binops")) this function is executed instead of the builtin operator. This can be used to fine tune the behavior of certain operators.

    Changelog

    New in version 2.6.

    Parameters:

    - **context** ([Context](../api/index#jinja2.runtime.Context "jinja2.runtime.Context")) –
    - **operator** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **left** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **right** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: SandboxedEnvironment.call_unop()
  id: sandbox/index#jinja2.sandbox.SandboxedEnvironment.call_unop
  summary: For intercepted unary operator calls (intercepted_unops()) this function is executed instead of the builtin operator
  belongs_to: Sandbox
  description: |-
    `call_unop(context, operator, arg)`

    For intercepted unary operator calls ([`intercepted_unops()`](#jinja2.sandbox.SandboxedEnvironment.intercepted_unops "jinja2.sandbox.SandboxedEnvironment.intercepted_unops")) this function is executed instead of the builtin operator. This can be used to fine tune the behavior of certain operators.

    Changelog

    New in version 2.6.

    Parameters:

    - **context** ([Context](../api/index#jinja2.runtime.Context "jinja2.runtime.Context")) –
    - **operator** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **arg** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: SandboxedEnvironment.default_binop_table
  id: sandbox/index#jinja2.sandbox.SandboxedEnvironment.default_binop_table
  summary: default callback table for the binary operators
  belongs_to: Sandbox
  description: |-
    `default_binop_table: Dict[str, Callable[[Any, Any], Any]] = {'%': <built-in function mod>, '*': <built-in function mul>, '**': <built-in function pow>, '+': <built-in function add>, '-': <built-in function sub>, '/': <built-in function truediv>, '//': <built-in function floordiv>}`

    default callback table for the binary operators. A copy of this is available on each instance of a sandboxed environment as `binop_table`
- name: SandboxedEnvironment.default_unop_table
  id: sandbox/index#jinja2.sandbox.SandboxedEnvironment.default_unop_table
  summary: default callback table for the unary operators
  belongs_to: Sandbox
  description: |-
    `default_unop_table: Dict[str, Callable[[Any], Any]] = {'+': <built-in function pos>, '-': <built-in function neg>}`

    default callback table for the unary operators. A copy of this is available on each instance of a sandboxed environment as `unop_table`
- name: SandboxedEnvironment.intercepted_binops
  id: sandbox/index#jinja2.sandbox.SandboxedEnvironment.intercepted_binops
  summary: a set of binary operators that should be intercepted
  belongs_to: Sandbox
  description: |-
    `intercepted_binops: FrozenSet[str] = frozenset({})`

    a set of binary operators that should be intercepted. Each operator that is added to this set (empty by default) is delegated to the [`call_binop()`](#jinja2.sandbox.SandboxedEnvironment.call_binop "jinja2.sandbox.SandboxedEnvironment.call_binop") method that will perform the operator. The default operator callback is specified by `binop_table`.

    The following binary operators are interceptable: `//`, `%`, `+`, `*`, `-`, `/`, and `**`

    The default operation form the operator table corresponds to the builtin function. Intercepted calls are always slower than the native operator call, so make sure only to intercept the ones you are interested in.

    Changelog

    New in version 2.6.
- name: SandboxedEnvironment.intercepted_unops
  id: sandbox/index#jinja2.sandbox.SandboxedEnvironment.intercepted_unops
  summary: a set of unary operators that should be intercepted
  belongs_to: Sandbox
  description: |-
    `intercepted_unops: FrozenSet[str] = frozenset({})`

    a set of unary operators that should be intercepted. Each operator that is added to this set (empty by default) is delegated to the [`call_unop()`](#jinja2.sandbox.SandboxedEnvironment.call_unop "jinja2.sandbox.SandboxedEnvironment.call_unop") method that will perform the operator. The default operator callback is specified by `unop_table`.

    The following unary operators are interceptable: `+`, `-`

    The default operation form the operator table corresponds to the builtin function. Intercepted calls are always slower than the native operator call, so make sure only to intercept the ones you are interested in.

    Changelog

    New in version 2.6.
- name: SandboxedEnvironment.is_safe_attribute()
  id: sandbox/index#jinja2.sandbox.SandboxedEnvironment.is_safe_attribute
  summary: The sandboxed environment will call this method to check if the attribute of an object is safe to access
  belongs_to: Sandbox
  description: |-
    `is_safe_attribute(obj, attr, value)`

    The sandboxed environment will call this method to check if the attribute of an object is safe to access. Per default all attributes starting with an underscore are considered private as well as the special attributes of internal python objects as returned by the [`is_internal_attribute()`](#jinja2.sandbox.is_internal_attribute "jinja2.sandbox.is_internal_attribute") function.

    Parameters:

    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attr** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **value** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: SandboxedEnvironment.is_safe_callable()
  id: sandbox/index#jinja2.sandbox.SandboxedEnvironment.is_safe_callable
  summary: Check if an object is safely callable
  belongs_to: Sandbox
  description: |-
    `is_safe_callable(obj)`

    Check if an object is safely callable. By default callables are considered safe unless decorated with [`unsafe()`](#jinja2.sandbox.unsafe "jinja2.sandbox.unsafe").

    This also recognizes the Django convention of setting `func.alters_data = True`.

    Parameters:

    **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: Scope
  id: extensions/index#jinja2.nodes.Scope
  summary: An artificial scope
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Scope(body)`

    An artificial scope.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: ScopedEvalContextModifier
  id: extensions/index#jinja2.nodes.ScopedEvalContextModifier
  summary: Modifies the eval context and reverts it later
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.ScopedEvalContextModifier(options, body)`

    Modifies the eval context and reverts it later. Works exactly like [`EvalContextModifier`](#jinja2.nodes.EvalContextModifier "jinja2.nodes.EvalContextModifier") but will only modify the [`EvalContext`](../api/index#jinja2.nodes.EvalContext "jinja2.nodes.EvalContext") for nodes in the `body`.

    Node type:

    [`EvalContextModifier`](#jinja2.nodes.EvalContextModifier "jinja2.nodes.EvalContextModifier")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: SecurityError
  id: sandbox/index#jinja2.sandbox.SecurityError
  summary: Raised if a template tries to do something insecure if the sandbox is enabled
  belongs_to: Sandbox
  description: |-
    `exception jinja2.sandbox.SecurityError(message=None)`

    Raised if a template tries to do something insecure if the sandbox is enabled.

    Parameters:

    **message** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: select()
  id: templates/index#jinja-filters.select
  summary: Filters a sequence of objects by applying a test to each object, and only selecting the objects with the test succeeding
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.select(value: 't.Iterable[V]', *args: Any, **kwargs: Any) → 't.Iterator[V]'`

    Filters a sequence of objects by applying a test to each object, and only selecting the objects with the test succeeding.

    If no test is specified, each object will be evaluated as a boolean.

    Example usage:

    ``` jinja
    {{ numbers|select("odd") }}
    {{ numbers|select("odd") }}
    {{ numbers|select("divisibleby", 3) }}
    {{ numbers|select("lessthan", 42) }}
    {{ strings|select("equalto", "mystring") }}
    ```

    Similar to a generator comprehension such as:

    ``` python
    (n for n in numbers if test_odd(n))
    (n for n in numbers if test_divisibleby(n, 3))
    ```

    Changelog

    New in version 2.7.
- name: select_autoescape()
  id: api/index#jinja2.select_autoescape
  summary: Intelligently sets the initial value of autoescaping based on the filename of the template
  description: |-
    `jinja2.select_autoescape(enabled_extensions=('html', 'htm', 'xml'), disabled_extensions=(), default_for_string=True, default=False)`

    Intelligently sets the initial value of autoescaping based on the filename of the template. This is the recommended way to configure autoescaping if you do not want to write a custom function yourself.

    If you want to enable it for all templates created from strings or for all templates with `.html` and `.xml` extensions:

    ``` python
    from jinja2 import Environment, select_autoescape
    env = Environment(autoescape=select_autoescape(
        enabled_extensions=('html', 'xml'),
        default_for_string=True,
    ))
    ```

    Example configuration to turn it on at all times except if the template ends with `.txt`:

    ``` python
    from jinja2 import Environment, select_autoescape
    env = Environment(autoescape=select_autoescape(
        disabled_extensions=('txt',),
        default_for_string=True,
        default=True,
    ))
    ```

    The `enabled_extensions` is an iterable of all the extensions that autoescaping should be enabled for. Likewise `disabled_extensions` is a list of all templates it should be disabled for. If a template is loaded from a string then the default from `default_for_string` is used. If nothing matches then the initial value of autoescaping is set to the value of `default`.

    For security reasons this function operates case insensitive.

    Changelog

    New in version 2.9.

    Parameters:

    - **enabled_extensions** ([Collection](https://docs.python.org/3/library/typing.html#typing.Collection "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]*) –
    - **disabled_extensions** ([Collection](https://docs.python.org/3/library/typing.html#typing.Collection "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]*) –
    - **default_for_string** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **default** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") \| None\], [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")\]

    Here a recommended setup that enables autoescaping for templates ending in `'.html'`, `'.htm'` and `'.xml'` and disabling it by default for all other extensions. You can use the [`select_autoescape()`](#jinja2.select_autoescape "jinja2.select_autoescape") function for this:

    ``` python
    from jinja2 import Environment, PackageLoader, select_autoescape
    env = Environment(autoescape=select_autoescape(['html', 'htm', 'xml']),
                      loader=PackageLoader('mypackage'))
    ```

    The `select_autoescape()` function returns a function that works roughly like this:

    ``` python
    def autoescape(template_name):
        if template_name is None:
            return False
        if template_name.endswith(('.html', '.htm', '.xml'))
    ```

    When implementing a guessing autoescape function, make sure you also accept `None` as valid template name. This will be passed when generating templates from strings. You should always configure autoescaping as defaults in the future might change.

    Inside the templates the behaviour can be temporarily changed by using the `autoescape` block (see [Autoescape Overrides](../templates/index#autoescape-overrides)).

    ## Notes on Identifiers

    Jinja uses Python naming rules. Valid identifiers can be any combination of characters accepted by Python.

    Filters and tests are looked up in separate namespaces and have slightly modified identifier syntax. Filters and tests may contain dots to group filters and tests by topic. For example it’s perfectly valid to add a function into the filter dict and call it `to.str`. The regular expression for filter and test identifiers is `[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)*`.

    ## Undefined Types

    These classes can be used as undefined types. The [`Environment`](#jinja2.Environment "jinja2.Environment") constructor takes an `undefined` parameter that can be one of those classes or a custom subclass of [`Undefined`](#jinja2.Undefined "jinja2.Undefined"). Whenever the template engine is unable to look up a name or access an attribute one of those objects is created and returned. Some operations on undefined values are then allowed, others fail.

    The closest to regular Python behavior is the [`StrictUndefined`](#jinja2.StrictUndefined "jinja2.StrictUndefined") which disallows all operations beside testing if it’s an undefined object.
- name: selectattr()
  id: templates/index#jinja-filters.selectattr
  summary: Filters a sequence of objects by applying a test to the specified attribute of each object, and only selecting the objects with the test succeeding
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.selectattr(value: 't.Iterable[V]', *args: Any, **kwargs: Any) → 't.Iterator[V]'`

    Filters a sequence of objects by applying a test to the specified attribute of each object, and only selecting the objects with the test succeeding.

    If no test is specified, the attribute’s value will be evaluated as a boolean.

    Example usage:

    ``` jinja
    {{ users|selectattr("is_active") }}
    {{ users|selectattr("email", "none") }}
    ```

    Similar to a generator comprehension such as:

    ``` python
    (u for user in users if user.is_active)
    (u for user in users if test_none(user.email))
    ```

    Changelog

    New in version 2.7.
- name: sequence()
  id: templates/index#jinja-tests.sequence
  summary: Return true if the variable is a sequence
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.sequence(value: Any) → bool`

    Return true if the variable is a sequence. Sequences are variables that are iterable.
- name: Slice
  id: extensions/index#jinja2.nodes.Slice
  summary: Represents a slice object
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Slice(start, stop, step)`

    Represents a slice object. This must only be used as argument for `Subscript`.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: slice()
  id: templates/index#jinja-filters.slice
  summary: Slice an iterator and return a list of lists containing those items
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.slice(value: 't.Collection[V]', slices: int, fill_with: 't.Optional[V]' = None) → 't.Iterator[t.List[V]]'`

    Slice an iterator and return a list of lists containing those items. Useful if you want to create a div containing three ul tags that represent columns:

    ``` html+jinja
    <div class="columnwrapper">
      {%- for column in items|slice(3) %}
        <ul class="column-{{ loop.index }}">
        {%- for item in column %}
          <li>{{ item }}</li>
        {%- endfor %}
        </ul>
      {%- endfor %}
    </div>
    ```

    If you pass it a second argument it’s used to fill missing values on the last iteration.
- name: sort()
  id: templates/index#jinja-filters.sort
  summary: Sort an iterable using Python’s sorted()
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.sort(value: 't.Iterable[V]', reverse: bool = False, case_sensitive: bool = False, attribute: str | int | NoneType = None) → 't.List[V]'`

    Sort an iterable using Python’s [`sorted()`](https://docs.python.org/3/library/functions.html#sorted "(in Python v3.11)").

    ``` jinja
    {% for city in cities|sort %}
        ...
    {% endfor %}
    ```

    Parameters:

    - **reverse** – Sort descending instead of ascending.
    - **case_sensitive** – When sorting strings, sort upper and lower case separately.
    - **attribute** – When sorting objects or dicts, an attribute or key to sort by. Can use dot notation like `"address.city"`. Can be a list of attributes like `"age,name"`.

    The sort is stable, it does not change the relative order of elements that compare equal. This makes it is possible to chain sorts on different attributes and ordering.

    ``` jinja
    {% for user in users|sort(attribute="name")
        |sort(reverse=true, attribute="age") %}
        ...
    {% endfor %}
    ```

    As a shortcut to chaining when the direction is the same for all attributes, pass a comma separate list of attributes.

    ``` jinja
    {% for user in users|sort(attribute="age,name") %}
        ...
    {% endfor %}
    ```

    Changelog

    Changed in version 2.11.0: The `attribute` parameter can be a comma separated list of attributes, e.g. `"age,name"`.

    Changed in version 2.6: The `attribute` parameter was added.
- name: Stmt
  id: extensions/index#jinja2.nodes.Stmt
  summary: Base node for all statements
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Stmt`

    Base node for all statements.

    Node type:

    [`Node`](#jinja2.nodes.Node "jinja2.nodes.Node")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: StrictUndefined
  id: api/index#jinja2.StrictUndefined
  summary: An undefined that barks on print and iteration as well as boolean tests and all kinds of comparisons
  description: |-
    `class jinja2.StrictUndefined`

    An undefined that barks on print and iteration as well as boolean tests and all kinds of comparisons. In other words: you can do nothing with it except checking if it’s defined using the `defined` test.

    ``` python
    >>> foo = StrictUndefined(name='foo')
    >>> str(foo)
    Traceback (most recent call last):
      ...
    jinja2.exceptions.UndefinedError: 'foo' is undefined
    >>> not foo
    Traceback (most recent call last):
      ...
    jinja2.exceptions.UndefinedError: 'foo' is undefined
    >>> foo + 42
    Traceback (most recent call last):
      ...
    jinja2.exceptions.UndefinedError: 'foo' is undefined
    ```

    Parameters:

    - **hint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **exc** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[TemplateRuntimeError](#jinja2.TemplateRuntimeError "jinja2.exceptions.TemplateRuntimeError")*\]*) –

    There is also a factory function that can decorate undefined objects to implement logging on failures:
- name: string()
  id: templates/index#jinja-tests.string
  summary: Return true if the object is a string
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.string(value: Any) → bool`

    Return true if the object is a string.
- name: string()
  id: templates/index#jinja-filters.string
  summary: Convert an object to a string if it isn’t already
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.string(value)`

    Convert an object to a string if it isn’t already. This preserves a `Markup` string rather than converting it back to a basic string, so it will still be marked as safe and won’t be escaped again.

    ``` python
    >>> value = escape("<User 1>")
    >>> value
    Markup('&lt;User 1&gt;')
    >>> escape(str(value))
    Markup('&amp;lt;User 1&amp;gt;')
    >>> escape(soft_str(value))
    Markup('&lt;User 1&gt;')
    ```
- name: striptags()
  id: templates/index#jinja-filters.striptags
  summary: Strip SGML/XML tags and replace adjacent whitespace by one space
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.striptags(value: 't.Union[str, HasHTML]') → str`

    Strip SGML/XML tags and replace adjacent whitespace by one space.
- name: Sub
  id: extensions/index#jinja2.nodes.Sub
  summary: Subtract the right from the left node
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Sub(left, right)`

    Subtract the right from the left node.

    Node type:

    [`BinExpr`](#jinja2.nodes.BinExpr "jinja2.nodes.BinExpr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: sum()
  id: templates/index#jinja-filters.sum
  summary: Returns the sum of a sequence of numbers plus the value of parameter ‘start’ (which defaults to 0)
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.sum(iterable: 't.Iterable[V]', attribute: str | int | NoneType = None, start: V = 0) → V`

    Returns the sum of a sequence of numbers plus the value of parameter ‘start’ (which defaults to 0). When the sequence is empty it returns start.

    It is also possible to sum up only certain attributes:

    ``` jinja
    Total: {{ items|sum(attribute='price') }}
    ```

    Changelog

    Changed in version 2.6: The `attribute` parameter was added to allow summing up over attributes. Also the `start` parameter was moved on to the right.
- name: Template
  id: extensions/index#jinja2.nodes.Template
  summary: Node that represents a template
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Template(body)`

    Node that represents a template. This must be the outermost node that is passed to the compiler.

    Node type:

    [`Node`](#jinja2.nodes.Node "jinja2.nodes.Node")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Template
  id: api/index#jinja2.Template
  summary: A compiled template that can be rendered
  description: |-
    `class jinja2.Template(source, block_start_string='{%', block_end_string='%}', variable_start_string='{{', variable_end_string='}}', comment_start_string='{#', comment_end_string='#}', line_statement_prefix=None, line_comment_prefix=None, trim_blocks=False, lstrip_blocks=False, newline_sequence='\n', keep_trailing_newline=False, extensions=(), optimized=True, undefined=<class 'jinja2.runtime.Undefined'>, finalize=None, autoescape=False, enable_async=False)`

    A compiled template that can be rendered.

    Use the methods on [`Environment`](#jinja2.Environment "jinja2.Environment") to create or load templates. The environment is used to configure how templates are compiled and behave.

    It is also possible to create a template object directly. This is not usually recommended. The constructor takes most of the same arguments as [`Environment`](#jinja2.Environment "jinja2.Environment"). All templates created with the same environment arguments share the same ephemeral `Environment` instance behind the scenes.

    A template object should be considered immutable. Modifications on the object are not supported.

    Parameters:

    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Template](../extensions/index#jinja2.nodes.Template "jinja2.nodes.Template")) –
    - **block_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **block_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **variable_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **variable_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **comment_start_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **comment_end_string** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **line_statement_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **line_comment_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **trim_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **lstrip_blocks** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **newline_sequence** (*te.Literal\['\n',* *'\r\n',* *'\r'\]*) –
    - **keep_trailing_newline** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **extensions** ([Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Extension](../extensions/index#jinja2.ext.Extension "jinja2.ext.Extension")*\]\]*) –
    - **optimized** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **undefined** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[Undefined](#jinja2.Undefined "jinja2.runtime.Undefined")*\]*) –
    - **finalize** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –
    - **autoescape** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None\],* [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")*\]*) –
    - **enable_async** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: Template Designer Documentation
  id: templates/index
  summary: This document describes the syntax and semantics of the template engine and will be most useful as reference to those creating Jinja templates
  description: "# Template Designer Documentation\n\nThis document describes the syntax and semantics of the template engine and will be most useful as reference to those creating Jinja templates. As the template engine is very flexible, the configuration from the application can be slightly different from the code presented here in terms of delimiters and behavior of undefined values.\n\n## Synopsis\n\nA Jinja template is simply a text file. Jinja can generate any text-based format (HTML, XML, CSV, LaTeX, etc.). A Jinja template doesn’t need to have a specific extension: `.html`, `.xml`, or any other extension is just fine.\n\nA template contains **variables** and/or **expressions**, which get replaced with values when a template is *rendered*; and **tags**, which control the logic of the template. The template syntax is heavily inspired by Django and Python.\n\nBelow is a minimal template that illustrates a few basics using the default Jinja configuration. We will cover the details later in this document:\n\n``` html+jinja\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>My Webpage</title>\n</head>\n<body>\n    <ul id=\"navigation\">\n    {% for item in navigation %}\n        <li><a href=\"{{ item.href }}\">{{ item.caption }}</a></li>\n    {% endfor %}\n    </ul>\n\n    <h1>My Webpage</h1>\n    {{ a_variable }}\n\n    {# a comment #}\n</body>\n</html>\n```\n\nThe following example shows the default configuration settings. An application developer can change the syntax configuration from `{% foo %}` to `<% foo %>`, or something similar.\n\nThere are a few kinds of delimiters. The default Jinja delimiters are configured as follows:\n\n- `{% ... %}` for [Statements](#list-of-control-structures)\n- `{{ ... }}` for [Expressions](#expressions) to print to the template output\n- `{# ... #}` for [Comments](#comments) not included in the template output\n\n[Line Statements and Comments](#line-statements) are also possible, though they don’t have default prefix characters. To use them, set `line_statement_prefix` and `line_comment_prefix` when creating the [`Environment`](../api/index#jinja2.Environment \"jinja2.Environment\").\n\n### Template File Extension\n\nAs stated above, any file can be loaded as a template, regardless of file extension. Adding a `.jinja` extension, like `user.html.jinja` may make it easier for some IDEs or editor plugins, but is not required. Autoescaping, introduced later, can be applied based on file extension, so you’ll need to take the extra suffix into account in that case.\n\nAnother good heuristic for identifying templates is that they are in a `templates` folder, regardless of extension. This is a common layout for projects.\n\n## Variables\n\nTemplate variables are defined by the context dictionary passed to the template.\n\nYou can mess around with the variables in templates provided they are passed in by the application. Variables may have attributes or elements on them you can access too. What attributes a variable has depends heavily on the application providing that variable.\n\nYou can use a dot (`.`) to access attributes of a variable in addition to the standard Python `__getitem__` “subscript” syntax (`[]`).\n\nThe following lines do the same thing:\n\n``` html+jinja\n{{ foo.bar }}\n{{ foo['bar'] }}\n```\n\nIt’s important to know that the outer double-curly braces are *not* part of the variable, but the print statement. If you access variables inside tags don’t put the braces around them.\n\nIf a variable or attribute does not exist, you will get back an undefined value. What you can do with that kind of value depends on the application configuration: the default behavior is to evaluate to an empty string if printed or iterated over, and to fail for every other operation.\n\nImplementation\n\nFor the sake of convenience, `foo.bar` in Jinja does the following things on the Python layer:\n\n- check for an attribute called `bar` on `foo` (`getattr(foo, 'bar')`)\n- if there is not, check for an item `'bar'` in `foo` (`foo.__getitem__('bar')`)\n- if there is not, return an undefined object.\n\n`foo['bar']` works mostly the same with a small difference in sequence:\n\n- check for an item `'bar'` in `foo`. (`foo.__getitem__('bar')`)\n- if there is not, check for an attribute called `bar` on `foo`. (`getattr(foo, 'bar')`)\n- if there is not, return an undefined object.\n\nThis is important if an object has an item and attribute with the same name. Additionally, the `attr()` filter only looks up attributes.\n\n## Filters\n\nVariables can be modified by **filters**. Filters are separated from the variable by a pipe symbol (`|`) and may have optional arguments in parentheses. Multiple filters can be chained. The output of one filter is applied to the next.\n\nFor example, `{{ name|striptags|title }}` will remove all HTML Tags from variable `name` and title-case the output (`title(striptags(name))`).\n\nFilters that accept arguments have parentheses around the arguments, just like a function call. For example: `{{ listx|join(', ') }}` will join a list with commas (`str.join(', ', listx)`).\n\nThe [List of Builtin Filters](#builtin-filters) below describes all the builtin filters.\n\n## Tests\n\nBeside filters, there are also so-called “tests” available. Tests can be used to test a variable against a common expression. To test a variable or expression, you add `is` plus the name of the test after the variable. For example, to find out if a variable is defined, you can do `name is defined`, which will then return true or false depending on whether `name` is defined in the current template context.\n\nTests can accept arguments, too. If the test only takes one argument, you can leave out the parentheses. For example, the following two expressions do the same thing:\n\n``` html+jinja\n{% if loop.index is divisibleby 3 %}\n{% if loop.index is divisibleby(3) %}\n```\n\nThe [List of Builtin Tests](#builtin-tests) below describes all the builtin tests.\n\n## Comments\n\nTo comment-out part of a line in a template, use the comment syntax which is by default set to `{# ... #}`. This is useful to comment out parts of the template for debugging or to add information for other template designers or yourself:\n\n``` html+jinja\n{# note: commented-out template because we no longer use this\n    {% for user in users %}\n        ...\n    {% endfor %}\n#}\n```\n\n## Whitespace Control\n\nIn the default configuration:\n\n- a single trailing newline is stripped if present\n- other whitespace (spaces, tabs, newlines etc.) is returned unchanged\n\nIf an application configures Jinja to `trim_blocks`, the first newline after a template tag is removed automatically (like in PHP). The `lstrip_blocks` option can also be set to strip tabs and spaces from the beginning of a line to the start of a block. (Nothing will be stripped if there are other characters before the start of the block.)\n\nWith both `trim_blocks` and `lstrip_blocks` enabled, you can put block tags on their own lines, and the entire block line will be removed when rendered, preserving the whitespace of the contents. For example, without the `trim_blocks` and `lstrip_blocks` options, this template:\n\n``` html+jinja\n<div>\n    {% if True %}\n        yay\n    {% endif %}\n</div>\n```\n\ngets rendered with blank lines inside the div:\n\n``` html+jinja\n<div>\n\n        yay\n\n</div>\n```\n\nBut with both `trim_blocks` and `lstrip_blocks` enabled, the template block lines are removed and other whitespace is preserved:\n\n``` html+jinja\n<div>\n        yay\n</div>\n```\n\nYou can manually disable the `lstrip_blocks` behavior by putting a plus sign (`+`) at the start of a block:\n\n``` html+jinja\n<div>\n        {%+ if something %}yay{% endif %}\n</div>\n```\n\nSimilarly, you can manually disable the `trim_blocks` behavior by putting a plus sign (`+`) at the end of a block:\n\n``` html+jinja\n<div>\n    {% if something +%}\n        yay\n    {% endif %}\n</div>\n```\n\nYou can also strip whitespace in templates by hand. If you add a minus sign (`-`) to the start or end of a block (e.g. a [For](#for-loop) tag), a comment, or a variable expression, the whitespaces before or after that block will be removed:\n\n``` html+jinja\n{% for item in seq -%}\n    {{ item }}\n{%- endfor %}\n```\n\nThis will yield all elements without whitespace between them. If `seq` was a list of numbers from `1` to `9`, the output would be `123456789`.\n\nIf [Line Statements](#line-statements) are enabled, they strip leading whitespace automatically up to the beginning of the line.\n\nBy default, Jinja also removes trailing newlines. To keep single trailing newlines, configure Jinja to `keep_trailing_newline`.\n\nNote\n\nYou must not add whitespace between the tag and the minus sign.\n\n**valid**:\n\n``` html+jinja\n{%- if foo -%}...{% endif %}\n```\n\n**invalid**:\n\n``` html+jinja\n{% - if foo - %}...{% endif %}\n```\n\n## Escaping\n\nIt is sometimes desirable – even necessary – to have Jinja ignore parts it would otherwise handle as variables or blocks. For example, if, with the default syntax, you want to use `{{` as a raw string in a template and not start a variable, you have to use a trick.\n\nThe easiest way to output a literal variable delimiter (`{{`) is by using a variable expression:\n\n``` html+jinja\n{{ '{{' }}\n```\n\nFor bigger sections, it makes sense to mark a block `raw`. For example, to include example Jinja syntax in a template, you can use this snippet:\n\n``` html+jinja\n{% raw %}\n    <ul>\n    {% for item in seq %}\n        <li>{{ item }}</li>\n    {% endfor %}\n    </ul>\n{% endraw %}\n```\n\nNote\n\nMinus sign at the end of `{% raw -%}` tag cleans all the spaces and newlines preceding the first character of your raw data.\n\n## Line Statements\n\nIf line statements are enabled by the application, it’s possible to mark a line as a statement. For example, if the line statement prefix is configured to `#`, the following two examples are equivalent:\n\n``` html+jinja\n<ul>\n# for item in seq\n    <li>{{ item }}</li>\n# endfor\n</ul>\n\n<ul>\n{% for item in seq %}\n    <li>{{ item }}</li>\n{% endfor %}\n</ul>\n```\n\nThe line statement prefix can appear anywhere on the line as long as no text precedes it. For better readability, statements that start a block (such as `for`, `if`, `elif` etc.) may end with a colon:\n\n``` html+jinja\n# for item in seq:\n    ...\n# endfor\n```\n\nNote\n\nLine statements can span multiple lines if there are open parentheses, braces or brackets:\n\n``` html+jinja\n<ul>\n# for href, caption in [('index.html', 'Index'),\n                        ('about.html', 'About')]:\n    <li><a href=\"{{ href }}\">{{ caption }}</a></li>\n# endfor\n</ul>\n```\n\nSince Jinja 2.2, line-based comments are available as well. For example, if the line-comment prefix is configured to be `##`, everything from `##` to the end of the line is ignored (excluding the newline sign):\n\n``` html+jinja\n# for item in seq:\n    <li>{{ item }}</li>     ## this comment is ignored\n# endfor\n```\n\n## Template Inheritance\n\nThe most powerful part of Jinja is template inheritance. Template inheritance allows you to build a base “skeleton” template that contains all the common elements of your site and defines **blocks** that child templates can override.\n\nSounds complicated but is very basic. It’s easiest to understand it by starting with an example.\n\n### Base Template\n\nThis template, which we’ll call `base.html`, defines a simple HTML skeleton document that you might use for a simple two-column page. It’s the job of “child” templates to fill the empty blocks with content:\n\n``` html+jinja\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    {% block head %}\n    <link rel=\"stylesheet\" href=\"style.css\" />\n    <title>{% block title %}{% endblock %} - My Webpage</title>\n    {% endblock %}\n</head>\n<body>\n    <div id=\"content\">{% block content %}{% endblock %}</div>\n    <div id=\"footer\">\n        {% block footer %}\n        &copy; Copyright 2008 by <a href=\"http://domain.invalid/\">you</a>.\n        {% endblock %}\n    </div>\n</body>\n</html>\n```\n\nIn this example, the `{% block %}` tags define four blocks that child templates can fill in. All the `block` tag does is tell the template engine that a child template may override those placeholders in the template.\n\n`block` tags can be inside other blocks such as `if`, but they will always be executed regardless of if the `if` block is actually rendered.\n\n### Child Template\n\nA child template might look like this:\n\n``` html+jinja\n{% extends \"base.html\" %}\n{% block title %}Index{% endblock %}\n{% block head %}\n    {{ super() }}\n    <style type=\"text/css\">\n        .important { color: #336699; }\n    </style>\n{% endblock %}\n{% block content %}\n    <h1>Index</h1>\n    <p class=\"important\">\n      Welcome to my awesome homepage.\n    </p>\n{% endblock %}\n```\n\nThe `{% extends %}` tag is the key here. It tells the template engine that this template “extends” another template. When the template system evaluates this template, it first locates the parent. The extends tag should be the first tag in the template. Everything before it is printed out normally and may cause confusion. For details about this behavior and how to take advantage of it, see [Null-Default Fallback](../tricks/index#null-default-fallback). Also a block will always be filled in regardless of whether the surrounding condition is evaluated to be true or false.\n\nThe filename of the template depends on the template loader. For example, the [`FileSystemLoader`](../api/index#jinja2.FileSystemLoader \"jinja2.FileSystemLoader\") allows you to access other templates by giving the filename. You can access templates in subdirectories with a slash:\n\n``` html+jinja\n{% extends \"layout/default.html\" %}\n```\n\nBut this behavior can depend on the application embedding Jinja. Note that since the child template doesn’t define the `footer` block, the value from the parent template is used instead.\n\nYou can’t define multiple `{% block %}` tags with the same name in the same template. This limitation exists because a block tag works in “both” directions. That is, a block tag doesn’t just provide a placeholder to fill - it also defines the content that fills the placeholder in the *parent*. If there were two similarly-named `{% block %}` tags in a template, that template’s parent wouldn’t know which one of the blocks’ content to use.\n\nIf you want to print a block multiple times, you can, however, use the special `self` variable and call the block with that name:\n\n``` html+jinja\n<title>{% block title %}{% endblock %}</title>\n<h1>{{ self.title() }}</h1>\n{% block body %}{% endblock %}\n```\n\n### Super Blocks\n\nIt’s possible to render the contents of the parent block by calling `super()`. This gives back the results of the parent block:\n\n``` html+jinja\n{% block sidebar %}\n    <h3>Table Of Contents</h3>\n    ...\n    {{ super() }}\n{% endblock %}\n```\n\n### Nesting extends\n\nIn the case of multiple levels of `{% extends %}`, `super` references may be chained (as in `super.super()`) to skip levels in the inheritance tree.\n\nFor example:\n\n``` html+jinja\n# parent.tmpl\nbody: {% block body %}Hi from parent.{% endblock %}\n\n# child.tmpl\n{% extends \"parent.tmpl\" %}\n{% block body %}Hi from child. {{ super() }}{% endblock %}\n\n# grandchild1.tmpl\n{% extends \"child.tmpl\" %}\n{% block body %}Hi from grandchild1.{% endblock %}\n\n# grandchild2.tmpl\n{% extends \"child.tmpl\" %}\n{% block body %}Hi from grandchild2. {{ super.super() }} {% endblock %}\n```\n\nRendering `child.tmpl` will give `body: Hi from child. Hi from parent.`\n\nRendering `grandchild1.tmpl` will give `body: Hi from grandchild1.`\n\nRendering `grandchild2.tmpl` will give `body: Hi from grandchild2. Hi from parent.`\n\n### Named Block End-Tags\n\nJinja allows you to put the name of the block after the end tag for better readability:\n\n``` html+jinja\n{% block sidebar %}\n    {% block inner_sidebar %}\n        ...\n    {% endblock inner_sidebar %}\n{% endblock sidebar %}\n```\n\nHowever, the name after the `endblock` word must match the block name.\n\n### Block Nesting and Scope\n\nBlocks can be nested for more complex layouts. However, per default blocks may not access variables from outer scopes:\n\n``` html+jinja\n{% for item in seq %}\n    <li>{% block loop_item %}{{ item }}{% endblock %}</li>\n{% endfor %}\n```\n\nThis example would output empty `<li>` items because `item` is unavailable inside the block. The reason for this is that if the block is replaced by a child template, a variable would appear that was not defined in the block or passed to the context.\n\nStarting with Jinja 2.2, you can explicitly specify that variables are available in a block by setting the block to “scoped” by adding the `scoped` modifier to a block declaration:\n\n``` html+jinja\n{% for item in seq %}\n    <li>{% block loop_item scoped %}{{ item }}{% endblock %}</li>\n{% endfor %}\n```\n\nWhen overriding a block, the `scoped` modifier does not have to be provided.\n\n### Required Blocks\n\nBlocks can be marked as `required`. They must be overridden at some point, but not necessarily by the direct child template. Required blocks may only contain space and comments, and they cannot be rendered directly.\n\n`page.txt`\n\n``` jinja\n{% block body required %}{% endblock %}\n```\n\n`issue.txt`\n\n``` jinja\n{% extends \"page.txt\" %}\n```\n\n`bug_report.txt`\n\n``` jinja\n{% extends \"issue.txt\" %}\n{% block body %}Provide steps to demonstrate the bug.{% endblock %}\n```\n\nRendering `page.txt` or `issue.txt` will raise `TemplateRuntimeError` because they don’t override the `body` block. Rendering `bug_report.txt` will succeed because it does override the block.\n\nWhen combined with `scoped`, the `required` modifier must be placed *after* the scoped modifier. Here are some valid examples:\n\n``` jinja\n{% block body scoped %}{% endblock %}\n{% block body required %}{% endblock %}\n{% block body scoped required %}{% endblock %}\n```\n\n### Template Objects\n\n`extends`, `include`, and `import` can take a template object instead of the name of a template to load. This could be useful in some advanced situations, since you can use Python code to load a template first and pass it in to `render`.\n\n``` python\nif debug_mode:\n    layout = env.get_template(\"debug_layout.html\")\nelse:\n    layout = env.get_template(\"layout.html\")\n\nuser_detail = env.get_template(\"user/detail.html\")\nreturn user_detail.render(layout=layout)\n```\n\n``` jinja\n{% extends layout %}\n```\n\nNote how `extends` is passed the variable with the template object that was passed to `render`, instead of a string.\n\n## HTML Escaping\n\nWhen generating HTML from templates, there’s always a risk that a variable will include characters that affect the resulting HTML. There are two approaches:\n\n1.  manually escaping each variable; or\n2.  automatically escaping everything by default.\n\nJinja supports both. What is used depends on the application configuration. The default configuration is no automatic escaping; for various reasons:\n\n- Escaping everything except for safe values will also mean that Jinja is escaping variables known to not include HTML (e.g. numbers, booleans) which can be a huge performance hit.\n- The information about the safety of a variable is very fragile. It could happen that by coercing safe and unsafe values, the return value is double-escaped HTML.\n\n### Working with Manual Escaping\n\nIf manual escaping is enabled, it’s **your** responsibility to escape variables if needed. What to escape? If you have a variable that *may* include any of the following chars (`>`, `<`, `&`, or `\"`) you **SHOULD** escape it unless the variable contains well-formed and trusted HTML. Escaping works by piping the variable through the `|e` filter:\n\n``` html+jinja\n{{ user.username|e }}\n```\n\n### Working with Automatic Escaping\n\nWhen automatic escaping is enabled, everything is escaped by default except for values explicitly marked as safe. Variables and expressions can be marked as safe either in:\n\n1.  The context dictionary by the application with `markupsafe.Markup`\n2.  The template, with the `|safe` filter.\n\nIf a string that you marked safe is passed through other Python code that doesn’t understand that mark, it may get lost. Be aware of when your data is marked safe and how it is processed before arriving at the template.\n\nIf a value has been escaped but is not marked safe, auto-escaping will still take place and result in double-escaped characters. If you know you have data that is already safe but not marked, be sure to wrap it in `Markup` or use the `|safe` filter.\n\nJinja functions (macros, `super`, `self.BLOCKNAME`) always return template data that is marked as safe.\n\nString literals in templates with automatic escaping are considered unsafe because native Python strings are not safe.\n\n## List of Control Structures\n\nA control structure refers to all those things that control the flow of a program - conditionals (i.e. if/elif/else), for-loops, as well as things like macros and blocks. With the default syntax, control structures appear inside `{% ... %}` blocks.\n\n### For\n\nLoop over each item in a sequence. For example, to display a list of users provided in a variable called `users`:\n\n``` html+jinja\n<h1>Members</h1>\n<ul>\n{% for user in users %}\n  <li>{{ user.username|e }}</li>\n{% endfor %}\n</ul>\n```\n\nAs variables in templates retain their object properties, it is possible to iterate over containers like `dict`:\n\n``` html+jinja\n<dl>\n{% for key, value in my_dict.items() %}\n    <dt>{{ key|e }}</dt>\n    <dd>{{ value|e }}</dd>\n{% endfor %}\n</dl>\n```\n\nPython dicts may not be in the order you want to display them in. If order matters, use the `|dictsort` filter.\n\n``` jinja\n<dl>\n{% for key, value in my_dict | dictsort %}\n    <dt>{{ key|e }}</dt>\n    <dd>{{ value|e }}</dd>\n{% endfor %}\n</dl>\n```\n\nInside of a for-loop block, you can access some special variables:\n\n| Variable             | Description                                                                             |\n|----------------------|-----------------------------------------------------------------------------------------|\n| `loop.index`         | The current iteration of the loop. (1 indexed)                                          |\n| `loop.index0`        | The current iteration of the loop. (0 indexed)                                          |\n| `loop.revindex`      | The number of iterations from the end of the loop (1 indexed)                           |\n| `loop.revindex0`     | The number of iterations from the end of the loop (0 indexed)                           |\n| `loop.first`         | True if first iteration.                                                                |\n| `loop.last`          | True if last iteration.                                                                 |\n| `loop.length`        | The number of items in the sequence.                                                    |\n| `loop.cycle`         | A helper function to cycle between a list of sequences. See the explanation below.      |\n| `loop.depth`         | Indicates how deep in a recursive loop the rendering currently is. Starts at level 1    |\n| `loop.depth0`        | Indicates how deep in a recursive loop the rendering currently is. Starts at level 0    |\n| `loop.previtem`      | The item from the previous iteration of the loop. Undefined during the first iteration. |\n| `loop.nextitem`      | The item from the following iteration of the loop. Undefined during the last iteration. |\n| `loop.changed(*val)` | True if previously called with a different value (or not called at all).                |\n\nWithin a for-loop, it’s possible to cycle among a list of strings/variables each time through the loop by using the special `loop.cycle` helper:\n\n``` html+jinja\n{% for row in rows %}\n    <li class=\"{{ loop.cycle('odd', 'even') }}\">{{ row }}</li>\n{% endfor %}\n```\n\nSince Jinja 2.1, an extra `cycle` helper exists that allows loop-unbound cycling. For more information, have a look at the [List of Global Functions](#builtin-globals).\n\nUnlike in Python, it’s not possible to `break` or `continue` in a loop. You can, however, filter the sequence during iteration, which allows you to skip items. The following example skips all the users which are hidden:\n\n``` html+jinja\n{% for user in users if not user.hidden %}\n    <li>{{ user.username|e }}</li>\n{% endfor %}\n```\n\nThe advantage is that the special `loop` variable will count correctly; thus not counting the users not iterated over.\n\nIf no iteration took place because the sequence was empty or the filtering removed all the items from the sequence, you can render a default block by using `else`:\n\n``` html+jinja\n<ul>\n{% for user in users %}\n    <li>{{ user.username|e }}</li>\n{% else %}\n    <li><em>no users found</em></li>\n{% endfor %}\n</ul>\n```\n\nNote that, in Python, `else` blocks are executed whenever the corresponding loop **did not** `break`. Since Jinja loops cannot `break` anyway, a slightly different behavior of the `else` keyword was chosen.\n\nIt is also possible to use loops recursively. This is useful if you are dealing with recursive data such as sitemaps or RDFa. To use loops recursively, you basically have to add the `recursive` modifier to the loop definition and call the `loop` variable with the new iterable where you want to recurse.\n\nThe following example implements a sitemap with recursive loops:\n\n``` html+jinja\n<ul class=\"sitemap\">\n{%- for item in sitemap recursive %}\n    <li><a href=\"{{ item.href|e }}\">{{ item.title }}</a>\n    {%- if item.children -%}\n        <ul class=\"submenu\">{{ loop(item.children) }}</ul>\n    {%- endif %}</li>\n{%- endfor %}\n</ul>\n```\n\nThe `loop` variable always refers to the closest (innermost) loop. If we have more than one level of loops, we can rebind the variable `loop` by writing `{% set outer_loop = loop %}` after the loop that we want to use recursively. Then, we can call it using `{{ outer_loop(…) }}`\n\nPlease note that assignments in loops will be cleared at the end of the iteration and cannot outlive the loop scope. Older versions of Jinja had a bug where in some circumstances it appeared that assignments would work. This is not supported. See [Assignments](#assignments) for more information about how to deal with this.\n\nIf all you want to do is check whether some value has changed since the last iteration or will change in the next iteration, you can use `previtem` and `nextitem`:\n\n``` html+jinja\n{% for value in values %}\n    {% if loop.previtem is defined and value > loop.previtem %}\n        The value just increased!\n    {% endif %}\n    {{ value }}\n    {% if loop.nextitem is defined and loop.nextitem > value %}\n        The value will increase even more!\n    {% endif %}\n{% endfor %}\n```\n\nIf you only care whether the value changed at all, using `changed` is even easier:\n\n``` html+jinja\n{% for entry in entries %}\n    {% if loop.changed(entry.category) %}\n        <h2>{{ entry.category }}</h2>\n    {% endif %}\n    <p>{{ entry.message }}</p>\n{% endfor %}\n```\n\n### If\n\nThe `if` statement in Jinja is comparable with the Python if statement. In the simplest form, you can use it to test if a variable is defined, not empty and not false:\n\n``` html+jinja\n{% if users %}\n<ul>\n{% for user in users %}\n    <li>{{ user.username|e }}</li>\n{% endfor %}\n</ul>\n{% endif %}\n```\n\nFor multiple branches, `elif` and `else` can be used like in Python. You can use more complex [Expressions](#expressions) there, too:\n\n``` html+jinja\n{% if kenny.sick %}\n    Kenny is sick.\n{% elif kenny.dead %}\n    You killed Kenny!  You bastard!!!\n{% else %}\n    Kenny looks okay --- so far\n{% endif %}\n```\n\nIf can also be used as an [inline expression](#if-expression) and for [loop filtering](#loop-filtering).\n\n### Macros\n\nMacros are comparable with functions in regular programming languages. They are useful to put often used idioms into reusable functions to not repeat yourself (“DRY”).\n\nHere’s a small example of a macro that renders a form element:\n\n``` html+jinja\n{% macro input(name, value='', type='text', size=20) -%}\n    <input type=\"{{ type }}\" name=\"{{ name }}\" value=\"{{\n        value|e }}\" size=\"{{ size }}\">\n{%- endmacro %}\n```\n\nThe macro can then be called like a function in the namespace:\n\n``` html+jinja\n<p>{{ input('username') }}</p>\n<p>{{ input('password', type='password') }}</p>\n```\n\nIf the macro was defined in a different template, you have to [import](#import) it first.\n\nInside macros, you have access to three special variables:\n\n`varargs`  \nIf more positional arguments are passed to the macro than accepted by the macro, they end up in the special `varargs` variable as a list of values.\n\n`kwargs`  \nLike `varargs` but for keyword arguments. All unconsumed keyword arguments are stored in this special variable.\n\n`caller`  \nIf the macro was called from a [call](#call) tag, the caller is stored in this variable as a callable macro.\n\nMacros also expose some of their internal details. The following attributes are available on a macro object:\n\n`name`  \nThe name of the macro. `{{ input.name }}` will print `input`.\n\n`arguments`  \nA tuple of the names of arguments the macro accepts.\n\n`catch_kwargs`  \nThis is `true` if the macro accepts extra keyword arguments (i.e.: accesses the special `kwargs` variable).\n\n`catch_varargs`  \nThis is `true` if the macro accepts extra positional arguments (i.e.: accesses the special `varargs` variable).\n\n`caller`  \nThis is `true` if the macro accesses the special `caller` variable and may be called from a [call](#call) tag.\n\nIf a macro name starts with an underscore, it’s not exported and can’t be imported.\n\nDue to how scopes work in Jinja, a macro in a child template does not override a macro in a parent template. The following will output “LAYOUT”, not “CHILD”.\n\n`layout.txt`\n\n``` jinja\n{% macro foo() %}LAYOUT{% endmacro %}\n{% block body %}{% endblock %}\n```\n\n`child.txt`\n\n``` jinja\n{% extends 'layout.txt' %}\n{% macro foo() %}CHILD{% endmacro %}\n{% block body %}{{ foo() }}{% endblock %}\n```\n\n### Call\n\nIn some cases it can be useful to pass a macro to another macro. For this purpose, you can use the special `call` block. The following example shows a macro that takes advantage of the call functionality and how it can be used:\n\n``` html+jinja\n{% macro render_dialog(title, class='dialog') -%}\n    <div class=\"{{ class }}\">\n        <h2>{{ title }}</h2>\n        <div class=\"contents\">\n            {{ caller() }}\n        </div>\n    </div>\n{%- endmacro %}\n\n{% call render_dialog('Hello World') %}\n    This is a simple dialog rendered by using a macro and\n    a call block.\n{% endcall %}\n```\n\nIt’s also possible to pass arguments back to the call block. This makes it useful as a replacement for loops. Generally speaking, a call block works exactly like a macro without a name.\n\nHere’s an example of how a call block can be used with arguments:\n\n``` html+jinja\n{% macro dump_users(users) -%}\n    <ul>\n    {%- for user in users %}\n        <li><p>{{ user.username|e }}</p>{{ caller(user) }}</li>\n    {%- endfor %}\n    </ul>\n{%- endmacro %}\n\n{% call(user) dump_users(list_of_user) %}\n    <dl>\n        <dt>Realname</dt>\n        <dd>{{ user.realname|e }}</dd>\n        <dt>Description</dt>\n        <dd>{{ user.description }}</dd>\n    </dl>\n{% endcall %}\n```\n\n### Filters\n\nFilter sections allow you to apply regular Jinja filters on a block of template data. Just wrap the code in the special `filter` section:\n\n``` html+jinja\n{% filter upper %}\n    This text becomes uppercase\n{% endfilter %}\n```\n\nFilters that accept arguments can be called like this:\n\n``` html+jinja\n{% filter center(100) %}Center this{% endfilter %}\n```\n\n### Assignments\n\nInside code blocks, you can also assign values to variables. Assignments at top level (outside of blocks, macros or loops) are exported from the template like top level macros and can be imported by other templates.\n\nAssignments use the `set` tag and can have multiple targets:\n\n``` html+jinja\n{% set navigation = [('index.html', 'Index'), ('about.html', 'About')] %}\n{% set key, value = call_something() %}\n```\n\nScoping Behavior\n\nPlease keep in mind that it is not possible to set variables inside a block and have them show up outside of it. This also applies to loops. The only exception to that rule are if statements which do not introduce a scope. As a result the following template is not going to do what you might expect:\n\n``` html+jinja\n{% set iterated = false %}\n{% for item in seq %}\n    {{ item }}\n    {% set iterated = true %}\n{% endfor %}\n{% if not iterated %} did not iterate {% endif %}\n```\n\nIt is not possible with Jinja syntax to do this. Instead use alternative constructs like the loop else block or the special `loop` variable:\n\n``` html+jinja\n{% for item in seq %}\n    {{ item }}\n{% else %}\n    did not iterate\n{% endfor %}\n```\n\nAs of version 2.10 more complex use cases can be handled using namespace objects which allow propagating of changes across scopes:\n\n``` html+jinja\n{% set ns = namespace(found=false) %}\n{% for item in items %}\n    {% if item.check_something() %}\n        {% set ns.found = true %}\n    {% endif %}\n    * {{ item.title }}\n{% endfor %}\nFound item having something: {{ ns.found }}\n```\n\nNote that the `obj.attr` notation in the `set` tag is only allowed for namespace objects; attempting to assign an attribute on any other object will raise an exception.\n\nChangelog\n\nNew in version 2.10: Added support for namespace objects\n\n### Block Assignments\n\nChangelog\n\nNew in version 2.8.\n\nStarting with Jinja 2.8, it’s possible to also use block assignments to capture the contents of a block into a variable name. This can be useful in some situations as an alternative for macros. In that case, instead of using an equals sign and a value, you just write the variable name and then everything until `{% endset %}` is captured.\n\nExample:\n\n``` html+jinja\n{% set navigation %}\n    <li><a href=\"/\">Index</a>\n    <li><a href=\"/downloads\">Downloads</a>\n{% endset %}\n```\n\nThe `navigation` variable then contains the navigation HTML source.\n\nChangelog\n\nChanged in version 2.10.\n\nStarting with Jinja 2.10, the block assignment supports filters.\n\nExample:\n\n``` html+jinja\n{% set reply | wordwrap %}\n    You wrote:\n    {{ message }}\n{% endset %}\n```\n\n### Extends\n\nThe `extends` tag can be used to extend one template from another. You can have multiple `extends` tags in a file, but only one of them may be executed at a time.\n\nSee the section about [Template Inheritance](#template-inheritance) above.\n\n### Blocks\n\nBlocks are used for inheritance and act as both placeholders and replacements at the same time. They are documented in detail in the [Template Inheritance](#template-inheritance) section.\n\n### Include\n\nThe `include` tag renders another template and outputs the result into the current template.\n\n``` jinja\n{% include 'header.html' %}\nBody goes here.\n{% include 'footer.html' %}\n```\n\nThe included template has access to context of the current template by default. Use `without context` to use a separate context instead. `with context` is also valid, but is the default behavior. See [Import Context Behavior](#import-visibility).\n\nThe included template can `extend` another template and override blocks in that template. However, the current template cannot override any blocks that the included template outputs.\n\nUse `ignore missing` to ignore the statement if the template does not exist. It must be placed *before* a context visibility statement.\n\n``` jinja\n{% include \"sidebar.html\" without context %}\n{% include \"sidebar.html\" ignore missing %}\n{% include \"sidebar.html\" ignore missing with context %}\n{% include \"sidebar.html\" ignore missing without context %}\n```\n\nIf a list of templates is given, each will be tried in order until one is not missing. This can be used with `ignore missing` to ignore if none of the templates exist.\n\n``` jinja\n{% include ['page_detailed.html', 'page.html'] %}\n{% include ['special_sidebar.html', 'sidebar.html'] ignore missing %}\n```\n\nA variable, with either a template name or template object, can also be passed to the statement.\n\n### Import\n\nJinja supports putting often used code into macros. These macros can go into different templates and get imported from there. This works similarly to the import statements in Python. It’s important to know that imports are cached and imported templates don’t have access to the current template variables, just the globals by default. For more details about context behavior of imports and includes, see [Import Context Behavior](#import-visibility).\n\nThere are two ways to import templates. You can import a complete template into a variable or request specific macros / exported variables from it.\n\nImagine we have a helper module that renders forms (called `forms.html`):\n\n``` html+jinja\n{% macro input(name, value='', type='text') -%}\n    <input type=\"{{ type }}\" value=\"{{ value|e }}\" name=\"{{ name }}\">\n{%- endmacro %}\n\n{%- macro textarea(name, value='', rows=10, cols=40) -%}\n    <textarea name=\"{{ name }}\" rows=\"{{ rows }}\" cols=\"{{ cols\n        }}\">{{ value|e }}</textarea>\n{%- endmacro %}\n```\n\nThe easiest and most flexible way to access a template’s variables and macros is to import the whole template module into a variable. That way, you can access the attributes:\n\n``` html+jinja\n{% import 'forms.html' as forms %}\n<dl>\n    <dt>Username</dt>\n    <dd>{{ forms.input('username') }}</dd>\n    <dt>Password</dt>\n    <dd>{{ forms.input('password', type='password') }}</dd>\n</dl>\n<p>{{ forms.textarea('comment') }}</p>\n```\n\nAlternatively, you can import specific names from a template into the current namespace:\n\n``` html+jinja\n{% from 'forms.html' import input as input_field, textarea %}\n<dl>\n    <dt>Username</dt>\n    <dd>{{ input_field('username') }}</dd>\n    <dt>Password</dt>\n    <dd>{{ input_field('password', type='password') }}</dd>\n</dl>\n<p>{{ textarea('comment') }}</p>\n```\n\nMacros and variables starting with one or more underscores are private and cannot be imported.\n\nChangelog\n\nChanged in version 2.4: If a template object was passed to the template context, you can import from that object.\n\n## Import Context Behavior\n\nBy default, included templates are passed the current context and imported templates are not. The reason for this is that imports, unlike includes, are cached; as imports are often used just as a module that holds macros.\n\nThis behavior can be changed explicitly: by adding `with context` or `without context` to the import/include directive, the current context can be passed to the template and caching is disabled automatically.\n\nHere are two examples:\n\n``` html+jinja\n{% from 'forms.html' import input with context %}\n{% include 'header.html' without context %}\n```\n\nNote\n\nIn Jinja 2.0, the context that was passed to the included template did not include variables defined in the template. As a matter of fact, this did not work:\n\n``` html+jinja\n{% for box in boxes %}\n    {% include \"render_box.html\" %}\n{% endfor %}\n```\n\nThe included template `render_box.html` is *not* able to access `box` in Jinja 2.0. As of Jinja 2.1, `render_box.html` *is* able to do so.\n\n## Expressions\n\nJinja allows basic expressions everywhere. These work very similarly to regular Python; even if you’re not working with Python you should feel comfortable with it.\n\n### Literals\n\nThe simplest form of expressions are literals. Literals are representations for Python objects such as strings and numbers. The following literals exist:\n\n`\"Hello World\"`  \nEverything between two double or single quotes is a string. They are useful whenever you need a string in the template (e.g. as arguments to function calls and filters, or just to extend or include a template).\n\n`42 / 123_456`  \nIntegers are whole numbers without a decimal part. The ‘\\_’ character can be used to separate groups for legibility.\n\n`42.23 / 42.1e2 / 123_456.789`  \nFloating point numbers can be written using a ‘.’ as a decimal mark. They can also be written in scientific notation with an upper or lower case ‘e’ to indicate the exponent part. The ‘\\_’ character can be used to separate groups for legibility, but cannot be used in the exponent part.\n\n`['list', 'of', 'objects']`  \nEverything between two brackets is a list. Lists are useful for storing sequential data to be iterated over. For example, you can easily create a list of links using lists and tuples for (and with) a for loop:\n\n``` html+jinja\n<ul>\n{% for href, caption in [('index.html', 'Index'), ('about.html', 'About'),\n                         ('downloads.html', 'Downloads')] %}\n    <li><a href=\"{{ href }}\">{{ caption }}</a></li>\n{% endfor %}\n</ul>\n```\n\n`('tuple', 'of', 'values')`  \nTuples are like lists that cannot be modified (“immutable”). If a tuple only has one item, it must be followed by a comma (`('1-tuple',)`). Tuples are usually used to represent items of two or more elements. See the list example above for more details.\n\n`{'dict': 'of', 'key': 'and', 'value': 'pairs'}`  \nA dict in Python is a structure that combines keys and values. Keys must be unique and always have exactly one value. Dicts are rarely used in templates; they are useful in some rare cases such as the `xmlattr()` filter.\n\n`true / false`  \n`true` is always true and `false` is always false.\n\nNote\n\nThe special constants `true`, `false`, and `none` are indeed lowercase. Because that caused confusion in the past, (`True` used to expand to an undefined variable that was considered false), all three can now also be written in title case (`True`, `False`, and `None`). However, for consistency, (all Jinja identifiers are lowercase) you should use the lowercase versions.\n\n### Math\n\nJinja allows you to calculate with values. This is rarely useful in templates but exists for completeness’ sake. The following operators are supported:\n\n`+`  \nAdds two objects together. Usually the objects are numbers, but if both are strings or lists, you can concatenate them this way. This, however, is not the preferred way to concatenate strings! For string concatenation, have a look-see at the `~` operator. `{{ 1 + 1 }}` is `2`.\n\n`-`  \nSubtract the second number from the first one. `{{ 3 - 2 }}` is `1`.\n\n`/`  \nDivide two numbers. The return value will be a floating point number. `{{ 1 / 2 }}` is `{{ 0.5 }}`.\n\n`//`  \nDivide two numbers and return the truncated integer result. `{{ 20 // 7 }}` is `2`.\n\n`%`  \nCalculate the remainder of an integer division. `{{ 11 % 7 }}` is `4`.\n\n`*`  \nMultiply the left operand with the right one. `{{ 2 * 2 }}` would return `4`. This can also be used to repeat a string multiple times. `{{ '=' * 80 }}` would print a bar of 80 equal signs.\n\n`**`  \nRaise the left operand to the power of the right operand. `{{ 2**3 }}` would return `8`.\n\nUnlike Python, chained pow is evaluated left to right. `{{ 3**3**3 }}` is evaluated as `(3**3)**3` in Jinja, but would be evaluated as `3**(3**3)` in Python. Use parentheses in Jinja to be explicit about what order you want. It is usually preferable to do extended math in Python and pass the results to `render` rather than doing it in the template.\n\nThis behavior may be changed in the future to match Python, if it’s possible to introduce an upgrade path.\n\n### Comparisons\n\n`==`  \nCompares two objects for equality.\n\n`!=`  \nCompares two objects for inequality.\n\n`>`  \n`true` if the left hand side is greater than the right hand side.\n\n`>=`  \n`true` if the left hand side is greater or equal to the right hand side.\n\n`<`  \n`true` if the left hand side is lower than the right hand side.\n\n`<=`  \n`true` if the left hand side is lower or equal to the right hand side.\n\n### Logic\n\nFor `if` statements, `for` filtering, and `if` expressions, it can be useful to combine multiple expressions:\n\n`and`  \nReturn true if the left and the right operand are true.\n\n`or`  \nReturn true if the left or the right operand are true.\n\n`not`  \nnegate a statement (see below).\n\n`(expr)`  \nParentheses group an expression.\n\nNote\n\nThe `is` and `in` operators support negation using an infix notation, too: `foo is not bar` and `foo not in bar` instead of `not foo is bar` and `not foo in bar`. All other expressions require a prefix notation: `not (foo and bar).`\n\n### Other Operators\n\nThe following operators are very useful but don’t fit into any of the other two categories:\n\n`in`  \nPerform a sequence / mapping containment test. Returns true if the left operand is contained in the right. `{{ 1 in [1, 2, 3] }}` would, for example, return true.\n\n`is`  \nPerforms a [test](#tests).\n\n`| (pipe, vertical bar)`  \nApplies a [filter](#filters).\n\n`~ (tilde)`  \nConverts all operands into strings and concatenates them.\n\n`{{ \"Hello \" ~ name ~ \"!\" }}` would return (assuming `name` is set to `'John'`) `Hello John!`.\n\n`()`  \nCall a callable: `{{ post.render() }}`. Inside of the parentheses you can use positional arguments and keyword arguments like in Python:\n\n`{{ post.render(user, full=true) }}`.\n\n`. / []`  \nGet an attribute of an object. (See [Variables](#variables))\n\n### If Expression\n\nIt is also possible to use inline `if` expressions. These are useful in some situations. For example, you can use this to extend from one template if a variable is defined, otherwise from the default layout template:\n\n``` html+jinja\n{% extends layout_template if layout_template is defined else 'default.html' %}\n```\n\nThe general syntax is `<do something> if <something is true> else <do something else>`.\n\nThe `else` part is optional. If not provided, the else block implicitly evaluates into an [`Undefined`](../api/index#jinja2.Undefined \"jinja2.Undefined\") object (regardless of what `undefined` in the environment is set to):\n\n``` jinja\n{{ \"[{}]\".format(page.title) if page.title }}\n```\n\n### Python Methods\n\nYou can also use any of the methods defined on a variable’s type. The value returned from the method invocation is used as the value of the expression. Here is an example that uses methods defined on strings (where `page.title` is a string):\n\n``` text\n{{ page.title.capitalize() }}\n```\n\nThis works for methods on user-defined types. For example, if variable `f` of type `Foo` has a method `bar` defined on it, you can do the following:\n\n``` text\n{{ f.bar(value) }}\n```\n\nOperator methods also work as expected. For example, `%` implements printf-style for strings:\n\n``` text\n{{ \"Hello, %s!\" % name }}\n```\n\nAlthough you should prefer the `.format` method for that case (which is a bit contrived in the context of rendering a template):\n\n``` text\n{{ \"Hello, {}!\".format(name) }}\n```\n\n## List of Builtin Filters\n\n|                                                                                    |                                                                           |                                                                        |                                                                        |                                                                     |\n|------------------------------------------------------------------------------------|---------------------------------------------------------------------------|------------------------------------------------------------------------|------------------------------------------------------------------------|---------------------------------------------------------------------|\n| [`abs()`](#jinja-filters.abs \"jinja-filters.abs\")                                  | [`forceescape()`](#jinja-filters.forceescape \"jinja-filters.forceescape\") | [`map()`](#jinja-filters.map \"jinja-filters.map\")                      | [`select()`](#jinja-filters.select \"jinja-filters.select\")             | [`unique()`](#jinja-filters.unique \"jinja-filters.unique\")          |\n| [`attr()`](#jinja-filters.attr \"jinja-filters.attr\")                               | [`format()`](#jinja-filters.format \"jinja-filters.format\")                | [`max()`](#jinja-filters.max \"jinja-filters.max\")                      | [`selectattr()`](#jinja-filters.selectattr \"jinja-filters.selectattr\") | [`upper()`](#jinja-filters.upper \"jinja-filters.upper\")             |\n| [`batch()`](#jinja-filters.batch \"jinja-filters.batch\")                            | [`groupby()`](#jinja-filters.groupby \"jinja-filters.groupby\")             | [`min()`](#jinja-filters.min \"jinja-filters.min\")                      | [`slice()`](#jinja-filters.slice \"jinja-filters.slice\")                | [`urlencode()`](#jinja-filters.urlencode \"jinja-filters.urlencode\") |\n| [`capitalize()`](#jinja-filters.capitalize \"jinja-filters.capitalize\")             | [`indent()`](#jinja-filters.indent \"jinja-filters.indent\")                | [`pprint()`](#jinja-filters.pprint \"jinja-filters.pprint\")             | [`sort()`](#jinja-filters.sort \"jinja-filters.sort\")                   | [`urlize()`](#jinja-filters.urlize \"jinja-filters.urlize\")          |\n| [`center()`](#jinja-filters.center \"jinja-filters.center\")                         | [`int()`](#jinja-filters.int \"jinja-filters.int\")                         | [`random()`](#jinja-filters.random \"jinja-filters.random\")             | [`string()`](#jinja-filters.string \"jinja-filters.string\")             | [`wordcount()`](#jinja-filters.wordcount \"jinja-filters.wordcount\") |\n| [`default()`](#jinja-filters.default \"jinja-filters.default\")                      | [`items()`](#jinja-filters.items \"jinja-filters.items\")                   | [`reject()`](#jinja-filters.reject \"jinja-filters.reject\")             | [`striptags()`](#jinja-filters.striptags \"jinja-filters.striptags\")    | [`wordwrap()`](#jinja-filters.wordwrap \"jinja-filters.wordwrap\")    |\n| [`dictsort()`](#jinja-filters.dictsort \"jinja-filters.dictsort\")                   | [`join()`](#jinja-filters.join \"jinja-filters.join\")                      | [`rejectattr()`](#jinja-filters.rejectattr \"jinja-filters.rejectattr\") | [`sum()`](#jinja-filters.sum \"jinja-filters.sum\")                      | [`xmlattr()`](#jinja-filters.xmlattr \"jinja-filters.xmlattr\")       |\n| [`escape()`](#jinja-filters.escape \"jinja-filters.escape\")                         | [`last()`](#jinja-filters.last \"jinja-filters.last\")                      | [`replace()`](#jinja-filters.replace \"jinja-filters.replace\")          | [`title()`](#jinja-filters.title \"jinja-filters.title\")                |                                                                     |\n| [`filesizeformat()`](#jinja-filters.filesizeformat \"jinja-filters.filesizeformat\") | [`length()`](#jinja-filters.length \"jinja-filters.length\")                | [`reverse()`](#jinja-filters.reverse \"jinja-filters.reverse\")          | [`tojson()`](#jinja-filters.tojson \"jinja-filters.tojson\")             |                                                                     |\n| [`first()`](#jinja-filters.first \"jinja-filters.first\")                            | [`list()`](#jinja-filters.list \"jinja-filters.list\")                      | [`round()`](#jinja-filters.round \"jinja-filters.round\")                | [`trim()`](#jinja-filters.trim \"jinja-filters.trim\")                   |                                                                     |\n| [`float()`](#jinja-filters.float \"jinja-filters.float\")                            | [`lower()`](#jinja-filters.lower \"jinja-filters.lower\")                   | [`safe()`](#jinja-filters.safe \"jinja-filters.safe\")                   | [`truncate()`](#jinja-filters.truncate \"jinja-filters.truncate\")       |                                                                     |\n\n`jinja-filters.abs(x, /)`  \nReturn the absolute value of the argument.\n\n`jinja-filters.attr(obj: Any, name: str) → jinja2.runtime.Undefined | Any`  \nGet an attribute of an object. `foo|attr(\"bar\")` works like `foo.bar` just that always an attribute is returned and items are not looked up.\n\nSee [Notes on subscriptions](#notes-on-subscriptions) for more details.\n\n&nbsp;\n\n`jinja-filters.batch(value: 't.Iterable[V]', linecount: int, fill_with: 't.Optional[V]' = None) → 't.Iterator[t.List[V]]'`  \nA filter that batches items. It works pretty much like `slice` just the other way round. It returns a list of lists with the given number of items. If you provide a second parameter this is used to fill up missing items. See this example:\n\n``` html+jinja\n<table>\n{%- for row in items|batch(3, '&nbsp;') %}\n  <tr>\n  {%- for column in row %}\n    <td>{{ column }}</td>\n  {%- endfor %}\n  </tr>\n{%- endfor %}\n</table>\n```\n\n&nbsp;\n\n`jinja-filters.capitalize(s: str) → str`  \nCapitalize a value. The first character will be uppercase, all others lowercase.\n\n&nbsp;\n\n`jinja-filters.center(value: str, width: int = 80) → str`  \nCenters the value in a field of a given width.\n\n&nbsp;\n\n`jinja-filters.default(value: V, default_value: V = '', boolean: bool = False) → V`  \nIf the value is undefined it will return the passed default value, otherwise the value of the variable:\n\n``` jinja\n{{ my_variable|default('my_variable is not defined') }}\n```\n\nThis will output the value of `my_variable` if the variable was defined, otherwise `'my_variable is not defined'`. If you want to use default with variables that evaluate to false you have to set the second parameter to `true`:\n\n``` jinja\n{{ ''|default('the string was empty', true) }}\n```\n\nChangelog\n\nChanged in version 2.11: It’s now possible to configure the [`Environment`](../api/index#jinja2.Environment \"jinja2.Environment\") with [`ChainableUndefined`](../api/index#jinja2.ChainableUndefined \"jinja2.ChainableUndefined\") to make the `default` filter work on nested elements and attributes that may contain undefined values in the chain without getting an [`UndefinedError`](../api/index#jinja2.UndefinedError \"jinja2.UndefinedError\").\n\nAliases:  \n`d`\n\n&nbsp;\n\n`jinja-filters.dictsort(value: Mapping[K, V], case_sensitive: bool = False, by: 'te.Literal[\"key\", \"value\"]' = 'key', reverse: bool = False) → List[Tuple[K, V]]`  \nSort a dict and yield (key, value) pairs. Python dicts may not be in the order you want to display them in, so sort them first.\n\n``` jinja\n{% for key, value in mydict|dictsort %}\n    sort the dict by key, case insensitive\n\n{% for key, value in mydict|dictsort(reverse=true) %}\n    sort the dict by key, case insensitive, reverse order\n\n{% for key, value in mydict|dictsort(true) %}\n    sort the dict by key, case sensitive\n\n{% for key, value in mydict|dictsort(false, 'value') %}\n    sort the dict by value, case insensitive\n```\n\n&nbsp;\n\n`jinja-filters.escape(value)`  \nReplace the characters `&`, `<`, `>`, `'`, and `\"` in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML.\n\nIf the object has an `__html__` method, it is called and the return value is assumed to already be safe for HTML.\n\nParameters:  \n**s** – An object to be converted to a string and escaped.\n\nReturns:  \nA `Markup` string with the escaped text.\n\nAliases:  \n`e`\n\n&nbsp;\n\n`jinja-filters.filesizeformat(value: str | float | int, binary: bool = False) → str`  \nFormat the value like a ‘human-readable’ file size (i.e. 13 kB, 4.1 MB, 102 Bytes, etc). Per default decimal prefixes are used (Mega, Giga, etc.), if the second parameter is set to `True` the binary prefixes are used (Mebi, Gibi).\n\n&nbsp;\n\n`jinja-filters.first(seq: 't.Iterable[V]') → 't.Union[V, Undefined]'`  \nReturn the first item of a sequence.\n\n&nbsp;\n\n`jinja-filters.float(value: Any, default: float = 0.0) → float`  \nConvert the value into a floating point number. If the conversion doesn’t work it will return `0.0`. You can override this default using the first parameter.\n\n&nbsp;\n\n`jinja-filters.forceescape(value: 't.Union[str, HasHTML]') → markupsafe.Markup`  \nEnforce HTML escaping. This will probably double escape variables.\n\n&nbsp;\n\n`jinja-filters.format(value: str, *args: Any, **kwargs: Any) → str`  \nApply the given values to a [printf-style](https://docs.python.org/library/stdtypes.html#printf-style-string-formatting) format string, like `string % values`.\n\n``` jinja\n{{ \"%s, %s!\"|format(greeting, name) }}\nHello, World!\n```\n\nIn most cases it should be more convenient and efficient to use the `%` operator or [`str.format()`](https://docs.python.org/3/library/stdtypes.html#str.format \"(in Python v3.11)\").\n\n``` text\n{{ \"%s, %s!\" % (greeting, name) }}\n{{ \"{}, {}!\".format(greeting, name) }}\n```\n\n&nbsp;\n\n`jinja-filters.groupby(value: 't.Iterable[V]', attribute: str | int, default: Any | None = None, case_sensitive: bool = False) → 't.List[_GroupTuple]'`  \nGroup a sequence of objects by an attribute using Python’s [`itertools.groupby()`](https://docs.python.org/3/library/itertools.html#itertools.groupby \"(in Python v3.11)\"). The attribute can use dot notation for nested access, like `\"address.city\"`. Unlike Python’s `groupby`, the values are sorted first so only one group is returned for each unique value.\n\nFor example, a list of `User` objects with a `city` attribute can be rendered in groups. In this example, `grouper` refers to the `city` value of the group.\n\n``` html+jinja\n<ul>{% for city, items in users|groupby(\"city\") %}\n  <li>{{ city }}\n    <ul>{% for user in items %}\n      <li>{{ user.name }}\n    {% endfor %}</ul>\n  </li>\n{% endfor %}</ul>\n```\n\n`groupby` yields namedtuples of `(grouper, list)`, which can be used instead of the tuple unpacking above. `grouper` is the value of the attribute, and `list` is the items with that value.\n\n``` html+jinja\n<ul>{% for group in users|groupby(\"city\") %}\n  <li>{{ group.grouper }}: {{ group.list|join(\", \") }}\n{% endfor %}</ul>\n```\n\nYou can specify a `default` value to use if an object in the list does not have the given attribute.\n\n``` jinja\n<ul>{% for city, items in users|groupby(\"city\", default=\"NY\") %}\n  <li>{{ city }}: {{ items|map(attribute=\"name\")|join(\", \") }}</li>\n{% endfor %}</ul>\n```\n\nLike the [`sort()`](#jinja-filters.sort \"jinja-filters.sort\") filter, sorting and grouping is case-insensitive by default. The `key` for each group will have the case of the first item in that group of values. For example, if a list of users has cities `[\"CA\", \"NY\", \"ca\"]`, the “CA” group will have two values. This can be disabled by passing `case_sensitive=True`.\n\nChanged in version 3.1: Added the `case_sensitive` parameter. Sorting and grouping is case-insensitive by default, matching other filters that do comparisons.\n\nChangelog\n\nChanged in version 3.0: Added the `default` parameter.\n\nChanged in version 2.6: The attribute supports dot notation for nested access.\n\n&nbsp;\n\n`jinja-filters.indent(s: str, width: int | str = 4, first: bool = False, blank: bool = False) → str`  \nReturn a copy of the string with each line indented by 4 spaces. The first line and blank lines are not indented by default.\n\nParameters:  \n- **width** – Number of spaces, or a string, to indent by.\n- **first** – Don’t skip indenting the first line.\n- **blank** – Don’t skip indenting empty lines.\n\nChangelog\n\nChanged in version 3.0: `width` can be a string.\n\nChanged in version 2.10: Blank lines are not indented by default.\n\nRename the `indentfirst` argument to `first`.\n\n&nbsp;\n\n`jinja-filters.int(value: Any, default: int = 0, base: int = 10) → int`  \nConvert the value into an integer. If the conversion doesn’t work it will return `0`. You can override this default using the first parameter. You can also override the default base (10) in the second parameter, which handles input with prefixes such as 0b, 0o and 0x for bases 2, 8 and 16 respectively. The base is ignored for decimal numbers and non-string values.\n\n&nbsp;\n\n`jinja-filters.items(value: Mapping[K, V] | jinja2.runtime.Undefined) → Iterator[Tuple[K, V]]`  \nReturn an iterator over the `(key, value)` items of a mapping.\n\n`x|items` is the same as `x.items()`, except if `x` is undefined an empty iterator is returned.\n\nThis filter is useful if you expect the template to be rendered with an implementation of Jinja in another programming language that does not have a `.items()` method on its mapping type.\n\n``` html+jinja\n<dl>\n{% for key, value in my_dict|items %}\n    <dt>{{ key }}\n    <dd>{{ value }}\n{% endfor %}\n</dl>\n```\n\nNew in version 3.1.\n\n&nbsp;\n\n`jinja-filters.join(value: Iterable, d: str = '', attribute: str | int | NoneType = None) → str`  \nReturn a string which is the concatenation of the strings in the sequence. The separator between elements is an empty string per default, you can define it with the optional parameter:\n\n``` jinja\n{{ [1, 2, 3]|join('|') }}\n    -> 1|2|3\n\n{{ [1, 2, 3]|join }}\n    -> 123\n```\n\nIt is also possible to join certain attributes of an object:\n\n``` jinja\n{{ users|join(', ', attribute='username') }}\n```\n\nChangelog\n\nNew in version 2.6: The `attribute` parameter was added.\n\n&nbsp;\n\n`jinja-filters.last(seq: 't.Reversible[V]') → 't.Union[V, Undefined]'`  \nReturn the last item of a sequence.\n\nNote: Does not work with generators. You may want to explicitly convert it to a list:\n\n``` jinja\n{{ data | selectattr('name', '==', 'Jinja') | list | last }}\n```\n\n&nbsp;\n\n`jinja-filters.length(obj, /)`  \nReturn the number of items in a container.\n\nAliases:  \n`count`\n\n&nbsp;\n\n`jinja-filters.list(value: 't.Iterable[V]') → 't.List[V]'`  \nConvert the value into a list. If it was a string the returned list will be a list of characters.\n\n&nbsp;\n\n`jinja-filters.lower(s: str) → str`  \nConvert a value to lowercase.\n\n&nbsp;\n\n`jinja-filters.map(value: Iterable, *args: Any, **kwargs: Any) → Iterable`  \nApplies a filter on a sequence of objects or looks up an attribute. This is useful when dealing with lists of objects but you are really only interested in a certain value of it.\n\nThe basic usage is mapping on an attribute. Imagine you have a list of users but you are only interested in a list of usernames:\n\n``` jinja\nUsers on this page: {{ users|map(attribute='username')|join(', ') }}\n```\n\nYou can specify a `default` value to use if an object in the list does not have the given attribute.\n\n``` jinja\n{{ users|map(attribute=\"username\", default=\"Anonymous\")|join(\", \") }}\n```\n\nAlternatively you can let it invoke a filter by passing the name of the filter and the arguments afterwards. A good example would be applying a text conversion filter on a sequence:\n\n``` jinja\nUsers on this page: {{ titles|map('lower')|join(', ') }}\n```\n\nSimilar to a generator comprehension such as:\n\n``` python\n(u.username for u in users)\n(getattr(u, \"username\", \"Anonymous\") for u in users)\n(do_lower(x) for x in titles)\n```\n\nChangelog\n\nChanged in version 2.11.0: Added the `default` parameter.\n\nNew in version 2.7.\n\n&nbsp;\n\n`jinja-filters.max(value: 't.Iterable[V]', case_sensitive: bool = False, attribute: str | int | NoneType = None) → 't.Union[V, Undefined]'`  \nReturn the largest item from the sequence.\n\n``` jinja\n{{ [1, 2, 3]|max }}\n    -> 3\n```\n\nParameters:  \n- **case_sensitive** – Treat upper and lower case strings as distinct.\n- **attribute** – Get the object with the max value of this attribute.\n\n&nbsp;\n\n`jinja-filters.min(value: 't.Iterable[V]', case_sensitive: bool = False, attribute: str | int | NoneType = None) → 't.Union[V, Undefined]'`  \nReturn the smallest item from the sequence.\n\n``` jinja\n{{ [1, 2, 3]|min }}\n    -> 1\n```\n\nParameters:  \n- **case_sensitive** – Treat upper and lower case strings as distinct.\n- **attribute** – Get the object with the min value of this attribute.\n\n&nbsp;\n\n`jinja-filters.pprint(value: Any) → str`  \nPretty print a variable. Useful for debugging.\n\n&nbsp;\n\n`jinja-filters.random(seq: 't.Sequence[V]') → 't.Union[V, Undefined]'`  \nReturn a random item from the sequence.\n\n&nbsp;\n\n`jinja-filters.reject(value: 't.Iterable[V]', *args: Any, **kwargs: Any) → 't.Iterator[V]'`  \nFilters a sequence of objects by applying a test to each object, and rejecting the objects with the test succeeding.\n\nIf no test is specified, each object will be evaluated as a boolean.\n\nExample usage:\n\n``` jinja\n{{ numbers|reject(\"odd\") }}\n```\n\nSimilar to a generator comprehension such as:\n\n``` python\n(n for n in numbers if not test_odd(n))\n```\n\nChangelog\n\nNew in version 2.7.\n\n&nbsp;\n\n`jinja-filters.rejectattr(value: 't.Iterable[V]', *args: Any, **kwargs: Any) → 't.Iterator[V]'`  \nFilters a sequence of objects by applying a test to the specified attribute of each object, and rejecting the objects with the test succeeding.\n\nIf no test is specified, the attribute’s value will be evaluated as a boolean.\n\n``` jinja\n{{ users|rejectattr(\"is_active\") }}\n{{ users|rejectattr(\"email\", \"none\") }}\n```\n\nSimilar to a generator comprehension such as:\n\n``` python\n(u for user in users if not user.is_active)\n(u for user in users if not test_none(user.email))\n```\n\nChangelog\n\nNew in version 2.7.\n\n&nbsp;\n\n`jinja-filters.replace(s: str, old: str, new: str, count: int | None = None) → str`  \nReturn a copy of the value with all occurrences of a substring replaced with a new one. The first argument is the substring that should be replaced, the second is the replacement string. If the optional third argument `count` is given, only the first `count` occurrences are replaced:\n\n``` jinja\n{{ \"Hello World\"|replace(\"Hello\", \"Goodbye\") }}\n    -> Goodbye World\n\n{{ \"aaaaargh\"|replace(\"a\", \"d'oh, \", 2) }}\n    -> d'oh, d'oh, aaargh\n```\n\n&nbsp;\n\n`jinja-filters.reverse(value: str | Iterable[V]) → str | Iterable[V]`  \nReverse the object or return an iterator that iterates over it the other way round.\n\n&nbsp;\n\n`jinja-filters.round(value: float, precision: int = 0, method: 'te.Literal[\"common\", \"ceil\", \"floor\"]' = 'common') → float`  \nRound the number to a given precision. The first parameter specifies the precision (default is `0`), the second the rounding method:\n\n- `'common'` rounds either up or down\n- `'ceil'` always rounds up\n- `'floor'` always rounds down\n\nIf you don’t specify a method `'common'` is used.\n\n``` jinja\n{{ 42.55|round }}\n    -> 43.0\n{{ 42.55|round(1, 'floor') }}\n    -> 42.5\n```\n\nNote that even if rounded to 0 precision, a float is returned. If you need a real integer, pipe it through `int`:\n\n``` jinja\n{{ 42.55|round|int }}\n    -> 43\n```\n\n&nbsp;\n\n`jinja-filters.safe(value: str) → markupsafe.Markup`  \nMark the value as safe which means that in an environment with automatic escaping enabled this variable will not be escaped.\n\n&nbsp;\n\n`jinja-filters.select(value: 't.Iterable[V]', *args: Any, **kwargs: Any) → 't.Iterator[V]'`  \nFilters a sequence of objects by applying a test to each object, and only selecting the objects with the test succeeding.\n\nIf no test is specified, each object will be evaluated as a boolean.\n\nExample usage:\n\n``` jinja\n{{ numbers|select(\"odd\") }}\n{{ numbers|select(\"odd\") }}\n{{ numbers|select(\"divisibleby\", 3) }}\n{{ numbers|select(\"lessthan\", 42) }}\n{{ strings|select(\"equalto\", \"mystring\") }}\n```\n\nSimilar to a generator comprehension such as:\n\n``` python\n(n for n in numbers if test_odd(n))\n(n for n in numbers if test_divisibleby(n, 3))\n```\n\nChangelog\n\nNew in version 2.7.\n\n&nbsp;\n\n`jinja-filters.selectattr(value: 't.Iterable[V]', *args: Any, **kwargs: Any) → 't.Iterator[V]'`  \nFilters a sequence of objects by applying a test to the specified attribute of each object, and only selecting the objects with the test succeeding.\n\nIf no test is specified, the attribute’s value will be evaluated as a boolean.\n\nExample usage:\n\n``` jinja\n{{ users|selectattr(\"is_active\") }}\n{{ users|selectattr(\"email\", \"none\") }}\n```\n\nSimilar to a generator comprehension such as:\n\n``` python\n(u for user in users if user.is_active)\n(u for user in users if test_none(user.email))\n```\n\nChangelog\n\nNew in version 2.7.\n\n&nbsp;\n\n`jinja-filters.slice(value: 't.Collection[V]', slices: int, fill_with: 't.Optional[V]' = None) → 't.Iterator[t.List[V]]'`  \nSlice an iterator and return a list of lists containing those items. Useful if you want to create a div containing three ul tags that represent columns:\n\n``` html+jinja\n<div class=\"columnwrapper\">\n  {%- for column in items|slice(3) %}\n    <ul class=\"column-{{ loop.index }}\">\n    {%- for item in column %}\n      <li>{{ item }}</li>\n    {%- endfor %}\n    </ul>\n  {%- endfor %}\n</div>\n```\n\nIf you pass it a second argument it’s used to fill missing values on the last iteration.\n\n&nbsp;\n\n`jinja-filters.sort(value: 't.Iterable[V]', reverse: bool = False, case_sensitive: bool = False, attribute: str | int | NoneType = None) → 't.List[V]'`  \nSort an iterable using Python’s [`sorted()`](https://docs.python.org/3/library/functions.html#sorted \"(in Python v3.11)\").\n\n``` jinja\n{% for city in cities|sort %}\n    ...\n{% endfor %}\n```\n\nParameters:  \n- **reverse** – Sort descending instead of ascending.\n- **case_sensitive** – When sorting strings, sort upper and lower case separately.\n- **attribute** – When sorting objects or dicts, an attribute or key to sort by. Can use dot notation like `\"address.city\"`. Can be a list of attributes like `\"age,name\"`.\n\nThe sort is stable, it does not change the relative order of elements that compare equal. This makes it is possible to chain sorts on different attributes and ordering.\n\n``` jinja\n{% for user in users|sort(attribute=\"name\")\n    |sort(reverse=true, attribute=\"age\") %}\n    ...\n{% endfor %}\n```\n\nAs a shortcut to chaining when the direction is the same for all attributes, pass a comma separate list of attributes.\n\n``` jinja\n{% for user in users|sort(attribute=\"age,name\") %}\n    ...\n{% endfor %}\n```\n\nChangelog\n\nChanged in version 2.11.0: The `attribute` parameter can be a comma separated list of attributes, e.g. `\"age,name\"`.\n\nChanged in version 2.6: The `attribute` parameter was added.\n\n&nbsp;\n\n`jinja-filters.string(value)`  \nConvert an object to a string if it isn’t already. This preserves a `Markup` string rather than converting it back to a basic string, so it will still be marked as safe and won’t be escaped again.\n\n``` python\n>>> value = escape(\"<User 1>\")\n>>> value\nMarkup('&lt;User 1&gt;')\n>>> escape(str(value))\nMarkup('&amp;lt;User 1&amp;gt;')\n>>> escape(soft_str(value))\nMarkup('&lt;User 1&gt;')\n```\n\n&nbsp;\n\n`jinja-filters.striptags(value: 't.Union[str, HasHTML]') → str`  \nStrip SGML/XML tags and replace adjacent whitespace by one space.\n\n&nbsp;\n\n`jinja-filters.sum(iterable: 't.Iterable[V]', attribute: str | int | NoneType = None, start: V = 0) → V`  \nReturns the sum of a sequence of numbers plus the value of parameter ‘start’ (which defaults to 0). When the sequence is empty it returns start.\n\nIt is also possible to sum up only certain attributes:\n\n``` jinja\nTotal: {{ items|sum(attribute='price') }}\n```\n\nChangelog\n\nChanged in version 2.6: The `attribute` parameter was added to allow summing up over attributes. Also the `start` parameter was moved on to the right.\n\n&nbsp;\n\n`jinja-filters.title(s: str) → str`  \nReturn a titlecased version of the value. I.e. words will start with uppercase letters, all remaining characters are lowercase.\n\n&nbsp;\n\n`jinja-filters.tojson(value: Any, indent: int | None = None) → markupsafe.Markup`  \nSerialize an object to a string of JSON, and mark it safe to render in HTML. This filter is only for use in HTML documents.\n\nThe returned string is safe to render in HTML documents and `<script>` tags. The exception is in HTML attributes that are double quoted; either use single quotes or the `|forceescape` filter.\n\nParameters:  \n- **value** – The object to serialize to JSON.\n- **indent** – The `indent` parameter passed to `dumps`, for pretty-printing the value.\n\nChangelog\n\nNew in version 2.9.\n\n&nbsp;\n\n`jinja-filters.trim(value: str, chars: str | None = None) → str`  \nStrip leading and trailing characters, by default whitespace.\n\n&nbsp;\n\n`jinja-filters.truncate(s: str, length: int = 255, killwords: bool = False, end: str = '...', leeway: int | None = None) → str`  \nReturn a truncated copy of the string. The length is specified with the first parameter which defaults to `255`. If the second parameter is `true` the filter will cut the text at length. Otherwise it will discard the last word. If the text was in fact truncated it will append an ellipsis sign (`\"...\"`). If you want a different ellipsis sign than `\"...\"` you can specify it using the third parameter. Strings that only exceed the length by the tolerance margin given in the fourth parameter will not be truncated.\n\n``` jinja\n{{ \"foo bar baz qux\"|truncate(9) }}\n    -> \"foo...\"\n{{ \"foo bar baz qux\"|truncate(9, True) }}\n    -> \"foo ba...\"\n{{ \"foo bar baz qux\"|truncate(11) }}\n    -> \"foo bar baz qux\"\n{{ \"foo bar baz qux\"|truncate(11, False, '...', 0) }}\n    -> \"foo bar...\"\n```\n\nThe default leeway on newer Jinja versions is 5 and was 0 before but can be reconfigured globally.\n\n&nbsp;\n\n`jinja-filters.unique(value: 't.Iterable[V]', case_sensitive: bool = False, attribute: str | int | NoneType = None) → 't.Iterator[V]'`  \nReturns a list of unique items from the given iterable.\n\n``` jinja\n{{ ['foo', 'bar', 'foobar', 'FooBar']|unique|list }}\n    -> ['foo', 'bar', 'foobar']\n```\n\nThe unique items are yielded in the same order as their first occurrence in the iterable passed to the filter.\n\nParameters:  \n- **case_sensitive** – Treat upper and lower case strings as distinct.\n- **attribute** – Filter objects with unique values for this attribute.\n\n&nbsp;\n\n`jinja-filters.upper(s: str) → str`  \nConvert a value to uppercase.\n\n&nbsp;\n\n`jinja-filters.urlencode(value: str | Mapping[str, Any] | Iterable[Tuple[str, Any]]) → str`  \nQuote data for use in a URL path or query using UTF-8.\n\nBasic wrapper around [`urllib.parse.quote()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.quote \"(in Python v3.11)\") when given a string, or [`urllib.parse.urlencode()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlencode \"(in Python v3.11)\") for a dict or iterable.\n\nParameters:  \n**value** – Data to quote. A string will be quoted directly. A dict or iterable of `(key, value)` pairs will be joined as a query string.\n\nWhen given a string, “/” is not quoted. HTTP servers treat “/” and “%2F” equivalently in paths. If you need quoted slashes, use the `|replace(\"/\", \"%2F\")` filter.\n\nChangelog\n\nNew in version 2.7.\n\n&nbsp;\n\n`jinja-filters.urlize(value: str, trim_url_limit: int | None = None, nofollow: bool = False, target: str | None = None, rel: str | None = None, extra_schemes: Iterable[str] | None = None) → str`  \nConvert URLs in text into clickable links.\n\nThis may not recognize links in some situations. Usually, a more comprehensive formatter, such as a Markdown library, is a better choice.\n\nWorks on `http://`, `https://`, `www.`, `mailto:`, and email addresses. Links with trailing punctuation (periods, commas, closing parentheses) and leading punctuation (opening parentheses) are recognized excluding the punctuation. Email addresses that include header fields are not recognized (for example, `mailto:address@example.com?cc=copy@example.com`).\n\nParameters:  \n- **value** – Original text containing URLs to link.\n- **trim_url_limit** – Shorten displayed URL values to this length.\n- **nofollow** – Add the `rel=nofollow` attribute to links.\n- **target** – Add the `target` attribute to links.\n- **rel** – Add the `rel` attribute to links.\n- **extra_schemes** – Recognize URLs that start with these schemes in addition to the default behavior. Defaults to `env.policies[\"urlize.extra_schemes\"]`, which defaults to no extra schemes.\n\nChangelog\n\nChanged in version 3.0: The `extra_schemes` parameter was added.\n\nChanged in version 3.0: Generate `https://` links for URLs without a scheme.\n\nChanged in version 3.0: The parsing rules were updated. Recognize email addresses with or without the `mailto:` scheme. Validate IP addresses. Ignore parentheses and brackets in more cases.\n\nChanged in version 2.8: The `target` parameter was added.\n\n&nbsp;\n\n`jinja-filters.wordcount(s: str) → int`  \nCount the words in that string.\n\n&nbsp;\n\n`jinja-filters.wordwrap(s: str, width: int = 79, break_long_words: bool = True, wrapstring: str | None = None, break_on_hyphens: bool = True) → str`  \nWrap a string to the given width. Existing newlines are treated as paragraphs to be wrapped separately.\n\nParameters:  \n- **s** – Original text to wrap.\n- **width** – Maximum length of wrapped lines.\n- **break_long_words** – If a word is longer than `width`, break it across lines.\n- **break_on_hyphens** – If a word contains hyphens, it may be split across lines.\n- **wrapstring** – String to join each wrapped line. Defaults to `Environment.newline_sequence`.\n\nChangelog\n\nChanged in version 2.11: Existing newlines are treated as paragraphs wrapped separately.\n\nChanged in version 2.11: Added the `break_on_hyphens` parameter.\n\nChanged in version 2.7: Added the `wrapstring` parameter.\n\n&nbsp;\n\n`jinja-filters.xmlattr(d: Mapping[str, Any], autospace: bool = True) → str`  \nCreate an SGML/XML attribute string based on the items in a dict. All values that are neither `none` nor `undefined` are automatically escaped:\n\n``` html+jinja\n<ul{{ {'class': 'my_list', 'missing': none,\n        'id': 'list-%d'|format(variable)}|xmlattr }}>\n...\n</ul>\n```\n\nResults in something like this:\n\n``` html\n<ul class=\"my_list\" id=\"list-42\">\n...\n</ul>\n```\n\nAs you can see it automatically prepends a space in front of the item if the filter returned something unless the second parameter is false.\n\n## List of Builtin Tests\n\n|                                                                       |                                                        |                                                              |                                                           |                                                                 |\n|-----------------------------------------------------------------------|--------------------------------------------------------|--------------------------------------------------------------|-----------------------------------------------------------|-----------------------------------------------------------------|\n| [`boolean()`](#jinja-tests.boolean \"jinja-tests.boolean\")             | [`even()`](#jinja-tests.even \"jinja-tests.even\")       | [`in()`](#jinja-tests.in \"jinja-tests.in\")                   | [`mapping()`](#jinja-tests.mapping \"jinja-tests.mapping\") | [`sequence()`](#jinja-tests.sequence \"jinja-tests.sequence\")    |\n| [`callable()`](#jinja-tests.callable \"jinja-tests.callable\")          | [`false()`](#jinja-tests.false \"jinja-tests.false\")    | [`integer()`](#jinja-tests.integer \"jinja-tests.integer\")    | [`ne()`](#jinja-tests.ne \"jinja-tests.ne\")                | [`string()`](#jinja-tests.string \"jinja-tests.string\")          |\n| [`defined()`](#jinja-tests.defined \"jinja-tests.defined\")             | [`filter()`](#jinja-tests.filter \"jinja-tests.filter\") | [`iterable()`](#jinja-tests.iterable \"jinja-tests.iterable\") | [`none()`](#jinja-tests.none \"jinja-tests.none\")          | [`test()`](#jinja-tests.test \"jinja-tests.test\")                |\n| [`divisibleby()`](#jinja-tests.divisibleby \"jinja-tests.divisibleby\") | [`float()`](#jinja-tests.float \"jinja-tests.float\")    | [`le()`](#jinja-tests.le \"jinja-tests.le\")                   | [`number()`](#jinja-tests.number \"jinja-tests.number\")    | [`true()`](#jinja-tests.true \"jinja-tests.true\")                |\n| [`eq()`](#jinja-tests.eq \"jinja-tests.eq\")                            | [`ge()`](#jinja-tests.ge \"jinja-tests.ge\")             | [`lower()`](#jinja-tests.lower \"jinja-tests.lower\")          | [`odd()`](#jinja-tests.odd \"jinja-tests.odd\")             | [`undefined()`](#jinja-tests.undefined \"jinja-tests.undefined\") |\n| [`escaped()`](#jinja-tests.escaped \"jinja-tests.escaped\")             | [`gt()`](#jinja-tests.gt \"jinja-tests.gt\")             | [`lt()`](#jinja-tests.lt \"jinja-tests.lt\")                   | [`sameas()`](#jinja-tests.sameas \"jinja-tests.sameas\")    | [`upper()`](#jinja-tests.upper \"jinja-tests.upper\")             |\n\n`jinja-tests.boolean(value: Any) → bool`  \nReturn true if the object is a boolean value.\n\nChangelog\n\nNew in version 2.11.\n\n&nbsp;\n\n`jinja-tests.callable(obj, /)`  \nReturn whether the object is callable (i.e., some kind of function).\n\nNote that classes are callable, as are instances of classes with a \\_\\_call\\_\\_() method.\n\n&nbsp;\n\n`jinja-tests.defined(value: Any) → bool`  \nReturn true if the variable is defined:\n\n``` jinja\n{% if variable is defined %}\n    value of variable: {{ variable }}\n{% else %}\n    variable is not defined\n{% endif %}\n```\n\nSee the `default()` filter for a simple way to set undefined variables.\n\n&nbsp;\n\n`jinja-tests.divisibleby(value: int, num: int) → bool`  \nCheck if a variable is divisible by a number.\n\n&nbsp;\n\n`jinja-tests.eq(a, b, /)`  \nSame as a == b.\n\nAliases:  \n`==`, `equalto`\n\n&nbsp;\n\n`jinja-tests.escaped(value: Any) → bool`  \nCheck if the value is escaped.\n\n&nbsp;\n\n`jinja-tests.even(value: int) → bool`  \nReturn true if the variable is even.\n\n&nbsp;\n\n`jinja-tests.false(value: Any) → bool`  \nReturn true if the object is False.\n\nChangelog\n\nNew in version 2.11.\n\n&nbsp;\n\n`jinja-tests.filter(value: str) → bool`  \nCheck if a filter exists by name. Useful if a filter may be optionally available.\n\n``` jinja\n{% if 'markdown' is filter %}\n    {{ value | markdown }}\n{% else %}\n    {{ value }}\n{% endif %}\n```\n\nChangelog\n\nNew in version 3.0.\n\n&nbsp;\n\n`jinja-tests.float(value: Any) → bool`  \nReturn true if the object is a float.\n\nChangelog\n\nNew in version 2.11.\n\n&nbsp;\n\n`jinja-tests.ge(a, b, /)`  \nSame as a \\>= b.\n\nAliases:  \n`>=`\n\n&nbsp;\n\n`jinja-tests.gt(a, b, /)`  \nSame as a \\> b.\n\nAliases:  \n`>`, `greaterthan`\n\n&nbsp;\n\n`jinja-tests.in(value: Any, seq: Container) → bool`  \nCheck if value is in seq.\n\nChangelog\n\nNew in version 2.10.\n\n&nbsp;\n\n`jinja-tests.integer(value: Any) → bool`  \nReturn true if the object is an integer.\n\nChangelog\n\nNew in version 2.11.\n\n&nbsp;\n\n`jinja-tests.iterable(value: Any) → bool`  \nCheck if it’s possible to iterate over an object.\n\n&nbsp;\n\n`jinja-tests.le(a, b, /)`  \nSame as a \\<= b.\n\nAliases:  \n`<=`\n\n&nbsp;\n\n`jinja-tests.lower(value: str) → bool`  \nReturn true if the variable is lowercased.\n\n&nbsp;\n\n`jinja-tests.lt(a, b, /)`  \nSame as a \\< b.\n\nAliases:  \n`<`, `lessthan`\n\n&nbsp;\n\n`jinja-tests.mapping(value: Any) → bool`  \nReturn true if the object is a mapping (dict etc.).\n\nChangelog\n\nNew in version 2.6.\n\n&nbsp;\n\n`jinja-tests.ne(a, b, /)`  \nSame as a != b.\n\nAliases:  \n`!=`\n\n&nbsp;\n\n`jinja-tests.none(value: Any) → bool`  \nReturn true if the variable is none.\n\n&nbsp;\n\n`jinja-tests.number(value: Any) → bool`  \nReturn true if the variable is a number.\n\n&nbsp;\n\n`jinja-tests.odd(value: int) → bool`  \nReturn true if the variable is odd.\n\n&nbsp;\n\n`jinja-tests.sameas(value: Any, other: Any) → bool`  \nCheck if an object points to the same memory address than another object:\n\n``` jinja\n{% if foo.attribute is sameas false %}\n    the foo attribute really is the `False` singleton\n{% endif %}\n```\n\n&nbsp;\n\n`jinja-tests.sequence(value: Any) → bool`  \nReturn true if the variable is a sequence. Sequences are variables that are iterable.\n\n&nbsp;\n\n`jinja-tests.string(value: Any) → bool`  \nReturn true if the object is a string.\n\n&nbsp;\n\n`jinja-tests.test(value: str) → bool`  \nCheck if a test exists by name. Useful if a test may be optionally available.\n\n``` jinja\n{% if 'loud' is test %}\n    {% if value is loud %}\n        {{ value|upper }}\n    {% else %}\n        {{ value|lower }}\n    {% endif %}\n{% else %}\n    {{ value }}\n{% endif %}\n```\n\nChangelog\n\nNew in version 3.0.\n\n&nbsp;\n\n`jinja-tests.true(value: Any) → bool`  \nReturn true if the object is True.\n\nChangelog\n\nNew in version 2.11.\n\n&nbsp;\n\n`jinja-tests.undefined(value: Any) → bool`  \nLike [`defined()`](#jinja-tests.defined \"jinja-tests.defined\") but the other way round.\n\n&nbsp;\n\n`jinja-tests.upper(value: str) → bool`  \nReturn true if the variable is uppercased.\n\n## List of Global Functions\n\nThe following functions are available in the global scope by default:\n\n`jinja-globals.range([start, ]stop[, step])`  \nReturn a list containing an arithmetic progression of integers. `range(i, j)` returns `[i, i+1, i+2, ..., j-1]`; start (!) defaults to `0`. When step is given, it specifies the increment (or decrement). For example, `range(4)` and `range(0, 4, 1)` return `[0, 1, 2, 3]`. The end point is omitted! These are exactly the valid indices for a list of 4 elements.\n\nThis is useful to repeat a template block multiple times, e.g. to fill a list. Imagine you have 7 users in the list but you want to render three empty items to enforce a height with CSS:\n\n``` html+jinja\n<ul>\n{% for user in users %}\n    <li>{{ user.username }}</li>\n{% endfor %}\n{% for number in range(10 - users|count) %}\n    <li class=\"empty\"><span>...</span></li>\n{% endfor %}\n</ul>\n```\n\n&nbsp;\n\n`jinja-globals.lipsum(n=5, html=True, min=20, max=100)`  \nGenerates some lorem ipsum for the template. By default, five paragraphs of HTML are generated with each paragraph between 20 and 100 words. If html is False, regular text is returned. This is useful to generate simple contents for layout testing.\n\n&nbsp;\n\n`jinja-globals.dict(\\**items)`  \nA convenient alternative to dict literals. `{'foo': 'bar'}` is the same as `dict(foo='bar')`.\n\n&nbsp;\n\n`class jinja-globals.cycler(\\*items)`  \nCycle through values by yielding them one at a time, then restarting once the end is reached.\n\nSimilar to `loop.cycle`, but can be used outside loops or across multiple loops. For example, render a list of folders and files in a list, alternating giving them “odd” and “even” classes.\n\n``` html+jinja\n{% set row_class = cycler(\"odd\", \"even\") %}\n<ul class=\"browser\">\n{% for folder in folders %}\n  <li class=\"folder {{ row_class.next() }}\">{{ folder }}\n{% endfor %}\n{% for file in files %}\n  <li class=\"file {{ row_class.next() }}\">{{ file }}\n{% endfor %}\n</ul>\n```\n\nParameters:  \n**items** – Each positional argument will be yielded in the order given for each cycle.\n\nChangelog\n\nNew in version 2.1.\n\n`property current`  \nReturn the current item. Equivalent to the item that will be returned next time [`next()`](#jinja-globals.cycler.next \"jinja-globals.cycler.next\") is called.\n\n`next()`  \nReturn the current item, then advance [`current`](#jinja-globals.cycler.current \"jinja-globals.cycler.current\") to the next item.\n\n`reset()`  \nResets the current item to the first item.\n\n&nbsp;\n\n`class jinja-globals.joiner(sep=', ')`  \nA tiny helper that can be used to “join” multiple sections. A joiner is passed a string and will return that string every time it’s called, except the first time (in which case it returns an empty string). You can use this to join things:\n\n``` html+jinja\n{% set pipe = joiner(\"|\") %}\n{% if categories %} {{ pipe() }}\n    Categories: {{ categories|join(\", \") }}\n{% endif %}\n{% if author %} {{ pipe() }}\n    Author: {{ author() }}\n{% endif %}\n{% if can_edit %} {{ pipe() }}\n    <a href=\"?action=edit\">Edit</a>\n{% endif %}\n```\n\nChangelog\n\nNew in version 2.1.\n\n&nbsp;\n\n`class jinja-globals.namespace(...)`  \nCreates a new container that allows attribute assignment using the `{% set %}` tag:\n\n``` html+jinja\n{% set ns = namespace() %}\n{% set ns.foo = 'bar' %}\n```\n\nThe main purpose of this is to allow carrying a value from within a loop body to an outer scope. Initial values can be provided as a dict, as keyword arguments, or both (same behavior as Python’s `dict` constructor):\n\n``` html+jinja\n{% set ns = namespace(found=false) %}\n{% for item in items %}\n    {% if item.check_something() %}\n        {% set ns.found = true %}\n    {% endif %}\n    * {{ item.title }}\n{% endfor %}\nFound item having something: {{ ns.found }}\n```\n\nChangelog\n\nNew in version 2.10.\n\n## Extensions\n\nThe following sections cover the built-in Jinja extensions that may be enabled by an application. An application could also provide further extensions not covered by this documentation; in which case there should be a separate document explaining said [extensions](../extensions/index#jinja-extensions).\n\n### i18n\n\nIf the [i18n Extension](../extensions/index#i18n-extension) is enabled, it’s possible to mark text in the template as translatable. To mark a section as translatable, use a `trans` block:\n\n``` jinja\n{% trans %}Hello, {{ user }}!{% endtrans %}\n```\n\nInside the block, no statements are allowed, only text and simple variable tags.\n\nVariable tags can only be a name, not attribute access, filters, or other expressions. To use an expression, bind it to a name in the `trans` tag for use in the block.\n\n``` jinja\n{% trans user=user.username %}Hello, {{ user }}!{% endtrans %}\n```\n\nTo bind more than one expression, separate each with a comma (`,`).\n\n``` jinja\n{% trans book_title=book.title, author=author.name %}\nThis is {{ book_title }} by {{ author }}\n{% endtrans %}\n```\n\nTo pluralize, specify both the singular and plural forms separated by the `pluralize` tag.\n\n``` jinja\n{% trans count=list|length %}\nThere is {{ count }} {{ name }} object.\n{% pluralize %}\nThere are {{ count }} {{ name }} objects.\n{% endtrans %}\n```\n\nBy default, the first variable in a block is used to determine whether to use singular or plural form. If that isn’t correct, specify the variable used for pluralizing as a parameter to `pluralize`.\n\n``` jinja\n{% trans ..., user_count=users|length %}...\n{% pluralize user_count %}...{% endtrans %}\n```\n\nWhen translating blocks of text, whitespace and linebreaks result in hard to read and error-prone translation strings. To avoid this, a trans block can be marked as trimmed, which will replace all linebreaks and the whitespace surrounding them with a single space and remove leading and trailing whitespace.\n\n``` jinja\n{% trans trimmed book_title=book.title %}\n    This is {{ book_title }}.\n    You should read it!\n{% endtrans %}\n```\n\nThis results in `This is %(book_title)s. You should read it!` in the translation file.\n\nIf trimming is enabled globally, the `notrimmed` modifier can be used to disable it for a block.\n\nChangelog\n\nNew in version 2.10: The `trimmed` and `notrimmed` modifiers have been added.\n\nIf the translation depends on the context that the message appears in, the `pgettext` and `npgettext` functions take a `context` string as the first argument, which is used to select the appropriate translation. To specify a context with the `{% trans %}` tag, provide a string as the first token after `trans`.\n\n``` jinja\n{% trans \"fruit\" %}apple{% endtrans %}\n{% trans \"fruit\" trimmed count -%}\n    1 apple\n{%- pluralize -%}\n    {{ count }} apples\n{%- endtrans %}\n```\n\nNew in version 3.1: A context can be passed to the `trans` tag to use `pgettext` and `npgettext`.\n\nIt’s possible to translate strings in expressions with these functions:\n\n- `_(message)`: Alias for `gettext`.\n- `gettext(message)`: Translate a message.\n- `ngettext(singluar, plural, n)`: Translate a singular or plural message based on a count variable.\n- `pgettext(context, message)`: Like `gettext()`, but picks the translation based on the context string.\n- `npgettext(context, singular, plural, n)`: Like `npgettext()`, but picks the translation based on the context string.\n\nYou can print a translated string like this:\n\n``` jinja\n{{ _(\"Hello, World!\") }}\n```\n\nTo use placeholders, use the `format` filter.\n\n``` jinja\n{{ _(\"Hello, %(user)s!\")|format(user=user.username) }}\n```\n\nAlways use keyword arguments to `format`, as other languages may not use the words in the same order.\n\nIf [New Style Gettext](../extensions/index#newstyle-gettext) calls are activated, using placeholders is easier. Formatting is part of the `gettext` call instead of using the `format` filter.\n\n``` jinja\n{{ gettext('Hello World!') }}\n{{ gettext('Hello %(name)s!', name='World') }}\n{{ ngettext('%(num)d apple', '%(num)d apples', apples|count) }}\n```\n\nThe `ngettext` function’s format string automatically receives the count as a `num` parameter in addition to the given parameters.\n\n### Expression Statement\n\nIf the expression-statement extension is loaded, a tag called `do` is available that works exactly like the regular variable expression (`{{ ... }}`); except it doesn’t print anything. This can be used to modify lists:\n\n``` html+jinja\n{% do navigation.append('a string') %}\n```\n\n### Loop Controls\n\nIf the application enables the [Loop Controls](../extensions/index#loopcontrols-extension), it’s possible to use `break` and `continue` in loops. When `break` is reached, the loop is terminated; if `continue` is reached, the processing is stopped and continues with the next iteration.\n\nHere’s a loop that skips every second item:\n\n``` html+jinja\n{% for user in users %}\n    {%- if loop.index is even %}{% continue %}{% endif %}\n    ...\n{% endfor %}\n```\n\nLikewise, a loop that stops processing after the 10th iteration:\n\n``` html+jinja\n{% for user in users %}\n    {%- if loop.index >= 10 %}{% break %}{% endif %}\n{%- endfor %}\n```\n\nNote that `loop.index` starts with 1, and `loop.index0` starts with 0 (See: [For](#for-loop)).\n\n### Debug Statement\n\nIf the [Debug Extension](../extensions/index#debug-extension) is enabled, a `{% debug %}` tag will be available to dump the current context as well as the available filters and tests. This is useful to see what’s available to use in the template without setting up a debugger.\n\n``` html+jinja\n<pre>{% debug %}</pre>\n```\n\n``` text\n{'context': {'cycler': <class 'jinja2.utils.Cycler'>,\n             ...,\n             'namespace': <class 'jinja2.utils.Namespace'>},\n 'filters': ['abs', 'attr', 'batch', 'capitalize', 'center', 'count', 'd',\n             ..., 'urlencode', 'urlize', 'wordcount', 'wordwrap', 'xmlattr'],\n 'tests': ['!=', '<', '<=', '==', '>', '>=', 'callable', 'defined',\n           ..., 'odd', 'sameas', 'sequence', 'string', 'undefined', 'upper']}\n```\n\n### With Statement\n\nChangelog\n\nNew in version 2.3.\n\nThe with statement makes it possible to create a new inner scope. Variables set within this scope are not visible outside of the scope.\n\nWith in a nutshell:\n\n``` html+jinja\n{% with %}\n    {% set foo = 42 %}\n    {{ foo }}           foo is 42 here\n{% endwith %}\nfoo is not visible here any longer\n```\n\nBecause it is common to set variables at the beginning of the scope, you can do that within the `with` statement. The following two examples are equivalent:\n\n``` html+jinja\n{% with foo = 42 %}\n    {{ foo }}\n{% endwith %}\n\n{% with %}\n    {% set foo = 42 %}\n    {{ foo }}\n{% endwith %}\n```\n\nAn important note on scoping here. In Jinja versions before 2.9 the behavior of referencing one variable to another had some unintended consequences. In particular one variable could refer to another defined in the same with block’s opening statement. This caused issues with the cleaned up scoping behavior and has since been improved. In particular in newer Jinja versions the following code always refers to the variable `a` from outside the `with` block:\n\n``` html+jinja\n{% with a={}, b=a.attribute %}...{% endwith %}\n```\n\nIn earlier Jinja versions the `b` attribute would refer to the results of the first attribute. If you depend on this behavior you can rewrite it to use the `set` tag:\n\n``` html+jinja\n{% with a={} %}\n    {% set b = a.attribute %}\n{% endwith %}\n```\n\nExtension\n\nIn older versions of Jinja (before 2.9) it was required to enable this feature with an extension. It’s now enabled by default.\n\n## Autoescape Overrides\n\nChangelog\n\nNew in version 2.4.\n\nIf you want you can activate and deactivate the autoescaping from within the templates.\n\nExample:\n\n``` html+jinja\n{% autoescape true %}\n    Autoescaping is active within this block\n{% endautoescape %}\n\n{% autoescape false %}\n    Autoescaping is inactive within this block\n{% endautoescape %}\n```\n\nAfter an `endautoescape` the behavior is reverted to what it was before.\n\nExtension\n\nIn older versions of Jinja (before 2.9) it was required to enable this feature with an extension. It’s now enabled by default.\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/templates/](https://jinja.palletsprojects.com/en/3.1.x/templates/)"
- name: Template.blocks
  id: api/index#jinja2.Template.blocks
  summary: A dict of block render functions
  description: |-
    `Template.blocks`

    A dict of block render functions. Each of these functions works exactly like the [`root_render_func()`](#jinja2.Template.root_render_func "jinja2.Template.root_render_func") with the same limitations.
- name: Template.filename
  id: api/index#jinja2.Template.filename
  summary: The filename of the template on the file system if it was loaded from there
  description: |-
    `filename`

    The filename of the template on the file system if it was loaded from there. Otherwise this is `None`.
- name: Template.generate()
  id: api/index#jinja2.Template.generate
  summary: For very large templates it can be useful to not render the whole template at once but evaluate each statement after another and yield piece for piece
  description: |-
    `generate([context])`

    For very large templates it can be useful to not render the whole template at once but evaluate each statement after another and yield piece for piece. This method basically does exactly that and returns a generator that yields one item after another as strings.

    It accepts the same arguments as [`render()`](#jinja2.Template.render "jinja2.Template.render").

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\]
- name: Template.generate_async()
  id: api/index#jinja2.Template.generate_async
  summary: An async version of generate()
  description: |-
    `async generate_async([context])`

    An async version of [`generate()`](#jinja2.Template.generate "jinja2.Template.generate"). Works very similarly but returns an async iterator instead.

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [AsyncIterator](https://docs.python.org/3/library/typing.html#typing.AsyncIterator "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\]
- name: Template.globals
  id: api/index#jinja2.Template.globals
  summary: A dict of variables that are available every time the template is rendered, without needing to pass them during render
  description: |-
    `globals`

    A dict of variables that are available every time the template is rendered, without needing to pass them during render. This should not be modified, as depending on how the template was loaded it may be shared with the environment and other templates.

    Defaults to [`Environment.globals`](#jinja2.Environment.globals "jinja2.Environment.globals") unless extra values are passed to [`Environment.get_template()`](#jinja2.Environment.get_template "jinja2.Environment.get_template").

    Globals are only intended for data that is common to every render of the template. Specific data should be passed to [`render()`](#jinja2.Template.render "jinja2.Template.render").

    See [The Global Namespace](#global-namespace).
- name: Template.is_up_to_date
  id: api/index#jinja2.Template.is_up_to_date
  summary: This attribute is False if there is a newer version of the template available, otherwise True
  description: |-
    `Template.is_up_to_date`

    This attribute is `False` if there is a newer version of the template available, otherwise `True`.

    Note

    The low-level API is fragile. Future Jinja versions will try not to change it in a backwards incompatible way but modifications in the Jinja core may shine through. For example if Jinja introduces a new AST node in later versions that may be returned by [`parse()`](#jinja2.Environment.parse "jinja2.Environment.parse").

    ## The Meta API

    Changelog

    New in version 2.2.

    The meta API returns some information about abstract syntax trees that could help applications to implement more advanced template concepts. All the functions of the meta API operate on an abstract syntax tree as returned by the [`Environment.parse()`](#jinja2.Environment.parse "jinja2.Environment.parse") method.
- name: Template.make_module()
  id: api/index#jinja2.Template.make_module
  summary: This method works like the module attribute when called without arguments but it will evaluate the template on every call rather than caching it
  description: |-
    `make_module(vars=None, shared=False, locals=None)`

    This method works like the [`module`](#jinja2.Template.module "jinja2.Template.module") attribute when called without arguments but it will evaluate the template on every call rather than caching it. It’s also possible to provide a dict which is then used as context. The arguments are the same as for the [`new_context()`](#jinja2.Template.new_context "jinja2.Template.new_context") method.

    Parameters:

    - **vars** ([Dict](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –
    - **shared** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **locals** ([Mapping](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –

    Return type:

    *TemplateModule*
- name: Template.module
  id: api/index#jinja2.Template.module
  summary: The template as module
  description: |-
    `property module: TemplateModule`

    The template as module. This is used for imports in the template runtime but is also useful if one wants to access exported template variables from the Python layer:

    ``` python
    >>> t = Template('{% macro foo() %}42{% endmacro %}23')
    >>> str(t.module)
    '23'
    >>> t.module.foo() == u'42'
    True
    ```

    This attribute is not available if async mode is enabled.
- name: Template.name
  id: api/index#jinja2.Template.name
  summary: The loading name of the template
  description: |-
    `name`

    The loading name of the template. If the template was loaded from a string this is `None`.
- name: Template.new_context()
  id: api/index#jinja2.Template.new_context
  summary: Create a new Context for this template
  description: |-
    `Template.new_context(vars=None, shared=False, locals=None)`

    Create a new `Context` for this template. The vars provided will be passed to the template. Per default the globals are added to the context. If shared is set to `True` the data is passed as is to the context without adding the globals.

    `locals` can be a dict of local variables for internal usage.

    Parameters:

    - **vars** ([Dict](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –
    - **shared** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **locals** ([Mapping](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –

    Return type:

    [Context](#jinja2.runtime.Context "jinja2.runtime.Context")
- name: Template.render()
  id: api/index#jinja2.Template.render
  summary: 'This method accepts the same arguments as the dict constructor: A dict, a dict subclass or some keyword arguments'
  description: |-
    `render([context])`

    This method accepts the same arguments as the `dict` constructor: A dict, a dict subclass or some keyword arguments. If no arguments are given the context will be empty. These two calls do the same:

    ``` python
    template.render(knights='that say nih')
    template.render({'knights': 'that say nih'})
    ```

    This will return the rendered template as a string.

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: Template.render_async()
  id: api/index#jinja2.Template.render_async
  summary: This works similar to render() but returns a coroutine that when awaited returns the entire rendered template string
  description: |-
    `async render_async([context])`

    This works similar to [`render()`](#jinja2.Template.render "jinja2.Template.render") but returns a coroutine that when awaited returns the entire rendered template string. This requires the async feature to be enabled.

    Example usage:

    ``` python
    await template.render_async(knights='that say nih; asynchronously')
    ```

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: Template.root_render_func()
  id: api/index#jinja2.Template.root_render_func
  summary: This is the low level render function
  description: |-
    `Template.root_render_func(context)`

    This is the low level render function. It’s passed a `Context` that has to be created by [`new_context()`](#jinja2.Template.new_context "jinja2.Template.new_context") of the same template or a compatible template. This render function is generated by the compiler from the template code and returns a generator that yields strings.

    If an exception in the template code happens the template engine will not rewrite the exception but pass through the original one. As a matter of fact this function should only be called from within a [`render()`](#jinja2.Template.render "jinja2.Template.render") / [`generate()`](#jinja2.Template.generate "jinja2.Template.generate") / [`stream()`](#jinja2.Template.stream "jinja2.Template.stream") call.
- name: Template.stream()
  id: api/index#jinja2.Template.stream
  summary: Works exactly like generate() but returns a TemplateStream
  description: |-
    `stream([context])`

    Works exactly like [`generate()`](#jinja2.Template.generate "jinja2.Template.generate") but returns a `TemplateStream`.

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [TemplateStream](#jinja2.environment.TemplateStream "jinja2.environment.TemplateStream")
- name: TemplateAssertionError
  id: api/index#jinja2.TemplateAssertionError
  summary: Like a template syntax error, but covers cases where something in the template caused an error at compile time that wasn’t necessarily caused by a syntax error
  description: |-
    `exception jinja2.TemplateAssertionError(message, lineno, name=None, filename=None)`

    Like a template syntax error, but covers cases where something in the template caused an error at compile time that wasn’t necessarily caused by a syntax error. However it’s a direct subclass of [`TemplateSyntaxError`](#jinja2.TemplateSyntaxError "jinja2.TemplateSyntaxError") and has the same attributes.

    Parameters:

    - **message** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **lineno** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    None

    ## Custom Filters

    Filters are Python functions that take the value to the left of the filter as the first argument and produce a new value. Arguments passed to the filter are passed after the value.

    For example, the filter `{{ 42|myfilter(23) }}` is called behind the scenes as `myfilter(42, 23)`.

    Jinja comes with some [built-in filters](../templates/index#builtin-filters). To use a custom filter, write a function that takes at least a `value` argument, then register it in [`Environment.filters`](#jinja2.Environment.filters "jinja2.Environment.filters").

    Here’s a filter that formats datetime objects:

    ``` python
    def datetime_format(value, format="%H:%M %d-%m-%y"):
        return value.strftime(format)

    environment.filters["datetime_format"] = datetime_format
    ```

    Now it can be used in templates:

    ``` jinja
    {{ article.pub_date|datetimeformat }}
    {{ article.pub_date|datetimeformat("%B %Y") }}
    ```

    Some decorators are available to tell Jinja to pass extra information to the filter. The object is passed as the first argument, making the value being filtered the second argument.

    - [`pass_environment()`](#jinja2.pass_environment "jinja2.pass_environment") passes the [`Environment`](#jinja2.Environment "jinja2.Environment").
    - [`pass_eval_context()`](#jinja2.pass_eval_context "jinja2.pass_eval_context") passes the [Evaluation Context](#eval-context).
    - [`pass_context()`](#jinja2.pass_context "jinja2.pass_context") passes the current [`Context`](#jinja2.runtime.Context "jinja2.runtime.Context").

    Here’s a filter that converts line breaks into HTML `<br>` and `<p>` tags. It uses the eval context to check if autoescape is currently enabled before escaping the input and marking the output safe.

    ``` python
    import re
    from jinja2 import pass_eval_context
    from markupsafe import Markup, escape

    @pass_eval_context
    def nl2br(eval_ctx, value):
        br = "<br>\n"

        if eval_ctx.autoescape:
            value = escape(value)
            br = Markup(br)

        result = "\n\n".join(
            f"<p>{br.join(p.splitlines())}<\p>"
            for p in re.split(r"(?:\r\n|\r(?!\n)|\n){2,}", value)
        )
        return Markup(result) if autoescape else result
    ```

    ## Custom Tests

    Test are Python functions that take the value to the left of the test as the first argument, and return `True` or `False`. Arguments passed to the test are passed after the value.

    For example, the test `{{ 42 is even }}` is called behind the scenes as `is_even(42)`.

    Jinja comes with some [built-in tests](../templates/index#builtin-tests). To use a custom tests, write a function that takes at least a `value` argument, then register it in [`Environment.tests`](#jinja2.Environment.tests "jinja2.Environment.tests").

    Here’s a test that checks if a value is a prime number:

    ``` python
    import math

    def is_prime(n):
        if n == 2:
            return True

        for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
            if n % i == 0:
                return False

        return True

    environment.tests["prime"] = is_prime
    ```

    Now it can be used in templates:

    ``` jinja
    {% if value is prime %}
        {{ value }} is a prime number
    {% else %}
        {{ value }} is not a prime number
    {% endif %}
    ```

    Some decorators are available to tell Jinja to pass extra information to the test. The object is passed as the first argument, making the value being tested the second argument.

    - [`pass_environment()`](#jinja2.pass_environment "jinja2.pass_environment") passes the [`Environment`](#jinja2.Environment "jinja2.Environment").
    - [`pass_eval_context()`](#jinja2.pass_eval_context "jinja2.pass_eval_context") passes the [Evaluation Context](#eval-context).
    - [`pass_context()`](#jinja2.pass_context "jinja2.pass_context") passes the current [`Context`](#jinja2.runtime.Context "jinja2.runtime.Context").

    ## Evaluation Context

    The evaluation context (short eval context or eval ctx) makes it possible to activate and deactivate compiled features at runtime.

    Currently it is only used to enable and disable automatic escaping, but it can be used by extensions as well.

    The `autoescape` setting should be checked on the evaluation context, not the environment. The evaluation context will have the computed value for the current template.

    Instead of `pass_environment`:

    ``` python
    @pass_environment
    def filter(env, value):
        result = do_something(value)

        if env.autoescape:
            result = Markup(result)

        return result
    ```

    Use `pass_eval_context` if you only need the setting:

    ``` python
    @pass_eval_context
    def filter(eval_ctx, value):
        result = do_something(value)

        if eval_ctx.autoescape:
            result = Markup(result)

        return result
    ```

    Or use `pass_context` if you need other context behavior as well:

    ``` python
    @pass_context
    def filter(context, value):
        result = do_something(value)

        if context.eval_ctx.autoescape:
            result = Markup(result)

        return result
    ```

    The evaluation context must not be modified at runtime. Modifications must only happen with a [`nodes.EvalContextModifier`](../extensions/index#jinja2.nodes.EvalContextModifier "jinja2.nodes.EvalContextModifier") and [`nodes.ScopedEvalContextModifier`](../extensions/index#jinja2.nodes.ScopedEvalContextModifier "jinja2.nodes.ScopedEvalContextModifier") from an extension, not on the eval context object itself.
- name: TemplateData
  id: extensions/index#jinja2.nodes.TemplateData
  summary: A constant template string
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.TemplateData(data)`

    A constant template string.

    Node type:

    [`Literal`](#jinja2.nodes.Literal "jinja2.nodes.Literal")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: TemplateError
  id: api/index#jinja2.TemplateError
  summary: Baseclass for all template errors
  description: |-
    `exception jinja2.TemplateError(message=None)`

    Baseclass for all template errors.

    Parameters:

    **message** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: TemplateNotFound
  id: api/index#jinja2.TemplateNotFound
  summary: Raised if a template does not exist
  description: |-
    `exception jinja2.TemplateNotFound(name, message=None)`

    Raised if a template does not exist.

    Changelog

    Changed in version 2.11: If the given name is [`Undefined`](#jinja2.Undefined "jinja2.Undefined") and no message was provided, an [`UndefinedError`](#jinja2.UndefinedError "jinja2.UndefinedError") is raised.

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Undefined](#jinja2.Undefined "jinja2.Undefined") *\|* *None*) –
    - **message** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: TemplateRuntimeError
  id: api/index#jinja2.TemplateRuntimeError
  summary: A generic runtime error in the template engine
  description: |-
    `exception jinja2.TemplateRuntimeError(message=None)`

    A generic runtime error in the template engine. Under some situations Jinja may raise this exception.

    Parameters:

    **message** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: TemplatesNotFound
  id: api/index#jinja2.TemplatesNotFound
  summary: Like TemplateNotFound but raised if multiple templates are selected
  description: |-
    `exception jinja2.TemplatesNotFound(names=(), message=None)`

    Like [`TemplateNotFound`](#jinja2.TemplateNotFound "jinja2.TemplateNotFound") but raised if multiple templates are selected. This is a subclass of [`TemplateNotFound`](#jinja2.TemplateNotFound "jinja2.TemplateNotFound") exception, so just catching the base exception will catch both.

    Changelog

    Changed in version 2.11: If a name in the list of names is [`Undefined`](#jinja2.Undefined "jinja2.Undefined"), a message about it being undefined is shown rather than the empty string.

    New in version 2.2.

    Parameters:

    - **names** ([Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Undefined](#jinja2.Undefined "jinja2.Undefined")*\]*) –
    - **message** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: TemplateStream
  id: api/index#jinja2.environment.TemplateStream
  summary: A template stream works pretty much like an ordinary python generator but it can buffer multiple items to reduce the number of total iterations
  description: |-
    `class jinja2.environment.TemplateStream`

    A template stream works pretty much like an ordinary python generator but it can buffer multiple items to reduce the number of total iterations. Per default the output is unbuffered which means that for every unbuffered instruction in the template one string is yielded.

    If buffering is enabled with a buffer size of 5, five items are combined into a new string. This is mainly useful if you are streaming big templates to a client via WSGI which flushes after each iteration.

    Parameters:

    **gen** ([Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]*) –
- name: TemplateStream.disable_buffering()
  id: api/index#jinja2.environment.TemplateStream.disable_buffering
  summary: Disable the output buffering
  description: |-
    `disable_buffering()`

    Disable the output buffering.

    Return type:

    None
- name: TemplateStream.dump()
  id: api/index#jinja2.environment.TemplateStream.dump
  summary: Dump the complete stream into a file or file-like object
  description: |-
    `dump(fp, encoding=None, errors='strict')`

    Dump the complete stream into a file or file-like object. Per default strings are written, if you want to encode before writing specify an `encoding`.

    Example usage:

    ``` python
    Template('Hello {{ name }}!').stream(name='foo').dump('hello.html')
    ```

    Parameters:

    - **fp** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [IO](https://docs.python.org/3/library/typing.html#typing.IO "(in Python v3.11)")) –
    - **encoding** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **errors** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: TemplateStream.enable_buffering()
  id: api/index#jinja2.environment.TemplateStream.enable_buffering
  summary: Enable buffering
  description: |-
    `enable_buffering(size=5)`

    Enable buffering. Buffer `size` items before yielding them.

    Parameters:

    **size** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –

    Return type:

    None

    ## Autoescaping

    Changelog

    Changed in version 2.4.

    Jinja now comes with autoescaping support. As of Jinja 2.9 the autoescape extension is removed and built-in. However autoescaping is not yet enabled by default though this will most likely change in the future. It’s recommended to configure a sensible default for autoescaping. This makes it possible to enable and disable autoescaping on a per-template basis (HTML versus text for instance).
- name: TemplateSyntaxError
  id: api/index#jinja2.TemplateSyntaxError
  summary: Raised to tell the user that there is a problem with the template
  description: |-
    `exception jinja2.TemplateSyntaxError(message, lineno, name=None, filename=None)`

    Raised to tell the user that there is a problem with the template.

    Parameters:

    - **message** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **lineno** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: TemplateSyntaxError.filename
  id: api/index#jinja2.TemplateSyntaxError.filename
  summary: The filename that loaded the template in the encoding of the file system (most likely utf-8, or mbcs on Windows systems)
  description: |-
    `filename`

    The filename that loaded the template in the encoding of the file system (most likely utf-8, or mbcs on Windows systems).
- name: TemplateSyntaxError.lineno
  id: api/index#jinja2.TemplateSyntaxError.lineno
  summary: The line number where the error occurred
  description: |-
    `lineno`

    The line number where the error occurred.
- name: TemplateSyntaxError.message
  id: api/index#jinja2.TemplateSyntaxError.message
  summary: The error message
  description: |-
    `message`

    The error message.
- name: TemplateSyntaxError.name
  id: api/index#jinja2.TemplateSyntaxError.name
  summary: The load name for the template
  description: |-
    `name`

    The load name for the template.
- name: Test
  id: extensions/index#jinja2.nodes.Test
  summary: Apply a test to an expression
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Test(node, name, args, kwargs, dyn_args, dyn_kwargs)`

    Apply a test to an expression. `name` is the name of the test, the other field are the same as [`Call`](#jinja2.nodes.Call "jinja2.nodes.Call").

    Changelog

    Changed in version 3.0: `as_const` shares the same logic for filters and tests. Tests check for volatile, async, and `@pass_context` etc. decorators.

    Node type:

    [`_FilterTestCommon`](#jinja2.nodes._FilterTestCommon "jinja2.nodes._FilterTestCommon")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: test()
  id: templates/index#jinja-tests.test
  summary: Check if a test exists by name
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.test(value: str) → bool`

    Check if a test exists by name. Useful if a test may be optionally available.

    ``` jinja
    {% if 'loud' is test %}
        {% if value is loud %}
            {{ value|upper }}
        {% else %}
            {{ value|lower }}
        {% endif %}
    {% else %}
        {{ value }}
    {% endif %}
    ```

    Changelog

    New in version 3.0.
- name: Tips and Tricks
  id: tricks/index
  summary: This part of the documentation shows some tips and tricks for Jinja templates
  description: "# Tips and Tricks\n\nThis part of the documentation shows some tips and tricks for Jinja templates.\n\n## Null-Default Fallback\n\nJinja supports dynamic inheritance and does not distinguish between parent and child template as long as no `extends` tag is visited. While this leads to the surprising behavior that everything before the first `extends` tag including whitespace is printed out instead of being ignored, it can be used for a neat trick.\n\nUsually child templates extend from one template that adds a basic HTML skeleton. However it’s possible to put the `extends` tag into an `if` tag to only extend from the layout template if the `standalone` variable evaluates to false which it does per default if it’s not defined. Additionally a very basic skeleton is added to the file so that if it’s indeed rendered with `standalone` set to `True` a very basic HTML skeleton is added:\n\n``` html+jinja\n{% if not standalone %}{% extends 'default.html' %}{% endif -%}\n<!DOCTYPE html>\n<title>{% block title %}The Page Title{% endblock %}</title>\n<link rel=\"stylesheet\" href=\"style.css\" type=\"text/css\">\n{% block body %}\n  <p>This is the page body.</p>\n{% endblock %}\n```\n\n## Alternating Rows\n\nIf you want to have different styles for each row of a table or list you can use the `cycle` method on the `loop` object:\n\n``` html+jinja\n<ul>\n{% for row in rows %}\n  <li class=\"{{ loop.cycle('odd', 'even') }}\">{{ row }}</li>\n{% endfor %}\n</ul>\n```\n\n`cycle` can take an unlimited number of strings. Each time this tag is encountered the next item from the list is rendered.\n\n## Highlighting Active Menu Items\n\nOften you want to have a navigation bar with an active navigation item. This is really simple to achieve. Because assignments outside of `block`s in child templates are global and executed before the layout template is evaluated it’s possible to define the active menu item in the child template:\n\n``` html+jinja\n{% extends \"layout.html\" %}\n{% set active_page = \"index\" %}\n```\n\nThe layout template can then access `active_page`. Additionally it makes sense to define a default for that variable:\n\n``` html+jinja\n{% set navigation_bar = [\n    ('/', 'index', 'Index'),\n    ('/downloads/', 'downloads', 'Downloads'),\n    ('/about/', 'about', 'About')\n] -%}\n{% set active_page = active_page|default('index') -%}\n...\n<ul id=\"navigation\">\n{% for href, id, caption in navigation_bar %}\n  <li{% if id == active_page %} class=\"active\"{% endif %}>\n  <a href=\"{{ href|e }}\">{{ caption|e }}</a></li>\n{% endfor %}\n</ul>\n...\n```\n\n## Accessing the parent Loop\n\nThe special `loop` variable always points to the innermost loop. If it’s desired to have access to an outer loop it’s possible to alias it:\n\n``` html+jinja\n<table>\n{% for row in table %}\n  <tr>\n  {% set rowloop = loop %}\n  {% for cell in row %}\n    <td id=\"cell-{{ rowloop.index }}-{{ loop.index }}\">{{ cell }}</td>\n  {% endfor %}\n  </tr>\n{% endfor %}\n</table>\n```\n\n© 2007–2021 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://jinja.palletsprojects.com/en/3.1.x/tricks/](https://jinja.palletsprojects.com/en/3.1.x/tricks/)"
- name: title()
  id: templates/index#jinja-filters.title
  summary: Return a titlecased version of the value
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.title(s: str) → str`

    Return a titlecased version of the value. I.e. words will start with uppercase letters, all remaining characters are lowercase.
- name: tojson()
  id: templates/index#jinja-filters.tojson
  summary: Serialize an object to a string of JSON, and mark it safe to render in HTML
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.tojson(value: Any, indent: int | None = None) → markupsafe.Markup`

    Serialize an object to a string of JSON, and mark it safe to render in HTML. This filter is only for use in HTML documents.

    The returned string is safe to render in HTML documents and `<script>` tags. The exception is in HTML attributes that are double quoted; either use single quotes or the `|forceescape` filter.

    Parameters:

    - **value** – The object to serialize to JSON.
    - **indent** – The `indent` parameter passed to `dumps`, for pretty-printing the value.

    Changelog

    New in version 2.9.
- name: Token
  id: extensions/index#jinja2.lexer.Token
  summary: null
  belongs_to: Extensions
  description: |-
    `class jinja2.lexer.Token(lineno, type, value)`

    Parameters:

    - **lineno** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –
    - **type** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **value** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
- name: Token.lineno
  id: extensions/index#jinja2.lexer.Token.lineno
  summary: null
  belongs_to: Extensions
  description: |-
    `lineno`

    The line number of the token
- name: Token.test()
  id: extensions/index#jinja2.lexer.Token.test
  summary: Test a token against a token expression
  belongs_to: Extensions
  description: |-
    `test(expr)`

    Test a token against a token expression. This can either be a token type or `'token_type:token_value'`. This can only test against string values and types.

    Parameters:

    **expr** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: Token.test_any()
  id: extensions/index#jinja2.lexer.Token.test_any
  summary: Test against multiple token expressions
  belongs_to: Extensions
  description: |-
    `test_any(*iterable)`

    Test against multiple token expressions.

    Parameters:

    **iterable** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")

    There is also a utility function in the lexer module that can count newline characters in strings:
- name: Token.type
  id: extensions/index#jinja2.lexer.Token.type
  summary: The type of the token
  belongs_to: Extensions
  description: |-
    `type`

    The type of the token. This string is interned so you may compare it with arbitrary strings using the `is` operator.
- name: Token.value
  id: extensions/index#jinja2.lexer.Token.value
  summary: The value of the token
  belongs_to: Extensions
  description: |-
    `value`

    The value of the token.
- name: TokenStream
  id: extensions/index#jinja2.lexer.TokenStream
  summary: A token stream is an iterable that yields Tokens
  belongs_to: Extensions
  description: |-
    `class jinja2.lexer.TokenStream(generator, name, filename)`

    A token stream is an iterable that yields [`Token`](#jinja2.lexer.Token "jinja2.lexer.Token")s. The parser however does not iterate over it but calls `next()` to go one token ahead. The current active token is stored as [`current`](#jinja2.lexer.TokenStream.current "jinja2.lexer.TokenStream.current").

    Parameters:

    - **generator** ([Iterable](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.11)")*\[*[Token](#jinja2.lexer.Token "jinja2.lexer.Token")*\]*) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
- name: TokenStream.__next__()
  id: extensions/index#jinja2.lexer.TokenStream.__next__
  summary: Go one token ahead and return the old one
  belongs_to: Extensions
  description: |-
    `__next__()`

    Go one token ahead and return the old one.

    Use the built-in [`next()`](https://docs.python.org/3/library/functions.html#next "(in Python v3.11)") instead of calling this directly.

    Return type:

    [Token](#jinja2.lexer.Token "jinja2.lexer.Token")
- name: TokenStream.current
  id: extensions/index#jinja2.lexer.TokenStream.current
  summary: The current Token
  belongs_to: Extensions
  description: |-
    `current`

    The current [`Token`](#jinja2.lexer.Token "jinja2.lexer.Token").
- name: TokenStream.eos
  id: extensions/index#jinja2.lexer.TokenStream.eos
  summary: null
  belongs_to: Extensions
  description: |-
    `property eos: bool`

    Are we at the end of the stream?
- name: TokenStream.expect()
  id: extensions/index#jinja2.lexer.TokenStream.expect
  summary: Expect a given token type and return it
  belongs_to: Extensions
  description: |-
    `expect(expr)`

    Expect a given token type and return it. This accepts the same argument as [`jinja2.lexer.Token.test()`](#jinja2.lexer.Token.test "jinja2.lexer.Token.test").

    Parameters:

    **expr** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [Token](#jinja2.lexer.Token "jinja2.lexer.Token")
- name: TokenStream.look()
  id: extensions/index#jinja2.lexer.TokenStream.look
  summary: Look at the next token
  belongs_to: Extensions
  description: |-
    `look()`

    Look at the next token.

    Return type:

    [Token](#jinja2.lexer.Token "jinja2.lexer.Token")
- name: TokenStream.next_if()
  id: extensions/index#jinja2.lexer.TokenStream.next_if
  summary: Perform the token test and return the token if it matched
  belongs_to: Extensions
  description: |-
    `next_if(expr)`

    Perform the token test and return the token if it matched. Otherwise the return value is `None`.

    Parameters:

    **expr** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [Token](#jinja2.lexer.Token "jinja2.lexer.Token") \| None
- name: TokenStream.push()
  id: extensions/index#jinja2.lexer.TokenStream.push
  summary: Push a token back to the stream
  belongs_to: Extensions
  description: |-
    `push(token)`

    Push a token back to the stream.

    Parameters:

    **token** ([Token](#jinja2.lexer.Token "jinja2.lexer.Token")) –

    Return type:

    None
- name: TokenStream.skip()
  id: extensions/index#jinja2.lexer.TokenStream.skip
  summary: Got n tokens ahead
  belongs_to: Extensions
  description: |-
    `skip(n=1)`

    Got n tokens ahead.

    Parameters:

    **n** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –

    Return type:

    None
- name: TokenStream.skip_if()
  id: extensions/index#jinja2.lexer.TokenStream.skip_if
  summary: Like next_if() but only returns True or False
  belongs_to: Extensions
  description: |-
    `skip_if(expr)`

    Like [`next_if()`](#jinja2.lexer.TokenStream.next_if "jinja2.lexer.TokenStream.next_if") but only returns `True` or `False`.

    Parameters:

    **expr** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: trim()
  id: templates/index#jinja-filters.trim
  summary: Strip leading and trailing characters, by default whitespace
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.trim(value: str, chars: str | None = None) → str`

    Strip leading and trailing characters, by default whitespace.
- name: true()
  id: templates/index#jinja-tests.true
  summary: Return true if the object is True
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.true(value: Any) → bool`

    Return true if the object is True.

    Changelog

    New in version 2.11.
- name: truncate()
  id: templates/index#jinja-filters.truncate
  summary: Return a truncated copy of the string
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.truncate(s: str, length: int = 255, killwords: bool = False, end: str = '...', leeway: int | None = None) → str`

    Return a truncated copy of the string. The length is specified with the first parameter which defaults to `255`. If the second parameter is `true` the filter will cut the text at length. Otherwise it will discard the last word. If the text was in fact truncated it will append an ellipsis sign (`"..."`). If you want a different ellipsis sign than `"..."` you can specify it using the third parameter. Strings that only exceed the length by the tolerance margin given in the fourth parameter will not be truncated.

    ``` jinja
    {{ "foo bar baz qux"|truncate(9) }}
        -> "foo..."
    {{ "foo bar baz qux"|truncate(9, True) }}
        -> "foo ba..."
    {{ "foo bar baz qux"|truncate(11) }}
        -> "foo bar baz qux"
    {{ "foo bar baz qux"|truncate(11, False, '...', 0) }}
        -> "foo bar..."
    ```

    The default leeway on newer Jinja versions is 5 and was 0 before but can be reconfigured globally.
- name: Tuple
  id: extensions/index#jinja2.nodes.Tuple
  summary: For loop unpacking and some other things like multiple arguments for subscripts
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.Tuple(items, ctx)`

    For loop unpacking and some other things like multiple arguments for subscripts. Like for [`Name`](#jinja2.nodes.Name "jinja2.nodes.Name") `ctx` specifies if the tuple is used for loading the names or storing.

    Node type:

    [`Literal`](#jinja2.nodes.Literal "jinja2.nodes.Literal")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: UnaryExpr
  id: extensions/index#jinja2.nodes.UnaryExpr
  summary: Baseclass for all unary expressions
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.UnaryExpr(node)`

    Baseclass for all unary expressions.

    Node type:

    [`Expr`](#jinja2.nodes.Expr "jinja2.nodes.Expr")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: Undefined
  id: api/index#jinja2.Undefined
  summary: The default undefined type
  description: |-
    `class jinja2.Undefined`

    The default undefined type. This undefined type can be printed and iterated over, but every other access will raise an [`UndefinedError`](#jinja2.UndefinedError "jinja2.UndefinedError"):

    ``` python
    >>> foo = Undefined(name='foo')
    >>> str(foo)
    ''
    >>> not foo
    True
    >>> foo + 42
    Traceback (most recent call last):
      ...
    jinja2.exceptions.UndefinedError: 'foo' is undefined
    ```

    Parameters:

    - **hint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **exc** ([Type](https://docs.python.org/3/library/typing.html#typing.Type "(in Python v3.11)")*\[*[TemplateRuntimeError](#jinja2.TemplateRuntimeError "jinja2.exceptions.TemplateRuntimeError")*\]*) –
- name: undefined()
  id: templates/index#jinja-tests.undefined
  summary: Like defined() but the other way round
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.undefined(value: Any) → bool`

    Like [`defined()`](#jinja-tests.defined "jinja-tests.defined") but the other way round.
- name: Undefined._fail_with_undefined_error()
  id: api/index#jinja2.Undefined._fail_with_undefined_error
  summary: When called with any arguments this method raises _undefined_exception with an error message generated from the undefined hints stored on the undefined object
  description: |-
    `_fail_with_undefined_error(\*args, \**kwargs)`

    When called with any arguments this method raises [`_undefined_exception`](#jinja2.Undefined._undefined_exception "jinja2.Undefined._undefined_exception") with an error message generated from the undefined hints stored on the undefined object.
- name: Undefined._undefined_exception
  id: api/index#jinja2.Undefined._undefined_exception
  summary: The exception that the undefined object wants to raise
  description: |-
    `_undefined_exception`

    The exception that the undefined object wants to raise. This is usually one of [`UndefinedError`](#jinja2.UndefinedError "jinja2.UndefinedError") or `SecurityError`.
- name: Undefined._undefined_hint
  id: api/index#jinja2.Undefined._undefined_hint
  summary: Either None or a string with the error message for the undefined object
  description: |-
    `_undefined_hint`

    Either `None` or a string with the error message for the undefined object.
- name: Undefined._undefined_name
  id: api/index#jinja2.Undefined._undefined_name
  summary: The name for the undefined variable / attribute or just None if no such information exists
  description: |-
    `_undefined_name`

    The name for the undefined variable / attribute or just `None` if no such information exists.
- name: Undefined._undefined_obj
  id: api/index#jinja2.Undefined._undefined_obj
  summary: Either None or the owner object that caused the undefined object to be created (for example because an attribute does not exist)
  description: |-
    `_undefined_obj`

    Either `None` or the owner object that caused the undefined object to be created (for example because an attribute does not exist).
- name: UndefinedError
  id: api/index#jinja2.UndefinedError
  summary: Raised if a template tries to operate on Undefined
  description: |-
    `exception jinja2.UndefinedError(message=None)`

    Raised if a template tries to operate on [`Undefined`](#jinja2.Undefined "jinja2.Undefined").

    Parameters:

    **message** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: unique()
  id: templates/index#jinja-filters.unique
  summary: Returns a list of unique items from the given iterable
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.unique(value: 't.Iterable[V]', case_sensitive: bool = False, attribute: str | int | NoneType = None) → 't.Iterator[V]'`

    Returns a list of unique items from the given iterable.

    ``` jinja
    {{ ['foo', 'bar', 'foobar', 'FooBar']|unique|list }}
        -> ['foo', 'bar', 'foobar']
    ```

    The unique items are yielded in the same order as their first occurrence in the iterable passed to the filter.

    Parameters:

    - **case_sensitive** – Treat upper and lower case strings as distinct.
    - **attribute** – Filter objects with unique values for this attribute.
- name: unsafe()
  id: sandbox/index#jinja2.sandbox.unsafe
  summary: Marks a function or method as unsafe
  belongs_to: Sandbox
  description: |-
    `jinja2.sandbox.unsafe(f)`

    Marks a function or method as unsafe.

    Parameters:

    **f** (*F*) –

    Return type:

    *F*
- name: upper()
  id: templates/index#jinja-tests.upper
  summary: Return true if the variable is uppercased
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-tests.upper(value: str) → bool`

    Return true if the variable is uppercased.

    ## List of Global Functions

    The following functions are available in the global scope by default:
- name: upper()
  id: templates/index#jinja-filters.upper
  summary: Convert a value to uppercase
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.upper(s: str) → str`

    Convert a value to uppercase.
- name: urlencode()
  id: templates/index#jinja-filters.urlencode
  summary: Quote data for use in a URL path or query using UTF-8
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.urlencode(value: str | Mapping[str, Any] | Iterable[Tuple[str, Any]]) → str`

    Quote data for use in a URL path or query using UTF-8.

    Basic wrapper around [`urllib.parse.quote()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.quote "(in Python v3.11)") when given a string, or [`urllib.parse.urlencode()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlencode "(in Python v3.11)") for a dict or iterable.

    Parameters:

    **value** – Data to quote. A string will be quoted directly. A dict or iterable of `(key, value)` pairs will be joined as a query string.

    When given a string, “/” is not quoted. HTTP servers treat “/” and “%2F” equivalently in paths. If you need quoted slashes, use the `|replace("/", "%2F")` filter.

    Changelog

    New in version 2.7.
- name: urlize()
  id: templates/index#jinja-filters.urlize
  summary: Convert URLs in text into clickable links
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.urlize(value: str, trim_url_limit: int | None = None, nofollow: bool = False, target: str | None = None, rel: str | None = None, extra_schemes: Iterable[str] | None = None) → str`

    Convert URLs in text into clickable links.

    This may not recognize links in some situations. Usually, a more comprehensive formatter, such as a Markdown library, is a better choice.

    Works on `http://`, `https://`, `www.`, `mailto:`, and email addresses. Links with trailing punctuation (periods, commas, closing parentheses) and leading punctuation (opening parentheses) are recognized excluding the punctuation. Email addresses that include header fields are not recognized (for example, `mailto:address@example.com?cc=copy@example.com`).

    Parameters:

    - **value** – Original text containing URLs to link.
    - **trim_url_limit** – Shorten displayed URL values to this length.
    - **nofollow** – Add the `rel=nofollow` attribute to links.
    - **target** – Add the `target` attribute to links.
    - **rel** – Add the `rel` attribute to links.
    - **extra_schemes** – Recognize URLs that start with these schemes in addition to the default behavior. Defaults to `env.policies["urlize.extra_schemes"]`, which defaults to no extra schemes.

    Changelog

    Changed in version 3.0: The `extra_schemes` parameter was added.

    Changed in version 3.0: Generate `https://` links for URLs without a scheme.

    Changed in version 3.0: The parsing rules were updated. Recognize email addresses with or without the `mailto:` scheme. Validate IP addresses. Ignore parentheses and brackets in more cases.

    Changed in version 2.8: The `target` parameter was added.
- name: With
  id: extensions/index#jinja2.nodes.With
  summary: Specific node for with statements
  belongs_to: Extensions
  description: |-
    `class jinja2.nodes.With(targets, values, body)`

    Specific node for with statements. In older versions of Jinja the with statement was implemented on the base of the `Scope` node instead.

    Changelog

    New in version 2.9.3.

    Node type:

    [`Stmt`](#jinja2.nodes.Stmt "jinja2.nodes.Stmt")

    Parameters:

    - **fields** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **attributes** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: wordcount()
  id: templates/index#jinja-filters.wordcount
  summary: Count the words in that string
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.wordcount(s: str) → int`

    Count the words in that string.
- name: wordwrap()
  id: templates/index#jinja-filters.wordwrap
  summary: Wrap a string to the given width
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.wordwrap(s: str, width: int = 79, break_long_words: bool = True, wrapstring: str | None = None, break_on_hyphens: bool = True) → str`

    Wrap a string to the given width. Existing newlines are treated as paragraphs to be wrapped separately.

    Parameters:

    - **s** – Original text to wrap.
    - **width** – Maximum length of wrapped lines.
    - **break_long_words** – If a word is longer than `width`, break it across lines.
    - **break_on_hyphens** – If a word contains hyphens, it may be split across lines.
    - **wrapstring** – String to join each wrapped line. Defaults to `Environment.newline_sequence`.

    Changelog

    Changed in version 2.11: Existing newlines are treated as paragraphs wrapped separately.

    Changed in version 2.11: Added the `break_on_hyphens` parameter.

    Changed in version 2.7: Added the `wrapstring` parameter.
- name: xmlattr()
  id: templates/index#jinja-filters.xmlattr
  summary: Create an SGML/XML attribute string based on the items in a dict
  belongs_to: Template Designer Documentation
  description: |-
    `jinja-filters.xmlattr(d: Mapping[str, Any], autospace: bool = True) → str`

    Create an SGML/XML attribute string based on the items in a dict. All values that are neither `none` nor `undefined` are automatically escaped:

    ``` html+jinja
    <ul{{ {'class': 'my_list', 'missing': none,
            'id': 'list-%d'|format(variable)}|xmlattr }}>
    ...
    </ul>
    ```

    Results in something like this:

    ``` html
    <ul class="my_list" id="list-42">
    ...
    </ul>
    ```

    As you can see it automatically prepends a space in front of the item if the filter returned something unless the second parameter is false.

    ## List of Builtin Tests

    |                                                                       |                                                        |                                                              |                                                           |                                                                 |
    |-----------------------------------------------------------------------|--------------------------------------------------------|--------------------------------------------------------------|-----------------------------------------------------------|-----------------------------------------------------------------|
    | [`boolean()`](#jinja-tests.boolean "jinja-tests.boolean")             | [`even()`](#jinja-tests.even "jinja-tests.even")       | [`in()`](#jinja-tests.in "jinja-tests.in")                   | [`mapping()`](#jinja-tests.mapping "jinja-tests.mapping") | [`sequence()`](#jinja-tests.sequence "jinja-tests.sequence")    |
    | [`callable()`](#jinja-tests.callable "jinja-tests.callable")          | [`false()`](#jinja-tests.false "jinja-tests.false")    | [`integer()`](#jinja-tests.integer "jinja-tests.integer")    | [`ne()`](#jinja-tests.ne "jinja-tests.ne")                | [`string()`](#jinja-tests.string "jinja-tests.string")          |
    | [`defined()`](#jinja-tests.defined "jinja-tests.defined")             | [`filter()`](#jinja-tests.filter "jinja-tests.filter") | [`iterable()`](#jinja-tests.iterable "jinja-tests.iterable") | [`none()`](#jinja-tests.none "jinja-tests.none")          | [`test()`](#jinja-tests.test "jinja-tests.test")                |
    | [`divisibleby()`](#jinja-tests.divisibleby "jinja-tests.divisibleby") | [`float()`](#jinja-tests.float "jinja-tests.float")    | [`le()`](#jinja-tests.le "jinja-tests.le")                   | [`number()`](#jinja-tests.number "jinja-tests.number")    | [`true()`](#jinja-tests.true "jinja-tests.true")                |
    | [`eq()`](#jinja-tests.eq "jinja-tests.eq")                            | [`ge()`](#jinja-tests.ge "jinja-tests.ge")             | [`lower()`](#jinja-tests.lower "jinja-tests.lower")          | [`odd()`](#jinja-tests.odd "jinja-tests.odd")             | [`undefined()`](#jinja-tests.undefined "jinja-tests.undefined") |
    | [`escaped()`](#jinja-tests.escaped "jinja-tests.escaped")             | [`gt()`](#jinja-tests.gt "jinja-tests.gt")             | [`lt()`](#jinja-tests.lt "jinja-tests.lt")                   | [`sameas()`](#jinja-tests.sameas "jinja-tests.sameas")    | [`upper()`](#jinja-tests.upper "jinja-tests.upper")             |
