---
name: C
slug: c
text_format: markdown
generator: src:devdocs
version: null
copyright: |-
  © cppreference.com
  Licensed under the Creative Commons Attribution-ShareAlike Unported
  License v3.0.
  https://en.cppreference.com/w/c/header
homepage: null

---
- name: '#define directive'
  summary: The preprocessor supports text macro replacement and function-like text macro replacement
  description: "# Replacing text macros\n\nThe preprocessor supports text macro replacement and function-like text macro replacement.\n\n### Syntax\n\n|                                                               |       |             |\n|---------------------------------------------------------------|-------|-------------|\n| `#define` identifier replacement-list \uFEFF(optional)              | \\(1\\) |             |\n| `#define` identifier \uFEFF`(` parameters `)` replacement-list      | \\(2\\) |             |\n| `#define` identifier \uFEFF`(` parameters`, ... )` replacement-list | \\(3\\) | (since C99) |\n| `#define` identifier \uFEFF`( ... )` replacement-list               | \\(4\\) | (since C99) |\n| `#undef` identifier                                           | \\(5\\) |             |\n\n### Explanation\n\n#### \\#define directives\n\nThe `#define` directives define the identifier as a macro, that is they instruct the compiler to replace all successive occurrences of identifier with replacement-list, which can be optionally additionally processed. If the identifier is already defined as any type of macro, the program is ill-formed unless the definitions are identical.\n\n##### Object-like macros\n\nObject-like macros replace every occurrence of a defined identifier with replacement-list. Version (1) of the `#define` directive behaves exactly like that.\n\n##### Function-like macros\n\nFunction-like macros replace each occurrence of a defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list.\n\nThe syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a ( as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching ) token, skipping intervening matched pairs of left and right parentheses.\n\nThe number of arguments must be the same as the number of arguments in the macro definition (parameters) or the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.\n\nVersion (2) of the `#define` directive defines a simple function-like macro.\n\nVersion (3) of the `#define` directive defines a function-like macro with variable number of arguments. The additional arguments can be accessed using `__VA_ARGS__` identifier, which is then replaced with arguments, supplied with the identifier to be replaced.\n\nVersion (4) of the `#define` directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments can be accessed only with `__VA_ARGS__` identifier, which is then replaced with arguments, supplied with identifier to be replaced.\n\n[TABLE]\n\n  \nNote: if an argument of a function-like macro includes commas that are not protected by matched pairs of left and right parentheses (such as `macro(array[x = y, x + 1])` or [`atomic_store`](http://en.cppreference.com/w/c/atomic/atomic_store)` ``(``p, ``(``struct`` S``)``{`` a, b ``}``)``;`), the comma is interpreted as macro argument separator, causing a compilation failure due to argument count mismatch.\n\n#### \\# and \\## operators\n\nIn function-like macros, a `#` operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called \"stringification\". If the result of stringification is not a valid string literal, the behavior is undefined.\n\n[TABLE]\n\nA `##` operator between any two successive identifiers in the replacement-list runs parameter replacement on the two identifiers and then concatenates the result. This operation is called \"concatenation\" or \"token pasting\". Only tokens that form a valid token together may be pasted: identifiers that form a longer identifier, digits that form a number, or operators `+` and `=` that form a `+=`. A comment cannot be created by pasting `/` and `*` because comments are removed from text before macro substitution is considered. If the result of concatenation is not a valid token, the behavior is undefined.\n\nNote: Some compilers offer an extension that allows `##` to appear after a comma and before `__VA_ARGS__`, in which case the `##` does nothing when `__VA_ARGS__` is non-empty, but removes the comma when `__VA_ARGS__` is empty: this makes it possible to define macros such as [`fprintf`](http://en.cppreference.com/w/c/io/fprintf)` ``(`[`stderr`](http://en.cppreference.com/w/c/io/std_streams)`, format, ``##__VA_ARGS__)`.\n\nThe order of evaluation of `#` and `##` operators is unspecified.\n\n#### \\#undef directive\n\nThe `#undef` directive undefines the identifier, that is it cancels the previous definition of the identifier by `#define` directive. If the identifier does not have an associated macro, the directive is ignored.\n\n### Predefined macros\n\nThe following macro names are predefined in any translation unit:\n\n[TABLE]\n\nThe following additional macro names may be predefined by an implementation:\n\n[TABLE]\n\nThe values of these macros (except for `__FILE__` and `__LINE__`) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.\n\n|                                                                                                                                                                                                                                                                                                                |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The predefined variable `__func__` (see [function definition](../language/function_definition#func \"c/language/function definition\") for details) is not a preprocessor macro, even though it is sometimes used together with `__FILE__` and `__LINE__`, e.g. by [`assert`](../error/assert \"c/error/assert\"). | (since C99) |\n\n### Example\n\n```\n#include <stdio.h>\n \n// make function factory and use it\n#define FUNCTION(name, a) int fun_##name(int x) { return (a) * x; }\n \nFUNCTION(quadruple, 4)\nFUNCTION(double, 2)\n \n#undef FUNCTION\n#define FUNCTION 34\n#define OUTPUT(a) puts( #a )\n \nint main(void)\n{\n    printf(\"quadruple(13): %d\\n\", fun_quadruple(13) );\n    printf(\"double(21): %d\\n\", fun_double(21) );\n    printf(\"%d\\n\", FUNCTION);\n    OUTPUT(billion);               // note the lack of quotes\n}\n```\n\nOutput:\n\n```\nquadruple(13): 52\ndouble(21): 42\n34\nbillion\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n[TABLE]\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.10.4 Macro replacement (p: 187-184)\n  - 6.10.9 Predefined macro names (p: 186-188)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.3 Macro replacement (p: 121-126)\n  - 6.10.8 Predefined macro names (p: 127-129)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.3 Macro replacement (p: 166-173)\n  - 6.10.8 Predefined macro names (p: 175-176)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.3 Macro replacement (p: 151-158)\n  - 6.10.8 Predefined macro names (p: 160-161)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.3 Macro replacement\n  - 3.8.8 Predefined macro names\n\n### See also\n\n|                                                                                                                                  |     |\n|----------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/replace \"cpp/preprocessor/replace\") for Replacing text macros |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/replace](https://en.cppreference.com/w/c/preprocessor/replace)"
- name: '#elif directive'
  summary: The preprocessor supports conditional compilation of parts of source file
  description: "# Conditional inclusion\n\nThe preprocessor supports conditional compilation of parts of source file. This behavior is controlled by `#if`, `#else`, `#elif`, `#ifdef`, `#ifndef`, `#elifdef`, `#elifndef`(since C23), and `#endif` directives.\n\n### Syntax\n\n|                        |     |             |\n|------------------------|-----|-------------|\n| `#if` expression       |     |             |\n| `#ifdef` identifier    |     |             |\n| `#ifndef` identifier   |     |             |\n| `#elif` expression     |     |             |\n| `#elifdef` identifier  |     | (since C23) |\n| `#elifndef` identifier |     | (since C23) |\n| `#else`                |     |             |\n| `#endif`               |     |             |\n\n### Explanation\n\nThe conditional preprocessing block starts with `#if`, `#ifdef` or `#ifndef` directive, then optionally includes any number of `#elif`, `#elifdef`, or `#elifndef`(since C23) directives, then optionally includes at most one `#else` directive and is terminated with `#endif` directive. Any inner conditional preprocessing blocks are processed separately.\n\nEach of `#if`, `#ifdef`, `#ifndef`, `#elif`, `#elifdef`, `#elifndef`(since C23), and `#else` directives control code block until first `#elif`, `#elifdef`, `#elifndef`(since C23), `#else`, `#endif` directive not belonging to any inner conditional preprocessing blocks.\n\n`#if`, `#ifdef` and `#ifndef` directives test the specified condition (see below) and if it evaluates to true, compiles the controlled code block. In that case subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) and `#elif` directives are ignored. Otherwise, if the specified condition evaluates false, the controlled code block is skipped and the subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) or `#elif` directive (if any) is processed. If the subsequent directive is `#else`, the code block controlled by the `#else` directive is unconditionally compiled. Otherwise, the `#elif`, `#elifdef`, or `#elifndef`(since C23) directive acts as if it was `#if` directive: checks for condition, compiles or skips the controlled code block based on the result, and in the latter case processes subsequent `#elif`, `#elifdef`, `#elifndef`,(since C23) and `#else` directives. The conditional preprocessing block is terminated by `#endif` directive.\n\n### Conditional evaluation\n\n#### \\#if, \\#elif\n\nThe expression is a constant expression, using only [constants](../language/expressions#Constants_and_literals \"c/language/expressions\") and identifiers, defined using [` #define`](replace \"c/preprocessor/replace\") directive. Any identifier, which is not literal, non defined using [` #define`](replace \"c/preprocessor/replace\") directive, evaluates to `​0​` except `true` which evaluates to `1`(since C23).\n\nThe expression may contain unary operators in form `defined` identifier or `defined (`identifier`)` which return `1` if the identifier was defined using [` #define`](replace \"c/preprocessor/replace\") directive and `​0​` otherwise. In this context, `__has_include`, `__has_embed` and `__has_c_attribute` are treated as if they were the name of defined macros.(since C23) If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise. If any used identifier is not a constant, it is replaced with `​0​`.\n\n|                                                                                                                                                                                                                                                     |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| In context of a preprocessor directive, a `__has_c_attribute` expression detects whether a given attribute token is supported and its supported version. See [Attribute testing](../language/attributes#Attribute_testing \"c/language/attributes\"). | (since C23) |\n\nNote: Until [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#if `*`cond1`* ... `#elif `*`cond2`* is different from `#if `*`cond1`* ... `#else` followed by `#if `*`cond3`* because if *`cond1`* is true, the second `#if` is skipped and *`cond3`* does not need to be well-formed, while `#elif`'s *`cond2`* must be a valid expression. As of [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#elif` that leads the skipped code block is also skipped.\n\n#### Combined directives\n\nChecks if the identifier was [defined as a macro name](replace \"c/preprocessor/replace\").\n\n`#ifdef` identifier is essentially equivalent to `#if defined` identifier.\n\n`#ifndef` identifier is essentially equivalent to `#if !defined` identifier.\n\n[TABLE]\n\n### Notes\n\nWhile `#elifdef` and `#elifndef` directives target C23, implementations may backport them to the older language modes as conforming extensions.\n\n### Example\n\n```\n#define ABCD 2\n#include <stdio.h>\n \nint main(void)\n{\n \n#ifdef ABCD\n    printf(\"1: yes\\n\");\n#else\n    printf(\"1: no\\n\");\n#endif\n \n#ifndef ABCD\n    printf(\"2: no1\\n\");\n#elif ABCD == 2\n    printf(\"2: yes\\n\");\n#else\n    printf(\"2: no2\\n\");\n#endif\n \n#if !defined(DCBA) && (ABCD < 2 * 4 - 3)\n    printf(\"3: yes\\n\");\n#endif\n \n// C23 directives #elifdef/#elifndef\n#ifdef CPU\n    printf(\"4: no1\\n\");\n#elifdef GPU\n    printf(\"4: no2\\n\");\n#elifndef RAM\n    printf(\"4: yes\\n\"); // selected in C23 mode, may be selected in pre-C23 mode\n#else\n    printf(\"4: no3\\n\"); // may be selected in pre-C23 mode\n#endif\n}\n```\n\nPossible output:\n\n```\n1: yes\n2: yes\n3: yes\n4: yes\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                | Correct behavior          |\n|-----------------------------------------------------------------------------|------------|------------------------------------------------------|---------------------------|\n| [DR 412](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_412) | C89        | failed `#elif`'s expression was required to be valid | failed `#elif` is skipped |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.10.1 Conditional inclusion (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.1 Conditional inclusion (p: 118-119)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.1 Conditional inclusion (p: 162-164)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.1 Conditional inclusion (p: 147-149)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.1 Conditional inclusion\n\n### See also\n\n|                                                                                                                                          |     |\n|------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/conditional \"cpp/preprocessor/conditional\") for Conditional inclusion |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/conditional](https://en.cppreference.com/w/c/preprocessor/conditional)"
- name: '#else directive'
  summary: The preprocessor supports conditional compilation of parts of source file
  description: "# Conditional inclusion\n\nThe preprocessor supports conditional compilation of parts of source file. This behavior is controlled by `#if`, `#else`, `#elif`, `#ifdef`, `#ifndef`, `#elifdef`, `#elifndef`(since C23), and `#endif` directives.\n\n### Syntax\n\n|                        |     |             |\n|------------------------|-----|-------------|\n| `#if` expression       |     |             |\n| `#ifdef` identifier    |     |             |\n| `#ifndef` identifier   |     |             |\n| `#elif` expression     |     |             |\n| `#elifdef` identifier  |     | (since C23) |\n| `#elifndef` identifier |     | (since C23) |\n| `#else`                |     |             |\n| `#endif`               |     |             |\n\n### Explanation\n\nThe conditional preprocessing block starts with `#if`, `#ifdef` or `#ifndef` directive, then optionally includes any number of `#elif`, `#elifdef`, or `#elifndef`(since C23) directives, then optionally includes at most one `#else` directive and is terminated with `#endif` directive. Any inner conditional preprocessing blocks are processed separately.\n\nEach of `#if`, `#ifdef`, `#ifndef`, `#elif`, `#elifdef`, `#elifndef`(since C23), and `#else` directives control code block until first `#elif`, `#elifdef`, `#elifndef`(since C23), `#else`, `#endif` directive not belonging to any inner conditional preprocessing blocks.\n\n`#if`, `#ifdef` and `#ifndef` directives test the specified condition (see below) and if it evaluates to true, compiles the controlled code block. In that case subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) and `#elif` directives are ignored. Otherwise, if the specified condition evaluates false, the controlled code block is skipped and the subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) or `#elif` directive (if any) is processed. If the subsequent directive is `#else`, the code block controlled by the `#else` directive is unconditionally compiled. Otherwise, the `#elif`, `#elifdef`, or `#elifndef`(since C23) directive acts as if it was `#if` directive: checks for condition, compiles or skips the controlled code block based on the result, and in the latter case processes subsequent `#elif`, `#elifdef`, `#elifndef`,(since C23) and `#else` directives. The conditional preprocessing block is terminated by `#endif` directive.\n\n### Conditional evaluation\n\n#### \\#if, \\#elif\n\nThe expression is a constant expression, using only [constants](../language/expressions#Constants_and_literals \"c/language/expressions\") and identifiers, defined using [` #define`](replace \"c/preprocessor/replace\") directive. Any identifier, which is not literal, non defined using [` #define`](replace \"c/preprocessor/replace\") directive, evaluates to `​0​` except `true` which evaluates to `1`(since C23).\n\nThe expression may contain unary operators in form `defined` identifier or `defined (`identifier`)` which return `1` if the identifier was defined using [` #define`](replace \"c/preprocessor/replace\") directive and `​0​` otherwise. In this context, `__has_include`, `__has_embed` and `__has_c_attribute` are treated as if they were the name of defined macros.(since C23) If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise. If any used identifier is not a constant, it is replaced with `​0​`.\n\n|                                                                                                                                                                                                                                                     |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| In context of a preprocessor directive, a `__has_c_attribute` expression detects whether a given attribute token is supported and its supported version. See [Attribute testing](../language/attributes#Attribute_testing \"c/language/attributes\"). | (since C23) |\n\nNote: Until [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#if `*`cond1`* ... `#elif `*`cond2`* is different from `#if `*`cond1`* ... `#else` followed by `#if `*`cond3`* because if *`cond1`* is true, the second `#if` is skipped and *`cond3`* does not need to be well-formed, while `#elif`'s *`cond2`* must be a valid expression. As of [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#elif` that leads the skipped code block is also skipped.\n\n#### Combined directives\n\nChecks if the identifier was [defined as a macro name](replace \"c/preprocessor/replace\").\n\n`#ifdef` identifier is essentially equivalent to `#if defined` identifier.\n\n`#ifndef` identifier is essentially equivalent to `#if !defined` identifier.\n\n[TABLE]\n\n### Notes\n\nWhile `#elifdef` and `#elifndef` directives target C23, implementations may backport them to the older language modes as conforming extensions.\n\n### Example\n\n```\n#define ABCD 2\n#include <stdio.h>\n \nint main(void)\n{\n \n#ifdef ABCD\n    printf(\"1: yes\\n\");\n#else\n    printf(\"1: no\\n\");\n#endif\n \n#ifndef ABCD\n    printf(\"2: no1\\n\");\n#elif ABCD == 2\n    printf(\"2: yes\\n\");\n#else\n    printf(\"2: no2\\n\");\n#endif\n \n#if !defined(DCBA) && (ABCD < 2 * 4 - 3)\n    printf(\"3: yes\\n\");\n#endif\n \n// C23 directives #elifdef/#elifndef\n#ifdef CPU\n    printf(\"4: no1\\n\");\n#elifdef GPU\n    printf(\"4: no2\\n\");\n#elifndef RAM\n    printf(\"4: yes\\n\"); // selected in C23 mode, may be selected in pre-C23 mode\n#else\n    printf(\"4: no3\\n\"); // may be selected in pre-C23 mode\n#endif\n}\n```\n\nPossible output:\n\n```\n1: yes\n2: yes\n3: yes\n4: yes\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                | Correct behavior          |\n|-----------------------------------------------------------------------------|------------|------------------------------------------------------|---------------------------|\n| [DR 412](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_412) | C89        | failed `#elif`'s expression was required to be valid | failed `#elif` is skipped |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.10.1 Conditional inclusion (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.1 Conditional inclusion (p: 118-119)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.1 Conditional inclusion (p: 162-164)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.1 Conditional inclusion (p: 147-149)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.1 Conditional inclusion\n\n### See also\n\n|                                                                                                                                          |     |\n|------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/conditional \"cpp/preprocessor/conditional\") for Conditional inclusion |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/conditional](https://en.cppreference.com/w/c/preprocessor/conditional)"
- name: '#endif directive'
  summary: The preprocessor supports conditional compilation of parts of source file
  description: "# Conditional inclusion\n\nThe preprocessor supports conditional compilation of parts of source file. This behavior is controlled by `#if`, `#else`, `#elif`, `#ifdef`, `#ifndef`, `#elifdef`, `#elifndef`(since C23), and `#endif` directives.\n\n### Syntax\n\n|                        |     |             |\n|------------------------|-----|-------------|\n| `#if` expression       |     |             |\n| `#ifdef` identifier    |     |             |\n| `#ifndef` identifier   |     |             |\n| `#elif` expression     |     |             |\n| `#elifdef` identifier  |     | (since C23) |\n| `#elifndef` identifier |     | (since C23) |\n| `#else`                |     |             |\n| `#endif`               |     |             |\n\n### Explanation\n\nThe conditional preprocessing block starts with `#if`, `#ifdef` or `#ifndef` directive, then optionally includes any number of `#elif`, `#elifdef`, or `#elifndef`(since C23) directives, then optionally includes at most one `#else` directive and is terminated with `#endif` directive. Any inner conditional preprocessing blocks are processed separately.\n\nEach of `#if`, `#ifdef`, `#ifndef`, `#elif`, `#elifdef`, `#elifndef`(since C23), and `#else` directives control code block until first `#elif`, `#elifdef`, `#elifndef`(since C23), `#else`, `#endif` directive not belonging to any inner conditional preprocessing blocks.\n\n`#if`, `#ifdef` and `#ifndef` directives test the specified condition (see below) and if it evaluates to true, compiles the controlled code block. In that case subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) and `#elif` directives are ignored. Otherwise, if the specified condition evaluates false, the controlled code block is skipped and the subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) or `#elif` directive (if any) is processed. If the subsequent directive is `#else`, the code block controlled by the `#else` directive is unconditionally compiled. Otherwise, the `#elif`, `#elifdef`, or `#elifndef`(since C23) directive acts as if it was `#if` directive: checks for condition, compiles or skips the controlled code block based on the result, and in the latter case processes subsequent `#elif`, `#elifdef`, `#elifndef`,(since C23) and `#else` directives. The conditional preprocessing block is terminated by `#endif` directive.\n\n### Conditional evaluation\n\n#### \\#if, \\#elif\n\nThe expression is a constant expression, using only [constants](../language/expressions#Constants_and_literals \"c/language/expressions\") and identifiers, defined using [` #define`](replace \"c/preprocessor/replace\") directive. Any identifier, which is not literal, non defined using [` #define`](replace \"c/preprocessor/replace\") directive, evaluates to `​0​` except `true` which evaluates to `1`(since C23).\n\nThe expression may contain unary operators in form `defined` identifier or `defined (`identifier`)` which return `1` if the identifier was defined using [` #define`](replace \"c/preprocessor/replace\") directive and `​0​` otherwise. In this context, `__has_include`, `__has_embed` and `__has_c_attribute` are treated as if they were the name of defined macros.(since C23) If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise. If any used identifier is not a constant, it is replaced with `​0​`.\n\n|                                                                                                                                                                                                                                                     |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| In context of a preprocessor directive, a `__has_c_attribute` expression detects whether a given attribute token is supported and its supported version. See [Attribute testing](../language/attributes#Attribute_testing \"c/language/attributes\"). | (since C23) |\n\nNote: Until [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#if `*`cond1`* ... `#elif `*`cond2`* is different from `#if `*`cond1`* ... `#else` followed by `#if `*`cond3`* because if *`cond1`* is true, the second `#if` is skipped and *`cond3`* does not need to be well-formed, while `#elif`'s *`cond2`* must be a valid expression. As of [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#elif` that leads the skipped code block is also skipped.\n\n#### Combined directives\n\nChecks if the identifier was [defined as a macro name](replace \"c/preprocessor/replace\").\n\n`#ifdef` identifier is essentially equivalent to `#if defined` identifier.\n\n`#ifndef` identifier is essentially equivalent to `#if !defined` identifier.\n\n[TABLE]\n\n### Notes\n\nWhile `#elifdef` and `#elifndef` directives target C23, implementations may backport them to the older language modes as conforming extensions.\n\n### Example\n\n```\n#define ABCD 2\n#include <stdio.h>\n \nint main(void)\n{\n \n#ifdef ABCD\n    printf(\"1: yes\\n\");\n#else\n    printf(\"1: no\\n\");\n#endif\n \n#ifndef ABCD\n    printf(\"2: no1\\n\");\n#elif ABCD == 2\n    printf(\"2: yes\\n\");\n#else\n    printf(\"2: no2\\n\");\n#endif\n \n#if !defined(DCBA) && (ABCD < 2 * 4 - 3)\n    printf(\"3: yes\\n\");\n#endif\n \n// C23 directives #elifdef/#elifndef\n#ifdef CPU\n    printf(\"4: no1\\n\");\n#elifdef GPU\n    printf(\"4: no2\\n\");\n#elifndef RAM\n    printf(\"4: yes\\n\"); // selected in C23 mode, may be selected in pre-C23 mode\n#else\n    printf(\"4: no3\\n\"); // may be selected in pre-C23 mode\n#endif\n}\n```\n\nPossible output:\n\n```\n1: yes\n2: yes\n3: yes\n4: yes\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                | Correct behavior          |\n|-----------------------------------------------------------------------------|------------|------------------------------------------------------|---------------------------|\n| [DR 412](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_412) | C89        | failed `#elif`'s expression was required to be valid | failed `#elif` is skipped |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.10.1 Conditional inclusion (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.1 Conditional inclusion (p: 118-119)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.1 Conditional inclusion (p: 162-164)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.1 Conditional inclusion (p: 147-149)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.1 Conditional inclusion\n\n### See also\n\n|                                                                                                                                          |     |\n|------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/conditional \"cpp/preprocessor/conditional\") for Conditional inclusion |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/conditional](https://en.cppreference.com/w/c/preprocessor/conditional)"
- name: '#if directive'
  summary: The preprocessor supports conditional compilation of parts of source file
  description: "# Conditional inclusion\n\nThe preprocessor supports conditional compilation of parts of source file. This behavior is controlled by `#if`, `#else`, `#elif`, `#ifdef`, `#ifndef`, `#elifdef`, `#elifndef`(since C23), and `#endif` directives.\n\n### Syntax\n\n|                        |     |             |\n|------------------------|-----|-------------|\n| `#if` expression       |     |             |\n| `#ifdef` identifier    |     |             |\n| `#ifndef` identifier   |     |             |\n| `#elif` expression     |     |             |\n| `#elifdef` identifier  |     | (since C23) |\n| `#elifndef` identifier |     | (since C23) |\n| `#else`                |     |             |\n| `#endif`               |     |             |\n\n### Explanation\n\nThe conditional preprocessing block starts with `#if`, `#ifdef` or `#ifndef` directive, then optionally includes any number of `#elif`, `#elifdef`, or `#elifndef`(since C23) directives, then optionally includes at most one `#else` directive and is terminated with `#endif` directive. Any inner conditional preprocessing blocks are processed separately.\n\nEach of `#if`, `#ifdef`, `#ifndef`, `#elif`, `#elifdef`, `#elifndef`(since C23), and `#else` directives control code block until first `#elif`, `#elifdef`, `#elifndef`(since C23), `#else`, `#endif` directive not belonging to any inner conditional preprocessing blocks.\n\n`#if`, `#ifdef` and `#ifndef` directives test the specified condition (see below) and if it evaluates to true, compiles the controlled code block. In that case subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) and `#elif` directives are ignored. Otherwise, if the specified condition evaluates false, the controlled code block is skipped and the subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) or `#elif` directive (if any) is processed. If the subsequent directive is `#else`, the code block controlled by the `#else` directive is unconditionally compiled. Otherwise, the `#elif`, `#elifdef`, or `#elifndef`(since C23) directive acts as if it was `#if` directive: checks for condition, compiles or skips the controlled code block based on the result, and in the latter case processes subsequent `#elif`, `#elifdef`, `#elifndef`,(since C23) and `#else` directives. The conditional preprocessing block is terminated by `#endif` directive.\n\n### Conditional evaluation\n\n#### \\#if, \\#elif\n\nThe expression is a constant expression, using only [constants](../language/expressions#Constants_and_literals \"c/language/expressions\") and identifiers, defined using [` #define`](replace \"c/preprocessor/replace\") directive. Any identifier, which is not literal, non defined using [` #define`](replace \"c/preprocessor/replace\") directive, evaluates to `​0​` except `true` which evaluates to `1`(since C23).\n\nThe expression may contain unary operators in form `defined` identifier or `defined (`identifier`)` which return `1` if the identifier was defined using [` #define`](replace \"c/preprocessor/replace\") directive and `​0​` otherwise. In this context, `__has_include`, `__has_embed` and `__has_c_attribute` are treated as if they were the name of defined macros.(since C23) If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise. If any used identifier is not a constant, it is replaced with `​0​`.\n\n|                                                                                                                                                                                                                                                     |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| In context of a preprocessor directive, a `__has_c_attribute` expression detects whether a given attribute token is supported and its supported version. See [Attribute testing](../language/attributes#Attribute_testing \"c/language/attributes\"). | (since C23) |\n\nNote: Until [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#if `*`cond1`* ... `#elif `*`cond2`* is different from `#if `*`cond1`* ... `#else` followed by `#if `*`cond3`* because if *`cond1`* is true, the second `#if` is skipped and *`cond3`* does not need to be well-formed, while `#elif`'s *`cond2`* must be a valid expression. As of [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#elif` that leads the skipped code block is also skipped.\n\n#### Combined directives\n\nChecks if the identifier was [defined as a macro name](replace \"c/preprocessor/replace\").\n\n`#ifdef` identifier is essentially equivalent to `#if defined` identifier.\n\n`#ifndef` identifier is essentially equivalent to `#if !defined` identifier.\n\n[TABLE]\n\n### Notes\n\nWhile `#elifdef` and `#elifndef` directives target C23, implementations may backport them to the older language modes as conforming extensions.\n\n### Example\n\n```\n#define ABCD 2\n#include <stdio.h>\n \nint main(void)\n{\n \n#ifdef ABCD\n    printf(\"1: yes\\n\");\n#else\n    printf(\"1: no\\n\");\n#endif\n \n#ifndef ABCD\n    printf(\"2: no1\\n\");\n#elif ABCD == 2\n    printf(\"2: yes\\n\");\n#else\n    printf(\"2: no2\\n\");\n#endif\n \n#if !defined(DCBA) && (ABCD < 2 * 4 - 3)\n    printf(\"3: yes\\n\");\n#endif\n \n// C23 directives #elifdef/#elifndef\n#ifdef CPU\n    printf(\"4: no1\\n\");\n#elifdef GPU\n    printf(\"4: no2\\n\");\n#elifndef RAM\n    printf(\"4: yes\\n\"); // selected in C23 mode, may be selected in pre-C23 mode\n#else\n    printf(\"4: no3\\n\"); // may be selected in pre-C23 mode\n#endif\n}\n```\n\nPossible output:\n\n```\n1: yes\n2: yes\n3: yes\n4: yes\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                | Correct behavior          |\n|-----------------------------------------------------------------------------|------------|------------------------------------------------------|---------------------------|\n| [DR 412](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_412) | C89        | failed `#elif`'s expression was required to be valid | failed `#elif` is skipped |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.10.1 Conditional inclusion (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.1 Conditional inclusion (p: 118-119)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.1 Conditional inclusion (p: 162-164)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.1 Conditional inclusion (p: 147-149)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.1 Conditional inclusion\n\n### See also\n\n|                                                                                                                                          |     |\n|------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/conditional \"cpp/preprocessor/conditional\") for Conditional inclusion |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/conditional](https://en.cppreference.com/w/c/preprocessor/conditional)"
- name: '#ifdef directive'
  summary: The preprocessor supports conditional compilation of parts of source file
  description: "# Conditional inclusion\n\nThe preprocessor supports conditional compilation of parts of source file. This behavior is controlled by `#if`, `#else`, `#elif`, `#ifdef`, `#ifndef`, `#elifdef`, `#elifndef`(since C23), and `#endif` directives.\n\n### Syntax\n\n|                        |     |             |\n|------------------------|-----|-------------|\n| `#if` expression       |     |             |\n| `#ifdef` identifier    |     |             |\n| `#ifndef` identifier   |     |             |\n| `#elif` expression     |     |             |\n| `#elifdef` identifier  |     | (since C23) |\n| `#elifndef` identifier |     | (since C23) |\n| `#else`                |     |             |\n| `#endif`               |     |             |\n\n### Explanation\n\nThe conditional preprocessing block starts with `#if`, `#ifdef` or `#ifndef` directive, then optionally includes any number of `#elif`, `#elifdef`, or `#elifndef`(since C23) directives, then optionally includes at most one `#else` directive and is terminated with `#endif` directive. Any inner conditional preprocessing blocks are processed separately.\n\nEach of `#if`, `#ifdef`, `#ifndef`, `#elif`, `#elifdef`, `#elifndef`(since C23), and `#else` directives control code block until first `#elif`, `#elifdef`, `#elifndef`(since C23), `#else`, `#endif` directive not belonging to any inner conditional preprocessing blocks.\n\n`#if`, `#ifdef` and `#ifndef` directives test the specified condition (see below) and if it evaluates to true, compiles the controlled code block. In that case subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) and `#elif` directives are ignored. Otherwise, if the specified condition evaluates false, the controlled code block is skipped and the subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) or `#elif` directive (if any) is processed. If the subsequent directive is `#else`, the code block controlled by the `#else` directive is unconditionally compiled. Otherwise, the `#elif`, `#elifdef`, or `#elifndef`(since C23) directive acts as if it was `#if` directive: checks for condition, compiles or skips the controlled code block based on the result, and in the latter case processes subsequent `#elif`, `#elifdef`, `#elifndef`,(since C23) and `#else` directives. The conditional preprocessing block is terminated by `#endif` directive.\n\n### Conditional evaluation\n\n#### \\#if, \\#elif\n\nThe expression is a constant expression, using only [constants](../language/expressions#Constants_and_literals \"c/language/expressions\") and identifiers, defined using [` #define`](replace \"c/preprocessor/replace\") directive. Any identifier, which is not literal, non defined using [` #define`](replace \"c/preprocessor/replace\") directive, evaluates to `​0​` except `true` which evaluates to `1`(since C23).\n\nThe expression may contain unary operators in form `defined` identifier or `defined (`identifier`)` which return `1` if the identifier was defined using [` #define`](replace \"c/preprocessor/replace\") directive and `​0​` otherwise. In this context, `__has_include`, `__has_embed` and `__has_c_attribute` are treated as if they were the name of defined macros.(since C23) If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise. If any used identifier is not a constant, it is replaced with `​0​`.\n\n|                                                                                                                                                                                                                                                     |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| In context of a preprocessor directive, a `__has_c_attribute` expression detects whether a given attribute token is supported and its supported version. See [Attribute testing](../language/attributes#Attribute_testing \"c/language/attributes\"). | (since C23) |\n\nNote: Until [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#if `*`cond1`* ... `#elif `*`cond2`* is different from `#if `*`cond1`* ... `#else` followed by `#if `*`cond3`* because if *`cond1`* is true, the second `#if` is skipped and *`cond3`* does not need to be well-formed, while `#elif`'s *`cond2`* must be a valid expression. As of [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#elif` that leads the skipped code block is also skipped.\n\n#### Combined directives\n\nChecks if the identifier was [defined as a macro name](replace \"c/preprocessor/replace\").\n\n`#ifdef` identifier is essentially equivalent to `#if defined` identifier.\n\n`#ifndef` identifier is essentially equivalent to `#if !defined` identifier.\n\n[TABLE]\n\n### Notes\n\nWhile `#elifdef` and `#elifndef` directives target C23, implementations may backport them to the older language modes as conforming extensions.\n\n### Example\n\n```\n#define ABCD 2\n#include <stdio.h>\n \nint main(void)\n{\n \n#ifdef ABCD\n    printf(\"1: yes\\n\");\n#else\n    printf(\"1: no\\n\");\n#endif\n \n#ifndef ABCD\n    printf(\"2: no1\\n\");\n#elif ABCD == 2\n    printf(\"2: yes\\n\");\n#else\n    printf(\"2: no2\\n\");\n#endif\n \n#if !defined(DCBA) && (ABCD < 2 * 4 - 3)\n    printf(\"3: yes\\n\");\n#endif\n \n// C23 directives #elifdef/#elifndef\n#ifdef CPU\n    printf(\"4: no1\\n\");\n#elifdef GPU\n    printf(\"4: no2\\n\");\n#elifndef RAM\n    printf(\"4: yes\\n\"); // selected in C23 mode, may be selected in pre-C23 mode\n#else\n    printf(\"4: no3\\n\"); // may be selected in pre-C23 mode\n#endif\n}\n```\n\nPossible output:\n\n```\n1: yes\n2: yes\n3: yes\n4: yes\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                | Correct behavior          |\n|-----------------------------------------------------------------------------|------------|------------------------------------------------------|---------------------------|\n| [DR 412](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_412) | C89        | failed `#elif`'s expression was required to be valid | failed `#elif` is skipped |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.10.1 Conditional inclusion (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.1 Conditional inclusion (p: 118-119)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.1 Conditional inclusion (p: 162-164)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.1 Conditional inclusion (p: 147-149)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.1 Conditional inclusion\n\n### See also\n\n|                                                                                                                                          |     |\n|------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/conditional \"cpp/preprocessor/conditional\") for Conditional inclusion |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/conditional](https://en.cppreference.com/w/c/preprocessor/conditional)"
- name: '#ifndef directive'
  summary: The preprocessor supports conditional compilation of parts of source file
  description: "# Conditional inclusion\n\nThe preprocessor supports conditional compilation of parts of source file. This behavior is controlled by `#if`, `#else`, `#elif`, `#ifdef`, `#ifndef`, `#elifdef`, `#elifndef`(since C23), and `#endif` directives.\n\n### Syntax\n\n|                        |     |             |\n|------------------------|-----|-------------|\n| `#if` expression       |     |             |\n| `#ifdef` identifier    |     |             |\n| `#ifndef` identifier   |     |             |\n| `#elif` expression     |     |             |\n| `#elifdef` identifier  |     | (since C23) |\n| `#elifndef` identifier |     | (since C23) |\n| `#else`                |     |             |\n| `#endif`               |     |             |\n\n### Explanation\n\nThe conditional preprocessing block starts with `#if`, `#ifdef` or `#ifndef` directive, then optionally includes any number of `#elif`, `#elifdef`, or `#elifndef`(since C23) directives, then optionally includes at most one `#else` directive and is terminated with `#endif` directive. Any inner conditional preprocessing blocks are processed separately.\n\nEach of `#if`, `#ifdef`, `#ifndef`, `#elif`, `#elifdef`, `#elifndef`(since C23), and `#else` directives control code block until first `#elif`, `#elifdef`, `#elifndef`(since C23), `#else`, `#endif` directive not belonging to any inner conditional preprocessing blocks.\n\n`#if`, `#ifdef` and `#ifndef` directives test the specified condition (see below) and if it evaluates to true, compiles the controlled code block. In that case subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) and `#elif` directives are ignored. Otherwise, if the specified condition evaluates false, the controlled code block is skipped and the subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) or `#elif` directive (if any) is processed. If the subsequent directive is `#else`, the code block controlled by the `#else` directive is unconditionally compiled. Otherwise, the `#elif`, `#elifdef`, or `#elifndef`(since C23) directive acts as if it was `#if` directive: checks for condition, compiles or skips the controlled code block based on the result, and in the latter case processes subsequent `#elif`, `#elifdef`, `#elifndef`,(since C23) and `#else` directives. The conditional preprocessing block is terminated by `#endif` directive.\n\n### Conditional evaluation\n\n#### \\#if, \\#elif\n\nThe expression is a constant expression, using only [constants](../language/expressions#Constants_and_literals \"c/language/expressions\") and identifiers, defined using [` #define`](replace \"c/preprocessor/replace\") directive. Any identifier, which is not literal, non defined using [` #define`](replace \"c/preprocessor/replace\") directive, evaluates to `​0​` except `true` which evaluates to `1`(since C23).\n\nThe expression may contain unary operators in form `defined` identifier or `defined (`identifier`)` which return `1` if the identifier was defined using [` #define`](replace \"c/preprocessor/replace\") directive and `​0​` otherwise. In this context, `__has_include`, `__has_embed` and `__has_c_attribute` are treated as if they were the name of defined macros.(since C23) If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise. If any used identifier is not a constant, it is replaced with `​0​`.\n\n|                                                                                                                                                                                                                                                     |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| In context of a preprocessor directive, a `__has_c_attribute` expression detects whether a given attribute token is supported and its supported version. See [Attribute testing](../language/attributes#Attribute_testing \"c/language/attributes\"). | (since C23) |\n\nNote: Until [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#if `*`cond1`* ... `#elif `*`cond2`* is different from `#if `*`cond1`* ... `#else` followed by `#if `*`cond3`* because if *`cond1`* is true, the second `#if` is skipped and *`cond3`* does not need to be well-formed, while `#elif`'s *`cond2`* must be a valid expression. As of [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#elif` that leads the skipped code block is also skipped.\n\n#### Combined directives\n\nChecks if the identifier was [defined as a macro name](replace \"c/preprocessor/replace\").\n\n`#ifdef` identifier is essentially equivalent to `#if defined` identifier.\n\n`#ifndef` identifier is essentially equivalent to `#if !defined` identifier.\n\n[TABLE]\n\n### Notes\n\nWhile `#elifdef` and `#elifndef` directives target C23, implementations may backport them to the older language modes as conforming extensions.\n\n### Example\n\n```\n#define ABCD 2\n#include <stdio.h>\n \nint main(void)\n{\n \n#ifdef ABCD\n    printf(\"1: yes\\n\");\n#else\n    printf(\"1: no\\n\");\n#endif\n \n#ifndef ABCD\n    printf(\"2: no1\\n\");\n#elif ABCD == 2\n    printf(\"2: yes\\n\");\n#else\n    printf(\"2: no2\\n\");\n#endif\n \n#if !defined(DCBA) && (ABCD < 2 * 4 - 3)\n    printf(\"3: yes\\n\");\n#endif\n \n// C23 directives #elifdef/#elifndef\n#ifdef CPU\n    printf(\"4: no1\\n\");\n#elifdef GPU\n    printf(\"4: no2\\n\");\n#elifndef RAM\n    printf(\"4: yes\\n\"); // selected in C23 mode, may be selected in pre-C23 mode\n#else\n    printf(\"4: no3\\n\"); // may be selected in pre-C23 mode\n#endif\n}\n```\n\nPossible output:\n\n```\n1: yes\n2: yes\n3: yes\n4: yes\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                | Correct behavior          |\n|-----------------------------------------------------------------------------|------------|------------------------------------------------------|---------------------------|\n| [DR 412](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_412) | C89        | failed `#elif`'s expression was required to be valid | failed `#elif` is skipped |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.10.1 Conditional inclusion (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.1 Conditional inclusion (p: 118-119)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.1 Conditional inclusion (p: 162-164)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.1 Conditional inclusion (p: 147-149)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.1 Conditional inclusion\n\n### See also\n\n|                                                                                                                                          |     |\n|------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/conditional \"cpp/preprocessor/conditional\") for Conditional inclusion |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/conditional](https://en.cppreference.com/w/c/preprocessor/conditional)"
- name: '#include directive'
  summary: Includes another source file into the current source file at the line immediately after the directive
  description: "# Source file inclusion\n\nIncludes another source file into the current source file at the line immediately after the directive.\n\n### Syntax\n\n[TABLE]\n\n1) Searches for a header identified uniquely by h-char-sequence and replaces the directive by the entire contents of the header.\n\n2) Searches for a source file identified by q-char-sequence and replaces the directive by the entire contents of the source file. It may fallback to (1) and treat q-char-sequence as a header identifier.\n\n3) If neither (1) nor (2) is matched, pp-tokens will undergo macro replacement. The directive after replacement will be tried to match with (1) or (2) again.\n\n4) Checks whether a header or source file is available for inclusion.\n\n5) If (4) is not matched, h-pp-tokens will undergo macro replacement. The directive after replacement will be tried to match with (4) again.\n\n[TABLE]\n\n### Explanation\n\n1) Searches for the file identified by h-char-sequence in implementation-defined manner. The intent of this syntax is to search for the files under control of the implementation. Typical implementations search only standard include directories. The standard C library is implicitly included in these standard include directories. The standard include directories usually can be controlled by the user through compiler options.\n\n2) Searches for the file identified by q-char-sequence in implementation-defined manner. The intent of this syntax is to search for the files that are not controlled by the implementation. Typical implementations first search the directory where the current file resides and, only if the file is not found, search the standard include directories as with (1).\n\n3) The preprocessing tokens after `include` in the directive are processed just as in normal text (i.e., each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens). The directive resulting after all replacements shall match one of the two previous forms. The method by which a sequence of preprocessing tokens between `<` and `>` preprocessing token pair or a pair of `\"` characters is combined into a single header name preprocessing token is implementation-defined.\n\n4) The header or source file identified by h-char-sequence or q-char-sequence is searched for as if that preprocessing token sequence were the pp-tokens in syntax (3), except that no further macro expansion is performed. If such a directive would not satisfy the syntactic requirements of an \\#include directive, the program is ill-formed. The `__has_include` expression evaluates to `1` if the search for the source file succeeds, and to `​0​` if the search fails.\n\n5) This form is considered only if syntax (4) does not match, in which case the preprocessing tokens are processed just as in normal text.\n\nIn the case the file is not found, the program is ill-formed.\n\n|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| `__has_include` can be expanded in the expression of [` #if`](conditional \"c/preprocessor/conditional\") and [` #elif`](conditional \"c/preprocessor/conditional\"). It is treated as a defined macro by [` #ifdef`](conditional \"c/preprocessor/conditional\"), [` #ifndef`](conditional \"c/preprocessor/conditional\"), [` #elifdef`](conditional \"c/preprocessor/conditional\"), [` #elifndef`](conditional \"c/preprocessor/conditional\") and [`defined`](conditional \"c/preprocessor/conditional\") but cannot be used anywhere else. | (since C23) |\n\n### Notes\n\nTypical implementations search only standard include directories for syntax (1). The standard C library is implicitly included in these standard include directories. The standard include directories usually can be controlled by the user through compiler options.\n\nThe intent of syntax (2) is to search for the files that are not controlled by the implementation. Typical implementations first search the directory where the current file resides then falls back to (1).\n\nWhen a file is included, it is processed by [translation phases](../language/translation_phases \"c/language/translation phases\") 1-4, which may include, recursively, expansion of the nested `#include` directives, up to an implementation-defined nesting limit. To avoid repeated inclusion of the same file and endless recursion when a file includes itself, perhaps transitively, *header guards* are commonly used: the entire header is wrapped in\n\n```\n#ifndef FOO_H_INCLUDED /* any name uniquely mapped to file name */\n#define FOO_H_INCLUDED\n// contents of the file are here\n#endif\n```\n\nMany compilers also implement the non-standard [`pragma`](impl \"c/preprocessor/impl\") `#pragma once` with similar effects: it disables processing of a file if the same file (where file identity is determined in OS-specific way) has already been included.\n\nA `__has_include` result of `1` only means that a header or source file with the specified name exists. It does not mean that the header or source file, when included, would not cause an error or would contain anything useful.\n\n### Example\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.4.7 Header names (p: 69)\n  - 6.10.1 Conditional inclusion (p: 165-169)\n  - 6.10.2 Source file inclusion (p: 169-170)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.2 Source file inclusion (p: 119-120)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.2 Source file inclusion (p: 164-166)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.2 Source file inclusion (p: 149-151)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.2 Source file inclusion\n\n### See also\n\n|                                                                                                                                  |     |\n|----------------------------------------------------------------------------------------------------------------------------------|-----|\n| [A list of C Standard Library header files](../index \"c/header\")                                                                 |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/include \"cpp/preprocessor/include\") for Source file inclusion |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/include](https://en.cppreference.com/w/c/preprocessor/include)"
- name: '#line directive'
  summary: Changes the current line number and file name in the preprocessor
  description: "# Filename and line information\n\nChanges the current line number and file name in the preprocessor.\n\n### Syntax\n\n|                               |       |     |\n|-------------------------------|-------|-----|\n| `#line` lineno                | \\(1\\) |     |\n| `#line` lineno `\"`filename`\"` | \\(2\\) |     |\n\n### Explanation\n\n1) Changes the current preprocessor line number to lineno. Occurrences of the macro `__LINE__` beyond this point will expand to lineno plus the number of actual source code lines encountered since.\n\n2) Also changes the current preprocessor file name to filename. Occurrences of the macro `__FILE__` beyond this point will produce filename.\n\nAny preprocessing tokens (macro constants or expressions) are permitted as arguments to `#line` as long as they expand to a valid decimal integer optionally following a valid character string.\n\nlineno must be a sequence of at least one decimal digit (the program is ill-formed, otherwise) and is always interpreted as decimal (even if it starts with `0`).\n\nIf lineno is `0` or greater than `32767`(until C99)`2147483647`(since C99), the behavior is undefined.\n\n### Notes\n\nThis directive is used by some automatic code generation tools which produce C source files from a file written in another language. In that case, `#line` directives may be inserted in the generated C file referencing line numbers and the file name of the original (human-editable) source file.\n\nThe line number following the directive `#line __LINE__` is unspecified (there are two possible values that `__LINE__` can expand to in this case: number of endlines seen so far, or number of endlines seen so far plus the endline that ends the `#line` directive). This is the result of [DR 464](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2257.htm#dr_464), which applies retroactively.\n\n### Example\n\n```\n#include <assert.h>\n#define FNAME \"test.c\"\nint main(void)\n{\n#line 777 FNAME\n        assert(2+2 == 5);\n}\n```\n\nPossible output:\n\n```\ntest: test.c:777: int main(): Assertion `2+2 == 5' failed.\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.4 Line control (p: 126)\n  - J.1 Unspecified behavior\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.4 Line control (p: 173)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.4 Line control (p: 158)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.4 Line control\n\n### See also\n\n|                                                                                                                                    |     |\n|------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/line \"cpp/preprocessor/line\") for Filename and line information |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/line](https://en.cppreference.com/w/c/preprocessor/line)"
- name: '#pragma directive'
  summary: 'Implementation defined behavior is controlled by #pragma directive'
  description: "# Implementation defined behavior control\n\nImplementation defined behavior is controlled by `#pragma` directive.\n\n### Syntax\n\n|                                  |       |             |\n|----------------------------------|-------|-------------|\n| `#pragma` pragma_params          | \\(1\\) |             |\n| `_Pragma` `(` string-literal `)` | \\(2\\) | (since C99) |\n\n1) Behaves in an implementation-defined manner (unless pragma_params is one of the standard pragmas shown below).\n\n2) Removes the encoding prefix (if any), the outer quotes, and leading/trailing whitespace from string-literal, replaces each `\\\"` with `\"` and each `\\\\` with `\\`, then tokenizes the result (as in [translation stage 3](../language/translation_phases \"c/language/translation phases\")), and then uses the result as if the input to `#pragma` in (1).\n\n### Explanation\n\nThe pragma directive controls implementation-specific behavior of the compiler, such as disabling compiler warnings or changing alignment requirements. Any pragma that is not recognized is ignored.\n\n### Standard pragmas\n\nThe following three pragmas are defined by the language standard:\n\n|                                     |       |             |\n|-------------------------------------|-------|-------------|\n| `#pragma STDC FENV_ACCESS `arg      | \\(1\\) | (since C99) |\n| `#pragma STDC FP_CONTRACT `arg      | \\(2\\) | (since C99) |\n| `#pragma STDC CX_LIMITED_RANGE `arg | \\(3\\) | (since C99) |\n\nwhere arg is either `ON` or `OFF` or `DEFAULT`.\n\n1) If set to `ON`, informs the compiler that the program will access or modify [floating-point environment](../numeric/fenv \"c/numeric/fenv\"), which means that optimizations that could subvert flag tests and mode changes (e.g., global common subexpression elimination, code motion, and constant folding) are prohibited. The default value is implementation-defined, usually `OFF`.\n\n2) Allows *contracting* of floating-point expressions, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of `(x * y) + z` with a single fused multiply-add CPU instruction. The default value is implementation-defined, usually `ON`.\n\n3) Informs the compiler that multiplication, division, and absolute value of complex numbers may use simplified mathematical formulas (x+iy)×(u+iv) = (xu-yv)+i(yu+xv), (x+iy)/(u+iv) = \\[(xu+yv)+i(yu-xv)\\]/(u²+v²), and \\|x+iy\\| = √x²+y², despite the possibility of intermediate overflow. In other words, the programmer guarantees that the range of the values that will be passed to those function is limited. The default value is `OFF`\n\nNote: compilers that do not support these pragmas may provide equivalent compile-time options, such as gcc's `-fcx-limited-range` and `-ffp-contract`.\n\n### Non-standard pragmas\n\n#### \\#pragma once\n\n`#pragma once` is a non-standard pragma that is supported by the [vast majority of modern compilers](https://en.wikipedia.org/wiki/Pragma_once#Portability \"enwiki:Pragma once\"). If it appears in a header file, it indicates that it is only to be parsed once, even if it is (directly or indirectly) included multiple times in the same source file.\n\nStandard approach to preventing multiple inclusion of the same header is by using [include guards](https://en.wikipedia.org/wiki/Include_guard \"enwiki:Include guard\"):\n\n```\n#ifndef LIBRARY_FILENAME_H\n#define LIBRARY_FILENAME_H\n// contents of the header\n#endif /* LIBRARY_FILENAME_H */\n```\n\nSo that all but the first inclusion of the header in any translation unit are excluded from compilation. All modern compilers record the fact that a header file uses an include guard and do not re-parse the file if it is encountered again, as long as the guard is still defined (see e.g. [gcc](https://gcc.gnu.org/onlinedocs/cpp/Once-Only-Headers.html)).\n\nWith `#pragma once`, the same header appears as\n\n```\n#pragma once\n// contents of the header\n```\n\nUnlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with `#pragma once` files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.\n\n#### \\#pragma pack\n\nThis family of pragmas control the maximum alignment for subsequently defined structure and union members.\n\n|                                |       |     |\n|--------------------------------|-------|-----|\n| `#pragma pack(``arg``) `       | \\(1\\) |     |\n| `#pragma pack() `              | \\(2\\) |     |\n| `#pragma pack(push) `          | \\(3\\) |     |\n| `#pragma pack(push, ``arg``) ` | \\(4\\) |     |\n| `#pragma pack(pop) `           | \\(5\\) |     |\n\nwhere arg is a small power of two and specifies the new alignment in bytes.\n\n1) Sets the current alignment to value arg.\n\n2) Sets the current alignment to the default value (specified by a command-line option).\n\n3) Pushes the value of the current alignment on an internal stack.\n\n4) Pushes the value of the current alignment on the internal stack and then sets the current alignment to value arg.\n\n5) Pops the top entry from the internal stack and then sets (restores) the current alignment to that value.\n\n`#pragma pack` may decrease the alignment of a structure, however, it cannot make a structure overaligned.\n\nSee also specific details for [GCC](https://gcc.gnu.org/onlinedocs/gcc/Structure-Layout-Pragmas.html) and [MSVC](https://docs.microsoft.com/en-us/cpp/preprocessor/pack).\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.6 Pragma directive (p: 127)\n  - 6.10.9 Pragma operator (p: 129)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.6 Pragma directive (p: 174)\n  - 6.10.9 Pragma operator (p: 178)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.6 Pragma directive (p: 159)\n  - 6.10.9 Pragma operator (p: 161-162)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.6 Pragma directive\n\n### See also\n\n|                                                                                                                                              |     |\n|----------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/impl \"cpp/preprocessor/impl\") for Implementation defined behavior control |     |\n\n### External links\n\n|     |                                                                                                                                                                                                                                                                                                                                |\n|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 1\\. | [C++ pragmas in Visual Studio 2019](https://docs.microsoft.com/en-us/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=vs-2019)                                                                                                                                                                                   |\n| 2\\. | [Pragmas](https://gcc.gnu.org/onlinedocs/gcc/Pragmas.html) accepted by GCC                                                                                                                                                                                                                                                     |\n| 3\\. | [Individual pragma descriptions](https://www.ibm.com/support/knowledgecenter/en/SSGH3R_16.1.0/com.ibm.xlcpp161.aix.doc/compiler_ref/pragma_descriptions.html) and [Standard pragmas](https://www.ibm.com/support/knowledgecenter/en/SSGH3R_16.1.0/com.ibm.xlcpp161.aix.doc/language_ref/std_pragmas.html) in IBM AIX XL C 16.1 |\n| 4\\. | [Appendix B. Pragmas](http://download.oracle.com/docs/cd/E19422-01/819-3690/Pragmas_App.html#73499) in Sun Studio 11 C++ User's Guide                                                                                                                                                                                          |\n| 5\\. | [Intel C++ compiler pragmas](https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/pragmas.html)                                                                                                                                                |\n| 6\\. | [HP aCC compiler pragmas](http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/Online_Help/pragmas.htm)                                                                                                                                                                                                                 |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/impl](https://en.cppreference.com/w/c/preprocessor/impl)"
- name: _Alignas
  summary: Appears in the declaration syntax as one of the type specifiers to modify the alignment requirement of the object being declared
  description: "# \\_Alignas (since C11), alignas (since C23)\n\nAppears in the [declaration](declarations \"c/language/declarations\") syntax as one of the type specifiers to modify the [alignment requirement](object#Alignment \"c/language/object\") of the object being declared.\n\n### Syntax\n\n|                               |       |             |\n|-------------------------------|-------|-------------|\n| `_Alignas` `(` expression `)` | \\(1\\) | (since C11) |\n| `alignas` `(` expression `)`  | \\(2\\) | (since C23) |\n| `_Alignas` `(` type `)`       | \\(3\\) | (since C11) |\n| `alignas` `(` type `)`        | \\(4\\) | (since C23) |\n\n|            |     |                                                                                                                                                                          |\n|------------|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| expression | \\-  | any [integer constant expression](constant_expression \"c/language/constant expression\") whose value is a valid [alignment](object#Alignment \"c/language/object\") or zero |\n| type       | \\-  | any [type name](type#Type_names \"c/language/type\")                                                                                                                       |\n\n|                                                                                                                                                              |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The keyword `_Alignas` is also available as convenience macro [`alignas`](../types \"c/types\"), available in the header [`<stdalign.h>`](../types \"c/types\"). | (until C23) |\n\n### Explanation\n\nThe `_Alignas`(until C23)`alignas`(since C23) specifier can only be used when declaring objects that are not [bit-fields](bit_field \"c/language/bit field\"), and don't have the [register](storage_duration \"c/language/storage duration\") storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.\n\nWhen used in a declaration, the declared object will have its [alignment requirement](object#Alignment \"c/language/object\") set to\n\n1,2) the result of the expression, unless it is zero\n\n3,4) the alignment requirement of type, that is, to `_Alignof(type)`(until C23)`alignof(type)`(since C23)\n\nexcept when this would weaken the alignment the type would have had naturally.\n\nIf expression evaluates to zero, this specifier has no effect.\n\nWhen multiple `_Alignas`(until C23)`alignas`(since C23) specifiers appear in the same declaration, the strictest one is used.\n\n`_Alignas`(until C23)`alignas`(since C23) specifier only needs to appear on the [definition](declarations#Definitions \"c/language/declarations\") of an object, but if any declaration uses `_Alignas`(until C23)`alignas`(since C23), it must specify the same alignment as the `_Alignas`(until C23)`alignas`(since C23) on the definition. The behavior is undefined if different translation units specify different alignments for the same object.\n\n### Notes\n\nIn C++, the `alignas` specifier may also be applied to the declarations of class/struct/union types and enumerations. This is not supported in C, but the alignment of a struct type can be controlled by using `_Alignas`(until C23)`alignas`(since C23) in a member declaration.\n\n### Keywords\n\n[`alignas`](../keyword/alignas \"c/keyword/alignas\"), [`_Alignas`](../keyword/_alignas \"c/keyword/ Alignas\")\n\n### Example\n\n```\n#include <stdalign.h>\n#include <stdio.h>\n \n// every object of type struct sse_t will be aligned to 16-byte boundary\n// (note: needs support for DR 444)\nstruct sse_t\n{\n    alignas(16) float sse_data[4];\n};\n \n// every object of type struct data will be aligned to 128-byte boundary\nstruct data\n{\n    char x;\n    alignas(128) char cacheline[128]; // over-aligned array of char,\n                                      // not array of over-aligned chars\n};\n \nint main(void)\n{\n    printf(\"sizeof(data) = %zu (1 byte + 127 bytes padding + 128-byte array)\\n\",\n           sizeof(struct data));\n \n    printf(\"alignment of sse_t is %zu\\n\", alignof(struct sse_t));\n \n    alignas(2048) struct data d; // this instance of data is aligned even stricter\n    (void)d; // suppresses \"maybe unused\" warning\n}\n```\n\nOutput:\n\n```\nsizeof(data) = 256 (1 byte + 127 bytes padding + 128-byte array)\nalignment of sse_t is 16\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                  | Correct behavior |\n|-----------------------------------------------------------------------------|------------|--------------------------------------------------------|------------------|\n| [DR 444](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_444) | C11        | `_Alignas` was not allowed in struct and union members | allowed          |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.5 Alignment specifier (p: TBD)\n  - 6.2.8 Alignment of objects (p: TBD)\n  - 7.15 Alignment \\<stdalign.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.5 Alignment specifier (p: 92)\n  - 6.2.8 Alignment of objects (p: 36-37)\n  - 7.15 Alignment \\<stdalign.h\\> (p: 196)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.5 Alignment specifier (p: 127-128)\n  - 6.2.8 Alignment of objects (p: 48-49)\n  - 7.15 Alignment \\<stdalign.h\\> (p: 268)\n\n### See also\n\n|                                                                                                                        |     |\n|------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/alignas \"cpp/language/alignas\") for `alignas` specifier |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/\\_Alignas](https://en.cppreference.com/w/c/language/_Alignas)"
- name: _Alignas
  summary: Appears in the declaration syntax as one of the type specifiers to modify the alignment requirement of the object being declared
  description: "# \\_Alignas (since C11), alignas (since C23)\n\nAppears in the [declaration](declarations \"c/language/declarations\") syntax as one of the type specifiers to modify the [alignment requirement](object#Alignment \"c/language/object\") of the object being declared.\n\n### Syntax\n\n|                               |       |             |\n|-------------------------------|-------|-------------|\n| `_Alignas` `(` expression `)` | \\(1\\) | (since C11) |\n| `alignas` `(` expression `)`  | \\(2\\) | (since C23) |\n| `_Alignas` `(` type `)`       | \\(3\\) | (since C11) |\n| `alignas` `(` type `)`        | \\(4\\) | (since C23) |\n\n|            |     |                                                                                                                                                                          |\n|------------|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| expression | \\-  | any [integer constant expression](constant_expression \"c/language/constant expression\") whose value is a valid [alignment](object#Alignment \"c/language/object\") or zero |\n| type       | \\-  | any [type name](type#Type_names \"c/language/type\")                                                                                                                       |\n\n|                                                                                                                                                              |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The keyword `_Alignas` is also available as convenience macro [`alignas`](../types \"c/types\"), available in the header [`<stdalign.h>`](../types \"c/types\"). | (until C23) |\n\n### Explanation\n\nThe `_Alignas`(until C23)`alignas`(since C23) specifier can only be used when declaring objects that are not [bit-fields](bit_field \"c/language/bit field\"), and don't have the [register](storage_duration \"c/language/storage duration\") storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.\n\nWhen used in a declaration, the declared object will have its [alignment requirement](object#Alignment \"c/language/object\") set to\n\n1,2) the result of the expression, unless it is zero\n\n3,4) the alignment requirement of type, that is, to `_Alignof(type)`(until C23)`alignof(type)`(since C23)\n\nexcept when this would weaken the alignment the type would have had naturally.\n\nIf expression evaluates to zero, this specifier has no effect.\n\nWhen multiple `_Alignas`(until C23)`alignas`(since C23) specifiers appear in the same declaration, the strictest one is used.\n\n`_Alignas`(until C23)`alignas`(since C23) specifier only needs to appear on the [definition](declarations#Definitions \"c/language/declarations\") of an object, but if any declaration uses `_Alignas`(until C23)`alignas`(since C23), it must specify the same alignment as the `_Alignas`(until C23)`alignas`(since C23) on the definition. The behavior is undefined if different translation units specify different alignments for the same object.\n\n### Notes\n\nIn C++, the `alignas` specifier may also be applied to the declarations of class/struct/union types and enumerations. This is not supported in C, but the alignment of a struct type can be controlled by using `_Alignas`(until C23)`alignas`(since C23) in a member declaration.\n\n### Keywords\n\n[`alignas`](../keyword/alignas \"c/keyword/alignas\"), [`_Alignas`](../keyword/_alignas \"c/keyword/ Alignas\")\n\n### Example\n\n```\n#include <stdalign.h>\n#include <stdio.h>\n \n// every object of type struct sse_t will be aligned to 16-byte boundary\n// (note: needs support for DR 444)\nstruct sse_t\n{\n    alignas(16) float sse_data[4];\n};\n \n// every object of type struct data will be aligned to 128-byte boundary\nstruct data\n{\n    char x;\n    alignas(128) char cacheline[128]; // over-aligned array of char,\n                                      // not array of over-aligned chars\n};\n \nint main(void)\n{\n    printf(\"sizeof(data) = %zu (1 byte + 127 bytes padding + 128-byte array)\\n\",\n           sizeof(struct data));\n \n    printf(\"alignment of sse_t is %zu\\n\", alignof(struct sse_t));\n \n    alignas(2048) struct data d; // this instance of data is aligned even stricter\n    (void)d; // suppresses \"maybe unused\" warning\n}\n```\n\nOutput:\n\n```\nsizeof(data) = 256 (1 byte + 127 bytes padding + 128-byte array)\nalignment of sse_t is 16\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                  | Correct behavior |\n|-----------------------------------------------------------------------------|------------|--------------------------------------------------------|------------------|\n| [DR 444](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_444) | C11        | `_Alignas` was not allowed in struct and union members | allowed          |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.5 Alignment specifier (p: TBD)\n  - 6.2.8 Alignment of objects (p: TBD)\n  - 7.15 Alignment \\<stdalign.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.5 Alignment specifier (p: 92)\n  - 6.2.8 Alignment of objects (p: 36-37)\n  - 7.15 Alignment \\<stdalign.h\\> (p: 196)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.5 Alignment specifier (p: 127-128)\n  - 6.2.8 Alignment of objects (p: 48-49)\n  - 7.15 Alignment \\<stdalign.h\\> (p: 268)\n\n### See also\n\n|                                                                                                                        |     |\n|------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/alignas \"cpp/language/alignas\") for `alignas` specifier |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/alignas](https://en.cppreference.com/w/c/language/alignas)"
- name: _Alignas
  summary: ''
  description: "# C keywords: \\_Alignas (since C11)\n\n### Usage\n\n- [`_Alignas`](../language/_alignas \"c/language/ Alignas\") alignment specifier. (since C11)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Alignas](https://en.cppreference.com/w/c/keyword/_Alignas)"
- name: _Alignof
  summary: ''
  description: "# C keywords: \\_Alignof (since C11)\n\n### Usage\n\n- [`_Alignof` operator](../language/_alignof \"c/language/ Alignof\") (since C11)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Alignof](https://en.cppreference.com/w/c/keyword/_Alignof)"
- name: _Alignof operator
  summary: Queries the alignment requirement of its operand type
  description: "# \\_Alignof operator (since C11)\n\nQueries the alignment requirement of its operand type.\n\n### Syntax\n\n|                           |     |             |\n|---------------------------|-----|-------------|\n| `_Alignof(` type-name `)` |     | (since C11) |\n| `alignof(` type-name `)`  |     | (since C23) |\n\n|                                                                                                                                                                     |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| This operator is typically used through the convenience macro [`alignof`](../types \"c/types\"), which is provided in the header [`<stdalign.h>`](../types \"c/types\") | (until C23) |\n\n### Explanation\n\nReturns the [alignment requirement](object#Alignment \"c/language/object\") of the type [named](type#Type_names \"c/language/type\") by type-name. If type-name is an array type, the result is the alignment requirement of the array element type. The type-name cannot be function type or an incomplete type.\n\nThe result is an integer constant of type [`size_t`](../types/size_t \"c/types/size t\").\n\nThe operand is not evaluated (so external identifiers used in the operand do not have to be defined).\n\nIf type-name is a [VLA](array \"c/language/array\") type, its size expression is not evaluated.\n\n### Notes\n\nThe use of `_Alignof`(until C23)`alignof`(since C23) with expressions is allowed by some C compilers as a non-standard extension.\n\n### Keywords\n\n[`alignof`](../keyword/alignof \"c/keyword/alignof\"), [`_Alignof`](../keyword/_alignof \"c/keyword/ Alignof\")\n\n### Example\n\n```\n#include <stdalign.h>\n#include <stddef.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"Alignment of char = %zu\\n\", alignof(char));\n    printf(\"Alignment of max_align_t = %zu\\n\", alignof(max_align_t));\n    printf(\"alignof(float[10]) = %zu\\n\", alignof(float[10]));\n    printf(\"alignof(struct{char c; int n;}) = %zu\\n\",\n            alignof(struct {char c; int n;}));\n}\n```\n\nPossible output:\n\n```\nAlignment of char = 1\nAlignment of max_align_t = 16\nalignof(float[10]) = 4\nalignof(struct{char c; int n;}) = 4\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                                           | Correct behavior  |\n|-----------------------------------------------------------------------------|------------|---------------------------------------------------------------------------------|-------------------|\n| [DR 494](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_494) | C11        | whether the size expression in a VLA is evaluated in `_Alignof` was unspecified | it is unevaluated |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.5.3.4 The sizeof and alignof operators (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.3.4 The sizeof and \\_Alignof operators (p: 64-65)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.3.4 The sizeof and \\_Alignof operators (p: 90-91)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/\\_Alignof](https://en.cppreference.com/w/c/language/_Alignof)"
- name: _Alignof operator
  summary: Queries the alignment requirement of its operand type
  description: "# \\_Alignof operator (since C11)\n\nQueries the alignment requirement of its operand type.\n\n### Syntax\n\n|                           |     |             |\n|---------------------------|-----|-------------|\n| `_Alignof(` type-name `)` |     | (since C11) |\n| `alignof(` type-name `)`  |     | (since C23) |\n\n|                                                                                                                                                                     |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| This operator is typically used through the convenience macro [`alignof`](../types \"c/types\"), which is provided in the header [`<stdalign.h>`](../types \"c/types\") | (until C23) |\n\n### Explanation\n\nReturns the [alignment requirement](object#Alignment \"c/language/object\") of the type [named](type#Type_names \"c/language/type\") by type-name. If type-name is an array type, the result is the alignment requirement of the array element type. The type-name cannot be function type or an incomplete type.\n\nThe result is an integer constant of type [`size_t`](../types/size_t \"c/types/size t\").\n\nThe operand is not evaluated (so external identifiers used in the operand do not have to be defined).\n\nIf type-name is a [VLA](array \"c/language/array\") type, its size expression is not evaluated.\n\n### Notes\n\nThe use of `_Alignof`(until C23)`alignof`(since C23) with expressions is allowed by some C compilers as a non-standard extension.\n\n### Keywords\n\n[`alignof`](../keyword/alignof \"c/keyword/alignof\"), [`_Alignof`](../keyword/_alignof \"c/keyword/ Alignof\")\n\n### Example\n\n```\n#include <stdalign.h>\n#include <stddef.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"Alignment of char = %zu\\n\", alignof(char));\n    printf(\"Alignment of max_align_t = %zu\\n\", alignof(max_align_t));\n    printf(\"alignof(float[10]) = %zu\\n\", alignof(float[10]));\n    printf(\"alignof(struct{char c; int n;}) = %zu\\n\",\n            alignof(struct {char c; int n;}));\n}\n```\n\nPossible output:\n\n```\nAlignment of char = 1\nAlignment of max_align_t = 16\nalignof(float[10]) = 4\nalignof(struct{char c; int n;}) = 4\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                                           | Correct behavior  |\n|-----------------------------------------------------------------------------|------------|---------------------------------------------------------------------------------|-------------------|\n| [DR 494](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_494) | C11        | whether the size expression in a VLA is evaluated in `_Alignof` was unspecified | it is unevaluated |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.5.3.4 The sizeof and alignof operators (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.3.4 The sizeof and \\_Alignof operators (p: 64-65)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.3.4 The sizeof and \\_Alignof operators (p: 90-91)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/alignof](https://en.cppreference.com/w/c/language/alignof)"
- name: _Atomic
  summary: ''
  description: "# C keywords: \\_Atomic (since C11)\n\n### Usage\n\n- [atomic type specifier and qualifier](../language/atomic \"c/language/atomic\") (since C11)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Atomic](https://en.cppreference.com/w/c/keyword/_Atomic)"
- name: _Bool
  summary: ''
  description: "# C keywords: \\_Bool (since C99)\n\n### Usage\n\n- [boolean type](../language/arithmetic_types#Boolean_type \"c/language/arithmetic types\"): as the declaration of the type (since C99)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Bool](https://en.cppreference.com/w/c/keyword/_Bool)"
- name: _Complex
  summary: ''
  description: "# C keywords: \\_Complex (since C99)\n\n### Usage\n\n- [`_Complex` type](../language/arithmetic_types#Complex_floating_types \"c/language/arithmetic types\"): as the declaration of the type (since C99)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Complex](https://en.cppreference.com/w/c/keyword/_Complex)"
- name: _Complex_I
  summary: The _Complex_I macro expands to a value of type const float _Complex with the value of the imaginary unit
  description: "# \\_Complex_I\n\n[TABLE]\n\nThe `_Complex_I` macro expands to a value of type `const float _Complex` with the value of the imaginary unit.\n\n### Notes\n\nThis macro may be used when `I` is not available, such as when it has been undefined by the application.\n\nUnlike [`_Imaginary_I`](imaginary_i \"c/numeric/complex/Imaginary I\") and [`CMPLX`](cmplx \"c/numeric/complex/CMPLX\"), use of this macro to construct a complex number may lose the sign of zero on the imaginary part.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \n#undef I\n#define J _Complex_I // can be used to redefine I\n \nint main(void)\n{\n    // can be used to construct a complex number\n    double complex z = 1.0 + 2.0 * _Complex_I;\n    printf(\"1.0 + 2.0 * _Complex_I = %.1f%+.1fi\\n\", creal(z), cimag(z));\n \n    // sign of zero may not be preserved\n    double complex z2 = 0.0 + -0.0 * _Complex_I;\n    printf(\"0.0 + -0.0 * _Complex_I = %.1f%+.1fi\\n\", creal(z2), cimag(z2));\n}\n```\n\nPossible output:\n\n```\n1.0 + 2.0 * _Complex_I = 1.0+2.0i\n0.0 + -0.0 * _Complex_I = 0.0+0.0i\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.3.1/4 \\_Complex_I (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.3.1/4 \\_Complex_I (p: 136)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.1/4 \\_Complex_I (p: 188)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.1/2 \\_Complex_I (p: 170)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/Complex_I](https://en.cppreference.com/w/c/numeric/complex/Complex_I)"
- name: _Decimal128
  summary: ''
  description: "# C keywords: \\_Decimal128 (since C23)\n\n### Usage\n\n- [`_Decimal128` type](../language/types \"c/language/types\"): as the declaration of the type (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Decimal128](https://en.cppreference.com/w/c/keyword/_Decimal128)"
- name: _Decimal32
  summary: ''
  description: "# C keywords: \\_Decimal32 (since C23)\n\n### Usage\n\n- [`_Decimal32` type](../language/types \"c/language/types\"): as the declaration of the type (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Decimal32](https://en.cppreference.com/w/c/keyword/_Decimal32)"
- name: _Decimal64
  summary: ''
  description: "# C keywords: \\_Decimal64 (since C23)\n\n### Usage\n\n- [`_Decimal64` type](../language/types \"c/language/types\"): as the declaration of the type (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Decimal64](https://en.cppreference.com/w/c/keyword/_Decimal64)"
- name: _Exit
  summary: Causes normal program termination to occur without completely cleaning the resources
  description: "# \\_Exit\n\n[TABLE]\n\nCauses normal program termination to occur without completely cleaning the resources.\n\nFunctions passed to [`at_quick_exit()`](at_quick_exit \"c/program/at quick exit\") or [`atexit()`](atexit \"c/program/atexit\") are not called. Whether open streams with unwritten buffered data are flushed, open streams are closed, or temporary files are removed is implementation-defined.\n\nIf `exit_code` is `0` or [`EXIT_SUCCESS`](exit_status \"c/program/EXIT status\"), an implementation-defined status indicating successful termination is returned to the host environment. If `exit_code` is [`EXIT_FAILURE`](exit_status \"c/program/EXIT status\"), an implementation-defined status, indicating *unsuccessful* termination, is returned. In other cases an implementation-defined status value is returned.\n\n### Parameters\n\n|           |     |                            |\n|-----------|-----|----------------------------|\n| exit_code | \\-  | exit status of the program |\n\n### Return value\n\n(none)\n\n### Example\n\n```\n#include <stdlib.h>\n#include <stdio.h>\n \n/* _Exit does not call functions registered with atexit. */\nvoid f1(void)\n{\n    puts(\"pushed first\");\n}\n \nvoid f2(void)\n{\n    puts(\"pushed second\");\n}\n \nint main(void)\n{\n    printf(\"Enter main()\\n\");\n    atexit(f1);\n    atexit(f2);\n    fflush(stdout);   /* _Exit may not flush unwritten buffered data */\n    _Exit(0);\n}\n```\n\nOutput:\n\n```\nEnter main()\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.4.5 The \\_Exit function (p: 256)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.4.5 The \\_Exit function (p: 352)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.4.4 The \\_Exit function (p: 316)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/\\_Exit](https://en.cppreference.com/w/c/program/_Exit)"
- name: _Generic
  summary: ''
  description: "# C keywords: \\_Generic (since C11)\n\n### Usage\n\n- [Type-generic expression](../language/generic \"c/language/generic\") (since C11)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Generic](https://en.cppreference.com/w/c/keyword/_Generic)"
- name: _Imaginary
  summary: ''
  description: "# C keywords: \\_Imaginary (since C99)\n\n### Usage\n\n- [imaginary floating type](../language/arithmetic_types#Imaginary_floating_types \"c/language/arithmetic types\") specifier (since C99)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Imaginary](https://en.cppreference.com/w/c/keyword/_Imaginary)"
- name: _Imaginary_I
  summary: The _Imaginary_I macro expands to a value of type const float _Imaginary with the value of the imaginary unit
  description: "# \\_Imaginary_I\n\n[TABLE]\n\nThe `_Imaginary_I` macro expands to a value of type `const float _Imaginary` with the value of the imaginary unit.\n\nAs with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.\n\n[TABLE]\n\n### Notes\n\nThis macro allows for the precise way to assemble a complex number from its real and imaginary components, e.g. with `(``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex)`)``(``(``double``)``x ``+`` _Imaginary_I ``*`` ``(``double``)``y``)`. This pattern was standardized in C11 as the macro [`CMPLX`](http://en.cppreference.com/w/c/numeric/complex/CMPLX). Note that if [`_Complex_I`](http://en.cppreference.com/w/c/numeric/complex/Complex_I) is used instead, this expression is allowed to convert negative zero to positive zero in the imaginary position.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n#include <math.h>\n \nint main(void)\n{\n    double complex z1 = 0.0 + INFINITY * _Imaginary_I;\n    printf(\"z1 = %.1f%+.1fi\\n\", creal(z1), cimag(z1));\n \n    double complex z2 = 0.0 + INFINITY * _Complex_I;\n    printf(\"z2 = %.1f%+.1fi\\n\", creal(z2), cimag(z2));\n}\n```\n\nOutput:\n\n```\nz1 = 0.0+Infi \nz2 = NaN+Infi\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.1/5 \\_Imaginary_I (p: 188)\n  - G.6/1 \\_Imaginary_I (p: 537)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.1/3 \\_Imaginary_I (p: 170)\n  - G.6/1 \\_Imaginary_I (p: 472)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/Imaginary_I](https://en.cppreference.com/w/c/numeric/complex/Imaginary_I)"
- name: _Noreturn
  summary: Since C23, _Noreturn is also attribute token
  description: "# C keywords: \\_Noreturn (since C11)\n\n### Usage\n\n- [`_Noreturn` function specifier](../language/_noreturn \"c/language/ Noreturn\")(deprecated in C23)\n- [`_Noreturn` attribute-token](../language/attributes/noreturn \"c/language/attributes/noreturn\")(since C23)(deprecated in C23)\n\n### Notes\n\nSince C23, `_Noreturn` is also [attribute token](../language/attributes/noreturn \"c/language/attributes/noreturn\"). Its usage is deprecated and `noreturn` should be used instead.\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Noreturn](https://en.cppreference.com/w/c/keyword/_Noreturn)"
- name: _Noreturn (since C23)
  summary: Indicates that the function does not return
  description: "# C attribute: noreturn, \\_Noreturn (since C23)\n\nIndicates that the function does not return.\n\n### Syntax\n\n[TABLE]\n\n### Explanation\n\nIndicates that the function does not return.\n\nThis attribute applies to the name of the function and specifies that the function does not return by executing the return statement or by reaching the end of the function body (it may return by executing [`longjmp`](../../program/longjmp \"c/program/longjmp\")). The behavior is undefined if the function with this attribute actually returns. A compiler diagnostic is recommended if this can be detected.\n\nIt has been previously denoted by the keyword [`_Noreturn`](../_noreturn \"c/language/ Noreturn\") until it was deprecated since C23 and replaced by this attribute.\n\n### Standard library\n\nThe following standard functions are declared with `noreturn` attribute (they used to be declared with [`_Noreturn`](../_noreturn \"c/language/ Noreturn\") specifier until C23):\n\n- [`abort()`](../../program/abort \"c/program/abort\")\n- [`exit()`](../../program/exit \"c/program/exit\")\n- [`_Exit()`](../../program/_exit \"c/program/ Exit\")\n- [`quick_exit()`](../../program/quick_exit \"c/program/quick exit\")\n- [`thrd_exit()`](../../thread/thrd_exit \"c/thread/thrd exit\")\n- [`longjmp()`](../../program/longjmp \"c/program/longjmp\")\n\n### See also\n\n|                                                                                                                                           |     |\n|-------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C documentation](../_noreturn \"c/language/ Noreturn\") for `_Noreturn`                                                                    |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/attributes/noreturn \"cpp/language/attributes/noreturn\") for `[[noreturn]]` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes/noreturn](https://en.cppreference.com/w/c/language/attributes/noreturn)"
- name: _Noreturn function specifier
  summary: Specifies that the function does not return to its point of invocation
  description: "# \\_Noreturn function specifier\n\nSpecifies that the function does not return to its point of invocation.\n\n### Syntax\n\n|                                  |     |                                |\n|----------------------------------|-----|--------------------------------|\n| `_Noreturn` function_declaration |     | (since C11)(deprecated in C23) |\n\n### Explanation\n\nThe `_Noreturn` keyword appears in a function declaration and specifies that the function does not return by executing the return statement or by reaching the end of the function body (it may return by executing [`longjmp`](../program/longjmp \"c/program/longjmp\")). If the function declared `_Noreturn` returns, the behavior is undefined. A compiler diagnostic is recommended if this can be detected.\n\nThe `_Noreturn` specifier may appear more than once in the same function declaration, the behavior is the same as if it appeared once.\n\nThis specifier is typically used through the convenience macro [`noreturn`](../types \"c/types\"), which is provided in the header `<stdnoreturn.h>`.\n\n[TABLE]\n\n### Keywords\n\n[`_Noreturn`](../keyword/_noreturn \"c/keyword/ Noreturn\")\n\n### Standard library\n\nThe following functions are `noreturn` in the standard library:\n\n- [`abort()`](../program/abort \"c/program/abort\")\n- [`exit()`](../program/exit \"c/program/exit\")\n- [`_Exit()`](../program/_exit \"c/program/ Exit\")\n- [`quick_exit()`](../program/quick_exit \"c/program/quick exit\")\n- [`thrd_exit()`](../thread/thrd_exit \"c/thread/thrd exit\")\n- [`longjmp()`](../program/longjmp \"c/program/longjmp\")\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdnoreturn.h>\n \n// causes undefined behavior if i <= 0\n// exits if i > 0\nnoreturn void exit_now(int i) // or _Noreturn void exit_now(int i)\n{\n    if (i > 0)\n        exit(i);\n}\n \nint main(void)\n{\n    puts(\"Preparing to exit...\");\n    exit_now(2);\n    puts(\"This code is never executed.\");\n}\n```\n\nOutput:\n\n```\nPreparing to exit...\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.4 Function specifiers (p: TBD)\n  - 7.23 \\_Noreturn \\<stdnoreturn.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.4 Function specifiers (p: 90-91)\n  - 7.23 \\_Noreturn \\<stdnoreturn.h\\> (p: 263)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.4 Function specifiers (p: 125-127)\n  - 7.23 \\_Noreturn \\<stdnoreturn.h\\> (p: 361)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/\\_Noreturn](https://en.cppreference.com/w/c/language/_Noreturn)"
- name: _Static_assert
  summary: ''
  description: "# C keywords: \\_Static_assert (since C11)(deprecated in C23)\n\n### Usage\n\n- [static assert declaration](../language/_static_assert \"c/language/ Static assert\") (since C11)(deprecated in C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Static_assert](https://en.cppreference.com/w/c/keyword/_Static_assert)"
- name: _Thread_local
  summary: ''
  description: "# C keywords: \\_Thread_local (since C11)\n\n### Usage\n\n- [thread storage-class specifier](../language/storage_duration \"c/language/storage duration\") (since C11)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/\\_Thread_local](https://en.cppreference.com/w/c/keyword/_Thread_local)"
- name: abort
  summary: Causes abnormal program termination unless SIGABRT is being caught by a signal handler passed to signal and the handler does not return
  description: "# abort\n\n[TABLE]\n\nCauses abnormal program termination unless [`SIGABRT`](sig_types \"c/program/SIG types\") is being caught by a signal handler passed to signal and the handler does not return.\n\nFunctions passed to [`atexit()`](atexit \"c/program/atexit\") are not called. Whether open resources such as files are closed is implementation defined. An implementation defined status is returned to the host environment that indicates unsuccessful execution.\n\n### Parameters\n\n(none)\n\n### Return value\n\n(none)\n\n### Notes\n\nPOSIX [specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/abort.html) that the `abort()` function overrides blocking or ignoring the `SIGABRT` signal.\n\nSome compiler intrinsics, e.g. [`__builtin_trap`](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html) (gcc, clang, and icc) or [`__fastfail`](https://learn.microsoft.com/en-us/cpp/intrinsics/fastfail)/[`__debugbreak`](https://learn.microsoft.com/en-us/cpp/intrinsics/debugbreak) (msvc), can be used to terminate the program as fast as possible.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE *fp = fopen(\"data.txt\",\"r\");\n    if (fp == NULL)\n    {\n        fprintf(stderr, \"error opening file data.txt in function main()\\n\");\n        abort();\n    }\n \n    /* Normal processing continues here. */\n    fclose(fp);\n    printf(\"Normal Return\\n\");\n    return 0;\n}\n```\n\nOutput:\n\n```\nerror opening file data.txt in function main()\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.4.1 The abort function (p: 255)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.4.1 The abort function (p: 350)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.4.1 The abort function (p: 315)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.4.1 The abort function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/abort](https://en.cppreference.com/w/c/program/abort)"
- name: abort_handler_s
  summary: Writes an implementation-defined message to stderr which must include the string pointed to by msg and calls abort()
  description: "# abort_handler_s\n\n[TABLE]\n\nWrites an implementation-defined message to [`stderr`](../io/std_streams \"c/io/std streams\") which must include the string pointed to by `msg` and calls [`abort()`](../program/abort \"c/program/abort\").\n\nA pointer to this function can be passed to [set_constraint_handler_s](set_constraint_handler_s \"c/error/set constraint handler s\") to establish a runtime constraints violation handler. As with all bounds-checked functions, `abort_handler_s` is only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including `<stdlib.h>`.\n\n### Parameters\n\n|       |     |                                                                                                                                                                                                                                          |\n|-------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| msg   | \\-  | pointer to the message written to the standard error stream                                                                                                                                                                              |\n| ptr   | \\-  | pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected |\n| error | \\-  | a positive value of type errno_t                                                                                                                                                                                                         |\n\n### Return value\n\nnone; this function does not return to its caller\n\n### Notes\n\nIf `set_constraint_handler_s` is never called, the default handler is implementation-defined: it may be `abort_handler_s`, `ignore_handler_s`, or some other implementation-defined handler.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n#ifdef __STDC_LIB_EXT1__\n    char dst[2];\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcpy_s(dst, sizeof dst, \"Too long!\");\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n    set_constraint_handler_s(abort_handler_s);\n    r = strcpy_s(dst, sizeof dst, \"Too long!\");\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n#endif\n}\n```\n\nPossible output:\n\n```\ndst = \"\", r = 22\nabort_handler_s was called in response to a runtime-constraint violation.\n \nThe runtime-constraint violation was caused by the following expression in strcpy_s:\n(s1max <= (s2_len=strnlen_s(s2, s1max)) ) (in string_s.c:62)\n \nNote to end users: This program was terminated as a result\nof a bug present in the software. Please reach out to your\nsoftware's vendor to get more help.\nAborted\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - K.3.6.1.2 The abort_handler_s function (p: 605)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/error/abort_handler_s](https://en.cppreference.com/w/c/error/abort_handler_s)"
- name: abs
  summary: Computes the absolute value of an integer number
  description: "# abs, labs, llabs, imaxabs\n\n[TABLE]\n\nComputes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.\n\n### Parameters\n\n|     |     |               |\n|-----|-----|---------------|\n| n   | \\-  | integer value |\n\n### Return value\n\nThe absolute value of `n` (i.e. `|n|`), if it is representable.\n\n### Notes\n\nIn 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type `int`, [`INT_MIN`](../../types/limits \"c/types/limits\") is `-2147483648`, but the would-be result `2147483648` is greater than [`INT_MAX`](../../types/limits \"c/types/limits\"), which is `2147483647`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n \nint main(void)\n{\n    printf(\"abs(+3) = %d\\n\", abs(+3));\n    printf(\"abs(-3) = %d\\n\", abs(-3));\n \n//  printf(\"%+d\\n\", abs(INT_MIN)); // undefined behavior on 2's complement systems\n}\n```\n\nOutput:\n\n```\nabs(+3) = 3\nabs(-3) = 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.2.1 The imaxabs function (p: 159)\n  - 7.22.6.1 The abs, labs and llabs functions (p: 259)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.1 The imaxabs function (p: 218)\n  - 7.22.6.1 The abs, labs and llabs functions (p: 356)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.1 The imaxabs function (p: 199-200)\n  - 7.20.6.1 The abs, labs and llabs functions (p: 320)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.6.1 The abs function\n  - 4.10.6.3 The labs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/abs](https://en.cppreference.com/w/c/numeric/math/abs)"
- name: acos
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# acos, acosf, acosl\n\n[TABLE]\n\n1-6) Computes the principal value of the arc cosine of `arg`.\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`acosl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`acos`) is called. Otherwise, (1) (`acosf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`cacosf`](../complex/cacos \"c/numeric/complex/cacos\"), [`cacos`](../complex/cacos \"c/numeric/complex/cacos\"), [`cacosl`](../complex/cacos \"c/numeric/complex/cacos\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating-point value |\n\n### Return value\n\nIf no errors occur, the arc cosine of `arg` (arccos(arg)) in the range \\[0 ; π\\], is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is outside the range `[-1.0; 1.0]`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- If the argument is +1, the value `+0` is returned;\n- If \\|arg\\| \\> 1, a domain error occurs and NaN is returned;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    printf(\"acos(-1) = %f\\n\", acos(-1));\n    printf(\"acos(0.0) = %f 2*acos(0.0) = %f\\n\", acos(0), 2 * acos(0));\n    printf(\"acos(0.5) = %f 3*acos(0.5) = %f\\n\", acos(0.5), 3 * acos(0.5));\n    printf(\"acos(1) = %f\\n\", acos(1));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"acos(1.1) = %f\\n\", acos(1.1));\n    if (errno == EDOM)\n        perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nacos(-1) = 3.141593\nacos(0.0) = 1.570796 2*acos(0.0) = 3.141593\nacos(0.5) = 1.047198 3*acos(0.5) = 3.141593\nacos(1) = 0.000000\nacos(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.1 The acos functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.1 The acos functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.1 The acos functions (p: 173)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.1 The acos functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.1 The acos functions (p: 238)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.1 The acos functions (p: 518)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.1 The acos functions (p: 218)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.1 The acos functions (p: 455)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.1 The acos function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/acos](https://en.cppreference.com/w/c/numeric/math/acos)"
- name: acosf
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# acos, acosf, acosl\n\n[TABLE]\n\n1-6) Computes the principal value of the arc cosine of `arg`.\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`acosl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`acos`) is called. Otherwise, (1) (`acosf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`cacosf`](../complex/cacos \"c/numeric/complex/cacos\"), [`cacos`](../complex/cacos \"c/numeric/complex/cacos\"), [`cacosl`](../complex/cacos \"c/numeric/complex/cacos\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating-point value |\n\n### Return value\n\nIf no errors occur, the arc cosine of `arg` (arccos(arg)) in the range \\[0 ; π\\], is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is outside the range `[-1.0; 1.0]`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- If the argument is +1, the value `+0` is returned;\n- If \\|arg\\| \\> 1, a domain error occurs and NaN is returned;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    printf(\"acos(-1) = %f\\n\", acos(-1));\n    printf(\"acos(0.0) = %f 2*acos(0.0) = %f\\n\", acos(0), 2 * acos(0));\n    printf(\"acos(0.5) = %f 3*acos(0.5) = %f\\n\", acos(0.5), 3 * acos(0.5));\n    printf(\"acos(1) = %f\\n\", acos(1));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"acos(1.1) = %f\\n\", acos(1.1));\n    if (errno == EDOM)\n        perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nacos(-1) = 3.141593\nacos(0.0) = 1.570796 2*acos(0.0) = 3.141593\nacos(0.5) = 1.047198 3*acos(0.5) = 3.141593\nacos(1) = 0.000000\nacos(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.1 The acos functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.1 The acos functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.1 The acos functions (p: 173)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.1 The acos functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.1 The acos functions (p: 238)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.1 The acos functions (p: 518)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.1 The acos functions (p: 218)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.1 The acos functions (p: 455)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.1 The acos function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/acos](https://en.cppreference.com/w/c/numeric/math/acos)"
- name: acosh
  summary: If no errors occur, the inverse hyperbolic cosine of arg (cosh-1(arg), or arcosh(arg)) on the interval [0, +∞], is returned
  description: "# acosh, acoshf, acoshl\n\n[TABLE]\n\n1-3) Computes the inverse hyperbolic cosine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `acoshl` is called. Otherwise, if the argument has integer type or the type `double`, `acosh` is called. Otherwise, `acoshf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`cacoshf`](http://en.cppreference.com/w/c/numeric/complex/cacosh), [`cacosh`](http://en.cppreference.com/w/c/numeric/complex/cacosh), [`cacoshl`](http://en.cppreference.com/w/c/numeric/complex/cacosh)).\n\n### Parameters\n\n|     |     |                                                                   |\n|-----|-----|-------------------------------------------------------------------|\n| arg | \\-  | floating point value representing the area of a hyperbolic sector |\n\n### Return value\n\nIf no errors occur, the inverse hyperbolic cosine of `arg` (cosh⁻¹(arg), or arcosh(arg)) on the interval \\[0, +∞\\], is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the argument is less than 1, a domain error occurs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is less than 1, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised an NaN is returned\n- if the argument is 1, +0 is returned\n- if the argument is +∞, +∞ is returned\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nAlthough the C standard names this function \"arc hyperbolic cosine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic cosine\" (used by POSIX) or \"area hyperbolic cosine\".\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"acosh(1) = %f\\nacosh(10) = %f\\n\", acosh(1), acosh(10));\n    printf(\"acosh(DBL_MAX) = %f\\nacosh(Inf) = %f\\n\", acosh(DBL_MAX), acosh(INFINITY));\n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"acosh(0.5) = %f\\n\", acosh(0.5));\n    if (errno == EDOM)\n        perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nacosh(1) = 0.000000\nacosh(10) = 2.993223\nacosh(DBL_MAX) = 710.475860\nacosh(Inf) = inf\nacosh(0.5) = -nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.5.1 The acosh functions (p: TBD)\n  - 7.27 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.2.1 The acosh functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.1 The acosh functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.2.1 The acosh functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.1 The acosh functions (p: 240)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.1 The acosh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.1 The acosh functions (p: 221)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.1 The acosh functions (p: 457)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|     |                                                                                                                                                       |\n|-----|-------------------------------------------------------------------------------------------------------------------------------------------------------|\n|     | [Weisstein, Eric W. \"Inverse Hyperbolic Cosine.\"](http://mathworld.wolfram.com/InverseHyperbolicCosine.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/acosh](https://en.cppreference.com/w/c/numeric/math/acosh)"
- name: acoshf
  summary: If no errors occur, the inverse hyperbolic cosine of arg (cosh-1(arg), or arcosh(arg)) on the interval [0, +∞], is returned
  description: "# acosh, acoshf, acoshl\n\n[TABLE]\n\n1-3) Computes the inverse hyperbolic cosine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `acoshl` is called. Otherwise, if the argument has integer type or the type `double`, `acosh` is called. Otherwise, `acoshf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`cacoshf`](http://en.cppreference.com/w/c/numeric/complex/cacosh), [`cacosh`](http://en.cppreference.com/w/c/numeric/complex/cacosh), [`cacoshl`](http://en.cppreference.com/w/c/numeric/complex/cacosh)).\n\n### Parameters\n\n|     |     |                                                                   |\n|-----|-----|-------------------------------------------------------------------|\n| arg | \\-  | floating point value representing the area of a hyperbolic sector |\n\n### Return value\n\nIf no errors occur, the inverse hyperbolic cosine of `arg` (cosh⁻¹(arg), or arcosh(arg)) on the interval \\[0, +∞\\], is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the argument is less than 1, a domain error occurs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is less than 1, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised an NaN is returned\n- if the argument is 1, +0 is returned\n- if the argument is +∞, +∞ is returned\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nAlthough the C standard names this function \"arc hyperbolic cosine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic cosine\" (used by POSIX) or \"area hyperbolic cosine\".\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"acosh(1) = %f\\nacosh(10) = %f\\n\", acosh(1), acosh(10));\n    printf(\"acosh(DBL_MAX) = %f\\nacosh(Inf) = %f\\n\", acosh(DBL_MAX), acosh(INFINITY));\n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"acosh(0.5) = %f\\n\", acosh(0.5));\n    if (errno == EDOM)\n        perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nacosh(1) = 0.000000\nacosh(10) = 2.993223\nacosh(DBL_MAX) = 710.475860\nacosh(Inf) = inf\nacosh(0.5) = -nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.5.1 The acosh functions (p: TBD)\n  - 7.27 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.2.1 The acosh functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.1 The acosh functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.2.1 The acosh functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.1 The acosh functions (p: 240)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.1 The acosh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.1 The acosh functions (p: 221)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.1 The acosh functions (p: 457)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|     |                                                                                                                                                       |\n|-----|-------------------------------------------------------------------------------------------------------------------------------------------------------|\n|     | [Weisstein, Eric W. \"Inverse Hyperbolic Cosine.\"](http://mathworld.wolfram.com/InverseHyperbolicCosine.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/acosh](https://en.cppreference.com/w/c/numeric/math/acosh)"
- name: acoshl
  summary: If no errors occur, the inverse hyperbolic cosine of arg (cosh-1(arg), or arcosh(arg)) on the interval [0, +∞], is returned
  description: "# acosh, acoshf, acoshl\n\n[TABLE]\n\n1-3) Computes the inverse hyperbolic cosine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `acoshl` is called. Otherwise, if the argument has integer type or the type `double`, `acosh` is called. Otherwise, `acoshf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`cacoshf`](http://en.cppreference.com/w/c/numeric/complex/cacosh), [`cacosh`](http://en.cppreference.com/w/c/numeric/complex/cacosh), [`cacoshl`](http://en.cppreference.com/w/c/numeric/complex/cacosh)).\n\n### Parameters\n\n|     |     |                                                                   |\n|-----|-----|-------------------------------------------------------------------|\n| arg | \\-  | floating point value representing the area of a hyperbolic sector |\n\n### Return value\n\nIf no errors occur, the inverse hyperbolic cosine of `arg` (cosh⁻¹(arg), or arcosh(arg)) on the interval \\[0, +∞\\], is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the argument is less than 1, a domain error occurs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is less than 1, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised an NaN is returned\n- if the argument is 1, +0 is returned\n- if the argument is +∞, +∞ is returned\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nAlthough the C standard names this function \"arc hyperbolic cosine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic cosine\" (used by POSIX) or \"area hyperbolic cosine\".\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"acosh(1) = %f\\nacosh(10) = %f\\n\", acosh(1), acosh(10));\n    printf(\"acosh(DBL_MAX) = %f\\nacosh(Inf) = %f\\n\", acosh(DBL_MAX), acosh(INFINITY));\n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"acosh(0.5) = %f\\n\", acosh(0.5));\n    if (errno == EDOM)\n        perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nacosh(1) = 0.000000\nacosh(10) = 2.993223\nacosh(DBL_MAX) = 710.475860\nacosh(Inf) = inf\nacosh(0.5) = -nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.5.1 The acosh functions (p: TBD)\n  - 7.27 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.2.1 The acosh functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.1 The acosh functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.2.1 The acosh functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.1 The acosh functions (p: 240)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.1 The acosh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.1 The acosh functions (p: 221)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.1 The acosh functions (p: 457)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|     |                                                                                                                                                       |\n|-----|-------------------------------------------------------------------------------------------------------------------------------------------------------|\n|     | [Weisstein, Eric W. \"Inverse Hyperbolic Cosine.\"](http://mathworld.wolfram.com/InverseHyperbolicCosine.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/acosh](https://en.cppreference.com/w/c/numeric/math/acosh)"
- name: acosl
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# acos, acosf, acosl\n\n[TABLE]\n\n1-6) Computes the principal value of the arc cosine of `arg`.\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`acosl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`acos`) is called. Otherwise, (1) (`acosf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`cacosf`](../complex/cacos \"c/numeric/complex/cacos\"), [`cacos`](../complex/cacos \"c/numeric/complex/cacos\"), [`cacosl`](../complex/cacos \"c/numeric/complex/cacos\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating-point value |\n\n### Return value\n\nIf no errors occur, the arc cosine of `arg` (arccos(arg)) in the range \\[0 ; π\\], is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is outside the range `[-1.0; 1.0]`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- If the argument is +1, the value `+0` is returned;\n- If \\|arg\\| \\> 1, a domain error occurs and NaN is returned;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    printf(\"acos(-1) = %f\\n\", acos(-1));\n    printf(\"acos(0.0) = %f 2*acos(0.0) = %f\\n\", acos(0), 2 * acos(0));\n    printf(\"acos(0.5) = %f 3*acos(0.5) = %f\\n\", acos(0.5), 3 * acos(0.5));\n    printf(\"acos(1) = %f\\n\", acos(1));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"acos(1.1) = %f\\n\", acos(1.1));\n    if (errno == EDOM)\n        perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nacos(-1) = 3.141593\nacos(0.0) = 1.570796 2*acos(0.0) = 3.141593\nacos(0.5) = 1.047198 3*acos(0.5) = 3.141593\nacos(1) = 0.000000\nacos(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.1 The acos functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.1 The acos functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.1 The acos functions (p: 173)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.1 The acos functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.1 The acos functions (p: 238)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.1 The acos functions (p: 518)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.1 The acos functions (p: 218)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.1 The acos functions (p: 455)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.1 The acos function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/acos](https://en.cppreference.com/w/c/numeric/math/acos)"
- name: Algorithms
  summary: ''
  description: "# Algorithms\n\n[TABLE]\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.5 Searching and sorting utilities (p: 354-356)\n  - K.3.6.3 Searching and sorting utilities (p: 607-609)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.5 Searching and sorting utilities (p: 318-319)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.5 Searching and sorting utilities\n\n### See also\n\n|                                                                                                         |     |\n|---------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/algorithm \"cpp/algorithm\") for Algorithms library |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/algorithm](https://en.cppreference.com/w/c/algorithm)"
- name: alignas
  summary: ''
  description: "# C keywords: alignas (since C23)\n\n### Usage\n\n- [`alignas`](../language/alignas \"c/language/alignas\") alignment specifier. (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/alignas](https://en.cppreference.com/w/c/keyword/alignas)"
- name: alignas (since C23)
  summary: Appears in the declaration syntax as one of the type specifiers to modify the alignment requirement of the object being declared
  description: "# \\_Alignas (since C11), alignas (since C23)\n\nAppears in the [declaration](declarations \"c/language/declarations\") syntax as one of the type specifiers to modify the [alignment requirement](object#Alignment \"c/language/object\") of the object being declared.\n\n### Syntax\n\n|                               |       |             |\n|-------------------------------|-------|-------------|\n| `_Alignas` `(` expression `)` | \\(1\\) | (since C11) |\n| `alignas` `(` expression `)`  | \\(2\\) | (since C23) |\n| `_Alignas` `(` type `)`       | \\(3\\) | (since C11) |\n| `alignas` `(` type `)`        | \\(4\\) | (since C23) |\n\n|            |     |                                                                                                                                                                          |\n|------------|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| expression | \\-  | any [integer constant expression](constant_expression \"c/language/constant expression\") whose value is a valid [alignment](object#Alignment \"c/language/object\") or zero |\n| type       | \\-  | any [type name](type#Type_names \"c/language/type\")                                                                                                                       |\n\n|                                                                                                                                                              |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The keyword `_Alignas` is also available as convenience macro [`alignas`](../types \"c/types\"), available in the header [`<stdalign.h>`](../types \"c/types\"). | (until C23) |\n\n### Explanation\n\nThe `_Alignas`(until C23)`alignas`(since C23) specifier can only be used when declaring objects that are not [bit-fields](bit_field \"c/language/bit field\"), and don't have the [register](storage_duration \"c/language/storage duration\") storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.\n\nWhen used in a declaration, the declared object will have its [alignment requirement](object#Alignment \"c/language/object\") set to\n\n1,2) the result of the expression, unless it is zero\n\n3,4) the alignment requirement of type, that is, to `_Alignof(type)`(until C23)`alignof(type)`(since C23)\n\nexcept when this would weaken the alignment the type would have had naturally.\n\nIf expression evaluates to zero, this specifier has no effect.\n\nWhen multiple `_Alignas`(until C23)`alignas`(since C23) specifiers appear in the same declaration, the strictest one is used.\n\n`_Alignas`(until C23)`alignas`(since C23) specifier only needs to appear on the [definition](declarations#Definitions \"c/language/declarations\") of an object, but if any declaration uses `_Alignas`(until C23)`alignas`(since C23), it must specify the same alignment as the `_Alignas`(until C23)`alignas`(since C23) on the definition. The behavior is undefined if different translation units specify different alignments for the same object.\n\n### Notes\n\nIn C++, the `alignas` specifier may also be applied to the declarations of class/struct/union types and enumerations. This is not supported in C, but the alignment of a struct type can be controlled by using `_Alignas`(until C23)`alignas`(since C23) in a member declaration.\n\n### Keywords\n\n[`alignas`](../keyword/alignas \"c/keyword/alignas\"), [`_Alignas`](../keyword/_alignas \"c/keyword/ Alignas\")\n\n### Example\n\n```\n#include <stdalign.h>\n#include <stdio.h>\n \n// every object of type struct sse_t will be aligned to 16-byte boundary\n// (note: needs support for DR 444)\nstruct sse_t\n{\n    alignas(16) float sse_data[4];\n};\n \n// every object of type struct data will be aligned to 128-byte boundary\nstruct data\n{\n    char x;\n    alignas(128) char cacheline[128]; // over-aligned array of char,\n                                      // not array of over-aligned chars\n};\n \nint main(void)\n{\n    printf(\"sizeof(data) = %zu (1 byte + 127 bytes padding + 128-byte array)\\n\",\n           sizeof(struct data));\n \n    printf(\"alignment of sse_t is %zu\\n\", alignof(struct sse_t));\n \n    alignas(2048) struct data d; // this instance of data is aligned even stricter\n    (void)d; // suppresses \"maybe unused\" warning\n}\n```\n\nOutput:\n\n```\nsizeof(data) = 256 (1 byte + 127 bytes padding + 128-byte array)\nalignment of sse_t is 16\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                  | Correct behavior |\n|-----------------------------------------------------------------------------|------------|--------------------------------------------------------|------------------|\n| [DR 444](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_444) | C11        | `_Alignas` was not allowed in struct and union members | allowed          |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.5 Alignment specifier (p: TBD)\n  - 6.2.8 Alignment of objects (p: TBD)\n  - 7.15 Alignment \\<stdalign.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.5 Alignment specifier (p: 92)\n  - 6.2.8 Alignment of objects (p: 36-37)\n  - 7.15 Alignment \\<stdalign.h\\> (p: 196)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.5 Alignment specifier (p: 127-128)\n  - 6.2.8 Alignment of objects (p: 48-49)\n  - 7.15 Alignment \\<stdalign.h\\> (p: 268)\n\n### See also\n\n|                                                                                                                        |     |\n|------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/alignas \"cpp/language/alignas\") for `alignas` specifier |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/alignas](https://en.cppreference.com/w/c/language/alignas)"
- name: alignas (since C23)
  summary: Appears in the declaration syntax as one of the type specifiers to modify the alignment requirement of the object being declared
  description: "# \\_Alignas (since C11), alignas (since C23)\n\nAppears in the [declaration](declarations \"c/language/declarations\") syntax as one of the type specifiers to modify the [alignment requirement](object#Alignment \"c/language/object\") of the object being declared.\n\n### Syntax\n\n|                               |       |             |\n|-------------------------------|-------|-------------|\n| `_Alignas` `(` expression `)` | \\(1\\) | (since C11) |\n| `alignas` `(` expression `)`  | \\(2\\) | (since C23) |\n| `_Alignas` `(` type `)`       | \\(3\\) | (since C11) |\n| `alignas` `(` type `)`        | \\(4\\) | (since C23) |\n\n|            |     |                                                                                                                                                                          |\n|------------|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| expression | \\-  | any [integer constant expression](constant_expression \"c/language/constant expression\") whose value is a valid [alignment](object#Alignment \"c/language/object\") or zero |\n| type       | \\-  | any [type name](type#Type_names \"c/language/type\")                                                                                                                       |\n\n|                                                                                                                                                              |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The keyword `_Alignas` is also available as convenience macro [`alignas`](../types \"c/types\"), available in the header [`<stdalign.h>`](../types \"c/types\"). | (until C23) |\n\n### Explanation\n\nThe `_Alignas`(until C23)`alignas`(since C23) specifier can only be used when declaring objects that are not [bit-fields](bit_field \"c/language/bit field\"), and don't have the [register](storage_duration \"c/language/storage duration\") storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.\n\nWhen used in a declaration, the declared object will have its [alignment requirement](object#Alignment \"c/language/object\") set to\n\n1,2) the result of the expression, unless it is zero\n\n3,4) the alignment requirement of type, that is, to `_Alignof(type)`(until C23)`alignof(type)`(since C23)\n\nexcept when this would weaken the alignment the type would have had naturally.\n\nIf expression evaluates to zero, this specifier has no effect.\n\nWhen multiple `_Alignas`(until C23)`alignas`(since C23) specifiers appear in the same declaration, the strictest one is used.\n\n`_Alignas`(until C23)`alignas`(since C23) specifier only needs to appear on the [definition](declarations#Definitions \"c/language/declarations\") of an object, but if any declaration uses `_Alignas`(until C23)`alignas`(since C23), it must specify the same alignment as the `_Alignas`(until C23)`alignas`(since C23) on the definition. The behavior is undefined if different translation units specify different alignments for the same object.\n\n### Notes\n\nIn C++, the `alignas` specifier may also be applied to the declarations of class/struct/union types and enumerations. This is not supported in C, but the alignment of a struct type can be controlled by using `_Alignas`(until C23)`alignas`(since C23) in a member declaration.\n\n### Keywords\n\n[`alignas`](../keyword/alignas \"c/keyword/alignas\"), [`_Alignas`](../keyword/_alignas \"c/keyword/ Alignas\")\n\n### Example\n\n```\n#include <stdalign.h>\n#include <stdio.h>\n \n// every object of type struct sse_t will be aligned to 16-byte boundary\n// (note: needs support for DR 444)\nstruct sse_t\n{\n    alignas(16) float sse_data[4];\n};\n \n// every object of type struct data will be aligned to 128-byte boundary\nstruct data\n{\n    char x;\n    alignas(128) char cacheline[128]; // over-aligned array of char,\n                                      // not array of over-aligned chars\n};\n \nint main(void)\n{\n    printf(\"sizeof(data) = %zu (1 byte + 127 bytes padding + 128-byte array)\\n\",\n           sizeof(struct data));\n \n    printf(\"alignment of sse_t is %zu\\n\", alignof(struct sse_t));\n \n    alignas(2048) struct data d; // this instance of data is aligned even stricter\n    (void)d; // suppresses \"maybe unused\" warning\n}\n```\n\nOutput:\n\n```\nsizeof(data) = 256 (1 byte + 127 bytes padding + 128-byte array)\nalignment of sse_t is 16\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                  | Correct behavior |\n|-----------------------------------------------------------------------------|------------|--------------------------------------------------------|------------------|\n| [DR 444](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_444) | C11        | `_Alignas` was not allowed in struct and union members | allowed          |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.5 Alignment specifier (p: TBD)\n  - 6.2.8 Alignment of objects (p: TBD)\n  - 7.15 Alignment \\<stdalign.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.5 Alignment specifier (p: 92)\n  - 6.2.8 Alignment of objects (p: 36-37)\n  - 7.15 Alignment \\<stdalign.h\\> (p: 196)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.5 Alignment specifier (p: 127-128)\n  - 6.2.8 Alignment of objects (p: 48-49)\n  - 7.15 Alignment \\<stdalign.h\\> (p: 268)\n\n### See also\n\n|                                                                                                                        |     |\n|------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/alignas \"cpp/language/alignas\") for `alignas` specifier |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/\\_Alignas](https://en.cppreference.com/w/c/language/_Alignas)"
- name: aligned_alloc
  summary: Allocate size bytes of uninitialized storage whose alignment is specified by alignment
  description: "# aligned_alloc\n\n[TABLE]\n\nAllocate `size` bytes of uninitialized storage whose alignment is specified by `alignment`. The `size` parameter must be an integral multiple of `alignment`.\n\n`aligned_alloc` is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.\n\nA previous call to [`free`](free \"c/memory/free\") or [`realloc`](realloc \"c/memory/realloc\") that deallocates a region of memory *synchronizes-with* a call to `aligned_alloc` that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by `aligned_alloc`. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.\n\n### Parameters\n\n|           |     |                                                                                     |\n|-----------|-----|-------------------------------------------------------------------------------------|\n| alignment | \\-  | specifies the alignment. Must be a valid alignment supported by the implementation. |\n| size      | \\-  | number of bytes to allocate. An integral multiple of `alignment`                    |\n\n### Return value\n\nOn success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with [`free`](free \"c/memory/free\") or [`realloc`](realloc \"c/memory/realloc\").\n\nOn failure, returns a null pointer.\n\n### Notes\n\nPassing a `size` which is not an integral multiple of `alignment` or an `alignment` which is not valid or not supported by the implementation causes the function to fail and return a null pointer (C11, as published, specified undefined behavior in this case, this was corrected by [DR460](https://open-std.org/JTC1/SC22/WG14/www/docs/summary.htm#dr_460)). Removal of size restrictions to make it possible to allocate small objects at restrictive alignment boundaries (similar to [`alignas`](../language/_alignas \"c/language/ Alignas\")) has been proposed by [N2072](https://open-std.org/JTC1/SC22/WG14/www/docs/n2072.htm).\n\nAs an example of the \"supported by the implementation\" requirement, POSIX function [`posix_memalign`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html) accepts any `alignment` that is a power of two and a multiple of `sizeof(void *)`, and POSIX-based implementations of `aligned_alloc` inherit this requirements.\n\nFundamental alignments are always supported. If `alignment` is a power of two and not greater than `_Alignof``(`[`max_align_t`](http://en.cppreference.com/w/c/types/max_align_t)`)`, `aligned_alloc` may simply call [`malloc`](malloc \"c/memory/malloc\").\n\nRegular [`malloc`](malloc \"c/memory/malloc\") aligns memory suitable for any object type with a fundamental alignment. The `aligned_alloc` is useful for over-aligned allocations, such as to [SSE](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions \"enwiki:Streaming SIMD Extensions\"), cache line, or [VM page](https://en.wikipedia.org/wiki/Page_(computer_memory)#Multiple_page_sizes \"enwiki:Page (computer memory)\") boundary.\n\nThis function is not supported in Microsoft C Runtime library because its implementation of `std::free` is [unable to handle aligned allocations](https://learn.microsoft.com/en-us/cpp/standard-library/cstdlib#remarks-6) of any kind. Instead, MS CRT provides [`_aligned_malloc`](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/aligned-malloc) (to be freed with [`_aligned_free`](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/aligned-free)).\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int *p1 = malloc(10*sizeof *p1);\n    printf(\"default-aligned addr:   %p\\n\", (void*)p1);\n    free(p1);\n \n    int *p2 = aligned_alloc(1024, 1024*sizeof *p2);\n    printf(\"1024-byte aligned addr: %p\\n\", (void*)p2);\n    free(p2);\n}\n```\n\nPossible output:\n\n```\ndefault-aligned addr:   0x1e40c20\n1024-byte aligned addr: 0x1e41000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.22.3.1 The aligned_alloc function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.3.1 The aligned_alloc function (p: 253)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.3.1 The aligned_alloc function (p: 347-348)\n\n### See also\n\n|                                                                                                                                |     |\n|--------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/memory/c/aligned_alloc \"cpp/memory/c/aligned alloc\") for `aligned_alloc` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/memory/aligned_alloc](https://en.cppreference.com/w/c/memory/aligned_alloc)"
- name: alignof
  summary: ''
  description: "# C keywords: alignof (since C23)\n\n### Usage\n\n- [`alignof` operator](../language/alignof \"c/language/alignof\") (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/alignof](https://en.cppreference.com/w/c/keyword/alignof)"
- name: Alternative operators and tokens
  summary: C source code may be written in any 8-bit character set that includes the ISO 646:1983 invariant character set, even non-ASCII ones
  description: "# Alternative operators and tokens\n\nC source code may be written in any 8-bit character set that includes the [ISO 646:1983](https://en.wikipedia.org/wiki/ISO_646 \"enwiki:ISO 646\") invariant character set, even non-ASCII ones. However, several C operators and punctuators require characters that are outside of the ISO 646 codeset: `{, }, [, ], #, \\, ^, |, ~`. To be able to use character encodings where some or all of these symbols do not exist (such as the German [DIN 66003](https://en.wikipedia.org/wiki/DIN_66003 \"enwiki:DIN 66003\")), there are two possibilities: alternative spellings of operators that use these characters or special combinations of two or three ISO 646 compatible characters that are interpreted as if they were a single non-ISO 646 character.\n\n## Operator macros(C95)\n\nThere are alternative spellings for the operators that use non-ISO646 characters, defined in **`<iso646.h>`** as macros:\n\n[TABLE]\n\nThe characters `&` and `!` are invariant under ISO-646, but alternatives are provided for the operators that use these characters anyway to accommodate even more restrictive historical charsets.\n\nThere is no alternative spelling (such as `eq`) for the equality operator `==` because the character `=` was present in all supported charsets.\n\n## Alternative tokens(C95)\n\nThe following alternative tokens are part of the core language, and, in all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the [stringification operator](../preprocessor/replace \"c/preprocessor/replace\") can make the spelling visible). The two-letter alternative tokens are sometimes called \"digraphs\" (even though it is four letters long `%:%:` is also considered a digraph).\n\n| Primary | Alternative |\n|---------|-------------|\n| `{`     | `<%`        |\n| }       | `%>`        |\n| `[`     | `<:`        |\n| `]`     | `:>`        |\n| `#`     | `%:`        |\n| `##`    | `%:%:`      |\n\n## Trigraphs (removed in C23)\n\nThe following three-character groups (trigraphs) are [parsed before comments and string literals are recognized](translation_phases \"c/language/translation phases\"), and each appearance of a trigraph is replaced by the corresponding primary character:\n\n| Primary | Trigraph |\n|---------|----------|\n| `{`     | `??<`    |\n| }       | `??>`    |\n| `[`     | `??(`    |\n| `]`     | `??)`    |\n| `#`     | `??=`    |\n| `\\`     | `??/`    |\n| `^`     | `??'`    |\n| `|`     | `??!`    |\n| `~`     | `??-`    |\n\nBecause trigraphs are processed early, a comment such as `// Will the next line be executed?????/` will effectively comment out the following line, and the string literal such as `\"What's going on??!\"` is parsed as `\"What's going on|\"`.\n\n### Example\n\nDemonstrates alternative operator spellings from the **`<iso646.h>`** as well as use of digraphs and trigraphs. If command line arguments contain spaces they should be wrapped in the quotation marks, e.g., `\"Third World!\"`.\n\n```\n%:include <stdio.h>\n%:include <stdlib.h>\n??=include <iso646.h>\n \nint main(int argc, char** argv)\n??<\n    if (argc > 1 and argv<:1:> not_eq NULL)\n    <%\n       printf(\"Hello %s??/n\", argv<:1:>);\n    %>\n    else\n    <%\n       printf(\"Hello %s??/n\", argc? argv??(42??'42??) : __FILE__);\n    %>\n \n    return EXIT_SUCCESS;\n??>\n```\n\nPossible output:\n\n```\nHello ./a.out\n```\n\n### See also\n\n|                                                                                                                                                                   |     |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/operator_alternative \"cpp/language/operator alternative\") for Alternative operator representations |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/operator_alternative](https://en.cppreference.com/w/c/language/operator_alternative)"
- name: Analyzability
  summary: This optional extension to the C language limits the potential results of executing some forms of undefined behavior, which improves the effectiveness of static analysis of such programs
  description: "# Analyzability\n\nThis optional extension to the C language limits the potential results of executing some forms of undefined behavior, which improves the effectiveness of static analysis of such programs. Analyzability is only guaranteed to be enabled if the [predefined macro constant](../preprocessor/replace \"c/preprocessor/replace\") `__STDC_ANALYZABLE__`(C11) is defined by the compiler.\n\nIf the compiler supports analyzability, any language or library construct whose behavior is undefined is further classified between *critical* and *bounded* undefined behavior, and the behavior of all bounded UB cases is limited as specified below.\n\n### Critical undefined behavior\n\nCritical UB is undefined behavior that might perform a memory write or a volatile memory read out of bounds of any object. A program that has critical undefined behavior may be susceptible to security exploits.\n\nOnly the following undefined behaviors are critical:\n\n- access to an object outside of its [lifetime](lifetime \"c/language/lifetime\") (e.g. through a dangling pointer)\n- write to an object whose declarations are not [compatible](type#Compatible_types \"c/language/type\")\n- function call through a function pointer whose type is not [compatible](type#Compatible_types \"c/language/type\") with the type of the function it points to\n- [lvalue expression](value_category \"c/language/value category\") is evaluated, but does not designate an object\n- attempted modification of a [string literal](string_literal \"c/language/string literal\")\n- [dereferencing](operator_member_access \"c/language/operator member access\") an invalid (null, indeterminate, etc) or [past-the-end](operator_arithmetic \"c/language/operator arithmetic\") pointer\n- modification of a [const object](const \"c/language/const\") through a non-const pointer\n- call to a standard library function or macro with an invalid argument\n- call to a variadic standard library function with unexpected argument type (e.g. call to [`printf`](../io/fprintf \"c/io/fprintf\") with an argument of the type that doesn't match its conversion specifier)\n- [`longjmp`](../program/longjmp \"c/program/longjmp\") where there is no [`setjmp`](../program/setjmp \"c/program/setjmp\") up the calling scope, across threads, or from within the scope of a VM type.\n- any use of the pointer that was deallocated by [`free`](../memory/free \"c/memory/free\") or [`realloc`](../memory/realloc \"c/memory/realloc\")\n- any [string](../string/byte \"c/string/byte\") or [wide string](../string/wide \"c/string/wide\") library function accesses an array out of bounds\n\n### Bounded undefined behavior\n\nBounded UB is undefined behavior that cannot perform an illegal memory write, although it may trap and may produce or store indeterminate values.\n\n- All undefined behavior not listed as critical is bounded, including\n  - multithreaded data races\n  - use of a [indeterminate values](initialization \"c/language/initialization\") with automatic storage duration\n  - [strict aliasing](object#Strict_aliasing \"c/language/object\") violations\n  - [misaligned](object#alignment \"c/language/object\") object access\n  - signed integer overflow\n  - [unsequenced side-effects](eval_order \"c/language/eval order\") modify the same scalar or modify and read the same scalar\n  - floating-to-integer or pointer-to-integer [conversion](conversion \"c/language/conversion\") overflow\n  - [bitwise shift](operator_arithmetic \"c/language/operator arithmetic\") by a negative or too large bit count\n  - [integer division](operator_arithmetic \"c/language/operator arithmetic\") by zero\n  - use of a void expression\n  - direct [assignment](operator_assignment \"c/language/operator assignment\") or [`memcpy`](../string/byte/memcpy \"c/string/byte/memcpy\") of inexactly-overlapped objects\n  - [restrict](restrict \"c/language/restrict\") violations\n  - etc.. ALL undefined behavior that's not in the critical list.\n\n### Notes\n\nBounded undefined behavior disables certain optimizations: compilation with analyzability enabled preserves source-code causality, which [may be violated](as_if \"c/language/as if\") by undefined behavior otherwise.\n\nAnalyzability extension permits, as a form of implementation-defined behavior, for the [runtime constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") to be invoked when a trap occurs.\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.8.3/1 Conditional feature macros (p: 177)\n  - Annex L Analyzability (p: 652-653)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/analyzability](https://en.cppreference.com/w/c/language/analyzability)"
- name: Arithmetic operators
  summary: Arithmetic operators apply standard mathematical operations to their operands
  description: "# Arithmetic operators\n\nArithmetic operators apply standard mathematical operations to their operands.\n\n| Operator | Operator name       | Example  | Result                                  |\n|----------|---------------------|----------|-----------------------------------------|\n| `+`      | unary plus          | `+a`     | the value of **a** after promotions     |\n| `-`      | unary minus         | `-a`     | the negative of **a**                   |\n| `+`      | addition            | `a + b`  | the addition of **a** and **b**         |\n| `-`      | subtraction         | `a - b`  | the subtraction of **b** from **a**     |\n| `*`      | product             | `a * b`  | the product of **a** and **b**          |\n| `/`      | division            | `a / b`  | the division of **a** by **b**          |\n| `%`      | remainder           | `a % b`  | the remainder of **a** divided by **b** |\n| `~`      | bitwise NOT         | `~a`     | the bitwise NOT of **a**                |\n| `&`      | bitwise AND         | `a & b`  | the bitwise AND of **a** and **b**      |\n| `|`      | bitwise OR          | `a | b`  | the bitwise OR of **a** and **b**       |\n| `^`      | bitwise XOR         | `a ^ b`  | the bitwise XOR of **a** and **b**      |\n| `<<`     | bitwise left shift  | `a << b` | **a** left shifted by **b**             |\n| `>>`     | bitwise right shift | `a >> b` | **a** right shifted by **b**            |\n\n### Overflows\n\nUnsigned integer arithmetic is always performed modulo 2^(n) where n is the number of bits in that particular integer. E.g. for `unsigned int`, adding one to [`UINT_MAX`](../types/limits \"c/types/limits\") gives `​0​`, and subtracting one from `​0​` gives [`UINT_MAX`](../types/limits \"c/types/limits\").\n\nWhen signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. `-ftrapv` in GCC and Clang), or may be completely [optimized out by the compiler](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html).\n\n#### Floating-point environment\n\nIf [` #pragma STDC FENV_ACCESS`](../preprocessor/impl \"c/preprocessor/impl\") is set to `ON`, all floating-point arithmetic operators obey the current floating-point [rounding direction](../numeric/fenv/fe_round \"c/numeric/fenv/FE round\") and report floating-point arithmetic errors as specified in [`math_errhandling`](../numeric/math/math_errhandling \"c/numeric/math/math errhandling\") unless part of a [static initializer](initialization \"c/language/initialization\") (in which case floating-point exceptions are not raised and the rounding mode is to nearest)\n\n#### Floating-point contraction\n\nUnless [` #pragma STDC FP_CONTRACT`](../preprocessor/impl \"c/preprocessor/impl\") is set to `OFF`, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of `(x*y) + z` with a single fused multiply-add CPU instruction or optimization of `a = x*x*x*x;` as `tmp = x*x; a = tmp*tmp`.\n\nUnrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see [`FLT_EVAL_METHOD`](../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\")\n\n### Unary arithmetic\n\nThe unary arithmetic operator expressions have the form\n\n|                |       |     |\n|----------------|-------|-----|\n| `+` expression | \\(1\\) |     |\n| `-` expression | \\(2\\) |     |\n\n1) unary plus (promotion)\n\n2) unary minus (negation)\n\nwhere\n\n|            |     |                                                                                     |\n|------------|-----|-------------------------------------------------------------------------------------|\n| expression | \\-  | expression of any [arithmetic type](arithmetic_types \"c/language/arithmetic types\") |\n\nBoth unary plus and unary minus first apply [integral promotions](conversion \"c/language/conversion\") to their operand, and then\n\n- unary plus returns the value after promotion\n- unary minus returns the negative of the value after promotion (except that the negative of a NaN is another NaN)\n\nThe type of the expression is the type after promotion, and the [value category](value_category \"c/language/value category\") is non-lvalue.\n\n#### Notes\n\nThe unary minus invokes undefined behavior due to signed integer overflow when applied to [`INT_MIN`](../types/limits \"c/types/limits\"), [`LONG_MIN`](../types/limits \"c/types/limits\"), or [`LLONG_MIN`](../types/limits \"c/types/limits\"), on typical (2's complement) platforms.\n\nIn C++, unary operator `+` can also be used with other built-in types such as arrays and functions, not so in C.\n\n```\n#include <stdio.h>\n#include <complex.h>\n#include <limits.h>\n \nint main(void)\n{\n    char c = 'a';\n    printf(\"sizeof char: %zu sizeof int: %zu\\n\", sizeof c, sizeof +c);\n \n    printf(\"-1, where 1 is signed: %d\\n\", -1);\n \n    // Defined behavior since arithmetic is performed for unsigned integer.\n    // Hence, the calculation is (-1) modulo (2 raised to n) = UINT_MAX, where n is\n    // the number of bits of unsigned int. If unsigned int is 32-bit long, then this\n    // gives (-1) modulo (2 raised to 32) = 4294967295\n    printf(\"-1, where 1 is unsigned: %u\\n\", -1u); \n \n    // Undefined behavior because the mathematical value of -INT_MIN = INT_MAX + 1\n    // (i.e. 1 more than the maximum possible value for signed int)\n    //\n    // printf(\"%d\\n\", -INT_MIN);\n \n    // Undefined behavior because the mathematical value of -LONG_MIN = LONG_MAX + 1\n    // (i.e. 1 more than the maximum possible value for signed long)\n    //\n    // printf(\"%ld\\n\", -LONG_MIN);\n \n    // Undefined behavior because the mathematical value of -LLONG_MIN = LLONG_MAX + 1\n    // (i.e. 1 more than the maximum possible value for signed long long)\n    //\n    // printf(\"%lld\\n\", -LLONG_MIN);\n \n    double complex z = 1 + 2*I;\n    printf(\"-(1+2i) = %.1f%+.1f\\n\", creal(-z), cimag(-z));\n}\n```\n\nPossible output:\n\n```\nsizeof char: 1 sizeof int: 4\n-1, where 1 is signed: -1\n-1, where 1 is unsigned: 4294967295\n-(1+2i) = -1.0-2.0\n```\n\n### Additive operators\n\nThe binary additive arithmetic operator expressions have the form\n\n|             |       |     |\n|-------------|-------|-----|\n| lhs `+` rhs | \\(1\\) |     |\n| lhs `-` rhs | \\(2\\) |     |\n\n1) addition: lhs and rhs must be one of the following\n\n- both have [arithmetic types](arithmetic_types \"c/language/arithmetic types\"), including complex and imaginary\n- one is a pointer to complete object type, the other has integer type\n\n2) subtraction: lhs and rhs must be one of the following\n\n- both have [arithmetic types](arithmetic_types \"c/language/arithmetic types\"), including complex and imaginary\n- lhs has pointer to complete object type, rhs has integer type\n- both are pointers to complete objects of [compatible](type#Comparible_types \"c/language/type\") types, ignoring qualifiers\n\n#### Arithmetic addition and subtraction\n\nIf both operands have [arithmetic types](arithmetic_types \"c/language/arithmetic types\"), then\n\n- first, [usual arithmetic conversions](conversion#Usual_arithmetic_conversions \"c/language/conversion\") are performed\n- then, the values of the operands after conversions are added or subtracted following the usual rules of mathematics (for subtraction, rhs is subtracted from lhs), except that\n  - if one operand is NaN, the result is NaN\n  - infinity minus infinity is NaN and [`FE_INVALID`](../numeric/fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n  - infinity plus the negative infinity is NaN and [`FE_INVALID`](../numeric/fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n\nComplex and imaginary addition and subtraction are defined as follows (note the result type is imaginary if both operands are imaginary and complex if one operand is real and the other imaginary, as specified by the usual arithmetic conversions):\n\n| \\+ or - | u            | iv           | u + iv             |\n|---------|--------------|--------------|--------------------|\n| x       | x ± u        | x ± iv       | (x ± u) ± iv       |\n| iy      | ±u + iy      | i(y ± v)     | ±u + i(y ± v)      |\n| x + iy  | (x ± u) + iy | x + i(y ± v) | (x ± u) + i(y ± v) |\n\n```\n// work in progress\n// note: take part of the c/language/conversion example\n```\n\n#### Pointer arithmetic\n\n- If the pointer `P` points at an element of an array with index `I`, then\n  - `P+N` and `N+P` are pointers that point at an element of the same array with index `I+N`\n  - `P-N` is a pointer that points at an element of the same array with index `I-N`\n\nThe behavior is defined only if both the original pointer and the result pointer are pointing at elements of the same array or one past the end of that array. Note that executing p-1 when p points at the first element of an array is undefined behavior and may fail on some platforms.\n\n- If the pointer `P1` points at an element of an array with index `I` (or one past the end) and `P2` points at an element of the same array with index `J` (or one past the end), then\n  - `P1-P2` has the value equal to `I-J` and the type [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") (which is a signed integer type, typically half as large as the size of the largest object that can be declared)\n\nThe behavior is defined only if the result fits in [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\").\n\nFor the purpose of pointer arithmetic, a pointer to an object that is not an element of any array is treated as a pointer to the first element of an array of size 1.\n\n```\n// work in progress\nint n = 4, m = 3;\nint a[n][m];     // VLA of 4 VLAs of 3 ints each\nint (*p)[m] = a; // p == &a[0] \np = p + 1;       // p == &a[1] (pointer arithmetic works with VLAs just the same)\n(*p)[2] = 99;    // changes a[1][2]\n```\n\n### Multiplicative operators\n\nThe binary multiplicative arithmetic operator expressions have the form\n\n|             |       |     |\n|-------------|-------|-----|\n| lhs `*` rhs | \\(1\\) |     |\n| lhs `/` rhs | \\(2\\) |     |\n| lhs `%` rhs | \\(3\\) |     |\n\n1) multiplication. lhs and rhs must have [arithmetic types](arithmetic_types \"c/language/arithmetic types\")\n\n2) division. lhs and rhs must have [arithmetic types](arithmetic_types \"c/language/arithmetic types\")\n\n3) remainder. lhs and rhs must have [integer types](arithmetic_types \"c/language/arithmetic types\")\n\n- first, [usual arithmetic conversions](conversion#Usual_arithmetic_conversions \"c/language/conversion\") are performed. Then...\n\n#### Multiplication\n\nThe binary operator \\* performs multiplication of its operands (after usual arithmetic conversions) following the usual arithmetic definitions, except that\n\n- if one operand is a NaN, the result is a NaN\n- multiplication of infinity by zero gives NaN and [`FE_INVALID`](../numeric/fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- multiplication of infinity by a nonzero gives infinity (even for complex arguments)\n\nBecause in C, any [complex value](arithmetic_types \"c/language/arithmetic types\") with at least one infinite part is an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex multiplication. Other combinations of floating operands follow the following table:\n\n| \\*     | u            | iv            | u + iv          |\n|--------|--------------|---------------|-----------------|\n| x      | xu           | i(xv)         | (xu) + i(xv)    |\n| iy     | i(yu)        | −yv           | (−yv) + i(yu)   |\n| x + iy | (xu) + i(yu) | (−yv) + i(xv) | *special rules* |\n\nBesides infinity handling, complex multiplication is not allowed to overflow intermediate results, except when [` #pragma STDC CX_LIMITED_RANGE`](../preprocessor/impl \"c/preprocessor/impl\") is set to `ON`, in which case the value may be calculated as if by (x+iy)×(u+iv) = (xu-yv)+i(yu+xv), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.\n\nDespite disallowing undue overflow, complex multiplication may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions)\n\n```\n#include <stdio.h>\n#include <stdio.h>\n#include <complex.h>\n#include <math.h>\nint main(void)\n{\n \n \n// TODO simpler cases, take some from C++\n \n \n   double complex z = (1 + 0*I) * (INFINITY + I*INFINITY);\n// textbook formula would give\n// (1+i0)(∞+i∞) ⇒ (1×∞ – 0×∞) + i(0×∞+1×∞) ⇒ NaN + I*NaN\n// but C gives a complex infinity\n   printf(\"%f + i*%f\\n\", creal(z), cimag(z));\n \n// textbook formula would give\n// cexp(∞+iNaN) ⇒ exp(∞)×(cis(NaN)) ⇒ NaN + I*NaN\n// but C gives  ±∞+i*nan\n   double complex y = cexp(INFINITY + I*NAN);\n   printf(\"%f + i*%f\\n\", creal(y), cimag(y));\n \n}\n```\n\nPossible output:\n\n```\ninf + i*inf \ninf + i*nan\n```\n\n#### Division\n\nThe binary operator `/` divides the first operand by the second (after usual arithmetic conversions) following the usual arithmetic definitions, except that\n\n- when the type after usual arithmetic conversions is an integer type, the result is the algebraic quotient (not a fraction), rounded in implementation-defined direction(until C99)truncated towards zero(since C99)\n- if one operand is a NaN, the result is a NaN\n- if the first operand is a complex infinity and the second operand is finite, then the result of the `/` operator is a complex infinity\n- if the first operand is finite and the second operand is a complex infinity, then the result of the `/` operator is a zero.\n\nBecause in C, any [complex value](arithmetic_types \"c/language/arithmetic types\") with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex division. Other combinations of floating operands follow the following table:\n\n| /      | u              | iv              |\n|--------|----------------|-----------------|\n| x      | x/u            | i(−x/v)         |\n| iy     | i(y/u)         | y/v             |\n| x + iy | (x/u) + i(y/u) | (y/v) + i(−x/v) |\n\nBesides infinity handling, complex division is not allowed to overflow intermediate results, except when [` #pragma STDC CX_LIMITED_RANGE`](../preprocessor/impl \"c/preprocessor/impl\") is set to `ON`, in which case the value may be calculated as if by (x+iy)/(u+iv) = \\[(xu+yv)+i(yu-xv)\\]/(u²+v²), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.\n\nDespite disallowing undue overflow, complex division may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions)\n\nIf the second operand is zero, the behavior is undefined, except that if the IEEE floating-point arithmetic is supported, and the floating-point division is taking place, then\n\n- Dividing a non-zero number by ±0.0 gives the correctly-signed infinity and [`FE_DIVBYZERO`](../numeric/fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- Dividing 0.0 by 0.0 gives NaN and [`FE_INVALID`](../numeric/fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n\n#### Remainder\n\nThe binary operator % yields the remainder of the division of the first operand by the second (after usual arithmetic conversions).\n\nThe sign of the remainder is defined in such a way that if the quotient `a/b` is representable in the result type, then `(a/b)*b + a%b == a`.\n\nIf the second operand is zero, the behavior is undefined.\n\nIf the quotient `a/b` is not representable in the result type, the behavior of both `a/b` and `a%b` is undefined (that means `INT_MIN%-1` is undefined on 2's complement systems)\n\nNote: the remainder operator does not work on floating-point types, the library function [`fmod`](../numeric/math/fmod \"c/numeric/math/fmod\") provides that functionality.\n\n### Bitwise logic\n\nThe bitwise arithmetic operator expressions have the form\n\n|             |       |     |\n|-------------|-------|-----|\n| `~` rhs     | \\(1\\) |     |\n| lhs `&` rhs | \\(2\\) |     |\n| lhs `|` rhs | \\(3\\) |     |\n| lhs `^` rhs | \\(4\\) |     |\n\n1) bitwise NOT\n\n2) bitwise AND\n\n3) bitwise OR\n\n4) bitwise XOR\n\nwhere\n\n|          |     |                             |\n|----------|-----|-----------------------------|\n| lhs, rhs | \\-  | expressions of integer type |\n\nFirst, operators `&`, `^`, and `|` perform [usual arithmetic conversions](conversion#Usual_arithmetic_conversions \"c/language/conversion\") on both operands and the operator `~` performs [integer promotions](conversion#Integer_promotions \"c/language/conversion\") on its only operand.\n\nThen, the corresponding binary logic operators are applied bitwise; that is, each bit of the result is set or cleared according to the logic operation (NOT, AND, OR, or XOR), applied to the corresponding bits of the operands.\n\nNote: bitwise operators are commonly used to manipulate bit sets and bit masks.\n\nNote: for unsigned types (after promotion), the expression `~E` is equivalent to the maximum value representable by the result type minus the original value of `E`.\n\n```\n#include <stdio.h>\n#include <stdint.h>\n \nint main(void)\n{\n    uint32_t a = 0x12345678;\n    uint16_t mask = 0x00f0;\n \n    printf(\"Promoted mask:\\t%#010x\\n\"\n           \"Value:\\t\\t%#x\\n\"\n           \"Setting bits:\\t%#x\\n\"\n           \"Clearing bits:\\t%#x\\n\"\n           \"Selecting bits:\\t%#010x\\n\"\n           , mask\n           , a\n           , a | mask\n           , a & ~mask\n           , a & mask\n    );\n}\n```\n\nPossible output:\n\n```\nPromoted mask:  0x000000f0\nValue:          0x12345678\nSetting bits:   0x123456f8\nClearing bits:  0x12345608\nSelecting bits: 0x00000070\n```\n\n### Shift operators\n\nThe bitwise shift operator expressions have the form\n\n|              |       |     |\n|--------------|-------|-----|\n| lhs `<<` rhs | \\(1\\) |     |\n| lhs `>>` rhs | \\(2\\) |     |\n\n1) left shift of lhs by rhs bits\n\n2) right shift of lhs by rhs bits\n\nwhere\n\n|          |     |                             |\n|----------|-----|-----------------------------|\n| lhs, rhs | \\-  | expressions of integer type |\n\nFirst, [integer promotions](conversion \"c/language/conversion\") are performed, individually, on each operand (Note: this is unlike other binary arithmetic operators, which all perform usual arithmetic conversions). The type of the result is the type of lhs after promotion.\n\nThe behavior is undefined if rhs is negative or is greater or equal the number of bits in the promoted lhs.\n\nFor unsigned lhs, the value of `LHS << RHS` is the value of LHS \\* 2^(RHS), reduced modulo maximum value of the return type plus 1 (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded). For signed lhs with nonnegative values, the value of `LHS << RHS` is LHS \\* 2^(RHS) if it is representable in the promoted type of lhs, otherwise the behavior is undefined.\n\nFor unsigned lhs and for signed lhs with nonnegative values, the value of `LHS >> RHS` is the integer part of LHS / 2^(RHS). For negative `LHS`, the value of `LHS >> RHS` is implementation-defined where in most implementations, this performs arithmetic right shift (so that the result remains negative). Thus in most implementations, right shifting a signed `LHS` fills the new higher-order bits with the original sign bit (i.e. with 0 if it was non-negative and 1 if it was negative).\n\n```\n#include <stdio.h>\nenum {ONE=1, TWO=2};\nint main(void)\n{\n    char c = 0x10;\n    unsigned long long ulong_num = 0x123;\n    printf(\"0x123 << 1  = %#llx\\n\"\n           \"0x123 << 63 = %#llx\\n\"   // overflow truncates high bits for unsigned numbers\n           \"0x10  << 10 = %#x\\n\",    // char is promoted to int\n           ulong_num << 1, ulong_num << 63, c << 10);\n    long long long_num = -1000;\n    printf(\"-1000 >> 1 = %lld\\n\", long_num >> ONE);  // implementation defined\n}\n```\n\nPossible output:\n\n```\n0x123 << 1  = 0x246\n0x123 << 63 = 0x8000000000000000\n0x10  << 10 = 0x4000\n-1000 >> 1 = -500\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.3.3 Unary arithmetic operators (p: 64)\n  - 6.5.5 Multiplicative operators (p: 66)\n  - 6.5.6 Additive operators (p: 66-68)\n  - 6.5.7 Bitwise shift operators (p: 68)\n  - 6.5.10 Bitwise AND operator (p: 70)\n  - 6.5.11 Bitwise exclusive OR operator (p: 70)\n  - 6.5.12 Bitwise inclusive OR operator (p: 70-71)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.3.3 Unary arithmetic operators (p: 89)\n  - 6.5.5 Multiplicative operators (p: 92)\n  - 6.5.6 Additive operators (p: 92-94)\n  - 6.5.7 Bitwise shift operators (p: 94-95)\n  - 6.5.10 Bitwise AND operator (p: 97)\n  - 6.5.11 Bitwise exclusive OR operator (p: 98)\n  - 6.5.12 Bitwise inclusive OR operator (p: 98)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5.3.3 Unary arithmetic operators (p: 79)\n  - 6.5.5 Multiplicative operators (p: 82)\n  - 6.5.6 Additive operators (p: 82-84)\n  - 6.5.7 Bitwise shift operators (p: 84-85)\n  - 6.5.10 Bitwise AND operator (p: 87)\n  - 6.5.11 Bitwise exclusive OR operator (p: 88)\n  - 6.5.12 Bitwise inclusive OR operator (p: 88)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.3.3.3 Unary arithmetic operators\n  - 3.3.5 Multiplicative operators\n  - 3.3.6 Additive operators\n  - 3.3.7 Bitwise shift operators\n  - 3.3.10 Bitwise AND operator\n  - 3.3.11 Bitwise exclusive OR operator\n  - 3.3.12 Bitwise inclusive OR operator\n\n### See also\n\n[Operator precedence](operator_precedence \"c/language/operator precedence\")\n\n[TABLE]\n\n|                                                                                                                                                 |     |\n|-------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/operator_arithmetic \"cpp/language/operator arithmetic\") for Arithmetic operators |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/operator_arithmetic](https://en.cppreference.com/w/c/language/operator_arithmetic)"
- name: Arithmetic types
  summary: (See also type for type system overview and the list of type-related utilities that are provided by the C library.)
  description: "# Arithmetic types\n\n(See also [type](type \"c/language/type\") for type system overview and [the list of type-related utilities](../types \"c/types\") that are provided by the C library.)\n\n[TABLE]\n\n### Character types\n\n- `signed char` - type for signed character representation.\n- `unsigned char` - type for unsigned character representation. Also used to inspect [object representations](object \"c/language/object\") (raw memory).\n- `char` - type for character representation. Equivalent to either `signed char` or `unsigned char` (which one is implementation-defined and may be controlled by a compiler commandline switch), but `char` is a distinct type, different from both `signed char` and `unsigned char`.\n\nNote that the standard library also defines [typedef](typedef \"c/language/typedef\") names [`wchar_t`](../string/wide \"c/string/wide\") , [`char16_t`](../string/multibyte \"c/string/multibyte\") and [`char32_t`](../string/multibyte \"c/string/multibyte\")(since C11) to represent wide characters and [`char8_t`](../string/multibyte \"c/string/multibyte\") for UTF-8 characters(since C23).\n\n### Integer types\n\n- `short int` (also accessible as `short`, may use the keyword `signed`)\n- `unsigned short int` (also accessible as `unsigned short`)\n- `int` (also accessible as `signed int`)\n- `unsigned int` (also accessible as `unsigned`), the unsigned counterpart of `int`, implementing modulo arithmetic. Suitable for bit manipulations.\n- `long int` (also accessible as `long`)\n- `unsigned long int` (also accessible as `unsigned long`)\n\nThis is the most optimal integer type for the platform, and is guaranteed to be at least 16 bits. Most current systems use 32 bits (see Data models below).\n\n[TABLE]\n\nNote: as with all type specifiers, any order is permitted: `unsigned long long int` and `long int unsigned long` name the same type.\n\nThe following table summarizes all available integer types and their properties:\n\n[TABLE]\n\nBesides the minimal bit counts, the C Standard guarantees that `1` == `sizeof(char)` ≤ `sizeof(short)` ≤ `sizeof(int)` ≤ `sizeof(long)` ≤ `sizeof(long long)`.\n\nNote: this allows the extreme case in which [byte](https://en.wikipedia.org/wiki/byte \"enwiki:byte\") are sized 64 bits, all types (including `char`) are 64 bits wide, and `sizeof` returns 1 for every type.\n\nNote: integer arithmetic is defined differently for the signed and unsigned integer types. See [arithmetic operators](operator_arithmetic \"c/language/operator arithmetic\"), in particular [integer overflows](operator_arithmetic#Overflows \"c/language/operator arithmetic\").\n\n#### Data models\n\nThe choices made by each implementation about the sizes of the fundamental types are collectively known as *data model*. Four data models found wide acceptance:\n\n32 bit systems:\n\n- **LP32** or **2/4/4** (int is 16-bit, long and pointer are 32-bit)\n  - Win16 API\n- **ILP32** or **4/4/4** (int, long, and pointer are 32-bit);\n  - Win32 API\n  - Unix and Unix-like systems (Linux, Mac OS X)\n\n64 bit systems:\n\n- **LLP64** or **4/4/8** (int and long are 32-bit, pointer is 64-bit)\n  - Win64 API\n- **LP64** or **4/8/8** (int is 32-bit, long and pointer are 64-bit)\n  - Unix and Unix-like systems (Linux, Mac OS X)\n\nOther models are very rare. For example, **ILP64** (**8/8/8**: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. Unicos on Cray).\n\nNote that exact-width integer types are available in [`<stdint.h>`](../types/integer \"c/types/integer\") since C99.\n\n### Real floating types\n\nC has three or six(since C23) types for representing real floating-point values:\n\n- `float` - single precision floating-point type. Matches [IEEE-754 binary32 format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format \"enwiki:Single-precision floating-point format\") if supported.\n- `double` - double precision floating-point type. Matches [IEEE-754 binary64 format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format \"enwiki:Double-precision floating-point format\") if supported.\n- `long double` - extended precision floating-point type. Matches [IEEE-754 binary128 format](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format \"enwiki:Quadruple-precision floating-point format\") if supported, otherwise matches [IEEE-754 binary64-extended format](https://en.wikipedia.org/wiki/Extended_precision \"enwiki:Extended precision\") if supported, otherwise matches some non-IEEE-754 extended floating-point format as long as its precision is better than binary64 and range is at least as good as binary64, otherwise matches IEEE-754 binary64 format.\n  - binary128 format is used by some HP-UX, SPARC, MIPS, ARM64, and z/OS implementations.\n  - The most well known IEEE-754 binary64-extended format is 80-bit x87 extended precision format. It is used by many x86 and x86-64 implementations (a notable exception is MSVC, which implements `long double` in the same format as `double`, i.e. binary64).\n\n[TABLE]\n\nFloating-point types may support special values:\n\n- *infinity* (positive and negative), see [`INFINITY`](../numeric/math/infinity \"c/numeric/math/INFINITY\")\n- the *negative zero*, `-0.0`. It compares equal to the positive zero, but is meaningful in some arithmetic operations, e.g. `1.0/0.0 == INFINITY`, but `1.0/-0.0 == -INFINITY`)\n- *not-a-number* (NaN), which does not compare equal with anything (including itself). Multiple bit patterns represent NaNs, see [`nan`](../numeric/math/nan \"c/numeric/math/nan\"), [`NAN`](../numeric/math/nan \"c/numeric/math/NAN\"). Note that C takes no special notice of signaling NaNs (specified by IEEE-754), and treats all NaNs as quiet.\n\nReal floating-point numbers may be used with [arithmetic operators](operator_arithmetic \"c/language/operator arithmetic\") + - / \\* and various mathematical functions from [`<math.h>`](../numeric/math \"c/numeric/math\"). Both built-in operators and library functions may raise floating-point exceptions and set [`errno`](../error/errno \"c/error/errno\") as described in [`math_errhandling`](../numeric/math/math_errhandling \"c/numeric/math/math errhandling\").\n\nFloating-point expressions may have greater range and precision than indicated by their types, see [`FLT_EVAL_METHOD`](../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\"). [Assignment](operator_assignment \"c/language/operator assignment\"), [return](return \"c/language/return\"), and [cast](cast \"c/language/cast\") force the range and precision to the one associated with the declared type.\n\nFloating-point expressions may also be *contracted*, that is, calculated as if all intermediate values have infinite range and precision, see [` #pragma STDC FP_CONTRACT`](../preprocessor/impl#Standard_pragmas \"c/preprocessor/impl\").\n\nSome operations on floating-point numbers are affected by and modify the state of [the floating-point environment](../numeric/fenv \"c/numeric/fenv\") (most notably, the rounding direction).\n\n[Implicit conversions](conversion \"c/language/conversion\") are defined between real floating types and integer, complex, and imaginary types.\n\nSee [Limits of floating-point types](../types/limits#Limits_of_floating-point_types \"c/types/limits\") and the [`<math.h>`](../numeric/math \"c/numeric/math\") library for additional details, limits, and properties of the floating-point types.\n\n[TABLE]\n\n### Keywords\n\n- [`bool`](../keyword/bool \"c/keyword/bool\"), [`true`](../keyword/true \"c/keyword/true\"), [`false`](../keyword/false \"c/keyword/false\"), [`char`](../keyword/char \"c/keyword/char\"), [`int`](../keyword/int \"c/keyword/int\"), [`short`](../keyword/short \"c/keyword/short\"), [`long`](../keyword/long \"c/keyword/long\"), [`signed`](../keyword/signed \"c/keyword/signed\"), [`unsigned`](../keyword/unsigned \"c/keyword/unsigned\"), [`float`](../keyword/float \"c/keyword/float\"), [`double`](../keyword/double \"c/keyword/double\").\n- [`_Bool`](../keyword/_bool \"c/keyword/ Bool\"), [`_BitInt`](https://en.cppreference.com/mwiki/index.php?title=c/keyword/_BitInt&action=edit&redlink=1 \"c/keyword/ BitInt (page does not exist)\"), [`_Complex`](../keyword/_complex \"c/keyword/ Complex\"), [`_Imaginary`](../keyword/_imaginary \"c/keyword/ Imaginary\"), [`_Decimal32`](../keyword/_decimal32 \"c/keyword/ Decimal32\"), [`_Decimal64`](../keyword/_decimal64 \"c/keyword/ Decimal64\"), [`_Decimal128`](../keyword/_decimal128 \"c/keyword/ Decimal128\").\n\n### Range of values\n\nThe following table provides a reference for the limits of common numeric representations.\n\nPrior to C23, the C Standard allowed any signed integer representation, and the minimum guaranteed range of N-bit signed integers was from \\\\\\scriptsize -(2^{N-1}-1)\\\\-(2^(N-1)-1) to \\\\\\scriptsize +2^{N-1}-1\\\\+2^(N-1)-1 (e.g. **-127** to **127** for a signed 8-bit type), which corresponds to the limits of [one's complement](https://en.wikipedia.org/wiki/one%27s_complement \"enwiki:one's complement\") or [sign-and-magnitude](https://en.wikipedia.org/wiki/Signed_number_representations#Sign-and-magnitude_method \"enwiki:Signed number representations\").\n\nHowever, all popular data models (including all of ILP32, LP32, LP64, LLP64) and almost all C compilers use [two's complement](https://en.wikipedia.org/wiki/two%27s_complement \"enwiki:two's complement\") representation (the only known exceptions are some compliers for UNISYS), and as of C23, it is the only representation allowed by the standard, with the guaranteed range from \\\\\\scriptsize -2^{N-1}\\\\-2^(N-1) to \\\\\\scriptsize +2^{N-1}-1\\\\+2^(N-1)-1 (e.g. **-128** to **127** for a signed 8-bit type).\n\n[TABLE]\n\n1.  The object representation usually occupies 96/128 bits on 32/64-bit platforms respectively.\n\nNote: actual (as opposed to guaranteed minimal) ranges are available in the library headers [`<limits.h>`](../types/limits \"c/types/limits\") and [`<float.h>`](../types/limits#Limits_of_floating_point_types \"c/types/limits\").\n\n### See also\n\n|                                                                                                                  |     |\n|------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/types \"cpp/language/types\") for Fundamental types |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/arithmetic_types](https://en.cppreference.com/w/c/language/arithmetic_types)"
- name: Array declaration
  summary: Array is a type consisting of a contiguously allocated nonempty sequence of objects with a particular element type
  description: "# Array declaration\n\nArray is a type consisting of a contiguously allocated nonempty sequence of objects with a particular *element type*. The number of those objects (the array size) never changes during the array lifetime.\n\n### Syntax\n\nIn the [declaration grammar](declarations \"c/language/declarations\") of an array declaration, the *type-specifier* sequence designates the *element type* (which must be a complete object type), and the *declarator* has the form:\n\n|                                                                                                 |       |     |\n|-------------------------------------------------------------------------------------------------|-------|-----|\n| `[` `static`(optional) qualifiers \uFEFF(optional) expression \uFEFF(optional) `]` attr-spec-seq \uFEFF(optional) | \\(1\\) |     |\n| `[` qualifiers \uFEFF(optional) `static`(optional) expression \uFEFF(optional) `]` attr-spec-seq \uFEFF(optional) | \\(2\\) |     |\n| `[` qualifiers \uFEFF(optional) `*` `]` attr-spec-seq \uFEFF(optional)                                      | \\(3\\) |     |\n\n1,2) General array declarator syntax\n\n3) Declarator for VLA of unspecified size (can appear in function prototype scope only) where\n\n|               |     |                                                                                                                                                                                                                                                                                          |\n|---------------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| expression    | \\-  | any expression other than [comma operator](operator_other#Comma_operator \"c/language/operator other\"), designates the number of elements in the array                                                                                                                                    |\n| qualifiers    | \\-  | any combination of [`const`](const \"c/language/const\"), [`restrict`](restrict \"c/language/restrict\"), or [`volatile`](volatile \"c/language/volatile\") qualifiers, only allowed in function parameter lists; this qualifies the pointer type to which this array parameter is transformed |\n| attr-spec-seq | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the declared array                                                                                                                                                                                    |\n\n```\nfloat fa[11], *afp[17]; // fa is an array of 11 floats\n                        // afp is an array of 17 pointers to floats\n```\n\n### Explanation\n\nThere are several variations of array types: arrays of known constant size, variable-length arrays, and arrays of unknown size.\n\n#### Arrays of constant known size\n\nIf expression in an array declarator is an [integer constant expression](constant_expression#Integer_constant_expression \"c/language/constant expression\") with a value greater than zero and the element type is a type with a known constant size (that is, elements are not VLA)(since C99), then the declarator declares an array of constant known size:\n\n```\nint n[10]; // integer constants are constant expressions\nchar o[sizeof(double)]; // sizeof is a constant expression\nenum { MAX_SZ=100 };\nint n[MAX_SZ]; // enum constants are constant expressions\n```\n\nArrays of constant known size can use [array initializers](array_initialization \"c/language/array initialization\") to provide their initial values:\n\n```\nint a[5] = {1,2,3}; // declares int[5] initialized to 1,2,3,0,0\nchar str[] = \"abc\"; // declares char[4] initialized to 'a','b','c','\\0'\n```\n\n[TABLE]\n\n#### Arrays of unknown size\n\nIf expression in an array declarator is omitted, it declares an array of unknown size. Except in function parameter lists (where such arrays are transformed to pointers) and when an [initializer](array_initialization \"c/language/array initialization\") is available, such type is an [incomplete type](type#Incomplete_types \"c/language/type\") (note that VLA of unspecified size, declared with `*` as the size, is a complete type)(since C99):\n\n```\nextern int x[]; // the type of x is \"array of unknown bound of int\"\nint a[] = {1,2,3}; // the type of a is \"array of 3 int\"\n```\n\n[TABLE]\n\n#### Qualifiers\n\n|                                                                                                                                                                                                                                                                                                                                       |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If an array type is declared with a [`const`](const \"c/language/const\"), [`volatile`](volatile \"c/language/volatile\"), or [`restrict`](restrict \"c/language/restrict\")(since C99) qualifier (which is possible through the use of [typedef](typedef \"c/language/typedef\")), the array type is not qualified, but its element type is: | (until C23) |\n| An array type and its element type are always considered to be identically qualified, except that an array type is never considered to be [`_Atomic`](atomic \"c/language/atomic\")-qualified.                                                                                                                                          | (since C23) |\n\n```\ntypedef int A[2][3];\nconst A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const int\nint* pi = a[0]; // Error: a[0] has type const int*\nvoid* unqual_ptr = a; // OK until C23; error since C23\n// Notes: clang applies the rule in C++/C23 even in C89-C17 modes\n```\n\n[TABLE]\n\n#### Assignment\n\nObjects of array type are not [modifiable lvalues](value_category \"c/language/value category\"), and although their address may be taken, they cannot appear on the left hand side of an assignment operator. However, structs with array members are modifiable lvalues and can be assigned:\n\n```\nint a[3] = {1,2,3}, b[3] = {4,5,6};\nint (*p)[3] = &a; // okay, address of a can be taken\n// a = b;            // error, a is an array\nstruct { int c[3]; } s1, s2 = {3,4,5};\ns1 = s2; // okay: can assign structs holding array members\n```\n\n#### Array to pointer conversion\n\nAny [lvalue expression](value_category \"c/language/value category\") of array type, when used in any context other than\n\n- as the operand of the [address-of operator](operator_member_access \"c/language/operator member access\")\n- as the operand of [`sizeof`](sizeof \"c/language/sizeof\")\n- as the operand of [`typeof`](typeof \"c/language/typeof\") and [`typeof_unqual`](https://en.cppreference.com/mwiki/index.php?title=c/language/typeof_unqual&action=edit&redlink=1 \"c/language/typeof unqual (page does not exist)\") (since C23)\n- as the string literal used for [array initialization](array_initialization \"c/language/array initialization\")\n\n[TABLE]\n\nundergoes an [implicit conversion](conversion \"c/language/conversion\") to the pointer to its first element. The result is not an lvalue.\n\nIf the array was declared [`register`](storage_duration \"c/language/storage duration\"), the behavior of the program that attempts such conversion is undefined.\n\n```\nint a[3] = {1,2,3};\nint* p = a;\nprintf(\"%zu\\n\", sizeof a); // prints size of array\nprintf(\"%zu\\n\", sizeof p); // prints size of a pointer\n```\n\nWhen an array type is used in a function parameter list, it is transformed to the corresponding pointer type: `int f(int a[2])` and `int f(int* a)` declare the same function. Since the function's actual parameter type is pointer type, a function call with an array argument performs array-to-pointer conversion; the size of the argument array is not available to the called function and must be passed explicitly:\n\n```\n#include <stdio.h>\n \nvoid f(int a[], int sz) // actually declares void f(int* a, int sz)\n{\n    for (int i = 0; i < sz; ++i)\n        printf(\"%d\\n\", a[i]);\n}\n \nvoid g(int (*a)[10]) // pointer to array parameter is not transformed\n{\n    for (int i = 0; i < 10; ++i)\n        printf(\"%d\\n\", (*a)[i]);\n}\n \nint main(void)\n{\n    int a[10] = {0};\n    f(a, 10); // converts a to int*, passes the pointer\n    g(&a);    // passes a pointer to the array (no need to pass the size)\n}\n```\n\n#### Multidimensional arrays\n\nWhen the element type of an array is another array, it is said that the array is multidimensional:\n\n```\n// array of 2 arrays of 3 ints each\nint a[2][3] = {{1,2,3},  // can be viewed as a 2x3 matrix\n               {4,5,6}}; // with row-major layout\n```\n\nNote that when array-to-pointer conversion is applied, a multidimensional array is converted to a pointer to its first element, e.g., pointer to the first row:\n\n```\nint a[2][3]; // 2x3 matrix\nint (*p1)[3] = a; // pointer to the first 3-element row\nint b[3][3][3]; // 3x3x3 cube\nint (*p2)[3][3] = b; // pointer to the first 3x3 plane\n```\n\n[TABLE]\n\n### Notes\n\nZero-length array declarations are not allowed, even though some compilers offer them as extensions (typically as a pre-C99 implementation of [flexible array members](struct \"c/language/struct\")).\n\nIf the size expression of a VLA has side effects, they are guaranteed to be produced except when it is a part of a sizeof expression whose result doesn't depend on it:\n\n```\nint n = 5;\nsize_t sz = sizeof(int (*)[n++]); // may or may not increment n\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.6.2 Array declarators (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.6.2 Array declarators (p: 94-96)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.6.2 Array declarators (p: 130-132)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.5.2 Array declarators (p: 116-118)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.5.4.2 Array declarators\n\n### See also\n\n|                                                                                                                  |     |\n|------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/array \"cpp/language/array\") for Array declaration |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/array](https://en.cppreference.com/w/c/language/array)"
- name: Array initialization
  summary: 'When initializing an object of array type, the initializer must be either a string literal (optionally enclosed in braces) or be a brace-enclosed list of initialized for array members:'
  description: "# Array initialization\n\nWhen [initializing](initialization \"c/language/initialization\") an object of [array](array \"c/language/array\") type, the initializer must be either a [string literal](string_literal \"c/language/string literal\") (optionally enclosed in braces) or be a brace-enclosed list of initialized for array members:\n\n|                                                       |       |             |\n|-------------------------------------------------------|-------|-------------|\n| `=` string-literal                                    | \\(1\\) |             |\n| `=` `{` expression `,` `...` `}`                      | \\(2\\) | (until C99) |\n| `=` `{` designator(optional) expression `,` `...` `}` | \\(2\\) | (since C99) |\n| `=` `{` `}`                                           | \\(3\\) | (since C23) |\n\n1) string literal initializer for character and wide character arrays\n\n2) comma-separated list of constant(until C99) expressions that are initializers for array elements, optionally using array designators of the form `[` constant-expression `]` `=` (since C99)\n\n3) empty initializer empty-initializes every element of the array\n\nArrays of known size and arrays of unknown size may be initialized, but not VLAs(since C99)(until C23). A VLA can only be empty-initialized.(since C23)\n\nAll array elements that are not initialized explicitly are [empty-initialized](initialization#Empty_initialization \"c/language/initialization\").\n\n### Initialization from strings\n\n[String literal](string_literal \"c/language/string literal\") (optionally enclosed in braces) may be used as the initializer for an array of matching type:\n\n- ordinary string literals and UTF-8 string literals(since C11) can initialize arrays of any character type (`char`, `signed char`, `unsigned char`)\n- L-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications) `wchar_t`\n\n[TABLE]\n\nSuccessive bytes of the string literal or wide characters of the wide string literal, including the terminating null byte/character, initialize the elements of the array:\n\n```\nchar str[] = \"abc\"; // str has type char[4] and holds 'a', 'b', 'c', '\\0'\nwchar_t wstr[4] = L\"猫\"; // str has type wchar_t[4] and holds L'猫', '\\0', '\\0', '\\0'\n```\n\nIf the size of the array is known, it may be one less than the size of the string literal, in which case the terminating null character is ignored:\n\n```\nchar str[3] = \"abc\"; // str has type char[3] and holds 'a', 'b', 'c'\n```\n\nNote that the contents of such array are modifiable, unlike when accessing a string literal directly with `char* str = \"abc\";`.\n\n### Initialization from brace-enclosed lists\n\nWhen an array is initialized with a brace-enclosed list of initializers, the first initializer in the list initializes the array element at index zero (unless a designator is specified)(since C99), and each subsequent initializer without a designator (since C99)initializes the array element at index one greater than the one initialized by the previous initializer.\n\n```\nint x[] = {1,2,3}; // x has type int[3] and holds 1,2,3\nint y[5] = {1,2,3}; // y has type int[5] and holds 1,2,3,0,0\nint z[4] = {1}; // z has type int[4] and holds 1,0,0,0\nint w[3] = {0}; // w has type int[3] and holds all zeroes\n```\n\nIt's an error to provide more initializers than elements when initializing an array of known size (except when initializing character arrays from string literals).\n\n[TABLE]\n\nWhen initializing an array of unknown size, the largest subscript for which an initializer is specified determines the size of the array being declared.\n\n### Nested arrays\n\nIf the elements of an array are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:\n\nIf the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding array element:\n\n```\nint y[4][3] = { // array of 4 arrays of 3 ints each (4x3 matrix)\n    { 1 },      // row 0 initialized to {1, 0, 0}\n    { 0, 1 },   // row 1 initialized to {0, 1, 0}\n    { [2]=1 },  // row 2 initialized to {0, 0, 1}\n};              // row 3 initialized to {0, 0, 0}\n```\n\nIf the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the sub-array, struct or union; any remaining initializers are left to initialize the next array element:\n\n```\nint y[4][3] = {    // array of 4 arrays of 3 ints each (4x3 matrix)\n1, 3, 5, 2, 4, 6, 3, 5, 7 // row 0 initialized to {1, 3, 5}\n};                        // row 1 initialized to {2, 4, 6}\n                          // row 2 initialized to {3, 5, 7}\n                          // row 3 initialized to {0, 0, 0}\n \nstruct { int a[3], b; } w[] = { { 1 }, 2 }; // array of structs\n   // { 1 } is taken to be a fully-braced initializer for element #0 of the array\n   // that element is initialized to { {1, 0, 0}, 0}\n   // 2 is taken to be the first initialized for element #1 of the array\n   // that element is initialized { {2, 0, 0}, 0}\n```\n\n[TABLE]\n\n### Notes\n\nThe [order of evaluation](eval_order \"c/language/eval order\") of subexpressions in an array initializer is indeterminately sequenced in C (but not in C++ since C++11):\n\n```\nint n = 1;\nint a[2] = {n++, n++}; // unspecified, but well-defined behavior,\n                       // n is incremented twice (in arbitrary order)\n                       // a initialized to {1, 2} and to {2, 1} are both valid\nputs((char[4]){'0'+n} + n++); // undefined behavior:\n                              // increment and read from n are unsequenced\n```\n\n|                                                                                 |             |\n|---------------------------------------------------------------------------------|-------------|\n| In C, the braced list of an initializer cannot be empty. C++ allows empty list: | (until C23) |\n| An empty initializer can be used to initialize an array:                        | (since C23) |\n\n```\nint a[3] = {0}; // valid C and C++ way to zero-out a block-scope array\nint a[3] = {}; // valid C++ way to zero-out a block-scope array; valid in C since C23\n```\n\nAs with all other [initialization](initialization \"c/language/initialization\"), every expression in the initializer list must be a [constant expression](constant_expression \"c/language/constant expression\") when initializing arrays of static or thread-local [storage duration](storage_duration \"c/language/storage duration\"):\n\n```\nstatic char* p[2] = {malloc(1), malloc(2)}; // error\n```\n\n### Example\n\n```\nint main(void)\n{\n    // The following four array declarations are the same\n    short q1[4][3][2] = {\n        { 1 },\n        { 2, 3 },\n        { 4, 5, 6 }\n    };\n \n    short q2[4][3][2] = {1, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 4, 5, 6};\n \n    short q3[4][3][2] = {\n        {\n            { 1 },\n        },\n        {\n            { 2, 3 },\n        },\n        {\n            { 4, 5 },\n            { 6 },\n        }\n    };\n \n    short q4[4][3][2] = {1, [1]=2, 3, [2]=4, 5, 6};\n \n \n    // Character names can be associated with enumeration constants\n    // using arrays with designators:\n    enum { RED, GREEN, BLUE };\n    const char *nm[] = {\n        [RED] = \"red\",\n        [GREEN] = \"green\",\n        [BLUE] = \"blue\",\n    };\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.9/12-39 Initialization (p: 101-105)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.9/12-38 Initialization (p: 140-144)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.8/12-38 Initialization (p: 126-130)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 6.5.7 Initialization\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/array_initialization](https://en.cppreference.com/w/c/language/array_initialization)"
- name: As-if rule
  summary: Allows any and all code transformations that do not change the observable behavior of the program
  description: "# As-if rule\n\nAllows any and all code transformations that do not change the observable behavior of the program.\n\n### Explanation\n\nThe C compiler is permitted to perform any changes to the program as long as the following remains true:\n\n|                                                                                                                                                                                                                                                                                                                            |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| 1) At every [sequence point](eval_order \"c/language/eval order\"), the values of all [volatile](volatile \"c/language/volatile\") objects are stable (previous evaluations are complete, new evaluations not started).                                                                                                        | (until C11) |\n| 1) Accesses (reads and writes) to [volatile](volatile \"c/language/volatile\") objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are [not reordered](../atomic/memory_order \"c/atomic/memory order\") with respect to other volatile accesses on the same thread. | (since C11) |\n\n2) At program termination, data written to files is exactly as if the program was executed as written.\n\n3) Prompting text which is sent to interactive devices will be shown before the program waits for input.\n\n[TABLE]\n\n### Notes\n\n### See also\n\n- [Order of evaluation](eval_order \"c/language/eval order\")\n\n|                                                                                                           |     |\n|-----------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/as_if \"cpp/language/as if\") for as-if rule |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/as_if](https://en.cppreference.com/w/c/language/as_if)"
- name: ASCII Chart
  summary: The following chart contains all 128 ASCII decimal (dec), octal (oct), hexadecimal (hex) and character (ch) codes
  description: "# ASCII Chart\n\nThe following chart contains all 128 ASCII decimal **(dec)**, octal **(oct)**, hexadecimal **(hex)** and character **(ch)** codes.\n\n|       |       |       |                                   |     |       |       |       |         |     |       |       |       |      |     |       |       |       |                |\n|-------|-------|-------|-----------------------------------|-----|-------|-------|-------|---------|-----|-------|-------|-------|------|-----|-------|-------|-------|----------------|\n| `dec` | `oct` | `hex` | `ch`                              |     | `dec` | `oct` | `hex` | `ch`    |     | `dec` | `oct` | `hex` | `ch` |     | `dec` | `oct` | `hex` | `ch`           |\n| `0`   | `0`   | `00`  | `NUL` (null)                      |     | `32`  | `40`  | `20`  | (space) |     | `64`  | `100` | `40`  | `@`  |     | `96`  | `140` | `60`  | `` ` ``        |\n| `1`   | `1`   | `01`  | `SOH` (start of header)           |     | `33`  | `41`  | `21`  | `!`     |     | `65`  | `101` | `41`  | `A`  |     | `97`  | `141` | `61`  | `a`            |\n| `2`   | `2`   | `02`  | `STX` (start of text)             |     | `34`  | `42`  | `22`  | `\"`     |     | `66`  | `102` | `42`  | `B`  |     | `98`  | `142` | `62`  | `b`            |\n| `3`   | `3`   | `03`  | `ETX` (end of text)               |     | `35`  | `43`  | `23`  | `#`     |     | `67`  | `103` | `43`  | `C`  |     | `99`  | `143` | `63`  | `c`            |\n| `4`   | `4`   | `04`  | `EOT` (end of transmission)       |     | `36`  | `44`  | `24`  | `$`     |     | `68`  | `104` | `44`  | `D`  |     | `100` | `144` | `64`  | `d`            |\n| `5`   | `5`   | `05`  | `ENQ` (enquiry)                   |     | `37`  | `45`  | `25`  | `%`     |     | `69`  | `105` | `45`  | `E`  |     | `101` | `145` | `65`  | `e`            |\n| `6`   | `6`   | `06`  | `ACK` (acknowledge)               |     | `38`  | `46`  | `26`  | `&`     |     | `70`  | `106` | `46`  | `F`  |     | `102` | `146` | `66`  | `f`            |\n| `7`   | `7`   | `07`  | `BEL` (bell)                      |     | `39`  | `47`  | `27`  | `'`     |     | `71`  | `107` | `47`  | `G`  |     | `103` | `147` | `67`  | `g`            |\n| `8`   | `10`  | `08`  | `BS` (backspace)                  |     | `40`  | `50`  | `28`  | `(`     |     | `72`  | `110` | `48`  | `H`  |     | `104` | `150` | `68`  | `h`            |\n| `9`   | `11`  | `09`  | `HT` (horizontal tab)             |     | `41`  | `51`  | `29`  | `)`     |     | `73`  | `111` | `49`  | `I`  |     | `105` | `151` | `69`  | `i`            |\n| `10`  | `12`  | `0a`  | `LF` (line feed - new line)       |     | `42`  | `52`  | `2a`  | `*`     |     | `74`  | `112` | `4a`  | `J`  |     | `106` | `152` | `6a`  | `j`            |\n| `11`  | `13`  | `0b`  | `VT` (vertical tab)               |     | `43`  | `53`  | `2b`  | `+`     |     | `75`  | `113` | `4b`  | `K`  |     | `107` | `153` | `6b`  | `k`            |\n| `12`  | `14`  | `0c`  | `FF` (form feed - new page)       |     | `44`  | `54`  | `2c`  | `,`     |     | `76`  | `114` | `4c`  | `L`  |     | `108` | `154` | `6c`  | `l`            |\n| `13`  | `15`  | `0d`  | `CR` (carriage return)            |     | `45`  | `55`  | `2d`  | `-`     |     | `77`  | `115` | `4d`  | `M`  |     | `109` | `155` | `6d`  | `m`            |\n| `14`  | `16`  | `0e`  | `SO` (shift out)                  |     | `46`  | `56`  | `2e`  | `.`     |     | `78`  | `116` | `4e`  | `N`  |     | `110` | `156` | `6e`  | `n`            |\n| `15`  | `17`  | `0f`  | `SI` (shift in)                   |     | `47`  | `57`  | `2f`  | `/`     |     | `79`  | `117` | `4f`  | `O`  |     | `111` | `157` | `6f`  | `o`            |\n| `16`  | `20`  | `10`  | `DLE` (data link escape)          |     | `48`  | `60`  | `30`  | `0`     |     | `80`  | `120` | `50`  | `P`  |     | `112` | `160` | `70`  | `p`            |\n| `17`  | `21`  | `11`  | `DC1` (device control 1)          |     | `49`  | `61`  | `31`  | `1`     |     | `81`  | `121` | `51`  | `Q`  |     | `113` | `161` | `71`  | `q`            |\n| `18`  | `22`  | `12`  | `DC2` (device control 2)          |     | `50`  | `62`  | `32`  | `2`     |     | `82`  | `122` | `52`  | `R`  |     | `114` | `162` | `72`  | `r`            |\n| `19`  | `23`  | `13`  | `DC3` (device control 3)          |     | `51`  | `63`  | `33`  | `3`     |     | `83`  | `123` | `53`  | `S`  |     | `115` | `163` | `73`  | `s`            |\n| `20`  | `24`  | `14`  | `DC4` (device control 4)          |     | `52`  | `64`  | `34`  | `4`     |     | `84`  | `124` | `54`  | `T`  |     | `116` | `164` | `74`  | `t`            |\n| `21`  | `25`  | `15`  | `NAK` (negative acknowledge)      |     | `53`  | `65`  | `35`  | `5`     |     | `85`  | `125` | `55`  | `U`  |     | `117` | `165` | `75`  | `u`            |\n| `22`  | `26`  | `16`  | `SYN` (synchronous idle)          |     | `54`  | `66`  | `36`  | `6`     |     | `86`  | `126` | `56`  | `V`  |     | `118` | `166` | `76`  | `v`            |\n| `23`  | `27`  | `17`  | `ETB` (end of transmission block) |     | `55`  | `67`  | `37`  | `7`     |     | `87`  | `127` | `57`  | `W`  |     | `119` | `167` | `77`  | `w`            |\n| `24`  | `30`  | `18`  | `CAN` (cancel)                    |     | `56`  | `70`  | `38`  | `8`     |     | `88`  | `130` | `58`  | `X`  |     | `120` | `170` | `78`  | `x`            |\n| `25`  | `31`  | `19`  | `EM` (end of medium)              |     | `57`  | `71`  | `39`  | `9`     |     | `89`  | `131` | `59`  | `Y`  |     | `121` | `171` | `79`  | `y`            |\n| `26`  | `32`  | `1a`  | `SUB` (substitute)                |     | `58`  | `72`  | `3a`  | `:`     |     | `90`  | `132` | `5a`  | `Z`  |     | `122` | `172` | `7a`  | `z`            |\n| `27`  | `33`  | `1b`  | `ESC` (escape)                    |     | `59`  | `73`  | `3b`  | `;`     |     | `91`  | `133` | `5b`  | `[`  |     | `123` | `173` | `7b`  | `{`            |\n| `28`  | `34`  | `1c`  | `FS` (file separator)             |     | `60`  | `74`  | `3c`  | `<`     |     | `92`  | `134` | `5c`  | `\\ ` |     | `124` | `174` | `7c`  | `|`            |\n| `29`  | `35`  | `1d`  | `GS` (group separator)            |     | `61`  | `75`  | `3d`  | `=`     |     | `93`  | `135` | `5d`  | `]`  |     | `125` | `175` | `7d`  | `}`            |\n| `30`  | `36`  | `1e`  | `RS` (record separator)           |     | `62`  | `76`  | `3e`  | `>`     |     | `94`  | `136` | `5e`  | `^`  |     | `126` | `176` | `7e`  | `~`            |\n| `31`  | `37`  | `1f`  | `US` (unit separator)             |     | `63`  | `77`  | `3f`  | `?`     |     | `95`  | `137` | `5f`  | `_`  |     | `127` | `177` | `7f`  | `DEL` (delete) |\n\nNote: in Unicode, the ASCII character block is known as [`U+0000..U+007F` Basic Latin](https://www.unicode.org/charts/PDF/U0000.pdf).\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    puts(\"Printable ASCII:\");\n    for (int i = 32; i < 127; ++i) {\n        putchar(i);\n        putchar(i % 16 == 15 ? '\\n' : ' ');\n    }\n}\n```\n\nPossible output:\n\n```\nPrintable ASCII:\n  ! \" # $ % & ' ( ) * + , - . /\n0 1 2 3 4 5 6 7 8 9 : ; < = > ?\n@ A B C D E F G H I J K L M N O\nP Q R S T U V W X Y Z [ \\ ] ^ _\n` a b c d e f g h i j k l m n o\np q r s t u v w x y z { | } ~\n```\n\n### See also\n\n|                                                                                                            |     |\n|------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/ascii \"cpp/language/ascii\") for ASCII Chart |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/ascii](https://en.cppreference.com/w/c/language/ascii)"
- name: asctime
  summary: asctime returns a pointer to static data and is not thread-safe
  description: "# asctime, asctime_s\n\n[TABLE]\n\n1) Converts given calendar time [`tm`](tm \"c/chrono/tm\") to a textual representation of the following fixed 25-character form: `Www Mmm dd hh:mm:ss yyyy\\n`\n\n- `Www` - three-letter English abbreviated day of the week from `time_ptr->tm_wday`, one of `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`.\n- `Mmm` - three-letter English abbreviated month name from `time_ptr->tm_mon`, one of `Jan`, `Feb`, `Mar`, `Apr`, `May`, `Jun`, `Jul`, `Aug`, `Sep`, `Oct`, `Nov`, `Dec`.\n- `dd` - 2-digit day of the month from `timeptr->tm_mday` as if printed by [`sprintf`](../io/fprintf \"c/io/fprintf\") using `%2d`\n- `hh` - 2-digit hour from `timeptr->tm_hour` as if printed by [`sprintf`](../io/fprintf \"c/io/fprintf\") using `%.2d`\n- `mm` - 2-digit minute from `timeptr->tm_min` as if printed by [`sprintf`](../io/fprintf \"c/io/fprintf\") using `%.2d`\n- `ss` - 2-digit second from `timeptr->tm_sec` as if printed by [`sprintf`](../io/fprintf \"c/io/fprintf\") using `%.2d`\n- `yyyy` - 4-digit year from `timeptr->tm_year + 1900` as if printed by [`sprintf`](../io/fprintf \"c/io/fprintf\") using `%4d`\n\nThe behavior is undefined if any member of `*time_ptr` is outside its normal range\n\nThe behavior is undefined if the calendar year indicated by `time_ptr->tm_year` has more than 4 digits or is less than the year 1000.\n\nThe function does not support localization, and the newline character cannot be removed.\n\nThe function modifies static storage and is not thread-safe.\n\n|                                                                 |             |\n|-----------------------------------------------------------------|-------------|\n| This function is deprecated and should not be used in new code. | (since C23) |\n\n2) Same as (1), except that the message is written into user-provided storage `buf`, which is guaranteed to be null-terminated, and the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `buf` or `time_ptr` is a null pointer\n- `bufsz` is less than 26 or greater than `RSIZE_MAX`\n- not all members of `*time_ptr` are within their normal ranges\n- the year indicated by `time_ptr->tm_year` is less than 0 or greater than 9999\n\nAs with all bounds-checked functions, `asctime_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<time.h>`](../chrono \"c/chrono\").\n\n### Parameters\n\n|          |     |                                                                           |\n|----------|-----|---------------------------------------------------------------------------|\n| time_ptr | \\-  | pointer to a [`tm`](tm \"c/chrono/tm\") object specifying the time to print |\n| buf      | \\-  | pointer to a user-supplied buffer at least 26 bytes in length             |\n| bufsz    | \\-  | size of the user-supplied buffer                                          |\n\n### Return value\n\n1) pointer to a static null-terminated character string holding the textual representation of date and time as described above. The string may be shared between `asctime` and [`ctime`](ctime \"c/chrono/ctime\"), and may be overwritten on each invocation of any of those functions.\n\n2) zero on success, non-zero on failure, in which case `buf[0]` is set to zero (unless `buf` is a null pointer or `bufsz` is zero or greater than `RSIZE_MAX`).\n\n### Notes\n\n`asctime` returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends [`strftime`](strftime \"c/chrono/strftime\") instead. The C standard also recommends [`strftime`](strftime \"c/chrono/strftime\") instead of `asctime` and `asctime_s` because `strftime` is more flexible and locale-sensitive.\n\nPOSIX limits undefined behaviors only to when the output string would be longer than 25 characters, when `timeptr->tm_wday` or `timeptr->tm_mon` are not within the expected ranges, or when `timeptr->tm_year` exceeds `INT_MAX-1990`.\n\nSome implementations handle `timeptr->tm_mday==0` as meaning the last day of the preceding month.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <time.h>\n#include <stdio.h>\n \nint main(void)\n{\n    struct tm tm = *localtime(&(time_t){time(NULL)});\n    printf(\"%s\", asctime(&tm));\n \n#ifdef __STDC_LIB_EXT1__\n    char str[26];\n    asctime_s(str, sizeof str, &tm);\n    printf(\"%s\", str);\n#endif\n}\n```\n\nPossible output:\n\n```\nTue May 26 21:51:50 2015\nTue May 26 21:51:50 2015\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.2.1 The asctime function (p: 287)\n  - K.3.8.2.1 The asctime_s function (p: 453-454)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.2.1 The asctime function (p: 392-393)\n  - K.3.8.2.1 The asctime_s function (p: 624-625)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.1 The asctime function (p: 341-342)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.1 The asctime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/asctime](https://en.cppreference.com/w/c/chrono/asctime)"
- name: asctime_s
  summary: asctime returns a pointer to static data and is not thread-safe
  description: "# asctime, asctime_s\n\n[TABLE]\n\n1) Converts given calendar time [`tm`](tm \"c/chrono/tm\") to a textual representation of the following fixed 25-character form: `Www Mmm dd hh:mm:ss yyyy\\n`\n\n- `Www` - three-letter English abbreviated day of the week from `time_ptr->tm_wday`, one of `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`.\n- `Mmm` - three-letter English abbreviated month name from `time_ptr->tm_mon`, one of `Jan`, `Feb`, `Mar`, `Apr`, `May`, `Jun`, `Jul`, `Aug`, `Sep`, `Oct`, `Nov`, `Dec`.\n- `dd` - 2-digit day of the month from `timeptr->tm_mday` as if printed by [`sprintf`](../io/fprintf \"c/io/fprintf\") using `%2d`\n- `hh` - 2-digit hour from `timeptr->tm_hour` as if printed by [`sprintf`](../io/fprintf \"c/io/fprintf\") using `%.2d`\n- `mm` - 2-digit minute from `timeptr->tm_min` as if printed by [`sprintf`](../io/fprintf \"c/io/fprintf\") using `%.2d`\n- `ss` - 2-digit second from `timeptr->tm_sec` as if printed by [`sprintf`](../io/fprintf \"c/io/fprintf\") using `%.2d`\n- `yyyy` - 4-digit year from `timeptr->tm_year + 1900` as if printed by [`sprintf`](../io/fprintf \"c/io/fprintf\") using `%4d`\n\nThe behavior is undefined if any member of `*time_ptr` is outside its normal range\n\nThe behavior is undefined if the calendar year indicated by `time_ptr->tm_year` has more than 4 digits or is less than the year 1000.\n\nThe function does not support localization, and the newline character cannot be removed.\n\nThe function modifies static storage and is not thread-safe.\n\n|                                                                 |             |\n|-----------------------------------------------------------------|-------------|\n| This function is deprecated and should not be used in new code. | (since C23) |\n\n2) Same as (1), except that the message is written into user-provided storage `buf`, which is guaranteed to be null-terminated, and the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `buf` or `time_ptr` is a null pointer\n- `bufsz` is less than 26 or greater than `RSIZE_MAX`\n- not all members of `*time_ptr` are within their normal ranges\n- the year indicated by `time_ptr->tm_year` is less than 0 or greater than 9999\n\nAs with all bounds-checked functions, `asctime_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<time.h>`](../chrono \"c/chrono\").\n\n### Parameters\n\n|          |     |                                                                           |\n|----------|-----|---------------------------------------------------------------------------|\n| time_ptr | \\-  | pointer to a [`tm`](tm \"c/chrono/tm\") object specifying the time to print |\n| buf      | \\-  | pointer to a user-supplied buffer at least 26 bytes in length             |\n| bufsz    | \\-  | size of the user-supplied buffer                                          |\n\n### Return value\n\n1) pointer to a static null-terminated character string holding the textual representation of date and time as described above. The string may be shared between `asctime` and [`ctime`](ctime \"c/chrono/ctime\"), and may be overwritten on each invocation of any of those functions.\n\n2) zero on success, non-zero on failure, in which case `buf[0]` is set to zero (unless `buf` is a null pointer or `bufsz` is zero or greater than `RSIZE_MAX`).\n\n### Notes\n\n`asctime` returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends [`strftime`](strftime \"c/chrono/strftime\") instead. The C standard also recommends [`strftime`](strftime \"c/chrono/strftime\") instead of `asctime` and `asctime_s` because `strftime` is more flexible and locale-sensitive.\n\nPOSIX limits undefined behaviors only to when the output string would be longer than 25 characters, when `timeptr->tm_wday` or `timeptr->tm_mon` are not within the expected ranges, or when `timeptr->tm_year` exceeds `INT_MAX-1990`.\n\nSome implementations handle `timeptr->tm_mday==0` as meaning the last day of the preceding month.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <time.h>\n#include <stdio.h>\n \nint main(void)\n{\n    struct tm tm = *localtime(&(time_t){time(NULL)});\n    printf(\"%s\", asctime(&tm));\n \n#ifdef __STDC_LIB_EXT1__\n    char str[26];\n    asctime_s(str, sizeof str, &tm);\n    printf(\"%s\", str);\n#endif\n}\n```\n\nPossible output:\n\n```\nTue May 26 21:51:50 2015\nTue May 26 21:51:50 2015\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.2.1 The asctime function (p: 287)\n  - K.3.8.2.1 The asctime_s function (p: 453-454)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.2.1 The asctime function (p: 392-393)\n  - K.3.8.2.1 The asctime_s function (p: 624-625)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.1 The asctime function (p: 341-342)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.1 The asctime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/asctime](https://en.cppreference.com/w/c/chrono/asctime)"
- name: asin
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# asin, asinf, asinl\n\n[TABLE]\n\n1-6) Computes the principal values of the arc sine of `arg`.\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`asinl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`asin`) is called. Otherwise, (1) (`asinf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`casinf`](../complex/casin \"c/numeric/complex/casin\"), [`casin`](../complex/casin \"c/numeric/complex/casin\"), [`casinl`](../complex/casin \"c/numeric/complex/casin\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating-point value |\n\n### Return value\n\nIf no errors occur, the arc sine of `arg` (arcsin(arg)) in the range \\[-π/2 ; +π/2\\], is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is outside the range `[-1.0; 1.0]`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if \\|arg\\| \\> 1, a domain error occurs and NaN is returned;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    printf(\"asin( 1.0) = %+f, 2*asin( 1.0)=%+f\\n\", asin(1), 2 * asin(1));\n    printf(\"asin(-0.5) = %+f, 6*asin(-0.5)=%+f\\n\", asin(-0.5), 6 * asin(-0.5));\n \n    // special values\n    printf(\"asin(0.0) = %1f, asin(-0.0)=%f\\n\", asin(+0.0), asin(-0.0));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"asin(1.1) = %f\\n\", asin(1.1));\n    if (errno == EDOM)\n        perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nasin( 1.0) = +1.570796, 2*asin( 1.0)=+3.141593\nasin(-0.5) = -0.523599, 6*asin(-0.5)=-3.141593\nasin(0.0) = 0.000000, asin(-0.0)=-0.000000\nasin(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.2 The asin functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.2 The asin functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.2 The asin functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.2 The asin functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.2 The asin functions (p: 238)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.2 The asin functions (p: 518)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.2 The asin functions (p: 219)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.2 The asin functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.2 The asin function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/asin](https://en.cppreference.com/w/c/numeric/math/asin)"
- name: asinf
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# asin, asinf, asinl\n\n[TABLE]\n\n1-6) Computes the principal values of the arc sine of `arg`.\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`asinl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`asin`) is called. Otherwise, (1) (`asinf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`casinf`](../complex/casin \"c/numeric/complex/casin\"), [`casin`](../complex/casin \"c/numeric/complex/casin\"), [`casinl`](../complex/casin \"c/numeric/complex/casin\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating-point value |\n\n### Return value\n\nIf no errors occur, the arc sine of `arg` (arcsin(arg)) in the range \\[-π/2 ; +π/2\\], is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is outside the range `[-1.0; 1.0]`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if \\|arg\\| \\> 1, a domain error occurs and NaN is returned;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    printf(\"asin( 1.0) = %+f, 2*asin( 1.0)=%+f\\n\", asin(1), 2 * asin(1));\n    printf(\"asin(-0.5) = %+f, 6*asin(-0.5)=%+f\\n\", asin(-0.5), 6 * asin(-0.5));\n \n    // special values\n    printf(\"asin(0.0) = %1f, asin(-0.0)=%f\\n\", asin(+0.0), asin(-0.0));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"asin(1.1) = %f\\n\", asin(1.1));\n    if (errno == EDOM)\n        perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nasin( 1.0) = +1.570796, 2*asin( 1.0)=+3.141593\nasin(-0.5) = -0.523599, 6*asin(-0.5)=-3.141593\nasin(0.0) = 0.000000, asin(-0.0)=-0.000000\nasin(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.2 The asin functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.2 The asin functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.2 The asin functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.2 The asin functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.2 The asin functions (p: 238)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.2 The asin functions (p: 518)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.2 The asin functions (p: 219)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.2 The asin functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.2 The asin function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/asin](https://en.cppreference.com/w/c/numeric/math/asin)"
- name: asinh
  summary: If no errors occur, the inverse hyperbolic sine of arg (sinh-1(arg), or arsinh(arg)), is returned
  description: "# asinh, asinhf, asinhl\n\n[TABLE]\n\n1-3) Computes the inverse hyperbolic sine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `asinhl` is called. Otherwise, if the argument has integer type or the type `double`, `asinh` is called. Otherwise, `asinhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`casinhf`](http://en.cppreference.com/w/c/numeric/complex/casinh), [`casinh`](http://en.cppreference.com/w/c/numeric/complex/casinh), [`casinhl`](http://en.cppreference.com/w/c/numeric/complex/casinh)).\n\n### Parameters\n\n|     |     |                                                                   |\n|-----|-----|-------------------------------------------------------------------|\n| arg | \\-  | floating point value representing the area of a hyperbolic sector |\n\n### Return value\n\nIf no errors occur, the inverse hyperbolic sine of `arg` (sinh⁻¹(arg), or arsinh(arg)), is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0 or ±∞, it is returned unmodified\n- if the argument is NaN, NaN is returned\n\n### Notes\n\nAlthough the C standard names this function \"arc hyperbolic sine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic sine\" (used by POSIX) or \"area hyperbolic sine\".\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"asinh(1) = %f\\nasinh(-1) = %f\\n\", asinh(1), asinh(-1));\n    // special values\n    printf(\"asinh(+0) = %f\\nasinh(-0) = %f\\n\", asinh(0.0), asinh(-0.0));\n}\n```\n\nOutput:\n\n```\nasinh(1) = 0.881374\nasinh(-1) = -0.881374\nasinh(+0) = 0.000000\nasinh(-0) = -0.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.2 The asinh functions (p: 240-241)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.2 The asinh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.2 The asinh functions (p: 221)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.2 The asinh functions (p: 457)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                                    |\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Inverse Hyperbolic Sine.\"](https://mathworld.wolfram.com/InverseHyperbolicSine.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/asinh](https://en.cppreference.com/w/c/numeric/math/asinh)"
- name: asinhf
  summary: If no errors occur, the inverse hyperbolic sine of arg (sinh-1(arg), or arsinh(arg)), is returned
  description: "# asinh, asinhf, asinhl\n\n[TABLE]\n\n1-3) Computes the inverse hyperbolic sine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `asinhl` is called. Otherwise, if the argument has integer type or the type `double`, `asinh` is called. Otherwise, `asinhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`casinhf`](http://en.cppreference.com/w/c/numeric/complex/casinh), [`casinh`](http://en.cppreference.com/w/c/numeric/complex/casinh), [`casinhl`](http://en.cppreference.com/w/c/numeric/complex/casinh)).\n\n### Parameters\n\n|     |     |                                                                   |\n|-----|-----|-------------------------------------------------------------------|\n| arg | \\-  | floating point value representing the area of a hyperbolic sector |\n\n### Return value\n\nIf no errors occur, the inverse hyperbolic sine of `arg` (sinh⁻¹(arg), or arsinh(arg)), is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0 or ±∞, it is returned unmodified\n- if the argument is NaN, NaN is returned\n\n### Notes\n\nAlthough the C standard names this function \"arc hyperbolic sine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic sine\" (used by POSIX) or \"area hyperbolic sine\".\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"asinh(1) = %f\\nasinh(-1) = %f\\n\", asinh(1), asinh(-1));\n    // special values\n    printf(\"asinh(+0) = %f\\nasinh(-0) = %f\\n\", asinh(0.0), asinh(-0.0));\n}\n```\n\nOutput:\n\n```\nasinh(1) = 0.881374\nasinh(-1) = -0.881374\nasinh(+0) = 0.000000\nasinh(-0) = -0.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.2 The asinh functions (p: 240-241)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.2 The asinh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.2 The asinh functions (p: 221)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.2 The asinh functions (p: 457)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                                    |\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Inverse Hyperbolic Sine.\"](https://mathworld.wolfram.com/InverseHyperbolicSine.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/asinh](https://en.cppreference.com/w/c/numeric/math/asinh)"
- name: asinhl
  summary: If no errors occur, the inverse hyperbolic sine of arg (sinh-1(arg), or arsinh(arg)), is returned
  description: "# asinh, asinhf, asinhl\n\n[TABLE]\n\n1-3) Computes the inverse hyperbolic sine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `asinhl` is called. Otherwise, if the argument has integer type or the type `double`, `asinh` is called. Otherwise, `asinhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`casinhf`](http://en.cppreference.com/w/c/numeric/complex/casinh), [`casinh`](http://en.cppreference.com/w/c/numeric/complex/casinh), [`casinhl`](http://en.cppreference.com/w/c/numeric/complex/casinh)).\n\n### Parameters\n\n|     |     |                                                                   |\n|-----|-----|-------------------------------------------------------------------|\n| arg | \\-  | floating point value representing the area of a hyperbolic sector |\n\n### Return value\n\nIf no errors occur, the inverse hyperbolic sine of `arg` (sinh⁻¹(arg), or arsinh(arg)), is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0 or ±∞, it is returned unmodified\n- if the argument is NaN, NaN is returned\n\n### Notes\n\nAlthough the C standard names this function \"arc hyperbolic sine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic sine\" (used by POSIX) or \"area hyperbolic sine\".\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"asinh(1) = %f\\nasinh(-1) = %f\\n\", asinh(1), asinh(-1));\n    // special values\n    printf(\"asinh(+0) = %f\\nasinh(-0) = %f\\n\", asinh(0.0), asinh(-0.0));\n}\n```\n\nOutput:\n\n```\nasinh(1) = 0.881374\nasinh(-1) = -0.881374\nasinh(+0) = 0.000000\nasinh(-0) = -0.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.2 The asinh functions (p: 240-241)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.2 The asinh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.2 The asinh functions (p: 221)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.2 The asinh functions (p: 457)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                                    |\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Inverse Hyperbolic Sine.\"](https://mathworld.wolfram.com/InverseHyperbolicSine.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/asinh](https://en.cppreference.com/w/c/numeric/math/asinh)"
- name: asinl
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# asin, asinf, asinl\n\n[TABLE]\n\n1-6) Computes the principal values of the arc sine of `arg`.\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`asinl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`asin`) is called. Otherwise, (1) (`asinf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`casinf`](../complex/casin \"c/numeric/complex/casin\"), [`casin`](../complex/casin \"c/numeric/complex/casin\"), [`casinl`](../complex/casin \"c/numeric/complex/casin\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating-point value |\n\n### Return value\n\nIf no errors occur, the arc sine of `arg` (arcsin(arg)) in the range \\[-π/2 ; +π/2\\], is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is outside the range `[-1.0; 1.0]`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if \\|arg\\| \\> 1, a domain error occurs and NaN is returned;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    printf(\"asin( 1.0) = %+f, 2*asin( 1.0)=%+f\\n\", asin(1), 2 * asin(1));\n    printf(\"asin(-0.5) = %+f, 6*asin(-0.5)=%+f\\n\", asin(-0.5), 6 * asin(-0.5));\n \n    // special values\n    printf(\"asin(0.0) = %1f, asin(-0.0)=%f\\n\", asin(+0.0), asin(-0.0));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"asin(1.1) = %f\\n\", asin(1.1));\n    if (errno == EDOM)\n        perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nasin( 1.0) = +1.570796, 2*asin( 1.0)=+3.141593\nasin(-0.5) = -0.523599, 6*asin(-0.5)=-3.141593\nasin(0.0) = 0.000000, asin(-0.0)=-0.000000\nasin(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.2 The asin functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.2 The asin functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.2 The asin functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.2 The asin functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.2 The asin functions (p: 238)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.2 The asin functions (p: 518)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.2 The asin functions (p: 219)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.2 The asin functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.2 The asin function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/asin](https://en.cppreference.com/w/c/numeric/math/asin)"
- name: assert
  summary: The definition of the macro assert depends on another macro, NDEBUG, which is not defined by the standard library
  description: "# assert\n\n[TABLE]\n\nThe definition of the macro `assert` depends on another macro, `NDEBUG`, which is not defined by the standard library.\n\nIf `NDEBUG` is defined as a macro name at the point in the source code where `<assert.h>` is included, then `assert` does nothing.\n\nIf `NDEBUG` is not defined, then `assert` checks if its argument (which must have scalar type) compares equal to zero. If it does, `assert` outputs implementation-specific diagnostic information on the standard error output and calls [`abort`](http://en.cppreference.com/w/c/program/abort)`(``)`. The diagnostic information is required to include the text of `expression`, as well as the values of the [predefined variable](../language/function_definition \"c/language/function definition\") `__func__` and of(since C99) the [predefined macros](../preprocessor/replace \"c/preprocessor/replace\") `__FILE__` and `__LINE__`.\n\n### Parameters\n\n|           |     |                           |\n|-----------|-----|---------------------------|\n| condition | \\-  | expression of scalar type |\n\n### Return value\n\n(none)\n\n### Notes\n\nThere is no standardized interface to add an additional message to `assert` errors. A portable way to include one is to use a [comma operator](../language/operator_other#Comma_operator \"c/language/operator other\"):\n\n```\nassert((\"There are five lights\", 2 + 2 == 5));\n```\n\nThe implementation of `assert` in [Microsoft CRT](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/assert-macro-assert-wassert?view=msvc-160) does not conform to C99 and later revisions, because its underlying function (`_wassert`) takes neither `__func__` nor an equivalent replacement.\n\n### Example\n\n```\n#include <stdio.h>\n// uncomment to disable assert()\n// #define NDEBUG\n#include <assert.h>\n#include <math.h>\n \nint main(void)\n{\n    double x = -1.0;\n    assert(x >= 0.0);\n    printf(\"sqrt(x) = %f\\n\", sqrt(x));   \n \n    return 0;\n}\n```\n\nOutput:\n\n```\noutput with NDEBUG not defined:\na.out: main.cpp:10: main: Assertion `x >= 0.0' failed.\n \noutput with NDEBUG defined:\nsqrt(x) = -nan\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.2.1.1 The assert macro (p: 135)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.2.1.1 The assert macro (p: 186-187)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.2.1.1 The assert macro (p: 169)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.2.1.1 The assert macro\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/error/assert](https://en.cppreference.com/w/c/error/assert)"
- name: Assignment operators
  summary: Assignment and compound assignment operators are binary operators that modify the variable to their left using the value to their right
  description: "# Assignment operators\n\nAssignment and compound assignment operators are binary operators that modify the variable to their left using the value to their right.\n\n| Operator | Operator name                  | Example   | Description                                                    | Equivalent of |\n|----------|--------------------------------|-----------|----------------------------------------------------------------|---------------|\n| `=`      | basic assignment               | `a = b`   | **a** becomes equal to **b**                                   | N/A           |\n| `+=`     | addition assignment            | `a += b`  | **a** becomes equal to the addition of **a** and **b**         | `a = a + b`   |\n| `-=`     | subtraction assignment         | `a -= b`  | **a** becomes equal to the subtraction of **b** from **a**     | `a = a - b`   |\n| `*=`     | multiplication assignment      | `a *= b`  | **a** becomes equal to the product of **a** and **b**          | `a = a * b`   |\n| `/=`     | division assignment            | `a /= b`  | **a** becomes equal to the division of **a** by **b**          | `a = a / b`   |\n| `%=`     | modulo assignment              | `a %= b`  | **a** becomes equal to the remainder of **a** divided by **b** | `a = a % b`   |\n| `&=`     | bitwise AND assignment         | `a &= b`  | **a** becomes equal to the bitwise AND of **a** and **b**      | `a = a & b`   |\n| `|=`     | bitwise OR assignment          | `a |= b`  | **a** becomes equal to the bitwise OR of **a** and **b**       | `a = a | b`   |\n| `^=`     | bitwise XOR assignment         | `a ^= b`  | **a** becomes equal to the bitwise XOR of **a** and **b**      | `a = a ^ b`   |\n| `<<=`    | bitwise left shift assignment  | `a <<= b` | **a** becomes equal to **a** left shifted by **b**             | `a = a << b`  |\n| `>>=`    | bitwise right shift assignment | `a >>= b` | **a** becomes equal to **a** right shifted by **b**            | `a = a >> b`  |\n\n### Simple assignment\n\nThe simple assignment operator expressions have the form\n\n|             |     |     |\n|-------------|-----|-----|\n| lhs `=` rhs |     |     |\n\nwhere\n\n|     |     |                                                                                                                                                              |\n|-----|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| lhs | \\-  | [modifiable lvalue](value_category \"c/language/value category\") expression of any complete object type                                                       |\n| rhs | \\-  | expression of any type [implicitly convertible](conversion \"c/language/conversion\") to lhs or [compatible](type#Compatible_types \"c/language/type\") with lhs |\n\nAssignment performs [implicit conversion](conversion \"c/language/conversion\") from the value of rhs to the type of lhs and then replaces the value in the object designated by lhs with the converted value of rhs.\n\nAssignment also returns the same value as what was stored in `lhs` (so that expressions such as `a = b = c` are possible). The [value category](value_category \"c/language/value category\") of the assignment operator is non-lvalue (so that expressions such as `(a=b)=c` are invalid).\n\nrhs and lhs must satisfy one of the following:\n\n- both lhs and rhs have [compatible](type#Compatible_types \"c/language/type\") [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") type, or..\n- rhs must be [implicitly convertible](conversion \"c/language/conversion\") to lhs, which implies\n  - both lhs and rhs have [arithmetic types](arithmetic_types \"c/language/arithmetic types\"), in which case lhs may be [volatile](volatile \"c/language/volatile\")-qualified or [atomic](atomic \"c/language/atomic\")(since C11)\n  - both lhs and rhs have [pointer](pointer \"c/language/pointer\") to [compatible](type#Compatible_types \"c/language/type\") (ignoring qualifiers) types, or one of the pointers is a pointer to void, and the [conversion](conversion \"c/language/conversion\") would not add qualifiers to the pointed-to type. lhs may be [volatile](volatile \"c/language/volatile\") or [restrict](restrict \"c/language/restrict\")(since C99)-qualified or [atomic](atomic \"c/language/atomic\")(since C11).\n  - lhs is a (possibly qualified or atomic(since C11)) pointer and rhs is a null pointer constant such as [`NULL`](../types/null \"c/types/NULL\") or a [`nullptr_t`](../types/nullptr_t \"c/types/nullptr t\") value(since C23)\n\n[TABLE]\n\n[TABLE]\n\n#### Notes\n\nIf rhs and lhs overlap in memory (e.g. they are members of the same union), the behavior is undefined unless the overlap is exact and the types are [compatible](type#Compatible_types \"c/language/type\").\n\nAlthough arrays are not assignable, an array wrapped in a struct is assignable to another object of the same (or compatible) struct type.\n\nThe side effect of updating lhs is [sequenced after](eval_order \"c/language/eval order\") the value computations, but not the side effects of lhs and rhs themselves and the evaluations of the operands are, as usual, unsequenced relative to each other (so the expressions such as `i=++i`; are undefined)\n\nAssignment strips extra range and precision from floating-point expressions (see [`FLT_EVAL_METHOD`](../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\")).\n\nIn C++, assignment operators are lvalue expressions, not so in C.\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    // integers\n    int i = 1, j = 2, k = 3; // initialization, not assignment\n \n    i = j = k;   // values of i and j are now 3\n//  (i = j) = k; // Error: lvalue required\n    printf(\"%d %d %d\\n\", i, j, k);\n \n    // pointers\n    const char c = 'A'; // initialization; not assignment\n    const char *p = &c;  // initialization; not assignment\n    const char **cpp = &p; // initialization; not assignment\n \n//  cpp = &p;   // Error: char** is not convertible to const char**\n    *cpp = &c;  // OK, char* is convertible to const char*\n    printf(\"%c \\n\", **cpp);\n    cpp = 0;    // OK, null pointer constant is convertible to any pointer\n \n    // arrays\n    int arr1[2] = {1,2}, arr2[2] = {3, 4};\n//  arr1 = arr2; // Error: cannot assign to an array\n    printf(\"arr1[0]=%d arr1[1]=%d arr2[0]=%d arr2[1]=%d\\n\",\n            arr1[0],   arr1[1],   arr2[0],   arr2[1]);\n \n    struct { int arr[2]; } sam1 = { {5, 6} }, sam2 = { {7, 8} };\n    sam1 = sam2; // OK: can assign arrays wrapped in structs\n \n    printf(\"%d %d \\n\", sam1.arr[0], sam1.arr[1]);\n}\n```\n\nOutput:\n\n```\n3 3 3\nA\narr1[0]=1 arr1[1]=2 arr2[0]=3 arr2[1]=4\n7 8\n```\n\n### Compound assignment\n\nThe compound assignment operator expressions have the form\n\n|            |     |     |\n|------------|-----|-----|\n| lhs op rhs |     |     |\n\nwhere\n\n|          |     |                                                                                                                                                                                                                                   |\n|----------|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| op       | \\-  | one of `*=`, `/=` `%=`, `+=` `-=`, `<<=`, `>>=`, `&=`, `^=`, `|=`                                                                                                                                                                 |\n| lhs, rhs | \\-  | expressions with [arithmetic types](arithmetic_types \"c/language/arithmetic types\") (where lhs may be qualified or atomic), except when op is `+=` or `-=`, which also accept pointer types with the same restrictions as + and - |\n\nThe expression lhs @= rhs is exactly the same as lhs `=` lhs @ `(` rhs `)`, except that lhs is evaluated only once.\n\n[TABLE]\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    int x = 10; \n    int hundred = 100; \n    int ten = 10; \n    int fifty = 50; \n \n    printf(\"%d %d %d %d\\n\", x, hundred, ten, fifty);\n \n    hundred *= x; \n    ten     /= x; \n    fifty   %= x; \n \n    printf(\"%d %d %d %d\\n\", x, hundred, ten, fifty);\n \n    return 0;\n}\n```\n\nOutput:\n\n```\n10 100 10 50\n10 1000 1 0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.16 Assignment operators (p: 72-73)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.16 Assignment operators (p: 101-104)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5.16 Assignment operators (p: 91-93)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.3.16 Assignment operators\n\n### See Also\n\n[Operator precedence](operator_precedence \"c/language/operator precedence\")\n\n[TABLE]\n\n### See also\n\n|                                                                                                                                                 |     |\n|-------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/operator_assignment \"cpp/language/operator assignment\") for Assignment operators |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/operator_assignment](https://en.cppreference.com/w/c/language/operator_assignment)"
- name: at_quick_exit
  summary: Registers the function pointed to by func to be called on quick program termination (via quick_exit)
  description: "# at_quick_exit\n\n[TABLE]\n\nRegisters the function pointed to by `func` to be called on quick program termination (via [`quick_exit`](quick_exit \"c/program/quick exit\")).\n\nCalling the function from several threads does not induce a data race. The implementation is guaranteed to support the registration of at least 32 functions. The exact limit is implementation-defined.\n\nThe registered functions will not be called on [normal program termination](exit \"c/program/exit\"). If a function need to be called in that case, [`atexit`](atexit \"c/program/atexit\") must be used.\n\n### Parameters\n\n|      |     |                                                                 |\n|------|-----|-----------------------------------------------------------------|\n| func | \\-  | pointer to a function to be called on quick program termination |\n\n### Return value\n\n`​0​` if the registration succeeds, nonzero value otherwise.\n\n### Example\n\n```\n#include <stdlib.h>\n#include <stdio.h>\n \nvoid f1(void)\n{\n    puts(\"pushed first\");\n    fflush(stdout);\n}\n \nvoid f2(void)\n{\n    puts(\"pushed second\");\n}\n \nint main(void)\n{\n    at_quick_exit(f1);\n    at_quick_exit(f2);\n    quick_exit(0);\n}\n```\n\nOutput:\n\n```\npushed second\npushed first\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.4.3 The at_quick_exit function (p: 255)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.4.3 The at_quick_exit function (p: 351)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/at_quick_exit](https://en.cppreference.com/w/c/program/at_quick_exit)"
- name: atan
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# atan, atanf, atanl\n\n[TABLE]\n\n1-6) Computes the principal value of the arc tangent of `arg`.\n\n7) Type-generic macro: If the argument has type `long double`, (3) (atanl) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`atan`) is called. Otherwise, (1) (`atanf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`catanf`](../complex/catan \"c/numeric/complex/catan\"), [`catan`](../complex/catan \"c/numeric/complex/catan\"), [`catanl`](../complex/catan \"c/numeric/complex/catan\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the arc tangent of `arg` (arctan(arg)) in the range \\[- π/2 ; +π/2\\] radians, is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is +∞, +π/2 is returned;\n- if the argument is -∞, -π/2 is returned;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/atan.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"atan(1) = %f, 4*atan(1)=%f\\n\", atan(1), 4 * atan(1));\n    // special values\n    printf(\"atan(Inf) = %f, 2*atan(Inf) = %f\\n\", atan(INFINITY), 2 * atan(INFINITY));\n    printf(\"atan(-0.0) = %+f, atan(+0.0) = %+f\\n\", atan(-0.0), atan(0));\n}\n```\n\nOutput:\n\n```\natan(1) = 0.785398, 4*atan(1)=3.141593\natan(Inf) = 1.570796, 2*atan(Inf) = 3.141593\natan(-0.0) = -0.000000, atan(+0.0) = +0.000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.3 The atan functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.3 The atan functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.3 The atan functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.3 The atan functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.3 The atan functions (p: 238-239)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.3 The atan functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.3 The atan functions (p: 219)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.3 The atan functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.3 The atan function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/atan](https://en.cppreference.com/w/c/numeric/math/atan)"
- name: atan2
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# atan2, atan2f, atan2l\n\n[TABLE]\n\n1-6) Computes the arc tangent of `y / x` using the signs of arguments to determine the correct quadrant.\n\n7) Type-generic macro: If any argument has type `long double`, (3) (`atan2l`) is called. Otherwise, if any argument has integer type or has type `double`, (2) (`atan2`) is called. Otherwise, (1) (`atan2f`) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|      |     |                      |\n|------|-----|----------------------|\n| x, y | \\-  | floating-point value |\n\n### Return value\n\nIf no errors occur, the arc tangent of `y / x` (arctan(y/x)) in the range \\[-π ; +π\\] radians, is returned.\n\nY argument\n\nReturn value\n\n[](https://en.cppreference.com/w/File:math-atan2.png)\n\nX argument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `x` and `y` are both zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- If `x` and `y` are both zero, domain error *does not* occur;\n- If `x` and `y` are both zero, range error does not occur either;\n- If `y` is zero, pole error does not occur;\n- If `y` is `±0` and `x` is negative or `-0`, `±π` is returned;\n- If `y` is `±0` and `x` is positive or `+0`, `±0` is returned;\n- If `y` is `±∞` and `x` is finite, `±π/2` is returned;\n- If `y` is `±∞` and `x` is `-∞`, `±3π/4` is returned;\n- If `y` is `±∞` and `x` is `+∞`, `±π/4` is returned;\n- If `x` is `±0` and `y` is negative, `-π/2` is returned;\n- If `x` is `±0` and `y` is positive, `+π/2` is returned;\n- If `x` is `-∞` and `y` is finite and positive, `+π` is returned;\n- If `x` is `-∞` and `y` is finite and negative, `-π` is returned;\n- If `x` is `+∞` and `y` is finite and positive, `+0` is returned;\n- If `x` is `+∞` and `y` is finite and negative, `-0` is returned;\n- If either `x` is NaN or `y` is NaN, NaN is returned.\n\n### Notes\n\n`atan2(y, x)` is equivalent to [`carg`](http://en.cppreference.com/w/c/numeric/complex/carg)`(``x ``+`` I``*``y``)`.\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/atan2.html) that in case of underflow, `y / x` is the value returned, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    // normal usage: the signs of the two arguments determine the quadrant\n    // atan2(1,1) = +pi/4, Quad I\n    printf(\"(+1,+1) cartesian is (%f,%f) polar\\n\", hypot( 1, 1), atan2( 1, 1));\n    // atan2(1, -1) = +3pi/4, Quad II\n    printf(\"(+1,-1) cartesian is (%f,%f) polar\\n\", hypot( 1,-1), atan2( 1,-1));\n    // atan2(-1,-1) = -3pi/4, Quad III\n    printf(\"(-1,-1) cartesian is (%f,%f) polar\\n\", hypot(-1,-1), atan2(-1,-1));\n    // atan2(-1,-1) = -pi/4, Quad IV\n    printf(\"(-1,+1) cartesian is (%f,%f) polar\\n\", hypot(-1, 1), atan2(-1, 1));\n \n    // special values\n    printf(\"atan2(0, 0) = %f atan2(0, -0)=%f\\n\", atan2(0,0), atan2(0,-0.0));\n    printf(\"atan2(7, 0) = %f atan2(7, -0)=%f\\n\", atan2(7,0), atan2(7,-0.0));\n}\n```\n\nOutput:\n\n```\n(+1,+1) cartesian is (1.414214,0.785398) polar\n(+1,-1) cartesian is (1.414214,2.356194) polar\n(-1,-1) cartesian is (1.414214,-2.356194) polar\n(-1,+1) cartesian is (1.414214,-0.785398) polar\natan2(0, 0) = 0.000000 atan2(0, -0)=3.141593\natan2(7, 0) = 1.570796 atan2(7, -0)=1.570796\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.4 The atan2 functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.4 The atan2 functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.4 The atan2 functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.4 The atan2 functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.4 The atan2 functions (p: 239)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.4 The atan2 functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.4 The atan2 functions (p: 219)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.4 The atan2 functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.4 The atan2 function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/atan2](https://en.cppreference.com/w/c/numeric/math/atan2)"
- name: atan2f
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# atan2, atan2f, atan2l\n\n[TABLE]\n\n1-6) Computes the arc tangent of `y / x` using the signs of arguments to determine the correct quadrant.\n\n7) Type-generic macro: If any argument has type `long double`, (3) (`atan2l`) is called. Otherwise, if any argument has integer type or has type `double`, (2) (`atan2`) is called. Otherwise, (1) (`atan2f`) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|      |     |                      |\n|------|-----|----------------------|\n| x, y | \\-  | floating-point value |\n\n### Return value\n\nIf no errors occur, the arc tangent of `y / x` (arctan(y/x)) in the range \\[-π ; +π\\] radians, is returned.\n\nY argument\n\nReturn value\n\n[](https://en.cppreference.com/w/File:math-atan2.png)\n\nX argument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `x` and `y` are both zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- If `x` and `y` are both zero, domain error *does not* occur;\n- If `x` and `y` are both zero, range error does not occur either;\n- If `y` is zero, pole error does not occur;\n- If `y` is `±0` and `x` is negative or `-0`, `±π` is returned;\n- If `y` is `±0` and `x` is positive or `+0`, `±0` is returned;\n- If `y` is `±∞` and `x` is finite, `±π/2` is returned;\n- If `y` is `±∞` and `x` is `-∞`, `±3π/4` is returned;\n- If `y` is `±∞` and `x` is `+∞`, `±π/4` is returned;\n- If `x` is `±0` and `y` is negative, `-π/2` is returned;\n- If `x` is `±0` and `y` is positive, `+π/2` is returned;\n- If `x` is `-∞` and `y` is finite and positive, `+π` is returned;\n- If `x` is `-∞` and `y` is finite and negative, `-π` is returned;\n- If `x` is `+∞` and `y` is finite and positive, `+0` is returned;\n- If `x` is `+∞` and `y` is finite and negative, `-0` is returned;\n- If either `x` is NaN or `y` is NaN, NaN is returned.\n\n### Notes\n\n`atan2(y, x)` is equivalent to [`carg`](http://en.cppreference.com/w/c/numeric/complex/carg)`(``x ``+`` I``*``y``)`.\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/atan2.html) that in case of underflow, `y / x` is the value returned, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    // normal usage: the signs of the two arguments determine the quadrant\n    // atan2(1,1) = +pi/4, Quad I\n    printf(\"(+1,+1) cartesian is (%f,%f) polar\\n\", hypot( 1, 1), atan2( 1, 1));\n    // atan2(1, -1) = +3pi/4, Quad II\n    printf(\"(+1,-1) cartesian is (%f,%f) polar\\n\", hypot( 1,-1), atan2( 1,-1));\n    // atan2(-1,-1) = -3pi/4, Quad III\n    printf(\"(-1,-1) cartesian is (%f,%f) polar\\n\", hypot(-1,-1), atan2(-1,-1));\n    // atan2(-1,-1) = -pi/4, Quad IV\n    printf(\"(-1,+1) cartesian is (%f,%f) polar\\n\", hypot(-1, 1), atan2(-1, 1));\n \n    // special values\n    printf(\"atan2(0, 0) = %f atan2(0, -0)=%f\\n\", atan2(0,0), atan2(0,-0.0));\n    printf(\"atan2(7, 0) = %f atan2(7, -0)=%f\\n\", atan2(7,0), atan2(7,-0.0));\n}\n```\n\nOutput:\n\n```\n(+1,+1) cartesian is (1.414214,0.785398) polar\n(+1,-1) cartesian is (1.414214,2.356194) polar\n(-1,-1) cartesian is (1.414214,-2.356194) polar\n(-1,+1) cartesian is (1.414214,-0.785398) polar\natan2(0, 0) = 0.000000 atan2(0, -0)=3.141593\natan2(7, 0) = 1.570796 atan2(7, -0)=1.570796\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.4 The atan2 functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.4 The atan2 functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.4 The atan2 functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.4 The atan2 functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.4 The atan2 functions (p: 239)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.4 The atan2 functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.4 The atan2 functions (p: 219)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.4 The atan2 functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.4 The atan2 function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/atan2](https://en.cppreference.com/w/c/numeric/math/atan2)"
- name: atan2l
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# atan2, atan2f, atan2l\n\n[TABLE]\n\n1-6) Computes the arc tangent of `y / x` using the signs of arguments to determine the correct quadrant.\n\n7) Type-generic macro: If any argument has type `long double`, (3) (`atan2l`) is called. Otherwise, if any argument has integer type or has type `double`, (2) (`atan2`) is called. Otherwise, (1) (`atan2f`) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|      |     |                      |\n|------|-----|----------------------|\n| x, y | \\-  | floating-point value |\n\n### Return value\n\nIf no errors occur, the arc tangent of `y / x` (arctan(y/x)) in the range \\[-π ; +π\\] radians, is returned.\n\nY argument\n\nReturn value\n\n[](https://en.cppreference.com/w/File:math-atan2.png)\n\nX argument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `x` and `y` are both zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- If `x` and `y` are both zero, domain error *does not* occur;\n- If `x` and `y` are both zero, range error does not occur either;\n- If `y` is zero, pole error does not occur;\n- If `y` is `±0` and `x` is negative or `-0`, `±π` is returned;\n- If `y` is `±0` and `x` is positive or `+0`, `±0` is returned;\n- If `y` is `±∞` and `x` is finite, `±π/2` is returned;\n- If `y` is `±∞` and `x` is `-∞`, `±3π/4` is returned;\n- If `y` is `±∞` and `x` is `+∞`, `±π/4` is returned;\n- If `x` is `±0` and `y` is negative, `-π/2` is returned;\n- If `x` is `±0` and `y` is positive, `+π/2` is returned;\n- If `x` is `-∞` and `y` is finite and positive, `+π` is returned;\n- If `x` is `-∞` and `y` is finite and negative, `-π` is returned;\n- If `x` is `+∞` and `y` is finite and positive, `+0` is returned;\n- If `x` is `+∞` and `y` is finite and negative, `-0` is returned;\n- If either `x` is NaN or `y` is NaN, NaN is returned.\n\n### Notes\n\n`atan2(y, x)` is equivalent to [`carg`](http://en.cppreference.com/w/c/numeric/complex/carg)`(``x ``+`` I``*``y``)`.\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/atan2.html) that in case of underflow, `y / x` is the value returned, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    // normal usage: the signs of the two arguments determine the quadrant\n    // atan2(1,1) = +pi/4, Quad I\n    printf(\"(+1,+1) cartesian is (%f,%f) polar\\n\", hypot( 1, 1), atan2( 1, 1));\n    // atan2(1, -1) = +3pi/4, Quad II\n    printf(\"(+1,-1) cartesian is (%f,%f) polar\\n\", hypot( 1,-1), atan2( 1,-1));\n    // atan2(-1,-1) = -3pi/4, Quad III\n    printf(\"(-1,-1) cartesian is (%f,%f) polar\\n\", hypot(-1,-1), atan2(-1,-1));\n    // atan2(-1,-1) = -pi/4, Quad IV\n    printf(\"(-1,+1) cartesian is (%f,%f) polar\\n\", hypot(-1, 1), atan2(-1, 1));\n \n    // special values\n    printf(\"atan2(0, 0) = %f atan2(0, -0)=%f\\n\", atan2(0,0), atan2(0,-0.0));\n    printf(\"atan2(7, 0) = %f atan2(7, -0)=%f\\n\", atan2(7,0), atan2(7,-0.0));\n}\n```\n\nOutput:\n\n```\n(+1,+1) cartesian is (1.414214,0.785398) polar\n(+1,-1) cartesian is (1.414214,2.356194) polar\n(-1,-1) cartesian is (1.414214,-2.356194) polar\n(-1,+1) cartesian is (1.414214,-0.785398) polar\natan2(0, 0) = 0.000000 atan2(0, -0)=3.141593\natan2(7, 0) = 1.570796 atan2(7, -0)=1.570796\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.4 The atan2 functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.4 The atan2 functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.4 The atan2 functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.4 The atan2 functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.4 The atan2 functions (p: 239)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.4 The atan2 functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.4 The atan2 functions (p: 219)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.4 The atan2 functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.4 The atan2 function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/atan2](https://en.cppreference.com/w/c/numeric/math/atan2)"
- name: atanf
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# atan, atanf, atanl\n\n[TABLE]\n\n1-6) Computes the principal value of the arc tangent of `arg`.\n\n7) Type-generic macro: If the argument has type `long double`, (3) (atanl) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`atan`) is called. Otherwise, (1) (`atanf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`catanf`](../complex/catan \"c/numeric/complex/catan\"), [`catan`](../complex/catan \"c/numeric/complex/catan\"), [`catanl`](../complex/catan \"c/numeric/complex/catan\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the arc tangent of `arg` (arctan(arg)) in the range \\[- π/2 ; +π/2\\] radians, is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is +∞, +π/2 is returned;\n- if the argument is -∞, -π/2 is returned;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/atan.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"atan(1) = %f, 4*atan(1)=%f\\n\", atan(1), 4 * atan(1));\n    // special values\n    printf(\"atan(Inf) = %f, 2*atan(Inf) = %f\\n\", atan(INFINITY), 2 * atan(INFINITY));\n    printf(\"atan(-0.0) = %+f, atan(+0.0) = %+f\\n\", atan(-0.0), atan(0));\n}\n```\n\nOutput:\n\n```\natan(1) = 0.785398, 4*atan(1)=3.141593\natan(Inf) = 1.570796, 2*atan(Inf) = 3.141593\natan(-0.0) = -0.000000, atan(+0.0) = +0.000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.3 The atan functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.3 The atan functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.3 The atan functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.3 The atan functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.3 The atan functions (p: 238-239)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.3 The atan functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.3 The atan functions (p: 219)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.3 The atan functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.3 The atan function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/atan](https://en.cppreference.com/w/c/numeric/math/atan)"
- name: atanh
  summary: If no errors occur, the inverse hyperbolic tangent of arg (tanh-1(arg), or artanh(arg)), is returned
  description: "# atanh, atanhf, atanhl\n\n[TABLE]\n\n1-3) Computes the inverse hyperbolic tangent of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `atanhl` is called. Otherwise, if the argument has integer type or the type `double`, `atanh` is called. Otherwise, `atanhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`catanhf`](http://en.cppreference.com/w/c/numeric/complex/catanh), [`catanh`](http://en.cppreference.com/w/c/numeric/complex/catanh), [`catanhl`](http://en.cppreference.com/w/c/numeric/complex/catanh)).\n\n### Parameters\n\n|     |     |                                                                   |\n|-----|-----|-------------------------------------------------------------------|\n| arg | \\-  | floating point value representing the area of a hyperbolic sector |\n\n### Return value\n\nIf no errors occur, the inverse hyperbolic tangent of `arg` (tanh⁻¹(arg), or artanh(arg)), is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned (with the correct sign).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the argument is not on the interval \\[-1, +1\\], a range error occurs.\n\nIf the argument is ±1, a pole error occurs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0, it is returned unmodified\n- if the argument is ±1, ±∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- if \\|arg\\|\\>1, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nAlthough the C standard names this function \"arc hyperbolic tangent\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic tangent\" (used by POSIX) or \"area hyperbolic tangent\".\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/atanh.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"atanh(0) = %f\\natanh(-0) = %f\\n\", atanh(0), atanh(-0.0));\n    printf(\"atanh(0.9) = %f\\n\", atanh(0.9));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"atanh(-1) = %f\\n\", atanh(-1));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_DIVBYZERO))\n        puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\natanh(0) = 0.000000\natanh(-0) = -0.000000\natanh(0.9) = 1.472219\natanh(-1) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.3 The atanh functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.2.3 The atanh functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.3 The atanh functions (p: 241)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.3 The atanh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.3 The atanh functions (p: 221-222)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.3 The atanh functions (p: 457)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                                          |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Inverse Hyperbolic Tangent.\"](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/atanh](https://en.cppreference.com/w/c/numeric/math/atanh)"
- name: atanhf
  summary: If no errors occur, the inverse hyperbolic tangent of arg (tanh-1(arg), or artanh(arg)), is returned
  description: "# atanh, atanhf, atanhl\n\n[TABLE]\n\n1-3) Computes the inverse hyperbolic tangent of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `atanhl` is called. Otherwise, if the argument has integer type or the type `double`, `atanh` is called. Otherwise, `atanhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`catanhf`](http://en.cppreference.com/w/c/numeric/complex/catanh), [`catanh`](http://en.cppreference.com/w/c/numeric/complex/catanh), [`catanhl`](http://en.cppreference.com/w/c/numeric/complex/catanh)).\n\n### Parameters\n\n|     |     |                                                                   |\n|-----|-----|-------------------------------------------------------------------|\n| arg | \\-  | floating point value representing the area of a hyperbolic sector |\n\n### Return value\n\nIf no errors occur, the inverse hyperbolic tangent of `arg` (tanh⁻¹(arg), or artanh(arg)), is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned (with the correct sign).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the argument is not on the interval \\[-1, +1\\], a range error occurs.\n\nIf the argument is ±1, a pole error occurs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0, it is returned unmodified\n- if the argument is ±1, ±∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- if \\|arg\\|\\>1, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nAlthough the C standard names this function \"arc hyperbolic tangent\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic tangent\" (used by POSIX) or \"area hyperbolic tangent\".\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/atanh.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"atanh(0) = %f\\natanh(-0) = %f\\n\", atanh(0), atanh(-0.0));\n    printf(\"atanh(0.9) = %f\\n\", atanh(0.9));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"atanh(-1) = %f\\n\", atanh(-1));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_DIVBYZERO))\n        puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\natanh(0) = 0.000000\natanh(-0) = -0.000000\natanh(0.9) = 1.472219\natanh(-1) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.3 The atanh functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.2.3 The atanh functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.3 The atanh functions (p: 241)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.3 The atanh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.3 The atanh functions (p: 221-222)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.3 The atanh functions (p: 457)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                                          |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Inverse Hyperbolic Tangent.\"](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/atanh](https://en.cppreference.com/w/c/numeric/math/atanh)"
- name: atanhl
  summary: If no errors occur, the inverse hyperbolic tangent of arg (tanh-1(arg), or artanh(arg)), is returned
  description: "# atanh, atanhf, atanhl\n\n[TABLE]\n\n1-3) Computes the inverse hyperbolic tangent of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `atanhl` is called. Otherwise, if the argument has integer type or the type `double`, `atanh` is called. Otherwise, `atanhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`catanhf`](http://en.cppreference.com/w/c/numeric/complex/catanh), [`catanh`](http://en.cppreference.com/w/c/numeric/complex/catanh), [`catanhl`](http://en.cppreference.com/w/c/numeric/complex/catanh)).\n\n### Parameters\n\n|     |     |                                                                   |\n|-----|-----|-------------------------------------------------------------------|\n| arg | \\-  | floating point value representing the area of a hyperbolic sector |\n\n### Return value\n\nIf no errors occur, the inverse hyperbolic tangent of `arg` (tanh⁻¹(arg), or artanh(arg)), is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned (with the correct sign).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the argument is not on the interval \\[-1, +1\\], a range error occurs.\n\nIf the argument is ±1, a pole error occurs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0, it is returned unmodified\n- if the argument is ±1, ±∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- if \\|arg\\|\\>1, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nAlthough the C standard names this function \"arc hyperbolic tangent\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic tangent\" (used by POSIX) or \"area hyperbolic tangent\".\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/atanh.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"atanh(0) = %f\\natanh(-0) = %f\\n\", atanh(0), atanh(-0.0));\n    printf(\"atanh(0.9) = %f\\n\", atanh(0.9));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"atanh(-1) = %f\\n\", atanh(-1));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_DIVBYZERO))\n        puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\natanh(0) = 0.000000\natanh(-0) = -0.000000\natanh(0.9) = 1.472219\natanh(-1) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.3 The atanh functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.2.3 The atanh functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.3 The atanh functions (p: 241)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.3 The atanh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.3 The atanh functions (p: 221-222)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.3 The atanh functions (p: 457)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                                          |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Inverse Hyperbolic Tangent.\"](https://mathworld.wolfram.com/InverseHyperbolicTangent.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/atanh](https://en.cppreference.com/w/c/numeric/math/atanh)"
- name: atanl
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# atan, atanf, atanl\n\n[TABLE]\n\n1-6) Computes the principal value of the arc tangent of `arg`.\n\n7) Type-generic macro: If the argument has type `long double`, (3) (atanl) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`atan`) is called. Otherwise, (1) (`atanf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`catanf`](../complex/catan \"c/numeric/complex/catan\"), [`catan`](../complex/catan \"c/numeric/complex/catan\"), [`catanl`](../complex/catan \"c/numeric/complex/catan\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the arc tangent of `arg` (arctan(arg)) in the range \\[- π/2 ; +π/2\\] radians, is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is +∞, +π/2 is returned;\n- if the argument is -∞, -π/2 is returned;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/atan.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"atan(1) = %f, 4*atan(1)=%f\\n\", atan(1), 4 * atan(1));\n    // special values\n    printf(\"atan(Inf) = %f, 2*atan(Inf) = %f\\n\", atan(INFINITY), 2 * atan(INFINITY));\n    printf(\"atan(-0.0) = %+f, atan(+0.0) = %+f\\n\", atan(-0.0), atan(0));\n}\n```\n\nOutput:\n\n```\natan(1) = 0.785398, 4*atan(1)=3.141593\natan(Inf) = 1.570796, 2*atan(Inf) = 3.141593\natan(-0.0) = -0.000000, atan(+0.0) = +0.000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.3 The atan functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.3 The atan functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.3 The atan functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.3 The atan functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.3 The atan functions (p: 238-239)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.3 The atan functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.3 The atan functions (p: 219)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.3 The atan functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.3 The atan function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/atan](https://en.cppreference.com/w/c/numeric/math/atan)"
- name: atexit
  summary: Registers the function pointed to by func to be called on normal program termination (via exit() or returning from main())
  description: "# atexit\n\n[TABLE]\n\nRegisters the function pointed to by `func` to be called on normal program termination (via [`exit()`](exit \"c/program/exit\") or returning from `main()`). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first.\n\nThe same function may be registered more than once.\n\n`atexit` is thread-safe: calling the function from several threads does not induce a data race.\n\nThe implementation is guaranteed to support the registration of at least `32` functions. The exact limit is implementation-defined.\n\n### Parameters\n\n|      |     |                                                                  |\n|------|-----|------------------------------------------------------------------|\n| func | \\-  | pointer to a function to be called on normal program termination |\n\n### Return value\n\n`​0​` if the registration succeeds, nonzero value otherwise.\n\n### Example\n\n```\n#include <stdlib.h>\n#include <stdio.h>\n \nvoid f1(void)\n{\n    puts(\"f1\");\n}\n \nvoid f2(void)\n{\n    puts(\"f2\");\n}\n \nint main(void)\n{\n    if ( ! atexit(f1) && ! atexit(f2) && ! atexit(f2) )\n        return EXIT_SUCCESS ;\n \n    // atexit registration failed\n    return EXIT_FAILURE ;\n \n}   // <- if registration was successful calls f2, f2, f1\n```\n\nOutput:\n\n```\nf2\nf2\nf1\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.4.2 The atexit function (p: 255)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.4.2 The atexit function (p: 350)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.4.2 The atexit function (p: 315)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 7.10.4.2 The atexit function (p: 156)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/atexit](https://en.cppreference.com/w/c/program/atexit)"
- name: atof
  summary: Interprets a floating-point value in a byte string pointed to by str
  description: "# atof\n\n[TABLE]\n\nInterprets a floating-point value in a byte string pointed to by `str`.\n\nFunction discards any whitespace characters (as determined by [`isspace`](isspace \"c/string/byte/isspace\")) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:\n\n- decimal floating-point expression. It consists of the following parts:\n  - (optional) plus or minus sign\n  - nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C [locale](../../locale/setlocale \"c/locale/setlocale\")) (defines significand)\n  - (optional) `e` or `E` followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent to base 10)\n\n[TABLE]\n\n- any other expression that may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\")\n\n### Parameters\n\n|     |     |                                                              |\n|-----|-----|--------------------------------------------------------------|\n| str | \\-  | pointer to the null-terminated byte string to be interpreted |\n\n### Return value\n\n`double` value corresponding to the contents of `str` on success. If the converted value falls out of range of the return type, the return value is undefined. If no conversion can be performed, `0.0` is returned.\n\n### Notes\n\nThe name stands for \"ASCII to float\".\n\n### Example\n\n```\n#include <stdlib.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"%g\\n\", atof(\"  -0.0000000123junk\"));\n    printf(\"%g\\n\", atof(\"0.012\"));\n    printf(\"%g\\n\", atof(\"15e16\"));\n    printf(\"%g\\n\", atof(\"-0x1afp-2\"));\n    printf(\"%g\\n\", atof(\"inF\"));\n    printf(\"%g\\n\", atof(\"Nan\"));\n    printf(\"%g\\n\", atof(\"1.0e+309\"));   // UB: out of range of double\n    printf(\"%g\\n\", atof(\"0.0\"));\n    printf(\"%g\\n\", atof(\"junk\"));       // no conversion can be performed\n}\n```\n\nPossible output:\n\n```\n-1.23e-08\n0.012\n1.5e+17\n-107.75\ninf\nnan\ninf\n0\n0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.1 The atof function (p: 341)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.1 The atof function (p: 307)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.1 The atof function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/atof](https://en.cppreference.com/w/c/string/byte/atof)"
- name: atoi
  summary: Interprets an integer value in a byte string pointed to by str
  description: "# atoi, atol, atoll\n\n[TABLE]\n\nInterprets an integer value in a byte string pointed to by `str`. The implied radix is always 10.\n\nDiscards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- numeric digits\n\nIf the value of the result cannot be represented, i.e. the converted value falls out of range of the corresponding return type, the behavior is undefined.\n\n### Parameters\n\n|     |     |                                                              |\n|-----|-----|--------------------------------------------------------------|\n| str | \\-  | pointer to the null-terminated byte string to be interpreted |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success.\n\nIf no conversion can be performed, `​0​` is returned.\n\n### Notes\n\nThe name stands for \"ASCII to integer\".\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    printf(\"%i\\n\", atoi(\" -123junk\"));\n    printf(\"%i\\n\", atoi(\" +321dust\"));\n    printf(\"%i\\n\", atoi(\"0\"));\n    printf(\"%i\\n\", atoi(\"0042\")); // treated as a decimal number with leading zeros\n    printf(\"%i\\n\", atoi(\"0x2A\")); // only leading zero is converted discarding \"x2A\"\n    printf(\"%i\\n\", atoi(\"junk\")); // no conversion can be performed\n    printf(\"%i\\n\", atoi(\"2147483648\")); // UB: out of range of int\n}\n```\n\nPossible output:\n\n```\n-123\n321\n0\n42\n0\n0\n-2147483648\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.1.2 The atoi, atol, and atoll functions (p: 249)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.2 The atoi, atol, and atoll functions (p: 341)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.2 The atoi, atol, and atoll functions (p: 307)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.2 The atoi function\n  - 4.10.1.3 The atol function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/atoi](https://en.cppreference.com/w/c/string/byte/atoi)"
- name: atol
  summary: Interprets an integer value in a byte string pointed to by str
  description: "# atoi, atol, atoll\n\n[TABLE]\n\nInterprets an integer value in a byte string pointed to by `str`. The implied radix is always 10.\n\nDiscards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- numeric digits\n\nIf the value of the result cannot be represented, i.e. the converted value falls out of range of the corresponding return type, the behavior is undefined.\n\n### Parameters\n\n|     |     |                                                              |\n|-----|-----|--------------------------------------------------------------|\n| str | \\-  | pointer to the null-terminated byte string to be interpreted |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success.\n\nIf no conversion can be performed, `​0​` is returned.\n\n### Notes\n\nThe name stands for \"ASCII to integer\".\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    printf(\"%i\\n\", atoi(\" -123junk\"));\n    printf(\"%i\\n\", atoi(\" +321dust\"));\n    printf(\"%i\\n\", atoi(\"0\"));\n    printf(\"%i\\n\", atoi(\"0042\")); // treated as a decimal number with leading zeros\n    printf(\"%i\\n\", atoi(\"0x2A\")); // only leading zero is converted discarding \"x2A\"\n    printf(\"%i\\n\", atoi(\"junk\")); // no conversion can be performed\n    printf(\"%i\\n\", atoi(\"2147483648\")); // UB: out of range of int\n}\n```\n\nPossible output:\n\n```\n-123\n321\n0\n42\n0\n0\n-2147483648\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.1.2 The atoi, atol, and atoll functions (p: 249)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.2 The atoi, atol, and atoll functions (p: 341)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.2 The atoi, atol, and atoll functions (p: 307)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.2 The atoi function\n  - 4.10.1.3 The atol function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/atoi](https://en.cppreference.com/w/c/string/byte/atoi)"
- name: atoll
  summary: Interprets an integer value in a byte string pointed to by str
  description: "# atoi, atol, atoll\n\n[TABLE]\n\nInterprets an integer value in a byte string pointed to by `str`. The implied radix is always 10.\n\nDiscards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- numeric digits\n\nIf the value of the result cannot be represented, i.e. the converted value falls out of range of the corresponding return type, the behavior is undefined.\n\n### Parameters\n\n|     |     |                                                              |\n|-----|-----|--------------------------------------------------------------|\n| str | \\-  | pointer to the null-terminated byte string to be interpreted |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success.\n\nIf no conversion can be performed, `​0​` is returned.\n\n### Notes\n\nThe name stands for \"ASCII to integer\".\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    printf(\"%i\\n\", atoi(\" -123junk\"));\n    printf(\"%i\\n\", atoi(\" +321dust\"));\n    printf(\"%i\\n\", atoi(\"0\"));\n    printf(\"%i\\n\", atoi(\"0042\")); // treated as a decimal number with leading zeros\n    printf(\"%i\\n\", atoi(\"0x2A\")); // only leading zero is converted discarding \"x2A\"\n    printf(\"%i\\n\", atoi(\"junk\")); // no conversion can be performed\n    printf(\"%i\\n\", atoi(\"2147483648\")); // UB: out of range of int\n}\n```\n\nPossible output:\n\n```\n-123\n321\n0\n42\n0\n0\n-2147483648\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.1.2 The atoi, atol, and atoll functions (p: 249)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.2 The atoi, atol, and atoll functions (p: 341)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.2 The atoi, atol, and atoll functions (p: 307)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.2 The atoi function\n  - 4.10.1.3 The atol function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/atoi](https://en.cppreference.com/w/c/string/byte/atoi)"
- name: Atomic operations library
  summary: If the macro constant __STDC_NO_ATOMICS__(C11) is defined by the compiler, the header <stdatomic.h>, the keyword _Atomic, and all of the names listed here are not provided
  description: "# Atomic operations library\n\nIf the macro constant `__STDC_NO_ATOMICS__`(C11) is defined by the compiler, the header `<stdatomic.h>`, the keyword `_Atomic`, and all of the names listed here are not provided.\n\n### Types\n\n[TABLE]\n\n### Macros\n\n[TABLE]\n\n### Functions\n\n[TABLE]\n\n### Types\n\nThe standard library offers convenience typedefs for the [core language atomic types](language/atomic \"c/language/atomic\").\n\n| Typedef name            | Full type name                                                             |\n|-------------------------|----------------------------------------------------------------------------|\n| `atomic_bool`           | `_Atomic _Bool`                                                            |\n| `atomic_char`           | `_Atomic char`                                                             |\n| `atomic_schar`          | `_Atomic signed char`                                                      |\n| `atomic_uchar`          | `_Atomic unsigned char`                                                    |\n| `atomic_short`          | `_Atomic short`                                                            |\n| `atomic_ushort`         | `_Atomic unsigned short`                                                   |\n| `atomic_int`            | `_Atomic int`                                                              |\n| `atomic_uint`           | `_Atomic unsigned int`                                                     |\n| `atomic_long`           | `_Atomic long`                                                             |\n| `atomic_ulong`          | `_Atomic unsigned long`                                                    |\n| `atomic_llong`          | `_Atomic long long`                                                        |\n| `atomic_ullong`         | `_Atomic unsigned long long`                                               |\n| `atomic_char8_t` (C23)  | `_Atomic char8_t`                                                          |\n| `atomic_char16_t`       | `_Atomic char16_t`                                                         |\n| `atomic_char32_t`       | `_Atomic char32_t`                                                         |\n| `atomic_wchar_t`        | `_Atomic wchar_t`                                                          |\n| `atomic_int_least8_t`   | `_Atomic `[`int_least8_t`](http://en.cppreference.com/w/c/types/integer)   |\n| `atomic_uint_least8_t`  | `_Atomic `[`uint_least8_t`](http://en.cppreference.com/w/c/types/integer)  |\n| `atomic_int_least16_t`  | `_Atomic `[`int_least16_t`](http://en.cppreference.com/w/c/types/integer)  |\n| `atomic_uint_least16_t` | `_Atomic `[`uint_least16_t`](http://en.cppreference.com/w/c/types/integer) |\n| `atomic_int_least32_t`  | `_Atomic `[`int_least32_t`](http://en.cppreference.com/w/c/types/integer)  |\n| `atomic_uint_least32_t` | `_Atomic `[`uint_least32_t`](http://en.cppreference.com/w/c/types/integer) |\n| `atomic_int_least64_t`  | `_Atomic `[`int_least64_t`](http://en.cppreference.com/w/c/types/integer)  |\n| `atomic_uint_least64_t` | `_Atomic `[`uint_least64_t`](http://en.cppreference.com/w/c/types/integer) |\n| `atomic_int_fast8_t`    | `_Atomic `[`int_fast8_t`](http://en.cppreference.com/w/c/types/integer)    |\n| `atomic_uint_fast8_t`   | `_Atomic `[`uint_fast8_t`](http://en.cppreference.com/w/c/types/integer)   |\n| `atomic_int_fast16_t`   | `_Atomic `[`int_fast16_t`](http://en.cppreference.com/w/c/types/integer)   |\n| `atomic_uint_fast16_t`  | `_Atomic `[`uint_fast16_t`](http://en.cppreference.com/w/c/types/integer)  |\n| `atomic_int_fast32_t`   | `_Atomic `[`int_fast32_t`](http://en.cppreference.com/w/c/types/integer)   |\n| `atomic_uint_fast32_t`  | `_Atomic `[`uint_fast32_t`](http://en.cppreference.com/w/c/types/integer)  |\n| `atomic_int_fast64_t`   | `_Atomic `[`int_fast64_t`](http://en.cppreference.com/w/c/types/integer)   |\n| `atomic_uint_fast64_t`  | `_Atomic `[`uint_fast64_t`](http://en.cppreference.com/w/c/types/integer)  |\n| `atomic_intptr_t`       | `_Atomic `[`intptr_t`](http://en.cppreference.com/w/c/types/integer)       |\n| `atomic_uintptr_t`      | `_Atomic `[`uintptr_t`](http://en.cppreference.com/w/c/types/integer)      |\n| `atomic_size_t`         | `_Atomic `[`size_t`](http://en.cppreference.com/w/c/types/size_t)          |\n| `atomic_ptrdiff_t`      | `_Atomic `[`ptrdiff_t`](http://en.cppreference.com/w/c/types/ptrdiff_t)    |\n| `atomic_intmax_t`       | `_Atomic `[`intmax_t`](http://en.cppreference.com/w/c/types/integer)       |\n| `atomic_uintmax_t`      | `_Atomic `[`uintmax_t`](http://en.cppreference.com/w/c/types/integer)      |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.17 Atomics \\<stdatomic.h\\> (p: TBD)\n  - 7.31.8 Atomics \\<stdatomic.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17 Atomics \\<stdatomic.h\\> (p: TBD)\n  - 7.31.8 Atomics \\<stdatomic.h\\> (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17 Atomics \\<stdatomic.h\\> (p: 273-286)\n  - 7.31.8 Atomics \\<stdatomic.h\\> (p: 455-456)\n\n### See also\n\n|                                                                                                          |     |\n|----------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/atomic \"cpp/atomic\") for Atomic operations library |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic](https://en.cppreference.com/w/c/atomic)"
- name: Atomic types
  summary: The header <stdatomic.h> defines 37 convenience type aliases, from atomic_bool to atomic_uintmax_t, which simplify the use of this keyword with built-in and library types
  description: "# Atomic types\n\n### Syntax\n\n|                             |       |             |\n|-----------------------------|-------|-------------|\n| `_Atomic` `(` type-name `)` | \\(1\\) | (since C11) |\n| `_Atomic` type-name         | \\(2\\) | (since C11) |\n\n1) Use as a type specifier; this designates a new atomic type\n\n2) Use as a type qualifier; this designates the atomic version of type-name. In this role, it may be mixed with [const](const \"c/language/const\"), [volatile](volatile \"c/language/volatile\"), and [restrict](restrict \"c/language/restrict\"), although unlike other qualifiers, the atomic version of type-name may have a different size, alignment, and object representation.\n\n|           |     |                                                                                                  |\n|-----------|-----|--------------------------------------------------------------------------------------------------|\n| type-name | \\-  | any type other than array or function. For (1), type-name also cannot be atomic or cvr-qualified |\n\nThe header `<stdatomic.h>` defines [37 convenience type aliases](../thread#Atomic_operations \"c/thread\"), from [`atomic_bool`](../thread#Atomic_operations \"c/thread\") to [`atomic_uintmax_t`](../thread#Atomic_operations \"c/thread\"), which simplify the use of this keyword with built-in and library types.\n\n```\n_Atomic const int * p1;  // p is a pointer to an atomic const int\nconst atomic_int * p2;   // same\nconst _Atomic(int) * p3; // same\n```\n\nIf the macro constant `__STDC_NO_ATOMICS__` is defined by the compiler, the keyword `_Atomic` is not provided.\n\n### Explanation\n\nObjects of atomic types are the only objects that are free from [data races](memory_model \"c/language/memory model\"); that is, they may be modified by two threads concurrently or modified by one and read by another.\n\nEach atomic object has its own associated *modification order*, which is a total order of modifications made to that object. If, from some thread's point of view, modification `A` of some atomic M [happens-before](../atomic/memory_order \"c/atomic/memory order\") modification `B` of the same atomic M, then in the modification order of M, A occurs before B.\n\nNote that although each atomic object has its own modification order, there is no single total order; different threads may observe modifications to different atomic objects in different orders.\n\nThere are four coherences that are guaranteed for all atomic operations:\n\n- **write-write coherence**: If an operation A that modifies an atomic object M *happens-before* an operation B that modifies M, then A appears earlier than B in the modification order of M.\n- **read-read coherence**: If a value computation A of an atomic object M happens before a value computation B of M, and A takes its value from a side effect X on M, then the value computed by B is either the value stored by X or is the value stored by a side effect Y on M, where Y appears later than X in the modification order of M.\n- **read-write coherence**: If a value computation A of an atomic object M *happens-before* an operation B on M, then A takes its value from a side effect X on M, where X appears before B in the modification order of M.\n- **write-read coherence**: If a side effect X on an atomic object M *happens-before* a value computation B of M, then the evaluation B takes its value from X or from a side effect Y that appears after X in the modification order of M.\n\nSome atomic operations are also synchronization operations; they may have additional release semantics, acquire semantics, or sequentially-consistent semantics. See [`memory_order`](../atomic/memory_order \"c/atomic/memory order\").\n\nBuilt-in [increment and decrement operators](operator_incdec \"c/language/operator incdec\") and [compound assignment](operator_assignment \"c/language/operator assignment\") are read-modify-write atomic operations with total sequentially consistent ordering (as if using [`memory_order_seq_cst`](../atomic/memory_order \"c/atomic/memory order\")). If less strict synchronization semantics are desired, the [standard library functions](../thread#Atomic_operations \"c/thread\") may be used instead.\n\nAtomic properties are only meaningful for [lvalue expressions](value_category \"c/language/value category\"). Lvalue-to-rvalue conversion (which models a memory read from an atomic location to a CPU register) strips atomicity along with other qualifiers.\n\n### Notes\n\nAccessing a member of an atomic struct/union is undefined behavior.\n\nThe library type [`sig_atomic_t`](http://en.cppreference.com/w/c/program/sig_atomic_t) does not provide inter-thread synchronization or memory ordering, only atomicity.\n\nThe [volatile](volatile \"c/language/volatile\") types do not provide inter-thread synchronization, memory ordering, or atomicity.\n\nImplementations are recommended to ensure that the representation of `_Atomic(T)` in C is same as that of `std::atomic<T>` in C++ for every possible type `T`. The mechanisms used to ensure atomicity and memory ordering should be compatible.\n\n### Keywords\n\n[`_Atomic`](../keyword/_atomic \"c/keyword/ Atomic\")\n\n### Example\n\n```\n#include <stdio.h>\n#include <threads.h>\n#include <stdatomic.h>\n \natomic_int acnt;\nint cnt;\n \nint f(void* thr_data)\n{\n    for(int n = 0; n < 1000; ++n) {\n        ++cnt;\n        ++acnt;\n        // for this example, relaxed memory order is sufficient, e.g.\n        // atomic_fetch_add_explicit(&acnt, 1, memory_order_relaxed);\n    }\n    return 0;\n}\n \nint main(void)\n{\n    thrd_t thr[10];\n    for(int n = 0; n < 10; ++n)\n        thrd_create(&thr[n], f, NULL);\n    for(int n = 0; n < 10; ++n)\n        thrd_join(thr[n], NULL);\n \n    printf(\"The atomic counter is %u\\n\", acnt);\n    printf(\"The non-atomic counter is %u\\n\", cnt);\n}\n```\n\nPossible output:\n\n```\nThe atomic counter is 10000\nThe non-atomic counter is 8644\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.2.4 Atomic type specifiers (p: 87)\n  - 7.17 Atomics \\<stdatomic.h\\> (p: 200-209)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.2.4 Atomic type specifiers (p: 121)\n  - 7.17 Atomics \\<stdatomic.h\\> (p: 273-286)\n\n### See also\n\n|                                                                                                       |     |\n|-------------------------------------------------------------------------------------------------------|-----|\n| [C documentation](../thread \"c/thread\") for `thread (Concurrency support library)`                    |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/atomic/atomic \"cpp/atomic/atomic\") for `atomic` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/atomic](https://en.cppreference.com/w/c/language/atomic)"
- name: ATOMIC_*_LOCK_FREE
  summary: Expands to preprocessor constant expressions that evaluate to either 0, 1, or 2 which indicate the lock-free property of the corresponding atomic types (both signed and unsigned)
  description: "# ATOMIC\\_\\*\\_LOCK_FREE\n\n[TABLE]\n\nExpands to [preprocessor constant expressions](../language/constant_expression \"c/language/constant expression\") that evaluate to either `0`, `1`, or `2` which indicate the lock-free property of the corresponding [atomic types](../thread#Atomic_operations \"c/thread\") (both signed and unsigned).\n\n| Value | Explanation                            |\n|-------|----------------------------------------|\n| `0`   | The atomic type is never lock-free     |\n| `1`   | The atomic type is sometimes lock-free |\n| `2`   | The atomic type is always lock-free    |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.1/3 atomic lock-free macros (p: 200)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.1/3 atomic lock-free macros (p: 273)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/ATOMIC_LOCK_FREE_consts](https://en.cppreference.com/w/c/atomic/ATOMIC_LOCK_FREE_consts)"
- name: atomic_compare_exchange_strong
  summary: Atomically compares the contents of memory pointed to by obj with the contents of memory pointed to by expected, and if those are bitwise equal, replaces the former with desired (performs read-modify-write operation)
  description: "# atomic_compare_exchange_weak, atomic_compare_exchange_strong, atomic_compare_exchange_weak_explicit, atomic_compare_exchange_strong_explicit\n\n[TABLE]\n\nAtomically compares the contents of memory pointed to by `obj` with the contents of memory pointed to by `expected`, and if those are bitwise equal, replaces the former with `desired` (performs read-modify-write operation). Otherwise, loads the actual contents of memory pointed to by `obj` into `*expected` (performs load operation).\n\nThe memory models for the read-modify-write and load operations are `succ` and `fail` respectively. The (1-2) versions use [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\") by default.\n\nThe weak forms ((2) and (4)) of the functions are allowed to fail spuriously, that is, act as if `*obj != *expected` even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_compare_exchange)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|          |     |                                                                                                                                                                                                                                                                                 |\n|----------|-----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| obj      | \\-  | pointer to the atomic object to test and modify                                                                                                                                                                                                                                 |\n| expected | \\-  | pointer to the value expected to be found in the atomic object                                                                                                                                                                                                                  |\n| desired  | \\-  | the value to store in the atomic object if it is as expected                                                                                                                                                                                                                    |\n| succ     | \\-  | the memory synchronization ordering for the read-modify-write operation if the comparison succeeds. All values are permitted.                                                                                                                                                   |\n| fail     | \\-  | the memory synchronization ordering for the load operation if the comparison fails. Cannot be [`memory_order_release`](memory_order \"c/atomic/memory order\") or [`memory_order_acq_rel`](memory_order \"c/atomic/memory order\") and cannot specify stronger ordering than `succ` |\n\n### Return value\n\nThe result of the comparison: `true` if `*obj` was equal to `*exp`, `false` otherwise.\n\n### Notes\n\nThe behavior of `atomic_compare_exchange_*` family is as if the following was executed atomically:\n\n```\nif (memcmp(obj, expected, sizeof *obj) == 0) {\n    memcpy(obj, &desired, sizeof *obj);\n    return true;\n} else {\n    memcpy(expected, obj, sizeof *obj);\n    return false;\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.4 The atomic_compare_exchange generic functions (p: 207)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.4 The atomic_compare_exchange generic functions (p: 283-284)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_compare_exchange](https://en.cppreference.com/w/c/atomic/atomic_compare_exchange)"
- name: atomic_compare_exchange_strong_explicit
  summary: Atomically compares the contents of memory pointed to by obj with the contents of memory pointed to by expected, and if those are bitwise equal, replaces the former with desired (performs read-modify-write operation)
  description: "# atomic_compare_exchange_weak, atomic_compare_exchange_strong, atomic_compare_exchange_weak_explicit, atomic_compare_exchange_strong_explicit\n\n[TABLE]\n\nAtomically compares the contents of memory pointed to by `obj` with the contents of memory pointed to by `expected`, and if those are bitwise equal, replaces the former with `desired` (performs read-modify-write operation). Otherwise, loads the actual contents of memory pointed to by `obj` into `*expected` (performs load operation).\n\nThe memory models for the read-modify-write and load operations are `succ` and `fail` respectively. The (1-2) versions use [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\") by default.\n\nThe weak forms ((2) and (4)) of the functions are allowed to fail spuriously, that is, act as if `*obj != *expected` even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_compare_exchange)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|          |     |                                                                                                                                                                                                                                                                                 |\n|----------|-----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| obj      | \\-  | pointer to the atomic object to test and modify                                                                                                                                                                                                                                 |\n| expected | \\-  | pointer to the value expected to be found in the atomic object                                                                                                                                                                                                                  |\n| desired  | \\-  | the value to store in the atomic object if it is as expected                                                                                                                                                                                                                    |\n| succ     | \\-  | the memory synchronization ordering for the read-modify-write operation if the comparison succeeds. All values are permitted.                                                                                                                                                   |\n| fail     | \\-  | the memory synchronization ordering for the load operation if the comparison fails. Cannot be [`memory_order_release`](memory_order \"c/atomic/memory order\") or [`memory_order_acq_rel`](memory_order \"c/atomic/memory order\") and cannot specify stronger ordering than `succ` |\n\n### Return value\n\nThe result of the comparison: `true` if `*obj` was equal to `*exp`, `false` otherwise.\n\n### Notes\n\nThe behavior of `atomic_compare_exchange_*` family is as if the following was executed atomically:\n\n```\nif (memcmp(obj, expected, sizeof *obj) == 0) {\n    memcpy(obj, &desired, sizeof *obj);\n    return true;\n} else {\n    memcpy(expected, obj, sizeof *obj);\n    return false;\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.4 The atomic_compare_exchange generic functions (p: 207)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.4 The atomic_compare_exchange generic functions (p: 283-284)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_compare_exchange](https://en.cppreference.com/w/c/atomic/atomic_compare_exchange)"
- name: atomic_compare_exchange_weak
  summary: Atomically compares the contents of memory pointed to by obj with the contents of memory pointed to by expected, and if those are bitwise equal, replaces the former with desired (performs read-modify-write operation)
  description: "# atomic_compare_exchange_weak, atomic_compare_exchange_strong, atomic_compare_exchange_weak_explicit, atomic_compare_exchange_strong_explicit\n\n[TABLE]\n\nAtomically compares the contents of memory pointed to by `obj` with the contents of memory pointed to by `expected`, and if those are bitwise equal, replaces the former with `desired` (performs read-modify-write operation). Otherwise, loads the actual contents of memory pointed to by `obj` into `*expected` (performs load operation).\n\nThe memory models for the read-modify-write and load operations are `succ` and `fail` respectively. The (1-2) versions use [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\") by default.\n\nThe weak forms ((2) and (4)) of the functions are allowed to fail spuriously, that is, act as if `*obj != *expected` even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_compare_exchange)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|          |     |                                                                                                                                                                                                                                                                                 |\n|----------|-----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| obj      | \\-  | pointer to the atomic object to test and modify                                                                                                                                                                                                                                 |\n| expected | \\-  | pointer to the value expected to be found in the atomic object                                                                                                                                                                                                                  |\n| desired  | \\-  | the value to store in the atomic object if it is as expected                                                                                                                                                                                                                    |\n| succ     | \\-  | the memory synchronization ordering for the read-modify-write operation if the comparison succeeds. All values are permitted.                                                                                                                                                   |\n| fail     | \\-  | the memory synchronization ordering for the load operation if the comparison fails. Cannot be [`memory_order_release`](memory_order \"c/atomic/memory order\") or [`memory_order_acq_rel`](memory_order \"c/atomic/memory order\") and cannot specify stronger ordering than `succ` |\n\n### Return value\n\nThe result of the comparison: `true` if `*obj` was equal to `*exp`, `false` otherwise.\n\n### Notes\n\nThe behavior of `atomic_compare_exchange_*` family is as if the following was executed atomically:\n\n```\nif (memcmp(obj, expected, sizeof *obj) == 0) {\n    memcpy(obj, &desired, sizeof *obj);\n    return true;\n} else {\n    memcpy(expected, obj, sizeof *obj);\n    return false;\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.4 The atomic_compare_exchange generic functions (p: 207)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.4 The atomic_compare_exchange generic functions (p: 283-284)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_compare_exchange](https://en.cppreference.com/w/c/atomic/atomic_compare_exchange)"
- name: atomic_compare_exchange_weak_explicit
  summary: Atomically compares the contents of memory pointed to by obj with the contents of memory pointed to by expected, and if those are bitwise equal, replaces the former with desired (performs read-modify-write operation)
  description: "# atomic_compare_exchange_weak, atomic_compare_exchange_strong, atomic_compare_exchange_weak_explicit, atomic_compare_exchange_strong_explicit\n\n[TABLE]\n\nAtomically compares the contents of memory pointed to by `obj` with the contents of memory pointed to by `expected`, and if those are bitwise equal, replaces the former with `desired` (performs read-modify-write operation). Otherwise, loads the actual contents of memory pointed to by `obj` into `*expected` (performs load operation).\n\nThe memory models for the read-modify-write and load operations are `succ` and `fail` respectively. The (1-2) versions use [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\") by default.\n\nThe weak forms ((2) and (4)) of the functions are allowed to fail spuriously, that is, act as if `*obj != *expected` even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_compare_exchange)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|          |     |                                                                                                                                                                                                                                                                                 |\n|----------|-----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| obj      | \\-  | pointer to the atomic object to test and modify                                                                                                                                                                                                                                 |\n| expected | \\-  | pointer to the value expected to be found in the atomic object                                                                                                                                                                                                                  |\n| desired  | \\-  | the value to store in the atomic object if it is as expected                                                                                                                                                                                                                    |\n| succ     | \\-  | the memory synchronization ordering for the read-modify-write operation if the comparison succeeds. All values are permitted.                                                                                                                                                   |\n| fail     | \\-  | the memory synchronization ordering for the load operation if the comparison fails. Cannot be [`memory_order_release`](memory_order \"c/atomic/memory order\") or [`memory_order_acq_rel`](memory_order \"c/atomic/memory order\") and cannot specify stronger ordering than `succ` |\n\n### Return value\n\nThe result of the comparison: `true` if `*obj` was equal to `*exp`, `false` otherwise.\n\n### Notes\n\nThe behavior of `atomic_compare_exchange_*` family is as if the following was executed atomically:\n\n```\nif (memcmp(obj, expected, sizeof *obj) == 0) {\n    memcpy(obj, &desired, sizeof *obj);\n    return true;\n} else {\n    memcpy(expected, obj, sizeof *obj);\n    return false;\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.4 The atomic_compare_exchange generic functions (p: 207)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.4 The atomic_compare_exchange generic functions (p: 283-284)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_compare_exchange](https://en.cppreference.com/w/c/atomic/atomic_compare_exchange)"
- name: atomic_exchange
  summary: Atomically replaces the value pointed by obj with desired and returns the value obj held previously
  description: "# atomic_exchange, atomic_exchange_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with `desired` and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_exchange)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined..\n\n### Parameters\n\n|         |     |                                                                                  |\n|---------|-----|----------------------------------------------------------------------------------|\n| obj     | \\-  | pointer to the atomic object to modify                                           |\n| desired | \\-  | the value to replace the atomic object with                                      |\n| order   | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously be the atomic object pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.3 The atomic_exchange generic functions (p: 207)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.3 The atomic_exchange generic functions (p: 283)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_exchange](https://en.cppreference.com/w/c/atomic/atomic_exchange)"
- name: atomic_exchange_explicit
  summary: Atomically replaces the value pointed by obj with desired and returns the value obj held previously
  description: "# atomic_exchange, atomic_exchange_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with `desired` and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_exchange)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined..\n\n### Parameters\n\n|         |     |                                                                                  |\n|---------|-----|----------------------------------------------------------------------------------|\n| obj     | \\-  | pointer to the atomic object to modify                                           |\n| desired | \\-  | the value to replace the atomic object with                                      |\n| order   | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously be the atomic object pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.3 The atomic_exchange generic functions (p: 207)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.3 The atomic_exchange generic functions (p: 283)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_exchange](https://en.cppreference.com/w/c/atomic/atomic_exchange)"
- name: atomic_fetch_add
  summary: Atomically replaces the value pointed by obj with the result of addition of arg to the old value of obj, and returns the value obj held previously
  description: "# atomic_fetch_add, atomic_fetch_add_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with the result of addition of `arg` to the old value of `obj`, and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `M` is either the non-atomic type corresponding to `A` if `A` is atomic integer type, or [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") if `A` is atomic pointer type.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_fetch_add)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\nFor signed integer types, arithmetic is defined to use two’s complement representation. There are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                                           |\n| arg   | \\-  | the value to add to the value stored in the atomic object                        |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously by the atomic object pointed to by `obj`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <threads.h>\n#include <stdatomic.h>\n \natomic_int acnt;\nint cnt;\n \nint f(void* thr_data)\n{\n    for(int n = 0; n < 1000; ++n) {\n        atomic_fetch_add_explicit(&acnt, 1, memory_order_relaxed); // atomic\n        ++cnt; // undefined behavior, in practice some updates missed\n    }\n    return 0;\n}\n \nint main(void)\n{\n    thrd_t thr[10];\n    for(int n = 0; n < 10; ++n)\n        thrd_create(&thr[n], f, NULL);\n    for(int n = 0; n < 10; ++n)\n        thrd_join(thr[n], NULL);\n \n    printf(\"The atomic counter is %u\\n\", acnt);\n    printf(\"The non-atomic counter is %u\\n\", cnt);\n}\n```\n\nPossible output:\n\n```\nThe atomic counter is 10000\nThe non-atomic counter is 9511\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 284-285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_fetch_add](https://en.cppreference.com/w/c/atomic/atomic_fetch_add)"
- name: atomic_fetch_add_explicit
  summary: Atomically replaces the value pointed by obj with the result of addition of arg to the old value of obj, and returns the value obj held previously
  description: "# atomic_fetch_add, atomic_fetch_add_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with the result of addition of `arg` to the old value of `obj`, and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `M` is either the non-atomic type corresponding to `A` if `A` is atomic integer type, or [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") if `A` is atomic pointer type.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_fetch_add)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\nFor signed integer types, arithmetic is defined to use two’s complement representation. There are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                                           |\n| arg   | \\-  | the value to add to the value stored in the atomic object                        |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously by the atomic object pointed to by `obj`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <threads.h>\n#include <stdatomic.h>\n \natomic_int acnt;\nint cnt;\n \nint f(void* thr_data)\n{\n    for(int n = 0; n < 1000; ++n) {\n        atomic_fetch_add_explicit(&acnt, 1, memory_order_relaxed); // atomic\n        ++cnt; // undefined behavior, in practice some updates missed\n    }\n    return 0;\n}\n \nint main(void)\n{\n    thrd_t thr[10];\n    for(int n = 0; n < 10; ++n)\n        thrd_create(&thr[n], f, NULL);\n    for(int n = 0; n < 10; ++n)\n        thrd_join(thr[n], NULL);\n \n    printf(\"The atomic counter is %u\\n\", acnt);\n    printf(\"The non-atomic counter is %u\\n\", cnt);\n}\n```\n\nPossible output:\n\n```\nThe atomic counter is 10000\nThe non-atomic counter is 9511\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 284-285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_fetch_add](https://en.cppreference.com/w/c/atomic/atomic_fetch_add)"
- name: atomic_fetch_and
  summary: Atomically replaces the value pointed by obj with the result of bitwise AND between the old value of obj and arg, and returns the value obj held previously
  description: "# atomic_fetch_and, atomic_fetch_and_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with the result of bitwise AND between the old value of `obj` and `arg`, and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `M` is either the non-atomic type corresponding to `A` if `A` is atomic integer type, or [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") if `A` is atomic pointer type.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_fetch_and)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                                           |\n| arg   | \\-  | the value to bitwise AND to the value stored in the atomic object                |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously be the atomic object pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 284-285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_fetch_and](https://en.cppreference.com/w/c/atomic/atomic_fetch_and)"
- name: atomic_fetch_and_explicit
  summary: Atomically replaces the value pointed by obj with the result of bitwise AND between the old value of obj and arg, and returns the value obj held previously
  description: "# atomic_fetch_and, atomic_fetch_and_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with the result of bitwise AND between the old value of `obj` and `arg`, and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `M` is either the non-atomic type corresponding to `A` if `A` is atomic integer type, or [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") if `A` is atomic pointer type.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_fetch_and)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                                           |\n| arg   | \\-  | the value to bitwise AND to the value stored in the atomic object                |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously be the atomic object pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 284-285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_fetch_and](https://en.cppreference.com/w/c/atomic/atomic_fetch_and)"
- name: atomic_fetch_or
  summary: Atomically replaces the value pointed by obj with the result of bitwise OR between the old value of obj and arg, and returns the value obj held previously
  description: "# atomic_fetch_or, atomic_fetch_or_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with the result of bitwise OR between the old value of `obj` and `arg`, and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `M` is either the non-atomic type corresponding to `A` if `A` is atomic integer type, or [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") if `A` is atomic pointer type.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_fetch_or)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                                           |\n| arg   | \\-  | the value to bitwise OR to the value stored in the atomic object                 |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously be the atomic object pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 284-285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_fetch_or](https://en.cppreference.com/w/c/atomic/atomic_fetch_or)"
- name: atomic_fetch_or_explicit
  summary: Atomically replaces the value pointed by obj with the result of bitwise OR between the old value of obj and arg, and returns the value obj held previously
  description: "# atomic_fetch_or, atomic_fetch_or_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with the result of bitwise OR between the old value of `obj` and `arg`, and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `M` is either the non-atomic type corresponding to `A` if `A` is atomic integer type, or [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") if `A` is atomic pointer type.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_fetch_or)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                                           |\n| arg   | \\-  | the value to bitwise OR to the value stored in the atomic object                 |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously be the atomic object pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 284-285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_fetch_or](https://en.cppreference.com/w/c/atomic/atomic_fetch_or)"
- name: atomic_fetch_sub
  summary: Atomically replaces the value pointed by obj with the result of subtraction of arg from the old value of obj, and returns the value obj held previously
  description: "# atomic_fetch_sub, atomic_fetch_sub_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with the result of subtraction of `arg` from the old value of `obj`, and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `M` is either the non-atomic type corresponding to `A` if `A` is atomic integer type, or [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") if `A` is atomic pointer type.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_fetch_sub)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\nFor signed integer types, arithmetic is defined to use two’s complement representation. There are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                                           |\n| arg   | \\-  | the value to subtract from the value stored in the atomic object                 |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously by the atomic object pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 284-285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_fetch_sub](https://en.cppreference.com/w/c/atomic/atomic_fetch_sub)"
- name: atomic_fetch_sub_explicit
  summary: Atomically replaces the value pointed by obj with the result of subtraction of arg from the old value of obj, and returns the value obj held previously
  description: "# atomic_fetch_sub, atomic_fetch_sub_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with the result of subtraction of `arg` from the old value of `obj`, and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `M` is either the non-atomic type corresponding to `A` if `A` is atomic integer type, or [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") if `A` is atomic pointer type.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_fetch_sub)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\nFor signed integer types, arithmetic is defined to use two’s complement representation. There are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                                           |\n| arg   | \\-  | the value to subtract from the value stored in the atomic object                 |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously by the atomic object pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 284-285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_fetch_sub](https://en.cppreference.com/w/c/atomic/atomic_fetch_sub)"
- name: atomic_fetch_xor
  summary: Atomically replaces the value pointed by obj with the result of bitwise XOR between the old value of obj and arg, and returns the value obj held previously
  description: "# atomic_fetch_xor, atomic_fetch_xor_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with the result of bitwise XOR between the old value of `obj` and `arg`, and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `M` is either the non-atomic type corresponding to `A` if `A` is atomic integer type, or [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") if `A` is atomic pointer type.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_fetch_xor)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                                           |\n| arg   | \\-  | the value to bitwise XOR to the value stored in the atomic object                |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously be the atomic object pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 284-285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_fetch_xor](https://en.cppreference.com/w/c/atomic/atomic_fetch_xor)"
- name: atomic_fetch_xor_explicit
  summary: Atomically replaces the value pointed by obj with the result of bitwise XOR between the old value of obj and arg, and returns the value obj held previously
  description: "# atomic_fetch_xor, atomic_fetch_xor_explicit\n\n[TABLE]\n\nAtomically replaces the value pointed by `obj` with the result of bitwise XOR between the old value of `obj` and `arg`, and returns the value `obj` held previously. The operation is read-modify-write operation. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `M` is either the non-atomic type corresponding to `A` if `A` is atomic integer type, or [`ptrdiff_t`](../types/ptrdiff_t \"c/types/ptrdiff t\") if `A` is atomic pointer type.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_fetch_xor)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                                           |\n| arg   | \\-  | the value to bitwise XOR to the value stored in the atomic object                |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe value held previously be the atomic object pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.5 The atomic_fetch and modify generic functions (p: 284-285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_fetch_xor](https://en.cppreference.com/w/c/atomic/atomic_fetch_xor)"
- name: atomic_flag
  summary: atomic_flag is an atomic boolean type
  description: "# atomic_flag\n\n[TABLE]\n\n`atomic_flag` is an atomic boolean type. Unlike other atomic types, it is guaranteed to be lock-free. Unlike [`atomic_bool`](../thread#Atomic_operations \"c/thread\"), `atomic_flag` does not provide load or store operations.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.1/4 atomic_flag (p: 200)\n  - 7.17.8 Atomic flag type and operations (p: 208-209)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.1/4 atomic_flag (p: 273)\n  - 7.17.8 Atomic flag type and operations (p: 285-286)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_flag](https://en.cppreference.com/w/c/atomic/atomic_flag)"
- name: atomic_flag_clear
  summary: Atomically changes the state of a atomic_flag pointed to by obj to clear (false)
  description: "# atomic_flag_clear, atomic_flag_clear_explicit\n\n[TABLE]\n\nAtomically changes the state of a `atomic_flag` pointed to by `obj` to clear (`false`). The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThe argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic flags.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic flag object to modify                                      |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\n(none)\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.8.2 The atomic_flag_clear functions (p: 209)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.8.2 The atomic_flag_clear functions (p: 286)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_flag_clear](https://en.cppreference.com/w/c/atomic/atomic_flag_clear)"
- name: atomic_flag_clear_explicit
  summary: Atomically changes the state of a atomic_flag pointed to by obj to clear (false)
  description: "# atomic_flag_clear, atomic_flag_clear_explicit\n\n[TABLE]\n\nAtomically changes the state of a `atomic_flag` pointed to by `obj` to clear (`false`). The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThe argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic flags.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic flag object to modify                                      |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\n(none)\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.8.2 The atomic_flag_clear functions (p: 209)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.8.2 The atomic_flag_clear functions (p: 286)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_flag_clear](https://en.cppreference.com/w/c/atomic/atomic_flag_clear)"
- name: ATOMIC_FLAG_INIT
  summary: Expands to an initializer that can be used to initialize atomic_flag type to the clear state
  description: "# ATOMIC_FLAG_INIT\n\n[TABLE]\n\nExpands to an initializer that can be used to initialize [`atomic_flag`](atomic_flag \"c/atomic/atomic flag\") type to the clear state. The value `atomic_flag` that is not initialized using this macro is indeterminate.\n\n### Example\n\n```\n#include <stdatomic.h>\n \natomic_flag flag = ATOMIC_FLAG_INIT;\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.1/3 ATOMIC_FLAG_INIT (p: 200)\n  - 7.17.8/4 ATOMIC_FLAG_INIT (p: 208)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.1/3 ATOMIC_FLAG_INIT (p: 273)\n  - 7.17.8/4 ATOMIC_FLAG_INIT (p: 285)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/ATOMIC_FLAG_INIT](https://en.cppreference.com/w/c/atomic/ATOMIC_FLAG_INIT)"
- name: atomic_flag_test_and_set
  summary: Atomically changes the state of a atomic_flag pointed to by obj to set (true) and returns the previous value
  description: "# atomic_flag_test_and_set, atomic_flag_test_and_set_explicit\n\n[TABLE]\n\nAtomically changes the state of a `atomic_flag` pointed to by `obj` to set (`true`) and returns the previous value. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThe argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic flags.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic flag object to modify                                      |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe previous value held by the atomic flag pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.8.1 The atomic_flag_test_and_set functions (p: 209)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.8.1 The atomic_flag_test_and_set functions (p: 285-286)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_flag_test_and_set](https://en.cppreference.com/w/c/atomic/atomic_flag_test_and_set)"
- name: atomic_flag_test_and_set_explicit
  summary: Atomically changes the state of a atomic_flag pointed to by obj to set (true) and returns the previous value
  description: "# atomic_flag_test_and_set, atomic_flag_test_and_set_explicit\n\n[TABLE]\n\nAtomically changes the state of a `atomic_flag` pointed to by `obj` to set (`true`) and returns the previous value. The first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`.\n\nThe argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic flags.\n\n### Parameters\n\n|       |     |                                                                                  |\n|-------|-----|----------------------------------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic flag object to modify                                      |\n| order | \\-  | the memory synchronization ordering for this operation: all values are permitted |\n\n### Return value\n\nThe previous value held by the atomic flag pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.8.1 The atomic_flag_test_and_set functions (p: 209)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.8.1 The atomic_flag_test_and_set functions (p: 285-286)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_flag_test_and_set](https://en.cppreference.com/w/c/atomic/atomic_flag_test_and_set)"
- name: atomic_init
  summary: Initializes the default-constructed atomic object obj with the value desired
  description: "# atomic_init\n\n[TABLE]\n\nInitializes the default-constructed atomic object `obj` with the value `desired`. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_init)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|         |     |                                            |\n|---------|-----|--------------------------------------------|\n| obj     | \\-  | pointer to an atomic object to initialize  |\n| desired | \\-  | the value to initialize atomic object with |\n\n### Return value\n\n(none)\n\n### Notes\n\n`atomic_init` is the only way to initialize dynamically-allocated atomic objects. For example:\n\n```\n_Atomic int *p = malloc(sizeof(_Atomic int));\natomic_init(p, 42);\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.17.2.2 The atomic_init generic function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.2.2 The atomic_init generic function (p: 201)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.2.2 The atomic_init generic function (p: 274-275)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_init](https://en.cppreference.com/w/c/atomic/atomic_init)"
- name: atomic_is_lock_free
  summary: Determines if the atomic operations on all objects of the type A (the type of the object pointed to by obj) are lock-free
  description: "# atomic_is_lock_free\n\n[TABLE]\n\nDetermines if the atomic operations on all objects of the type `A` (the type of the object pointed to by `obj`) are lock-free. In any given program execution, the result of calling `atomic_is_lock_free` is the same for all pointers of the same type.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_is_lock_free)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|     |     |                                         |\n|-----|-----|-----------------------------------------|\n| obj | \\-  | pointer to the atomic object to inspect |\n\n### Return value\n\n`true` if the operations on all objects of the type `A` are lock-free, `false` otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdatomic.h>\n \n_Atomic struct A { int a[100]; } a;\n_Atomic struct B { int x, y; } b;\nint main(void)\n{\n    printf(\"_Atomic struct A is lock free? %s\\n\", \n            atomic_is_lock_free(&a) ? \"true\" : \"false\");\n    printf(\"_Atomic struct B is lock free? %s\\n\", \n            atomic_is_lock_free(&b) ? \"true\" : \"false\");\n}\n```\n\nPossible output:\n\n```\n_Atomic struct A is lock free? false\n_Atomic struct B is lock free? true\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published        | Correct behavior           |\n|-----------------------------------------------------------------------------|------------|------------------------------|----------------------------|\n| [DR 465](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_465) | C11        | this function was per-object | this functions is per-type |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.5.1 The atomic_is_lock_free generic function (p: 205)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.5.1 The atomic_is_lock_free generic function (p: 280)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_is_lock_free](https://en.cppreference.com/w/c/atomic/atomic_is_lock_free)"
- name: atomic_load
  summary: Atomically loads and returns the current value of the atomic variable pointed to by obj
  description: "# atomic_load, atomic_load_explicit\n\n[TABLE]\n\nAtomically loads and returns the current value of the atomic variable pointed to by `obj`. The operation is atomic read operation.\n\nThe first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`. `order` must be one of [`memory_order_relaxed`](memory_order \"c/atomic/memory order\"), [`memory_order_consume`](memory_order \"c/atomic/memory order\"), [`memory_order_acquire`](memory_order \"c/atomic/memory order\") or [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"). Otherwise the behavior is undefined.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_load)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                                        |\n|-------|-----|--------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to access                 |\n| order | \\-  | the memory synchronization ordering for this operation |\n\n### Return value\n\nThe current value of the atomic variable pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.2 The atomic_load generic functions (p: 206)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.2 The atomic_load generic functions (p: 282)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_load](https://en.cppreference.com/w/c/atomic/atomic_load)"
- name: atomic_load_explicit
  summary: Atomically loads and returns the current value of the atomic variable pointed to by obj
  description: "# atomic_load, atomic_load_explicit\n\n[TABLE]\n\nAtomically loads and returns the current value of the atomic variable pointed to by `obj`. The operation is atomic read operation.\n\nThe first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`. `order` must be one of [`memory_order_relaxed`](memory_order \"c/atomic/memory order\"), [`memory_order_consume`](memory_order \"c/atomic/memory order\"), [`memory_order_acquire`](memory_order \"c/atomic/memory order\") or [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"). Otherwise the behavior is undefined.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_load)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                                        |\n|-------|-----|--------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to access                 |\n| order | \\-  | the memory synchronization ordering for this operation |\n\n### Return value\n\nThe current value of the atomic variable pointed to by `obj`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.2 The atomic_load generic functions (p: 206)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.2 The atomic_load generic functions (p: 282)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_load](https://en.cppreference.com/w/c/atomic/atomic_load)"
- name: atomic_signal_fence
  summary: Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by order, between a thread and a signal handler executed on the same thread
  description: "# atomic_signal_fence\n\n[TABLE]\n\nEstablishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by `order`, between a thread and a signal handler executed on the same thread. This is equivalent to [`atomic_thread_fence`](atomic_thread_fence \"c/atomic/atomic thread fence\"), except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as `order` instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.\n\n### Parameters\n\n|       |     |                                            |\n|-------|-----|--------------------------------------------|\n| order | \\-  | the memory ordering executed by this fence |\n\n### Return value\n\n(none)\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.4.2 The atomic_signal_fence function (p: 204-205)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.4.2 The atomic_signal_fence function (p: 279)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_signal_fence](https://en.cppreference.com/w/c/atomic/atomic_signal_fence)"
- name: atomic_store
  summary: Atomically replaces the value of the atomic variable pointed to by obj with desired
  description: "# atomic_store, atomic_store_explicit\n\n[TABLE]\n\nAtomically replaces the value of the atomic variable pointed to by `obj` with `desired`. The operation is atomic write operation.\n\nThe first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`. `order` must be one of [`memory_order_relaxed`](memory_order \"c/atomic/memory order\"), [`memory_order_release`](memory_order \"c/atomic/memory order\") or [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"). Otherwise the behavior is undefined.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_store)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                                        |\n|-------|-----|--------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                 |\n| order | \\-  | the memory synchronization ordering for this operation |\n\n### Return value\n\n(none)\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.1 The atomic_store generic functions (p: 206)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.1 The atomic_store generic functions (p: 282)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_store](https://en.cppreference.com/w/c/atomic/atomic_store)"
- name: atomic_store_explicit
  summary: Atomically replaces the value of the atomic variable pointed to by obj with desired
  description: "# atomic_store, atomic_store_explicit\n\n[TABLE]\n\nAtomically replaces the value of the atomic variable pointed to by `obj` with `desired`. The operation is atomic write operation.\n\nThe first version orders memory accesses according to [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"), the second version orders memory accesses according to `order`. `order` must be one of [`memory_order_relaxed`](memory_order \"c/atomic/memory order\"), [`memory_order_release`](memory_order \"c/atomic/memory order\") or [`memory_order_seq_cst`](memory_order \"c/atomic/memory order\"). Otherwise the behavior is undefined.\n\nThis is a [generic function](../language/generic \"c/language/generic\") defined for all [atomic object types](../language/atomic \"c/language/atomic\") `A`. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and [volatile](../language/volatile \"c/language/volatile\") (e.g. memory-mapped I/O) atomic objects, and volatile semantic is preserved when applying this operation to volatile atomic objects. `C` is the non-atomic type corresponding to `A`.\n\nIt is unspecified whether the name of a generic function is a macro or an identifier declared with external linkage. If a macro definition is suppressed in order to access an actual function (e.g. parenthesized like `(atomic_store)(...)`), or a program defines an external identifier with the name of a generic function, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                                        |\n|-------|-----|--------------------------------------------------------|\n| obj   | \\-  | pointer to the atomic object to modify                 |\n| order | \\-  | the memory synchronization ordering for this operation |\n\n### Return value\n\n(none)\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.7.1 The atomic_store generic functions (p: 206)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.7.1 The atomic_store generic functions (p: 282)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_store](https://en.cppreference.com/w/c/atomic/atomic_store)"
- name: atomic_thread_fence
  summary: Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by order, without an associated atomic operation
  description: "# atomic_thread_fence\n\n[TABLE]\n\nEstablishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by `order`, without an associated atomic operation. For example, all non-atomic and relaxed atomic stores that happen before a [`memory_order_release`](memory_order \"c/atomic/memory order\") fence in thread A will be synchronized with non-atomic and relaxed atomic loads from the same locations made in thread B after an [`memory_order_acquire`](memory_order \"c/atomic/memory order\") fence.\n\n### Parameters\n\n|       |     |                                            |\n|-------|-----|--------------------------------------------|\n| order | \\-  | the memory ordering executed by this fence |\n\n### Return value\n\n(none)\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.4.1 The atomic_thread_fence function (p: 204)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.4.1 The atomic_thread_fence function (p: 278-279)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/atomic_thread_fence](https://en.cppreference.com/w/c/atomic/atomic_thread_fence)"
- name: ATOMIC_VAR_INIT
  summary: Expands to an expression that can be used to initialize an atomic variable of the same type as value
  description: "# ATOMIC_VAR_INIT\n\n[TABLE]\n\nExpands to an expression that can be used to initialize an atomic variable of the same type as `value`.\n\nThe initial value of atomic object of automatic storage duration that is not explicitly initialized is indeterminate. The default (zero) initialization of static and thread-local variables produces a valid value however.\n\nWhen initializing an atomic variable, any concurrent access, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a [`memory_order_relaxed`](memory_order \"c/atomic/memory order\") operation).\n\n### Notes\n\nThis macro was a part of early draft design for C11 atomic types. It is not needed in C11, and is deprecated in C17 and removed in C23.\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                                  | Correct behavior |\n|-----------------------------------------------------------------------------|------------|------------------------------------------------------------------------|------------------|\n| [DR 485](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_485) | C11        | the specification was redundant and contradictory to the core language | fixed            |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.2.1 The ATOMIC_VAR_INIT macro (p: 201)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.2.1 The ATOMIC_VAR_INIT macro (p: 274)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/ATOMIC_VAR_INIT](https://en.cppreference.com/w/c/atomic/ATOMIC_VAR_INIT)"
- name: Attribute specifier sequence(since C23)
  summary: Introduces implementation-defined attributes for types, objects, expressions, etc
  description: "# Attribute specifier sequence(since C23)\n\nIntroduces implementation-defined attributes for types, objects, expressions, etc.\n\n### Syntax\n\n`[[`attr \uFEFF`]]` `[[`attr1, attr2, attr3`(`args`)``]]` `[[`attribute-prefix`::`attr \uFEFF`(`args`)``]]`\n\nFormally, the syntax is\n\n|                          |     |             |\n|--------------------------|-----|-------------|\n| `[[` attribute-list `]]` |     | (since C23) |\n\nwhere attribute-list is a comma-separated sequence of zero or more attribute-token \uFEFFs\n\n|                                                                   |       |     |\n|-------------------------------------------------------------------|-------|-----|\n| standard-attribute                                                | \\(1\\) |     |\n| attribute-prefix `::` identifier                                  | \\(2\\) |     |\n| standard-attribute `(` argument-list \uFEFF(optional) `)`               | \\(3\\) |     |\n| attribute-prefix `::` identifier `(` argument-list \uFEFF(optional) `)` | \\(4\\) |     |\n\nwhere attribute-prefix is an identifier and argument-list is a sequence of tokens where parentheses, brackets and braces are balanced (balanced-token-sequence).\n\n1) standard attribute, such as \\[\\[fallthrough\\]\\]\n\n2) attribute with a namespace, such as \\[\\[gnu::unused\\]\\]\n\n3) standard attribute with arguments, such as \\[\\[deprecated(\"reason\")\\]\\]\n\n4) attribute with both a namespace and an argument list, such as \\[\\[gnu::nonnull(1)\\]\\]\n\n### Explanation\n\nAttributes provide the unified standard syntax for implementation-defined language extensions, such as the GNU and IBM language extensions `__attribute__((...))`, Microsoft extension `__declspec()`, etc.\n\nAn attribute can be used almost everywhere in the C program, and can be applied to almost everything: to types, to variables, to functions, to names, to code blocks, to entire translation units, although each particular attribute is only valid where it is permitted by the implementation: `[[expect_true]]` could be an attribute that can only be used with an `if`, and not with a class declaration. `[[omp::parallel()]]` could be an attribute that applies to a code block or to a `for` loop, but not to the type `int`, etc. (note these two attributes are fictional examples, see below for the standard and some non-standard attributes)\n\nIn declarations, attributes may appear both before the whole declaration and directly after the name of the entity that is declared, in which case they are combined. In most other situations, attributes apply to the directly preceding entity.\n\nTwo consecutive left square bracket tokens (`[[`) may only appear when introducing an attribute-specifier or inside an attribute argument.\n\nBesides the standard attributes listed below, implementations may support arbitrary non-standard attributes with implementation-defined behavior. All attributes unknown to an implementation are ignored without causing an error.\n\nEvery standard-attribute is reserved for standardization. That is, every non-standard attribute is prefixed by a attribute-prefix provided by the implementation, e.g. `[[gnu::may_alias]]` and `[[clang::no_sanitize]]`.\n\n### Standard attributes\n\nOnly the following attributes are defined by the C standard. Every standard attribute whose name is of form `attr` can be also spelled as `__attr__` and its meaning is not changed.\n\n[TABLE]\n\n### Attribute testing\n\n|                                          |     |     |\n|------------------------------------------|-----|-----|\n| `__has_c_attribute(` attribute-token `)` |     |     |\n\nChecks for the presence of an attribute token named by attribute-token.\n\nFor standard attributes, it will expand to the year and month in which the attribute was added to the working draft (see table below), the presence of vendor-specific attributes is determined by a non-zero integer constant.\n\n`__has_c_attribute` can be expanded in the expression of [` #if`](../preprocessor/conditional \"c/preprocessor/conditional\") and [` #elif`](../preprocessor/conditional \"c/preprocessor/conditional\"). It is treated as a defined macro by [` #ifdef`](../preprocessor/conditional \"c/preprocessor/conditional\"), [` #ifndef`](../preprocessor/conditional \"c/preprocessor/conditional\") and [`defined`](../preprocessor/conditional \"c/preprocessor/conditional\") but cannot be used anywhere else.\n\n[TABLE]\n\n### Example\n\n```\n[[gnu::hot]] [[gnu::const]] [[nodiscard]]\nint f(void); // declare f with three attributes\n \n[[gnu::const, gnu::hot, nodiscard]]\nint f(void); // the same as above, but uses a single attr\n             // specifier that contains three attributes\n \nint f(void) { return 0; }\n \nint main(void)\n{\n}\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.12 Attributes (p: TBD)\n\n### See also\n\n|                                                                                                                                       |     |\n|---------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/attributes \"cpp/language/attributes\") for Attribute specifier sequence |     |\n\n### External links\n\n|     |                                                                                                |\n|-----|------------------------------------------------------------------------------------------------|\n| 1\\. | [Attributes in GCC](https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax) |\n| 2\\. | [Attributes in Clang](https://clang.llvm.org/docs/AttributeReference.html)                     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes](https://en.cppreference.com/w/c/language/attributes)"
- name: auto
  summary: ''
  description: "# C keywords: auto\n\n### Usage\n\n- [automatic duration storage-class specifier](../language/storage_duration \"c/language/storage duration\") with no linkage.\n- type inference (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/auto](https://en.cppreference.com/w/c/keyword/auto)"
- name: Basic concepts
  summary: This section provides definitions for the specific terminology and the concepts used when describing the C programming language
  description: "# Basic concepts\n\nThis section provides definitions for the specific terminology and the concepts used when describing the C programming language.\n\nA C program is a sequence of text files (typically header and source files) that contain [declarations](declarations \"c/language/declarations\"). They undergo [translation](translation_phases \"c/language/translation phases\") to become an executable program, which is executed when the OS calls its [main function](main_function \"c/language/main function\") (unless it is itself the OS or another *freestanding* program, in which case the entry point is implementation-defined).\n\nCertain words in a C program have special meaning, they are [keywords](../keyword \"c/keyword\"). Others can be used as [identifiers](identifier \"c/language/identifier\"), which may be used to identify [objects](object \"c/language/object\"), [functions](functions \"c/language/functions\"), [struct](struct \"c/language/struct\"), [union](union \"c/language/union\"), or [enumeration](enum \"c/language/enum\") tags, their members, [typedef](typedef \"c/language/typedef\") names, [labels](statements#Labels \"c/language/statements\"), or [macros](../preprocessor/replace \"c/preprocessor/replace\").\n\nEach identifier (other than macro) is only valid within a part of the program called its [scope](scope \"c/language/scope\") and belongs to one of four kinds of [name spaces](name_space \"c/language/name space\"). Some identifiers have [linkage](storage_duration \"c/language/storage duration\") which makes them refer to the same entities when they appear in different scopes or translation units.\n\nDefinitions of functions include sequences of [statements](statements \"c/language/statements\") and [declarations](declarations \"c/language/declarations\"), some of which include [expressions](expressions \"c/language/expressions\"), which specify the computations to be performed by the program.\n\n[Declarations](declarations \"c/language/declarations\") and [expressions](expressions \"c/language/expressions\") create, destroy, access, and manipulate [objects](object \"c/language/object\"). Each [object](object \"c/language/object\"), [function](functions \"c/language/functions\"), and [expression](expressions \"c/language/expressions\") in C is associated with a [type](type \"c/language/type\").\n\n### See also\n\n|                                                                                                                                 |     |\n|---------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/basic_concepts \"cpp/language/basic concepts\") for Basic concepts |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/basic_concepts](https://en.cppreference.com/w/c/language/basic_concepts)"
- name: Binary resource inclusion
  summary: '#embed is a preprocessor directive to include (binary) resources in the build, where a resource is defined as a source of data accessible from the translation environment'
  description: "# Binary resource inclusion (since C23)\n\n\\#embed is a preprocessor directive to include (binary) resources in the build, where a resource is defined as a source of data accessible from the translation environment.\n\n### Syntax\n\n[TABLE]\n\n1) Searches for a resource identified uniquely by h-char-sequence and replaces the directive by a comma separated list of integers corresponding to the data of the resource.\n\n2) Searches for a resource identified by q-char-sequence and replaces the directive by a list of integers corresponding to the data of the resource. It may fallback to (1).\n\n3) If neither (1) nor (2) is matched, pp-tokens will undergo macro replacement. The directive after replacement will be tried to match with (1) or (2) again.\n\n4) Checks whether a resource is available for embedding, whether it is empty or not and whether the parameters passed are supported by the implementation.\n\n5) If (4) is not matched, h-pp-tokens and pp-balanced-token-sequence will undergo macro replacement. The directive after replacement will be tried to match with (4) again.\n\n[TABLE]\n\n### Explanation\n\n1) Searches for the resource identified by h-char-sequence in implementation-defined manner.\n\n2) Searches for the resource identified by q-char-sequence in implementation-defined manner. For (1,2), the implementations typically use a mechanism similar to, but distinct from, the implementation-defined search paths used for [source file inclusion](include \"c/preprocessor/include\"). The construct `__has_embed(__FILE__ ...` appears in one of the examples in the standard, suggesting, in case (2) at least, that the directory where the current file resides is expected to be searched.\n\n3) The preprocessing tokens after `embed` in the directive are processed just as in normal text (i.e., each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens). The directive resulting after all replacements shall match one of the two previous forms. The method by which a sequence of preprocessing tokens between `<` and `>` preprocessing token pair or a pair of `\"` characters is combined into a single header name preprocessing token is implementation-defined.\n\n4) The resource identified by h-char-sequence or q-char-sequence is searched for as if that preprocessing token sequence were the pp-tokens in syntax (3), except that no further macro expansion is performed. If such a directive would not satisfy the syntactic requirements of an \\#embed directive, the program is ill-formed. The `__has__embed` expression evaluates to `__STDC_EMBED_FOUND__` if the search for the resource succeeds, the resource is non empty and all the parameters are supported, to `__STDC_EMBED_EMPTY__` if the resource is empty and all the parameters are supported, and to `__STDC_EMBED_NOT_FOUND__` if the search fails or one of the parameters passed is not supported by the implementation.\n\n5) This form is considered only if syntax (4) does not match, in which case the preprocessing tokens are processed just as in normal text.\n\nIn the case the resource is not found or one of the parameters is not supported by the implementation, the program is ill-formed.\n\n`__has_embed` can be expanded in the expression of [` #if`](conditional \"c/preprocessor/conditional\") and [` #elif`](conditional \"c/preprocessor/conditional\"). It is treated as a defined macro by [` #ifdef`](conditional \"c/preprocessor/conditional\"), [` #ifndef`](conditional \"c/preprocessor/conditional\"), [` #elifdef`](conditional \"c/preprocessor/conditional\"), [` #elifndef`](conditional \"c/preprocessor/conditional\") and [`defined`](conditional \"c/preprocessor/conditional\") but cannot be used anywhere else.\n\nA resource has an *implementation resource width* which is the implementation-defined size in bits of the located resource. Its *resource width* is the implementation resource width unless modified by a `limit` parameter. If the resource width is 0, the resource is considered empty. The *embed element width* is equal to [`CHAR_BIT`](../types/limits \"c/types/limits\") unless modified by an implementation defined parameter. The resource width must be divisible by the embed element width.\n\nThe expansion of a \\#embed directive is a token sequence formed from the list of integer [constant expressions](../language/constant_expression \"c/language/constant expression\") described below. The group of tokens for each integer constant expression in the list is separated in the token sequence from the group of tokens for the previous integer constant expression in the list by a comma. The sequence neither begins nor ends in a comma. If the list of integer constant expressions is empty, the token sequence is empty. The directive is replaced by its expansion and, with the presence of certain embed parameters, additional or replacement token sequences.\n\nThe values of the integer constant expressions in the expanded sequence are determined by an implementation-defined mapping of the resource’s data. Each integer constant expression’s value is in the range `[`0`, `2^(embed element width)`)`. If:\n\n1.  The list of integer constant expressions is used to initialize an array of a type compatible with `unsigned char`, or compatible with `char` if `char` cannot hold negative values, and\n2.  The embed element width is equal to [`CHAR_BIT`](../types/limits \"c/types/limits\"),\n\nthen the contents of the initialized elements of the array are as-if the resource’s binary data is [`fread`](../io/fread \"c/io/fread\") into the array at translation time.\n\nImplementations are encouraged to take into account translation-time bit and byte orders as well as execution-time bit and byte orders to more appropriately represent the resource’s binary data from the directive. This maximizes the chance that, if the resource referenced at translation time through the \\#embed directive is the same one accessed through execution-time means, the data that is e.g. [`fread`](../io/fread \"c/io/fread\") or similar into contiguous storage will compare bit-for-bit equal to an array of character type initialized from an \\#embed directive’s expanded contents.\n\n### Parameters\n\nThe standard defines the parameters `limit`, `prefix`, `suffix` and `if_empty`. Any other parameter that appears in the directive must be implementation-defined, or the program is ill-formed. Implementation-defined embed parameters may change the semantics of the directive.\n\n#### limit\n\n|                                      |       |     |\n|--------------------------------------|-------|-----|\n| `limit(` constant-expression `)`     | \\(1\\) |     |\n| `__limit__(` constant-expression `)` | \\(2\\) |     |\n\nThe `limit` embed parameter can appear at most once in the embed parameter sequence. It must have an argument, which must be an integer (preprocessor) [constant expression](../language/constant_expression \"c/language/constant expression\") that evaluates to a non negative number and does not contain the token `defined`. The resource width is set to the minimum of the integer constant expression multiplied by the embed element width and the implementation resource width.\n\n#### suffix\n\n|                                                         |       |     |\n|---------------------------------------------------------|-------|-----|\n| `suffix(` pp-balanced-token-sequence \uFEFF(optional) `)`     | \\(1\\) |     |\n| `__suffix__(` pp-balanced-token-sequence \uFEFF(optional) `)` | \\(2\\) |     |\n\nThe `suffix` embed parameter can appear at most once in the embed parameter sequence. It must have a (possibly empty) preprocessor argument clause. If the resource is non empty, the contents of the parameter clause are placed immediately after the expansion of the directive. Otherwise, it has no effect.\n\n#### prefix\n\n|                                                         |       |     |\n|---------------------------------------------------------|-------|-----|\n| `prefix(` pp-balanced-token-sequence \uFEFF(optional) `)`     | \\(1\\) |     |\n| `__prefix__(` pp-balanced-token-sequence \uFEFF(optional) `)` | \\(2\\) |     |\n\nThe `prefix` embed parameter can appear at most once in the embed parameter sequence. It must have a (possibly empty) preprocessor argument clause. If the resource is non empty, the contents of the parameter clause are placed immediately before the expansion of the directive. Otherwise, it has no effect.\n\n#### if_empty\n\n|                                                           |       |     |\n|-----------------------------------------------------------|-------|-----|\n| `if_empty(` pp-balanced-token-sequence \uFEFF(optional) `)`     | \\(1\\) |     |\n| `__if_empty__(` pp-balanced-token-sequence \uFEFF(optional) `)` | \\(2\\) |     |\n\nThe `if_empty` embed parameter can appear at most once in the embed parameter sequence. It must have a (possibly empty) preprocessor argument clause. If the resource is empty, the contents of the parameter clause replace the directive. Otherwise, it has no effect.\n\n### Example\n\n```\n#include <stdint.h>\n#include <stdio.h>\n \nconst uint8_t image_data[] = {\n#embed \"image.png\"\n};\n \nconst char message[] = {\n#embed \"message.txt\" if_empty('M', 'i', 's', 's', 'i', 'n', 'g', '\\n')\n,'\\0' // null terminator\n};\n \nvoid dump(const uint8_t arr[], size_t size)\n{\n    for (size_t i = 0; i != size; ++i)\n        printf(\"%02X%c\", arr[i], (i + 1) % 16 ? ' ' : '\\n');\n    puts(\"\");\n}\n \nint main()\n{\n    puts(\"image_data[]:\");\n    dump(image_data, sizeof image_data);\n    puts(\"message[]:\");\n    dump((const uint8_t*)message, sizeof message);\n}\n```\n\nPossible output:\n\n```\nimage_data[]:\n89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52\n00 00 00 01 00 00 00 01 01 03 00 00 00 25 DB 56\n...\nmessage[]:\n4D 69 73 73 69 6E 67 0A 00\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.4.7 Header names (p: 69)\n  - 6.10.1 Conditional inclusion (p: 165-169)\n  - 6.10.2 Binary resource inclusion (p: 170-177)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/embed](https://en.cppreference.com/w/c/preprocessor/embed)"
- name: Bit-fields
  summary: Declares a member with explicit width, in bits
  description: "# Bit-fields\n\nDeclares a member with explicit width, in bits. Adjacent bit-field members may be packed to share and straddle the individual bytes.\n\nA bit-field declaration is a [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") member declaration which uses the following [declarator](declarations \"c/language/declarations\"):\n\n|                                 |     |     |\n|---------------------------------|-----|-----|\n| identifier \uFEFF(optional) `:` width |     |     |\n\n|            |     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n|------------|-----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| identifier | \\-  | a name of the bit-field that is being declared. The name is optional: nameless bit-fields introduce the specified number of bits of padding                                                                                                                                                                                                                                                                                                                             |\n| width      | \\-  | an integer [constant expression](constant_expression \"c/language/constant expression\") with a value greater or equal to zero and less or equal the number of bits in the underlying type. When greater than zero, this is the number of bits that this bit-field will occupy. The value zero is only allowed for nameless bit-fields and has special meaning: it specifies that the next bit-field in the class definition will begin at an allocation unit's boundary. |\n\n### Explanation\n\nBit-fields can have only one of these three(until C99) – four(since C99)(until C23) types (possibly [const](const \"c/language/const\") or [volatile](volatile \"c/language/volatile\") qualified):\n\n- `unsigned int`, for unsigned bit-fields (`unsigned int b:3;` has the range `0..7`)\n- `signed int`, for signed bit-fields (`signed int b:3;` has the range `-4..3`)\n- `int`, for bit-fields with implementation-defined signedness (Note that this differs from the meaning of the keyword `int` everywhere else, where it means \"signed int\"). For example, `int b:3;` may have the range of values `0..7` or `-4..3`.\n\n[TABLE]\n\nAdditional implementation-defined types may be acceptable. It is also implementation-defined whether a bit-field may have [atomic](atomic \"c/language/atomic\") type.(since C11) The number of bits in a bit-field (width) sets the limit to the range of values it can hold:\n\n```\n#include <stdio.h>\n \nstruct S\n{\n    // three-bit unsigned field,\n    // allowed values are 0...7\n    unsigned int b : 3;\n};\n \nint main(void)\n{\n    struct S s = {7};\n    ++s.b; // unsigned overflow\n    printf(\"%d\\n\", s.b); // output: 0\n}\n```\n\nMultiple adjacent bit-fields are permitted to be (and usually are) packed together:\n\n```\n#include <stdio.h>\n \nstruct S\n{\n    // will usually occupy 4 bytes:\n    // 5 bits: value of b1\n    // 11 bits: unused\n    // 6 bits: value of b2\n    // 2 bits: value of b3\n    // 8 bits: unused\n    unsigned b1 : 5, : 11, b2 : 6, b3 : 2;\n};\n \nint main(void)\n{\n    printf(\"%zu\\n\",sizeof(struct S)); // usually prints 4\n}\n```\n\nThe special *unnamed bit-field* of width zero breaks up padding: it specifies that the next bit-field begins at the beginning of the next allocation unit:\n\n```\n#include <stdio.h>\n \nstruct S\n{\n    // will usually occupy 8 bytes:\n    // 5 bits: value of b1\n    // 27 bits: unused\n    // 6 bits: value of b2\n    // 15 bits: value of b3\n    // 11 bits: unused\n    unsigned b1 : 5;\n    unsigned :0; // start a new unsigned int\n    unsigned b2 : 6;\n    unsigned b3 : 15;\n};\n \nint main(void)\n{\n    printf(\"%zu\\n\", sizeof(struct S)); // usually prints 8\n}\n```\n\nBecause bit-fields do not necessarily begin at the beginning of a byte, address of a bit-field cannot be taken. Pointers to bit-fields are not possible. Bit-fields cannot be used with [`sizeof`](sizeof \"c/language/sizeof\") and [`_Alignas`](_alignas \"c/language/ Alignas\")(since C11).\n\n### Notes\n\nThe following usages of bit-fields causes *undefined behavior*:\n\n- Calling [`offsetof`](../types/offsetof \"c/types/offsetof\") on a bit-field\n\nThe following properties of bit-fields are *unspecified*:\n\n- Alignment of the allocation unit that holds a bit-field\n\nThe following properties of bit-fields are *implementation-defined*:\n\n- Whether bit-fields of type `int` are treated as signed or unsigned\n- Whether types other than `int`, `signed int`, `unsigned int`, `_Bool`(since C99) and (possibly `unsigned`) `_BitInt(N)`(since C23) are permitted\n\n[TABLE]\n\n- Whether a bit-field can straddle an allocation unit boundary\n- The order of bit-fields within an allocation unit (on some platforms, bit-fields are packed left-to-right, on others right-to-left)\n\n|                                                                                                                                                                                                         |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Even though the number of bits in the object representation of `_Bool` is at least [`CHAR_BIT`](../types/limits \"c/types/limits\"), the width of the bit-field of type `_Bool` cannot be greater than 1. | (since C99) |\n\nIn the C++ programming language, the width of a bit-field can exceed the width of the underlying type (but the extra bits are padding bits), and bit-fields of type `int` are always signed.\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.2.1 Structure and union specifiers\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.2.1 Structure and union specifiers\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.2.1 Structure and union specifiers\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.2.1 Structure and union specifiers\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.5.2.1 Structure and union specifiers\n\n### See also\n\n|                                                                                                                  |     |\n|------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/bit_field \"cpp/language/bit field\") for Bit-field |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/bit_field](https://en.cppreference.com/w/c/language/bit_field)"
- name: bool
  summary: ''
  description: "# C keywords: bool (since C23)\n\n### Usage\n\n- [boolean type](../language/arithmetic_types#Boolean_type \"c/language/arithmetic types\"): as the declaration of the type (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/bool](https://en.cppreference.com/w/c/keyword/bool)"
- name: break
  summary: ''
  description: "# C keywords: break\n\n### Usage\n\n- [`break` statement](../language/break \"c/language/break\"): as the declaration of the statement\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/break](https://en.cppreference.com/w/c/keyword/break)"
- name: break statement
  summary: Causes the enclosing for, while or do-while loop or switch statement to terminate
  description: "# break statement\n\nCauses the enclosing [for](for \"c/language/for\"), [while](while \"c/language/while\") or [do-while](do \"c/language/do\") loop or [switch statement](switch \"c/language/switch\") to terminate.\n\nUsed when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.\n\n### Syntax\n\n|                                      |     |     |\n|--------------------------------------|-----|-----|\n| attr-spec-seq \uFEFF(optional) `break` `;` |     |     |\n\n|               |     |                                                                                                           |\n|---------------|-----|-----------------------------------------------------------------------------------------------------------|\n| attr-spec-seq | \\-  | (C23) optional list of [attributes](attributes \"c/language/attributes\"), applied to the `break` statement |\n\nAppears only within the statement of a loop body ([`while`](while \"c/language/while\"), [`do-while`](do \"c/language/do\"), [`for`](for \"c/language/for\")) or within the statement of a [`switch`](switch \"c/language/switch\").\n\n### Explanation\n\nAfter this statement the control is transferred to the statement or declaration immediately following the enclosing loop or switch, as if by [`goto`](goto \"c/language/goto\").\n\n### Keywords\n\n[`break`](../keyword/break \"c/keyword/break\")\n\n### Notes\n\nA break statement cannot be used to break out of multiple nested loops. The [`goto` statement](goto \"c/language/goto\") may be used for this purpose.\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    int i = 2;\n    switch (i)\n    {\n        case 1: printf(\"1\");\n        case 2: printf(\"2\");   // i==2, so execution starts at this case label\n        case 3: printf(\"3\");\n        case 4:\n        case 5: printf(\"45\");\n                break;         // execution of subsequent cases is terminated\n        case 6: printf(\"6\");\n    }\n    printf(\"\\n\");\n \n    // Compare outputs from these two nested for loops.\n    for (int j = 0; j < 2; j++)\n        for (int k = 0; k < 5; k++)\n            printf(\"%d%d \", j,k);\n    printf(\"\\n\");\n \n    for (int j = 0; j < 2; j++)\n    {\n        for (int k = 0; k < 5; k++) // only this loop is exited by break\n        {\n            if (k == 2)\n                break;\n            printf(\"%d%d \", j,k);\n        }\n    }\n}\n```\n\nPossible output:\n\n```\n2345\n00 01 02 03 04 10 11 12 13 14\n00 01 10 11\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.8.6.3 The break statement (p: 111)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.8.6.3 The break statement (p: 153)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.8.6.3 The break statement (p: 138)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.6.6.3 The break statement\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/break](https://en.cppreference.com/w/c/language/break)"
- name: bsearch
  summary: If the array contains several elements that comp would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result
  description: "# bsearch, bsearch_s\n\n[TABLE]\n\n1) Finds an element equal to element pointed to by `key` in an array pointed to by `ptr`. The array contains `count` elements of `size` bytes and must be partitioned with respect to `key`, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by `comp`. The behavior is undefined if the array is not already partitioned with respect to `*key` in ascending order according to the same criterion that `comp` uses.\n\n2) Same as (1), except that the additional state argument `context` is passed to `comp` and that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `count` or `size` is greater than `RSIZE_MAX`\n- `key`, `ptr` or `comp` is a null pointer (unless `count` is zero)\n\nAs with all bounds-checked functions, `bsearch_s` (and the corresponding type-generic macro)(since C23) is only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../program \"c/program\").\n\n3,4) Type-generic macros equivalent to (1) and (2) respectively. Let `T` be a unqualified object type (including `void`).\n\n- If `ptr` is of type `const T*`, the return type is `const void*`.\n- Otherwise, if `ptr` is of type `T*`, the return type is `void*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(bsearch)`, `(bsearch_s)`, or a function pointer is used), the actual function declaration (1) or (2) becomes visible.\n\nIf the array contains several elements that `comp` would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.\n\n|                                                               |             |\n|---------------------------------------------------------------|-------------|\n| Direct usages of actual functions (1) and (2) are deprecated. | (since C23) |\n\n### Parameters\n\n[TABLE]\n\n### Return value\n\n1) Pointer to an element in the array that compares equal to `*key`, or null pointer if such element has not been found.\n\n2) Same as (1), except that the null pointer is also returned on runtime constraints violations.\n\n3,4) Same as (1) and (2) respectively, except that cv-qualification is adjusted.\n\n### Notes\n\nDespite the name, neither C nor POSIX standards require this function to be implemented using binary search or make any complexity guarantees.\n\nUnlike other bounds-checked functions, `bsearch_s` does not treat arrays of zero size as a runtime constraint violation and instead indicates element not found (the other function that accepts arrays of zero size is `qsort_s`).\n\nUntil `bsearch_s`, users of `bsearch` often used global variables to represent the state of the comparator.\n\n### Example\n\n```\n#include <stdlib.h>\n#include <stdio.h>\n \nstruct data {\n    int nr;\n    char const *value;\n} dat[] = {\n    {1, \"Foo\"}, {2, \"Bar\"}, {3, \"Hello\"}, {4, \"World\"}\n};\n \nint data_cmp(void const *lhs, void const *rhs) \n{\n    struct data const *const l = lhs;\n    struct data const *const r = rhs;\n \n    if (l->nr < r->nr) return -1;\n    else if (l->nr > r->nr) return 1;\n    else return 0;\n \n    // return (l->nr > r->nr) - (l->nr < r->nr); // possible shortcut\n    // return l->nr - r->nr; // erroneous shortcut (fails if INT_MIN is present)\n}\n \nint main(void) \n{\n    struct data key = { .nr = 3 };\n    struct data const *res = bsearch(&key, dat, sizeof dat / sizeof dat[0],\n                                     sizeof dat[0], data_cmp);\n    if (res) {\n        printf(\"No %d: %s\\n\", res->nr, res->value);\n    } else {\n        printf(\"No %d not found\\n\", key.nr);\n    }\n}\n```\n\nOutput:\n\n```\nNo 3: Hello\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.5.1 The bsearch function (p: 258)\n  - K.3.6.3.1 The bsearch_s function (p: 441-442)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.5.1 The bsearch function (p: 355)\n  - K.3.6.3.1 The bsearch_s function (p: 608-609)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.5.1 The bsearch function (p: 318-319)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.5.1 The bsearch function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/algorithm/bsearch](https://en.cppreference.com/w/c/algorithm/bsearch)"
- name: bsearch_s
  summary: If the array contains several elements that comp would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result
  description: "# bsearch, bsearch_s\n\n[TABLE]\n\n1) Finds an element equal to element pointed to by `key` in an array pointed to by `ptr`. The array contains `count` elements of `size` bytes and must be partitioned with respect to `key`, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by `comp`. The behavior is undefined if the array is not already partitioned with respect to `*key` in ascending order according to the same criterion that `comp` uses.\n\n2) Same as (1), except that the additional state argument `context` is passed to `comp` and that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `count` or `size` is greater than `RSIZE_MAX`\n- `key`, `ptr` or `comp` is a null pointer (unless `count` is zero)\n\nAs with all bounds-checked functions, `bsearch_s` (and the corresponding type-generic macro)(since C23) is only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../program \"c/program\").\n\n3,4) Type-generic macros equivalent to (1) and (2) respectively. Let `T` be a unqualified object type (including `void`).\n\n- If `ptr` is of type `const T*`, the return type is `const void*`.\n- Otherwise, if `ptr` is of type `T*`, the return type is `void*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(bsearch)`, `(bsearch_s)`, or a function pointer is used), the actual function declaration (1) or (2) becomes visible.\n\nIf the array contains several elements that `comp` would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.\n\n|                                                               |             |\n|---------------------------------------------------------------|-------------|\n| Direct usages of actual functions (1) and (2) are deprecated. | (since C23) |\n\n### Parameters\n\n[TABLE]\n\n### Return value\n\n1) Pointer to an element in the array that compares equal to `*key`, or null pointer if such element has not been found.\n\n2) Same as (1), except that the null pointer is also returned on runtime constraints violations.\n\n3,4) Same as (1) and (2) respectively, except that cv-qualification is adjusted.\n\n### Notes\n\nDespite the name, neither C nor POSIX standards require this function to be implemented using binary search or make any complexity guarantees.\n\nUnlike other bounds-checked functions, `bsearch_s` does not treat arrays of zero size as a runtime constraint violation and instead indicates element not found (the other function that accepts arrays of zero size is `qsort_s`).\n\nUntil `bsearch_s`, users of `bsearch` often used global variables to represent the state of the comparator.\n\n### Example\n\n```\n#include <stdlib.h>\n#include <stdio.h>\n \nstruct data {\n    int nr;\n    char const *value;\n} dat[] = {\n    {1, \"Foo\"}, {2, \"Bar\"}, {3, \"Hello\"}, {4, \"World\"}\n};\n \nint data_cmp(void const *lhs, void const *rhs) \n{\n    struct data const *const l = lhs;\n    struct data const *const r = rhs;\n \n    if (l->nr < r->nr) return -1;\n    else if (l->nr > r->nr) return 1;\n    else return 0;\n \n    // return (l->nr > r->nr) - (l->nr < r->nr); // possible shortcut\n    // return l->nr - r->nr; // erroneous shortcut (fails if INT_MIN is present)\n}\n \nint main(void) \n{\n    struct data key = { .nr = 3 };\n    struct data const *res = bsearch(&key, dat, sizeof dat / sizeof dat[0],\n                                     sizeof dat[0], data_cmp);\n    if (res) {\n        printf(\"No %d: %s\\n\", res->nr, res->value);\n    } else {\n        printf(\"No %d not found\\n\", key.nr);\n    }\n}\n```\n\nOutput:\n\n```\nNo 3: Hello\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.5.1 The bsearch function (p: 258)\n  - K.3.6.3.1 The bsearch_s function (p: 441-442)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.5.1 The bsearch function (p: 355)\n  - K.3.6.3.1 The bsearch_s function (p: 608-609)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.5.1 The bsearch function (p: 318-319)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.5.1 The bsearch function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/algorithm/bsearch](https://en.cppreference.com/w/c/algorithm/bsearch)"
- name: btowc
  summary: Widens a single-byte character c (reinterpreted as unsigned char) to its wide character equivalent
  description: "# btowc\n\n[TABLE]\n\nWidens a single-byte character `c` (reinterpreted as `unsigned char`) to its wide character equivalent.\n\nMost multibyte character encodings use single-byte codes to represent the characters from the ASCII character set. This function may be used to convert such characters to `wchar_t`.\n\n### Parameters\n\n|     |     |                                |\n|-----|-----|--------------------------------|\n| c   | \\-  | single-byte character to widen |\n\n### Return value\n\n`WEOF` if `c` is [`EOF`](../../io \"c/io\")\n\nwide character representation of `c` if `(unsigned char)c` is a valid single-byte character in the initial shift state, `WEOF` otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <assert.h>\n \nvoid try_widen(unsigned char c)\n{\n    wint_t w = btowc(c);\n    if(w != WEOF)\n        printf(\"The single-byte character %#x widens to %#x\\n\", c, w);\n    else\n        printf(\"The single-byte character %#x failed to widen\\n\", c);\n}\n \nint main(void)\n{\n    char *loc = setlocale(LC_ALL, \"lt_LT.iso88594\");\n    assert(loc);\n    printf(\"In Lithuanian ISO-8859-4 locale:\\n\");\n    try_widen('A');\n    try_widen('\\xdf'); // German letter ß (U+00df) in ISO-8859-4\n    try_widen('\\xf9'); // Lithuanian letter ų (U+0173) in ISO-8859-4\n \n    setlocale(LC_ALL, \"lt_LT.utf8\");\n    printf(\"In Lithuanian UTF-8 locale:\\n\");\n    try_widen('A');\n    try_widen('\\xdf');\n    try_widen('\\xf9');\n}\n```\n\nPossible output:\n\n```\nIn Lithuanian ISO-8859-4 locale:\nThe single-byte character 0x41 widens to 0x41\nThe single-byte character 0xdf widens to 0xdf\nThe single-byte character 0xf9 widens to 0x173\nIn Lithuanian UTF-8 locale:\nThe single-byte character 0x41 widens to 0x41\nThe single-byte character 0xdf failed to widen\nThe single-byte character 0xf9 failed to widen\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.1.1 The btowc function (p: 441)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.1.1 The btowc function (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/btowc](https://en.cppreference.com/w/c/string/multibyte/btowc)"
- name: 'C attribute: deprecated'
  summary: Indicates that the name or entity declared with this attribute is deprecated, that is, the use is allowed, but discouraged for some reason
  description: "# C attribute: deprecated (since C23)\n\nIndicates that the name or entity declared with this attribute is [deprecated](https://en.wikipedia.org/wiki/Deprecation \"enwiki:Deprecation\"), that is, the use is allowed, but discouraged for some reason.\n\n### Syntax\n\n[TABLE]\n\n|                |     |                                                                                                       |\n|----------------|-----|-------------------------------------------------------------------------------------------------------|\n| string-literal | \\-  | text that could be used to explain the rationale for deprecation and/or to suggest a replacing entity |\n\n### Explanation\n\nIndicates that the use of the name or entity declared with this attribute is allowed, but discouraged for some reason. Compilers typically issue warnings on such uses. The string-literal, if specified, is usually included in the warnings.\n\nThis attribute is allowed in declarations of the following names or entities:\n\n- [struct](../struct \"c/language/struct\")/[union](../union \"c/language/union\"): `struct [[deprecated]] S;`,\n- [typedef-name](../typedef \"c/language/typedef\"): `[[deprecated]] typedef S* PS;`,\n- objects: `[[deprecated]] int x;`,\n- struct/union member: `union U { [[deprecated]] int n; };`,\n- [function](../function_definition \"c/language/function definition\"): `[[deprecated]] void f(void);`,\n- [enumeration](../enum \"c/language/enum\"): `enum [[deprecated]] E {};`,\n- enumerator: `enum { A [[deprecated]], B [[deprecated]] = 42 };`.\n\nA name declared non-deprecated may be redeclared deprecated. A name declared deprecated cannot be un-deprecated by redeclaring it without this attribute.\n\n### Example\n\n```\n#include <stdio.h>\n \n[[deprecated]]\nvoid TriassicPeriod(void)\n{\n    puts(\"Triassic Period: [251.9 - 208.5] million years ago.\");\n}\n \n[[deprecated(\"Use NeogenePeriod() instead.\")]]\nvoid JurassicPeriod(void)\n{\n    puts(\"Jurassic Period: [201.3 - 152.1] million years ago.\");\n}\n \n[[deprecated(\"Use calcSomethingDifferently(int).\")]]\nint calcSomething(int x)\n{\n    return x * 2;\n}\n \nint main(void)\n{\n    TriassicPeriod();\n    JurassicPeriod();\n}\n```\n\nPossible output:\n\n```\nTriassic Period: [251.9 - 208.5] million years ago.\nJurassic Period: [201.3 - 152.1] million years ago.\n \nprog.c:23:5: warning: 'TriassicPeriod' is deprecated [-Wdeprecated-declarations]\n    TriassicPeriod();\n    ^\nprog.c:3:3: note: 'TriassicPeriod' has been explicitly marked deprecated here\n[[deprecated]]\n  ^\nprog.c:24:5: warning: 'JurassicPeriod' is deprecated: Use NeogenePeriod() instead. [-Wdeprecated-declarations]\n    JurassicPeriod();\n    ^\nprog.c:9:3: note: 'JurassicPeriod' has been explicitly marked deprecated here\n[[deprecated(\"Use NeogenePeriod() instead.\")]]\n  ^\n2 warnings generated.\n```\n\n### See also\n\n|                                                                                                                                             |     |\n|---------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/attributes/deprecated \"cpp/language/attributes/deprecated\") for `deprecated` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes/deprecated](https://en.cppreference.com/w/c/language/attributes/deprecated)"
- name: 'C attribute: fallthrough'
  summary: Indicates that the fall through from the previous case label is intentional and should not be diagnosed by a compiler that warns on fallthrough
  description: "# C attribute: fallthrough (since C23)\n\nIndicates that the fall through from the previous case label is intentional and should not be diagnosed by a compiler that warns on fallthrough.\n\n### Syntax\n\n[TABLE]\n\n### Explanation\n\nMay only be used in an [attribute declaration](../declarations \"c/language/declarations\") to create a *fallthrough declaration* (`[[fallthrough]];`).\n\nA fallthrough declaration may only be used in a [`switch`](../switch \"c/language/switch\") statement, where the next block item (statement, declaration, or label) to be encounted is a statement with a `case` or `default` label for that switch statement.\n\nIndicates that the fall through from the previous case label is intentional and should not be diagnosed by a compiler that warns on fallthrough.\n\n### Example\n\n```\n#include <stdbool.h>\n \nvoid g(void) {}\nvoid h(void) {}\nvoid i(void) {}\n \nvoid f(int n) {\n  switch (n) {\n    case 1:\n    case 2:\n      g();\n     [[fallthrough]];\n    case 3: // no warning on fallthrough\n      h();\n    case 4: // compiler may warn on fallthrough\n      if(n < 3) {\n          i();\n          [[fallthrough]]; // OK\n      }\n      else {\n          return;\n      }\n    case 5:\n      while (false) {\n        [[fallthrough]]; // ill-formed: no subsequent case or default label\n      }\n    case 6:\n      [[fallthrough]]; // ill-formed: no subsequent case or default label\n  }\n}\n \nint main(void) {}\n```\n\n### See also\n\n|                                                                                                                                                |     |\n|------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/attributes/fallthrough \"cpp/language/attributes/fallthrough\") for `fallthrough` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes/fallthrough](https://en.cppreference.com/w/c/language/attributes/fallthrough)"
- name: 'C attribute: maybe_unused'
  summary: Suppresses warnings on unused entities
  description: "# C attribute: maybe_unused (since C23)\n\nSuppresses warnings on unused entities.\n\n### Syntax\n\n[TABLE]\n\n### Explanation\n\nThis attribute can appear in the declaration of the following entities:\n\n- [struct](../struct \"c/language/struct\")/[union](../union \"c/language/union\"): `struct [[maybe_unused]] S;`,\n- [typedef name](../typedef \"c/language/typedef\"): `[[maybe_unused]] typedef S* PS;`,\n- object: `[[maybe_unused]] int x;`,\n- struct/union member: `union U { [[maybe_unused]] int n; };`,\n- [function](../function_definition \"c/language/function definition\"): `[[maybe_unused]] void f(void);`,\n- [enumeration](../enum \"c/language/enum\"): `enum [[maybe_unused]] E {};`,\n- enumerator: `enum { A [[maybe_unused]], B [[maybe_unused]] = 42 };`.\n\nIf the compiler issues warnings on unused entities, that warning is suppressed for any entity declared `maybe_unused`.\n\n### Example\n\n```\n#include <assert.h>\n \n[[maybe_unused]] void f([[maybe_unused]] _Bool cond1, [[maybe_unused]] _Bool cond2)\n{\n   [[maybe_unused]] _Bool b = cond1 && cond2;\n   assert(b); // in release mode, assert is compiled out, and b is unused\n              // no warning because it is declared [[maybe_unused]]\n} // parameters cond1 and cond2 are not used, no warning\n \nint main(void)\n{\n    f(1, 1);\n}\n```\n\n### See also\n\n|                                                                                                                                                   |     |\n|---------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/attributes/maybe_unused \"cpp/language/attributes/maybe unused\") for `maybe_unused` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes/maybe_unused](https://en.cppreference.com/w/c/language/attributes/maybe_unused)"
- name: 'C attribute: nodiscard'
  summary: If a function declared nodiscard or a function returning a struct/union/enum declared nodiscard by value is called from a discarded-value expression other than a cast to void, the compiler is encouraged to issue a warning
  description: "# C attribute: nodiscard (since C23)\n\nIf a function declared `nodiscard` or a function returning a struct/union/enum declared `nodiscard` by value is called from a [discarded-value expression](../expressions \"c/language/expressions\") other than a cast to `void`, the compiler is encouraged to issue a warning.\n\n### Syntax\n\n[TABLE]\n\n|                |     |                                                                                             |\n|----------------|-----|---------------------------------------------------------------------------------------------|\n| string-literal | \\-  | text that could be used to explain the rationale for why the result should not be discarded |\n\n### Explanation\n\nAppears in a function declaration, enumeration declaration, or struct/union declaration.\n\nIf, from a [discarded-value expression](../expressions \"c/language/expressions\") other than a cast to `void`,\n\n- a function declared `nodiscard` is called, or\n- a function returning a struct/union/enum declared `nodiscard` is called,\n\nthe compiler is encouraged to issue a warning.\n\nThe string-literal, if specified, is usually included in the warnings.\n\n### Example\n\n```\nstruct [[nodiscard]] error_info { int status; /*...*/ };\nstruct error_info enable_missile_safety_mode() { /*...*/ return (struct error_info){0}; }\nvoid launch_missiles() { /*...*/ }\nvoid test_missiles() {\n   enable_missile_safety_mode(); // compiler may warn on discarding a nodiscard value\n   launch_missiles();\n}\nstruct error_info* foo() { static struct error_info e; /*...*/ return &e; }\nvoid f1() {\n    foo(); // nodiscard type itself is not returned, no warning\n}\n// nodiscard( string-literal ):\n[[nodiscard(\"PURE FUN\")]] int strategic_value(int x, int y) { return x ^ y; }\n \nint main()\n{\n    strategic_value(4,2); // compiler may warn on discarding a nodiscard value\n    int z = strategic_value(0,0); // OK: return value is not discarded\n    return z;\n}\n```\n\nPossible output:\n\n```\ngame.cpp:5:4: warning: ignoring return value of function declared with 'nodiscard' attribute\ngame.cpp:17:5: warning: ignoring return value of function declared with 'nodiscard' attribute: PURE FUN\n```\n\n### See also\n\n|                                                                                                                                          |     |\n|------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/attributes/nodiscard \"cpp/language/attributes/nodiscard\") for `nodiscard` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes/nodiscard](https://en.cppreference.com/w/c/language/attributes/nodiscard)"
- name: 'C attribute: noreturn'
  summary: Indicates that the function does not return
  description: "# C attribute: noreturn, \\_Noreturn (since C23)\n\nIndicates that the function does not return.\n\n### Syntax\n\n[TABLE]\n\n### Explanation\n\nIndicates that the function does not return.\n\nThis attribute applies to the name of the function and specifies that the function does not return by executing the return statement or by reaching the end of the function body (it may return by executing [`longjmp`](../../program/longjmp \"c/program/longjmp\")). The behavior is undefined if the function with this attribute actually returns. A compiler diagnostic is recommended if this can be detected.\n\nIt has been previously denoted by the keyword [`_Noreturn`](../_noreturn \"c/language/ Noreturn\") until it was deprecated since C23 and replaced by this attribute.\n\n### Standard library\n\nThe following standard functions are declared with `noreturn` attribute (they used to be declared with [`_Noreturn`](../_noreturn \"c/language/ Noreturn\") specifier until C23):\n\n- [`abort()`](../../program/abort \"c/program/abort\")\n- [`exit()`](../../program/exit \"c/program/exit\")\n- [`_Exit()`](../../program/_exit \"c/program/ Exit\")\n- [`quick_exit()`](../../program/quick_exit \"c/program/quick exit\")\n- [`thrd_exit()`](../../thread/thrd_exit \"c/thread/thrd exit\")\n- [`longjmp()`](../../program/longjmp \"c/program/longjmp\")\n\n### See also\n\n|                                                                                                                                           |     |\n|-------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C documentation](../_noreturn \"c/language/ Noreturn\") for `_Noreturn`                                                                    |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/attributes/noreturn \"cpp/language/attributes/noreturn\") for `[[noreturn]]` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes/noreturn](https://en.cppreference.com/w/c/language/attributes/noreturn)"
- name: 'C attribute: unsequenced'
  summary: Provides the compiler with information about the access of objects by a function such that certain properties of function calls can be deduced
  description: "# C attribute: unsequenced, reproducible (since C23)\n\nProvides the compiler with information about the access of objects by a function such that certain properties of function calls can be deduced.\n\n### Syntax\n\n[TABLE]\n\n1) Indicates that a function is effectless, idempotent, stateless, and independent\n\n2) Indicates that a function is effectless and idempotent\n\n### Explanation\n\nThese attributes apply to a function declarator or to a type specifier that has a function type. The corresponding attribute is a property of the function type.\n\n#### Effectless\n\nAn evaluation of a function call is effectless if any store operation that is sequenced during the call is the modification of an object that synchronizes with the call; if additionally the operation is observable, all access to the object must be based on a unique pointer parameter of the function.\n\n#### Idempotent\n\nAn evaluation E is idempotent if a second evaluation of E can be sequenced immediately after the original one without changing the resulting value, if any, or the observable state of the execution.\n\n#### Stateless\n\nA function F is stateless if any definition of an object of static or thread [storage duration](../storage_duration \"c/language/storage duration\") in F or in a function that is called by F is `const` but not `volatile` qualified.\n\n#### Independent\n\nA function F is independent if for any object X that is observed by a call to F through an lvalue that is not based on a parameter of the call, all accesses to X in all calls to F during the same program execution observe the same value; otherwise if the access is based on a pointer parameter, there shall be a unique such pointer parameter P such that any access to X shall be to an lvalue that is based on P.\n\nAn object X is observed by a function call if both synchronize, if X is not local to the call, if X has a lifetime that starts before the function call, and if an access of X is sequenced during the call; the last value of X, if any, that is stored before the call is said to be the value of X that is observed by the call.\n\n### Notes\n\nThese attributes exist for the purpose of compiler optimization.\n\nIf a function is reproducible, multiple subsequent calls can be treated as a single call.\n\nIf a function is unsequenced, multiple subsequent calls can be treated as a single call, and the calls can be parallelized and reordered arbitrarily.\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes/reproducible](https://en.cppreference.com/w/c/language/attributes/reproducible)"
- name: 'C attribute: unsequenced'
  summary: Provides the compiler with information about the access of objects by a function such that certain properties of function calls can be deduced
  description: "# C attribute: unsequenced, reproducible (since C23)\n\nProvides the compiler with information about the access of objects by a function such that certain properties of function calls can be deduced.\n\n### Syntax\n\n[TABLE]\n\n1) Indicates that a function is effectless, idempotent, stateless, and independent\n\n2) Indicates that a function is effectless and idempotent\n\n### Explanation\n\nThese attributes apply to a function declarator or to a type specifier that has a function type. The corresponding attribute is a property of the function type.\n\n#### Effectless\n\nAn evaluation of a function call is effectless if any store operation that is sequenced during the call is the modification of an object that synchronizes with the call; if additionally the operation is observable, all access to the object must be based on a unique pointer parameter of the function.\n\n#### Idempotent\n\nAn evaluation E is idempotent if a second evaluation of E can be sequenced immediately after the original one without changing the resulting value, if any, or the observable state of the execution.\n\n#### Stateless\n\nA function F is stateless if any definition of an object of static or thread [storage duration](../storage_duration \"c/language/storage duration\") in F or in a function that is called by F is `const` but not `volatile` qualified.\n\n#### Independent\n\nA function F is independent if for any object X that is observed by a call to F through an lvalue that is not based on a parameter of the call, all accesses to X in all calls to F during the same program execution observe the same value; otherwise if the access is based on a pointer parameter, there shall be a unique such pointer parameter P such that any access to X shall be to an lvalue that is based on P.\n\nAn object X is observed by a function call if both synchronize, if X is not local to the call, if X has a lifetime that starts before the function call, and if an access of X is sequenced during the call; the last value of X, if any, that is stored before the call is said to be the value of X that is observed by the call.\n\n### Notes\n\nThese attributes exist for the purpose of compiler optimization.\n\nIf a function is reproducible, multiple subsequent calls can be treated as a single call.\n\nIf a function is unsequenced, multiple subsequent calls can be treated as a single call, and the calls can be parallelized and reordered arbitrarily.\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes/unsequenced](https://en.cppreference.com/w/c/language/attributes/unsequenced)"
- name: C keywords
  summary: This is a list of reserved keywords in C
  description: "# C keywords\n\nThis is a list of reserved keywords in C. Since they are used by the language, these keywords are not available for re-definition. As an exception, they are not considered reserved in [attribute-tokens](language/attributes \"c/language/attributes\")(since C23)\n\n[TABLE]\n\nThe most common keywords that begin with an underscore are generally used through their convenience macros:\n\n|                                                                                                                                                        |                                                                                 |                 |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------|-----------------|\n| keyword                                                                                                                                                | used as                                                                         | defined in      |\n| [`_Alignas`](keyword/_alignas \"c/keyword/ Alignas\") (C11)                                                                                              | [`alignas`](types \"c/types\") (removed in C23)                                   | `stdalign.h`    |\n| [`_Alignof`](keyword/_alignof \"c/keyword/ Alignof\") (C11)                                                                                              | [`alignof`](types \"c/types\") (removed in C23)                                   | `stdalign.h`    |\n| [`_Atomic`](keyword/_atomic \"c/keyword/ Atomic\") (C11)                                                                                                 | [`atomic_bool, atomic_int, ...`](thread \"c/thread\")                             | `stdatomic.h`   |\n| [`_BitInt`](https://en.cppreference.com/mwiki/index.php?title=c/keyword/_BitInt&action=edit&redlink=1 \"c/keyword/ BitInt (page does not exist)\") (C23) | (no macro)                                                                      |                 |\n| [`_Bool`](keyword/_bool \"c/keyword/ Bool\") (C99)                                                                                                       | [`bool`](types \"c/types\") (removed in C23)                                      | `stdbool.h`     |\n| [`_Complex`](keyword/_complex \"c/keyword/ Complex\") (C99)                                                                                              | [`complex`](numeric/complex/complex \"c/numeric/complex/complex\")                | `complex.h`     |\n| [`_Decimal128`](keyword/_decimal128 \"c/keyword/ Decimal128\") (C23)                                                                                     | (no macro)                                                                      |                 |\n| [`_Decimal32`](keyword/_decimal32 \"c/keyword/ Decimal32\") (C23)                                                                                        | (no macro)                                                                      |                 |\n| [`_Decimal64`](keyword/_decimal64 \"c/keyword/ Decimal64\") (C23)                                                                                        | (no macro)                                                                      |                 |\n| [`_Generic`](keyword/_generic \"c/keyword/ Generic\") (C11)                                                                                              | (no macro)                                                                      |                 |\n| [`_Imaginary`](keyword/_imaginary \"c/keyword/ Imaginary\") (C99)                                                                                        | [`imaginary`](numeric/complex/imaginary \"c/numeric/complex/imaginary\")          | `complex.h`     |\n| [`_Noreturn`](keyword/_noreturn \"c/keyword/ Noreturn\") (C11)                                                                                           | [`noreturn`](types \"c/types\")                                                   | `stdnoreturn.h` |\n| [`_Static_assert`](keyword/_static_assert \"c/keyword/ Static assert\") (C11)                                                                            | [`static_assert`](error/static_assert \"c/error/static assert\") (removed in C23) | `assert.h`      |\n| [`_Thread_local`](keyword/_thread_local \"c/keyword/ Thread local\") (C11)                                                                               | [`thread_local`](thread/thread_local \"c/thread/thread local\") (removed in C23)  | `threads.h`     |\n\nAlso, each name that begins with a double underscore `__` or an underscore `_` followed by an uppercase letter is reserved: see [identifier](language/identifier#Reserved_identifiers \"c/language/identifier\") for details.\n\nNote that digraphs `<%`, `%>`, `<:`, `:>`, `%:`, and `%:%:` provide an [alternative way to represent standard tokens](language/operator_alternative \"c/language/operator alternative\").\n\nThe following tokens are recognized by the [preprocessor](preprocessor \"c/preprocessor\") when they are used *within* the context of a preprocessor directive:\n\n[TABLE]\n\nThe following tokens are recognized by the preprocessor when they are used *outside* the context of a preprocessor directive:\n\n|                                                            |\n|------------------------------------------------------------|\n| [`_Pragma`](preprocessor/impl \"c/preprocessor/impl\") (C99) |\n\nThe following additional keywords are classified as extensions and conditionally-supported:\n\n[TABLE]\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.4.1 Keywords (p: TBD)\n  - J.5.9 The fortran keyword (p: TBD)\n  - J.5.10 The asm keyword (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.4.1 Keywords (p: 42-43)\n  - J.5.9 The fortran keyword (p: 422)\n  - J.5.10 The asm keyword (p: 422)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.4.1 Keywords (p: 58-59)\n  - J.5.9 The fortran keyword (p: 580)\n  - J.5.10 The asm keyword (p: 580)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.4.1 Keywords (p: 50)\n  - J.5.9 The fortran keyword (p: 514)\n  - J.5.10 The asm keyword (p: 514)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.1 Keywords\n  - G.5.9 The fortran keyword\n  - G.5.10 The asm keyword\n\n### See also\n\n|                                                                                               |     |\n|-----------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/keyword \"cpp/keyword\") for C++ keywords |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword](https://en.cppreference.com/w/c/keyword)"
- name: C language
  summary: This is a reference of the core C language constructs
  description: "# C language\n\nThis is a reference of the core C language constructs.\n\n[TABLE]\n\n### See also\n\n|                                                                                                            |     |\n|------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language \"cpp/language\") for C++ language constructs |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language](https://en.cppreference.com/w/c/language)"
- name: C Operator Precedence
  summary: The following table lists the precedence and associativity of C operators
  description: "# C Operator Precedence\n\nThe following table lists the precedence and associativity of C operators. Operators are listed top to bottom, in descending precedence.\n\n| Precedence                      | Operator                   | Description                                                 | Associativity |\n|---------------------------------|----------------------------|-------------------------------------------------------------|---------------|\n| 1                               | `++` `--`                  | Suffix/postfix increment and decrement                      | Left-to-right |\n|                                 | `()`                       | Function call                                               |               |\n|                                 | `[]`                       | Array subscripting                                          |               |\n|                                 | `.`                        | Structure and union member access                           |               |\n|                                 | `->`                       | Structure and union member access through pointer           |               |\n|                                 | `(`*`type`*`){`*`list`*`}` | Compound literal(C99)                                       |               |\n| 2                               | `++` `--`                  | Prefix increment and decrement^([\\[note 1\\]](#cite_note-1)) | Right-to-left |\n|                                 | `+` `-`                    | Unary plus and minus                                        |               |\n|                                 | `!` `~`                    | Logical NOT and bitwise NOT                                 |               |\n|                                 | `(`*`type`*`)`             | Cast                                                        |               |\n|                                 | `*`                        | Indirection (dereference)                                   |               |\n|                                 | `&`                        | Address-of                                                  |               |\n|                                 | `sizeof`                   | Size-of^([\\[note 2\\]](#cite_note-2))                        |               |\n|                                 | `_Alignof`                 | Alignment requirement(C11)                                  |               |\n| 3                               | `*` `/` `%`                | Multiplication, division, and remainder                     | Left-to-right |\n| 4                               | `+` `-`                    | Addition and subtraction                                    |               |\n| 5                               | `<<` `>>`                  | Bitwise left shift and right shift                          |               |\n| 6                               | `<` `<=`                   | For relational operators \\< and ≤ respectively              |               |\n|                                 | `>` `>=`                   | For relational operators \\> and ≥ respectively              |               |\n| 7                               | `==` `!=`                  | For relational = and ≠ respectively                         |               |\n| 8                               | `&`                        | Bitwise AND                                                 |               |\n| 9                               | `^`                        | Bitwise XOR (exclusive or)                                  |               |\n| 10                              | `|`                        | Bitwise OR (inclusive or)                                   |               |\n| 11                              | `&&`                       | Logical AND                                                 |               |\n| 12                              | `||`                       | Logical OR                                                  |               |\n| 13                              | `?:`                       | Ternary conditional^([\\[note 3\\]](#cite_note-3))            | Right-to-left |\n| 14^([\\[note 4\\]](#cite_note-4)) | `=`                        | Simple assignment                                           |               |\n|                                 | `+=` `-=`                  | Assignment by sum and difference                            |               |\n|                                 | `*=` `/=` `%=`             | Assignment by product, quotient, and remainder              |               |\n|                                 | `<<=` `>>=`                | Assignment by bitwise left shift and right shift            |               |\n|                                 | `&=` `^=` `|=`             | Assignment by bitwise AND, XOR, and OR                      |               |\n| 15                              | `,`                        | Comma                                                       | Left-to-right |\n\n1.  The operand of prefix `++` and `--` can't be a type cast. This rule grammatically forbids some expressions that would be semantically invalid anyway. Some compilers ignore this rule and detect the invalidity semantically.\n2.  The operand of `sizeof` can't be a type cast: the expression `sizeof (int) * p` is unambiguously interpreted as `(sizeof(int)) * p`, but not `sizeof((int)*p)`.\n3.  The expression in the middle of the conditional operator (between `?` and `:`) is parsed as if parenthesized: its precedence relative to `?:` is ignored.\n4.  Assignment operators' left operands must be unary (level-2 non-cast) expressions. This rule grammatically forbids some expressions that would be semantically invalid anyway. Many compilers ignore this rule and detect the invalidity semantically. For example, `e = a < d ? a++ : a = d` is an expression that cannot be parsed because of this rule. However, many compilers ignore this rule and parse it as `e = ( ((a < d) ? (a++) : a) = d )`, and then give an error because it is semantically invalid.\n\nWhen parsing an expression, an operator which is listed on some row will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it. For example, the expression `*p++` is parsed as `*(p++)`, and not as `(*p)++`.\n\nOperators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same precedence, in the given direction. For example, the expression `a=b=c` is parsed as `a=(b=c)`, and not as `(a=b)=c` because of right-to-left associativity.\n\n### Notes\n\nPrecedence and associativity are independent from [order of evaluation](eval_order \"c/language/eval order\").\n\nThe standard itself doesn't specify precedence levels. They are derived from the grammar.\n\nIn C++, the conditional operator has the same precedence as assignment operators, and prefix `++` and `--` and assignment operators don't have the restrictions about their operands.\n\nAssociativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left (`sizeof ++*p` is `sizeof(++(*p))`) and unary postfix operators always associate left-to-right (`a[1][2]++` is `((a[1])[2])++`). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: `a.b++` is parsed `(a.b)++` and not `a.(b++)`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - A.2.1 Expressions\n- C11 standard (ISO/IEC 9899:2011):\n  - A.2.1 Expressions\n- C99 standard (ISO/IEC 9899:1999):\n  - A.2.1 Expressions\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - A.1.2.1 Expressions\n\n### See also\n\n[Order of evaluation](eval_order \"c/language/eval order\") of operator arguments at run time.\n\n[TABLE]\n\n|                                                                                                                                                    |     |\n|----------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/operator_precedence \"cpp/language/operator precedence\") for C++ operator precedence |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/operator_precedence](https://en.cppreference.com/w/c/language/operator_precedence)"
- name: C11
  summary: ISO/IEC 9899:2011, a.k.a
  description: "# C11\n\n**ISO/IEC 9899:2011**, a.k.a. **C11**, is a previous revision of the C standard.\n\n## Obsolete\n\n### Removed\n\n- [`gets()`](io/gets \"c/io/gets\")\n\n## New language features\n\n- Multithreaded environments\n  - [Atomic objects](language/atomic \"c/language/atomic\") ([`_Atomic`](keyword/_atomic \"c/keyword/ Atomic\"))\n  - [Thread local storage](language/storage_duration#Storage_duration \"c/language/storage duration\") ([`_Thread_local`](keyword/_thread_local \"c/keyword/ Thread local\"))\n- Enhanced alignment support\n  - [Alignment query](language/_alignof \"c/language/ Alignof\") ([`_Alignof`](keyword/_alignof \"c/keyword/ Alignof\"))\n  - [Alignment strengthening](language/_alignas \"c/language/ Alignas\") ([`_Alignas`](keyword/_alignas \"c/keyword/ Alignas\"))\n  - Over-aligned types\n- Unicode support\n  - [`u`/`U` character constants](language/character_constant \"c/language/character constant\")\n  - [`u8`/`u`/`U` string literals](language/string_literal \"c/language/string literal\")\n- [Generic selection expressions](language/generic \"c/language/generic\") ([`_Generic`](keyword/_generic \"c/keyword/ Generic\"))\n- [Non-returning functions](language/_noreturn \"c/language/ Noreturn\") ([`_Noreturn`](keyword/_noreturn \"c/keyword/ Noreturn\"))\n- Anonymous [struct](language/struct \"c/language/struct\") and [union](language/union \"c/language/union\") members\n- Fine-grained [evaluation order](language/eval_order \"c/language/eval order\")\n- Extending the lifetime of [temporary objects](language/lifetime#Temporary_lifetime \"c/language/lifetime\")\n- [`_Static_assert`](language/_static_assert \"c/language/ Static assert\")\n- [Analyzability](language/analyzability \"c/language/analyzability\")\n\n### Feature test macros for optional features\n\n- [`__STDC_ANALYZABLE__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates analyzability is supported.\n- [`__STDC_LIB_EXT1__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates bounds checking functions are supported.\n- [`__STDC_NO_ATOMICS__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates atomic objects and the atomic operation library are not supported.\n- [`__STDC_NO_COMPLEX__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates complex types and the complex math functions are not supported.\n\n  These features were mandatory in C99.\n- [`__STDC_NO_THREADS__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates thread local storage and the thread support library are not supported.\n- [`__STDC_NO_VLA__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates [variable length arrays and variably modified types](language/array#Variable-length_arrays \"c/language/array\") are not supported.\n\n  These features were mandatory in C99.\n\n## New library features\n\n### New headers\n\n- [`<stdalign.h>`](types \"c/types\")\n- [`<stdatomic.h>`](thread#Atomic_operations \"c/thread\")\n- [`<stdnoreturn.h>`](language/_noreturn \"c/language/ Noreturn\")\n- [`<threads.h>`](thread \"c/thread\")\n- [`<uchar.h>`](string/multibyte \"c/string/multibyte\")\n\n### Library features\n\n- [Concurrency support library](thread \"c/thread\")\n- [`aligned_alloc()`](memory/aligned_alloc \"c/memory/aligned alloc\")\n- UTF-16/32 type aliases\n  - [`char16_t`](string/multibyte/char16_t \"c/string/multibyte/char16 t\")\n  - [`char32_t`](string/multibyte/char32_t \"c/string/multibyte/char32 t\")\n- UTF-16/32 conversion functions\n  - [`mbrtoc16()`](string/multibyte/mbrtoc16 \"c/string/multibyte/mbrtoc16\")\n  - [`mbrtoc32()`](string/multibyte/mbrtoc32 \"c/string/multibyte/mbrtoc32\")\n  - [`c16rtomb()`](string/multibyte/c16rtomb \"c/string/multibyte/c16rtomb\")\n  - [`c32rtomb()`](string/multibyte/c32rtomb \"c/string/multibyte/c32rtomb\")\n- [`quick_exit`](program/quick_exit \"c/program/quick exit\")\n- [`at_quick_exit`](program/at_quick_exit \"c/program/at quick exit\")\n- Exclusive modes of [`fopen()`](io/fopen \"c/io/fopen\") and [`freopen()`](io/freopen \"c/io/freopen\") (`\"x\"`)\n- [Bounds checking functions](error#Bounds_checking \"c/error\")\n- [`timespec`](chrono/timespec \"c/chrono/timespec\")\n- [`timespec_get()`](chrono/timespec_get \"c/chrono/timespec get\")\n- [`CMPLX(F|L)?`](numeric/complex/cmplx \"c/numeric/complex/CMPLX\")\n- New numeric limit macros\n  - [`(FLT|DBL|LDBL)_DECIMAL_DIG`](types/limits \"c/types/limits\")\n  - [`(FLT|DBL|LDBL)_TRUE_MIN`](types/limits \"c/types/limits\")\n  - [`(FLT|DBL|LDBL)_HAS_SUBNORM`](types/limits \"c/types/limits\")\n- Thread local [`errno`](error/errno \"c/error/errno\")\n\n## Defect reports\n\n[Template:c/language/history/DR11](https://en.cppreference.com/mwiki/index.php?title=Template:c/language/history/DR11&action=edit&redlink=1 \"Template:c/language/history/DR11 (page does not exist)\")\n\n## Compiler support\n\n[Template:c/compiler support/11](https://en.cppreference.com/mwiki/index.php?title=Template:c/compiler_support/11&action=edit&redlink=1 \"Template:c/compiler support/11 (page does not exist)\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/11](https://en.cppreference.com/w/c/11)"
- name: c16rtomb
  summary: Converts a single code point from its variable-length 16-bit wide character representation (typically, UTF-16) to its narrow multibyte character representation
  description: "# c16rtomb\n\n[TABLE]\n\nConverts a single code point from its variable-length 16-bit wide character representation (typically, UTF-16) to its narrow multibyte character representation.\n\nIf `s` is not a null pointer and `c16` is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state `*ps`), and stores the multibyte character representation in the character array whose first element is pointed to by `s`, updating `*ps` as necessary. At most `MB_CUR_MAX` bytes can be written by this function.\n\nIf `s` is a null pointer, the call is equivalent to `c16rtomb(buf, u'\\0', ps)` for some internal buffer `buf`.\n\nIf `c16` is the null wide character `u'\\0'`, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter `*ps` is updated to represent the initial shift state.\n\nIf `c16` is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by `s`, only `*ps` is updated.\n\nIf the macro `__STDC_UTF_16__` is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. The macro is always defined and the encoding is always UTF-16.(since C23) In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\n### Parameters\n\n|     |     |                                                                                    |\n|-----|-----|------------------------------------------------------------------------------------|\n| s   | \\-  | pointer to narrow character array where the multibyte character will be stored     |\n| c16 | \\-  | the 16-bit wide character to convert                                               |\n| ps  | \\-  | pointer to the conversion state object used when interpreting the multibyte string |\n\n### Return value\n\nOn success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by `s`. This value may be `​0​`, e.g. when processing the leading `char16_t` units in a multi-`char16_t`-unit sequence (occurs when processing the leading surrogate in a surrogate pair of UTF-16).\n\nOn failure (if `c16` is not a valid 16-bit code unit), returns `-1`, stores [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") in [`errno`](../../error/errno \"c/error/errno\"), and leaves `*ps` in unspecified state.\n\n### Notes\n\nIn C11 as published, unlike [`mbrtoc16`](mbrtoc16 \"c/string/multibyte/mbrtoc16\"), which converts variable-width multibyte (such as UTF-8) to variable-width 16-bit (such as UTF-16) encoding, this function can only convert single-unit 16-bit encoding, meaning it cannot convert UTF-16 to UTF-8 despite that being the original intent of this function. This was corrected by the post-C11 defect report [DR488](https://open-std.org/JTC1/SC22/WG14/www/docs/n2059.htm#dr_488).\n\n### Example\n\nNote: this example assumes the fix for the defect report [DR488](https://open-std.org/JTC1/SC22/WG14/www/docs/n2059.htm#dr_488) is applied\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <uchar.h>\n \nmbstate_t state;\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char16_t in[] = u\"zß水🍌\"; // or \"z\\u00df\\u6c34\\U0001F34C\"\n    const size_t in_sz = sizeof in / sizeof *in;\n \n    printf(\"Processing %zu UTF-16 code units: [ \", in_sz);\n    for (size_t n = 0; n < in_sz; ++n)\n        printf(\"%#x \", in[n]);\n    puts(\"]\");\n \n    char out[MB_CUR_MAX * in_sz];\n    char *p = out;\n    for (size_t n = 0; n < in_sz; ++n)\n    {\n        size_t rc = c16rtomb(p, in[n], &state);\n        if (rc == (size_t)-1)\n            break;\n        p += rc;\n    }\n \n    size_t out_sz = p - out;\n    printf(\"into %zu UTF-8 code units: [ \", out_sz);\n    for (size_t x = 0; x < out_sz; ++x)\n        printf(\"%#x \", +(unsigned char)out[x]);\n    puts(\"]\");\n}\n```\n\nOutput:\n\n```\nProcessing 6 UTF-16 code units: [ 0x7a 0xdf 0x6c34 0xd83c 0xdf4c 0 ]\ninto 11 UTF-8 code units: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c 0 ]\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.28.1.2 The c16rtomb function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.28.1.2 The c16rtomb function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.28.1.2 The c16rtomb function (p: 399-400)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/c16rtomb](https://en.cppreference.com/w/c/string/multibyte/c16rtomb)"
- name: C17
  summary: ISO/IEC 9899:2018, a.k.a
  description: "# C17\n\n**ISO/IEC 9899:2018**, a.k.a. **C17**/**C18** (denote the year of completion and publication respectively), is the current revision of the C standard.\n\nC17 is same as C11, except that it bumps the [`__STDC_VERSION__`](preprocessor/replace \"c/preprocessor/replace\") predefined macro to `201710L`, contains several defect reports, and deprecates some features.\n\n## Obsolete\n\n### Deprecated\n\n- [`ATOMIC_VAR_INIT`](atomic/atomic_var_init \"c/atomic/ATOMIC VAR INIT\")\n- Support for calling [`realloc()`](memory/realloc \"c/memory/realloc\") with zero size\n\n## Defect reports\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/17](https://en.cppreference.com/w/c/17)"
- name: C23
  summary: The next generation of the C standard
  description: "# C23\n\nThe next generation of the C standard.\n\nSee: [The current WD of C23](https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf).\n\n## Obsolete\n\n### Removed\n\n- Old-style function [declarations](language/function_declaration \"c/language/function declaration\") and [definitions](language/function_definition \"c/language/function definition\")\n- Representations for [signed integers](language/arithmetic_types \"c/language/arithmetic types\") other than two's complement\n- Permission that `u`/`U`-prefixed [character constants](language/character_constant \"c/language/character constant\") and [string literals](language/string_literal \"c/language/string literal\") may be not UTF-16/32\n- Mixed wide [string literal](language/string_literal \"c/language/string literal\") concatenation\n- Support for calling [`realloc()`](memory/realloc \"c/memory/realloc\") with zero size (the behavior becomes undefined)\n- [`__alignof_is_defined`](types \"c/types\") and [`__alignas_is_defined`](types \"c/types\")\n- [`static_assert`](error/static_assert \"c/error/static assert\") is not provided as a macro defined in [`<assert.h>`](error \"c/error\") (becomes a keyword)\n- [`thread_local`](thread/thread_local \"c/thread/thread local\") is not provided as a macro defined in [`<threads.h>`](thread \"c/thread\") (becomes a keyword)\n\n### Deprecated\n\n- [`<stdnoreturn.h>`](language/_noreturn \"c/language/ Noreturn\")\n- Old feature-test macros\n  - [`__STDC_IEC_559__`](preprocessor/replace \"c/preprocessor/replace\")\n  - [`__STDC_IEC_559_COMPLEX__`](preprocessor/replace \"c/preprocessor/replace\")\n- [`_Noreturn`](language/_noreturn \"c/language/ Noreturn\") function specifier\n- [`_Noreturn`](language/attributes/noreturn \"c/language/attributes/noreturn\") attribute token\n- [`asctime()`](chrono/asctime \"c/chrono/asctime\")\n- [`ctime()`](chrono/ctime \"c/chrono/ctime\")\n- [`DECIMAL_DIG`](types/limits \"c/types/limits\") (use the appropriate type-specific macro ([`FLT_DECIMAL_DIG`](types/limits#Limits_of_floating-point_types \"c/types/limits\"), etc) instead)\n- Definition of following numeric limit macros in [`<math.h>`](numeric/math \"c/numeric/math\") (they should be used via [`<float.h>`](types/limits#Limits_of_floating_point_types \"c/types/limits\"))\n  - [`INFINITY`](numeric/math \"c/numeric/math\")\n  - [`DEC_INFINITY`](numeric/math \"c/numeric/math\")\n  - [`NAN`](numeric/math \"c/numeric/math\")\n  - [`DEC_NAN`](numeric/math \"c/numeric/math\")\n- [`__bool_true_false_are_defined`](types \"c/types\")\n\n## New language features\n\n- [Decimal floating-point types](language/arithmetic_types \"c/language/arithmetic types\") ([`_Decimal32`](keyword/_decimal32 \"c/keyword/ Decimal32\"), [`_Decimal64`](keyword/_decimal64 \"c/keyword/ Decimal64\"), and [`_Decimal128`](keyword/_decimal128 \"c/keyword/ Decimal128\"))\n- [Bit-precise integers](language/arithmetic_types \"c/language/arithmetic types\") ([`_BitInt`](https://en.cppreference.com/mwiki/index.php?title=c/keyword/_BitInt&action=edit&redlink=1 \"c/keyword/ BitInt (page does not exist)\"))\n- [Binary integer constants](language/integer_constant \"c/language/integer constant\")\n- [`u8` character constants](language/character_constant \"c/language/character constant\")\n- Type change of [`u8` string literals](language/string_literal \"c/language/string literal\")\n- Digit separator `'`\n- Empty [initializer](language/initialization \"c/language/initialization\") `={}`\n- [Attributes](language/attributes \"c/language/attributes\")\n  - `[[`[`deprecated`](language/attributes/deprecated \"c/language/attributes/deprecated\")`]]`\n  - `[[`[`fallthrough`](language/attributes/fallthrough \"c/language/attributes/fallthrough\")`]]`\n  - `[[`[`maybe_unused`](language/attributes/maybe_unused \"c/language/attributes/maybe unused\")`]]`\n  - `[[`[`nodiscard`](language/attributes/nodiscard \"c/language/attributes/nodiscard\")`]]`\n  - `[[`[`noreturn`](language/attributes/noreturn \"c/language/attributes/noreturn\")`]]`\n  - `[[`[`reproducible`](language/attributes/reproducible \"c/language/attributes/reproducible\")`]]`\n  - `[[`[`unsequenced`](language/attributes/unsequenced \"c/language/attributes/unsequenced\")`]]`\n- Unnamed parameters in [function definitions](language/function_definition \"c/language/function definition\")\n- Identical cvr-qualifications for [array types](language/array \"c/language/array\") and their element types\n- Single-argument [`_Static_assert`](language/_static_assert \"c/language/ Static assert\")\n- [`static_assert`](keyword/static_assert \"c/keyword/static assert\") becomes a keyword (may be a predefined macro for compatibility reasons)\n- [`thread_local`](keyword/thread_local \"c/keyword/thread local\") becomes a keyword (may be a predefined macro for compatibility reasons)\n- [Labels](language/goto \"c/language/goto\") followed by declarations and `}`\n- [`nullptr`](keyword/nullptr \"c/keyword/nullptr\") constant and the associated [`nullptr_t`](types/nullptr_t \"c/types/nullptr t\") type\n- [`true`](keyword/true \"c/keyword/true\") and [`false`](keyword/false \"c/keyword/false\") become keywords (may be predefined macros for compatibility reasons)\n- New preprocessor directives\n  - [` #elifdef`](preprocessor/conditional \"c/preprocessor/conditional\")\n  - [` #elifndef`](preprocessor/conditional \"c/preprocessor/conditional\")\n  - [` #warning`](preprocessor/error \"c/preprocessor/error\")\n  - [` #embed`](preprocessor/embed \"c/preprocessor/embed\")\n- Pragmas for rounding direction\n  - `STDC` [`FENV_ROUND`](preprocessor/impl \"c/preprocessor/impl\")\n  - `STDC` [`FENV_DEC_ROUND`](preprocessor/impl \"c/preprocessor/impl\")\n\n### Feature test macros for optional features\n\n- [`__STDC_IEC_60559_BFP__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates IEEE-754 binary floating-point arithmetic and required math functions are supported.\n\n  This macro supersedes [`__STDC_IEC_559__`](preprocessor/replace \"c/preprocessor/replace\").\n- [`__STDC_IEC_60559_DFP__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates IEEE-754 decimal floating-point arithmetic and required math functions are supported.\n- [`__STDC_IEC_60559_COMPLEX__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates IEEE-754 complex arithmetic and required math functions are supported.\n\n  This macro supersedes [`__STDC_IEC_559_COMPLEX__`](preprocessor/replace \"c/preprocessor/replace\").\n\n## New library features\n\n### New headers\n\n- `<stdbit.h>`\n- `<stdckdint.h>`\n\n### Library features\n\n- Extended binary floating-point math functions\n- Decimal floating-point math functions\n  - \\-`d`*`N`* variants for existing and new floating-point math functions\n  - [`quantizedN()`](https://en.cppreference.com/mwiki/index.php?title=c/numeric/math/quantize&action=edit&redlink=1 \"c/numeric/math/quantize (page does not exist)\")\n  - [`samequantumdN()`](https://en.cppreference.com/mwiki/index.php?title=c/numeric/math/samequantum&action=edit&redlink=1 \"c/numeric/math/samequantum (page does not exist)\")\n  - [`quantumdN()`](https://en.cppreference.com/mwiki/index.php?title=c/numeric/math/quantum&action=edit&redlink=1 \"c/numeric/math/quantum (page does not exist)\")\n  - [`llquantexpdN()`](https://en.cppreference.com/mwiki/index.php?title=c/numeric/math/llquantexp&action=edit&redlink=1 \"c/numeric/math/llquantexp (page does not exist)\")\n  - [`encodedecdN()`](https://en.cppreference.com/mwiki/index.php?title=c/numeric/math/encodedec&action=edit&redlink=1 \"c/numeric/math/encodedec (page does not exist)\")\n  - [`decodedecdN()`](https://en.cppreference.com/mwiki/index.php?title=c/numeric/math/decodedec&action=edit&redlink=1 \"c/numeric/math/decodedec (page does not exist)\")\n  - [`encodebindN()`](https://en.cppreference.com/mwiki/index.php?title=c/numeric/math/encodebin&action=edit&redlink=1 \"c/numeric/math/encodebin (page does not exist)\")\n  - [`decodebindN()`](https://en.cppreference.com/mwiki/index.php?title=c/numeric/math/decodebin&action=edit&redlink=1 \"c/numeric/math/decodebin (page does not exist)\")\n- [Floating-point formatting functions](string/byte/strfromf \"c/string/byte/strfromf\")\n- Library support for UTF-8\n  - `char8_t` type alias\n  - [`mbrtoc8()`](string/multibyte/mbrtoc8 \"c/string/multibyte/mbrtoc8\")\n  - [`c8rtomb()`](string/multibyte/c8rtomb \"c/string/multibyte/c8rtomb\")\n  - [`atomic_char8_t`](thread \"c/thread\") type alias\n  - [`ATOMIC_CHAR8_T_LOCK_FREE`](atomic/atomic_lock_free_consts \"c/atomic/ATOMIC LOCK FREE consts\") test macro\n- [`memset_explicit()`](string/byte/memset \"c/string/byte/memset\")\n- POSIX functions\n  - [`memccpy()`](string/byte/memccpy \"c/string/byte/memccpy\")\n  - [`strdup()`](string/byte/strdup \"c/string/byte/strdup\")\n  - [`strndup()`](string/byte/strndup \"c/string/byte/strndup\")\n  - [`gmtime_r()`](chrono/gmtime \"c/chrono/gmtime\")\n  - [`localtime_r()`](chrono/localtime \"c/chrono/localtime\")\n  - Extensions for [`strftime()`](chrono/strftime \"c/chrono/strftime\") and [`wcsftime()`](chrono/wcsftime \"c/chrono/wcsftime\")\n- Extensions for [`fscanf()`](io/fscanf \"c/io/fscanf\") and [`fprintf()`](io/fprintf \"c/io/fprintf\") function families\n  - `w`*`N`* and `wf`*`N`* length modifiers for [`[u]intN_t`](types/integer \"c/types/integer\") and [`[u]int_fastN_t`](types/integer \"c/types/integer\") respectively\n  - `H`, `D`, and `DD` length modifiers for `_Decimal32`, `_Decimal64`, and `_Decimal128` respectively\n  - `b` conversion specifier for unsigned integer types\n- [`timespec_getres()`](chrono/timespec_getres \"c/chrono/timespec getres\")\n- Macro constants for width of integer types\n- Additional numeric limit macros for floating-point types\n- Library version-test macros\n  - [`__STDC_VERSION_FENV_H__`](numeric/fenv \"c/numeric/fenv\")\n  - [`__STDC_VERSION_MATH_H__`](numeric/math \"c/numeric/math\")\n  - [`__STDC_VERSION_STDINT_H__`](types/integer \"c/types/integer\")\n  - [`__STDC_VERSION_STDLIB_H__`](string/byte \"c/string/byte\")\n  - [`__STDC_VERSION_TGMATH_H__`](numeric/tgmath \"c/numeric/tgmath\")\n  - [`__STDC_VERSION_TIME_H__`](chrono \"c/chrono\")\n  - [`__STDC_VERSION_STDCKDINT_H__`](https://en.cppreference.com/mwiki/index.php?title=STDC_VERSION_STDCKDINT_H&action=edit&redlink=1 \"STDC VERSION STDCKDINT H (page does not exist)\")\n  - [`__STDC_VERSION_STDBIT_H__`](https://en.cppreference.com/mwiki/index.php?title=STDC_VERSION_STDBIT_H&action=edit&redlink=1 \"STDC VERSION STDBIT H (page does not exist)\")\n\n## Defect reports\n\n[TABLE]\n\n## Compiler support\n\n### C23 core language features\n\n[TABLE]\n\n### C23 library features\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/23](https://en.cppreference.com/w/c/23)"
- name: c32rtomb
  summary: Converts a single code point from its variable-length 32-bit wide character representation (but typically, UTF-32) to its narrow multibyte character representation
  description: "# c32rtomb\n\n[TABLE]\n\nConverts a single code point from its variable-length 32-bit wide character representation (but typically, UTF-32) to its narrow multibyte character representation.\n\nIf `s` is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of `c32` (including any shift sequences, and taking into account the current multibyte conversion state `*ps`), and stores the multibyte character representation in the character array whose first element is pointed to by `s`, updating `*ps` as necessary. At most `MB_CUR_MAX` bytes can be written by this function.\n\nIf `s` is a null pointer, the call is equivalent to `c32rtomb(buf, U'\\0', ps)` for some internal buffer `buf`.\n\nIf `c32` is the null wide character `U'\\0'`, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter `*ps` is updated to represent the initial shift state.\n\nIf the macro `__STDC_UTF_32__` is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. The macro is always defined and the encoding is always UTF-32.(since C23) In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\n### Parameters\n\n|     |     |                                                                                    |\n|-----|-----|------------------------------------------------------------------------------------|\n| s   | \\-  | pointer to narrow character array where the multibyte character will be stored     |\n| c32 | \\-  | the 32-bit wide character to convert                                               |\n| ps  | \\-  | pointer to the conversion state object used when interpreting the multibyte string |\n\n### Return value\n\nOn success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by `s`. This value may be `​0​`, e.g. when processing the leading `char32_t` units in a multi-`char32_t`-unit sequence (does not occur in UTF-32).\n\nOn failure (if `c32` is not a valid 32-bit wide character), returns `-1`, stores [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") in [`errno`](../../error/errno \"c/error/errno\"), and leaves `*ps` in unspecified state.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <uchar.h>\n \nmbstate_t state;\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char32_t in[] = U\"zß水🍌\"; // or \"z\\u00df\\u6c34\\U0001F34C\"\n    size_t in_sz = sizeof in / sizeof *in;\n \n    printf(\"Processing %zu UTF-32 code units: [ \", in_sz);\n    for (size_t n = 0; n < in_sz; ++n)\n        printf(\"%#x \", in[n]);\n    puts(\"]\");\n \n    char out[MB_CUR_MAX * in_sz];\n    char* p = out;\n    for (size_t n = 0; n < in_sz; ++n)\n    {\n        size_t rc = c32rtomb(p, in[n], &state);\n        if(rc == (size_t)-1) break;\n        p += rc;\n    }\n \n    size_t out_sz = p - out;\n    printf(\"into %zu UTF-8 code units: [ \", out_sz);\n    for (size_t x = 0; x < out_sz; ++x)\n        printf(\"%#x \", +(unsigned char)out[x]);\n    puts(\"]\");\n}\n```\n\nOutput:\n\n```\nProcessing 5 UTF-32 code units: [ 0x7a 0xdf 0x6c34 0x1f34c 0 ]\ninto 11 UTF-8 code units: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c 0 ]\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.1.6 The c32rtomb function (p: 411)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.28.1.4 The c32rtomb function (p: 401)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/c32rtomb](https://en.cppreference.com/w/c/string/multibyte/c32rtomb)"
- name: c8rtomb
  summary: Converts a single code point from UTF-8 to a narrow multibyte character representation
  description: "# c8rtomb\n\n[TABLE]\n\nConverts a single code point from UTF-8 to a narrow multibyte character representation.\n\nIf `s` is not a null pointer and `c8` is the last code unit in a valid UTF-8 encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state `*ps`), and stores the multibyte character representation in the character array whose first element is pointed to by `s`, updating `*ps` as necessary. At most `MB_CUR_MAX` bytes can be written by this function.\n\nIf `c8` is not the final UTF-8 code unit in a representation of a code point, the function does not write to the array pointed to by `s`, only `*ps` is updated.\n\nIf `s` is a null pointer, the call is equivalent to `c8rtomb(buf, u8'\\0', ps)` for some internal buffer `buf`.\n\nIf `c8` is the null character `u8'\\0'`, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter `*ps` is updated to represent the initial shift state.\n\nThe multibyte encoding used by this function is specified by the currently active C locale.\n\n### Parameters\n\n|     |     |                                                                                    |\n|-----|-----|------------------------------------------------------------------------------------|\n| s   | \\-  | pointer to narrow character array where the multibyte character will be stored     |\n| c8  | \\-  | the UTF-8 code unit to convert                                                     |\n| ps  | \\-  | pointer to the conversion state object used when interpreting the multibyte string |\n\n### Return value\n\nThe number of bytes stored in the array object (including any shift sequences). This may be zero when `c8` is not the final code unit in the UTF-8 representation of a code point.\n\nIf `c8` is invalid (does not contribute to a sequence of `char8_t` corresponding to a valid multibyte character), the value of the macro [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") is stored in [`errno`](../../error/errno \"c/error/errno\"), `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` is returned, and the conversion state is unspecified.\n\n### Notes\n\nCalls to `c8rtomb` with a null pointer argument for `s` may introduce a data race with other calls to `c8rtomb` with a null pointer argument for `s`.\n\n### Example\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/c8rtomb](https://en.cppreference.com/w/c/string/multibyte/c8rtomb)"
- name: C95
  summary: ISO/IEC 9899/AMD1:1995, a.k.a
  description: "# C95\n\n**ISO/IEC 9899/AMD1:1995**, a.k.a. **C95**, is a previous revision of the C standard.\n\n## New language features\n\n- [Digraphs](language/operator_alternative \"c/language/operator alternative\")\n- [`__STDC_VERSION__`](preprocessor/replace \"c/preprocessor/replace\")\n\n## New library features\n\n### New headers\n\n- [`<iso646.h>`](language/operator_alternative \"c/language/operator alternative\")\n- [`<wctype.h>`](string/wide \"c/string/wide\")\n- [`<wchar.h>`](string/wide \"c/string/wide\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/95](https://en.cppreference.com/w/c/95)"
- name: C99
  summary: ISO/IEC 9899:1999, a.k.a
  description: "# C99\n\n**ISO/IEC 9899:1999**, a.k.a. **C99**, is a previous revision of the C standard.\n\n## Obsolete\n\n### Removed\n\n- Implicit `int` in declarations\n- Implicit function declarations\n\n### Deprecated\n\n- [`gets()`](io/gets \"c/io/gets\")\n\n## New language features\n\n- Universal-character-names in [identifiers](language/identifier \"c/language/identifier\")\n- Increased [translation limits](language/identifier#Translation_limits \"c/language/identifier\")\n- `//` [comments](comment \"c/comment\")\n- [`restrict`](language/restrict \"c/language/restrict\") pointers\n- Enhanced [arithmetic types](language/arithmetic_types \"c/language/arithmetic types\")\n  - `_Bool`\n  - `long long` and `unsigned long long`\n  - Extended integer types\n  - [`_Complex`](keyword/_complex \"c/keyword/ Complex\") types (`float _Complex`, `double _Complex`, and `long double _Complex`)\n  - [`_Imaginary`](keyword/_imaginary \"c/keyword/ Imaginary\") types (`float _Imaginary`, `double _Imaginary`, and `long double _Imaginary`)\n- Flexible array members\n- [Variable-length array](language/array#Variable-length_arrays \"c/language/array\") (VLA) types and variably-modified (VM) types\n- Improvements of braced-init-list for [array](language/array_initialization \"c/language/array initialization\"), [struct and union](language/struct_initialization \"c/language/struct initialization\") types\n  - Non-constant initializers\n  - Designated initializers\n- Idempotent cvr-qualifiers\n- Trailing comma in [enumerator-list](language/enum \"c/language/enum\")\n- Hexadecimal [floating constants](language/floating_constant \"c/language/floating constant\")\n- [Compound literals](language/compound_literal \"c/language/compound literal\")\n- Floating-point environment\n- Requiring truncation for divisions of signed integer types\n- Implicit `return 0;` in the [`main()` function](language/main_function \"c/language/main function\")\n- Declarations and statements in mixed order\n- init-statement in [`for`](language/for \"c/language/for\") loops\n- [`inline`](language/inline \"c/language/inline\") functions\n- Predefined variable [`__func__`](language/function_definition \"c/language/function definition\")\n- Cvr-qualifiers and `static` in `[]` within function declarations\n- [Variadic macros](preprocessor/replace \"c/preprocessor/replace\")\n- [`_Pragma`](preprocessor/impl \"c/preprocessor/impl\") preprocessor operator\n- Standard pragmas for floating-point evaluation\n  - `STDC` [`FENV_ACCESS`](preprocessor/impl \"c/preprocessor/impl\")\n  - `STDC` [`FP_CONTRACT`](preprocessor/impl \"c/preprocessor/impl\")\n  - `STDC` [`CX_LIMITED_RANGE`](preprocessor/impl \"c/preprocessor/impl\")\n\n### Feature test macros for optional features\n\n- [`__STDC_IEC_559__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates IEEE-754 binary floating-point arithmetic and required math functions are supported.\n- [`__STDC_IEC_559_COMPLEX__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates IEEE-754 complex arithmetic and required math functions are supported.\n- [`__STDC_HOSTED__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates that the implementation is [hosted](language/conformance \"c/language/conformance\").\n- [`__STDC_ISO_10646__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates that Unicode is used by the wide literal encodings and expands to the latest supported revision.\n- [`__STDC_MB_MIGHT_NEQ_WC__`](preprocessor/replace \"c/preprocessor/replace\")\n  - Indicates that there are some characters in the basic character set having different code unit values in [ordinary and wide literal encodings](language/character_constant \"c/language/character constant\").\n\n## New library features\n\n### New headers\n\n- [`<complex.h>`](numeric/complex \"c/numeric/complex\")\n- [`<fenv.h>`](numeric/fenv \"c/numeric/fenv\")\n- [`<inttypes.h>`](types/integer \"c/types/integer\")\n- [`<stdbool.h>`](types \"c/types\")\n- [`<stdint.h>`](types/integer \"c/types/integer\")\n- [`<tgmath.h>`](numeric/tgmath \"c/numeric/tgmath\")\n\n### Library features\n\n- [Aliases for integer types](types/integer \"c/types/integer\")\n  - Integer types with exact width (`int`*`N`*`_t` and `uint`*`N`*`_t`)\n  - Fastest integer types with at least given width (`int_fast`*`N`*`_t` and `uint_fast`*`N`*`_t`)\n  - Smallest integer types with at least given width (`int_least`*`N`*`_t` and `uint_least`*`N`*`_t`)\n  - Integer types capable for cast between object pointers ([`intptr_t`](types/integer \"c/types/integer\") and [`uintptr_t`](types/integer \"c/types/integer\"))\n  - Integer types with maximum width ([`intmax_t`](types/integer \"c/types/integer\") and [`uintmax_t`](types/integer \"c/types/integer\"))\n- Operations on `long long` and [`intmax_t`](types/integer \"c/types/integer\")\n  - [`llabs()`](numeric/math/abs \"c/numeric/math/abs\")\n  - [`imaxabs()`](numeric/math/abs \"c/numeric/math/abs\")\n  - [`lldiv()`](numeric/math/div \"c/numeric/math/div\")\n  - [`imaxdiv()`](numeric/math/div \"c/numeric/math/div\")\n- [Floating-point environment access](numeric/fenv \"c/numeric/fenv\")\n- Extended floating-point math functions\n  - New floating-point math functions\n  - \\-`f` and -`l` variants for existing and new floating-point math functions\n  - [Math error handling](numeric/math/math_errhandling \"c/numeric/math/math errhandling\")\n- [Complex functions](numeric/complex \"c/numeric/complex\")\n- [`_Exit()`](program/_exit \"c/program/ Exit\")\n- Formatting support for `long long`, `unsigned long long`, [`intmax_t`](types/integer \"c/types/integer\"), and [`uintmax_t`](types/integer \"c/types/integer\")\n  - [`atoll()`](string/byte/atoi \"c/string/byte/atoi\")\n  - [`strtoimax()`](string/byte/strtoimax \"c/string/byte/strtoimax\")\n  - [`strtoll()`](string/byte/strtol \"c/string/byte/strtol\")\n  - [`strtoull`](string/byte/strtoul \"c/string/byte/strtoul\")\n  - [`strtoumax()`](string/byte/strtoimax \"c/string/byte/strtoimax\")\n  - [`wcstoimax()`](string/wide/wcstoimax \"c/string/wide/wcstoimax\")\n  - [`wcstoll()`](string/wide/wcstol \"c/string/wide/wcstol\")\n  - [`wcstoull()`](string/wide/wcstoul \"c/string/wide/wcstoul\")\n  - [`wcstoumax()`](string/wide/wcstoimax \"c/string/wide/wcstoimax\")\n- [`isblank()`](string/byte/isblank \"c/string/byte/isblank\") and [`iswblank()`](string/wide/iswblank \"c/string/wide/iswblank\")\n- [`snprintf()`](io/fprintf \"c/io/fprintf\") and [`vsnprintf()`](io/vfprintf \"c/io/vfprintf\")\n- [`vfscanf()`](io/vfscanf \"c/io/vfscanf\") and [`vfwscanf()`](io/vfwscanf \"c/io/vfwscanf\") function families\n- Extensions for [`fscanf()`](io/fscanf \"c/io/fscanf\") and [`fprintf()`](io/fprintf \"c/io/fprintf\") function families\n  - `ll` length modifier for `long long` and `unsigned long long`\n  - `hh` length modifier for `signed char` and `unsigned char`\n  - `l` length modifier for `double`\n  - `z` length modifier for [`size_t`](types/size_t \"c/types/size t\") and its signed version\n  - `t` length modifier for [`ptrdiff_t`](types/ptrdiff_t \"c/types/ptrdiff t\") and its unsigned version\n  - `j` length modifier for [`intmax_t`](types/integer \"c/types/integer\") and [`uintmax_t`](types/integer \"c/types/integer\")\n  - `a` conversion specifier for floating-point types\n- Numeric limit macros for `long long` and `unsigned long long`\n- Numeric limit macros corresponding to existing and new aliases for integer types\n- [Format string macros for integer types](types/integer#Format_macro_constants \"c/types/integer\")\n- [`va_copy`](variadic/va_copy \"c/variadic/va copy\")\n- [Type-generic math macros](numeric/tgmath \"c/numeric/tgmath\")\n- Floating-point comparison macros\n- Floating-point classification macros\n- Compatibility macros for `_Bool` ([`bool`](types \"c/types\"), [`true`](types \"c/types\"), and [`false`](types \"c/types\"))\n\n## Defect reports\n\n[Template:c/language/history/DR99](https://en.cppreference.com/mwiki/index.php?title=Template:c/language/history/DR99&action=edit&redlink=1 \"Template:c/language/history/DR99 (page does not exist)\")\n\n## Compiler support\n\n### C99 core language features\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/99](https://en.cppreference.com/w/c/99)"
- name: cabs
  summary: If no errors occur, returns the absolute value (norm, magnitude) of z
  description: "# cabsf, cabs, cabsl\n\n[TABLE]\n\n1-3) Computes the complex absolute value (also known as norm, modulus, or magnitude) of `z`.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) or `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `cabsl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) or `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `cabsf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) or `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `cabs` is called. For real and integer types, the corresponding version of [`fabs`](../math/fabs \"c/numeric/math/fabs\") is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, returns the absolute value (norm, magnitude) of `z`.\n\nErrors and special cases are handled as if the function is implemented as [`hypot`](http://en.cppreference.com/w/c/numeric/math/hypot)`(`[`creal`](http://en.cppreference.com/w/c/numeric/complex/creal)`(``z``)``, `[`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)``)`\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = 1.0 + 1.0*I;\n    printf(\"%.1f%+.1fi cartesian is rho=%f theta=%f polar\\n\",\n           creal(z), cimag(z), cabs(z), carg(z));\n}\n```\n\nOutput:\n\n```\n1.0+1.0i cartesian is rho=1.414214 theta=0.785398 polar\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.8.1 The cabs functions (p: 195)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.8.1 The cabs functions (p: 177)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cabs](https://en.cppreference.com/w/c/numeric/complex/cabs)"
- name: cabsf
  summary: If no errors occur, returns the absolute value (norm, magnitude) of z
  description: "# cabsf, cabs, cabsl\n\n[TABLE]\n\n1-3) Computes the complex absolute value (also known as norm, modulus, or magnitude) of `z`.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) or `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `cabsl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) or `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `cabsf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) or `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `cabs` is called. For real and integer types, the corresponding version of [`fabs`](../math/fabs \"c/numeric/math/fabs\") is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, returns the absolute value (norm, magnitude) of `z`.\n\nErrors and special cases are handled as if the function is implemented as [`hypot`](http://en.cppreference.com/w/c/numeric/math/hypot)`(`[`creal`](http://en.cppreference.com/w/c/numeric/complex/creal)`(``z``)``, `[`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)``)`\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = 1.0 + 1.0*I;\n    printf(\"%.1f%+.1fi cartesian is rho=%f theta=%f polar\\n\",\n           creal(z), cimag(z), cabs(z), carg(z));\n}\n```\n\nOutput:\n\n```\n1.0+1.0i cartesian is rho=1.414214 theta=0.785398 polar\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.8.1 The cabs functions (p: 195)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.8.1 The cabs functions (p: 177)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cabs](https://en.cppreference.com/w/c/numeric/complex/cabs)"
- name: cabsl
  summary: If no errors occur, returns the absolute value (norm, magnitude) of z
  description: "# cabsf, cabs, cabsl\n\n[TABLE]\n\n1-3) Computes the complex absolute value (also known as norm, modulus, or magnitude) of `z`.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) or `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `cabsl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) or `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `cabsf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) or `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `cabs` is called. For real and integer types, the corresponding version of [`fabs`](../math/fabs \"c/numeric/math/fabs\") is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, returns the absolute value (norm, magnitude) of `z`.\n\nErrors and special cases are handled as if the function is implemented as [`hypot`](http://en.cppreference.com/w/c/numeric/math/hypot)`(`[`creal`](http://en.cppreference.com/w/c/numeric/complex/creal)`(``z``)``, `[`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)``)`\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = 1.0 + 1.0*I;\n    printf(\"%.1f%+.1fi cartesian is rho=%f theta=%f polar\\n\",\n           creal(z), cimag(z), cabs(z), carg(z));\n}\n```\n\nOutput:\n\n```\n1.0+1.0i cartesian is rho=1.414214 theta=0.785398 polar\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.8.1 The cabs functions (p: 195)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.8.1 The cabs functions (p: 177)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cabs](https://en.cppreference.com/w/c/numeric/complex/cabs)"
- name: cacos
  summary: If no errors occur, complex arc cosine of z is returned, in the range a strip unbounded along the imaginary axis and in the interval [0; π] along the real axis
  description: "# cacosf, cacos, cacosl\n\n[TABLE]\n\n1-3) Computes the complex arc cosine of `z` with branch cuts outside the interval \\[−1,+1\\] along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacosl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacos` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacosf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`acosf`, [`acos`](http://en.cppreference.com/w/c/numeric/math/acos), `acosl`). If `z` is imaginary, then the macro invokes the corresponding complex number version.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex arc cosine of `z` is returned, in the range a strip unbounded along the imaginary axis and in the interval \\[0; π\\] along the real axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [`math_errhandling`](../math/math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `cacos``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``cacos``(``z``)``)`\n- If `z` is `±0+0i`, the result is `π/2-0i`\n- If `z` is `±0+NaNi`, the result is `π/2+NaNi`\n- If `z` is `x+∞i` (for any finite x), the result is `π/2-∞i`\n- If `z` is `x+NaNi` (for any nonzero finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `-∞+yi` (for any positive finite y), the result is `π-∞i`\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+0-∞i`\n- If `z` is `-∞+∞i`, the result is `3π/4-∞i`\n- If `z` is `+∞+∞i`, the result is `π/4-∞i`\n- If `z` is `±∞+NaNi`, the result is `NaN±∞i` (the sign of the imaginary part is unspecified)\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `NaN-∞i`\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nInverse cosine (or arc cosine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventially placed at the line segments (-∞,-1) and (1,∞) of the real axis. The mathematical definition of the principal value of arc cosine is acos z =\n\n1/2π + *i*ln(*i*z + √1-z²)\n\nFor any z, acos(z) = π - acos(-z)\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = cacos(-2);\n    printf(\"cacos(-2+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = cacos(conj(-2)); // or CMPLX(-2, -0.0)\n    printf(\"cacos(-2-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, acos(z) = pi - acos(-z)\n    double pi = acos(-1);\n    double complex z3 = ccos(pi-z2);\n    printf(\"ccos(pi - cacos(-2-0i) = %f%+fi\\n\", creal(z3), cimag(z3));\n}\n```\n\nOutput:\n\n```\ncacos(-2+0i) = 3.141593-1.316958i\ncacos(-2-0i) (the other side of the cut) = 3.141593+1.316958i\nccos(pi - cacos(-2-0i) = 2.000000+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.1 The cacos functions (p: 190)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.1.1 The cacos functions (p: 539)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.1 The cacos functions (p: 172)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.1.1 The cacos functions (p: 474)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cacos](https://en.cppreference.com/w/c/numeric/complex/cacos)"
- name: cacosf
  summary: If no errors occur, complex arc cosine of z is returned, in the range a strip unbounded along the imaginary axis and in the interval [0; π] along the real axis
  description: "# cacosf, cacos, cacosl\n\n[TABLE]\n\n1-3) Computes the complex arc cosine of `z` with branch cuts outside the interval \\[−1,+1\\] along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacosl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacos` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacosf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`acosf`, [`acos`](http://en.cppreference.com/w/c/numeric/math/acos), `acosl`). If `z` is imaginary, then the macro invokes the corresponding complex number version.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex arc cosine of `z` is returned, in the range a strip unbounded along the imaginary axis and in the interval \\[0; π\\] along the real axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [`math_errhandling`](../math/math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `cacos``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``cacos``(``z``)``)`\n- If `z` is `±0+0i`, the result is `π/2-0i`\n- If `z` is `±0+NaNi`, the result is `π/2+NaNi`\n- If `z` is `x+∞i` (for any finite x), the result is `π/2-∞i`\n- If `z` is `x+NaNi` (for any nonzero finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `-∞+yi` (for any positive finite y), the result is `π-∞i`\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+0-∞i`\n- If `z` is `-∞+∞i`, the result is `3π/4-∞i`\n- If `z` is `+∞+∞i`, the result is `π/4-∞i`\n- If `z` is `±∞+NaNi`, the result is `NaN±∞i` (the sign of the imaginary part is unspecified)\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `NaN-∞i`\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nInverse cosine (or arc cosine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventially placed at the line segments (-∞,-1) and (1,∞) of the real axis. The mathematical definition of the principal value of arc cosine is acos z =\n\n1/2π + *i*ln(*i*z + √1-z²)\n\nFor any z, acos(z) = π - acos(-z)\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = cacos(-2);\n    printf(\"cacos(-2+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = cacos(conj(-2)); // or CMPLX(-2, -0.0)\n    printf(\"cacos(-2-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, acos(z) = pi - acos(-z)\n    double pi = acos(-1);\n    double complex z3 = ccos(pi-z2);\n    printf(\"ccos(pi - cacos(-2-0i) = %f%+fi\\n\", creal(z3), cimag(z3));\n}\n```\n\nOutput:\n\n```\ncacos(-2+0i) = 3.141593-1.316958i\ncacos(-2-0i) (the other side of the cut) = 3.141593+1.316958i\nccos(pi - cacos(-2-0i) = 2.000000+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.1 The cacos functions (p: 190)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.1.1 The cacos functions (p: 539)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.1 The cacos functions (p: 172)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.1.1 The cacos functions (p: 474)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cacos](https://en.cppreference.com/w/c/numeric/complex/cacos)"
- name: cacosh
  summary: The complex arc hyperbolic cosine of z in the interval [0; ∞) along the real axis and in the interval [−iπ; +iπ] along the imaginary axis
  description: "# cacoshf, cacosh, cacoshl\n\n[TABLE]\n\n1-3) Computes complex arc hyperbolic cosine of a complex value `z` with branch cut at values less than 1 along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacoshl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacosh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacoshf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`acoshf`, [`acosh`](http://en.cppreference.com/w/c/numeric/math/acosh), `acoshl`). If `z` is imaginary, then the macro invokes the corresponding complex number version and the return type is complex.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe complex arc hyperbolic cosine of `z` in the interval \\[0; ∞) along the real axis and in the interval \\[−iπ; +iπ\\] along the imaginary axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `cacosh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``cacosh``(``z``)``)`\n- If `z` is `±0+0i`, the result is `+0+iπ/2`\n- If `z` is `+x+∞i` (for any finite x), the result is `+∞+iπ/2`\n- If `z` is `+x+NaNi` (for non-zero finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `0+NaNi`, the result is `NaN±iπ/2`, where the sign of the imaginary part is unspecified\n- If `z` is `-∞+yi` (for any positive finite y), the result is `+∞+iπ`\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+∞+0i`\n- If `z` is `-∞+∞i`, the result is `+∞+3iπ/4`\n- If `z` is `+∞+∞i`, the result is `+∞+iπ/4`\n- If `z` is `±∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `NaN+∞i`, the result is `+∞+NaNi`\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nAlthough the C standard names this function \"complex arc hyperbolic cosine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic cosine\", and, less common, \"complex area hyperbolic cosine\".\n\nInverse hyperbolic cosine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segment (-∞,+1) of the real axis.\n\nThe mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + √z+1 √z-1) For any z, acosh(z) =\n\n√z-1/√1-z acos(z), or simply i acos(z) in the upper half of the complex plane.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = cacosh(0.5);\n    printf(\"cacosh(+0.5+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = conj(0.5); // or cacosh(CMPLX(0.5, -0.0)) in C11\n    printf(\"cacosh(+0.5-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // in upper half-plane, acosh(z) = i*acos(z) \n    double complex z3 = casinh(1+I);\n    printf(\"casinh(1+1i) = %f%+fi\\n\", creal(z3), cimag(z3));\n    double complex z4 = I*casin(1+I);\n    printf(\"I*asin(1+1i) = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\ncacosh(+0.5+0i) = 0.000000-1.047198i\ncacosh(+0.5-0i) (the other side of the cut) = 0.500000-0.000000i\ncasinh(1+1i) = 1.061275+0.666239i\nI*asin(1+1i) = -1.061275+0.666239i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.1 The cacosh functions (p: 192)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.1 The cacosh functions (p: 539-540)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.1 The cacosh functions (p: 174)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.1 The cacosh functions (p: 474-475)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cacosh](https://en.cppreference.com/w/c/numeric/complex/cacosh)"
- name: cacoshf
  summary: The complex arc hyperbolic cosine of z in the interval [0; ∞) along the real axis and in the interval [−iπ; +iπ] along the imaginary axis
  description: "# cacoshf, cacosh, cacoshl\n\n[TABLE]\n\n1-3) Computes complex arc hyperbolic cosine of a complex value `z` with branch cut at values less than 1 along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacoshl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacosh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacoshf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`acoshf`, [`acosh`](http://en.cppreference.com/w/c/numeric/math/acosh), `acoshl`). If `z` is imaginary, then the macro invokes the corresponding complex number version and the return type is complex.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe complex arc hyperbolic cosine of `z` in the interval \\[0; ∞) along the real axis and in the interval \\[−iπ; +iπ\\] along the imaginary axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `cacosh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``cacosh``(``z``)``)`\n- If `z` is `±0+0i`, the result is `+0+iπ/2`\n- If `z` is `+x+∞i` (for any finite x), the result is `+∞+iπ/2`\n- If `z` is `+x+NaNi` (for non-zero finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `0+NaNi`, the result is `NaN±iπ/2`, where the sign of the imaginary part is unspecified\n- If `z` is `-∞+yi` (for any positive finite y), the result is `+∞+iπ`\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+∞+0i`\n- If `z` is `-∞+∞i`, the result is `+∞+3iπ/4`\n- If `z` is `+∞+∞i`, the result is `+∞+iπ/4`\n- If `z` is `±∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `NaN+∞i`, the result is `+∞+NaNi`\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nAlthough the C standard names this function \"complex arc hyperbolic cosine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic cosine\", and, less common, \"complex area hyperbolic cosine\".\n\nInverse hyperbolic cosine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segment (-∞,+1) of the real axis.\n\nThe mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + √z+1 √z-1) For any z, acosh(z) =\n\n√z-1/√1-z acos(z), or simply i acos(z) in the upper half of the complex plane.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = cacosh(0.5);\n    printf(\"cacosh(+0.5+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = conj(0.5); // or cacosh(CMPLX(0.5, -0.0)) in C11\n    printf(\"cacosh(+0.5-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // in upper half-plane, acosh(z) = i*acos(z) \n    double complex z3 = casinh(1+I);\n    printf(\"casinh(1+1i) = %f%+fi\\n\", creal(z3), cimag(z3));\n    double complex z4 = I*casin(1+I);\n    printf(\"I*asin(1+1i) = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\ncacosh(+0.5+0i) = 0.000000-1.047198i\ncacosh(+0.5-0i) (the other side of the cut) = 0.500000-0.000000i\ncasinh(1+1i) = 1.061275+0.666239i\nI*asin(1+1i) = -1.061275+0.666239i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.1 The cacosh functions (p: 192)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.1 The cacosh functions (p: 539-540)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.1 The cacosh functions (p: 174)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.1 The cacosh functions (p: 474-475)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cacosh](https://en.cppreference.com/w/c/numeric/complex/cacosh)"
- name: cacoshl
  summary: The complex arc hyperbolic cosine of z in the interval [0; ∞) along the real axis and in the interval [−iπ; +iπ] along the imaginary axis
  description: "# cacoshf, cacosh, cacoshl\n\n[TABLE]\n\n1-3) Computes complex arc hyperbolic cosine of a complex value `z` with branch cut at values less than 1 along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacoshl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacosh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacoshf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`acoshf`, [`acosh`](http://en.cppreference.com/w/c/numeric/math/acosh), `acoshl`). If `z` is imaginary, then the macro invokes the corresponding complex number version and the return type is complex.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe complex arc hyperbolic cosine of `z` in the interval \\[0; ∞) along the real axis and in the interval \\[−iπ; +iπ\\] along the imaginary axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `cacosh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``cacosh``(``z``)``)`\n- If `z` is `±0+0i`, the result is `+0+iπ/2`\n- If `z` is `+x+∞i` (for any finite x), the result is `+∞+iπ/2`\n- If `z` is `+x+NaNi` (for non-zero finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `0+NaNi`, the result is `NaN±iπ/2`, where the sign of the imaginary part is unspecified\n- If `z` is `-∞+yi` (for any positive finite y), the result is `+∞+iπ`\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+∞+0i`\n- If `z` is `-∞+∞i`, the result is `+∞+3iπ/4`\n- If `z` is `+∞+∞i`, the result is `+∞+iπ/4`\n- If `z` is `±∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `NaN+∞i`, the result is `+∞+NaNi`\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nAlthough the C standard names this function \"complex arc hyperbolic cosine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic cosine\", and, less common, \"complex area hyperbolic cosine\".\n\nInverse hyperbolic cosine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segment (-∞,+1) of the real axis.\n\nThe mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + √z+1 √z-1) For any z, acosh(z) =\n\n√z-1/√1-z acos(z), or simply i acos(z) in the upper half of the complex plane.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = cacosh(0.5);\n    printf(\"cacosh(+0.5+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = conj(0.5); // or cacosh(CMPLX(0.5, -0.0)) in C11\n    printf(\"cacosh(+0.5-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // in upper half-plane, acosh(z) = i*acos(z) \n    double complex z3 = casinh(1+I);\n    printf(\"casinh(1+1i) = %f%+fi\\n\", creal(z3), cimag(z3));\n    double complex z4 = I*casin(1+I);\n    printf(\"I*asin(1+1i) = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\ncacosh(+0.5+0i) = 0.000000-1.047198i\ncacosh(+0.5-0i) (the other side of the cut) = 0.500000-0.000000i\ncasinh(1+1i) = 1.061275+0.666239i\nI*asin(1+1i) = -1.061275+0.666239i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.1 The cacosh functions (p: 192)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.1 The cacosh functions (p: 539-540)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.1 The cacosh functions (p: 174)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.1 The cacosh functions (p: 474-475)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cacosh](https://en.cppreference.com/w/c/numeric/complex/cacosh)"
- name: cacosl
  summary: If no errors occur, complex arc cosine of z is returned, in the range a strip unbounded along the imaginary axis and in the interval [0; π] along the real axis
  description: "# cacosf, cacos, cacosl\n\n[TABLE]\n\n1-3) Computes the complex arc cosine of `z` with branch cuts outside the interval \\[−1,+1\\] along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacosl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacos` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cacosf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`acosf`, [`acos`](http://en.cppreference.com/w/c/numeric/math/acos), `acosl`). If `z` is imaginary, then the macro invokes the corresponding complex number version.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex arc cosine of `z` is returned, in the range a strip unbounded along the imaginary axis and in the interval \\[0; π\\] along the real axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [`math_errhandling`](../math/math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `cacos``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``cacos``(``z``)``)`\n- If `z` is `±0+0i`, the result is `π/2-0i`\n- If `z` is `±0+NaNi`, the result is `π/2+NaNi`\n- If `z` is `x+∞i` (for any finite x), the result is `π/2-∞i`\n- If `z` is `x+NaNi` (for any nonzero finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `-∞+yi` (for any positive finite y), the result is `π-∞i`\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+0-∞i`\n- If `z` is `-∞+∞i`, the result is `3π/4-∞i`\n- If `z` is `+∞+∞i`, the result is `π/4-∞i`\n- If `z` is `±∞+NaNi`, the result is `NaN±∞i` (the sign of the imaginary part is unspecified)\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `NaN-∞i`\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nInverse cosine (or arc cosine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventially placed at the line segments (-∞,-1) and (1,∞) of the real axis. The mathematical definition of the principal value of arc cosine is acos z =\n\n1/2π + *i*ln(*i*z + √1-z²)\n\nFor any z, acos(z) = π - acos(-z)\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = cacos(-2);\n    printf(\"cacos(-2+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = cacos(conj(-2)); // or CMPLX(-2, -0.0)\n    printf(\"cacos(-2-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, acos(z) = pi - acos(-z)\n    double pi = acos(-1);\n    double complex z3 = ccos(pi-z2);\n    printf(\"ccos(pi - cacos(-2-0i) = %f%+fi\\n\", creal(z3), cimag(z3));\n}\n```\n\nOutput:\n\n```\ncacos(-2+0i) = 3.141593-1.316958i\ncacos(-2-0i) (the other side of the cut) = 3.141593+1.316958i\nccos(pi - cacos(-2-0i) = 2.000000+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.1 The cacos functions (p: 190)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.1.1 The cacos functions (p: 539)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.1 The cacos functions (p: 172)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.1.1 The cacos functions (p: 474)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cacos](https://en.cppreference.com/w/c/numeric/complex/cacos)"
- name: call_once
  summary: (none)
  description: "# call_once, once_flag, ONCE_FLAG_INIT\n\n[TABLE]\n\n1) Calls function `func` exactly once, even if invoked from several threads. The completion of the function `func` synchronizes with all previous or subsequent calls to `call_once` with the same `flag` variable.\n\n2) Complete object type capable of holding a flag used by `call_once`.\n\n3) Expands to a value that can be used to initialize an object of type `once_flag`.\n\n### Parameters\n\n|      |     |                                                                                            |\n|------|-----|--------------------------------------------------------------------------------------------|\n| flag | \\-  | pointer to an object of type `call_once` that is used to ensure `func` is called only once |\n| func | \\-  | the function to execute only once                                                          |\n\n### Return value\n\n(none)\n\n### Notes\n\nThe POSIX equivalent of this function is [`pthread_once`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_once.html).\n\n### Example\n\n```\n#include <stdio.h>\n#include <threads.h>\n \nvoid do_once(void) {\n    puts(\"called once\");\n}\n \nstatic once_flag flag = ONCE_FLAG_INIT;\nint func(void* data)\n{\n    call_once(&flag, do_once);\n}\n \nint main(void)\n{\n    thrd_t t1, t2, t3, t4;\n    thrd_create(&t1, func, NULL);\n    thrd_create(&t2, func, NULL);\n    thrd_create(&t3, func, NULL);\n    thrd_create(&t4, func, NULL);\n \n    thrd_join(t1, NULL);\n    thrd_join(t2, NULL);\n    thrd_join(t3, NULL);\n    thrd_join(t4, NULL);\n}\n```\n\nOutput:\n\n```\ncalled once\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.2.1 The call_once function (p: 275)\n  - 7.26.1/3 ONCE_FLAG_INIT (p: 274)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.2.1 The call_once function (p: 378)\n  - 7.26.1/3 ONCE_FLAG_INIT (p: 376)\n\n### See also\n\n|                                                                                                                |     |\n|----------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/call_once \"cpp/thread/call once\") for `call_once` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/call_once](https://en.cppreference.com/w/c/thread/call_once)"
- name: calloc
  summary: Allocates memory for an array of num objects of size and initializes all bytes in the allocated storage to zero
  description: "# calloc\n\n[TABLE]\n\nAllocates memory for an array of `num` objects of `size` and initializes all bytes in the allocated storage to zero.\n\nIf allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type with [fundamental alignment](../language/object#Alignment \"c/language/object\").\n\nIf `size` is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).\n\n[TABLE]\n\n### Parameters\n\n|      |     |                     |\n|------|-----|---------------------|\n| num  | \\-  | number of objects   |\n| size | \\-  | size of each object |\n\n### Return value\n\nOn success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with [`free()`](free \"c/memory/free\") or [`realloc()`](realloc \"c/memory/realloc\").\n\nOn failure, returns a null pointer.\n\n### Notes\n\nDue to the alignment requirements, the number of allocated bytes is not necessarily equal to `num * size`.\n\nInitialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).\n\nOriginally (in C89), support for zero size was added to accommodate code such as\n\n```\nOBJ* p = calloc(0, sizeof(OBJ)); // \"zero-length\" placeholder\n...\nwhile(1)\n{\n    p = realloc(p, c * sizeof(OBJ)); // reallocations until size settles\n    ... // code that may change c or break out of loop\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int* p1 = calloc(4, sizeof(int));    // allocate and zero out an array of 4 int\n    int* p2 = calloc(1, sizeof(int[4])); // same, naming the array type directly\n    int* p3 = calloc(4, sizeof *p3);     // same, without repeating the type name\n \n    if (p2)\n    {\n        for (int n = 0; n < 4; ++n) // print the array\n            printf(\"p2[%d] == %d\\n\", n, p2[n]);\n    }\n \n    free(p1);\n    free(p2);\n    free(p3);\n}\n```\n\nOutput:\n\n```\np2[0] == 0\np2[1] == 0\np2[2] == 0\np2[3] == 0\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.22.3.2 The calloc function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.3.2 The calloc function (p: 253)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.3.2 The calloc function (p: 348)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.3.1 The calloc function (p: 313)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.3.1 The calloc function\n\n### See also\n\n|                                                                                                           |     |\n|-----------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/memory/c/calloc \"cpp/memory/c/calloc\") for `calloc` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/memory/calloc](https://en.cppreference.com/w/c/memory/calloc)"
- name: carg
  summary: If no errors occur, returns the phase angle of z in the interval [−π; π]
  description: "# cargf, carg, cargl\n\n[TABLE]\n\n1-3) Computes the argument (also called phase angle) of `z`, with a branch cut along the negative real axis.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `cargl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `cargf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `carg` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, returns the phase angle of `z` in the interval \\[−π; π\\].\n\nErrors and special cases are handled as if the function is implemented as [`atan2`](http://en.cppreference.com/w/c/numeric/math/atan2)`(`[`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)``, `[`creal`](http://en.cppreference.com/w/c/numeric/complex/creal)`(``z``)``)`\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void) \n{\n    double complex z1 = 1.0+0.0*I;\n    printf(\"phase angle of %.1f%+.1fi is %f\\n\", creal(z1), cimag(z1), carg(z1));\n \n    double complex z2 = 0.0+1.0*I;\n    printf(\"phase angle of %.1f%+.1fi is %f\\n\", creal(z2), cimag(z2), carg(z2));\n \n    double complex z3 = -1.0+0.0*I;\n    printf(\"phase angle of %.1f%+.1fi is %f\\n\", creal(z3), cimag(z3), carg(z3));\n \n    double complex z4 = conj(z3); // or CMPLX(-1, -0.0)\n    printf(\"phase angle of %.1f%+.1fi (the other side of the cut) is %f\\n\",\n             creal(z4), cimag(z4), carg(z4));\n}\n```\n\nOutput:\n\n```\nphase angle of 1.0+0.0i is 0.000000\nphase angle of 0.0+1.0i is 1.570796\nphase angle of -1.0+0.0i is 3.141593\nphase angle of -1.0-0.0i (the other side of the cut) is -3.141593\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.1 The carg functions (p: 196)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.1 The carg functions (p: 178)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/carg](https://en.cppreference.com/w/c/numeric/complex/carg)"
- name: cargf
  summary: If no errors occur, returns the phase angle of z in the interval [−π; π]
  description: "# cargf, carg, cargl\n\n[TABLE]\n\n1-3) Computes the argument (also called phase angle) of `z`, with a branch cut along the negative real axis.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `cargl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `cargf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `carg` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, returns the phase angle of `z` in the interval \\[−π; π\\].\n\nErrors and special cases are handled as if the function is implemented as [`atan2`](http://en.cppreference.com/w/c/numeric/math/atan2)`(`[`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)``, `[`creal`](http://en.cppreference.com/w/c/numeric/complex/creal)`(``z``)``)`\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void) \n{\n    double complex z1 = 1.0+0.0*I;\n    printf(\"phase angle of %.1f%+.1fi is %f\\n\", creal(z1), cimag(z1), carg(z1));\n \n    double complex z2 = 0.0+1.0*I;\n    printf(\"phase angle of %.1f%+.1fi is %f\\n\", creal(z2), cimag(z2), carg(z2));\n \n    double complex z3 = -1.0+0.0*I;\n    printf(\"phase angle of %.1f%+.1fi is %f\\n\", creal(z3), cimag(z3), carg(z3));\n \n    double complex z4 = conj(z3); // or CMPLX(-1, -0.0)\n    printf(\"phase angle of %.1f%+.1fi (the other side of the cut) is %f\\n\",\n             creal(z4), cimag(z4), carg(z4));\n}\n```\n\nOutput:\n\n```\nphase angle of 1.0+0.0i is 0.000000\nphase angle of 0.0+1.0i is 1.570796\nphase angle of -1.0+0.0i is 3.141593\nphase angle of -1.0-0.0i (the other side of the cut) is -3.141593\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.1 The carg functions (p: 196)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.1 The carg functions (p: 178)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/carg](https://en.cppreference.com/w/c/numeric/complex/carg)"
- name: cargl
  summary: If no errors occur, returns the phase angle of z in the interval [−π; π]
  description: "# cargf, carg, cargl\n\n[TABLE]\n\n1-3) Computes the argument (also called phase angle) of `z`, with a branch cut along the negative real axis.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `cargl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `cargf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `carg` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, returns the phase angle of `z` in the interval \\[−π; π\\].\n\nErrors and special cases are handled as if the function is implemented as [`atan2`](http://en.cppreference.com/w/c/numeric/math/atan2)`(`[`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)``, `[`creal`](http://en.cppreference.com/w/c/numeric/complex/creal)`(``z``)``)`\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void) \n{\n    double complex z1 = 1.0+0.0*I;\n    printf(\"phase angle of %.1f%+.1fi is %f\\n\", creal(z1), cimag(z1), carg(z1));\n \n    double complex z2 = 0.0+1.0*I;\n    printf(\"phase angle of %.1f%+.1fi is %f\\n\", creal(z2), cimag(z2), carg(z2));\n \n    double complex z3 = -1.0+0.0*I;\n    printf(\"phase angle of %.1f%+.1fi is %f\\n\", creal(z3), cimag(z3), carg(z3));\n \n    double complex z4 = conj(z3); // or CMPLX(-1, -0.0)\n    printf(\"phase angle of %.1f%+.1fi (the other side of the cut) is %f\\n\",\n             creal(z4), cimag(z4), carg(z4));\n}\n```\n\nOutput:\n\n```\nphase angle of 1.0+0.0i is 0.000000\nphase angle of 0.0+1.0i is 1.570796\nphase angle of -1.0+0.0i is 3.141593\nphase angle of -1.0-0.0i (the other side of the cut) is -3.141593\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.1 The carg functions (p: 196)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.1 The carg functions (p: 178)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/carg](https://en.cppreference.com/w/c/numeric/complex/carg)"
- name: case
  summary: ''
  description: "# C keywords: case\n\n### Usage\n\n- [`switch` statement](../language/switch \"c/language/switch\"): as the declaration of the case labels\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/case](https://en.cppreference.com/w/c/keyword/case)"
- name: casin
  summary: If no errors occur, complex arc sine of z is returned, in the range of a strip unbounded along the imaginary axis and in the interval [−π/2; +π/2] along the real axis
  description: "# casinf, casin, casinl\n\n[TABLE]\n\n1-3) Computes the complex arc sine of `z` with branch cuts outside the interval \\[−1,+1\\] along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casin` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`asinf`, [`asin`](http://en.cppreference.com/w/c/numeric/math/asin), `asinl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`asinh`](../math/asinh \"c/numeric/math/asinh\"), implementing the formula \\\\\\small \\arcsin({\\rm i}y) = {\\rm i}{\\rm arsinh}(y)\\\\arcsin(iy) = i arsinh(y), and the return type of the macro is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex arc sine of `z` is returned, in the range of a strip unbounded along the imaginary axis and in the interval \\[−π/2; +π/2\\] along the real axis.\n\nErrors and special cases are handled as if the operation is implemented by `-``I ``*`` `[`casinh`](http://en.cppreference.com/w/c/numeric/complex/casinh)`(``I``*``z``)`\n\n### Notes\n\nInverse sine (or arc sine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-∞,-1) and (1,∞) of the real axis.\n\nThe mathematical definition of the principal value of arc sine is \\\\\\small \\arcsin z = -{\\rm i}\\ln({\\rm i}z+\\sqrt{1-z^2})\\\\arcsin z = -*i*ln(*i*z + √1-z²) For any z, \\\\\\small{ \\arcsin(z) = \\arccos(-z) - \\frac{\\pi}{2} }\\\\arcsin(z) = acos(-z) -\n\nπ/2\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = casin(-2);\n    printf(\"casin(-2+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = casin(conj(-2)); // or CMPLX(-2, -0.0)\n    printf(\"casin(-2-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, asin(z) = acos(-z) - pi/2\n    double pi = acos(-1);\n    double complex z3 = csin(cacos(conj(-2))-pi/2);\n    printf(\"csin(cacos(-2-0i)-pi/2) = %f%+fi\\n\", creal(z3), cimag(z3));\n}\n```\n\nOutput:\n\n```\ncasin(-2+0i) = -1.570796+1.316958i\ncasin(-2-0i) (the other side of the cut) = -1.570796-1.316958i\ncsin(cacos(-2-0i)-pi/2) = 2.000000+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.2 The casin functions (p: 190)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.2 The casin functions (p: 172)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/casin](https://en.cppreference.com/w/c/numeric/complex/casin)"
- name: casinf
  summary: If no errors occur, complex arc sine of z is returned, in the range of a strip unbounded along the imaginary axis and in the interval [−π/2; +π/2] along the real axis
  description: "# casinf, casin, casinl\n\n[TABLE]\n\n1-3) Computes the complex arc sine of `z` with branch cuts outside the interval \\[−1,+1\\] along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casin` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`asinf`, [`asin`](http://en.cppreference.com/w/c/numeric/math/asin), `asinl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`asinh`](../math/asinh \"c/numeric/math/asinh\"), implementing the formula \\\\\\small \\arcsin({\\rm i}y) = {\\rm i}{\\rm arsinh}(y)\\\\arcsin(iy) = i arsinh(y), and the return type of the macro is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex arc sine of `z` is returned, in the range of a strip unbounded along the imaginary axis and in the interval \\[−π/2; +π/2\\] along the real axis.\n\nErrors and special cases are handled as if the operation is implemented by `-``I ``*`` `[`casinh`](http://en.cppreference.com/w/c/numeric/complex/casinh)`(``I``*``z``)`\n\n### Notes\n\nInverse sine (or arc sine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-∞,-1) and (1,∞) of the real axis.\n\nThe mathematical definition of the principal value of arc sine is \\\\\\small \\arcsin z = -{\\rm i}\\ln({\\rm i}z+\\sqrt{1-z^2})\\\\arcsin z = -*i*ln(*i*z + √1-z²) For any z, \\\\\\small{ \\arcsin(z) = \\arccos(-z) - \\frac{\\pi}{2} }\\\\arcsin(z) = acos(-z) -\n\nπ/2\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = casin(-2);\n    printf(\"casin(-2+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = casin(conj(-2)); // or CMPLX(-2, -0.0)\n    printf(\"casin(-2-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, asin(z) = acos(-z) - pi/2\n    double pi = acos(-1);\n    double complex z3 = csin(cacos(conj(-2))-pi/2);\n    printf(\"csin(cacos(-2-0i)-pi/2) = %f%+fi\\n\", creal(z3), cimag(z3));\n}\n```\n\nOutput:\n\n```\ncasin(-2+0i) = -1.570796+1.316958i\ncasin(-2-0i) (the other side of the cut) = -1.570796-1.316958i\ncsin(cacos(-2-0i)-pi/2) = 2.000000+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.2 The casin functions (p: 190)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.2 The casin functions (p: 172)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/casin](https://en.cppreference.com/w/c/numeric/complex/casin)"
- name: casinh
  summary: If no errors occur, the complex arc hyperbolic sine of z is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [−iπ/2; +iπ/2] along the imaginary axis
  description: "# casinhf, casinh, casinhl\n\n[TABLE]\n\n1-3) Computes the complex arc hyperbolic sine of `z` with branch cuts outside the interval \\[−i; +i\\] along the imaginary axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`asinhf`, [`asinh`](http://en.cppreference.com/w/c/numeric/math/asinh), `asinhl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`asin`](../math/asin \"c/numeric/math/asin\"), implementing the formula asinh(iy) = i asin(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex arc hyperbolic sine of `z` is returned, in the range of a strip mathematically unbounded along the real axis and in the interval \\[−iπ/2; +iπ/2\\] along the imaginary axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `casinh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``casinh``(``z``)``)`\n- `casinh(-z) == -casinh(z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `x+∞i` (for any positive finite x), the result is `+∞+π/2`\n- If `z` is `x+NaNi` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+∞+0i`\n- If `z` is `+∞+∞i`, the result is `+∞+iπ/4`\n- If `z` is `+∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any finite nonzero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `±∞+NaNi` (the sign of the real part is unspecified)\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nAlthough the C standard names this function \"complex arc hyperbolic sine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic sine\", and, less common, \"complex area hyperbolic sine\".\n\nInverse hyperbolic sine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-*i*∞,-*i*) and (*i*,*i*∞) of the imaginary axis.\n\nThe mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + √1+z²) For any z, asinh(z) =\n\nasin(iz)/i\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = casinh(0+2*I);\n    printf(\"casinh(+0+2i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = casinh(-conj(2*I)); // or casinh(CMPLX(-0.0, 2)) in C11\n    printf(\"casinh(-0+2i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, asinh(z) = asin(iz)/i\n    double complex z3 = casinh(1+2*I);\n    printf(\"casinh(1+2i) = %f%+fi\\n\", creal(z3), cimag(z3));\n    double complex z4 = casin((1+2*I)*I)/I;\n    printf(\"casin(i * (1+2i))/i = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\ncasinh(+0+2i) = 1.316958+1.570796i\ncasinh(-0+2i) (the other side of the cut) = -1.316958+1.570796i\ncasinh(1+2i) = 1.469352+1.063440i\ncasin(i * (1+2i))/i =  1.469352+1.063440i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.2 The casinh functions (p: 192-193)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.2 The casinh functions (p: 540)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.2 The casinh functions (p: 174-175)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.2 The casinh functions (p: 475)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/casinh](https://en.cppreference.com/w/c/numeric/complex/casinh)"
- name: casinhf
  summary: If no errors occur, the complex arc hyperbolic sine of z is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [−iπ/2; +iπ/2] along the imaginary axis
  description: "# casinhf, casinh, casinhl\n\n[TABLE]\n\n1-3) Computes the complex arc hyperbolic sine of `z` with branch cuts outside the interval \\[−i; +i\\] along the imaginary axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`asinhf`, [`asinh`](http://en.cppreference.com/w/c/numeric/math/asinh), `asinhl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`asin`](../math/asin \"c/numeric/math/asin\"), implementing the formula asinh(iy) = i asin(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex arc hyperbolic sine of `z` is returned, in the range of a strip mathematically unbounded along the real axis and in the interval \\[−iπ/2; +iπ/2\\] along the imaginary axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `casinh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``casinh``(``z``)``)`\n- `casinh(-z) == -casinh(z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `x+∞i` (for any positive finite x), the result is `+∞+π/2`\n- If `z` is `x+NaNi` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+∞+0i`\n- If `z` is `+∞+∞i`, the result is `+∞+iπ/4`\n- If `z` is `+∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any finite nonzero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `±∞+NaNi` (the sign of the real part is unspecified)\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nAlthough the C standard names this function \"complex arc hyperbolic sine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic sine\", and, less common, \"complex area hyperbolic sine\".\n\nInverse hyperbolic sine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-*i*∞,-*i*) and (*i*,*i*∞) of the imaginary axis.\n\nThe mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + √1+z²) For any z, asinh(z) =\n\nasin(iz)/i\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = casinh(0+2*I);\n    printf(\"casinh(+0+2i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = casinh(-conj(2*I)); // or casinh(CMPLX(-0.0, 2)) in C11\n    printf(\"casinh(-0+2i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, asinh(z) = asin(iz)/i\n    double complex z3 = casinh(1+2*I);\n    printf(\"casinh(1+2i) = %f%+fi\\n\", creal(z3), cimag(z3));\n    double complex z4 = casin((1+2*I)*I)/I;\n    printf(\"casin(i * (1+2i))/i = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\ncasinh(+0+2i) = 1.316958+1.570796i\ncasinh(-0+2i) (the other side of the cut) = -1.316958+1.570796i\ncasinh(1+2i) = 1.469352+1.063440i\ncasin(i * (1+2i))/i =  1.469352+1.063440i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.2 The casinh functions (p: 192-193)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.2 The casinh functions (p: 540)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.2 The casinh functions (p: 174-175)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.2 The casinh functions (p: 475)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/casinh](https://en.cppreference.com/w/c/numeric/complex/casinh)"
- name: casinhl
  summary: If no errors occur, the complex arc hyperbolic sine of z is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [−iπ/2; +iπ/2] along the imaginary axis
  description: "# casinhf, casinh, casinhl\n\n[TABLE]\n\n1-3) Computes the complex arc hyperbolic sine of `z` with branch cuts outside the interval \\[−i; +i\\] along the imaginary axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`asinhf`, [`asinh`](http://en.cppreference.com/w/c/numeric/math/asinh), `asinhl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`asin`](../math/asin \"c/numeric/math/asin\"), implementing the formula asinh(iy) = i asin(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex arc hyperbolic sine of `z` is returned, in the range of a strip mathematically unbounded along the real axis and in the interval \\[−iπ/2; +iπ/2\\] along the imaginary axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `casinh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``casinh``(``z``)``)`\n- `casinh(-z) == -casinh(z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `x+∞i` (for any positive finite x), the result is `+∞+π/2`\n- If `z` is `x+NaNi` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+∞+0i`\n- If `z` is `+∞+∞i`, the result is `+∞+iπ/4`\n- If `z` is `+∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any finite nonzero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `±∞+NaNi` (the sign of the real part is unspecified)\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nAlthough the C standard names this function \"complex arc hyperbolic sine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic sine\", and, less common, \"complex area hyperbolic sine\".\n\nInverse hyperbolic sine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-*i*∞,-*i*) and (*i*,*i*∞) of the imaginary axis.\n\nThe mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + √1+z²) For any z, asinh(z) =\n\nasin(iz)/i\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = casinh(0+2*I);\n    printf(\"casinh(+0+2i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = casinh(-conj(2*I)); // or casinh(CMPLX(-0.0, 2)) in C11\n    printf(\"casinh(-0+2i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, asinh(z) = asin(iz)/i\n    double complex z3 = casinh(1+2*I);\n    printf(\"casinh(1+2i) = %f%+fi\\n\", creal(z3), cimag(z3));\n    double complex z4 = casin((1+2*I)*I)/I;\n    printf(\"casin(i * (1+2i))/i = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\ncasinh(+0+2i) = 1.316958+1.570796i\ncasinh(-0+2i) (the other side of the cut) = -1.316958+1.570796i\ncasinh(1+2i) = 1.469352+1.063440i\ncasin(i * (1+2i))/i =  1.469352+1.063440i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.2 The casinh functions (p: 192-193)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.2 The casinh functions (p: 540)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.2 The casinh functions (p: 174-175)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.2 The casinh functions (p: 475)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/casinh](https://en.cppreference.com/w/c/numeric/complex/casinh)"
- name: casinl
  summary: If no errors occur, complex arc sine of z is returned, in the range of a strip unbounded along the imaginary axis and in the interval [−π/2; +π/2] along the real axis
  description: "# casinf, casin, casinl\n\n[TABLE]\n\n1-3) Computes the complex arc sine of `z` with branch cuts outside the interval \\[−1,+1\\] along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casin` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `casinf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`asinf`, [`asin`](http://en.cppreference.com/w/c/numeric/math/asin), `asinl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`asinh`](../math/asinh \"c/numeric/math/asinh\"), implementing the formula \\\\\\small \\arcsin({\\rm i}y) = {\\rm i}{\\rm arsinh}(y)\\\\arcsin(iy) = i arsinh(y), and the return type of the macro is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex arc sine of `z` is returned, in the range of a strip unbounded along the imaginary axis and in the interval \\[−π/2; +π/2\\] along the real axis.\n\nErrors and special cases are handled as if the operation is implemented by `-``I ``*`` `[`casinh`](http://en.cppreference.com/w/c/numeric/complex/casinh)`(``I``*``z``)`\n\n### Notes\n\nInverse sine (or arc sine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-∞,-1) and (1,∞) of the real axis.\n\nThe mathematical definition of the principal value of arc sine is \\\\\\small \\arcsin z = -{\\rm i}\\ln({\\rm i}z+\\sqrt{1-z^2})\\\\arcsin z = -*i*ln(*i*z + √1-z²) For any z, \\\\\\small{ \\arcsin(z) = \\arccos(-z) - \\frac{\\pi}{2} }\\\\arcsin(z) = acos(-z) -\n\nπ/2\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = casin(-2);\n    printf(\"casin(-2+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = casin(conj(-2)); // or CMPLX(-2, -0.0)\n    printf(\"casin(-2-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, asin(z) = acos(-z) - pi/2\n    double pi = acos(-1);\n    double complex z3 = csin(cacos(conj(-2))-pi/2);\n    printf(\"csin(cacos(-2-0i)-pi/2) = %f%+fi\\n\", creal(z3), cimag(z3));\n}\n```\n\nOutput:\n\n```\ncasin(-2+0i) = -1.570796+1.316958i\ncasin(-2-0i) (the other side of the cut) = -1.570796-1.316958i\ncsin(cacos(-2-0i)-pi/2) = 2.000000+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.2 The casin functions (p: 190)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.2 The casin functions (p: 172)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/casin](https://en.cppreference.com/w/c/numeric/complex/casin)"
- name: cast operator
  summary: Performs explicit type conversion
  description: "# cast operator\n\nPerforms explicit type conversion\n\n### Syntax\n\n|                              |     |     |\n|------------------------------|-----|-----|\n| `(` type-name `)` expression |     |     |\n\nwhere\n\n|            |     |                                                                                                                                                                          |\n|------------|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| type-name  | \\-  | either the type `void` or any [scalar type](type#Type_groups \"c/language/type\")                                                                                          |\n| expression | \\-  | any [expression](expressions \"c/language/expressions\") of [scalar type](type#Type_groups \"c/language/type\") (unless type-name is void, in which case it can be anything) |\n\n### Explanation\n\nIf type-name is `void`, then expression is evaluated for its side-effects and its returned value is discarded, same as when expression is used on its own, as an [expression statement](statements#Expression_statements \"c/language/statements\").\n\nOtherwise, if type-name is exactly the type of expression, nothing is done (except that if expression has floating type and is represented with greater range and precision than its type indicates -- see below)\n\nOtherwise, the value of expression is converted to the type named by type-name, as follows:\n\nEvery [implicit conversion as if by assignment](conversion \"c/language/conversion\") is allowed.\n\nIn addition to the implicit conversions, the following conversions are allowed:\n\n- Any integer can be cast to any pointer type. Except for the null pointer constants such as [`NULL`](../types/null \"c/types/NULL\") (which [doesn't need a cast](conversion \"c/language/conversion\")), the result is implementation-defined, may not be correctly aligned, may not point to an object of the referenced type, and may be a [trap representation](object \"c/language/object\").\n- Any pointer type can be cast to any integer type. The result is implementation-defined, even for null pointer values (they do not necessarily result in the value zero). If the result cannot be represented in the target type, the behavior is undefined (unsigned integers do not implement modulo arithmetic on a cast from pointer)\n- Any pointer to object can be cast to any other pointer to object. If the value is not correctly aligned for the target type, the behavior is undefined. Otherwise, if the value is converted back to the original type, it compares equal to the original value. If a pointer to object is cast to pointer to any character type, the result points at the lowest byte of the object and may be incremented up to sizeof the target type (in other words, can be used to examine [object representation](object \"c/language/object\") or to make a copy via [`memcpy`](../string/byte/memcpy \"c/string/byte/memcpy\") or [`memmove`](../string/byte/memmove \"c/string/byte/memmove\")).\n- Any pointer to function can be cast to a pointer to any other function type. If the resulting pointer is converted back to the original type, it compares equal to the original value. If the converted pointer is used to make a function call, the behavior is undefined (unless the function types are [compatible](type#Compatible_types \"c/language/type\"))\n- When casting between pointers (either object or function), if the original value is a null pointer value of its type, the result is the correct null pointer value for the target type.\n\nIn any case (both when executing an implicit conversion and in the same-type cast), if expression and type-name are floating types and expression is represented with greater range and precision than its type indicates (see [`FLT_EVAL_METHOD`](../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\")), the range and precision are stripped off to match the target type.\n\nThe [value category](value_category \"c/language/value category\") of the cast expression is always non-lvalue.\n\n### Notes\n\nBecause [`const`](const \"c/language/const\"), [`volatile`](volatile \"c/language/volatile\"), [`restrict`](restrict \"c/language/restrict\"), and [`_Atomic`](atomic \"c/language/atomic\") qualifiers have effect on [lvalues](value_category \"c/language/value category\") only, a cast to a cvr-qualified or atomic type is exactly equivalent to the cast to the corresponding unqualified type.\n\nThe cast to `void` is sometimes useful to silence compiler warnings about unused results.\n\nThe conversions not listed here are not allowed. In particular,\n\n- there are no conversions between pointers and floating types\n- there are no conversions between pointers to functions and pointers to objects (including `void*`)\n\n|                                                                                                                                                                                                                                                                                                               |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If the implementation provides [`intptr_t`](../types/integer \"c/types/integer\") and/or [`uintptr_t`](../types/integer \"c/types/integer\"), then a cast from a pointer to an object type (including *cv* `void`) to these types is always well-defined. However, this is not guaranteed for a function pointer. | (since C99) |\n\nNote that conversions between function pointers and object pointers are accepted as extensions by many compilers, and expected by some usages of [POSIX `dlsym()` function](https://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html).\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    // examining object representation is a legitimate use of cast\n    double d = 3.14;\n    printf(\"The double %.2f (%a) is: \", d, d);\n    for (size_t n = 0; n < sizeof d; ++n)\n        printf(\"0x%02x \", ((unsigned char*)&d)[n]);\n \n    // edge cases\n    struct S { int x; } s;\n//    (struct S)s; // error; not a scalar type\n                   // even though casting to the same type does nothing\n    (void)s; // okay to cast any type to void\n}\n```\n\nPossible output:\n\n```\nThe double 3.14 (0x1.91eb851eb851fp+1) is: 0x1f 0x85 0xeb 0x51 0xb8 0x1e 0x09 0x40\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.5.4 Cast operators (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.4 Cast operators (p: 65-66)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.4 Cast operators (p: 91)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5.4 Cast operators (p: 81)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.3.4 Cast operators\n\n### See also\n\n|                                                                                                                                         |     |\n|-----------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/explicit_cast \"cpp/language/explicit cast\") for explicit type conversion |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/cast](https://en.cppreference.com/w/c/language/cast)"
- name: catan
  summary: If no errors occur, complex arc tangent of z is returned, in the range of a strip unbounded along the imaginary axis and in the interval [−π/2; +π/2] along the real axis
  description: "# catanf, catan, catanl\n\n[TABLE]\n\n1-3) Computes the complex arc tangent of `z` with branch cuts outside the interval \\[−i,+i\\] along the imaginary axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catan` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`atanf`, [`atan`](http://en.cppreference.com/w/c/numeric/math/atan), `atanl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`atanh`](../math/atanh \"c/numeric/math/atanh\"), implementing the formula atan(iy) = i atanh(y), and the return type of the macro is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex arc tangent of `z` is returned, in the range of a strip unbounded along the imaginary axis and in the interval \\[−π/2; +π/2\\] along the real axis.\n\nErrors and special cases are handled as if the operation is implemented by `-``I ``*`` `[`catanh`](http://en.cppreference.com/w/c/numeric/complex/catanh)`(``I``*``z``)`.\n\n### Notes\n\nInverse tangent (or arc tangent) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-∞i,-i) and (+i,+∞i) of the imaginary axis. The mathematical definition of the principal value of inverse tangent is atan z = -\n\n1/2 i \\[ln(1 - iz) - ln (1 + iz\\]\n\n### Example\n\n```\n#include <stdio.h>\n#include <float.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = catan(2*I);\n    printf(\"catan(+0+2i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = catan(-conj(2*I)); // or CMPLX(-0.0, 2)\n    printf(\"catan(-0+2i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    double complex z3 = 2*catan(2*I*DBL_MAX); // or CMPLX(0, INFINITY)\n    printf(\"2*catan(+0+i*Inf) = %f%+fi\\n\", creal(z3), cimag(z3));\n}\n```\n\nOutput:\n\n```\ncatan(+0+2i) = 1.570796+0.549306i\ncatan(-0+2i) (the other side of the cut) = -1.570796+0.549306i\n2*catan(+0+i*Inf) = 3.141593+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.3 The catan functions (p: 191)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.3 The catan functions (p: 173)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/catan](https://en.cppreference.com/w/c/numeric/complex/catan)"
- name: catanf
  summary: If no errors occur, complex arc tangent of z is returned, in the range of a strip unbounded along the imaginary axis and in the interval [−π/2; +π/2] along the real axis
  description: "# catanf, catan, catanl\n\n[TABLE]\n\n1-3) Computes the complex arc tangent of `z` with branch cuts outside the interval \\[−i,+i\\] along the imaginary axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catan` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`atanf`, [`atan`](http://en.cppreference.com/w/c/numeric/math/atan), `atanl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`atanh`](../math/atanh \"c/numeric/math/atanh\"), implementing the formula atan(iy) = i atanh(y), and the return type of the macro is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex arc tangent of `z` is returned, in the range of a strip unbounded along the imaginary axis and in the interval \\[−π/2; +π/2\\] along the real axis.\n\nErrors and special cases are handled as if the operation is implemented by `-``I ``*`` `[`catanh`](http://en.cppreference.com/w/c/numeric/complex/catanh)`(``I``*``z``)`.\n\n### Notes\n\nInverse tangent (or arc tangent) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-∞i,-i) and (+i,+∞i) of the imaginary axis. The mathematical definition of the principal value of inverse tangent is atan z = -\n\n1/2 i \\[ln(1 - iz) - ln (1 + iz\\]\n\n### Example\n\n```\n#include <stdio.h>\n#include <float.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = catan(2*I);\n    printf(\"catan(+0+2i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = catan(-conj(2*I)); // or CMPLX(-0.0, 2)\n    printf(\"catan(-0+2i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    double complex z3 = 2*catan(2*I*DBL_MAX); // or CMPLX(0, INFINITY)\n    printf(\"2*catan(+0+i*Inf) = %f%+fi\\n\", creal(z3), cimag(z3));\n}\n```\n\nOutput:\n\n```\ncatan(+0+2i) = 1.570796+0.549306i\ncatan(-0+2i) (the other side of the cut) = -1.570796+0.549306i\n2*catan(+0+i*Inf) = 3.141593+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.3 The catan functions (p: 191)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.3 The catan functions (p: 173)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/catan](https://en.cppreference.com/w/c/numeric/complex/catan)"
- name: catanh
  summary: If no errors occur, the complex arc hyperbolic tangent of z is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [−iπ/2; +iπ/2] along the imaginary axis
  description: "# catanhf, catanh, catanhl\n\n[TABLE]\n\n1-3) Computes the complex arc hyperbolic tangent of `z` with branch cuts outside the interval \\[−1; +1\\] along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`atanhf`, [`atanh`](http://en.cppreference.com/w/c/numeric/math/atanh), `atanhl`). If `z` is imaginary, then the macro invokes the corresponding real version of [`atan`](http://en.cppreference.com/w/c/numeric/math/atan), implementing the formula atanh(iy) = i atan(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex arc hyperbolic tangent of `z` is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval \\[−iπ/2; +iπ/2\\] along the imaginary axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `catanh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``catanh``(``z``)``)`\n- `catanh(-z) == -catanh(z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `+0+NaNi`, the result is `+0+NaNi`\n- If `z` is `+1+0i`, the result is `+∞+0i` and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+∞i` (for any finite positive x), the result is `+0+iπ/2`\n- If `z` is `x+NaNi` (for any finite nonzero x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+yi` (for any finite positive y), the result is `+0+iπ/2`\n- If `z` is `+∞+∞i`, the result is `+0+iπ/2`\n- If `z` is `+∞+NaNi`, the result is `+0+NaNi`\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `±0+iπ/2` (the sign of the real part is unspecified)\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nAlthough the C standard names this function \"complex arc hyperbolic tangent\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic tangent\", and, less common, \"complex area hyperbolic tangent\".\n\nInverse hyperbolic tangent is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segmentd (-∞,-1\\] and \\[+1,+∞) of the real axis. The mathematical definition of the principal value of the inverse hyperbolic tangent is atanh z =\n\nln(1+z)-ln(z-1)/2.\n\n  \nFor any z, atanh(z) =\n\natan(iz)/i\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = catanh(2);\n    printf(\"catanh(+2+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = catanh(conj(2)); // or catanh(CMPLX(2, -0.0)) in C11\n    printf(\"catanh(+2-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, atanh(z) = atan(iz)/i\n    double complex z3 = catanh(1+2*I);\n    printf(\"catanh(1+2i) = %f%+fi\\n\", creal(z3), cimag(z3));\n    double complex z4 = catan((1+2*I)*I)/I;\n    printf(\"catan(i * (1+2i))/i = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\ncatanh(+2+0i) = 0.549306+1.570796i\ncatanh(+2-0i) (the other side of the cut) = 0.549306-1.570796i\ncatanh(1+2i) = 0.173287+1.178097i\ncatan(i * (1+2i))/i = 0.173287+1.178097i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.3 The catanh functions (p: 193)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.3 The catanh functions (p: 540-541)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.3 The catanh functions (p: 175)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.3 The catanh functions (p: 475-476)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/catanh](https://en.cppreference.com/w/c/numeric/complex/catanh)"
- name: catanhf
  summary: If no errors occur, the complex arc hyperbolic tangent of z is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [−iπ/2; +iπ/2] along the imaginary axis
  description: "# catanhf, catanh, catanhl\n\n[TABLE]\n\n1-3) Computes the complex arc hyperbolic tangent of `z` with branch cuts outside the interval \\[−1; +1\\] along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`atanhf`, [`atanh`](http://en.cppreference.com/w/c/numeric/math/atanh), `atanhl`). If `z` is imaginary, then the macro invokes the corresponding real version of [`atan`](http://en.cppreference.com/w/c/numeric/math/atan), implementing the formula atanh(iy) = i atan(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex arc hyperbolic tangent of `z` is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval \\[−iπ/2; +iπ/2\\] along the imaginary axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `catanh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``catanh``(``z``)``)`\n- `catanh(-z) == -catanh(z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `+0+NaNi`, the result is `+0+NaNi`\n- If `z` is `+1+0i`, the result is `+∞+0i` and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+∞i` (for any finite positive x), the result is `+0+iπ/2`\n- If `z` is `x+NaNi` (for any finite nonzero x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+yi` (for any finite positive y), the result is `+0+iπ/2`\n- If `z` is `+∞+∞i`, the result is `+0+iπ/2`\n- If `z` is `+∞+NaNi`, the result is `+0+NaNi`\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `±0+iπ/2` (the sign of the real part is unspecified)\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nAlthough the C standard names this function \"complex arc hyperbolic tangent\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic tangent\", and, less common, \"complex area hyperbolic tangent\".\n\nInverse hyperbolic tangent is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segmentd (-∞,-1\\] and \\[+1,+∞) of the real axis. The mathematical definition of the principal value of the inverse hyperbolic tangent is atanh z =\n\nln(1+z)-ln(z-1)/2.\n\n  \nFor any z, atanh(z) =\n\natan(iz)/i\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = catanh(2);\n    printf(\"catanh(+2+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = catanh(conj(2)); // or catanh(CMPLX(2, -0.0)) in C11\n    printf(\"catanh(+2-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, atanh(z) = atan(iz)/i\n    double complex z3 = catanh(1+2*I);\n    printf(\"catanh(1+2i) = %f%+fi\\n\", creal(z3), cimag(z3));\n    double complex z4 = catan((1+2*I)*I)/I;\n    printf(\"catan(i * (1+2i))/i = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\ncatanh(+2+0i) = 0.549306+1.570796i\ncatanh(+2-0i) (the other side of the cut) = 0.549306-1.570796i\ncatanh(1+2i) = 0.173287+1.178097i\ncatan(i * (1+2i))/i = 0.173287+1.178097i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.3 The catanh functions (p: 193)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.3 The catanh functions (p: 540-541)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.3 The catanh functions (p: 175)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.3 The catanh functions (p: 475-476)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/catanh](https://en.cppreference.com/w/c/numeric/complex/catanh)"
- name: catanhl
  summary: If no errors occur, the complex arc hyperbolic tangent of z is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [−iπ/2; +iπ/2] along the imaginary axis
  description: "# catanhf, catanh, catanhl\n\n[TABLE]\n\n1-3) Computes the complex arc hyperbolic tangent of `z` with branch cuts outside the interval \\[−1; +1\\] along the real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`atanhf`, [`atanh`](http://en.cppreference.com/w/c/numeric/math/atanh), `atanhl`). If `z` is imaginary, then the macro invokes the corresponding real version of [`atan`](http://en.cppreference.com/w/c/numeric/math/atan), implementing the formula atanh(iy) = i atan(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex arc hyperbolic tangent of `z` is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval \\[−iπ/2; +iπ/2\\] along the imaginary axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `catanh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``catanh``(``z``)``)`\n- `catanh(-z) == -catanh(z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `+0+NaNi`, the result is `+0+NaNi`\n- If `z` is `+1+0i`, the result is `+∞+0i` and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+∞i` (for any finite positive x), the result is `+0+iπ/2`\n- If `z` is `x+NaNi` (for any finite nonzero x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+yi` (for any finite positive y), the result is `+0+iπ/2`\n- If `z` is `+∞+∞i`, the result is `+0+iπ/2`\n- If `z` is `+∞+NaNi`, the result is `+0+NaNi`\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `±0+iπ/2` (the sign of the real part is unspecified)\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nAlthough the C standard names this function \"complex arc hyperbolic tangent\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic tangent\", and, less common, \"complex area hyperbolic tangent\".\n\nInverse hyperbolic tangent is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segmentd (-∞,-1\\] and \\[+1,+∞) of the real axis. The mathematical definition of the principal value of the inverse hyperbolic tangent is atanh z =\n\nln(1+z)-ln(z-1)/2.\n\n  \nFor any z, atanh(z) =\n\natan(iz)/i\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = catanh(2);\n    printf(\"catanh(+2+0i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = catanh(conj(2)); // or catanh(CMPLX(2, -0.0)) in C11\n    printf(\"catanh(+2-0i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    // for any z, atanh(z) = atan(iz)/i\n    double complex z3 = catanh(1+2*I);\n    printf(\"catanh(1+2i) = %f%+fi\\n\", creal(z3), cimag(z3));\n    double complex z4 = catan((1+2*I)*I)/I;\n    printf(\"catan(i * (1+2i))/i = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\ncatanh(+2+0i) = 0.549306+1.570796i\ncatanh(+2-0i) (the other side of the cut) = 0.549306-1.570796i\ncatanh(1+2i) = 0.173287+1.178097i\ncatan(i * (1+2i))/i = 0.173287+1.178097i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.3 The catanh functions (p: 193)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.3 The catanh functions (p: 540-541)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.3 The catanh functions (p: 175)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.3 The catanh functions (p: 475-476)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/catanh](https://en.cppreference.com/w/c/numeric/complex/catanh)"
- name: catanl
  summary: If no errors occur, complex arc tangent of z is returned, in the range of a strip unbounded along the imaginary axis and in the interval [−π/2; +π/2] along the real axis
  description: "# catanf, catan, catanl\n\n[TABLE]\n\n1-3) Computes the complex arc tangent of `z` with branch cuts outside the interval \\[−i,+i\\] along the imaginary axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catan` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `catanf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`atanf`, [`atan`](http://en.cppreference.com/w/c/numeric/math/atan), `atanl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`atanh`](../math/atanh \"c/numeric/math/atanh\"), implementing the formula atan(iy) = i atanh(y), and the return type of the macro is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex arc tangent of `z` is returned, in the range of a strip unbounded along the imaginary axis and in the interval \\[−π/2; +π/2\\] along the real axis.\n\nErrors and special cases are handled as if the operation is implemented by `-``I ``*`` `[`catanh`](http://en.cppreference.com/w/c/numeric/complex/catanh)`(``I``*``z``)`.\n\n### Notes\n\nInverse tangent (or arc tangent) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-∞i,-i) and (+i,+∞i) of the imaginary axis. The mathematical definition of the principal value of inverse tangent is atan z = -\n\n1/2 i \\[ln(1 - iz) - ln (1 + iz\\]\n\n### Example\n\n```\n#include <stdio.h>\n#include <float.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = catan(2*I);\n    printf(\"catan(+0+2i) = %f%+fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = catan(-conj(2*I)); // or CMPLX(-0.0, 2)\n    printf(\"catan(-0+2i) (the other side of the cut) = %f%+fi\\n\", creal(z2), cimag(z2));\n \n    double complex z3 = 2*catan(2*I*DBL_MAX); // or CMPLX(0, INFINITY)\n    printf(\"2*catan(+0+i*Inf) = %f%+fi\\n\", creal(z3), cimag(z3));\n}\n```\n\nOutput:\n\n```\ncatan(+0+2i) = 1.570796+0.549306i\ncatan(-0+2i) (the other side of the cut) = -1.570796+0.549306i\n2*catan(+0+i*Inf) = 3.141593+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.3 The catan functions (p: 191)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.3 The catan functions (p: 173)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/catan](https://en.cppreference.com/w/c/numeric/complex/catan)"
- name: cbrt
  summary: If no errors occur, the cube root of arg (\(\small{\sqrt[3]{arg} }\)3√arg), is returned
  description: "# cbrt, cbrtf, cbrtl\n\n[TABLE]\n\n1-3) Computes the cube root of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `cbrtl` is called. Otherwise, if `arg` has integer type or the type `double`, `cbrt` is called. Otherwise, `cbrtf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the cube root of `arg` (\\\\\\small{\\sqrt\\[3\\]{arg} }\\\\3√arg), is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0 or ±∞, it is returned, unchanged\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\n`cbrt(arg)` is not equivalent to [`pow`](http://en.cppreference.com/w/c/numeric/math/pow)`(``arg, ``1.0``/``3``)` because the rational number \\\\\\small{\\frac1{3} }\\\\1/3 is typically not equal to `1.0/3` and `std::pow` cannot raise a negative base to a fractional exponent. Moreover, `cbrt(arg)` usually gives more accurate results than [`pow`](http://en.cppreference.com/w/c/numeric/math/pow)`(``arg, ``1.0``/``3``)` (see example).\n\n### Example\n\n```\n#include <stdio.h>\n#include <float.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"Normal use:\\n\"\n           \"cbrt(729)      = %f\\n\", cbrt(729));\n    printf(\"cbrt(-0.125)   = %f\\n\", cbrt(-0.125));\n    printf(\"Special values:\\n\"\n           \"cbrt(-0)       = %f\\n\", cbrt(-0.0));\n    printf(\"cbrt(+inf)     = %f\\n\", cbrt(INFINITY));\n    printf(\"Accuracy:\\n\"\n           \"cbrt(343)      = %.*f\\n\", DBL_DECIMAL_DIG, cbrt(343));\n    printf(\"pow(343,1.0/3) = %.*f\\n\", DBL_DECIMAL_DIG, pow(343, 1.0/3));\n}\n```\n\nPossible output:\n\n```\nNormal use:\ncbrt(729)      = 9.000000\ncbrt(-0.125)   = -0.500000\nSpecial values:\ncbrt(-0)       = -0.000000\ncbrt(+inf)     = inf\nAccuracy:\ncbrt(343)      = 7.00000000000000000\npow(343,1.0/3) = 6.99999999999999911\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.1 The cbrt functions (p: 180-181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.1 The cbrt functions (p: 381-)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.1 The cbrt functions (p: 247)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.1 The cbrt functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.1 The cbrt functions (p: 228)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.1 The cbrt functions (p: 460)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cbrt](https://en.cppreference.com/w/c/numeric/math/cbrt)"
- name: cbrtf
  summary: If no errors occur, the cube root of arg (\(\small{\sqrt[3]{arg} }\)3√arg), is returned
  description: "# cbrt, cbrtf, cbrtl\n\n[TABLE]\n\n1-3) Computes the cube root of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `cbrtl` is called. Otherwise, if `arg` has integer type or the type `double`, `cbrt` is called. Otherwise, `cbrtf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the cube root of `arg` (\\\\\\small{\\sqrt\\[3\\]{arg} }\\\\3√arg), is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0 or ±∞, it is returned, unchanged\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\n`cbrt(arg)` is not equivalent to [`pow`](http://en.cppreference.com/w/c/numeric/math/pow)`(``arg, ``1.0``/``3``)` because the rational number \\\\\\small{\\frac1{3} }\\\\1/3 is typically not equal to `1.0/3` and `std::pow` cannot raise a negative base to a fractional exponent. Moreover, `cbrt(arg)` usually gives more accurate results than [`pow`](http://en.cppreference.com/w/c/numeric/math/pow)`(``arg, ``1.0``/``3``)` (see example).\n\n### Example\n\n```\n#include <stdio.h>\n#include <float.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"Normal use:\\n\"\n           \"cbrt(729)      = %f\\n\", cbrt(729));\n    printf(\"cbrt(-0.125)   = %f\\n\", cbrt(-0.125));\n    printf(\"Special values:\\n\"\n           \"cbrt(-0)       = %f\\n\", cbrt(-0.0));\n    printf(\"cbrt(+inf)     = %f\\n\", cbrt(INFINITY));\n    printf(\"Accuracy:\\n\"\n           \"cbrt(343)      = %.*f\\n\", DBL_DECIMAL_DIG, cbrt(343));\n    printf(\"pow(343,1.0/3) = %.*f\\n\", DBL_DECIMAL_DIG, pow(343, 1.0/3));\n}\n```\n\nPossible output:\n\n```\nNormal use:\ncbrt(729)      = 9.000000\ncbrt(-0.125)   = -0.500000\nSpecial values:\ncbrt(-0)       = -0.000000\ncbrt(+inf)     = inf\nAccuracy:\ncbrt(343)      = 7.00000000000000000\npow(343,1.0/3) = 6.99999999999999911\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.1 The cbrt functions (p: 180-181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.1 The cbrt functions (p: 381-)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.1 The cbrt functions (p: 247)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.1 The cbrt functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.1 The cbrt functions (p: 228)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.1 The cbrt functions (p: 460)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cbrt](https://en.cppreference.com/w/c/numeric/math/cbrt)"
- name: cbrtl
  summary: If no errors occur, the cube root of arg (\(\small{\sqrt[3]{arg} }\)3√arg), is returned
  description: "# cbrt, cbrtf, cbrtl\n\n[TABLE]\n\n1-3) Computes the cube root of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `cbrtl` is called. Otherwise, if `arg` has integer type or the type `double`, `cbrt` is called. Otherwise, `cbrtf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the cube root of `arg` (\\\\\\small{\\sqrt\\[3\\]{arg} }\\\\3√arg), is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0 or ±∞, it is returned, unchanged\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\n`cbrt(arg)` is not equivalent to [`pow`](http://en.cppreference.com/w/c/numeric/math/pow)`(``arg, ``1.0``/``3``)` because the rational number \\\\\\small{\\frac1{3} }\\\\1/3 is typically not equal to `1.0/3` and `std::pow` cannot raise a negative base to a fractional exponent. Moreover, `cbrt(arg)` usually gives more accurate results than [`pow`](http://en.cppreference.com/w/c/numeric/math/pow)`(``arg, ``1.0``/``3``)` (see example).\n\n### Example\n\n```\n#include <stdio.h>\n#include <float.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"Normal use:\\n\"\n           \"cbrt(729)      = %f\\n\", cbrt(729));\n    printf(\"cbrt(-0.125)   = %f\\n\", cbrt(-0.125));\n    printf(\"Special values:\\n\"\n           \"cbrt(-0)       = %f\\n\", cbrt(-0.0));\n    printf(\"cbrt(+inf)     = %f\\n\", cbrt(INFINITY));\n    printf(\"Accuracy:\\n\"\n           \"cbrt(343)      = %.*f\\n\", DBL_DECIMAL_DIG, cbrt(343));\n    printf(\"pow(343,1.0/3) = %.*f\\n\", DBL_DECIMAL_DIG, pow(343, 1.0/3));\n}\n```\n\nPossible output:\n\n```\nNormal use:\ncbrt(729)      = 9.000000\ncbrt(-0.125)   = -0.500000\nSpecial values:\ncbrt(-0)       = -0.000000\ncbrt(+inf)     = inf\nAccuracy:\ncbrt(343)      = 7.00000000000000000\npow(343,1.0/3) = 6.99999999999999911\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.1 The cbrt functions (p: 180-181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.1 The cbrt functions (p: 381-)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.1 The cbrt functions (p: 247)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.1 The cbrt functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.1 The cbrt functions (p: 228)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.1 The cbrt functions (p: 460)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cbrt](https://en.cppreference.com/w/c/numeric/math/cbrt)"
- name: ccos
  summary: If no errors occur, the complex cosine of z is returned
  description: "# ccosf, ccos, ccosl\n\n[TABLE]\n\n1-3) Computes the complex cosine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccosl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccos` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccosf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`cosf`, [`cos`](http://en.cppreference.com/w/c/numeric/math/cos), `cosl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`cosh`](../math/cosh \"c/numeric/math/cosh\"), implementing the formula cos(iy) = cosh(y), and the return type is real.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex cosine of `z` is returned.\n\nErrors and special cases are handled as if the operation is implemented by [`ccosh`](http://en.cppreference.com/w/c/numeric/complex/ccosh)`(``I``*``z``)`.\n\n### Notes\n\nThe cosine is an entire function on the complex plane, and has no branch cuts. Mathematical definition of the cosine is cos z =\n\neiz+e-iz/2\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ccos(1);  // behaves like real cosine along the real line\n    printf(\"cos(1+0i) = %f%+fi ( cos(1)=%f)\\n\", creal(z), cimag(z), cos(1));\n \n    double complex z2 = ccos(I); // behaves like real cosh along the imaginary line\n    printf(\"cos(0+1i) = %f%+fi (cosh(1)=%f)\\n\", creal(z2), cimag(z2), cosh(1));\n}\n```\n\nOutput:\n\n```\ncos(1+0i) = 0.540302-0.000000i ( cos(1)=0.540302)\ncos(0+1i) = 1.543081-0.000000i (cosh(1)=1.543081)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.4 The ccos functions (p: 191)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.4 The ccos functions (p: 173)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ccos](https://en.cppreference.com/w/c/numeric/complex/ccos)"
- name: ccosf
  summary: If no errors occur, the complex cosine of z is returned
  description: "# ccosf, ccos, ccosl\n\n[TABLE]\n\n1-3) Computes the complex cosine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccosl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccos` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccosf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`cosf`, [`cos`](http://en.cppreference.com/w/c/numeric/math/cos), `cosl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`cosh`](../math/cosh \"c/numeric/math/cosh\"), implementing the formula cos(iy) = cosh(y), and the return type is real.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex cosine of `z` is returned.\n\nErrors and special cases are handled as if the operation is implemented by [`ccosh`](http://en.cppreference.com/w/c/numeric/complex/ccosh)`(``I``*``z``)`.\n\n### Notes\n\nThe cosine is an entire function on the complex plane, and has no branch cuts. Mathematical definition of the cosine is cos z =\n\neiz+e-iz/2\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ccos(1);  // behaves like real cosine along the real line\n    printf(\"cos(1+0i) = %f%+fi ( cos(1)=%f)\\n\", creal(z), cimag(z), cos(1));\n \n    double complex z2 = ccos(I); // behaves like real cosh along the imaginary line\n    printf(\"cos(0+1i) = %f%+fi (cosh(1)=%f)\\n\", creal(z2), cimag(z2), cosh(1));\n}\n```\n\nOutput:\n\n```\ncos(1+0i) = 0.540302-0.000000i ( cos(1)=0.540302)\ncos(0+1i) = 1.543081-0.000000i (cosh(1)=1.543081)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.4 The ccos functions (p: 191)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.4 The ccos functions (p: 173)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ccos](https://en.cppreference.com/w/c/numeric/complex/ccos)"
- name: ccosh
  summary: If no errors occur, complex hyperbolic cosine of z is returned
  description: "# ccoshf, ccosh, ccoshl\n\n[TABLE]\n\n1-3) Computes the complex hyperbolic cosine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccoshl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccosh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccoshf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`coshf`, [`cosh`](http://en.cppreference.com/w/c/numeric/math/cosh), `coshl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`cos`](../math/cos \"c/numeric/math/cos\"), implementing the formula cosh(iy) = cos(y), and the return type is real.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex hyperbolic cosine of `z` is returned\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `ccosh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``ccosh``(``z``)``)`\n- `ccosh(z) == ccosh(-z)`\n- If `z` is `+0+0i`, the result is `1+0i`\n- If `z` is `+0+∞i`, the result is `NaN±0i` (the sign of the imaginary part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+0+NaNi`, the result is `NaN±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `x+∞i` (for any finite non-zero x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+NaNi` (for any finite non-zero x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+0i`, the result is `+∞+0i`\n- If `z` is `+∞+yi` (for any finite non-zero y), the result is `+∞cis(y)`\n- If `z` is `+∞+∞i`, the result is `±∞+NaNi` (the sign of the real part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+∞+NaN`, the result is `+∞+NaN`\n- If `z` is `NaN+0i`, the result is `NaN±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `NaN+yi` (for any finite non-zero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\nwhere cis(y) is cos(y) + i sin(y)\n\n### Notes\n\nMathematical definition of hyperbolic cosine is cosh z = ez+e-z/2\n\nHyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2πi\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ccosh(1);  // behaves like real cosh along the real line\n    printf(\"cosh(1+0i) = %f%+fi (cosh(1)=%f)\\n\", creal(z), cimag(z), cosh(1));\n \n    double complex z2 = ccosh(I); // behaves like real cosine along the imaginary line\n    printf(\"cosh(0+1i) = %f%+fi ( cos(1)=%f)\\n\", creal(z2), cimag(z2), cos(1));\n}\n```\n\nOutput:\n\n```\ncosh(1+0i) = 1.543081+0.000000i (cosh(1)=1.543081)\ncosh(0+1i) = 0.540302+0.000000i ( cos(1)=0.540302)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.4 The ccosh functions (p: 193)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.4 The ccosh functions (p: 541)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.4 The ccosh functions (p: 175)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.4 The ccosh functions (p: 476)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ccosh](https://en.cppreference.com/w/c/numeric/complex/ccosh)"
- name: ccoshf
  summary: If no errors occur, complex hyperbolic cosine of z is returned
  description: "# ccoshf, ccosh, ccoshl\n\n[TABLE]\n\n1-3) Computes the complex hyperbolic cosine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccoshl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccosh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccoshf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`coshf`, [`cosh`](http://en.cppreference.com/w/c/numeric/math/cosh), `coshl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`cos`](../math/cos \"c/numeric/math/cos\"), implementing the formula cosh(iy) = cos(y), and the return type is real.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex hyperbolic cosine of `z` is returned\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `ccosh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``ccosh``(``z``)``)`\n- `ccosh(z) == ccosh(-z)`\n- If `z` is `+0+0i`, the result is `1+0i`\n- If `z` is `+0+∞i`, the result is `NaN±0i` (the sign of the imaginary part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+0+NaNi`, the result is `NaN±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `x+∞i` (for any finite non-zero x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+NaNi` (for any finite non-zero x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+0i`, the result is `+∞+0i`\n- If `z` is `+∞+yi` (for any finite non-zero y), the result is `+∞cis(y)`\n- If `z` is `+∞+∞i`, the result is `±∞+NaNi` (the sign of the real part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+∞+NaN`, the result is `+∞+NaN`\n- If `z` is `NaN+0i`, the result is `NaN±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `NaN+yi` (for any finite non-zero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\nwhere cis(y) is cos(y) + i sin(y)\n\n### Notes\n\nMathematical definition of hyperbolic cosine is cosh z = ez+e-z/2\n\nHyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2πi\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ccosh(1);  // behaves like real cosh along the real line\n    printf(\"cosh(1+0i) = %f%+fi (cosh(1)=%f)\\n\", creal(z), cimag(z), cosh(1));\n \n    double complex z2 = ccosh(I); // behaves like real cosine along the imaginary line\n    printf(\"cosh(0+1i) = %f%+fi ( cos(1)=%f)\\n\", creal(z2), cimag(z2), cos(1));\n}\n```\n\nOutput:\n\n```\ncosh(1+0i) = 1.543081+0.000000i (cosh(1)=1.543081)\ncosh(0+1i) = 0.540302+0.000000i ( cos(1)=0.540302)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.4 The ccosh functions (p: 193)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.4 The ccosh functions (p: 541)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.4 The ccosh functions (p: 175)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.4 The ccosh functions (p: 476)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ccosh](https://en.cppreference.com/w/c/numeric/complex/ccosh)"
- name: ccoshl
  summary: If no errors occur, complex hyperbolic cosine of z is returned
  description: "# ccoshf, ccosh, ccoshl\n\n[TABLE]\n\n1-3) Computes the complex hyperbolic cosine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccoshl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccosh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccoshf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`coshf`, [`cosh`](http://en.cppreference.com/w/c/numeric/math/cosh), `coshl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`cos`](../math/cos \"c/numeric/math/cos\"), implementing the formula cosh(iy) = cos(y), and the return type is real.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex hyperbolic cosine of `z` is returned\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `ccosh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``ccosh``(``z``)``)`\n- `ccosh(z) == ccosh(-z)`\n- If `z` is `+0+0i`, the result is `1+0i`\n- If `z` is `+0+∞i`, the result is `NaN±0i` (the sign of the imaginary part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+0+NaNi`, the result is `NaN±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `x+∞i` (for any finite non-zero x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+NaNi` (for any finite non-zero x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+0i`, the result is `+∞+0i`\n- If `z` is `+∞+yi` (for any finite non-zero y), the result is `+∞cis(y)`\n- If `z` is `+∞+∞i`, the result is `±∞+NaNi` (the sign of the real part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+∞+NaN`, the result is `+∞+NaN`\n- If `z` is `NaN+0i`, the result is `NaN±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `NaN+yi` (for any finite non-zero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\nwhere cis(y) is cos(y) + i sin(y)\n\n### Notes\n\nMathematical definition of hyperbolic cosine is cosh z = ez+e-z/2\n\nHyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2πi\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ccosh(1);  // behaves like real cosh along the real line\n    printf(\"cosh(1+0i) = %f%+fi (cosh(1)=%f)\\n\", creal(z), cimag(z), cosh(1));\n \n    double complex z2 = ccosh(I); // behaves like real cosine along the imaginary line\n    printf(\"cosh(0+1i) = %f%+fi ( cos(1)=%f)\\n\", creal(z2), cimag(z2), cos(1));\n}\n```\n\nOutput:\n\n```\ncosh(1+0i) = 1.543081+0.000000i (cosh(1)=1.543081)\ncosh(0+1i) = 0.540302+0.000000i ( cos(1)=0.540302)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.4 The ccosh functions (p: 193)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.4 The ccosh functions (p: 541)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.4 The ccosh functions (p: 175)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.4 The ccosh functions (p: 476)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ccosh](https://en.cppreference.com/w/c/numeric/complex/ccosh)"
- name: ccosl
  summary: If no errors occur, the complex cosine of z is returned
  description: "# ccosf, ccos, ccosl\n\n[TABLE]\n\n1-3) Computes the complex cosine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccosl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccos` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ccosf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`cosf`, [`cos`](http://en.cppreference.com/w/c/numeric/math/cos), `cosl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`cosh`](../math/cosh \"c/numeric/math/cosh\"), implementing the formula cos(iy) = cosh(y), and the return type is real.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex cosine of `z` is returned.\n\nErrors and special cases are handled as if the operation is implemented by [`ccosh`](http://en.cppreference.com/w/c/numeric/complex/ccosh)`(``I``*``z``)`.\n\n### Notes\n\nThe cosine is an entire function on the complex plane, and has no branch cuts. Mathematical definition of the cosine is cos z =\n\neiz+e-iz/2\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ccos(1);  // behaves like real cosine along the real line\n    printf(\"cos(1+0i) = %f%+fi ( cos(1)=%f)\\n\", creal(z), cimag(z), cos(1));\n \n    double complex z2 = ccos(I); // behaves like real cosh along the imaginary line\n    printf(\"cos(0+1i) = %f%+fi (cosh(1)=%f)\\n\", creal(z2), cimag(z2), cosh(1));\n}\n```\n\nOutput:\n\n```\ncos(1+0i) = 0.540302-0.000000i ( cos(1)=0.540302)\ncos(0+1i) = 1.543081-0.000000i (cosh(1)=1.543081)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.4 The ccos functions (p: 191)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.4 The ccos functions (p: 173)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ccos](https://en.cppreference.com/w/c/numeric/complex/ccos)"
- name: ceil
  summary: If no errors occur, the smallest integer value not less than arg, that is ⌈arg⌉, is returned
  description: "# ceil, ceilf, ceill\n\n[TABLE]\n\n1-3) Computes the smallest integer value not less than `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `ceill` is called. Otherwise, if `arg` has integer type or the type `double`, `ceil` is called. Otherwise, `ceilf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the smallest integer value not less than `arg`, that is ⌈arg⌉, is returned.\n\nReturn value\n\nArgument\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If arg is NaN, NaN is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nThis function (for double argument) behaves as if (except for the freedom to not raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")) implemented by\n\n```\n#include <math.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\ndouble ceil(double x)\n{\n    double result;\n    int save_round = fegetround();\n    fesetround(FE_UPWARD);\n    result = rint(x); // or nearbyint \n    fesetround(save_round);\n    return result;\n}\n```\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"ceil(+2.4) = %+.1f\\n\", ceil(2.4));\n    printf(\"ceil(-2.4) = %+.1f\\n\", ceil(-2.4));\n    printf(\"ceil(-0.0) = %+.1f\\n\", ceil(-0.0));\n    printf(\"ceil(-Inf) = %+f\\n\",   ceil(-INFINITY));\n}\n```\n\nPossible output:\n\n```\nceil(+2.4) = +3.0\nceil(-2.4) = -2.0\nceil(-0.0) = -0.0\nceil(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.1 The ceil functions (p: 251)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.1 The ceil functions (p: 526)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.1 The ceil functions (p: 231-232)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.1 The ceil functions (p: 462-463)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.1 The ceil function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/ceil](https://en.cppreference.com/w/c/numeric/math/ceil)"
- name: ceilf
  summary: If no errors occur, the smallest integer value not less than arg, that is ⌈arg⌉, is returned
  description: "# ceil, ceilf, ceill\n\n[TABLE]\n\n1-3) Computes the smallest integer value not less than `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `ceill` is called. Otherwise, if `arg` has integer type or the type `double`, `ceil` is called. Otherwise, `ceilf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the smallest integer value not less than `arg`, that is ⌈arg⌉, is returned.\n\nReturn value\n\nArgument\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If arg is NaN, NaN is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nThis function (for double argument) behaves as if (except for the freedom to not raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")) implemented by\n\n```\n#include <math.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\ndouble ceil(double x)\n{\n    double result;\n    int save_round = fegetround();\n    fesetround(FE_UPWARD);\n    result = rint(x); // or nearbyint \n    fesetround(save_round);\n    return result;\n}\n```\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"ceil(+2.4) = %+.1f\\n\", ceil(2.4));\n    printf(\"ceil(-2.4) = %+.1f\\n\", ceil(-2.4));\n    printf(\"ceil(-0.0) = %+.1f\\n\", ceil(-0.0));\n    printf(\"ceil(-Inf) = %+f\\n\",   ceil(-INFINITY));\n}\n```\n\nPossible output:\n\n```\nceil(+2.4) = +3.0\nceil(-2.4) = -2.0\nceil(-0.0) = -0.0\nceil(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.1 The ceil functions (p: 251)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.1 The ceil functions (p: 526)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.1 The ceil functions (p: 231-232)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.1 The ceil functions (p: 462-463)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.1 The ceil function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/ceil](https://en.cppreference.com/w/c/numeric/math/ceil)"
- name: ceill
  summary: If no errors occur, the smallest integer value not less than arg, that is ⌈arg⌉, is returned
  description: "# ceil, ceilf, ceill\n\n[TABLE]\n\n1-3) Computes the smallest integer value not less than `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `ceill` is called. Otherwise, if `arg` has integer type or the type `double`, `ceil` is called. Otherwise, `ceilf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the smallest integer value not less than `arg`, that is ⌈arg⌉, is returned.\n\nReturn value\n\nArgument\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If arg is NaN, NaN is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nThis function (for double argument) behaves as if (except for the freedom to not raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")) implemented by\n\n```\n#include <math.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\ndouble ceil(double x)\n{\n    double result;\n    int save_round = fegetround();\n    fesetround(FE_UPWARD);\n    result = rint(x); // or nearbyint \n    fesetround(save_round);\n    return result;\n}\n```\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"ceil(+2.4) = %+.1f\\n\", ceil(2.4));\n    printf(\"ceil(-2.4) = %+.1f\\n\", ceil(-2.4));\n    printf(\"ceil(-0.0) = %+.1f\\n\", ceil(-0.0));\n    printf(\"ceil(-Inf) = %+f\\n\",   ceil(-INFINITY));\n}\n```\n\nPossible output:\n\n```\nceil(+2.4) = +3.0\nceil(-2.4) = -2.0\nceil(-0.0) = -0.0\nceil(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.1 The ceil functions (p: 251)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.1 The ceil functions (p: 526)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.1 The ceil functions (p: 231-232)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.1 The ceil functions (p: 462-463)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.1 The ceil function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/ceil](https://en.cppreference.com/w/c/numeric/math/ceil)"
- name: cexp
  summary: If no errors occur, e raised to the power of z, \(\small e^z\)ez is returned
  description: "# cexpf, cexp, cexpl\n\n[TABLE]\n\n1-3) Computes the complex base-*e* exponential of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cexpl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cexp` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cexpf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`expf`, [`exp`](http://en.cppreference.com/w/c/numeric/math/exp), `expl`). If `z` is imaginary, the corresponding complex argument version is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, *e* raised to the power of `z`, \\\\\\small e^z\\\\e^(z) is returned.\n\n### Error handling and special values\n\nErrors are reported consistent with [`math_errhandling`](../math/math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `cexp``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``cexp``(``z``)``)`\n- If `z` is `±0+0i`, the result is `1+0i`\n- If `z` is `x+∞i` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `z` is `x+NaNi` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `+∞+0i`, the result is `+∞+0i`\n- If `z` is `-∞+yi` (for any finite y), the result is `+0cis(y)`\n- If `z` is `+∞+yi` (for any finite nonzero y), the result is `+∞cis(y)`\n- If `z` is `-∞+∞i`, the result is `±0±0i` (signs are unspecified)\n- If `z` is `+∞+∞i`, the result is `±∞+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised (the sign of the real part is unspecified)\n- If `z` is `-∞+NaNi`, the result is `±0±0i` (signs are unspecified)\n- If `z` is `+∞+NaNi`, the result is `±∞+NaNi` (the sign of the real part is unspecified)\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any nonzero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\nwhere \\\\\\small{\\rm cis}(y)\\\\cis(y) is \\\\\\small \\cos(y)+{\\rm i}\\sin(y)\\\\cos(y) + i sin(y)\n\n### Notes\n\nThe complex exponential function \\\\\\small e^z\\\\e^(z) for \\\\\\small z = x + {\\rm i}y\\\\z = x+iy equals \\\\\\small e^x {\\rm cis}(y)\\\\e^(x) cis(y), or, \\\\\\small e^x (\\cos(y)+{\\rm i}\\sin(y))\\\\e^(x) (cos(y) + i sin(y))\n\nThe exponential function is an *entire function* in the complex plane and has no branch cuts.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double PI = acos(-1);\n    double complex z = cexp(I * PI); // Euler's formula\n    printf(\"exp(i*pi) = %.1f%+.1fi\\n\", creal(z), cimag(z));\n \n}\n```\n\nOutput:\n\n```\nexp(i*pi) = -1.0+0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.7.1 The cexp functions (p: 194)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.3.1 The cexp functions (p: 543)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.7.1 The cexp functions (p: 176)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.3.1 The cexp functions (p: 478)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cexp](https://en.cppreference.com/w/c/numeric/complex/cexp)"
- name: cexpf
  summary: If no errors occur, e raised to the power of z, \(\small e^z\)ez is returned
  description: "# cexpf, cexp, cexpl\n\n[TABLE]\n\n1-3) Computes the complex base-*e* exponential of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cexpl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cexp` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cexpf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`expf`, [`exp`](http://en.cppreference.com/w/c/numeric/math/exp), `expl`). If `z` is imaginary, the corresponding complex argument version is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, *e* raised to the power of `z`, \\\\\\small e^z\\\\e^(z) is returned.\n\n### Error handling and special values\n\nErrors are reported consistent with [`math_errhandling`](../math/math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `cexp``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``cexp``(``z``)``)`\n- If `z` is `±0+0i`, the result is `1+0i`\n- If `z` is `x+∞i` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `z` is `x+NaNi` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `+∞+0i`, the result is `+∞+0i`\n- If `z` is `-∞+yi` (for any finite y), the result is `+0cis(y)`\n- If `z` is `+∞+yi` (for any finite nonzero y), the result is `+∞cis(y)`\n- If `z` is `-∞+∞i`, the result is `±0±0i` (signs are unspecified)\n- If `z` is `+∞+∞i`, the result is `±∞+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised (the sign of the real part is unspecified)\n- If `z` is `-∞+NaNi`, the result is `±0±0i` (signs are unspecified)\n- If `z` is `+∞+NaNi`, the result is `±∞+NaNi` (the sign of the real part is unspecified)\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any nonzero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\nwhere \\\\\\small{\\rm cis}(y)\\\\cis(y) is \\\\\\small \\cos(y)+{\\rm i}\\sin(y)\\\\cos(y) + i sin(y)\n\n### Notes\n\nThe complex exponential function \\\\\\small e^z\\\\e^(z) for \\\\\\small z = x + {\\rm i}y\\\\z = x+iy equals \\\\\\small e^x {\\rm cis}(y)\\\\e^(x) cis(y), or, \\\\\\small e^x (\\cos(y)+{\\rm i}\\sin(y))\\\\e^(x) (cos(y) + i sin(y))\n\nThe exponential function is an *entire function* in the complex plane and has no branch cuts.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double PI = acos(-1);\n    double complex z = cexp(I * PI); // Euler's formula\n    printf(\"exp(i*pi) = %.1f%+.1fi\\n\", creal(z), cimag(z));\n \n}\n```\n\nOutput:\n\n```\nexp(i*pi) = -1.0+0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.7.1 The cexp functions (p: 194)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.3.1 The cexp functions (p: 543)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.7.1 The cexp functions (p: 176)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.3.1 The cexp functions (p: 478)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cexp](https://en.cppreference.com/w/c/numeric/complex/cexp)"
- name: cexpl
  summary: If no errors occur, e raised to the power of z, \(\small e^z\)ez is returned
  description: "# cexpf, cexp, cexpl\n\n[TABLE]\n\n1-3) Computes the complex base-*e* exponential of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cexpl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cexp` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cexpf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`expf`, [`exp`](http://en.cppreference.com/w/c/numeric/math/exp), `expl`). If `z` is imaginary, the corresponding complex argument version is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, *e* raised to the power of `z`, \\\\\\small e^z\\\\e^(z) is returned.\n\n### Error handling and special values\n\nErrors are reported consistent with [`math_errhandling`](../math/math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `cexp``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``cexp``(``z``)``)`\n- If `z` is `±0+0i`, the result is `1+0i`\n- If `z` is `x+∞i` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `z` is `x+NaNi` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised.\n- If `z` is `+∞+0i`, the result is `+∞+0i`\n- If `z` is `-∞+yi` (for any finite y), the result is `+0cis(y)`\n- If `z` is `+∞+yi` (for any finite nonzero y), the result is `+∞cis(y)`\n- If `z` is `-∞+∞i`, the result is `±0±0i` (signs are unspecified)\n- If `z` is `+∞+∞i`, the result is `±∞+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised (the sign of the real part is unspecified)\n- If `z` is `-∞+NaNi`, the result is `±0±0i` (signs are unspecified)\n- If `z` is `+∞+NaNi`, the result is `±∞+NaNi` (the sign of the real part is unspecified)\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any nonzero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\nwhere \\\\\\small{\\rm cis}(y)\\\\cis(y) is \\\\\\small \\cos(y)+{\\rm i}\\sin(y)\\\\cos(y) + i sin(y)\n\n### Notes\n\nThe complex exponential function \\\\\\small e^z\\\\e^(z) for \\\\\\small z = x + {\\rm i}y\\\\z = x+iy equals \\\\\\small e^x {\\rm cis}(y)\\\\e^(x) cis(y), or, \\\\\\small e^x (\\cos(y)+{\\rm i}\\sin(y))\\\\e^(x) (cos(y) + i sin(y))\n\nThe exponential function is an *entire function* in the complex plane and has no branch cuts.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double PI = acos(-1);\n    double complex z = cexp(I * PI); // Euler's formula\n    printf(\"exp(i*pi) = %.1f%+.1fi\\n\", creal(z), cimag(z));\n \n}\n```\n\nOutput:\n\n```\nexp(i*pi) = -1.0+0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.7.1 The cexp functions (p: 194)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.3.1 The cexp functions (p: 543)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.7.1 The cexp functions (p: 176)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.3.1 The cexp functions (p: 478)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cexp](https://en.cppreference.com/w/c/numeric/complex/cexp)"
- name: char
  summary: ''
  description: "# C keywords: char\n\n### Usage\n\n- *type specifier* for the [character types](../language/arithmetic_types#Character_types \"c/language/arithmetic types\") (`char`, `signed char`, and `unsigned char`).\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/char](https://en.cppreference.com/w/c/keyword/char)"
- name: char16_t
  summary: char16_t is an unsigned integer type used for 16-bit wide characters and is the same type as uint_least16_t
  description: "# char16_t\n\n[TABLE]\n\n`char16_t` is an unsigned integer type used for 16-bit wide characters and is the same type as [`uint_least16_t`](http://en.cppreference.com/w/c/types/integer).\n\n### Notes\n\nOn any given platform, by the definition of [`uint_least16_t`](http://en.cppreference.com/w/c/types/integer), the width of type `char16_t` can be greater than 16 bits, but the actual values stored in an object of type `char16_t` will always have a width of 16 bits.\n\n### Example\n\n```\n#include <stdio.h>\n#include <uchar.h>\n \nint main(void)\n{\n    const char16_t wcs[] = u\"zß水🍌\"; // or \"z\\u00df\\u6c34\\U0001f34c\"\n    const size_t wcs_sz = sizeof wcs / sizeof *wcs;\n    printf(\"%zu UTF-16 code units: [ \", wcs_sz);\n    for (size_t n = 0; n < wcs_sz; ++n)\n        printf(\"%#x \", wcs[n]);\n    printf(\"]\\n\");\n}\n```\n\nPossible output:\n\n```\n6 UTF-16 code units: [ 0x7a 0xdf 0x6c34 0xd83c 0xdf4c 0 ]\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.28 Unicode utilities \\<uchar.h\\> (p: 292)\n  - 7.20.1.2 Minimum-width integer types (p: 212-213)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.28 Unicode utilities \\<uchar.h\\> (p: 398)\n  - 7.20.1.2 Minimum-width integer types (p: 290)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.18.1.2 Minimum-width integer types (p: 256)\n\n### See also\n\n|                                                                                                                  |     |\n|------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/types \"cpp/language/types\") for Fundamental types |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/char16_t](https://en.cppreference.com/w/c/string/multibyte/char16_t)"
- name: char32_t
  summary: char32_t is an unsigned integer type used for 32-bit wide characters and is the same type as uint_least32_t
  description: "# char32_t\n\n[TABLE]\n\n`char32_t` is an unsigned integer type used for 32-bit wide characters and is the same type as [`uint_least32_t`](http://en.cppreference.com/w/c/types/integer).\n\n### Notes\n\nOn any given platform, by the definition of [`uint_least32_t`](http://en.cppreference.com/w/c/types/integer), the width of type `char32_t` can be greater than 32 bits, but the actual values stored in an object of type `char32_t` will always have a width of 32 bits.\n\n### Example\n\n```\n#include <stdio.h>\n#include <uchar.h>\n \nint main(void)\n{\n    const char32_t wc[] = U\"zß水🍌\"; // or \"z\\u00df\\u6c34\\U0001f34c\"\n    const size_t wc_sz = sizeof wc / sizeof *wc;\n    printf(\"%zu UTF-32 code units: [ \", wc_sz);\n    for (size_t n = 0; n < wc_sz; ++n)\n        printf(\"%#x \", wc[n]);\n    printf(\"]\\n\");\n}\n```\n\nPossible output:\n\n```\n5 UTF-32 code units: [ 0x7a 0xdf 0x6c34 0x1f34c 0 ]\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.28 Unicode utilities \\<uchar.h\\> (p: 292)\n  - 7.20.1.2 Minimum-width integer types (p: 212-213)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.28 Unicode utilities \\<uchar.h\\> (p: 398)\n  - 7.20.1.2 Minimum-width integer types (p: 290)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.18.1.2 Minimum-width integer types (p: 256)\n\n### See also\n\n|                                                                                                                  |     |\n|------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/types \"cpp/language/types\") for Fundamental types |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/char32_t](https://en.cppreference.com/w/c/string/multibyte/char32_t)"
- name: char8_t
  summary: char8_t is an unsigned integer type used for UTF-8 and is the same type as unsigned char
  description: "# char8_t\n\n[TABLE]\n\n`char8_t` is an unsigned integer type used for UTF-8 and is the same type as `unsigned char`.\n\n### Example\n\n```\n#include <uchar.h>\n#include <stdio.h>\n \nint main(void)\n{\n    char8_t str[] = u8\"zß水🍌\"; // or \"z\\u00df\\u6c34\\U0001f34c\"\n    size_t str_sz = sizeof str; // sizeof *str == 1 by definition\n    printf(\"%zu UTF-8 code units: [ \", str_sz);\n    for (size_t n = 0; n < str_sz; ++n)\n        printf(\"%02X \", str[n]);\n    printf(\"]\\n\");\n}\n```\n\nPossible output:\n\n```\n11 UTF-8 code units: [ 7A C3 9F E6 B0 B4 F0 9F 8D 8C 00 ]\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30 Unicode utilities \\<uchar.h\\> (p: 410)\n\n### See also\n\n|                                                                                                                    |     |\n|--------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/types \"cpp/language/types\") for `Fundamental types` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/char8_t](https://en.cppreference.com/w/c/string/multibyte/char8_t)"
- name: Character constant
  summary: where
  description: "# Character constant\n\n### Syntax\n\n|                         |       |                             |\n|-------------------------|-------|-----------------------------|\n| `'`c-char `'`           | \\(1\\) |                             |\n| `u8'`c-char `'`         | \\(2\\) | (since C23)                 |\n| `u'`c-char `'`          | \\(3\\) | (since C11)                 |\n| `U'`c-char `'`          | \\(4\\) | (since C11)                 |\n| `L'`c-char `'`          | \\(5\\) |                             |\n| `'`c-char-sequence `'`  | \\(6\\) |                             |\n| `L'`c-char-sequence `'` | \\(7\\) |                             |\n| `u'`c-char-sequence `'` | \\(8\\) | (since C11)(removed in C23) |\n| `U'`c-char-sequence `'` | \\(9\\) | (since C11)(removed in C23) |\n\nwhere\n\n- c-char is either\n  - a character from the basic source character set minus single-quote (`'`), backslash (`\\`), or the newline character.\n  - escape sequence: one of special character escapes `\\'` `\\\"` `\\?` `\\\\` `\\a` `\\b` `\\f` `\\n` `\\r` `\\t` `\\v`, hex escapes `\\x...` or octal escapes `\\...` as defined in [escape sequences](escape \"c/language/escape\").\n\n[TABLE]\n\n- c-char-sequence is a sequence of two or more c-chars.\n\n1) single-byte integer character constant, e.g. `'a'` or `'\\n'` or `'\\13'`. Such constant has type `int` and a value equal to the representation of c-char in the execution character set as a value of type `char` mapped to `int`. If c-char is not representable as a single byte in the execution character set, the value is implementation-defined.\n\n2) UTF-8 character constant, e.g. `u8'a'`. Such constant has type `char8_t` and the value equal to ISO 10646 code point value of c-char, provided that the code point value is representable with a single UTF-8 code unit (that is, c-char is in the range 0x0-0x7F, inclusive). If c-char is not representable with a single UTF-8 code unit, the program is ill-formed.\n\n|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| 3) 16-bit wide character constant, e.g. `u'貓'`, but not `u'🍌'` (`u'\\U0001f34c'`). Such constant has type `char16_t` and a value equal to the value of c-char in the 16-bit encoding produced by [`mbrtoc16`](../string/multibyte/mbrtoc16 \"c/string/multibyte/mbrtoc16\") (normally UTF-16). If c-char is not representable or maps to more than one 16-bit character, the value is implementation-defined. 4) 32-bit wide character constant, e.g. `U'貓'` or `U'🍌'`. Such constant has type `char32_t` and a value equal to the value of c-char in in the 32-bit encoding produced by [`mbrtoc32`](../string/multibyte/mbrtoc32 \"c/string/multibyte/mbrtoc32\") (normally UTF-32). If c-char is not representable or maps to more than one 32-bit character, the value is implementation-defined.                                                | (until C23) |\n| 3) UTF-16 character constant, e.g. `u'貓'`, but not `u'🍌'` (`u'\\U0001f34c'`). Such constant has type `char16_t` and the value equal to ISO 10646 code point value of c-char, provided that the code point value is representable with a single UTF-16 code unit (that is, c-char is in the range 0x0-0xD7FF or 0xE000-0xFFFF, inclusive). If c-char is not representable with a single UTF-16 code unit, the program is ill-formed. 4) UTF-32 character constant, e.g. `U'貓'` or `U'🍌'`. Such constant has type `char32_t` and the value equal to ISO 10646 code point value of c-char, provided that the code point value is representable with a single UTF-32 code unit (that is, c-char is in the range 0x0-0xD7FF or 0xE000-0x10FFFF, inclusive). If c-char is not representable with a single UTF-32 code unit, the program is ill-formed. | (since C23) |\n\n5) wide character constant, e.g. `L'β'` or `L'貓`. Such constant has type `wchar_t` and a value equal to the value of c-char in the execution wide character set (that is, the value that would be produced by [`mbtowc`](../string/multibyte/mbtowc \"c/string/multibyte/mbtowc\")). If c-char is not representable or maps to more than one wide character (e.g. a non-BMP value on Windows where `wchar_t` is 16-bit), the value is implementation-defined .\n\n6) multicharacter constant, e.g. `'AB'`, has type `int` and implementation-defined value.\n\n7) wide multicharacter constant, e.g. `L'AB'`, has type `wchar_t` and implementation-defined value.\n\n8) 16-bit multicharacter constant, e.g. `u'CD'`, has type `char16_t` and implementation-defined value.\n\n9) 32-bit multicharacter constant, e.g. `U'XY'`, has type `char32_t` and implementation-defined value.\n\n### Notes\n\nMulticharacter constants were inherited by C from the B programming language. Although not specified by the C standard, most compilers (MSVC is a notable exception) implement multicharacter constants as specified in B: the values of each char in the constant initialize successive bytes of the resulting integer, in big-endian zero-padded right-adjusted order, e.g. the value of `'\\1'` is `0x00000001` and the value of `'\\1\\2\\3\\4'` is `0x01020304`.\n\nIn C++, encodable ordinary character literals have type `char`, rather than `int`.\n\nUnlike [integer constants](integer_constant \"c/language/integer constant\"), a character constant may have a negative value if `char` is signed: on such implementations `'\\xFF'` is an `int` with the value `-1`.\n\nWhen used in a controlling expression of [` #if`](../preprocessor/conditional \"c/preprocessor/conditional\") or [` #elif`](../preprocessor/conditional \"c/preprocessor/conditional\"), character constants may be interpreted in terms of the source character set, the execution character set, or some other implementation-defined character set.\n\n16/32-bit multicharacter constants are not widely supported and removed in C23. Some common implementations (e.g. clang) do not accept them at all.\n\n### Example\n\n```\n#include <stddef.h>\n#include <stdio.h>\n#include <uchar.h>\n \nint main (void)\n{\n    printf(\"constant value     \\n\");\n    printf(\"-------- ----------\\n\");\n \n    // integer character constants,\n    int c1='a'; printf(\"'a':\\t %#010x\\n\", c1);\n    int c2='🍌'; printf(\"'🍌':\\t %#010x\\n\\n\", c2); // implementation-defined\n \n    // multicharacter constant\n    int c3='ab'; printf(\"'ab':\\t %#010x\\n\\n\", c3); // implementation-defined\n \n    // 16-bit wide character constants\n    char16_t uc1 = u'a'; printf(\"'a':\\t %#010x\\n\", (int)uc1);\n    char16_t uc2 = u'¢'; printf(\"'¢':\\t %#010x\\n\", (int)uc2);\n    char16_t uc3 = u'猫'; printf(\"'猫':\\t %#010x\\n\", (int)uc3);\n    // implementation-defined (🍌 maps to two 16-bit characters)\n    char16_t uc4 = u'🍌'; printf(\"'🍌':\\t %#010x\\n\\n\", (int)uc4);\n \n    // 32-bit wide character constants\n    char32_t Uc1 = U'a'; printf(\"'a':\\t %#010x\\n\", (int)Uc1);\n    char32_t Uc2 = U'¢'; printf(\"'¢':\\t %#010x\\n\", (int)Uc2);\n    char32_t Uc3 = U'猫'; printf(\"'猫':\\t %#010x\\n\", (int)Uc3);\n    char32_t Uc4 = U'🍌'; printf(\"'🍌':\\t %#010x\\n\\n\", (int)Uc4);\n \n    // wide character constants\n    wchar_t wc1 = L'a'; printf(\"'a':\\t %#010x\\n\", (int)wc1);\n    wchar_t wc2 = L'¢'; printf(\"'¢':\\t %#010x\\n\", (int)wc2);\n    wchar_t wc3 = L'猫'; printf(\"'猫':\\t %#010x\\n\", (int)wc3);\n    wchar_t wc4 = L'🍌'; printf(\"'🍌':\\t %#010x\\n\\n\", (int)wc4);\n}\n```\n\nPossible output:\n\n```\nconstant value     \n-------- ----------\n'a':         0x00000061\n'🍌':         0xf09f8d8c\n \n'ab':         0x00006162\n \n'a':         0x00000061\n'¢':         0x000000a2\n'猫':         0x0000732b\n'🍌':         0x0000df4c\n \n'a':         0x00000061\n'¢':         0x000000a2\n'猫':         0x0000732b\n'🍌':         0x0001f34c\n \n'a':         0x00000061\n'¢':         0x000000a2\n'猫':         0x0000732b\n'🍌':         0x0001f34c\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.4.4.4 Character constants (p: 48-50)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.4.4.4 Character constants (p: 67-70)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.4.4.4 Character constants (p: 59-61)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.3.4 Character constants\n\n### See also\n\n|                                                                                                                                          |     |\n|------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/character_literal \"cpp/language/character literal\") for Character literal |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/character_constant](https://en.cppreference.com/w/c/language/character_constant)"
- name: Character sets and encodings
  summary: 'The basic character set consists of the following 95 characters:'
  description: "# Character sets and encodings\n\n### Basic character set\n\nThe *basic character set* consists of the following 95 characters:\n\n[TABLE]\n\nUnlike C++, the U+000A LINE FEED (LF) character is not included in basic character set. Instead, there shall be some way of indicating the end of each line of text in the source file and the document treats such an end-of-line indicator as if it were a single new-line character.\n\nBasic character set is also known as *basic source character set*.\n\n### Basic execution character set\n\nThe *basic execution character set* contains all the members of the basic character set, plus the following characters:\n\n| Code unit | Character            |\n|-----------|----------------------|\n| U+0000    | Null                 |\n| U+0007    | Bell                 |\n| U+0008    | Backspace            |\n| U+000A    | Line feed (LF)       |\n| U+000D    | Carriage return (CR) |\n\nFor each basic execution character set, the values of the members shall be non-negative and distinct from one another. In both the source and execution basic character sets, the value of each character after 0 in the above list of decimal digits shall be one greater than the value of the previous. The U+0000 NULL character has the value 0.\n\nThe representation of each member of the basic execution character sets fit in a byte.\n\nIn C++, basic execution character set is also known as *basic literal character set* and *basic execution wide-character set*.\n\n### Literal encodings\n\nThe *literal encoding* is an implementation-defined mapping of the characters of the execution character set to the values in a [character constant](character_constant \"c/language/character constant\") or [string literal](string_literal \"c/language/string literal\") without encoding prefix. It supports a mapping from all the basic execution character set values into the implementation-defined encoding. It may contain multibyte character sequences.\n\n[TABLE]\n\nThe *wide literal encoding* is an implementation-defined mapping of the characters of the execution character set to the values in an `L`-prefixed character constant or string literal. It supports a mapping from all the basic execution character set values into the implementation-defined encoding. If an implementation does not define `__STDC_MB_MIGHT_NEQ_WC__`, the mapping produces values identical to the literal encoding for all the basic execution character set values. One or more values may map to one or more values of the extended execution character set.\n\n[TABLE]\n\n### See also\n\n|                                                                                                                                 |     |\n|---------------------------------------------------------------------------------------------------------------------------------|-----|\n| [ASCII chart](ascii \"c/language/ascii\")                                                                                         |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/charset \"cpp/language/charset\") for Character sets and encodings |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/charset](https://en.cppreference.com/w/c/language/charset)"
- name: cimag
  summary: The imaginary part of z
  description: "# cimagf, cimag, cimagl\n\n[TABLE]\n\n1-3) Returns the imaginary part of `z`.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `cimagl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `cimagf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `cimag` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe imaginary part of `z`.\n\nThis function is fully specified for all possible inputs and is not subject to any errors described in [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\n### Notes\n\nFor any complex variable `z`, `z ``==`` `[`creal`](http://en.cppreference.com/w/c/numeric/complex/creal)`(``z``)`` ``+`` I``*``cimag``(``z``)`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = 1.0 + 2.0*I;\n    printf(\"%f%+fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\n1.000000+2.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.2 The cimag functions (p: 197)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.2 The cimag functions (p: 178-179)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cimag](https://en.cppreference.com/w/c/numeric/complex/cimag)"
- name: cimagf
  summary: The imaginary part of z
  description: "# cimagf, cimag, cimagl\n\n[TABLE]\n\n1-3) Returns the imaginary part of `z`.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `cimagl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `cimagf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `cimag` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe imaginary part of `z`.\n\nThis function is fully specified for all possible inputs and is not subject to any errors described in [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\n### Notes\n\nFor any complex variable `z`, `z ``==`` `[`creal`](http://en.cppreference.com/w/c/numeric/complex/creal)`(``z``)`` ``+`` I``*``cimag``(``z``)`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = 1.0 + 2.0*I;\n    printf(\"%f%+fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\n1.000000+2.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.2 The cimag functions (p: 197)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.2 The cimag functions (p: 178-179)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cimag](https://en.cppreference.com/w/c/numeric/complex/cimag)"
- name: cimagl
  summary: The imaginary part of z
  description: "# cimagf, cimag, cimagl\n\n[TABLE]\n\n1-3) Returns the imaginary part of `z`.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `cimagl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `cimagf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `cimag` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe imaginary part of `z`.\n\nThis function is fully specified for all possible inputs and is not subject to any errors described in [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\n### Notes\n\nFor any complex variable `z`, `z ``==`` `[`creal`](http://en.cppreference.com/w/c/numeric/complex/creal)`(``z``)`` ``+`` I``*``cimag``(``z``)`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = 1.0 + 2.0*I;\n    printf(\"%f%+fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\n1.000000+2.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.2 The cimag functions (p: 197)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.2 The cimag functions (p: 178-179)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cimag](https://en.cppreference.com/w/c/numeric/complex/cimag)"
- name: clearerr
  summary: Resets the error flags and the EOF indicator for the given file stream
  description: "# clearerr\n\n[TABLE]\n\nResets the error flags and the [`EOF`](../io#Macro_constants \"c/io\") indicator for the given file stream.\n\n### Parameters\n\n|        |     |                                       |\n|--------|-----|---------------------------------------|\n| stream | \\-  | the file to reset the error flags for |\n\n### Return value\n\n(none)\n\n### Example\n\n```\n#include <stdio.h>\n#include <assert.h>\n \nint main(void)\n{\n    FILE* tmpf = tmpfile();\n    fputs(\"cppreference.com\\n\", tmpf);\n    rewind(tmpf);\n \n    for (int ch; (ch = fgetc(tmpf)) != EOF; putchar(ch)) { }\n \n    assert(feof(tmpf)); // the loop is expected to terminate by EOF\n    puts(\"End of file reached\");\n \n    clearerr(tmpf); // clear EOF\n \n    puts(feof(tmpf) ? \"EOF indicator set\" \n                    : \"EOF indicator cleared\");\n}\n```\n\nOutput:\n\n```\ncppreference.com\nEnd of file reached\nEOF indicator cleared\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.10.1 The clearerr function (p: 246)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.10.1 The clearerr function (p: 338)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.10.1 The clearerr function (p: 304)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.10.1 The clearerr function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/clearerr](https://en.cppreference.com/w/c/io/clearerr)"
- name: clock
  summary: Returns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution
  description: "# clock\n\n[TABLE]\n\nReturns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution. To convert result value to seconds, divide it by [`CLOCKS_PER_SEC`](clocks_per_sec \"c/chrono/CLOCKS PER SEC\").\n\nOnly the difference between two values returned by different calls to `clock` is meaningful, as the beginning of the `clock` era does not have to coincide with the start of the program. `clock` time may advance faster or slower than the wall clock, depending on the execution resources given to the program by the operating system. For example, if the CPU is shared by other processes, `clock` time may advance slower than wall clock. On the other hand, if the current process is multithreaded and more than one execution core is available, `clock` time may advance faster than wall clock.\n\n### Parameters\n\n(none)\n\n### Return value\n\nProcessor time used by the program so far or `(`[`clock_t`](http://en.cppreference.com/w/c/chrono/clock_t)`)``(``-``1``)` if that information is unavailable or its value cannot be represented.\n\n### Notes\n\nOn POSIX-compatible systems, [`clock_gettime`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html) with clock id `CLOCK_PROCESS_CPUTIME_ID` offers better resolution.\n\nThe value returned by `clock()` may wrap around on some non-conforming implementations. For example, on such an implementation, if [`clock_t`](clock_t \"c/chrono/clock t\") is a signed 32-bit integer and [`CLOCKS_PER_SEC`](clocks_per_sec \"c/chrono/CLOCKS PER SEC\") is 1000000, it will wrap after about 2147 seconds (about 36 minutes).\n\n### Example\n\nThis example demonstrates the difference between `clock()` time and real time.\n\n```\n#ifndef __STDC_NO_THREADS__\n    #include <threads.h>\n#else\n    // POSIX alternative\n    #define _POSIX_C_SOURCE 199309L\n    #include <pthread.h>\n#endif\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n \n// the function f() does some time-consuming work\nint f(void* thr_data) // return void* in POSIX\n{\n    (void) thr_data;\n    volatile double d = 0;\n    for (int n = 0; n < 10000; ++n)\n       for (int m = 0; m < 10000; ++m)\n           d += d * n * m;\n    return 0;\n}\n \nint main(void)\n{\n    struct timespec ts1, tw1; // both C11 and POSIX\n    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts1); // POSIX\n    clock_gettime(CLOCK_MONOTONIC, &tw1); // POSIX; use timespec_get in C11\n    clock_t t1 = clock();\n \n#ifndef __STDC_NO_THREADS__\n    thrd_t thr1, thr2;  // C11; use pthread_t in POSIX\n    thrd_create(&thr1, f, NULL); // C11; use pthread_create in POSIX\n    thrd_create(&thr2, f, NULL);\n    thrd_join(thr1, NULL); // C11; use pthread_join in POSIX\n    thrd_join(thr2, NULL);\n#endif\n \n    struct timespec ts2, tw2;\n    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts2);\n    clock_gettime(CLOCK_MONOTONIC, &tw2);\n    clock_t t2 = clock();\n \n    double dur = 1000.0 * (t2 - t1) / CLOCKS_PER_SEC;\n    double posix_dur = 1000.0 * ts2.tv_sec + 1e-6 * ts2.tv_nsec\n                       - (1000.0 * ts1.tv_sec + 1e-6 * ts1.tv_nsec);\n    double posix_wall = 1000.0 * tw2.tv_sec + 1e-6 * tw2.tv_nsec\n                        - (1000.0 * tw1.tv_sec + 1e-6 * tw1.tv_nsec);\n \n    printf(\"CPU time used (per clock()): %.2f ms\\n\", dur);\n    printf(\"CPU time used (per clock_gettime()): %.2f ms\\n\", posix_dur);\n    printf(\"Wall time passed: %.2f ms\\n\", posix_wall);\n}\n```\n\nPossible output:\n\n```\nCPU time used (per clock()): 1580.00 ms\nCPU time used (per clock_gettime()): 1582.76 ms\nWall time passed: 792.13 ms\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.2.1 The clock function (p: 285)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.2.1 The clock function (p: 389)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.2.1 The clock function (p: 339)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.2.1 The clock function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/clock](https://en.cppreference.com/w/c/chrono/clock)"
- name: clock_t
  summary: Arithmetic(until C11)Real(since C11) type capable of representing the processor time used by a process
  description: "# clock_t\n\n[TABLE]\n\nArithmetic(until C11)Real(since C11) type capable of representing the processor time used by a process. It has implementation-defined range and precision.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <math.h>\n \nvolatile double sink;\nint main (void)\n{\n  clock_t start = clock();\n \n  for(size_t i=0; i<3141592; ++i)\n      sink+=sin(i);\n \n  clock_t end = clock();\n  double cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;\n \n  printf(\"for loop took %f seconds to execute \\n\", cpu_time_used);\n}\n```\n\nPossible output:\n\n```\nfor loop took 0.271828 seconds to execute\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.1/3 Components of time (p: 284)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.1/3 Components of time (p: 388)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.1/3 Components of time (p: 338)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.1 Components of time\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/clock_t](https://en.cppreference.com/w/c/chrono/clock_t)"
- name: CLOCKS_PER_SEC
  summary: Expands to an expression (not necessarily a compile-time constant) of type clock_t equal to the number of clock ticks per second, as returned by clock()
  description: "# CLOCKS_PER_SEC\n\n[TABLE]\n\nExpands to an expression (not necessarily a compile-time constant) of type [`clock_t`](clock_t \"c/chrono/clock t\") equal to the number of clock ticks per second, as returned by [`clock()`](clock \"c/chrono/clock\").\n\n### Notes\n\nPOSIX defines `CLOCKS_PER_SEC` as one million, regardless of the actual precision of [`clock`](clock \"c/chrono/clock\").\n\nUntil standardized as `CLOCKS_PER_SEC` in C89, this macro was sometimes known by its IEEE std 1003.1-1988 name `CLK_TCK`: that name was not included in C89 and was removed from POSIX itself in 1996 over ambiguity with `_SC_CLK_TCK`, which gives number of clocks per second for the function [`times()`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/times.html)).\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.27.1/2 Components of time (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.1/2 Components of time (p: 284)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.1/2 Components of time (p: 388)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.1/2 Components of time (p: 338)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.1 Components of time\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/CLOCKS_PER_SEC](https://en.cppreference.com/w/c/chrono/CLOCKS_PER_SEC)"
- name: clog
  summary: If no errors occur, the complex natural logarithm of z is returned, in the range of a strip in the interval [−iπ, +iπ] along the imaginary axis and mathematically unbounded along the real axis
  description: "# clogf, clog, clogl\n\n[TABLE]\n\n1-3) Computes the complex natural (base-*e*) logarithm of `z` with branch cut along the negative real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `clogl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `clog` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `clogf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`logf`, [`log`](http://en.cppreference.com/w/c/numeric/math/log), `logl`). If `z` is imaginary, the corresponding complex number version is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex natural logarithm of `z` is returned, in the range of a strip in the interval \\[−iπ, +iπ\\] along the imaginary axis and mathematically unbounded along the real axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- The function is continuous onto the branch cut taking into account the sign of imaginary part\n- `clog``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``clog``(``z``)``)`\n- If `z` is `-0+0i`, the result is `-∞+πi` and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+0+0i`, the result is `-∞+0i` and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+∞i` (for any finite x), the result is `+∞+πi/2`\n- If `z` is `x+NaNi` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `-∞+yi` (for any finite positive y), the result is `+∞+πi`\n- If `z` is `+∞+yi` (for any finite positive y), the result is `+∞+0i`\n- If `z` is `-∞+∞i`, the result is `+∞+3πi/4`\n- If `z` is `+∞+∞i`, the result is `+∞+πi/4`\n- If `z` is `±∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `+∞+NaNi`\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nThe natural logarithm of a complex number z with polar coordinate components (r,θ) equals ln r + i(θ+2nπ), with the principal value ln r + iθ\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = clog(I); // r = 1, θ = pi/2\n    printf(\"2*log(i) = %.1f%+fi\\n\", creal(2*z), cimag(2*z));\n \n    double complex z2 = clog(sqrt(2)/2 + sqrt(2)/2*I); // r = 1, θ = pi/4\n    printf(\"4*log(sqrt(2)/2+sqrt(2)i/2) = %.1f%+fi\\n\", creal(4*z2), cimag(4*z2));\n \n    double complex z3 = clog(-1); // r = 1, θ = pi\n    printf(\"log(-1+0i) = %.1f%+fi\\n\", creal(z3), cimag(z3));\n \n    double complex z4 = clog(conj(-1)); // or clog(CMPLX(-1, -0.0)) in C11\n    printf(\"log(-1-0i) (the other side of the cut) = %.1f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\n2*log(i) = 0.0+3.141593i\n4*log(sqrt(2)/2+sqrt(2)i/2) = 0.0+3.141593i\nlog(-1+0i) = 0.0+3.141593i\nlog(-1-0i) (the other side of the cut) = 0.0-3.141593i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.7.2 The clog functions (p: 195)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.3.2 The clog functions (p: 543-544)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.7.2 The clog functions (p: 176-177)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.3.2 The clog functions (p: 478-479)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/clog](https://en.cppreference.com/w/c/numeric/complex/clog)"
- name: clogf
  summary: If no errors occur, the complex natural logarithm of z is returned, in the range of a strip in the interval [−iπ, +iπ] along the imaginary axis and mathematically unbounded along the real axis
  description: "# clogf, clog, clogl\n\n[TABLE]\n\n1-3) Computes the complex natural (base-*e*) logarithm of `z` with branch cut along the negative real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `clogl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `clog` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `clogf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`logf`, [`log`](http://en.cppreference.com/w/c/numeric/math/log), `logl`). If `z` is imaginary, the corresponding complex number version is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex natural logarithm of `z` is returned, in the range of a strip in the interval \\[−iπ, +iπ\\] along the imaginary axis and mathematically unbounded along the real axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- The function is continuous onto the branch cut taking into account the sign of imaginary part\n- `clog``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``clog``(``z``)``)`\n- If `z` is `-0+0i`, the result is `-∞+πi` and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+0+0i`, the result is `-∞+0i` and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+∞i` (for any finite x), the result is `+∞+πi/2`\n- If `z` is `x+NaNi` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `-∞+yi` (for any finite positive y), the result is `+∞+πi`\n- If `z` is `+∞+yi` (for any finite positive y), the result is `+∞+0i`\n- If `z` is `-∞+∞i`, the result is `+∞+3πi/4`\n- If `z` is `+∞+∞i`, the result is `+∞+πi/4`\n- If `z` is `±∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `+∞+NaNi`\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nThe natural logarithm of a complex number z with polar coordinate components (r,θ) equals ln r + i(θ+2nπ), with the principal value ln r + iθ\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = clog(I); // r = 1, θ = pi/2\n    printf(\"2*log(i) = %.1f%+fi\\n\", creal(2*z), cimag(2*z));\n \n    double complex z2 = clog(sqrt(2)/2 + sqrt(2)/2*I); // r = 1, θ = pi/4\n    printf(\"4*log(sqrt(2)/2+sqrt(2)i/2) = %.1f%+fi\\n\", creal(4*z2), cimag(4*z2));\n \n    double complex z3 = clog(-1); // r = 1, θ = pi\n    printf(\"log(-1+0i) = %.1f%+fi\\n\", creal(z3), cimag(z3));\n \n    double complex z4 = clog(conj(-1)); // or clog(CMPLX(-1, -0.0)) in C11\n    printf(\"log(-1-0i) (the other side of the cut) = %.1f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\n2*log(i) = 0.0+3.141593i\n4*log(sqrt(2)/2+sqrt(2)i/2) = 0.0+3.141593i\nlog(-1+0i) = 0.0+3.141593i\nlog(-1-0i) (the other side of the cut) = 0.0-3.141593i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.7.2 The clog functions (p: 195)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.3.2 The clog functions (p: 543-544)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.7.2 The clog functions (p: 176-177)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.3.2 The clog functions (p: 478-479)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/clog](https://en.cppreference.com/w/c/numeric/complex/clog)"
- name: clogl
  summary: If no errors occur, the complex natural logarithm of z is returned, in the range of a strip in the interval [−iπ, +iπ] along the imaginary axis and mathematically unbounded along the real axis
  description: "# clogf, clog, clogl\n\n[TABLE]\n\n1-3) Computes the complex natural (base-*e*) logarithm of `z` with branch cut along the negative real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `clogl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `clog` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `clogf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`logf`, [`log`](http://en.cppreference.com/w/c/numeric/math/log), `logl`). If `z` is imaginary, the corresponding complex number version is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex natural logarithm of `z` is returned, in the range of a strip in the interval \\[−iπ, +iπ\\] along the imaginary axis and mathematically unbounded along the real axis.\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- The function is continuous onto the branch cut taking into account the sign of imaginary part\n- `clog``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``clog``(``z``)``)`\n- If `z` is `-0+0i`, the result is `-∞+πi` and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+0+0i`, the result is `-∞+0i` and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+∞i` (for any finite x), the result is `+∞+πi/2`\n- If `z` is `x+NaNi` (for any finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `-∞+yi` (for any finite positive y), the result is `+∞+πi`\n- If `z` is `+∞+yi` (for any finite positive y), the result is `+∞+0i`\n- If `z` is `-∞+∞i`, the result is `+∞+3πi/4`\n- If `z` is `+∞+∞i`, the result is `+∞+πi/4`\n- If `z` is `±∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+yi` (for any finite y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+∞i`, the result is `+∞+NaNi`\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Notes\n\nThe natural logarithm of a complex number z with polar coordinate components (r,θ) equals ln r + i(θ+2nπ), with the principal value ln r + iθ\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = clog(I); // r = 1, θ = pi/2\n    printf(\"2*log(i) = %.1f%+fi\\n\", creal(2*z), cimag(2*z));\n \n    double complex z2 = clog(sqrt(2)/2 + sqrt(2)/2*I); // r = 1, θ = pi/4\n    printf(\"4*log(sqrt(2)/2+sqrt(2)i/2) = %.1f%+fi\\n\", creal(4*z2), cimag(4*z2));\n \n    double complex z3 = clog(-1); // r = 1, θ = pi\n    printf(\"log(-1+0i) = %.1f%+fi\\n\", creal(z3), cimag(z3));\n \n    double complex z4 = clog(conj(-1)); // or clog(CMPLX(-1, -0.0)) in C11\n    printf(\"log(-1-0i) (the other side of the cut) = %.1f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\n2*log(i) = 0.0+3.141593i\n4*log(sqrt(2)/2+sqrt(2)i/2) = 0.0+3.141593i\nlog(-1+0i) = 0.0+3.141593i\nlog(-1-0i) (the other side of the cut) = 0.0-3.141593i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.7.2 The clog functions (p: 195)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.3.2 The clog functions (p: 543-544)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.7.2 The clog functions (p: 176-177)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.3.2 The clog functions (p: 478-479)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/clog](https://en.cppreference.com/w/c/numeric/complex/clog)"
- name: CMPLX
  summary: Each of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of real (converted to the specified argument type) and the imaginary part having the value of imag (converted to the specified argument type)
  description: "# CMPLXF, CMPLX, CMPLXL\n\n[TABLE]\n\nEach of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of `real` (converted to the specified argument type) and the imaginary part having the value of `imag` (converted to the specified argument type)\n\nThe expressions are suitable for use as initializers for objects with static or thread storage duration, as long as the expressions `real` and `imag` are also suitable.\n\n### Parameters\n\n|      |     |                                                    |\n|------|-----|----------------------------------------------------|\n| real | \\-  | the real part of the complex number to return      |\n| imag | \\-  | the imaginary part of the complex number to return |\n\n### Return value\n\nA complex number composed of `real` and `imag` as the real and imaginary parts.\n\n### Notes\n\nThese macros are implemented as if the imaginary types are supported (even if they are otherwise not supported and [`_Imaginary_I`](imaginary_i \"c/numeric/complex/Imaginary I\") is actually undefined) and as if defined as follows:\n\n```\n#define CMPLX(x, y) ((double complex)((double)(x) + _Imaginary_I * (double)(y)))\n#define CMPLXF(x, y) ((float complex)((float)(x) + _Imaginary_I * (float)(y)))\n#define CMPLXL(x, y) ((long double complex)((long double)(x) + \\\n                      _Imaginary_I * (long double)(y)))\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = CMPLX(0.0, -0.0);\n    printf(\"z = %.1f%+.1fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\nz = 0.0-0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.3 The CMPLX macros (p: 197)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/CMPLX](https://en.cppreference.com/w/c/numeric/complex/CMPLX)"
- name: CMPLXF
  summary: Each of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of real (converted to the specified argument type) and the imaginary part having the value of imag (converted to the specified argument type)
  description: "# CMPLXF, CMPLX, CMPLXL\n\n[TABLE]\n\nEach of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of `real` (converted to the specified argument type) and the imaginary part having the value of `imag` (converted to the specified argument type)\n\nThe expressions are suitable for use as initializers for objects with static or thread storage duration, as long as the expressions `real` and `imag` are also suitable.\n\n### Parameters\n\n|      |     |                                                    |\n|------|-----|----------------------------------------------------|\n| real | \\-  | the real part of the complex number to return      |\n| imag | \\-  | the imaginary part of the complex number to return |\n\n### Return value\n\nA complex number composed of `real` and `imag` as the real and imaginary parts.\n\n### Notes\n\nThese macros are implemented as if the imaginary types are supported (even if they are otherwise not supported and [`_Imaginary_I`](imaginary_i \"c/numeric/complex/Imaginary I\") is actually undefined) and as if defined as follows:\n\n```\n#define CMPLX(x, y) ((double complex)((double)(x) + _Imaginary_I * (double)(y)))\n#define CMPLXF(x, y) ((float complex)((float)(x) + _Imaginary_I * (float)(y)))\n#define CMPLXL(x, y) ((long double complex)((long double)(x) + \\\n                      _Imaginary_I * (long double)(y)))\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = CMPLX(0.0, -0.0);\n    printf(\"z = %.1f%+.1fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\nz = 0.0-0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.3 The CMPLX macros (p: 197)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/CMPLX](https://en.cppreference.com/w/c/numeric/complex/CMPLX)"
- name: CMPLXL
  summary: Each of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of real (converted to the specified argument type) and the imaginary part having the value of imag (converted to the specified argument type)
  description: "# CMPLXF, CMPLX, CMPLXL\n\n[TABLE]\n\nEach of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of `real` (converted to the specified argument type) and the imaginary part having the value of `imag` (converted to the specified argument type)\n\nThe expressions are suitable for use as initializers for objects with static or thread storage duration, as long as the expressions `real` and `imag` are also suitable.\n\n### Parameters\n\n|      |     |                                                    |\n|------|-----|----------------------------------------------------|\n| real | \\-  | the real part of the complex number to return      |\n| imag | \\-  | the imaginary part of the complex number to return |\n\n### Return value\n\nA complex number composed of `real` and `imag` as the real and imaginary parts.\n\n### Notes\n\nThese macros are implemented as if the imaginary types are supported (even if they are otherwise not supported and [`_Imaginary_I`](imaginary_i \"c/numeric/complex/Imaginary I\") is actually undefined) and as if defined as follows:\n\n```\n#define CMPLX(x, y) ((double complex)((double)(x) + _Imaginary_I * (double)(y)))\n#define CMPLXF(x, y) ((float complex)((float)(x) + _Imaginary_I * (float)(y)))\n#define CMPLXL(x, y) ((long double complex)((long double)(x) + \\\n                      _Imaginary_I * (long double)(y)))\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = CMPLX(0.0, -0.0);\n    printf(\"z = %.1f%+.1fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\nz = 0.0-0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.3 The CMPLX macros (p: 197)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/CMPLX](https://en.cppreference.com/w/c/numeric/complex/CMPLX)"
- name: cnd_broadcast
  summary: Unblocks all threads that are blocked on condition variable cond at the time of the call
  description: "# cnd_broadcast\n\n[TABLE]\n\nUnblocks all threads that are blocked on condition variable `cond` at the time of the call. If no threads are blocked on `cond`, the function does nothing and returns `thrd_success`.\n\n### Parameters\n\n|      |     |                                 |\n|------|-----|---------------------------------|\n| cond | \\-  | pointer to a condition variable |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") otherwise.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.3.1 The cnd_broadcast function (p: 275-276)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.3.1 The cnd_broadcast function (p: 378)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/cnd_broadcast](https://en.cppreference.com/w/c/thread/cnd_broadcast)"
- name: cnd_destroy
  summary: Destroys the condition variable pointed to by cond
  description: "# cnd_destroy\n\n[TABLE]\n\nDestroys the condition variable pointed to by `cond`.\n\nIf there are threads waiting on `cond`, the behavior is undefined.\n\n### Parameters\n\n|      |     |                                              |\n|------|-----|----------------------------------------------|\n| cond | \\-  | pointer to the condition variable to destroy |\n\n### Return value\n\n(none)\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.3.2 The cnd_destroy function (p: 276)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.3.2 The cnd_destroy function (p: 378-379)\n\n### See also\n\n|                                                                                                                                                                                                          |     |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/condition_variable/%7Econdition_variable \"cpp/thread/condition variable/~condition variable\") for `~condition_variable`                     |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/condition_variable_any/%7Econdition_variable_any \"cpp/thread/condition variable any/~condition variable any\") for `~condition_variable_any` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/cnd_destroy](https://en.cppreference.com/w/c/thread/cnd_destroy)"
- name: cnd_init
  summary: Initializes new condition variable
  description: "# cnd_init\n\n[TABLE]\n\nInitializes new condition variable. The object pointed to by `cond` will be set to value that identifies the condition variable.\n\n### Parameters\n\n|      |     |                                                                        |\n|------|-----|------------------------------------------------------------------------|\n| cond | \\-  | pointer to a variable to store identifier of the condition variable to |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if the condition variable was successfully created. Otherwise returns [`thrd_nomem`](thrd_errors \"c/thread/thrd errors\") if there was insufficient amount of memory or `thrd_error` if another error occurred.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.3.3 The cnd_init function (p: 276)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.3.3 The cnd_init function (p: 379)\n\n### See also\n\n|                                                                                                                                                                                                     |     |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/condition_variable/condition_variable \"cpp/thread/condition variable/condition variable\") for `condition_variable`                     |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/condition_variable_any/condition_variable_any \"cpp/thread/condition variable any/condition variable any\") for `condition_variable_any` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/cnd_init](https://en.cppreference.com/w/c/thread/cnd_init)"
- name: cnd_signal
  summary: Unblocks one thread that currently waits on condition variable pointed to by cond
  description: "# cnd_signal\n\n[TABLE]\n\nUnblocks one thread that currently waits on condition variable pointed to by `cond`. If no threads are blocked, does nothing and returns `thrd_success`.\n\n### Parameters\n\n|      |     |                                 |\n|------|-----|---------------------------------|\n| cond | \\-  | pointer to a condition variable |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") otherwise.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.3.4 The cnd_signal function (p: 276)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.3.4 The cnd_signal function (p: 379)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/cnd_signal](https://en.cppreference.com/w/c/thread/cnd_signal)"
- name: cnd_timedwait
  summary: Atomically unlocks the mutex pointed to by mutex and blocks on the condition variable pointed to by cond until the thread is signalled by cnd_signal or cnd_broadcast, or until the TIME_UTC based time point pointed to by time_point has been reached, or until a spurious wake-up occurs
  description: "# cnd_timedwait\n\n[TABLE]\n\nAtomically unlocks the mutex pointed to by `mutex` and blocks on the condition variable pointed to by `cond` until the thread is signalled by [`cnd_signal`](cnd_signal \"c/thread/cnd signal\") or [`cnd_broadcast`](cnd_broadcast \"c/thread/cnd broadcast\"), or until the `TIME_UTC` based time point pointed to by `time_point` has been reached, or until a spurious wake-up occurs. The mutex is locked again before the function returns.\n\nThe behavior is undefined if the mutex is not already locked by the calling thread.\n\n### Parameters\n\n|            |     |                                                              |\n|------------|-----|--------------------------------------------------------------|\n| cond       | \\-  | pointer to the condition variable to block on                |\n| mutex      | \\-  | pointer to the mutex to unlock for the duration of the block |\n| time_point | \\-  | pointer to an object specifying timeout time to wait until   |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, `thrd_timedout` if the timeout time has been reached before the mutex is locked, or [`thrd_error`](thrd_errors \"c/thread/thrd errors\") if an error occurred.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.3.5 The cnd_timedwait function (p: 276-277)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.3.5 The cnd_timedwait function (p: 379-380)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/cnd_timedwait](https://en.cppreference.com/w/c/thread/cnd_timedwait)"
- name: cnd_wait
  summary: Atomically unlocks the mutex pointed to by mutex and blocks on the condition variable pointed to by cond until the thread is signalled by cnd_signal or cnd_broadcast, or until a spurious wake-up occurs
  description: "# cnd_wait\n\n[TABLE]\n\nAtomically unlocks the mutex pointed to by `mutex` and blocks on the condition variable pointed to by `cond` until the thread is signalled by [`cnd_signal`](cnd_signal \"c/thread/cnd signal\") or [`cnd_broadcast`](cnd_broadcast \"c/thread/cnd broadcast\"), or until a spurious wake-up occurs. The mutex is locked again before the function returns.\n\nThe behavior is undefined if the mutex is not already locked by the calling thread.\n\n### Parameters\n\n|       |     |                                                              |\n|-------|-----|--------------------------------------------------------------|\n| cond  | \\-  | pointer to the condition variable to block on                |\n| mutex | \\-  | pointer to the mutex to unlock for the duration of the block |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") otherwise.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.3.6 The cnd_wait function (p: 277)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.3.6 The cnd_wait function (p: 380)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/cnd_wait](https://en.cppreference.com/w/c/thread/cnd_wait)"
- name: Comments
  summary: Comments serve as a sort of in-code documentation
  description: "# Comments\n\nComments serve as a sort of in-code documentation. When inserted into a program, they are effectively ignored by the compiler; they are solely intended to be used as notes by the humans that read source code.\n\n### Syntax\n\n|                   |       |             |\n|-------------------|-------|-------------|\n| `/*` comment `*/` | \\(1\\) |             |\n| `//` comment      | \\(2\\) | (since C99) |\n\n1) Often known as \"C-style\" or \"multi-line\" comments.\n\n2) Often known as \"C++-style\" or \"single-line\" comments.\n\nAll comments are removed from the program at [translation phase 3](language/translation_phases \"c/language/translation phases\") by replacing each comment with a single whitespace character.\n\n### C-style\n\nC-style comments are usually used to comment large blocks of text or small fragments of code; however, they can be used to comment single lines. To insert text as a C-style comment, simply surround the text with `/*` and `*/`. C-style comments tell the compiler to ignore all content between `/*` and `*/`. Although it is not part of the C standard, `/**` and `**/` are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment.\n\nExcept within a [character constant](language/character_constant \"c/language/character constant\"), a [string literal](language/string_literal \"c/language/string literal\"), or a comment, the characters `/*` introduce a comment. The contents of such a comment are examined only to identify multibyte characters and to find the characters `*/` that terminate the comment. C-style comments cannot be nested.\n\n[TABLE]\n\n### Notes\n\nBecause comments [are removed](language/translation_phases \"c/language/translation phases\") before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an \\#include'd file.\n\n```\n/* An attempt to use a macro to form a comment. */\n/* But, a space replaces characters \"//\".       */\n#ifndef DEBUG\n    #define PRINTF //\n#else\n    #define PRINTF printf\n#endif\n...  \nPRINTF(\"Error in file %s at line %i\\n\", __FILE__, __LINE__);\n```\n\nBesides commenting out, other mechanisms used for source code exclusion are:\n\n```\n#if 0\n    puts(\"this will not be compiled\");\n    /* no conflict with C-style comments */\n    // no conflict with C++-style comments\n#endif\n```\n\nand\n\n```\nif(0) {\n    puts(\"this will be compiled but not be executed\");\n    /* no conflict with C-style comments */\n    // no conflict with C++-style comments\n}\n```\n\nThe introduction of // comments in C99 was a breaking change in some rare circumstances:\n\n```\na = b //*divisor:*/ c\n+ d; /* C89 compiles a = b / c + d;\n        C99 compiles a = b + d; */\n```\n\n### Example\n\n```\n#include <stdio.h>\n/*\nC-style comments can contain\nmultiple lines.\n*/\n \n/* Or, just one line. */\n \n// C++-style comments can comment one line.\n \n// Or, they can\n// be strung together.\n \nint main(void)\n{\n  // The below code won't be run\n  // puts(\"Hello\");\n \n  // The below code will be run\n  puts(\"World\");\n \n  // A note regarding backslash + newline.\n  // Despite belonging to translation phase 2 (vs phase 3 for comments),\n  // '\\' still determines which portion of the source code is considered\n  // as 'comments':\n  // This comment will be promoted to the next line \\\n  puts(\"Won't be run\"); // may issue a warning \"multi-line comment\"\n  puts(\"Hello, again\");\n}\n```\n\nOutput:\n\n```\nWorld\nHello, again\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.4.9 Comments (p: 54)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.4.9 Comments (p: 75)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.4.9 Comments (p: 66)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.9 Comments\n\n### See also\n\n|                                                                                             |     |\n|---------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/comments \"cpp/comments\") for Comments |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/comment](https://en.cppreference.com/w/c/comment)"
- name: Common mathematical functions
  summary: ''
  description: "# Common mathematical functions\n\n### Functions\n\n[TABLE]\n\n### Types\n\n[TABLE]\n\n### Macro constants\n\n[TABLE]\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8 Format conversion of integer types \\<inttypes.h\\> (p: 158-160)\n  - 7.12 Mathematics \\<math.h\\> (p: 169-190)\n  - 7.22 General utilities \\<stdlib.h\\> (p: 248-262)\n  - 7.31.5 Format conversion of integer types \\<inttypes.h\\> (p: 332)\n  - 7.31.12 General utilities \\<stdlib.h\\> (p: 333)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8 Format conversion of integer types \\<inttypes.h\\> (p: 217-220)\n  - 7.12 Mathematics \\<math.h\\> (p: 231-261)\n  - 7.22 General utilities \\<stdlib.h\\> (p: 340-360)\n  - 7.31.5 Format conversion of integer types \\<inttypes.h\\> (p: 455)\n  - 7.31.12 General utilities \\<stdlib.h\\> (p: 456)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8 Format conversion of integer types \\<inttypes.h\\> (p: 198-201)\n  - 7.12 Mathematics \\<math.h\\> (p: 212-242)\n  - 7.20 General utilities \\<stdlib.h\\> (p: 306-324)\n  - 7.26.4 Format conversion of integer types \\<inttypes.h\\> (p: 401)\n  - 7.26.10 General utilities \\<stdlib.h\\> (p: 402)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5 MATHEMATICS \\<math.h\\>\n  - 4.10 GENERAL UTILITIES \\<stdlib.h\\>\n  - 4.13.4 Mathematics \\<math.h\\>\n  - 7.13.7 General utilities \\<stdlib.h\\>\n\n### See also\n\n|                                                                                                                          |     |\n|--------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/math \"cpp/numeric/math\") for Common mathematical functions |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math](https://en.cppreference.com/w/c/numeric/math)"
- name: Comparison operators
  summary: Comparison operators are binary operators that test a condition and return 1 if that condition is logically true and 0 if that condition is false
  description: "# Comparison operators\n\nComparison operators are binary operators that test a condition and return **1** if that condition is logically **true** and **0** if that condition is **false**.\n\n| Operator | Operator name            | Example  | Description                             |\n|----------|--------------------------|----------|-----------------------------------------|\n| `==`     | equal to                 | `a == b` | **a** is equal to **b**                 |\n| `!=`     | not equal to             | `a != b` | **a** is not equal to **b**             |\n| `<`      | less than                | `a < b`  | **a** is less than **b**                |\n| `>`      | greater than             | `a > b`  | **a** is greater than **b**             |\n| `<=`     | less than or equal to    | `a <= b` | **a** is less than or equal to **b**    |\n| `>=`     | greater than or equal to | `a >= b` | **a** is greater than or equal to **b** |\n\n### Relational operators\n\nThe relational operator expressions have the form\n\n|              |       |     |\n|--------------|-------|-----|\n| lhs `<` rhs  | \\(1\\) |     |\n| lhs `>` rhs  | \\(2\\) |     |\n| lhs `<=` rhs | \\(3\\) |     |\n| lhs `>=` rhs | \\(4\\) |     |\n\n1) less-than expression\n\n2) greater-than expression\n\n3) less or equal expression\n\n4) greater or equal expression\n\nwhere\n\n|          |     |                                                                          |\n|----------|-----|--------------------------------------------------------------------------|\n| lhs, rhs | \\-  | expressions that both have real type or both have pointer to object type |\n\nThe type of any relational operator expression is `int`, and its value (which is not an lvalue) is `1` when the specified relationship holds true and `​0​` when the specified relationship does not hold.\n\nIf lhs and rhs are expressions of any [real type](types \"c/language/types\"), then\n\n- [usual arithmetic conversions](conversion#Usual_arithmetic_conversions \"c/language/conversion\") are performed\n- the values of the operands after conversion are compared in the usual mathematical sense (except that positive and negative zeroes compare equal and any comparison involving a NaN value returns zero)\n\nNote that complex and imaginary numbers cannot be compared with these operators.\n\nIf lhs and rhs are expressions of pointer type, they must be both pointers to objects of [compatible types](types#Compatible_types \"c/language/types\"), except that qualifications of the pointed-to objects are ignored.\n\n- a pointer to an object that is not an element of an array is treated as if it were pointing to an element of an array with one element\n- if two pointers point to the same object, or both point one past the end of the same array, they compare equal\n- if two pointers point to different elements of the same array, the one pointing at the element with the larger index compares greater.\n- if one pointer points to the element of an array and the other pointer points one past the end of the same array, the one-past-the-end pointer compares greater\n- if the two pointers point to members of the same [struct](struct \"c/language/struct\"), the pointer to the member declared later in the struct definition compares greater than then pointer to the member declared earlier.\n- pointers to members of the same union compare equal\n- all other pointer comparisons invoke undefined behavior\n\n```\n#include <assert.h>\nint main(void)\n{\n    assert(1 < 2);\n    assert(2+2 <= 4.0); // int converts to double, two 4.0's compare equal\n \n    struct { int x,y; } s;\n    assert(&s.x < &s.y); // struct members compare in order of declaration\n \n    double d = 0.0/0.0; // NaN\n    assert( !(d < d) );\n    assert( !(d > d) );\n    assert( !(d <= d) );\n    assert( !(d >= d) );\n    assert( !(d == d) );\n \n    float f = 0.1; // f = 0.100000001490116119384765625\n    double g = 0.1; // g = 0.1000000000000000055511151231257827021181583404541015625\n    assert(f > g); // different values\n}\n```\n\n### Equality operators\n\nThe equality operator expressions have the form\n\n|              |       |     |\n|--------------|-------|-----|\n| lhs `==` rhs | \\(1\\) |     |\n| lhs `!=` rhs | \\(2\\) |     |\n\n1) equal-to expression\n\n2) not equal to expression\n\nwhere\n\n[TABLE]\n\nThe type of any equality operator expression is `int`, and its value (which is not an lvalue) is `1` when the specified relationship holds true and `​0​` when the specified relationship does not hold.\n\n- if both operands have arithmetic types, [usual arithmetic conversions](conversion#Usual_arithmetic_conversions \"c/language/conversion\") are performed and the resulting values are compared in the usual mathematical sense (except that positive and negative zeroes compare equal and any comparison involving a NaN value, including equality with itself, returns zero). In particular, values of complex type are equal if their real parts compare equal and their imaginary parts compare equal.\n\n[TABLE]\n\n- if one operand is a pointer and the other is a null pointer constant, the null pointer constant is first [converted](conversion \"c/language/conversion\") to the type of the pointer (which gives a null pointer value), and the two pointers are compared as described below\n- if one operand is a pointer and the other is a pointer to void, the non-void pointer is [converted](conversion \"c/language/conversion\") to the pointer to void and the two pointers are compared as described below\n- two pointers compare equal if any of the following is true:\n  - they are both null pointer values of their type\n  - they are both pointers to the same object or function\n  - one pointer is to a struct/union/array object and the other is to its first member/any member/first element\n  - they are both pointing one past the last element of the same array\n  - one is one past the end of an array, and the other is at the start of a different array (of the same type) that follows the first in a larger array or in a struct with no padding\n\n(as with relational operators, pointers to objects that aren't elements of any array behave as pointers to elements of arrays of size 1)\n\n#### Notes\n\nObjects of struct type do not compare equal automatically, and comparing them with [`memcmp`](../string/byte/memcmp \"c/string/byte/memcmp\") is not reliable because the padding bytes may have any values.\n\nBecause pointer comparison works with pointers to void, the macro [`NULL`](../types/null \"c/types/NULL\") may be defined as `(void*)0` in C, although that would be invalid in C++ where void pointers do not implicitly convert to typed pointers\n\nCare must be taken when comparing floating-point values for equality, because the results of many operations cannot be represented exactly and must be rounded. In practice, floating-point numbers are usually compared allowing for the difference of one or more units of the last place.\n\n```\n#include <assert.h>\nint main(void)\n{\n    assert(2+2 == 4.0); // int converts to double, two 4.0's compare equal\n \n    int n[2][3] = {1,2,3,4,5,6};\n    int* p1 = &n[0][2]; // last element in the first row\n    int* p2 = &n[1][0]; // start of second row\n    assert(p1+1 == p2); // compare equal\n \n    double d = 0.0/0.0; // NaN\n    assert( d != d ); // NaN does not equal itself\n \n    float f = 0.1; // f = 0.100000001490116119384765625\n    double g = 0.1; // g = 0.1000000000000000055511151231257827021181583404541015625\n    assert(f != g); // different values\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.8 Relational operators (p: 68-69)\n  - 6.5.9 Equality operators (p: 69-70)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.8 Relational operators (p: 95-96)\n  - 6.5.9 Equality operators (p: 96-97)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5.8 Relational operators (p: 85-86)\n  - 6.5.9 Equality operators (p: 86-87)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.3.8 Relational operators\n  - 3.3.9 Equality operators\n\n### See also\n\n[Operator precedence](operator_precedence \"c/language/operator precedence\")\n\n[TABLE]\n\n|                                                                                                                                                 |     |\n|-------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/operator_comparison \"cpp/language/operator comparison\") for Comparison operators |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/operator_comparison](https://en.cppreference.com/w/c/language/operator_comparison)"
- name: complex
  summary: This macro expands to a type specifier used to identify complex types
  description: "# complex\n\n[TABLE]\n\nThis macro expands to a type specifier used to identify [complex types](../../language/arithmetic_types#Complex_floating_types \"c/language/arithmetic types\").\n\nA program may undefine and perhaps then redefine the `complex` macro.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n#include <math.h>\n \nvoid print_complex(const char* note, complex z)\n{\n    printf(\"%s %f%+f*i\\n\", note, creal(z), cimag(z));\n}\n \nint main(void)\n{\n    double complex z = -1.0 + 2.0*I;\n    print_complex(\"z  =\", z);\n    print_complex(\"z\\u00B2 =\", z * z);\n    double complex z2 = ccos(2.0 * carg(z)) + csin(2.0 * carg(z))*I;\n    print_complex(\"z\\u00B2 =\", cabs(z) * cabs(z) * z2);\n}\n```\n\nOutput:\n\n```\nz  = -1.000000+2.000000*i\nz² = -3.000000-4.000000*i\nz² = -3.000000-4.000000*i\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.3.1/4 complex (p: 136)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.1/4 complex (p: 188)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.1/2 complex (p: 170)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/complex](https://en.cppreference.com/w/c/numeric/complex/complex)"
- name: Complex number arithmetic
  summary: If the macro constant __STDC_NO_COMPLEX__ is defined by the implementation, the complex types, the header <complex.h> and all of the names listed here are not provided
  description: "# Complex number arithmetic\n\n|                                                                                                                                                                              |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If the macro constant `__STDC_NO_COMPLEX__` is defined by the implementation, the complex types, the header `<complex.h>` and all of the names listed here are not provided. | (since C11) |\n\nThe C programming language, as of C99, supports complex number math with the three built-in types `double _Complex`, `float _Complex`, and `long double _Complex` (see [`_Complex`](../keyword/_complex \"c/keyword/ Complex\")). When the header `<complex.h>` is included, the three complex number types are also accessible as `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex).\n\nIn addition to the complex types, the three imaginary types may be supported: `double _Imaginary`, `float _Imaginary`, and `long double _Imaginary` (see [`_Imaginary`](../keyword/_imaginary \"c/keyword/ Imaginary\")). When the header `<complex.h>` is included, the three imaginary types are also accessible as `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), and `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary).\n\nStandard arithmetic operators `+, -, *, /` can be used with real, complex, and imaginary types in any combination.\n\n[TABLE]\n\n[TABLE]\n\n### Notes\n\nThe following function names are potentially(since C23) reserved for future addition to `complex.h` and are not available for use in the programs that include that header: `cerf`, `cerfc`, `cexp2`, `cexpm1`, `clog10`, `clog1p`, `clog2`, `clgamma`, `ctgamma`, `csinpi`, `ccospi`, `ctanpi`, `casinpi`, `cacospi`, `catanpi`, `ccompoundn`, `cpown`, `cpowr`, `crootn`, `crsqrt`, `cexp10m1`, `cexp10`, `cexp2m1`, `clog10p1`, `clog2p1`, `clogp1`(since C23), along with their -f and -l suffixed variants.\n\nAlthough the C standard names the inverse hyperbolics with \"complex arc hyperbolic sine\" etc., the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct names are \"complex inverse hyperbolic sine\" etc. Some authors use \"complex area hyperbolic sine\" etc.\n\nA complex or imaginary number is infinite if one of its parts is infinite, even if the other part is NaN.\n\nA complex or imaginary number is finite if both parts are neither infinities nor NaNs.\n\nA complex or imaginary number is a zero if both parts are positive or negative zeroes.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n#include <tgmath.h>\n \nint main(void)\n{\n    double complex z1 = I * I;     // imaginary unit squared\n    printf(\"I * I = %.1f%+.1fi\\n\", creal(z1), cimag(z1));\n \n    double complex z2 = pow(I, 2); // imaginary unit squared\n    printf(\"pow(I, 2) = %.1f%+.1fi\\n\", creal(z2), cimag(z2));\n \n    double PI = acos(-1);\n    double complex z3 = exp(I * PI); // Euler's formula\n    printf(\"exp(I*PI) = %.1f%+.1fi\\n\", creal(z3), cimag(z3));\n \n    double complex z4 = 1+2*I, z5 = 1-2*I; // conjugates\n    printf(\"(1+2i)*(1-2i) = %.1f%+.1fi\\n\", creal(z4*z5), cimag(z4*z5));\n}\n```\n\nOutput:\n\n```\nI * I = -1.0+0.0i\npow(I, 2) = -1.0+0.0i\nexp(I*PI) = -1.0+0.0i\n(1+2i)*(1-2i) = 5.0+0.0i\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.8.3/1/2 `__STDC_NO_COMPLEX__` (p: 128)\n  - 6.10.8.3/1/2 `__STDC_IEC_559_COMPLEX__` (p: 128)\n  - 7.3 Complex arithmetic `<complex.h>` (p: 136-144)\n  - 7.25 Type-generic math `<tgmath.h>` (p: 272-273)\n  - 7.31.1 Complex arithmetic `<complex.h>` (p: 391)\n  - Annex G (normative) IEC 60559-compatible complex arithmetic (p: 469-479)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.8.3/1/2 `__STDC_NO_COMPLEX__` (p: 177)\n  - 6.10.8.3/1/2 `__STDC_IEC_559_COMPLEX__` (p: 177)\n  - 7.3 Complex arithmetic `<complex.h>` (p: 188-199)\n  - 7.25 Type-generic math `<tgmath.h>` (p: 373-375)\n  - 7.31.1 Complex arithmetic `<complex.h>` (p: 455)\n  - Annex G (normative) IEC 60559-compatible complex arithmetic (p: 532-545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.8/2 `__STDC_IEC_559_COMPLEX__` (p: 161)\n  - 7.3 Complex arithmetic `<complex.h>` (p: 170-180)\n  - 7.22 Type-generic math `<tgmath.h>` (p: 335-337)\n  - 7.26.1 Complex arithmetic `<complex.h>` (p: 401)\n  - Annex G (informative) IEC 60559-compatible complex arithmetic (p: 467-480)\n\n### See also\n\n|                                                                                                                            |     |\n|----------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/complex \"cpp/numeric/complex\") for Complex number arithmetic |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex](https://en.cppreference.com/w/c/numeric/complex)"
- name: Compound literals
  summary: Constructs an unnamed object of specified type (which may be struct, union, or even array type) in-place
  description: "# Compound literals (since C99)\n\nConstructs an unnamed object of specified type (which may be struct, union, or even array type) in-place.\n\n### Syntax\n\n|                                                                                          |     |             |\n|------------------------------------------------------------------------------------------|-----|-------------|\n| `(` storage-class-specifiers \uFEFF(optional)(since C23) type `)` `{` initializer-list `}`     |     | (since C99) |\n| `(` storage-class-specifiers \uFEFF(optional)(since C23) type `)` `{` initializer-list `,` `}` |     | (since C99) |\n| `(` storage-class-specifiers \uFEFF(optional) type `)` `{` `}`                                 |     | (since C23) |\n\nwhere\n\n|                          |     |                                                                                                                                                                                                                                   |\n|--------------------------|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| storage-class-specifiers | \\-  | (since C23) A list of [storage class specifiers](storage_duration \"c/language/storage duration\") that can contain only `constexpr`, `static`, `register`, or [`thread_local`](http://en.cppreference.com/w/c/thread/thread_local) |\n| type                     | \\-  | a [type name](type#Type_names \"c/language/type\") specifying any complete object type or an array of unknown size, but not a VLA                                                                                                   |\n| initializer-list         | \\-  | list of initializers suitable for [initialization](initialization \"c/language/initialization\") of an object of type                                                                                                               |\n\n### Explanation\n\nThe compound literal expression constructs an unnamed object of the type specified by type and initializes it as specified by initializer-list. [Designated initializers](initialization \"c/language/initialization\") are accepted.\n\nThe type of the compound literal is type (except when type is an array of unknown size; its size is deduced from the initializer-list as in [array initialization](array_initialization \"c/language/array initialization\")).\n\nThe value category of a compound literal is [lvalue](value_category \"c/language/value category\") (its address can be taken).\n\n[TABLE]\n\n### Notes\n\nCompound literals of const-qualified character or wide character array types may share storage with [string literals](string_literal \"c/language/string literal\").\n\n```\n(const char []){\"abc\"} == \"abc\" // might be 1 or 0, unspecified\n```\n\nEach compound literal creates only a single object in its scope:\n\n```\nint f (void)\n{\n    struct s {int i;} *p = 0, *q;\n    int j = 0;\nagain:\n    q = p, p = &((struct s){ j++ });\n    if (j < 2) goto again; // note; if a loop were used, it would end scope here,\n                           // which would terminate the lifetime of the compound literal\n                           // leaving p as a dangling pointer\n    return p == q && q->i == 1; // always returns 1\n}\n```\n\nBecause compound literals are unnamed, a compound literal cannot reference itself (a named struct can include a pointer to itself)\n\nAlthough the syntax of a compound literal is similar to a [cast](cast \"c/language/cast\"), the important distinction is that a cast is a non-lvalue expression while a compound literal is an lvalue.\n\n### Example\n\n```\n#include <stdio.h>\n \nint *p = (int[]){2, 4}; // creates an unnamed static array of type int[2]\n                        // initializes the array to the values {2, 4}\n                        // creates pointer p to point at the first element of\n                        // the array\nconst float *pc = (const float []){1e0, 1e1, 1e2}; // read-only compound literal\n \nstruct point {double x,y;};\n \nint main(void)\n{\n    int n = 2, *p = &n;\n    p = (int [2]){*p}; // creates an unnamed automatic array of type int[2]\n                       // initializes the first element to the value formerly\n                       // held in *p\n                       // initializes the second element to zero\n                       // stores the address of the first element in p\n \n    void drawline1(struct point from, struct point to);\n    void drawline2(struct point *from, struct point *to);\n    drawline1(\n        (struct point){.x=1, .y=1},  // creates two structs with block scope and\n        (struct point){.x=3, .y=4}); // calls drawline1, passing them by value\n    drawline2(\n        &(struct point){.x=1, .y=1},  // creates two structs with block scope and\n        &(struct point){.x=3, .y=4}); // calls drawline2, passing their addresses\n}\n \nvoid drawline1(struct point from, struct point to)\n{\n    printf(\"drawline1: `from` @ %p {%.2f, %.2f}, `to` @ %p {%.2f, %.2f}\\n\",\n        (void*)&from, from.x, from.y, (void*)&to, to.x, to.y);\n}\n \nvoid drawline2(struct point *from, struct point *to)\n{\n    printf(\"drawline2: `from` @ %p {%.2f, %.2f}, `to` @ %p {%.2f, %.2f}\\n\",\n        (void*)from, from->x, from->y, (void*)to, to->x, to->y);\n}\n```\n\nPossible output:\n\n```\ndrawline1: `from` @ 0x7ffd24facea0 {1.00, 1.00}, `to` @ 0x7ffd24face90 {3.00, 4.00}\ndrawline2: `from` @ 0x7ffd24facec0 {1.00, 1.00}, `to` @ 0x7ffd24faced0 {3.00, 4.00}\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.5.2.5 Compound literals (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.2.5 Compound literals (p: 61-63)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.2.5 Compound literals (p: 85-87)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5.2.5 Compound literals (p: 75-77)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/compound_literal](https://en.cppreference.com/w/c/language/compound_literal)"
- name: Concurrency support library
  summary: C includes built-in support for threads, atomic operations, mutual exclusion, condition variables, and thread-specific storages
  description: "# Concurrency support library\n\nC includes built-in support for threads, atomic operations, mutual exclusion, condition variables, and thread-specific storages.\n\nThese features are optionally provided:\n\n- if the macro constant `__STDC_NO_THREADS__` is defined by the compiler, the header `<threads.h>` and all of the names provided in it are not provided;\n- if the macro constant `__STDC_NO_ATOMICS__` is defined by the compiler, the header [`<stdatomic.h>`](thread#Atomic_operations \"c/thread\") and all of the names provided in it are not provided.\n\nSee also [`_Atomic` type specifier and qualifier](language/atomic \"c/language/atomic\").\n\n### Threads\n\n[TABLE]\n\n### Atomic operations\n\n[TABLE]\n\n### Mutual exclusion\n\n[TABLE]\n\n### Condition variables\n\n[TABLE]\n\n### Thread-local storage\n\n[TABLE]\n\n### Reserved identifiers\n\nIn future revisions of the C standard:\n\n- function names, type names, and enumeration constants that begin with either `cnd_`, `mtx_`, `thrd_`, or `tss_`, and a lowercase letter may be added to the declarations in the `<threads.h>` header;\n- macros that begin with `ATOMIC_` and an uppercase letter may be added to the macros defined in the [`<stdatomic.h>`](thread#Atomic_operations \"c/thread\") header;\n- typedef names that begin with either `atomic_` or `memory_`, and a lowercase letter may be added to the declarations in the [`<stdatomic.h>`](thread#Atomic_operations \"c/thread\") header;\n- enumeration constants that begin with `memory_order_` and a lowercase letter may be added to the definition of the [`memory_order`](atomic/memory_order \"c/atomic/memory order\") type in the [`<stdatomic.h>`](thread#Atomic_operations \"c/thread\") header;\n- function names that begin with `atomic_` and a lowercase letter may be added to the declarations in the [`<stdatomic.h>`](thread#Atomic_operations \"c/thread\") header.\n\nIdentifiers reserved for functions names are always potentially(since C23) reserved for use as identifiers with external linkage, while other identifiers list here are potentially(since C23) reserved when [`<stdatomic.h>`](thread#Atomic_operations \"c/thread\") is included.\n\nDeclaring, defining, or `#undef`ing such an identifier results in undefined behavior if it is provided by the standard or implementation(since C23). Portable programs should not use those identifiers.\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.17 Atomics \\<stdatomic.h\\> (p: TBD)\n  - 7.26 Threads \\<threads.h\\> (p: TBD)\n  - 7.31.8 Atomics \\<stdatomic.h\\> (p: TBD)\n  - 7.31.15 Threads \\<threads.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17 Atomics \\<stdatomic.h\\> (p: 200-209)\n  - 7.26 Threads \\<threads.h\\> (p: 274-283)\n  - 7.31.8 Atomics \\<stdatomic.h\\> (p: 332)\n  - 7.31.15 Threads \\<threads.h\\> (p: 333)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17 Atomics \\<stdatomic.h\\> (p: 273-286)\n  - 7.26 Threads \\<threads.h\\> (p: 376-387)\n  - 7.31.8 Atomics \\<stdatomic.h\\> (p: 455-456)\n  - 7.31.15 Threads \\<threads.h\\> (p: 456)\n\n### See also\n\n|                                                                                                            |     |\n|------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread \"cpp/thread\") for Concurrency support library |     |\n\n### External links\n\n|                                                                                                             |\n|-------------------------------------------------------------------------------------------------------------|\n| [GNU GCC Libc Manual: ISO C Mutexes](https://www.gnu.org/software/libc/manual/html_node/ISO-C-Mutexes.html) |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread](https://en.cppreference.com/w/c/thread)"
- name: Conditional inclusion
  summary: The preprocessor supports conditional compilation of parts of source file
  description: "# Conditional inclusion\n\nThe preprocessor supports conditional compilation of parts of source file. This behavior is controlled by `#if`, `#else`, `#elif`, `#ifdef`, `#ifndef`, `#elifdef`, `#elifndef`(since C23), and `#endif` directives.\n\n### Syntax\n\n|                        |     |             |\n|------------------------|-----|-------------|\n| `#if` expression       |     |             |\n| `#ifdef` identifier    |     |             |\n| `#ifndef` identifier   |     |             |\n| `#elif` expression     |     |             |\n| `#elifdef` identifier  |     | (since C23) |\n| `#elifndef` identifier |     | (since C23) |\n| `#else`                |     |             |\n| `#endif`               |     |             |\n\n### Explanation\n\nThe conditional preprocessing block starts with `#if`, `#ifdef` or `#ifndef` directive, then optionally includes any number of `#elif`, `#elifdef`, or `#elifndef`(since C23) directives, then optionally includes at most one `#else` directive and is terminated with `#endif` directive. Any inner conditional preprocessing blocks are processed separately.\n\nEach of `#if`, `#ifdef`, `#ifndef`, `#elif`, `#elifdef`, `#elifndef`(since C23), and `#else` directives control code block until first `#elif`, `#elifdef`, `#elifndef`(since C23), `#else`, `#endif` directive not belonging to any inner conditional preprocessing blocks.\n\n`#if`, `#ifdef` and `#ifndef` directives test the specified condition (see below) and if it evaluates to true, compiles the controlled code block. In that case subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) and `#elif` directives are ignored. Otherwise, if the specified condition evaluates false, the controlled code block is skipped and the subsequent `#else`, `#elifdef`, `#elifndef`,(since C23) or `#elif` directive (if any) is processed. If the subsequent directive is `#else`, the code block controlled by the `#else` directive is unconditionally compiled. Otherwise, the `#elif`, `#elifdef`, or `#elifndef`(since C23) directive acts as if it was `#if` directive: checks for condition, compiles or skips the controlled code block based on the result, and in the latter case processes subsequent `#elif`, `#elifdef`, `#elifndef`,(since C23) and `#else` directives. The conditional preprocessing block is terminated by `#endif` directive.\n\n### Conditional evaluation\n\n#### \\#if, \\#elif\n\nThe expression is a constant expression, using only [constants](../language/expressions#Constants_and_literals \"c/language/expressions\") and identifiers, defined using [` #define`](replace \"c/preprocessor/replace\") directive. Any identifier, which is not literal, non defined using [` #define`](replace \"c/preprocessor/replace\") directive, evaluates to `​0​` except `true` which evaluates to `1`(since C23).\n\nThe expression may contain unary operators in form `defined` identifier or `defined (`identifier`)` which return `1` if the identifier was defined using [` #define`](replace \"c/preprocessor/replace\") directive and `​0​` otherwise. In this context, `__has_include`, `__has_embed` and `__has_c_attribute` are treated as if they were the name of defined macros.(since C23) If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise. If any used identifier is not a constant, it is replaced with `​0​`.\n\n|                                                                                                                                                                                                                                                     |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| In context of a preprocessor directive, a `__has_c_attribute` expression detects whether a given attribute token is supported and its supported version. See [Attribute testing](../language/attributes#Attribute_testing \"c/language/attributes\"). | (since C23) |\n\nNote: Until [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#if `*`cond1`* ... `#elif `*`cond2`* is different from `#if `*`cond1`* ... `#else` followed by `#if `*`cond3`* because if *`cond1`* is true, the second `#if` is skipped and *`cond3`* does not need to be well-formed, while `#elif`'s *`cond2`* must be a valid expression. As of [DR 412](https://open-std.org/JTC1/SC22/WG14/www/docs/dr_412.htm), `#elif` that leads the skipped code block is also skipped.\n\n#### Combined directives\n\nChecks if the identifier was [defined as a macro name](replace \"c/preprocessor/replace\").\n\n`#ifdef` identifier is essentially equivalent to `#if defined` identifier.\n\n`#ifndef` identifier is essentially equivalent to `#if !defined` identifier.\n\n[TABLE]\n\n### Notes\n\nWhile `#elifdef` and `#elifndef` directives target C23, implementations may backport them to the older language modes as conforming extensions.\n\n### Example\n\n```\n#define ABCD 2\n#include <stdio.h>\n \nint main(void)\n{\n \n#ifdef ABCD\n    printf(\"1: yes\\n\");\n#else\n    printf(\"1: no\\n\");\n#endif\n \n#ifndef ABCD\n    printf(\"2: no1\\n\");\n#elif ABCD == 2\n    printf(\"2: yes\\n\");\n#else\n    printf(\"2: no2\\n\");\n#endif\n \n#if !defined(DCBA) && (ABCD < 2 * 4 - 3)\n    printf(\"3: yes\\n\");\n#endif\n \n// C23 directives #elifdef/#elifndef\n#ifdef CPU\n    printf(\"4: no1\\n\");\n#elifdef GPU\n    printf(\"4: no2\\n\");\n#elifndef RAM\n    printf(\"4: yes\\n\"); // selected in C23 mode, may be selected in pre-C23 mode\n#else\n    printf(\"4: no3\\n\"); // may be selected in pre-C23 mode\n#endif\n}\n```\n\nPossible output:\n\n```\n1: yes\n2: yes\n3: yes\n4: yes\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                | Correct behavior          |\n|-----------------------------------------------------------------------------|------------|------------------------------------------------------|---------------------------|\n| [DR 412](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_412) | C89        | failed `#elif`'s expression was required to be valid | failed `#elif` is skipped |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.10.1 Conditional inclusion (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.1 Conditional inclusion (p: 118-119)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.1 Conditional inclusion (p: 162-164)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.1 Conditional inclusion (p: 147-149)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.1 Conditional inclusion\n\n### See also\n\n|                                                                                                                                          |     |\n|------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/conditional \"cpp/preprocessor/conditional\") for Conditional inclusion |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/conditional](https://en.cppreference.com/w/c/preprocessor/conditional)"
- name: Conformance
  summary: 'Conformance has a three-fold definition:'
  description: "# Conformance\n\n*Conformance* has a three-fold definition:\n\n- *strictly conforming program* - uses only well-defined language constructs, that is constructs with a single behavior. It excludes unspecified, undefined, or implementation-defined behavior, and does not exceed any minimum implementation limit.\n- *conforming program* - acceptable to a conforming implementation.\n- *conforming implementation* -\n  - A conforming hosted implementation shall accept any strictly conforming program.\n  - A conforming freestanding implementation shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the freestanding standard library headers (see below).\n  - A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any strictly conforming program.\n\n### Explanation\n\nThe standard does not define any minimum implementation limit on translation units. A hosted environment has an operating system; a freestanding environment does not. A program running in a hosted environment may use all features described in the library clause (clause 7); a program running in a freestanding environment may use a subset of library features required by clause 4.\n\n#### Freestanding standard library headers\n\nAll standard library features in every fully freestanding header are required to be provided by a freestanding implementation.\n\n[TABLE]\n\n[TABLE]\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 4 Conformance (p: 4)\n- C11 standard (ISO/IEC 9899:2011):\n  - 4 Conformance (p: 8-9)\n- C99 standard (ISO/IEC 9899:1999):\n  - 4 Conformance (p: 7-8)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 1.7 Compliance\n\n### See also\n\n|                                                                                                                                   |     |\n|-----------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/freestanding \"cpp/freestanding\") for Freestanding and hosted implementation |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/conformance](https://en.cppreference.com/w/c/language/conformance)"
- name: conj
  summary: The complex conjugate of z
  description: "# conjf, conj, conjl\n\n[TABLE]\n\n1-3) Computes the [complex conjugate](https://en.wikipedia.org/wiki/Complex_conjugate \"enwiki:Complex conjugate\") of `z` by reversing the sign of the imaginary part.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `conjl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `conjf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `conj` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe complex conjugate of `z`.\n\n### Notes\n\nOn C99 implementations that do not implement `I` as [`_Imaginary_I`](imaginary_i \"c/numeric/complex/Imaginary I\"), `conj` may be used to obtain complex numbers with negative zero imaginary part. In C11, the macro [`CMPLX`](cmplx \"c/numeric/complex/CMPLX\") is used for that purpose.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = 1.0 + 2.0*I;\n    double complex z2 = conj(z);\n    printf(\"The conjugate of %.1f%+.1fi is %.1f%+.1fi\\n\",\n            creal(z), cimag(z), creal(z2), cimag(z2));\n \n    printf(\"Their product is %.1f%+.1fi\\n\", creal(z*z2), cimag(z*z2));\n}\n```\n\nOutput:\n\n```\nThe conjugate of 1.0+2.0i is 1.0-2.0i\nTheir product is 5.0+0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.4 The conj functions (p: 198)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.3 The conj functions (p: 179)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n|                                                                                                                   |     |\n|-------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/complex/conj \"cpp/numeric/complex/conj\") for `conj` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/conj](https://en.cppreference.com/w/c/numeric/complex/conj)"
- name: conjf
  summary: The complex conjugate of z
  description: "# conjf, conj, conjl\n\n[TABLE]\n\n1-3) Computes the [complex conjugate](https://en.wikipedia.org/wiki/Complex_conjugate \"enwiki:Complex conjugate\") of `z` by reversing the sign of the imaginary part.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `conjl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `conjf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `conj` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe complex conjugate of `z`.\n\n### Notes\n\nOn C99 implementations that do not implement `I` as [`_Imaginary_I`](imaginary_i \"c/numeric/complex/Imaginary I\"), `conj` may be used to obtain complex numbers with negative zero imaginary part. In C11, the macro [`CMPLX`](cmplx \"c/numeric/complex/CMPLX\") is used for that purpose.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = 1.0 + 2.0*I;\n    double complex z2 = conj(z);\n    printf(\"The conjugate of %.1f%+.1fi is %.1f%+.1fi\\n\",\n            creal(z), cimag(z), creal(z2), cimag(z2));\n \n    printf(\"Their product is %.1f%+.1fi\\n\", creal(z*z2), cimag(z*z2));\n}\n```\n\nOutput:\n\n```\nThe conjugate of 1.0+2.0i is 1.0-2.0i\nTheir product is 5.0+0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.4 The conj functions (p: 198)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.3 The conj functions (p: 179)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n|                                                                                                                   |     |\n|-------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/complex/conj \"cpp/numeric/complex/conj\") for `conj` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/conj](https://en.cppreference.com/w/c/numeric/complex/conj)"
- name: conjl
  summary: The complex conjugate of z
  description: "# conjf, conj, conjl\n\n[TABLE]\n\n1-3) Computes the [complex conjugate](https://en.wikipedia.org/wiki/Complex_conjugate \"enwiki:Complex conjugate\") of `z` by reversing the sign of the imaginary part.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `conjl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `conjf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `conj` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe complex conjugate of `z`.\n\n### Notes\n\nOn C99 implementations that do not implement `I` as [`_Imaginary_I`](imaginary_i \"c/numeric/complex/Imaginary I\"), `conj` may be used to obtain complex numbers with negative zero imaginary part. In C11, the macro [`CMPLX`](cmplx \"c/numeric/complex/CMPLX\") is used for that purpose.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = 1.0 + 2.0*I;\n    double complex z2 = conj(z);\n    printf(\"The conjugate of %.1f%+.1fi is %.1f%+.1fi\\n\",\n            creal(z), cimag(z), creal(z2), cimag(z2));\n \n    printf(\"Their product is %.1f%+.1fi\\n\", creal(z*z2), cimag(z*z2));\n}\n```\n\nOutput:\n\n```\nThe conjugate of 1.0+2.0i is 1.0-2.0i\nTheir product is 5.0+0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.4 The conj functions (p: 198)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.3 The conj functions (p: 179)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n|                                                                                                                   |     |\n|-------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/complex/conj \"cpp/numeric/complex/conj\") for `conj` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/conj](https://en.cppreference.com/w/c/numeric/complex/conj)"
- name: const
  summary: ''
  description: "# C keywords: const\n\n### Usage\n\n- [`const` type qualifier](../language/const \"c/language/const\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/const](https://en.cppreference.com/w/c/keyword/const)"
- name: const type qualifier
  summary: Each individual type in the C type system has several qualified versions of that type, corresponding to one, two, or all three of the const, volatile, and, for pointers to object types, restrict qualifiers
  description: "# const type qualifier\n\nEach individual type in the C [type system](type \"c/language/type\") has several *qualified* versions of that type, corresponding to one, two, or all three of the `const`, [`volatile`](volatile \"c/language/volatile\"), and, for pointers to object types, [`restrict`](restrict \"c/language/restrict\") qualifiers. This page describes the effects of the `const` qualifier.\n\nObjects [declared](declarations \"c/language/declarations\") with const-qualified types may be placed in read-only memory by the compiler, and if the address of a const object is never taken in a program, it may not be stored at all.\n\nAny attempt to modify an object whose type is const-qualified results in undefined behavior.\n\n```\nconst int n = 1; // object of const-qualified type\nint* p = (int*)&n;\n*p = 2; // undefined behavior\n```\n\n`const` semantics apply to [lvalue](value_category \"c/language/value category\") expressions only; whenever a const lvalue expression is used in context that does not require an lvalue, its `const` qualifier is lost (note that volatile qualifier, if present, isn't lost).\n\nThe lvalue expressions that designate objects of const-qualified type and the lvalue expressions that designate objects of struct or union type with at least one member of const-qualified type (including members of recursively contained aggregates or unions), are not *modifiable lvalues*. In particular, they are not assignable:\n\n```\nconst int n = 1; // object of const type\nn = 2; // error: the type of n is const-qualified\n \nint x = 2; // object of unqualified type\nconst int* p = &x;\n*p = 3; // error: the type of the lvalue *p is const-qualified\n \nstruct {int a; const int b; } s1 = {.b=1}, s2 = {.b=2};\ns1 = s2; // error: the type of s1 is unqualified, but it has a const member\n```\n\nA member of a const-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the `.` operator or the `->` operator).\n\n```\nstruct s { int i; const int ci; } s;\n// the type of s.i is int, the type of s.ci is const int\nconst struct s cs;\n// the types of cs.i and cs.ci are both const int\n```\n\n|                                                                                                                                                                                          |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If an array type is declared with the const type qualifier (through the use of [typedef](typedef \"c/language/typedef\")), the array type is not const-qualified, but its element type is. | (until C23) |\n| An array type and its element type are always considered to be identically const-qualified.                                                                                              | (since C23) |\n\n```\ntypedef int A[2][3];\nconst A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const int\nint* pi = a[0]; // Error: a[0] has type const int*\nvoid *unqual_ptr = a; // OK until C23; error since C23\n// Notes: clang applies the rule in C++/C23 even in C89-C17 modes\n```\n\nIf a function type is declared with the const type qualifier (through the use of [typedef](typedef \"c/language/typedef\")), the behavior is undefined.\n\n[TABLE]\n\n[TABLE]\n\nA pointer to a non-const type can be implicitly converted to a pointer to const-qualified version of the same or [compatible](compatible_type \"c/language/compatible type\") type. The reverse conversion requires a cast expression.\n\n```\nint* p = 0;\nconst int* cp = p; // OK: adds qualifiers (int to const int)\np = cp; // Error: discards qualifiers (const int to int)\np = (int*)cp; // OK: cast\n```\n\nNote that pointer to pointer to `T` is not convertible to pointer to pointer to `const T`; for two types to be compatible, their qualifications must be identical.\n\n```\nchar *p = 0;\nconst char **cpp = &p; // Error: char* and const char* are not compatible types\nchar * const *pcp = &p; // OK, adds qualifiers (char* to char*const)\n```\n\n### Keywords\n\n[`const`](https://en.cppreference.com/w/cpp/keyword/const \"cpp/keyword/const\")\n\n### Notes\n\nC adopted the *const* qualifier from C++, but unlike in C++, expressions of const-qualified type in C are not [constant expressions](constant_expression \"c/language/constant expression\"); they may not be used as [case](switch \"c/language/switch\") labels or to initialize [static](static_storage_duration \"c/language/static storage duration\") and [thread](thread_storage_duration \"c/language/thread storage duration\") storage duration objects, [enumerators](enum \"c/language/enum\"), or [bit-field](bit_field \"c/language/bit field\") sizes. When they are used as [array](array \"c/language/array\") sizes, the resulting arrays are VLAs.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.3 Type qualifiers (p: 87-90)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.3 Type qualifiers (p: 121-123)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.3 Type qualifiers (p: 108-110)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 6.5.3 Type qualifiers\n\n### See also\n\n|                                                                                                                                      |     |\n|--------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/cv \"cpp/language/cv\") for cv (`const` and `volatile`) type qualifiers |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/const](https://en.cppreference.com/w/c/language/const)"
- name: Constant expressions
  summary: Several varieties of expressions are known as constant expressions
  description: "# Constant expressions\n\nSeveral varieties of expressions are known as *constant expressions*\n\n### Preprocessor constant expression\n\nThe expression following [`#if` or `#elif`](../preprocessor/conditional \"c/preprocessor/conditional\") must expand to\n\n- [operators](expressions#Operators \"c/language/expressions\") other than [assignment](operator_assignment \"c/language/operator assignment\"), [increment, decrement](operator_incdec \"c/language/operator incdec\"), [function-call](operator_other#Function_call \"c/language/operator other\"), or [comma](operator_other#Comma_operator \"c/language/operator other\") whose arguments are preprocessor constant expressions\n- [integer constants](integer_constant \"c/language/integer constant\")\n- [character constants](character_constant \"c/language/character constant\")\n- the special preprocessor operator `defined`\n\nCharacter constants, when evaluated in `#if`-expressions, may be interpreted in the source character set, the execution character set, or some other implementation-defined character set.\n\n|                                                                                                                                                                                                                         |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Integer arithmetic in `#if`-expressions is performed using the semantics of [`intmax_t`](../types/integer \"c/types/integer\") for signed types and [`uintmax_t`](../types/integer \"c/types/integer\") for unsigned types. | (since C99) |\n\n### Integer constant expression\n\nAn integer constant expression is an expression that consists only of\n\n- [operators](expressions#Operators \"c/language/expressions\") other than [assignment](operator_assignment \"c/language/operator assignment\"), [increment, decrement](operator_incdec \"c/language/operator incdec\"), [function-call](operator_other#Function_call \"c/language/operator other\"), or [comma](operator_other#Comma_operator \"c/language/operator other\"), except that [cast](cast \"c/language/cast\") operators can only cast arithmetic types to integer types unless they are part of an operand to a sizeof, \\_Alignof(since C11) or typeof/typeof_unqual(since C23) operator.\n- [integer constants](integer_constant \"c/language/integer constant\")\n- [enumeration constants](enum \"c/language/enum\")\n- [character constants](character_constant \"c/language/character constant\")\n- [floating constants](floating_constant \"c/language/floating constant\"), but only if they are immediately used as operands of casts to integer type\n- [`sizeof`](sizeof \"c/language/sizeof\") operators whose operands are not VLA(since C99)\n\n[TABLE]\n\n[TABLE]\n\nInteger constant expressions are evaluated at compile time. The following contexts require expressions that are known as *integer constant expressions*:\n\n- The size of a [bit-field](bit_field \"c/language/bit field\").\n- The value of an [enumeration constant](enum \"c/language/enum\")\n- The `case` label of a [switch statement](switch \"c/language/switch\")\n- The size of a non-VLA(since C99) array\n- Integer to pointer implicit [conversion](conversion \"c/language/conversion\").\n\n[TABLE]\n\n### Static initializer\n\nExpressions that are used in the [initializers](initialization \"c/language/initialization\") of objects with static and thread_local [storage duration](storage_duration \"c/language/storage duration\") or declared with the `constexpr` storage-class specifier(since C23) must be either string literals or expressions that may be one of the following\n\n1) *arithmetic constant expression*, which is an expression of any arithmetic type that consists of\n\n- [operators](expressions#Operators \"c/language/expressions\") other than [assignment](operator_assignment \"c/language/operator assignment\"), [increment, decrement](operator_incdec \"c/language/operator incdec\"), [function-call](operator_other#Function_call \"c/language/operator other\"), or [comma](operator_other#Comma_operator \"c/language/operator other\"), except that [cast](cast \"c/language/cast\") operators must be converting arithmetic types to other arithmetic types unless they are part of an operand to a sizeof, \\_Alignof(since C11) or typeof/typeof_unqual(since C23) operator\n- [integer constants](integer_constant \"c/language/integer constant\")\n- [floating constants](floating_constant \"c/language/floating constant\")\n- [enumeration constants](enum \"c/language/enum\")\n- [character constants](character_constant \"c/language/character constant\")\n- [`sizeof`](sizeof \"c/language/sizeof\") operators whose operands are not VLA(since C99)\n\n[TABLE]\n\n[TABLE]\n\n2) a null pointer constant (e.g. [`NULL`](../types/null \"c/types/NULL\"))\n\n3) *address constant expression*, which is\n\n- a null pointer\n- [lvalue](value_category \"c/language/value category\") designating an object of static [storage duration](storage_duration \"c/language/storage duration\") or a function designator, converted to a pointer either\n  - by using the unary address-of operator\n  - by casting an integer constant to a pointer\n  - by array-to-pointer or function-to-pointer implicit [conversion](conversion \"c/language/conversion\")\n\n4) *address constant expression* of some complete object type, plus or minus an *integer constant expression*\n\n[TABLE]\n\n7) constant expression of one of the other forms accepted by the implementation.\n\nUnlike with integer constant expressions, static initializer expressions are not required to be evaluated at compile time; the compiler is at liberty to turn such initializers into executable code which is invoked prior to program startup.\n\n```\nstatic int i = 2 || 1 / 0; // initializes i to value 1\n```\n\nThe value of a floating-point static initializer is never less accurate than the value of the same expression executed at run time, but it may be better.\n\n### Floating-point constant expressions\n\nArithmetic constant expressions of floating-point types that are not used in static initializers are always evaluated as-if during run-time and are affected by the [current rounding](../numeric/fenv/fe_round \"c/numeric/fenv/FE round\") (if [`FENV_ACCESS`](../preprocessor/impl \"c/preprocessor/impl\") is on) and report errors as specified in [`math_errhandling`](../numeric/math/math_errhandling \"c/numeric/math/math errhandling\").\n\n```\nvoid f(void)\n{\n#pragma STDC FENV_ACCESS ON\n    static float x = 0.0/0.0; // static initializer: does not raise an exception\n    float w[] = { 0.0/0.0 }; // raises an exception\n    float y = 0.0/0.0; // raises an exception\n    double z = 0.0/0.0; // raises an exception\n}\n```\n\n### Notes\n\nIf an expression evaluates to a value that is not representable by its type, it cannot be used as a constant expression.\n\nImplementations may accept other forms of constant expressions. However, these constant expressions are not considered as integer constant expressions, arithmetic constant expressions, or address constant expressions, and thus cannot be used in the contexts requiring these kinds of constant expressions. For example, `int arr[(int)+1.0];` declares a VLA.\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.6 Constant expressions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.6 Constant expressions (p: 76-77)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.6 Constant expressions (p: 106-107)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.6 Constant expressions (p: 95-96)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.4 CONSTANT EXPRESSIONS\n\n### See also\n\n|                                                                                                                                                 |     |\n|-------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/constant_expression \"cpp/language/constant expression\") for Constant expressions |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/constant_expression](https://en.cppreference.com/w/c/language/constant_expression)"
- name: constexpr
  summary: ''
  description: "# C keywords: constexpr (since C23)\n\n### Usage\n\n- [`constexpr` specifier](../language/constexpr \"c/language/constexpr\") (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/constexpr](https://en.cppreference.com/w/c/keyword/constexpr)"
- name: constexpr specifier
  summary: A scalar object declared with the constexpr storage-class specifier is a constant
  description: "# constexpr specifier (since C23)\n\nA scalar object declared with the `constexpr` storage-class specifier is a [constant](constant_expression \"c/language/constant expression\"). It must be fully and explicitly initialized according to the static initialization rules. It still has linkage appropriate to its declaration and it exist at runtime to have its address taken; it simply cannot be modified at runtime in any way, i.e. the compiler can use its knowledge of the object’s fixed value in any other [constant expression](constant_expression \"c/language/constant expression\").\n\nAdditionally, the constant expression that is used for the initializer of such a constant is checked at compile time.\n\nAn initializer of floating-point type must be evaluated with the translation-time floating-point environment.\n\nThere are some restrictions on the type of an object that can be declared with `constexpr`. Namely, the following constructs are not allowed to be `constexpr`:\n\n- [Pointers](pointer \"c/language/pointer\") (except that null pointers can be `constexpr`),\n- Variably modified types,\n- [Atomic types](atomic \"c/language/atomic\"),\n- [`volatile`](volatile \"c/language/volatile\") types,\n- [`restrict`](restrict \"c/language/restrict\") pointers.\n\n### Keywords\n\n[`constexpr`](../keyword/constexpr \"c/keyword/constexpr\")\n\n### Notes\n\n### Example\n\n```\n#include <fenv.h>\n#include <stdio.h>\n \nint main(void)\n{\n    constexpr float f = 23.0f;\n    constexpr float g = 33.0f;\n    fesetround(FE_TOWARDZERO);\n    constexpr float h = f / g; // is not affected by fesetround() above\n    printf(\"%f\\n\", h);\n}\n```\n\nOutput:\n\n```\n0.696969\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - TBD TBD (p: TBD)\n\n### See also\n\n|                                                                                                                                   |     |\n|-----------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/constexpr \"cpp/language/constexpr\") for `constexpr` type specifier |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/constexpr](https://en.cppreference.com/w/c/language/constexpr)"
- name: constraint_handler_t
  summary: Configures the handler to be called by all bounds-checked functions on a runtime constraint violation or restores the default handler (if handler is a null pointer)
  description: "# set_constraint_handler_s, constraint_handler_t\n\n[TABLE]\n\nConfigures the handler to be called by all [bounds-checked functions](../error#Bounds_checking \"c/error\") on a runtime constraint violation or restores the default handler (if `handler` is a null pointer)\n\nThe handler must be a pointer to function of type `constraint_handler_t`, which is defined as\n\n[TABLE]\n\nOn a runtime constraint violation, it is called with the following arguments:\n\n1) pointer to character string that describes the error\n\n2) pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected\n\n3) the error about to be returned by the calling function, if it happens to be one of the functions that return `errno_t`\n\nIf `set_constraint_handler_s` is never called, the default handler is implementation-defined: it may be `abort_handler_s`, `ignore_handler_s`, or some other implementation-defined handler. As with all bounds-checked functions, `set_constraint_handler_s` and `constraint_handler_t` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including `<stdlib.h>`.\n\n### Parameters\n\n|         |     |                                                                      |\n|---------|-----|----------------------------------------------------------------------|\n| handler | \\-  | pointer to function of type `constraint_handler_t` or a null pointer |\n\n### Return value\n\nA pointer to the previously-installed runtime constraints handler. (note: this pointer is never a null pointer because calling `set_constraint_handler_s``(`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)` sets up the system default handler)\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n#ifdef __STDC_LIB_EXT1__\n    char dst[2];\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcpy_s(dst, sizeof dst, \"Too long!\");\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n    set_constraint_handler_s(abort_handler_s);\n    r = strcpy_s(dst, sizeof dst, \"Too long!\");\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n#endif\n}\n```\n\nPossible output:\n\n```\ndst = \"\", r = 22\nabort_handler_s was called in response to a runtime-constraint violation.\n \nThe runtime-constraint violation was caused by the following expression in strcpy_s:\n(s1max <= (s2_len=strnlen_s(s2, s1max)) ) (in string_s.c:62)\n \nNote to end users: This program was terminated as a result\nof a bug present in the software. Please reach out to your\nsoftware's vendor to get more help.\nAborted\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - K.3.6/2 constraint_handler_t (p: 604)\n  - K.3.6.1.1 The set_constraint_handler_s function (p: 604-605)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/error/set_constraint_handler_s](https://en.cppreference.com/w/c/error/set_constraint_handler_s)"
- name: continue
  summary: ''
  description: "# C keywords: continue\n\n### Usage\n\n- [`continue` statement](../language/continue \"c/language/continue\"): as the declaration of the statement\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/continue](https://en.cppreference.com/w/c/keyword/continue)"
- name: continue statement
  summary: Causes the remaining portion of the enclosing for, while or  do-while loop body to be skipped
  description: "# continue statement\n\nCauses the remaining portion of the enclosing [for](for \"c/language/for\"), [while](while \"c/language/while\") or [do-while](do \"c/language/do\") loop body to be skipped.\n\nUsed when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.\n\n### Syntax\n\n|                                        |     |     |\n|----------------------------------------|-----|-----|\n| attr-spec-seq(optional) `continue` `;` |     |     |\n\n|               |     |                                                                                                             |\n|---------------|-----|-------------------------------------------------------------------------------------------------------------|\n| attr-spec-seq | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the `continue` statement |\n\n### Explanation\n\nThe `continue` statement causes a jump, as if by [goto](goto \"c/language/goto\"), to the end of the loop body (it may only appear within the loop body of [for](for \"c/language/for\"), [while](while \"c/language/while\"), and [do-while](do \"c/language/do\") loops).\n\nFor [while](while \"c/language/while\") loop, it acts as\n\n```\nwhile (/* ... */) {\n   // ... \n   continue; // acts as goto contin;\n   // ... \n   contin:;\n}\n```\n\nFor [do-while](do \"c/language/do\") loop, it acts as:\n\n```\ndo {\n    // ... \n    continue; // acts as goto contin;\n    // ... \n    contin:;\n} while (/* ... */);\n```\n\nFor [for](for \"c/language/for\") loop, it acts as:\n\n```\nfor (/* ... */) {\n    // ... \n    continue; // acts as goto contin;\n    // ... \n    contin:;\n}\n```\n\n### Keywords\n\n[`continue`](../keyword/continue \"c/keyword/continue\")\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void) \n{\n    for (int i = 0; i < 10; i++) {\n        if (i != 5) continue;\n        printf(\"%d \", i);             // this statement is skipped each time i != 5\n    }\n \n    printf(\"\\n\");\n \n    for (int j = 0; j < 2; j++) {\n        for (int k = 0; k < 5; k++) { // only this loop is affected by continue\n            if (k == 3) continue;\n            printf(\"%d%d \", j, k);    // this statement is skipped each time k == 3\n        }\n    }\n}\n```\n\nOutput:\n\n```\n5\n00 01 02 04 10 11 12 14\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.8.6.2 The continue statement (p: 111)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.8.6.2 The continue statement (p: 153)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.8.6.2 The continue statement (p: 138)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.6.6.2 The continue statement\n\n### See also\n\n|                                                                                                                           |     |\n|---------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/continue \"cpp/language/continue\") for `continue` statement |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/continue](https://en.cppreference.com/w/c/language/continue)"
- name: copysign
  summary: If no errors occur, the floating point value with the magnitude of x and the sign of y is returned
  description: "# copysign, copysignf, copysignl\n\n[TABLE]\n\n1-3) Composes a floating point value with the magnitude of `x` and the sign of `y`.\n\n4) Type-generic macro: If any argument has type `long double`, `copysignl` is called. Otherwise, if any argument has integer type or has type `double`, `copysign` is called. Otherwise, `copysignf` is called.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf no errors occur, the floating point value with the magnitude of `x` and the sign of `y` is returned.\n\nIf `x` is NaN, then NaN with the sign of `y` is returned.\n\nIf `y` is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.\n\n### Error handling\n\nThis function is not subject to any errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The returned value is exact ([`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised) and independent of the current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\").\n\n### Notes\n\n`copysign` is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, [`signbit`](signbit \"c/numeric/math/signbit\") may also be used).\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"copysign(1.0,+2.0)      = %+.1f\\n\", copysign(1.0,+2.0));\n    printf(\"copysign(1.0,-2.0)      = %+.1f\\n\", copysign(1.0,-2.0));\n    printf(\"copysign(INFINITY,-2.0) = %f\\n\",    copysign(INFINITY,-2.0));\n    printf(\"copysign(NAN,-2.0)      = %f\\n\",    copysign(NAN,-2.0));\n}\n```\n\nPossible output:\n\n```\ncopysign(1.0,+2.0)      = +1.0\ncopysign(1.0,-2.0)      = -1.0\ncopysign(INFINITY,-2.0) = -inf\ncopysign(NAN,-2.0)      = -nan\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.1 The copysign functions (p: 255)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.8.1 The copysign functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.1 The copysign functions (p: 236)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.8.1 The copysign functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/copysign](https://en.cppreference.com/w/c/numeric/math/copysign)"
- name: copysignf
  summary: If no errors occur, the floating point value with the magnitude of x and the sign of y is returned
  description: "# copysign, copysignf, copysignl\n\n[TABLE]\n\n1-3) Composes a floating point value with the magnitude of `x` and the sign of `y`.\n\n4) Type-generic macro: If any argument has type `long double`, `copysignl` is called. Otherwise, if any argument has integer type or has type `double`, `copysign` is called. Otherwise, `copysignf` is called.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf no errors occur, the floating point value with the magnitude of `x` and the sign of `y` is returned.\n\nIf `x` is NaN, then NaN with the sign of `y` is returned.\n\nIf `y` is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.\n\n### Error handling\n\nThis function is not subject to any errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The returned value is exact ([`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised) and independent of the current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\").\n\n### Notes\n\n`copysign` is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, [`signbit`](signbit \"c/numeric/math/signbit\") may also be used).\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"copysign(1.0,+2.0)      = %+.1f\\n\", copysign(1.0,+2.0));\n    printf(\"copysign(1.0,-2.0)      = %+.1f\\n\", copysign(1.0,-2.0));\n    printf(\"copysign(INFINITY,-2.0) = %f\\n\",    copysign(INFINITY,-2.0));\n    printf(\"copysign(NAN,-2.0)      = %f\\n\",    copysign(NAN,-2.0));\n}\n```\n\nPossible output:\n\n```\ncopysign(1.0,+2.0)      = +1.0\ncopysign(1.0,-2.0)      = -1.0\ncopysign(INFINITY,-2.0) = -inf\ncopysign(NAN,-2.0)      = -nan\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.1 The copysign functions (p: 255)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.8.1 The copysign functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.1 The copysign functions (p: 236)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.8.1 The copysign functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/copysign](https://en.cppreference.com/w/c/numeric/math/copysign)"
- name: copysignl
  summary: If no errors occur, the floating point value with the magnitude of x and the sign of y is returned
  description: "# copysign, copysignf, copysignl\n\n[TABLE]\n\n1-3) Composes a floating point value with the magnitude of `x` and the sign of `y`.\n\n4) Type-generic macro: If any argument has type `long double`, `copysignl` is called. Otherwise, if any argument has integer type or has type `double`, `copysign` is called. Otherwise, `copysignf` is called.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf no errors occur, the floating point value with the magnitude of `x` and the sign of `y` is returned.\n\nIf `x` is NaN, then NaN with the sign of `y` is returned.\n\nIf `y` is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.\n\n### Error handling\n\nThis function is not subject to any errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The returned value is exact ([`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised) and independent of the current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\").\n\n### Notes\n\n`copysign` is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, [`signbit`](signbit \"c/numeric/math/signbit\") may also be used).\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"copysign(1.0,+2.0)      = %+.1f\\n\", copysign(1.0,+2.0));\n    printf(\"copysign(1.0,-2.0)      = %+.1f\\n\", copysign(1.0,-2.0));\n    printf(\"copysign(INFINITY,-2.0) = %f\\n\",    copysign(INFINITY,-2.0));\n    printf(\"copysign(NAN,-2.0)      = %f\\n\",    copysign(NAN,-2.0));\n}\n```\n\nPossible output:\n\n```\ncopysign(1.0,+2.0)      = +1.0\ncopysign(1.0,-2.0)      = -1.0\ncopysign(INFINITY,-2.0) = -inf\ncopysign(NAN,-2.0)      = -nan\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.1 The copysign functions (p: 255)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.8.1 The copysign functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.1 The copysign functions (p: 236)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.8.1 The copysign functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/copysign](https://en.cppreference.com/w/c/numeric/math/copysign)"
- name: cos
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# cos, cosf, cosl\n\n[TABLE]\n\n1-6) Computes the cosine of `arg` (measured in radians).\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`cosl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`cos`) is called. Otherwise, (1) (`cosf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ccosf`](../complex/ccos \"c/numeric/complex/ccos\"), [`ccos`](../complex/ccos \"c/numeric/complex/ccos\"), [`ccosl`](../complex/ccos \"c/numeric/complex/ccos\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                    |\n|-----|-----|----------------------------------------------------|\n| arg | \\-  | floating-point value representing angle in radians |\n\n### Return value\n\nIf no errors occur, the cosine of `arg` (cos(arg)) in the range \\[-1 ; +1\\], is returned.\n\n|                                                                                   |             |\n|-----------------------------------------------------------------------------------|-------------|\n| The result may have little or no significance if the magnitude of `arg` is large. | (until C99) |\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, the result is `1.0`;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nThe case where the argument is infinite is not specified to be a domain error in C, but it is defined as a [domain error in POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cos.html).\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"cos(pi/3) = %f\\n\", cos(pi / 3));\n    printf(\"cos(pi/2) = %f\\n\", cos(pi / 2));\n    printf(\"cos(-3*pi/4) = %f\\n\", cos(-3 * pi / 4));\n \n    // special values\n    printf(\"cos(+0) = %f\\n\", cos(0.0));\n    printf(\"cos(-0) = %f\\n\", cos(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cos(INFINITY) = %f\\n\", cos(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncos(pi/3) = 0.500000\ncos(pi/2) = 0.000000\ncos(-3*pi/4) = -0.707107\ncos(+0) = 1.000000\ncos(-0) = 1.000000\ncos(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.5 The cos functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.5 The cos functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.5 The cos functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.5 The cos functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.5 The cos functions (p: 239)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.5 The cos functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.5 The cos functions (p: 220)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.5 The cos functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.5 The cos function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cos](https://en.cppreference.com/w/c/numeric/math/cos)"
- name: cosf
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# cos, cosf, cosl\n\n[TABLE]\n\n1-6) Computes the cosine of `arg` (measured in radians).\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`cosl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`cos`) is called. Otherwise, (1) (`cosf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ccosf`](../complex/ccos \"c/numeric/complex/ccos\"), [`ccos`](../complex/ccos \"c/numeric/complex/ccos\"), [`ccosl`](../complex/ccos \"c/numeric/complex/ccos\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                    |\n|-----|-----|----------------------------------------------------|\n| arg | \\-  | floating-point value representing angle in radians |\n\n### Return value\n\nIf no errors occur, the cosine of `arg` (cos(arg)) in the range \\[-1 ; +1\\], is returned.\n\n|                                                                                   |             |\n|-----------------------------------------------------------------------------------|-------------|\n| The result may have little or no significance if the magnitude of `arg` is large. | (until C99) |\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, the result is `1.0`;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nThe case where the argument is infinite is not specified to be a domain error in C, but it is defined as a [domain error in POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cos.html).\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"cos(pi/3) = %f\\n\", cos(pi / 3));\n    printf(\"cos(pi/2) = %f\\n\", cos(pi / 2));\n    printf(\"cos(-3*pi/4) = %f\\n\", cos(-3 * pi / 4));\n \n    // special values\n    printf(\"cos(+0) = %f\\n\", cos(0.0));\n    printf(\"cos(-0) = %f\\n\", cos(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cos(INFINITY) = %f\\n\", cos(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncos(pi/3) = 0.500000\ncos(pi/2) = 0.000000\ncos(-3*pi/4) = -0.707107\ncos(+0) = 1.000000\ncos(-0) = 1.000000\ncos(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.5 The cos functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.5 The cos functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.5 The cos functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.5 The cos functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.5 The cos functions (p: 239)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.5 The cos functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.5 The cos functions (p: 220)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.5 The cos functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.5 The cos function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cos](https://en.cppreference.com/w/c/numeric/math/cos)"
- name: cosh
  summary: If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned
  description: "# cosh, coshf, coshl\n\n[TABLE]\n\n1-3) Computes the hyperbolic cosine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `coshl` is called. Otherwise, if the argument has integer type or the type `double`, `cosh` is called. Otherwise, `coshf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ccoshf`](http://en.cppreference.com/w/c/numeric/complex/ccosh), [`ccosh`](http://en.cppreference.com/w/c/numeric/complex/ccosh), [`ccoshl`](http://en.cppreference.com/w/c/numeric/complex/ccosh)).\n\n### Parameters\n\n|     |     |                                                      |\n|-----|-----|------------------------------------------------------|\n| arg | \\-  | floating point value representing a hyperbolic angle |\n\n### Return value\n\nIf no errors occur, the hyperbolic cosine of `arg` (cosh(arg), or earg+e-arg/2) is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0, 1 is returned\n- If the argument is ±∞, +∞ is returned\n- if the argument is NaN, NaN is returned\n\n### Notes\n\nFor the IEEE-compatible type `double`, if \\|arg\\| \\> 710.5, then `cosh(arg)` overflows.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"cosh(1) = %f\\ncosh(-1)= %f\\n\", cosh(1), cosh(-1));\n    printf(\"log(sinh(1) + cosh(1))=%f\\n\", log(sinh(1)+cosh(1)));\n    // special values\n    printf(\"cosh(+0) = %f\\ncosh(-0) = %f\\n\", cosh(0.0), cosh(-0.0));\n    // error handling \n    errno=0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cosh(710.5) = %f\\n\", cosh(710.5));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\ncosh(1) = 1.543081\ncosh(-1)= 1.543081\nlog(sinh(1) + cosh(1))=1.000000\ncosh(+0) = 1.000000\ncosh(-0) = 1.000000\ncosh(710.5) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.4 The cosh functions (p: 176)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.2.4 The cosh functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.4 The cosh functions (p: 241)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.4 The cosh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.4 The cosh functions (p: 222)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.4 The cosh functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.3.1 The cosh function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cosh](https://en.cppreference.com/w/c/numeric/math/cosh)"
- name: coshf
  summary: If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned
  description: "# cosh, coshf, coshl\n\n[TABLE]\n\n1-3) Computes the hyperbolic cosine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `coshl` is called. Otherwise, if the argument has integer type or the type `double`, `cosh` is called. Otherwise, `coshf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ccoshf`](http://en.cppreference.com/w/c/numeric/complex/ccosh), [`ccosh`](http://en.cppreference.com/w/c/numeric/complex/ccosh), [`ccoshl`](http://en.cppreference.com/w/c/numeric/complex/ccosh)).\n\n### Parameters\n\n|     |     |                                                      |\n|-----|-----|------------------------------------------------------|\n| arg | \\-  | floating point value representing a hyperbolic angle |\n\n### Return value\n\nIf no errors occur, the hyperbolic cosine of `arg` (cosh(arg), or earg+e-arg/2) is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0, 1 is returned\n- If the argument is ±∞, +∞ is returned\n- if the argument is NaN, NaN is returned\n\n### Notes\n\nFor the IEEE-compatible type `double`, if \\|arg\\| \\> 710.5, then `cosh(arg)` overflows.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"cosh(1) = %f\\ncosh(-1)= %f\\n\", cosh(1), cosh(-1));\n    printf(\"log(sinh(1) + cosh(1))=%f\\n\", log(sinh(1)+cosh(1)));\n    // special values\n    printf(\"cosh(+0) = %f\\ncosh(-0) = %f\\n\", cosh(0.0), cosh(-0.0));\n    // error handling \n    errno=0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cosh(710.5) = %f\\n\", cosh(710.5));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\ncosh(1) = 1.543081\ncosh(-1)= 1.543081\nlog(sinh(1) + cosh(1))=1.000000\ncosh(+0) = 1.000000\ncosh(-0) = 1.000000\ncosh(710.5) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.4 The cosh functions (p: 176)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.2.4 The cosh functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.4 The cosh functions (p: 241)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.4 The cosh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.4 The cosh functions (p: 222)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.4 The cosh functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.3.1 The cosh function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cosh](https://en.cppreference.com/w/c/numeric/math/cosh)"
- name: coshl
  summary: If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned
  description: "# cosh, coshf, coshl\n\n[TABLE]\n\n1-3) Computes the hyperbolic cosine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `coshl` is called. Otherwise, if the argument has integer type or the type `double`, `cosh` is called. Otherwise, `coshf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ccoshf`](http://en.cppreference.com/w/c/numeric/complex/ccosh), [`ccosh`](http://en.cppreference.com/w/c/numeric/complex/ccosh), [`ccoshl`](http://en.cppreference.com/w/c/numeric/complex/ccosh)).\n\n### Parameters\n\n|     |     |                                                      |\n|-----|-----|------------------------------------------------------|\n| arg | \\-  | floating point value representing a hyperbolic angle |\n\n### Return value\n\nIf no errors occur, the hyperbolic cosine of `arg` (cosh(arg), or earg+e-arg/2) is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0, 1 is returned\n- If the argument is ±∞, +∞ is returned\n- if the argument is NaN, NaN is returned\n\n### Notes\n\nFor the IEEE-compatible type `double`, if \\|arg\\| \\> 710.5, then `cosh(arg)` overflows.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"cosh(1) = %f\\ncosh(-1)= %f\\n\", cosh(1), cosh(-1));\n    printf(\"log(sinh(1) + cosh(1))=%f\\n\", log(sinh(1)+cosh(1)));\n    // special values\n    printf(\"cosh(+0) = %f\\ncosh(-0) = %f\\n\", cosh(0.0), cosh(-0.0));\n    // error handling \n    errno=0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cosh(710.5) = %f\\n\", cosh(710.5));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\ncosh(1) = 1.543081\ncosh(-1)= 1.543081\nlog(sinh(1) + cosh(1))=1.000000\ncosh(+0) = 1.000000\ncosh(-0) = 1.000000\ncosh(710.5) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.4 The cosh functions (p: 176)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.2.4 The cosh functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.4 The cosh functions (p: 241)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.4 The cosh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.4 The cosh functions (p: 222)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.4 The cosh functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.3.1 The cosh function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cosh](https://en.cppreference.com/w/c/numeric/math/cosh)"
- name: cosl
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# cos, cosf, cosl\n\n[TABLE]\n\n1-6) Computes the cosine of `arg` (measured in radians).\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`cosl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`cos`) is called. Otherwise, (1) (`cosf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ccosf`](../complex/ccos \"c/numeric/complex/ccos\"), [`ccos`](../complex/ccos \"c/numeric/complex/ccos\"), [`ccosl`](../complex/ccos \"c/numeric/complex/ccos\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                    |\n|-----|-----|----------------------------------------------------|\n| arg | \\-  | floating-point value representing angle in radians |\n\n### Return value\n\nIf no errors occur, the cosine of `arg` (cos(arg)) in the range \\[-1 ; +1\\], is returned.\n\n|                                                                                   |             |\n|-----------------------------------------------------------------------------------|-------------|\n| The result may have little or no significance if the magnitude of `arg` is large. | (until C99) |\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, the result is `1.0`;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nThe case where the argument is infinite is not specified to be a domain error in C, but it is defined as a [domain error in POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cos.html).\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"cos(pi/3) = %f\\n\", cos(pi / 3));\n    printf(\"cos(pi/2) = %f\\n\", cos(pi / 2));\n    printf(\"cos(-3*pi/4) = %f\\n\", cos(-3 * pi / 4));\n \n    // special values\n    printf(\"cos(+0) = %f\\n\", cos(0.0));\n    printf(\"cos(-0) = %f\\n\", cos(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cos(INFINITY) = %f\\n\", cos(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncos(pi/3) = 0.500000\ncos(pi/2) = 0.000000\ncos(-3*pi/4) = -0.707107\ncos(+0) = 1.000000\ncos(-0) = 1.000000\ncos(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.5 The cos functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.5 The cos functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.5 The cos functions (p: 174)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.5 The cos functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.5 The cos functions (p: 239)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.5 The cos functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.5 The cos functions (p: 220)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.5 The cos functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.5 The cos function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cos](https://en.cppreference.com/w/c/numeric/math/cos)"
- name: cospi
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# cospi, cospif, cospil, cospid32, cospid64, cospid128\n\n[TABLE]\n\n1-6) Computes the cosine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) (`cospi`) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the cosine of `π·arg` (cos(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, the result is `1.0`;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of cospi family\ndouble cospi(double arg)\n{\n    return cos(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"cospi(1) = %f, cos(pi) = %f\\n\", cospi(1), cos(pi));\n    printf(\"cospi(0.5) = %f, cos(pi/2) = %f\\n\", cospi(0.5), cos(pi / 2));\n    printf(\"cospi(-0.75) = %f, cos(-3*pi/4) = %f\\n\", cospi(-0.75), cos(-3 * pi / 4));\n \n    // special values\n    printf(\"cospi(+0) = %f\\n\", cospi(0.0));\n    printf(\"cospi(-0) = %f\\n\", cospi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cospi(INFINITY) = %f\\n\", cospi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncospi(1) = -1.000000, cos(pi) = -1.000000\ncospi(0.5) = 0.000000, cos(pi/2) = 0.000000\ncospi(-0.75) = -0.707107, cos(-3*pi/4) = -0.707107\ncospi(+0) = 1.000000\ncospi(-0) = 1.000000\ncospi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.12 The cospi functions (p: 247)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cospi](https://en.cppreference.com/w/c/numeric/math/cospi)"
- name: cospid128
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# cospi, cospif, cospil, cospid32, cospid64, cospid128\n\n[TABLE]\n\n1-6) Computes the cosine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) (`cospi`) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the cosine of `π·arg` (cos(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, the result is `1.0`;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of cospi family\ndouble cospi(double arg)\n{\n    return cos(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"cospi(1) = %f, cos(pi) = %f\\n\", cospi(1), cos(pi));\n    printf(\"cospi(0.5) = %f, cos(pi/2) = %f\\n\", cospi(0.5), cos(pi / 2));\n    printf(\"cospi(-0.75) = %f, cos(-3*pi/4) = %f\\n\", cospi(-0.75), cos(-3 * pi / 4));\n \n    // special values\n    printf(\"cospi(+0) = %f\\n\", cospi(0.0));\n    printf(\"cospi(-0) = %f\\n\", cospi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cospi(INFINITY) = %f\\n\", cospi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncospi(1) = -1.000000, cos(pi) = -1.000000\ncospi(0.5) = 0.000000, cos(pi/2) = 0.000000\ncospi(-0.75) = -0.707107, cos(-3*pi/4) = -0.707107\ncospi(+0) = 1.000000\ncospi(-0) = 1.000000\ncospi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.12 The cospi functions (p: 247)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cospi](https://en.cppreference.com/w/c/numeric/math/cospi)"
- name: cospid32
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# cospi, cospif, cospil, cospid32, cospid64, cospid128\n\n[TABLE]\n\n1-6) Computes the cosine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) (`cospi`) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the cosine of `π·arg` (cos(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, the result is `1.0`;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of cospi family\ndouble cospi(double arg)\n{\n    return cos(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"cospi(1) = %f, cos(pi) = %f\\n\", cospi(1), cos(pi));\n    printf(\"cospi(0.5) = %f, cos(pi/2) = %f\\n\", cospi(0.5), cos(pi / 2));\n    printf(\"cospi(-0.75) = %f, cos(-3*pi/4) = %f\\n\", cospi(-0.75), cos(-3 * pi / 4));\n \n    // special values\n    printf(\"cospi(+0) = %f\\n\", cospi(0.0));\n    printf(\"cospi(-0) = %f\\n\", cospi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cospi(INFINITY) = %f\\n\", cospi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncospi(1) = -1.000000, cos(pi) = -1.000000\ncospi(0.5) = 0.000000, cos(pi/2) = 0.000000\ncospi(-0.75) = -0.707107, cos(-3*pi/4) = -0.707107\ncospi(+0) = 1.000000\ncospi(-0) = 1.000000\ncospi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.12 The cospi functions (p: 247)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cospi](https://en.cppreference.com/w/c/numeric/math/cospi)"
- name: cospid64
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# cospi, cospif, cospil, cospid32, cospid64, cospid128\n\n[TABLE]\n\n1-6) Computes the cosine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) (`cospi`) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the cosine of `π·arg` (cos(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, the result is `1.0`;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of cospi family\ndouble cospi(double arg)\n{\n    return cos(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"cospi(1) = %f, cos(pi) = %f\\n\", cospi(1), cos(pi));\n    printf(\"cospi(0.5) = %f, cos(pi/2) = %f\\n\", cospi(0.5), cos(pi / 2));\n    printf(\"cospi(-0.75) = %f, cos(-3*pi/4) = %f\\n\", cospi(-0.75), cos(-3 * pi / 4));\n \n    // special values\n    printf(\"cospi(+0) = %f\\n\", cospi(0.0));\n    printf(\"cospi(-0) = %f\\n\", cospi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cospi(INFINITY) = %f\\n\", cospi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncospi(1) = -1.000000, cos(pi) = -1.000000\ncospi(0.5) = 0.000000, cos(pi/2) = 0.000000\ncospi(-0.75) = -0.707107, cos(-3*pi/4) = -0.707107\ncospi(+0) = 1.000000\ncospi(-0) = 1.000000\ncospi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.12 The cospi functions (p: 247)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cospi](https://en.cppreference.com/w/c/numeric/math/cospi)"
- name: cospif
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# cospi, cospif, cospil, cospid32, cospid64, cospid128\n\n[TABLE]\n\n1-6) Computes the cosine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) (`cospi`) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the cosine of `π·arg` (cos(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, the result is `1.0`;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of cospi family\ndouble cospi(double arg)\n{\n    return cos(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"cospi(1) = %f, cos(pi) = %f\\n\", cospi(1), cos(pi));\n    printf(\"cospi(0.5) = %f, cos(pi/2) = %f\\n\", cospi(0.5), cos(pi / 2));\n    printf(\"cospi(-0.75) = %f, cos(-3*pi/4) = %f\\n\", cospi(-0.75), cos(-3 * pi / 4));\n \n    // special values\n    printf(\"cospi(+0) = %f\\n\", cospi(0.0));\n    printf(\"cospi(-0) = %f\\n\", cospi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cospi(INFINITY) = %f\\n\", cospi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncospi(1) = -1.000000, cos(pi) = -1.000000\ncospi(0.5) = 0.000000, cos(pi/2) = 0.000000\ncospi(-0.75) = -0.707107, cos(-3*pi/4) = -0.707107\ncospi(+0) = 1.000000\ncospi(-0) = 1.000000\ncospi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.12 The cospi functions (p: 247)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cospi](https://en.cppreference.com/w/c/numeric/math/cospi)"
- name: cospil
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# cospi, cospif, cospil, cospid32, cospid64, cospid128\n\n[TABLE]\n\n1-6) Computes the cosine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) (`cospi`) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the cosine of `π·arg` (cos(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, the result is `1.0`;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of cospi family\ndouble cospi(double arg)\n{\n    return cos(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"cospi(1) = %f, cos(pi) = %f\\n\", cospi(1), cos(pi));\n    printf(\"cospi(0.5) = %f, cos(pi/2) = %f\\n\", cospi(0.5), cos(pi / 2));\n    printf(\"cospi(-0.75) = %f, cos(-3*pi/4) = %f\\n\", cospi(-0.75), cos(-3 * pi / 4));\n \n    // special values\n    printf(\"cospi(+0) = %f\\n\", cospi(0.0));\n    printf(\"cospi(-0) = %f\\n\", cospi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"cospi(INFINITY) = %f\\n\", cospi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncospi(1) = -1.000000, cos(pi) = -1.000000\ncospi(0.5) = 0.000000, cos(pi/2) = 0.000000\ncospi(-0.75) = -0.707107, cos(-3*pi/4) = -0.707107\ncospi(+0) = 1.000000\ncospi(-0) = 1.000000\ncospi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.12 The cospi functions (p: 247)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/cospi](https://en.cppreference.com/w/c/numeric/math/cospi)"
- name: cpow
  summary: If no errors occur, the complex power xy, is returned
  description: "# cpowf, cpow, cpowl\n\n[TABLE]\n\n1-3) Computes the complex power function x^(y), with branch cut for the first parameter along the negative real axis.\n\n4) Type-generic macro: If any argument has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cpowl` is called. if any argument has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cpow` is called, if any argument has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cpowf` is called. If the arguments are real or integer, then the macro invokes the corresponding real function (`powf`, [`pow`](http://en.cppreference.com/w/c/numeric/math/pow), `powl`). If any argument is imaginary, the corresponding complex number version is called.\n\n### Parameters\n\n|      |     |                  |\n|------|-----|------------------|\n| x, y | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex power x^(y), is returned.\n\nErrors and special cases are handled as if the operation is implemented by [`cexp`](http://en.cppreference.com/w/c/numeric/complex/cexp)`(``y``*`[`clog`](http://en.cppreference.com/w/c/numeric/complex/clog)`(``x``)``)`, except that the implementation is allowed to treat special cases more carefully.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = cpow(1.0+2.0*I, 2);\n    printf(\"(1+2i)^2 = %.1f%+.1fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = cpow(-1, 0.5);\n    printf(\"(-1+0i)^0.5 = %.1f%+.1fi\\n\", creal(z2), cimag(z2));\n \n    double complex z3 = cpow(conj(-1), 0.5); // other side of the cut\n    printf(\"(-1-0i)^0.5 = %.1f%+.1fi\\n\", creal(z3), cimag(z3));\n \n    double complex z4 = cpow(I, I); // i^i = exp(-pi/2)\n    printf(\"i^i = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\n(1+2i)^2 = -3.0+4.0i\n(-1+0i)^0.5 = 0.0+1.0i\n(-1-0i)^0.5 = 0.0-1.0i\ni^i = 0.207880+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.8.2 The cpow functions (p: 195-196)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.4.1 The cpow functions (p: 544)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.8.2 The cpow functions (p: 177)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.4.1 The cpow functions (p: 479)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cpow](https://en.cppreference.com/w/c/numeric/complex/cpow)"
- name: cpowf
  summary: If no errors occur, the complex power xy, is returned
  description: "# cpowf, cpow, cpowl\n\n[TABLE]\n\n1-3) Computes the complex power function x^(y), with branch cut for the first parameter along the negative real axis.\n\n4) Type-generic macro: If any argument has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cpowl` is called. if any argument has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cpow` is called, if any argument has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cpowf` is called. If the arguments are real or integer, then the macro invokes the corresponding real function (`powf`, [`pow`](http://en.cppreference.com/w/c/numeric/math/pow), `powl`). If any argument is imaginary, the corresponding complex number version is called.\n\n### Parameters\n\n|      |     |                  |\n|------|-----|------------------|\n| x, y | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex power x^(y), is returned.\n\nErrors and special cases are handled as if the operation is implemented by [`cexp`](http://en.cppreference.com/w/c/numeric/complex/cexp)`(``y``*`[`clog`](http://en.cppreference.com/w/c/numeric/complex/clog)`(``x``)``)`, except that the implementation is allowed to treat special cases more carefully.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = cpow(1.0+2.0*I, 2);\n    printf(\"(1+2i)^2 = %.1f%+.1fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = cpow(-1, 0.5);\n    printf(\"(-1+0i)^0.5 = %.1f%+.1fi\\n\", creal(z2), cimag(z2));\n \n    double complex z3 = cpow(conj(-1), 0.5); // other side of the cut\n    printf(\"(-1-0i)^0.5 = %.1f%+.1fi\\n\", creal(z3), cimag(z3));\n \n    double complex z4 = cpow(I, I); // i^i = exp(-pi/2)\n    printf(\"i^i = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\n(1+2i)^2 = -3.0+4.0i\n(-1+0i)^0.5 = 0.0+1.0i\n(-1-0i)^0.5 = 0.0-1.0i\ni^i = 0.207880+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.8.2 The cpow functions (p: 195-196)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.4.1 The cpow functions (p: 544)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.8.2 The cpow functions (p: 177)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.4.1 The cpow functions (p: 479)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cpow](https://en.cppreference.com/w/c/numeric/complex/cpow)"
- name: cpowl
  summary: If no errors occur, the complex power xy, is returned
  description: "# cpowf, cpow, cpowl\n\n[TABLE]\n\n1-3) Computes the complex power function x^(y), with branch cut for the first parameter along the negative real axis.\n\n4) Type-generic macro: If any argument has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cpowl` is called. if any argument has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cpow` is called, if any argument has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `cpowf` is called. If the arguments are real or integer, then the macro invokes the corresponding real function (`powf`, [`pow`](http://en.cppreference.com/w/c/numeric/math/pow), `powl`). If any argument is imaginary, the corresponding complex number version is called.\n\n### Parameters\n\n|      |     |                  |\n|------|-----|------------------|\n| x, y | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex power x^(y), is returned.\n\nErrors and special cases are handled as if the operation is implemented by [`cexp`](http://en.cppreference.com/w/c/numeric/complex/cexp)`(``y``*`[`clog`](http://en.cppreference.com/w/c/numeric/complex/clog)`(``x``)``)`, except that the implementation is allowed to treat special cases more carefully.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = cpow(1.0+2.0*I, 2);\n    printf(\"(1+2i)^2 = %.1f%+.1fi\\n\", creal(z), cimag(z));\n \n    double complex z2 = cpow(-1, 0.5);\n    printf(\"(-1+0i)^0.5 = %.1f%+.1fi\\n\", creal(z2), cimag(z2));\n \n    double complex z3 = cpow(conj(-1), 0.5); // other side of the cut\n    printf(\"(-1-0i)^0.5 = %.1f%+.1fi\\n\", creal(z3), cimag(z3));\n \n    double complex z4 = cpow(I, I); // i^i = exp(-pi/2)\n    printf(\"i^i = %f%+fi\\n\", creal(z4), cimag(z4));\n}\n```\n\nOutput:\n\n```\n(1+2i)^2 = -3.0+4.0i\n(-1+0i)^0.5 = 0.0+1.0i\n(-1-0i)^0.5 = 0.0-1.0i\ni^i = 0.207880+0.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.8.2 The cpow functions (p: 195-196)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.4.1 The cpow functions (p: 544)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.8.2 The cpow functions (p: 177)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.4.1 The cpow functions (p: 479)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cpow](https://en.cppreference.com/w/c/numeric/complex/cpow)"
- name: cproj
  summary: For most z, cproj(z)==z, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, INFINITY+0.0*I or INFINITY-0.0*I
  description: "# cprojf, cproj, cprojl\n\n[TABLE]\n\n1-3) Computes the projection of `z` on the Riemann sphere.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `cprojl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `cprojf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `cproj` is called.\n\nFor most `z`, `cproj(z)==z`, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, `INFINITY+0.0*I` or `INFINITY-0.0*I`. The sign of the imaginary (zero) component is the sign of [`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)`.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe projection of `z` on the Riemann sphere.\n\nThis function is fully specified for all possible inputs and is not subject to any errors described in [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\n### Notes\n\nThe `cproj` function helps model the Riemann sphere by mapping all infinities to one (give or take the sign of the imaginary zero), and should be used just before any operation, especially comparisons, that might give spurious results for any of the other infinities.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n#include <math.h>\n \nint main(void)\n{\n    double complex z1 = cproj(1 + 2*I);\n    printf(\"cproj(1+2i) = %.1f%+.1fi\\n\", creal(z1),cimag(z1));\n \n    double complex z2 = cproj(INFINITY+2.0*I);\n    printf(\"cproj(Inf+2i) = %.1f%+.1fi\\n\", creal(z2),cimag(z2));\n \n    double complex z3 = cproj(INFINITY-2.0*I);\n    printf(\"cproj(Inf-2i) = %.1f%+.1fi\\n\", creal(z3),cimag(z3));\n}\n```\n\nOutput:\n\n```\ncproj(1+2i) = 1.0+2.0i\ncproj(Inf+2i) = inf+0.0i\ncproj(Inf-2i) = inf-0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.5 The cproj functions (p: 198)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.4 The cproj functions (p: 179)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n|                                                                                                                   |     |\n|-------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/complex/proj \"cpp/numeric/complex/proj\") for `proj` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cproj](https://en.cppreference.com/w/c/numeric/complex/cproj)"
- name: cprojf
  summary: For most z, cproj(z)==z, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, INFINITY+0.0*I or INFINITY-0.0*I
  description: "# cprojf, cproj, cprojl\n\n[TABLE]\n\n1-3) Computes the projection of `z` on the Riemann sphere.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `cprojl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `cprojf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `cproj` is called.\n\nFor most `z`, `cproj(z)==z`, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, `INFINITY+0.0*I` or `INFINITY-0.0*I`. The sign of the imaginary (zero) component is the sign of [`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)`.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe projection of `z` on the Riemann sphere.\n\nThis function is fully specified for all possible inputs and is not subject to any errors described in [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\n### Notes\n\nThe `cproj` function helps model the Riemann sphere by mapping all infinities to one (give or take the sign of the imaginary zero), and should be used just before any operation, especially comparisons, that might give spurious results for any of the other infinities.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n#include <math.h>\n \nint main(void)\n{\n    double complex z1 = cproj(1 + 2*I);\n    printf(\"cproj(1+2i) = %.1f%+.1fi\\n\", creal(z1),cimag(z1));\n \n    double complex z2 = cproj(INFINITY+2.0*I);\n    printf(\"cproj(Inf+2i) = %.1f%+.1fi\\n\", creal(z2),cimag(z2));\n \n    double complex z3 = cproj(INFINITY-2.0*I);\n    printf(\"cproj(Inf-2i) = %.1f%+.1fi\\n\", creal(z3),cimag(z3));\n}\n```\n\nOutput:\n\n```\ncproj(1+2i) = 1.0+2.0i\ncproj(Inf+2i) = inf+0.0i\ncproj(Inf-2i) = inf-0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.5 The cproj functions (p: 198)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.4 The cproj functions (p: 179)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n|                                                                                                                   |     |\n|-------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/complex/proj \"cpp/numeric/complex/proj\") for `proj` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cproj](https://en.cppreference.com/w/c/numeric/complex/cproj)"
- name: cprojl
  summary: For most z, cproj(z)==z, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, INFINITY+0.0*I or INFINITY-0.0*I
  description: "# cprojf, cproj, cprojl\n\n[TABLE]\n\n1-3) Computes the projection of `z` on the Riemann sphere.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `cprojl` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `cprojf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `cproj` is called.\n\nFor most `z`, `cproj(z)==z`, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, `INFINITY+0.0*I` or `INFINITY-0.0*I`. The sign of the imaginary (zero) component is the sign of [`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)`.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe projection of `z` on the Riemann sphere.\n\nThis function is fully specified for all possible inputs and is not subject to any errors described in [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\n### Notes\n\nThe `cproj` function helps model the Riemann sphere by mapping all infinities to one (give or take the sign of the imaginary zero), and should be used just before any operation, especially comparisons, that might give spurious results for any of the other infinities.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n#include <math.h>\n \nint main(void)\n{\n    double complex z1 = cproj(1 + 2*I);\n    printf(\"cproj(1+2i) = %.1f%+.1fi\\n\", creal(z1),cimag(z1));\n \n    double complex z2 = cproj(INFINITY+2.0*I);\n    printf(\"cproj(Inf+2i) = %.1f%+.1fi\\n\", creal(z2),cimag(z2));\n \n    double complex z3 = cproj(INFINITY-2.0*I);\n    printf(\"cproj(Inf-2i) = %.1f%+.1fi\\n\", creal(z3),cimag(z3));\n}\n```\n\nOutput:\n\n```\ncproj(1+2i) = 1.0+2.0i\ncproj(Inf+2i) = inf+0.0i\ncproj(Inf-2i) = inf-0.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.5 The cproj functions (p: 198)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.4 The cproj functions (p: 179)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n|                                                                                                                   |     |\n|-------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/complex/proj \"cpp/numeric/complex/proj\") for `proj` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/cproj](https://en.cppreference.com/w/c/numeric/complex/cproj)"
- name: creal
  summary: The real part of z
  description: "# crealf, creal, creall\n\n[TABLE]\n\n1-3) Returns the real part of `z`.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `creall` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `crealf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `creal` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe real part of `z`.\n\nThis function is fully specified for all possible inputs and is not subject to any errors described in [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\n### Notes\n\nFor any complex variable `z`, `z ``==`` creal``(``z``)`` ``+`` I``*`[`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = 1.0 + 2.0*I;\n    printf(\"%f%+fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\n1.000000+2.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.6 The creal functions (p: 198-199)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.5 The creal functions (p: 180)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/creal](https://en.cppreference.com/w/c/numeric/complex/creal)"
- name: crealf
  summary: The real part of z
  description: "# crealf, creal, creall\n\n[TABLE]\n\n1-3) Returns the real part of `z`.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `creall` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `crealf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `creal` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe real part of `z`.\n\nThis function is fully specified for all possible inputs and is not subject to any errors described in [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\n### Notes\n\nFor any complex variable `z`, `z ``==`` creal``(``z``)`` ``+`` I``*`[`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = 1.0 + 2.0*I;\n    printf(\"%f%+fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\n1.000000+2.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.6 The creal functions (p: 198-199)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.5 The creal functions (p: 180)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/creal](https://en.cppreference.com/w/c/numeric/complex/creal)"
- name: creall
  summary: The real part of z
  description: "# crealf, creal, creall\n\n[TABLE]\n\n1-3) Returns the real part of `z`.\n\n4) Type-generic macro: if `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `long double`, `creall` is called. If `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), or `float`, `crealf` is called. If `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary), `double`, or any integer type, `creal` is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nThe real part of `z`.\n\nThis function is fully specified for all possible inputs and is not subject to any errors described in [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\n### Notes\n\nFor any complex variable `z`, `z ``==`` creal``(``z``)`` ``+`` I``*`[`cimag`](http://en.cppreference.com/w/c/numeric/complex/cimag)`(``z``)`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{    \n    double complex z = 1.0 + 2.0*I;\n    printf(\"%f%+fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\n1.000000+2.000000i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.9.6 The creal functions (p: 198-199)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.9.5 The creal functions (p: 180)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/creal](https://en.cppreference.com/w/c/numeric/complex/creal)"
- name: csin
  summary: If no errors occur, the complex sine of z
  description: "# csinf, csin, csinl\n\n[TABLE]\n\n1-3) Computes the complex sine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csin` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`sinf`, [`sin`](http://en.cppreference.com/w/c/numeric/math/sin), `sinl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`sinh`](../math/sinh \"c/numeric/math/sinh\"), implementing the formula sin(iy) = i ∙ sinh(y), and the return type of the macro is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex sine of `z`.\n\nErrors and special cases are handled as if the operation is implemented by `-``I ``*`` `[`csinh`](http://en.cppreference.com/w/c/numeric/complex/csinh)`(``I``*``z``)`\n\n### Notes\n\nThe sine is an entire function on the complex plane, and has no branch cuts. Mathematical definition of the sine is sin z =\n\neiz-e-iz/2i\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = csin(1);  // behaves like real sine along the real line\n    printf(\"sin(1+0i) = %f%+fi ( sin(1)=%f)\\n\", creal(z), cimag(z), sin(1));\n \n    double complex z2 = csin(I); // behaves like sinh along the imaginary line \n    printf(\"sin(0+1i) = %f%+fi (sinh(1)=%f)\\n\", creal(z2), cimag(z2), sinh(1));\n}\n```\n\nOutput:\n\n```\nsin(1+0i) = 0.841471+0.000000i ( sin(1)=0.841471)\nsin(0+1i) = 0.000000+1.175201i (sinh(1)=1.175201)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.3.5.5 The csin functions (p: 138-139)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 397)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.5 The csin functions (p: 191-192)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.5 The csin functions (p: 173)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/csin](https://en.cppreference.com/w/c/numeric/complex/csin)"
- name: csinf
  summary: If no errors occur, the complex sine of z
  description: "# csinf, csin, csinl\n\n[TABLE]\n\n1-3) Computes the complex sine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csin` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`sinf`, [`sin`](http://en.cppreference.com/w/c/numeric/math/sin), `sinl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`sinh`](../math/sinh \"c/numeric/math/sinh\"), implementing the formula sin(iy) = i ∙ sinh(y), and the return type of the macro is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex sine of `z`.\n\nErrors and special cases are handled as if the operation is implemented by `-``I ``*`` `[`csinh`](http://en.cppreference.com/w/c/numeric/complex/csinh)`(``I``*``z``)`\n\n### Notes\n\nThe sine is an entire function on the complex plane, and has no branch cuts. Mathematical definition of the sine is sin z =\n\neiz-e-iz/2i\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = csin(1);  // behaves like real sine along the real line\n    printf(\"sin(1+0i) = %f%+fi ( sin(1)=%f)\\n\", creal(z), cimag(z), sin(1));\n \n    double complex z2 = csin(I); // behaves like sinh along the imaginary line \n    printf(\"sin(0+1i) = %f%+fi (sinh(1)=%f)\\n\", creal(z2), cimag(z2), sinh(1));\n}\n```\n\nOutput:\n\n```\nsin(1+0i) = 0.841471+0.000000i ( sin(1)=0.841471)\nsin(0+1i) = 0.000000+1.175201i (sinh(1)=1.175201)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.3.5.5 The csin functions (p: 138-139)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 397)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.5 The csin functions (p: 191-192)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.5 The csin functions (p: 173)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/csin](https://en.cppreference.com/w/c/numeric/complex/csin)"
- name: csinh
  summary: If no errors occur, complex hyperbolic sine of z is returned
  description: "# csinhf, csinh, csinhl\n\n[TABLE]\n\n1-3) Computes the complex hyperbolic sine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`sinhf`, [`sinh`](http://en.cppreference.com/w/c/numeric/math/sinh), `sinhl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`sin`](../math/sin \"c/numeric/math/sin\"), implementing the formula sinh(iy) = i sin(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex hyperbolic sine of `z` is returned\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `csinh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``csinh``(``z``)``)`\n- `csinh(z) == -csinh(-z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `+0+∞i`, the result is `±0+NaNi` (the sign of the real part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+0+NaNi`, the result is `±0+NaNi`\n- If `z` is `x+∞i` (for any positive finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+NaNi` (for any positive finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+0i`, the result is `+∞+0i`\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+∞cis(y)`\n- If `z` is `+∞+∞i`, the result is `±∞+NaNi` (the sign of the real part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+∞+NaNi`, the result is `±∞+NaNi` (the sign of the real part is unspecified)\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any finite nonzero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\nwhere cis(y) is cos(y) + i sin(y)\n\n### Notes\n\nMathematical definition of hyperbolic sine is sinh z = ez-e-z/2\n\nHyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2πi\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = csinh(1);  // behaves like real sinh along the real line\n    printf(\"sinh(1+0i) = %f%+fi (sinh(1)=%f)\\n\", creal(z), cimag(z), sinh(1));\n \n    double complex z2 = csinh(I); // behaves like sine along the imaginary line\n    printf(\"sinh(0+1i) = %f%+fi ( sin(1)=%f)\\n\", creal(z2), cimag(z2), sin(1));\n}\n```\n\nOutput:\n\n```\nsinh(1+0i) = 1.175201+0.000000i (sinh(1)=1.175201)\nsinh(0+1i) = 0.000000+0.841471i ( sin(1)=0.841471)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.5 The csinh functions (p: 194)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.5 The csinh functions (p: 541-542)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.5 The csinh functions (p: 175-176)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.5 The csinh functions (p: 476-477)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/csinh](https://en.cppreference.com/w/c/numeric/complex/csinh)"
- name: csinhf
  summary: If no errors occur, complex hyperbolic sine of z is returned
  description: "# csinhf, csinh, csinhl\n\n[TABLE]\n\n1-3) Computes the complex hyperbolic sine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`sinhf`, [`sinh`](http://en.cppreference.com/w/c/numeric/math/sinh), `sinhl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`sin`](../math/sin \"c/numeric/math/sin\"), implementing the formula sinh(iy) = i sin(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex hyperbolic sine of `z` is returned\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `csinh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``csinh``(``z``)``)`\n- `csinh(z) == -csinh(-z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `+0+∞i`, the result is `±0+NaNi` (the sign of the real part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+0+NaNi`, the result is `±0+NaNi`\n- If `z` is `x+∞i` (for any positive finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+NaNi` (for any positive finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+0i`, the result is `+∞+0i`\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+∞cis(y)`\n- If `z` is `+∞+∞i`, the result is `±∞+NaNi` (the sign of the real part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+∞+NaNi`, the result is `±∞+NaNi` (the sign of the real part is unspecified)\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any finite nonzero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\nwhere cis(y) is cos(y) + i sin(y)\n\n### Notes\n\nMathematical definition of hyperbolic sine is sinh z = ez-e-z/2\n\nHyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2πi\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = csinh(1);  // behaves like real sinh along the real line\n    printf(\"sinh(1+0i) = %f%+fi (sinh(1)=%f)\\n\", creal(z), cimag(z), sinh(1));\n \n    double complex z2 = csinh(I); // behaves like sine along the imaginary line\n    printf(\"sinh(0+1i) = %f%+fi ( sin(1)=%f)\\n\", creal(z2), cimag(z2), sin(1));\n}\n```\n\nOutput:\n\n```\nsinh(1+0i) = 1.175201+0.000000i (sinh(1)=1.175201)\nsinh(0+1i) = 0.000000+0.841471i ( sin(1)=0.841471)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.5 The csinh functions (p: 194)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.5 The csinh functions (p: 541-542)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.5 The csinh functions (p: 175-176)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.5 The csinh functions (p: 476-477)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/csinh](https://en.cppreference.com/w/c/numeric/complex/csinh)"
- name: csinhl
  summary: If no errors occur, complex hyperbolic sine of z is returned
  description: "# csinhf, csinh, csinhl\n\n[TABLE]\n\n1-3) Computes the complex hyperbolic sine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`sinhf`, [`sinh`](http://en.cppreference.com/w/c/numeric/math/sinh), `sinhl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`sin`](../math/sin \"c/numeric/math/sin\"), implementing the formula sinh(iy) = i sin(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex hyperbolic sine of `z` is returned\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `csinh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``csinh``(``z``)``)`\n- `csinh(z) == -csinh(-z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `+0+∞i`, the result is `±0+NaNi` (the sign of the real part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+0+NaNi`, the result is `±0+NaNi`\n- If `z` is `x+∞i` (for any positive finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+NaNi` (for any positive finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+0i`, the result is `+∞+0i`\n- If `z` is `+∞+yi` (for any positive finite y), the result is `+∞cis(y)`\n- If `z` is `+∞+∞i`, the result is `±∞+NaNi` (the sign of the real part is unspecified) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `+∞+NaNi`, the result is `±∞+NaNi` (the sign of the real part is unspecified)\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any finite nonzero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\nwhere cis(y) is cos(y) + i sin(y)\n\n### Notes\n\nMathematical definition of hyperbolic sine is sinh z = ez-e-z/2\n\nHyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2πi\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = csinh(1);  // behaves like real sinh along the real line\n    printf(\"sinh(1+0i) = %f%+fi (sinh(1)=%f)\\n\", creal(z), cimag(z), sinh(1));\n \n    double complex z2 = csinh(I); // behaves like sine along the imaginary line\n    printf(\"sinh(0+1i) = %f%+fi ( sin(1)=%f)\\n\", creal(z2), cimag(z2), sin(1));\n}\n```\n\nOutput:\n\n```\nsinh(1+0i) = 1.175201+0.000000i (sinh(1)=1.175201)\nsinh(0+1i) = 0.000000+0.841471i ( sin(1)=0.841471)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.5 The csinh functions (p: 194)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.5 The csinh functions (p: 541-542)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.5 The csinh functions (p: 175-176)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.5 The csinh functions (p: 476-477)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/csinh](https://en.cppreference.com/w/c/numeric/complex/csinh)"
- name: csinl
  summary: If no errors occur, the complex sine of z
  description: "# csinf, csin, csinl\n\n[TABLE]\n\n1-3) Computes the complex sine of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csin` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csinf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`sinf`, [`sin`](http://en.cppreference.com/w/c/numeric/math/sin), `sinl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`sinh`](../math/sinh \"c/numeric/math/sinh\"), implementing the formula sin(iy) = i ∙ sinh(y), and the return type of the macro is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex sine of `z`.\n\nErrors and special cases are handled as if the operation is implemented by `-``I ``*`` `[`csinh`](http://en.cppreference.com/w/c/numeric/complex/csinh)`(``I``*``z``)`\n\n### Notes\n\nThe sine is an entire function on the complex plane, and has no branch cuts. Mathematical definition of the sine is sin z =\n\neiz-e-iz/2i\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = csin(1);  // behaves like real sine along the real line\n    printf(\"sin(1+0i) = %f%+fi ( sin(1)=%f)\\n\", creal(z), cimag(z), sin(1));\n \n    double complex z2 = csin(I); // behaves like sinh along the imaginary line \n    printf(\"sin(0+1i) = %f%+fi (sinh(1)=%f)\\n\", creal(z2), cimag(z2), sinh(1));\n}\n```\n\nOutput:\n\n```\nsin(1+0i) = 0.841471+0.000000i ( sin(1)=0.841471)\nsin(0+1i) = 0.000000+1.175201i (sinh(1)=1.175201)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.3.5.5 The csin functions (p: 138-139)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 397)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.5 The csin functions (p: 191-192)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.5 The csin functions (p: 173)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/csin](https://en.cppreference.com/w/c/numeric/complex/csin)"
- name: csqrt
  summary: If no errors occur, returns the square root of z, in the range of the right half-plane, including the imaginary axis ([0; +∞) along the real axis and (−∞; +∞) along the imaginary axis.)
  description: "# csqrtf, csqrt, csqrtl\n\n[TABLE]\n\n1-3) Computes the complex square root of `z` with branch cut along the negative real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csqrtl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csqrt` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csqrtf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`sqrtf`, [`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt), `sqrtl`). If `z` is imaginary, the corresponding complex number version is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, returns the square root of `z`, in the range of the right half-plane, including the imaginary axis (\\[0; +∞) along the real axis and (−∞; +∞) along the imaginary axis.)\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- The function is continuous onto the branch cut taking into account the sign of imaginary part\n- `csqrt``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``csqrt``(``z``)``)`\n- If `z` is `±0+0i`, the result is `+0+0i`\n- If `z` is `x+∞i`, the result is `+∞+∞i` even if x is NaN\n- If `z` is `x+NaNi`, the result is `NaN+NaNi` (unless x is ±∞) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `-∞+yi`, the result is `+0+∞i` for finite positive y\n- If `z` is `+∞+yi`, the result is `+∞+0i)` for finite positive y\n- If `z` is `-∞+NaNi`, the result is `NaN±∞i` (sign of imaginary part unspecified)\n- If `z` is `+∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+yi`, the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z1 = csqrt(-4);\n    printf(\"Square root of -4 is %.1f%+.1fi\\n\", creal(z1), cimag(z1));\n \n    double complex z2 = csqrt(conj(-4)); // or, in C11, CMPLX(-4, -0.0)\n    printf(\"Square root of -4-0i, the other side of the cut, is \"\n           \"%.1f%+.1fi\\n\", creal(z2), cimag(z2));\n}\n```\n\nOutput:\n\n```\nSquare root of -4 is 0.0+2.0i\nSquare root of -4-0i, the other side of the cut, is 0.0-2.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.8.3 The csqrt functions (p: 196)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.4.2 The csqrt functions (p: 544)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.8.3 The csqrt functions (p: 178)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.4.2 The csqrt functions (p: 479)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/csqrt](https://en.cppreference.com/w/c/numeric/complex/csqrt)"
- name: csqrtf
  summary: If no errors occur, returns the square root of z, in the range of the right half-plane, including the imaginary axis ([0; +∞) along the real axis and (−∞; +∞) along the imaginary axis.)
  description: "# csqrtf, csqrt, csqrtl\n\n[TABLE]\n\n1-3) Computes the complex square root of `z` with branch cut along the negative real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csqrtl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csqrt` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csqrtf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`sqrtf`, [`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt), `sqrtl`). If `z` is imaginary, the corresponding complex number version is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, returns the square root of `z`, in the range of the right half-plane, including the imaginary axis (\\[0; +∞) along the real axis and (−∞; +∞) along the imaginary axis.)\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- The function is continuous onto the branch cut taking into account the sign of imaginary part\n- `csqrt``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``csqrt``(``z``)``)`\n- If `z` is `±0+0i`, the result is `+0+0i`\n- If `z` is `x+∞i`, the result is `+∞+∞i` even if x is NaN\n- If `z` is `x+NaNi`, the result is `NaN+NaNi` (unless x is ±∞) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `-∞+yi`, the result is `+0+∞i` for finite positive y\n- If `z` is `+∞+yi`, the result is `+∞+0i)` for finite positive y\n- If `z` is `-∞+NaNi`, the result is `NaN±∞i` (sign of imaginary part unspecified)\n- If `z` is `+∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+yi`, the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z1 = csqrt(-4);\n    printf(\"Square root of -4 is %.1f%+.1fi\\n\", creal(z1), cimag(z1));\n \n    double complex z2 = csqrt(conj(-4)); // or, in C11, CMPLX(-4, -0.0)\n    printf(\"Square root of -4-0i, the other side of the cut, is \"\n           \"%.1f%+.1fi\\n\", creal(z2), cimag(z2));\n}\n```\n\nOutput:\n\n```\nSquare root of -4 is 0.0+2.0i\nSquare root of -4-0i, the other side of the cut, is 0.0-2.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.8.3 The csqrt functions (p: 196)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.4.2 The csqrt functions (p: 544)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.8.3 The csqrt functions (p: 178)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.4.2 The csqrt functions (p: 479)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/csqrt](https://en.cppreference.com/w/c/numeric/complex/csqrt)"
- name: csqrtl
  summary: If no errors occur, returns the square root of z, in the range of the right half-plane, including the imaginary axis ([0; +∞) along the real axis and (−∞; +∞) along the imaginary axis.)
  description: "# csqrtf, csqrt, csqrtl\n\n[TABLE]\n\n1-3) Computes the complex square root of `z` with branch cut along the negative real axis.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csqrtl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csqrt` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `csqrtf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`sqrtf`, [`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt), `sqrtl`). If `z` is imaginary, the corresponding complex number version is called.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, returns the square root of `z`, in the range of the right half-plane, including the imaginary axis (\\[0; +∞) along the real axis and (−∞; +∞) along the imaginary axis.)\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- The function is continuous onto the branch cut taking into account the sign of imaginary part\n- `csqrt``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``csqrt``(``z``)``)`\n- If `z` is `±0+0i`, the result is `+0+0i`\n- If `z` is `x+∞i`, the result is `+∞+∞i` even if x is NaN\n- If `z` is `x+NaNi`, the result is `NaN+NaNi` (unless x is ±∞) and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `-∞+yi`, the result is `+0+∞i` for finite positive y\n- If `z` is `+∞+yi`, the result is `+∞+0i)` for finite positive y\n- If `z` is `-∞+NaNi`, the result is `NaN±∞i` (sign of imaginary part unspecified)\n- If `z` is `+∞+NaNi`, the result is `+∞+NaNi`\n- If `z` is `NaN+yi`, the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z1 = csqrt(-4);\n    printf(\"Square root of -4 is %.1f%+.1fi\\n\", creal(z1), cimag(z1));\n \n    double complex z2 = csqrt(conj(-4)); // or, in C11, CMPLX(-4, -0.0)\n    printf(\"Square root of -4-0i, the other side of the cut, is \"\n           \"%.1f%+.1fi\\n\", creal(z2), cimag(z2));\n}\n```\n\nOutput:\n\n```\nSquare root of -4 is 0.0+2.0i\nSquare root of -4-0i, the other side of the cut, is 0.0-2.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.8.3 The csqrt functions (p: 196)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.4.2 The csqrt functions (p: 544)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.8.3 The csqrt functions (p: 178)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.4.2 The csqrt functions (p: 479)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/csqrt](https://en.cppreference.com/w/c/numeric/complex/csqrt)"
- name: ctan
  summary: If no errors occur, the complex tangent of z is returned
  description: "# ctanf, ctan, ctanl\n\n[TABLE]\n\n1-3) Computes the complex tangent of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctan` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`tanf`, [`tan`](http://en.cppreference.com/w/c/numeric/math/tan), `tanl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`tanh`](../math/tanh \"c/numeric/math/tanh\"), implementing the formula tan(iy) = i tanh(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex tangent of `z` is returned.\n\nErrors and special cases are handled as if the operation is implemented by `-``i ``*`` `[`ctanh`](http://en.cppreference.com/w/c/numeric/complex/ctanh)`(``i``*``z``)`, where `i` is the imaginary unit.\n\n### Notes\n\nTangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the real component, with period πi, and has poles of the first order along the real line, at coordinates (π(1/2 + n), 0). However no common floating-point representation is able to represent π/2 exactly, thus there is no value of the argument for which a pole error occurs. Mathematical definition of the tangent is tan z =\n\ni(e-iz-eiz)/e-iz+eiz\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ctan(1);  // behaves like real tangent along the real line\n    printf(\"tan(1+0i) = %f%+fi ( tan(1)=%f)\\n\", creal(z), cimag(z), tan(1));\n \n    double complex z2 = ctan(I); // behaves like tanh along the imaginary line \n    printf(\"tan(0+1i) = %f%+fi (tanh(1)=%f)\\n\", creal(z2), cimag(z2), tanh(1));\n}\n```\n\nOutput:\n\n```\ntan(1+0i) = 1.557408+0.000000i ( tan(1)=1.557408)\ntan(0+1i) = 0.000000+0.761594i (tanh(1)=0.761594)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.6 The ctan functions (p: 192)\n  - 7.25 Type-generic complex \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.6 The ctan functions (p: 174)\n  - 7.22 Type-generic complex \\<tgcomplex.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ctan](https://en.cppreference.com/w/c/numeric/complex/ctan)"
- name: ctanf
  summary: If no errors occur, the complex tangent of z is returned
  description: "# ctanf, ctan, ctanl\n\n[TABLE]\n\n1-3) Computes the complex tangent of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctan` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`tanf`, [`tan`](http://en.cppreference.com/w/c/numeric/math/tan), `tanl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`tanh`](../math/tanh \"c/numeric/math/tanh\"), implementing the formula tan(iy) = i tanh(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex tangent of `z` is returned.\n\nErrors and special cases are handled as if the operation is implemented by `-``i ``*`` `[`ctanh`](http://en.cppreference.com/w/c/numeric/complex/ctanh)`(``i``*``z``)`, where `i` is the imaginary unit.\n\n### Notes\n\nTangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the real component, with period πi, and has poles of the first order along the real line, at coordinates (π(1/2 + n), 0). However no common floating-point representation is able to represent π/2 exactly, thus there is no value of the argument for which a pole error occurs. Mathematical definition of the tangent is tan z =\n\ni(e-iz-eiz)/e-iz+eiz\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ctan(1);  // behaves like real tangent along the real line\n    printf(\"tan(1+0i) = %f%+fi ( tan(1)=%f)\\n\", creal(z), cimag(z), tan(1));\n \n    double complex z2 = ctan(I); // behaves like tanh along the imaginary line \n    printf(\"tan(0+1i) = %f%+fi (tanh(1)=%f)\\n\", creal(z2), cimag(z2), tanh(1));\n}\n```\n\nOutput:\n\n```\ntan(1+0i) = 1.557408+0.000000i ( tan(1)=1.557408)\ntan(0+1i) = 0.000000+0.761594i (tanh(1)=0.761594)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.6 The ctan functions (p: 192)\n  - 7.25 Type-generic complex \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.6 The ctan functions (p: 174)\n  - 7.22 Type-generic complex \\<tgcomplex.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ctan](https://en.cppreference.com/w/c/numeric/complex/ctan)"
- name: ctanh
  summary: If no errors occur, complex hyperbolic tangent of z is returned
  description: "# ctanhf, ctanh, ctanhl\n\n[TABLE]\n\n1-3) Computes the complex hyperbolic tangent of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`tanhf`, [`tanh`](http://en.cppreference.com/w/c/numeric/math/tanh), `tanhl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`tan`](../math/tan \"c/numeric/math/tan\"), implementing the formula tanh(iy) = i tan(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex hyperbolic tangent of `z` is returned\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `ctanh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``ctanh``(``z``)``)`\n- `ctanh(-z) == -ctanh(z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `x+∞i` (for any^([\\[1\\]](#cite_note-1)) finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+NaN` (for any^([\\[2\\]](#cite_note-2)) finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+yi` (for any finite positive y), the result is `1+0i`\n- If `z` is `+∞+∞i`, the result is `1±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `+∞+NaNi`, the result is `1±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any non-zero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n1.  per [DR471](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1892.htm#dr_471), this only holds for non-zero x. If `z` is `0+∞i`, the result should be `0+NaNi`\n2.  per [DR471](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1892.htm#dr_471), this only holds for non-zero x. If `z` is `0+NaNi`, the result should be `0+NaNi`\n\n### Notes\n\nMathematical definition of hyperbolic tangent is tanh z = ez-e-z/ez+e-z\n\nHyperbolic tangent is an analytical function on the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period πi, and has poles of the first order along the imaginary line, at coordinates (0, π(1/2 + n)). However no common floating-point representation is able to represent π/2 exactly, thus there is no value of the argument for which a pole error occurs.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ctanh(1);  // behaves like real tanh along the real line\n    printf(\"tanh(1+0i) = %f%+fi (tanh(1)=%f)\\n\", creal(z), cimag(z), tanh(1));\n \n    double complex z2 = ctanh(I); // behaves like tangent along the imaginary line\n    printf(\"tanh(0+1i) = %f%+fi ( tan(1)=%f)\\n\", creal(z2), cimag(z2), tan(1));\n}\n```\n\nOutput:\n\n```\ntanh(1+0i) = 0.761594+0.000000i (tanh(1)=0.761594)\ntanh(0+1i) = 0.000000+1.557408i ( tan(1)=1.557408)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.6 The ctanh functions (p: 194)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.6 The ctanh functions (p: 542)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.6 The ctanh functions (p: 176)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.6 The ctanh functions (p: 477)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ctanh](https://en.cppreference.com/w/c/numeric/complex/ctanh)"
- name: ctanhf
  summary: If no errors occur, complex hyperbolic tangent of z is returned
  description: "# ctanhf, ctanh, ctanhl\n\n[TABLE]\n\n1-3) Computes the complex hyperbolic tangent of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`tanhf`, [`tanh`](http://en.cppreference.com/w/c/numeric/math/tanh), `tanhl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`tan`](../math/tan \"c/numeric/math/tan\"), implementing the formula tanh(iy) = i tan(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex hyperbolic tangent of `z` is returned\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `ctanh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``ctanh``(``z``)``)`\n- `ctanh(-z) == -ctanh(z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `x+∞i` (for any^([\\[1\\]](#cite_note-1)) finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+NaN` (for any^([\\[2\\]](#cite_note-2)) finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+yi` (for any finite positive y), the result is `1+0i`\n- If `z` is `+∞+∞i`, the result is `1±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `+∞+NaNi`, the result is `1±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any non-zero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n1.  per [DR471](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1892.htm#dr_471), this only holds for non-zero x. If `z` is `0+∞i`, the result should be `0+NaNi`\n2.  per [DR471](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1892.htm#dr_471), this only holds for non-zero x. If `z` is `0+NaNi`, the result should be `0+NaNi`\n\n### Notes\n\nMathematical definition of hyperbolic tangent is tanh z = ez-e-z/ez+e-z\n\nHyperbolic tangent is an analytical function on the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period πi, and has poles of the first order along the imaginary line, at coordinates (0, π(1/2 + n)). However no common floating-point representation is able to represent π/2 exactly, thus there is no value of the argument for which a pole error occurs.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ctanh(1);  // behaves like real tanh along the real line\n    printf(\"tanh(1+0i) = %f%+fi (tanh(1)=%f)\\n\", creal(z), cimag(z), tanh(1));\n \n    double complex z2 = ctanh(I); // behaves like tangent along the imaginary line\n    printf(\"tanh(0+1i) = %f%+fi ( tan(1)=%f)\\n\", creal(z2), cimag(z2), tan(1));\n}\n```\n\nOutput:\n\n```\ntanh(1+0i) = 0.761594+0.000000i (tanh(1)=0.761594)\ntanh(0+1i) = 0.000000+1.557408i ( tan(1)=1.557408)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.6 The ctanh functions (p: 194)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.6 The ctanh functions (p: 542)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.6 The ctanh functions (p: 176)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.6 The ctanh functions (p: 477)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ctanh](https://en.cppreference.com/w/c/numeric/complex/ctanh)"
- name: ctanhl
  summary: If no errors occur, complex hyperbolic tangent of z is returned
  description: "# ctanhf, ctanh, ctanhl\n\n[TABLE]\n\n1-3) Computes the complex hyperbolic tangent of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanhl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanh` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanhf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`tanhf`, [`tanh`](http://en.cppreference.com/w/c/numeric/math/tanh), `tanhl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`tan`](../math/tan \"c/numeric/math/tan\"), implementing the formula tanh(iy) = i tan(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, complex hyperbolic tangent of `z` is returned\n\n### Error handling and special values\n\nErrors are reported consistent with [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\")\n\nIf the implementation supports IEEE floating-point arithmetic,\n\n- `ctanh``(`[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``z``)``)`` ``==`` `[`conj`](http://en.cppreference.com/w/c/numeric/complex/conj)`(``ctanh``(``z``)``)`\n- `ctanh(-z) == -ctanh(z)`\n- If `z` is `+0+0i`, the result is `+0+0i`\n- If `z` is `x+∞i` (for any^([\\[1\\]](#cite_note-1)) finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `z` is `x+NaN` (for any^([\\[2\\]](#cite_note-2)) finite x), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `+∞+yi` (for any finite positive y), the result is `1+0i`\n- If `z` is `+∞+∞i`, the result is `1±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `+∞+NaNi`, the result is `1±0i` (the sign of the imaginary part is unspecified)\n- If `z` is `NaN+0i`, the result is `NaN+0i`\n- If `z` is `NaN+yi` (for any non-zero y), the result is `NaN+NaNi` and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `z` is `NaN+NaNi`, the result is `NaN+NaNi`\n\n1.  per [DR471](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1892.htm#dr_471), this only holds for non-zero x. If `z` is `0+∞i`, the result should be `0+NaNi`\n2.  per [DR471](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1892.htm#dr_471), this only holds for non-zero x. If `z` is `0+NaNi`, the result should be `0+NaNi`\n\n### Notes\n\nMathematical definition of hyperbolic tangent is tanh z = ez-e-z/ez+e-z\n\nHyperbolic tangent is an analytical function on the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period πi, and has poles of the first order along the imaginary line, at coordinates (0, π(1/2 + n)). However no common floating-point representation is able to represent π/2 exactly, thus there is no value of the argument for which a pole error occurs.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ctanh(1);  // behaves like real tanh along the real line\n    printf(\"tanh(1+0i) = %f%+fi (tanh(1)=%f)\\n\", creal(z), cimag(z), tanh(1));\n \n    double complex z2 = ctanh(I); // behaves like tangent along the imaginary line\n    printf(\"tanh(0+1i) = %f%+fi ( tan(1)=%f)\\n\", creal(z2), cimag(z2), tan(1));\n}\n```\n\nOutput:\n\n```\ntanh(1+0i) = 0.761594+0.000000i (tanh(1)=0.761594)\ntanh(0+1i) = 0.000000+1.557408i ( tan(1)=1.557408)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.6.6 The ctanh functions (p: 194)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - G.6.2.6 The ctanh functions (p: 542)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.6.6 The ctanh functions (p: 176)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - G.6.2.6 The ctanh functions (p: 477)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ctanh](https://en.cppreference.com/w/c/numeric/complex/ctanh)"
- name: ctanl
  summary: If no errors occur, the complex tangent of z is returned
  description: "# ctanf, ctan, ctanl\n\n[TABLE]\n\n1-3) Computes the complex tangent of `z`.\n\n4) Type-generic macro: If `z` has type `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanl` is called. if `z` has type `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctan` is called, if `z` has type `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), `ctanf` is called. If `z` is real or integer, then the macro invokes the corresponding real function (`tanf`, [`tan`](http://en.cppreference.com/w/c/numeric/math/tan), `tanl`). If `z` is imaginary, then the macro invokes the corresponding real version of the function [`tanh`](../math/tanh \"c/numeric/math/tanh\"), implementing the formula tan(iy) = i tanh(y), and the return type is imaginary.\n\n### Parameters\n\n|     |     |                  |\n|-----|-----|------------------|\n| z   | \\-  | complex argument |\n\n### Return value\n\nIf no errors occur, the complex tangent of `z` is returned.\n\nErrors and special cases are handled as if the operation is implemented by `-``i ``*`` `[`ctanh`](http://en.cppreference.com/w/c/numeric/complex/ctanh)`(``i``*``z``)`, where `i` is the imaginary unit.\n\n### Notes\n\nTangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the real component, with period πi, and has poles of the first order along the real line, at coordinates (π(1/2 + n), 0). However no common floating-point representation is able to represent π/2 exactly, thus there is no value of the argument for which a pole error occurs. Mathematical definition of the tangent is tan z =\n\ni(e-iz-eiz)/e-iz+eiz\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n \nint main(void)\n{\n    double complex z = ctan(1);  // behaves like real tangent along the real line\n    printf(\"tan(1+0i) = %f%+fi ( tan(1)=%f)\\n\", creal(z), cimag(z), tan(1));\n \n    double complex z2 = ctan(I); // behaves like tanh along the imaginary line \n    printf(\"tan(0+1i) = %f%+fi (tanh(1)=%f)\\n\", creal(z2), cimag(z2), tanh(1));\n}\n```\n\nOutput:\n\n```\ntan(1+0i) = 1.557408+0.000000i ( tan(1)=1.557408)\ntan(0+1i) = 0.000000+0.761594i (tanh(1)=0.761594)\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.5.6 The ctan functions (p: 192)\n  - 7.25 Type-generic complex \\<tgmath.h\\> (p: 373-375)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 545)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.5.6 The ctan functions (p: 174)\n  - 7.22 Type-generic complex \\<tgcomplex.h\\> (p: 335-337)\n  - G.7 Type-generic math \\<tgmath.h\\> (p: 480)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/ctan](https://en.cppreference.com/w/c/numeric/complex/ctan)"
- name: ctime
  summary: 'The resulting string has the following format:'
  description: "# ctime, ctime_s\n\n[TABLE]\n\n1) Converts given time since epoch to a calendar local time and then to a textual representation, as if by calling [`asctime`](http://en.cppreference.com/w/c/chrono/asctime)`(`[`localtime`](http://en.cppreference.com/w/c/chrono/localtime)`(``timer``)``)` or [`asctime`](http://en.cppreference.com/w/c/chrono/asctime)`(``localtime_r``(``timer, ``&``(``struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm)`)``{``0``}``)``)`(since C23). This function is deprecated and should not be used in new code.(since C23)\n\n2) Same as (1), except that the function is equivalent to `asctime_s``(``buf, bufsz, localtime_s``(``timer, ``&``(``struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm)`)``{``0``}``)``)`, and the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `buf` or `timer` is a null pointer\n- `bufsz` is less than `26` or greater than `RSIZE_MAX`\n\nAs with all bounds-checked functions, `ctime_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<time.h>`](../chrono \"c/chrono\").\n\nThe resulting string has the following format:\n\n```\nWww Mmm dd hh:mm:ss yyyy\\n\n```\n\n- `Www` - the day of the week (one of `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`).\n- `Mmm` - the month (one of `Jan`, `Feb`, `Mar`, `Apr`, `May`, `Jun`, `Jul`, `Aug`, `Sep`, `Oct`, `Nov`, `Dec`).\n- `dd` - the day of the month\n- `hh` - hours\n- `mm` - minutes\n- `ss` - seconds\n- `yyyy` - years\n\nThe function does not support localization.\n\n### Parameters\n\n|       |     |                                                                                       |\n|-------|-----|---------------------------------------------------------------------------------------|\n| timer | \\-  | pointer to a [`time_t`](time_t \"c/chrono/time t\") object specifying the time to print |\n| buf   | \\-  | pointer to the first element of a char array of size at least `bufsz`                 |\n| bufsz | \\-  | max number of bytes to output, typically the size of the buffer pointed to by `buf`   |\n\n### Return value\n\n1) pointer to a static null-terminated character string holding the textual representation of date and time. The string may be shared between [`asctime`](asctime \"c/chrono/asctime\") and `ctime`, and may be overwritten on each invocation of any of those functions.\n\n2) zero on success (in which case the string representation of time has been written out to the array pointed to by `buf`), or non-zero on failure (in which case, the terminating null character is always written to `buf[0]` unless `buf` is a null pointer or `bufsz` is zero or greater than `RSIZE_MAX`.\n\n### Notes\n\n`ctime` returns a pointer to static data and is not thread-safe. In addition, it modifies the static [`tm`](tm \"c/chrono/tm\") object which may be shared with [`gmtime`](gmtime \"c/chrono/gmtime\") and [`localtime`](localtime \"c/chrono/localtime\"). POSIX marks this function obsolete and recommends [`strftime`](strftime \"c/chrono/strftime\") instead. The C standard also recommends [`strftime`](strftime \"c/chrono/strftime\") instead of `ctime` and `ctime_s` because `strftime` is more flexible and locale-sensitive.\n\nThe behavior of `ctime` is undefined for the values of [`time_t`](time_t \"c/chrono/time t\") that result in the string longer than 25 characters (e.g. year 10000).\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <time.h>\n#include <stdio.h>\n \nint main(void)\n{\n    time_t result = time(NULL);\n    printf(\"%s\", ctime(&result));\n \n#ifdef __STDC_LIB_EXT1__\n    char str[26];\n    ctime_s(str,sizeof str,&result);\n    printf(\"%s\", str);\n#endif\n}\n```\n\nPossible output:\n\n```\nTue May 26 21:51:03 2015\nTue May 26 21:51:03 2015\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.3.2 The ctime function (p: 287-288)\n  - K.3.8.2.2 The ctime_s function (p: 454)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.3.2 The ctime function (p: 393)\n  - K.3.8.2.2 The ctime_s function (p: 626)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.2 The ctime function (p: 342)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.2 The ctime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/ctime](https://en.cppreference.com/w/c/chrono/ctime)"
- name: ctime_s
  summary: 'The resulting string has the following format:'
  description: "# ctime, ctime_s\n\n[TABLE]\n\n1) Converts given time since epoch to a calendar local time and then to a textual representation, as if by calling [`asctime`](http://en.cppreference.com/w/c/chrono/asctime)`(`[`localtime`](http://en.cppreference.com/w/c/chrono/localtime)`(``timer``)``)` or [`asctime`](http://en.cppreference.com/w/c/chrono/asctime)`(``localtime_r``(``timer, ``&``(``struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm)`)``{``0``}``)``)`(since C23). This function is deprecated and should not be used in new code.(since C23)\n\n2) Same as (1), except that the function is equivalent to `asctime_s``(``buf, bufsz, localtime_s``(``timer, ``&``(``struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm)`)``{``0``}``)``)`, and the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `buf` or `timer` is a null pointer\n- `bufsz` is less than `26` or greater than `RSIZE_MAX`\n\nAs with all bounds-checked functions, `ctime_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<time.h>`](../chrono \"c/chrono\").\n\nThe resulting string has the following format:\n\n```\nWww Mmm dd hh:mm:ss yyyy\\n\n```\n\n- `Www` - the day of the week (one of `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`).\n- `Mmm` - the month (one of `Jan`, `Feb`, `Mar`, `Apr`, `May`, `Jun`, `Jul`, `Aug`, `Sep`, `Oct`, `Nov`, `Dec`).\n- `dd` - the day of the month\n- `hh` - hours\n- `mm` - minutes\n- `ss` - seconds\n- `yyyy` - years\n\nThe function does not support localization.\n\n### Parameters\n\n|       |     |                                                                                       |\n|-------|-----|---------------------------------------------------------------------------------------|\n| timer | \\-  | pointer to a [`time_t`](time_t \"c/chrono/time t\") object specifying the time to print |\n| buf   | \\-  | pointer to the first element of a char array of size at least `bufsz`                 |\n| bufsz | \\-  | max number of bytes to output, typically the size of the buffer pointed to by `buf`   |\n\n### Return value\n\n1) pointer to a static null-terminated character string holding the textual representation of date and time. The string may be shared between [`asctime`](asctime \"c/chrono/asctime\") and `ctime`, and may be overwritten on each invocation of any of those functions.\n\n2) zero on success (in which case the string representation of time has been written out to the array pointed to by `buf`), or non-zero on failure (in which case, the terminating null character is always written to `buf[0]` unless `buf` is a null pointer or `bufsz` is zero or greater than `RSIZE_MAX`.\n\n### Notes\n\n`ctime` returns a pointer to static data and is not thread-safe. In addition, it modifies the static [`tm`](tm \"c/chrono/tm\") object which may be shared with [`gmtime`](gmtime \"c/chrono/gmtime\") and [`localtime`](localtime \"c/chrono/localtime\"). POSIX marks this function obsolete and recommends [`strftime`](strftime \"c/chrono/strftime\") instead. The C standard also recommends [`strftime`](strftime \"c/chrono/strftime\") instead of `ctime` and `ctime_s` because `strftime` is more flexible and locale-sensitive.\n\nThe behavior of `ctime` is undefined for the values of [`time_t`](time_t \"c/chrono/time t\") that result in the string longer than 25 characters (e.g. year 10000).\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <time.h>\n#include <stdio.h>\n \nint main(void)\n{\n    time_t result = time(NULL);\n    printf(\"%s\", ctime(&result));\n \n#ifdef __STDC_LIB_EXT1__\n    char str[26];\n    ctime_s(str,sizeof str,&result);\n    printf(\"%s\", str);\n#endif\n}\n```\n\nPossible output:\n\n```\nTue May 26 21:51:03 2015\nTue May 26 21:51:03 2015\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.3.2 The ctime function (p: 287-288)\n  - K.3.8.2.2 The ctime_s function (p: 454)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.3.2 The ctime function (p: 393)\n  - K.3.8.2.2 The ctime_s function (p: 626)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.2 The ctime function (p: 342)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.2 The ctime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/ctime](https://en.cppreference.com/w/c/chrono/ctime)"
- name: Current Status
  summary: 'Recent milestones: C17 published, C23 underway'
  description: "# Current Status\n\n**Recent milestones: C17 published, C23 underway**\n\nC17 has been published, and work is now underway on C23.\n\n[The current schedule is in paper N2984](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2984.pdf).\n\nYou can also visit [open-std.org](https://www.open-std.org/jtc1/sc22/wg14/www/documents) to get the latest C standards committee papers. Reading through those proposals, you can track the C developing trends and know how does a cool idea turned into the standard. However, those papers **ARE NOT** and also **SHOULD NOT BE TREATED AS** the standard documents.\n\n### See also\n\n|                                                                                                               |     |\n|---------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/current_status \"cpp/current status\") for Current status |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/current_status](https://en.cppreference.com/w/c/current_status)"
- name: Date and time utilities
  summary: ''
  description: "# Date and time utilities\n\n### Functions\n\n[TABLE]\n\n### Constants\n\n[TABLE]\n\n### Types\n\n[TABLE]\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27 Date and time \\<time.h\\> (p: 284-291)\n  - 7.29.5.1 The wcsftime function (p: 320-321)\n  - 7.31.14 Date and time \\<time.h\\> (p: 333)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27 Date and time \\<time.h\\> (p: 388-397)\n  - 7.29.5.1 The wcsftime function (p: 439-440)\n  - 7.31.14 Date and time \\<time.h\\> (p: 456)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23 Date and time \\<time.h\\> (p: 338-347)\n  - 7.24.5.1 The wcsftime function (p: 385-386)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12 DATE AND TIME \\<time.h\\>\n\n### See also\n\n|                                                                                                              |     |\n|--------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/chrono/c \"cpp/chrono/c\") for C Date and time utilities |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono](https://en.cppreference.com/w/c/chrono)"
- name: Declarations
  summary: A declaration is a C language construct that introduces one or more identifiers into the program and specifies their meaning and properties
  description: "# Declarations\n\nA *declaration* is a C language construct that introduces one or more [identifiers](identifier \"c/language/identifier\") into the program and specifies their meaning and properties.\n\nDeclarations may appear in any scope. Each declaration ends with a semicolon (just like [a statement](statements \"c/language/statements\")) and consists of two(until C23)three(since C23) distinct parts:\n\n|                                                                          |       |             |\n|--------------------------------------------------------------------------|-------|-------------|\n| specifiers-and-qualifiers declarators-and-initializers(optional) `;`     | \\(1\\) |             |\n| attr-spec-seq specifiers-and-qualifiers declarators-and-initializers `;` | \\(2\\) | (since C23) |\n| attr-spec-seq `;`                                                        | \\(3\\) | (since C23) |\n\nwhere\n\n[TABLE]\n\n1-2) Simple declaration. Introduces one or more identifiers which denotes objects, functions, struct/union/enum tags, typedefs, or enumeration constants.\n\n3) Attribute declaration. Does not declares any identifier, and has implementation-defined meaning if the meaning is not specified by the standard.\n\nFor example,\n\n```\nint a, *b=NULL; // \"int\" is the type specifier,\n                // \"a\" is a declarator\n                // \"*b\" is a declarator and NULL is its initializer\nconst int *f(void); // \"int\" is the type specifier\n                    // \"const\" is the type qualifier\n                    // \"*f(void)\" is the declarator\nenum COLOR {RED, GREEN, BLUE} c; // \"enum COLOR {RED, GREEN, BLUE}\" is the type specifier\n                                 // \"c\" is the declarator\n```\n\nThe type of each identifier introduced in a declaration is determined by a combination of the type specified by the type specifier and the type modifications applied by its declarator. The type of a variable might also be inferred if `auto` specifier is used.(since C23)\n\n[Attributes](attributes \"c/language/attributes\")(since C23) may appear in specifiers-and-qualifiers, in which case they apply to the type determined by the preceding specifiers.\n\n### Declarators\n\nEach declarator is one of the following:\n\n[TABLE]\n\n1) the identifier that this declarator introduces.\n\n2) any declarator may be enclosed in parentheses; this is required to introduce pointers to arrays and pointers to functions.\n\n3) [pointer declarator](pointer \"c/language/pointer\"): the declaration `S * cvr D`; declares `D` as a cvr-qualified pointer to the type determined by `S`.\n\n4) [array declarator](array \"c/language/array\"): the declaration `S D[N]` declares `D` as an array of `N` objects of the type determined by `S`. noptr-declarator is any other declarator except unparenthesized pointer declarator.\n\n5) [function declarator](function_declaration \"c/language/function declaration\"): the declaration `S D(params)` declared `D` as a function taking the parameters `params` and returning `S`. noptr-declarator is any other declarator except unparenthesized pointer declarator.\n\nThe reasoning behind this syntax is that when the identifier declared by the declarator appears in an expression of the same form as the declarator, it would have the type specified by the type specifier sequence.\n\n```\nstruct C {\n    int member; // \"int\" is the type specifier \n                // \"member\" is the declarator\n} obj, *pObj = &obj;\n// \"struct C { int member; }\" is the type specifier\n// declarator \"obj\" defines an object of type struct C\n// declarator \"*pObj\" declares a pointer to C,\n// initializer \"= &obj\" provides the initial value for that pointer\n \nint a = 1, *p = NULL, f(void), (*pf)(double);\n// the type specifier is \"int\"\n// declarator \"a\" defines an object of type int\n//   initializer \"=1\" provides its initial value\n// declarator \"*p\" defines an object of type pointer to int\n//   initializer \"=NULL\" provides its initial value\n// declarator \"f(void)\" declares a function taking void and returning int\n// declarator \"(*pf)(double)\" defines an object of type pointer\n//   to function taking double and returning int\n \nint (*(*foo)(double))[3] = NULL;\n// the type specifier is int\n// 1. declarator \"(*(*foo)(double))[3]\" is an array declarator:\n//    the type declared is \"/nested declarator/ array of 3 int\"\n// 2. the nested declarator is \"*(*foo)(double))\", which is a pointer declarator\n//    the type declared is \"/nested declarator/ pointer to array of 3 int\"\n// 3. the nested declarator is \"(*foo)(double)\", which is a function declarator\n//    the type declared is \"/nested declarator/ function taking double and returning\n//        pointer to array of 3 int\"\n// 4. the nested declarator is \"(*foo)\" which is a (parenthesized, as required by\n//        function declarator syntax) pointer declarator.\n//    the type declared is \"/nested declarator/ pointer to function taking double\n//        and returning pointer to array of 3 int\"\n// 5. the nested declarator is \"foo\", which is an identifier.\n// The declaration introduces the identifier \"foo\" to refer to an object of type\n// \"pointer to function taking double and returning pointer to array of 3 int\"\n// The initializer \"= NULL\" provides the initial value of this pointer.\n \n// If \"foo\" is used in an expression of the form of the declarator, its type would be\n// int.\nint x = (*(*foo)(1.2))[0];\n```\n\nThe end of every declarator that is not part of another declarator is a [sequence point](eval_order \"c/language/eval order\").\n\nIn all cases, attr-spec-seq is an optional sequence of [attributes](attributes \"c/language/attributes\")(since C23). When appearing immediately after the identifier, it applies to the object or function being declared.\n\n### Definitions\n\nA *definition* is a declaration that provides all information about the identifiers it declares.\n\nEvery declaration of an [enum](enum \"c/language/enum\") or a [typedef](typedef \"c/language/typedef\") is a definition.\n\nFor functions, a declaration that includes the function body is a [function definition](function_definition \"c/language/function definition\"):\n\n```\nint foo(double); // declaration\nint foo(double x){ return x; } // definition\n```\n\nFor objects, a declaration that allocates storage ([automatic or static](storage_duration \"c/language/storage duration\"), but not extern) is a definition, while a declaration that does not allocate storage ([external declaration](extern \"c/language/extern\")) is not.\n\n```\nextern int n; // declaration\nint n = 10; // definition\n```\n\nFor [structs](struct \"c/language/struct\") and [unions](union \"c/language/union\"), declarations that specify the list of members are definitions:\n\n```\nstruct X; // declaration\nstruct X { int n; }; // definition\n```\n\n### Redeclaration\n\nA declaration cannot introduce an identifier if another declaration for the same identifier in the same [scope](scope \"c/language/scope\") appears earlier, except that\n\n- Declarations of objects [with linkage](storage_duration \"c/language/storage duration\") (external or internal) can be repeated:\n\n```\nextern int x;\nint x = 10; // OK\nextern int x; // OK\n \nstatic int n;\nstatic int n = 10; // OK\nstatic int n; // OK\n```\n\n- Non-VLA [typedef](typedef \"c/language/typedef\") can be repeated as long as it names the same type:\n\n```\ntypedef int int_t; \ntypedef int int_t; // OK\n```\n\n- [struct](struct \"c/language/struct\") and [union](union \"c/language/union\") declarations can be repeated:\n\n```\nstruct X;\nstruct X { int n; };\nstruct X;\n```\n\nThese rules simplify the use of header files.\n\n### Notes\n\n[TABLE]\n\nEmpty declarators are prohibited; a simple declaration must have at least one declarator or declare at least one struct/union/enum tag, or introduce at least one enumeration constant.\n\n[TABLE]\n\n|                                                                                                                                                                                                                                                                                         |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| [static_asserts](_static_assert \"c/language/ Static assert\") are considered to be declarations from the point of view of the C grammar (so that they may appear anywhere a declaration may appear), but they do not introduce any identifiers and do not follow the declaration syntax. | (since C11) |\n\n|                                                                                                                                                                                                                                                                                                  |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| [Attribute](attributes \"c/language/attributes\") declarations are also considered to be declarations (so that they may appear anywhere a declaration may appear), but they do not introduce any identifiers. A single `;` without attr-spec-seq is not an attribute declaration, but a statement. | (since C23) |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7 Declarations (p: 78-105)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7 Declarations (p: 108-145)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7 Declarations (p: 97-130)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.5 Declarations\n\n### See also\n\n|                                                                                                                           |     |\n|---------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/declarations \"cpp/language/declarations\") for Declarations |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/declarations](https://en.cppreference.com/w/c/language/declarations)"
- name: default
  summary: ''
  description: "# C keywords: default\n\n### Usage\n\n- [`switch` statement](../language/switch \"c/language/switch\"): as the declaration of the default case label\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/default](https://en.cppreference.com/w/c/keyword/default)"
- name: Diagnostic directives
  summary: Shows the given error message and renders the program ill-formed, or given warning message without affect the validity of the program(since C23)
  description: "# Diagnostic directives\n\nShows the given error message and renders the program ill-formed, or given warning message without affect the validity of the program(since C23).\n\n### Syntax\n\n|                               |       |             |\n|-------------------------------|-------|-------------|\n| `#error` diagnostic-message   | \\(1\\) |             |\n| `#warning` diagnostic-message | \\(2\\) | (since C23) |\n\n### Explanation\n\n1) After encountering the `#error` directive, an implementation displays the message diagnostic-message and renders the program ill-formed (the compilation stops).\n\n2) Same as (1), except that the validity of the program is not affected and the compilation continues.\n\ndiagnostic-message can consist of several words not necessarily in quotes.\n\n### Notes\n\nBefore its standardization in C23, `#warning` has been provided by many compilers in all modes as a conforming extension.\n\n### Example\n\n```\n#if __STDC__ != 1\n#  error \"Not a standard compliant compiler\"\n#endif\n \n#if __STDC_VERSION__ >= 202311L\n#  warning \"Using #warning as a standard feature\"\n#endif\n \n#include <stdio.h>\nint main (void)\n{\n    printf(\"The compiler used conforms to the ISO C Standard !!\");\n}\n```\n\nPossible output:\n\n```\nThe compiler used conforms to the ISO C Standard !!\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10.5 Error directive (p: 126-127)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10.5 Error directive (p: 174)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10.5 Error directive (p: 159)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8.5 Error directive\n\n### See also\n\n|                                                                                                                              |     |\n|------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor/error \"cpp/preprocessor/error\") for Diagnostic directives |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor/error](https://en.cppreference.com/w/c/preprocessor/error)"
- name: difftime
  summary: Computes difference between two calendar times as time_t objects (time_end - time_beg) in seconds
  description: "# difftime\n\n[TABLE]\n\nComputes difference between two calendar times as [`time_t`](time_t \"c/chrono/time t\") objects (`time_end - time_beg`) in seconds. If `time_end` refers to time point before `time_beg` then the result is negative.\n\n### Parameters\n\n|                    |     |                  |\n|--------------------|-----|------------------|\n| time_beg, time_end | \\-  | times to compare |\n\n### Return value\n\nDifference between two times in seconds.\n\n### Notes\n\nOn POSIX systems, [`time_t`](time_t \"c/chrono/time t\") is measured in seconds, and `difftime` is equivalent to arithmetic subtraction, but C and C++ allow fractional units for [`time_t`](time_t \"c/chrono/time t\").\n\n### Example\n\nThe following program computes the number of seconds that have passed since the beginning of the month.\n\n```\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    time_t now = time(0);\n \n    struct tm beg = *localtime(&now);\n \n    // set beg to the beginning of the month\n    beg.tm_hour = 0,\n    beg.tm_min = 0,\n    beg.tm_sec = 0,\n    beg.tm_mday = 1;\n \n    double seconds = difftime(now, mktime(&beg));\n \n    printf(\"%.f seconds have passed since the beginning of the month.\\n\", seconds);\n \n    return 0;\n}\n```\n\nOutput:\n\n```\n1937968 seconds have passed since the beginning of the month.\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.2.2 The difftime function (p: 285)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.2.2 The difftime function (p: 390)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.2.2 The difftime function (p: 338)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 7.12.2.2 The difftime function (p: 171)\n\n### See also\n\n|                                                                                                                 |     |\n|-----------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/chrono/c/difftime \"cpp/chrono/c/difftime\") for `difftime` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/difftime](https://en.cppreference.com/w/c/chrono/difftime)"
- name: div
  summary: Computes both the quotient and the remainder of the division of the numerator x by the denominator y
  description: "# div, ldiv, lldiv, imaxdiv\n\n[TABLE]\n\nComputes both the quotient and the remainder of the division of the numerator `x` by the denominator `y`.\n\n|                                                                                                                                                                                                       |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Computes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that `quot * y + rem == x`. | (until C99) |\n| Computes the quotient (the result of the expression `x / y`) and remainder (the result of the expression `x % y`) simultaneously.                                                                     | (since C99) |\n\n### Parameters\n\n|      |     |                |\n|------|-----|----------------|\n| x, y | \\-  | integer values |\n\n### Return value\n\nIf both the remainder and the quotient can be represented as objects of the corresponding type (`int`, `long`, `long long`, [`intmax_t`](http://en.cppreference.com/w/c/types/integer), respectively), returns both as an object of type `div_t`, `ldiv_t`, `lldiv_t`, `imaxdiv_t` defined as follows:\n\n## div_t\n\n```\nstruct div_t { int quot; int rem; };\n```\n\nor\n\n```\nstruct div_t { int rem; int quot; };\n```\n\n## ldiv_t\n\n```\nstruct ldiv_t { long quot; long rem; };\n```\n\nor\n\n```\nstruct ldiv_t { long rem; long quot; };\n```\n\n## lldiv_t\n\n```\nstruct lldiv_t { long long quot; long long rem; };\n```\n\nor\n\n```\nstruct lldiv_t { long long rem; long long quot; };\n```\n\n## imaxdiv_t\n\n```\nstruct imaxdiv_t { intmax_t quot; intmax_t rem; };\n```\n\nor\n\n```\nstruct imaxdiv_t { intmax_t rem; intmax_t quot; };\n```\n\nIf either the remainder or the quotient cannot be represented, the behavior is undefined.\n\n### Notes\n\nUntil C99, the rounding direction of the quotient and the sign of the remainder in the built-in division and remainder operators was implementation-defined if either of the operands was negative, but it was well-defined in `div` and `ldiv`.\n\nOn many platforms, a single CPU instruction obtains both the quotient and the remainder, and this function may leverage that, although compilers are generally able to merge nearby `/` and `%` where suitable.\n\n### Example\n\n```\n#include <assert.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nvoid reverse(char* first, char* last)\n{\n    for (--last; first < last; ++first, --last)\n    {\n        char c = *last;\n        *last = *first;\n        *first = c;\n    }\n}\n \n// returns empty buffer in case of buffer overflow\nchar* itoa(int n, int base, char* buf, size_t buf_size)\n{\n    assert(2 <= base && base <= 16 && buf && buf_size);\n    div_t dv = {.quot = n};\n    char* p = buf;\n    do\n    {\n        if (!--buf_size)\n            return (*buf = '\\0'), buf;\n        dv = div(dv.quot, base);\n        *p++ = \"0123456789abcdef\"[abs(dv.rem)];\n    }\n    while(dv.quot);\n    if (n < 0)\n        *p++ = '-';\n    *p = '\\0';\n    reverse(buf, p);\n    return buf;\n}\n \nint main(void)\n{\n    char buf[16];\n    printf(\"%s\\n\", itoa(0, 2, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(007, 3, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(12346, 10, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(-12346, 10, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(-42, 2, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(INT_MAX, 16, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(INT_MIN, 16, buf, sizeof buf));\n}\n```\n\nPossible output:\n\n```\n0\n21\n12346\n-12346\n-101010\n7fffffff\n-80000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.8.2.2 The imaxdiv function (p: TBD)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.2.2 The imaxdiv function (p: 159)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: 259)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.2 The imaxdiv function (p: 219)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: 356)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.2 The imaxdiv function (p: 200)\n  - 7.20.6.2 The div, ldiv and lldiv functions (p: 320)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10 div_t, ldiv_t\n  - 4.10.6.2 The div function\n  - 4.10.6.4 The ldiv function\n\n### See also\n\n[TABLE]\n\n### External links\n\n|     |                                                                                                                      |\n|-----|----------------------------------------------------------------------------------------------------------------------|\n| 1\\. | [Euclidean division](https://en.wikipedia.org/wiki/Euclidean_division \"enwiki:Euclidean division\") — From Wikipedia. |\n| 2\\. | [Modulo (and Truncated division)](https://en.wikipedia.org/wiki/Modulo \"enwiki:Modulo\") — From Wikipedia.            |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/div](https://en.cppreference.com/w/c/numeric/math/div)"
- name: do
  summary: ''
  description: "# C keywords: do\n\n### Usage\n\n- [`do-while` loop](../language/do \"c/language/do\"): as the declaration of the loop\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/do](https://en.cppreference.com/w/c/keyword/do)"
- name: do-while loop
  summary: Executes a statement repeatedly until the value of the condition expression becomes false
  description: "# do-while loop\n\nExecutes a statement repeatedly until the value of the condition expression becomes false. The test takes place after each iteration.\n\n### Syntax\n\n|                                                                     |     |     |\n|---------------------------------------------------------------------|-----|-----|\n| attr-spec-seq(optional) `do` statement `while (` expression `)` `;` |     |     |\n\n|               |     |                                                                                                                                                                                                                       |\n|---------------|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| expression    | \\-  | any [expression](expressions \"c/language/expressions\") of [scalar type](type#Type_groups \"c/language/type\"). This expression is evaluated after each iteration, and if it compares equal to zero, the loop is exited. |\n| statement     | \\-  | any [statement](statements \"c/language/statements\"), typically a compound statement, which is the body of the loop                                                                                                    |\n| attr-spec-seq | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the loop statement                                                                                                                 |\n\n### Explanation\n\nA `do-while` statement causes the statement (also called *the loop body*) to be executed repeatedly until the expression (also called *controlling expression*) compares equal to 0. The repetition occurs regardless of whether the loop body is entered normally or by a [goto](goto \"c/language/goto\") into the middle of statement.\n\nThe evaluation of expression takes place after each execution of statement (whether entered normally or by a goto). If the controlling expression needs to be evaluated before the loop body, the [while loop](while \"c/language/while\") or the [for loop](for \"c/language/for\") may be used.\n\nIf the execution of the loop needs to be terminated at some point, [break statement](break \"c/language/break\") can be used as terminating statement.\n\nIf the execution of the loop needs to be continued at the end of the loop body, [continue statement](continue \"c/language/continue\") can be used as a shortcut.\n\nA program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; `do {...} while(true);` is always an endless loop.\n\n|                                                                                                                                                                                                                      |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| As with all other selection and iteration statements, the do-while statement establishes [block scope](scope \"c/language/scope\"): any identifier introduced in the expression goes out of scope after the statement. | (since C99) |\n\n### Notes\n\nBoolean and pointer expressions are often used as loop controlling expressions. The boolean value `false` and the null pointer value of any pointer type compare equal to zero.\n\n### Keywords\n\n[`do`](../keyword/do \"c/keyword/do\"), [`while`](../keyword/while \"c/keyword/while\")\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\nenum { SIZE = 8 };\nint main(void)\n{\n    // trivial example\n    int array[SIZE], n = 0;\n    do array[n++] = rand() % 2; // the loop body is a single expression statement\n    while(n < SIZE);\n    puts(\"Array filled!\");\n    n = 0;\n    do { // the loop body is a compound statement\n        printf(\"%d \", array[n]);\n        ++n;\n    } while (n < SIZE);\n    printf(\"\\n\");\n \n    // the loop from K&R itoa(). The do-while loop is used\n    // because there is always at least one digit to generate\n    int num = 1234, i=0;\n    char s[10];\n    do s[i++] = num % 10 + '0'; // get next digit in reverse order\n    while ((num /= 10) > 0);\n    s[i] = '\\0';\n    puts(s);\n}\n```\n\nPossible output:\n\n```\nArray filled!\n1 0 1 1 1 1 0 0\n4321\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.8.5.2 The do statement (p: 109)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.8.5.2 The do statement (p: 151)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.8.5.2 The do statement (p: 136)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.6.5.2 The do statement\n\n### See also\n\n|                                                                                                            |     |\n|------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/do \"cpp/language/do\") for `do`-`while` loop |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/do](https://en.cppreference.com/w/c/language/do)"
- name: double
  summary: ''
  description: "# C keywords: double\n\n### Usage\n\n- [`double` type](../language/types \"c/language/types\"): as the declaration of the type\n- [`long double` type](../language/types \"c/language/types\"): as the declaration of the type when combined with [`long`](long \"c/keyword/long\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/double](https://en.cppreference.com/w/c/keyword/double)"
- name: double_t
  summary: The types float_t and double_t are floating types at least as wide as float and double, respectively, and such that double_t is at least as wide as float_t
  description: "# float_t, double_t\n\n[TABLE]\n\nThe types `float_t` and `double_t` are floating types at least as wide as `float` and `double`, respectively, and such that `double_t` is at least as wide as `float_t`. The value of [`FLT_EVAL_METHOD`](../../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\") determines the types of `float_t` and `double_t`.\n\n| FLT_EVAL_METHOD | Explanation                                                                   |\n|-----------------|-------------------------------------------------------------------------------|\n| `0`             | `float_t` and `double_t` are equivalent to `float` and `double`, respectively |\n| `1`             | both `float_t` and `double_t` are equivalent to `double`                      |\n| `2`             | both `float_t` and `double_t` are equivalent to `long double`                 |\n| `other`         | both `float_t` and `double_t` are implementation defined                      |\n\n### Example\n\n```\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"%d\\n\", FLT_EVAL_METHOD);\n    printf(\"%zu  %zu\\n\", sizeof(float),sizeof(float_t));\n    printf(\"%zu  %zu\\n\", sizeof(double),sizeof(double_t));\n    return 0;\n}\n```\n\nPossible output:\n\n```\n0\n4  4\n8  8\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12 Mathematics \\<math.h\\> (p: 231)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12 Mathematics \\<math.h\\> (p: 212)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/float_t](https://en.cppreference.com/w/c/numeric/math/float_t)"
- name: Dynamic memory management
  summary: ''
  description: "# Dynamic memory management\n\n### Functions\n\n[TABLE]\n\n### See also\n\n|                                                                                                                |     |\n|----------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/memory/c \"cpp/memory/c\") for C memory management library |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/memory](https://en.cppreference.com/w/c/memory)"
- name: else
  summary: ''
  description: "# C keywords: else\n\n### Usage\n\n- [`if` statement](../language/if \"c/language/if\"): as the declaration of the alternative branch\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/else](https://en.cppreference.com/w/c/keyword/else)"
- name: enum
  summary: ''
  description: "# C keywords: enum\n\n### Usage\n\n- [declaration of an enumeration type](../language/enum \"c/language/enum\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/enum](https://en.cppreference.com/w/c/keyword/enum)"
- name: Enumerations
  summary: An enumerated type is a distinct type whose value is a value of its underlying type (see below), which includes the values of explicitly named constants (enumeration constants)
  description: "# Enumerations\n\nAn *enumerated type* is a distinct [type](type \"c/language/type\") whose value is a value of its *underlying type* (see below), which includes the values of explicitly named constants (*enumeration constants*).\n\n### Syntax\n\nEnumerated type is declared using the following *enumeration specifier* as the type-specifier in the [declaration grammar](declarations \"c/language/declarations\"):\n\n|                                                                                        |       |             |\n|----------------------------------------------------------------------------------------|-------|-------------|\n| `enum` attr-spec-seq \uFEFF(optional) identifier \uFEFF(optional) `{` enumerator-list `}`          | \\(1\\) |             |\n| `enum` attr-spec-seq \uFEFF(optional) identifier \uFEFF(optional) `:` type `{` enumerator-list `}` | \\(2\\) | (since C23) |\n\n1) Declares an enumeration without a fixed underlying type.\n\n2) Declares an enumeration of fixed underlying type type.\n\nwhere enumerator-list is a comma-separated list(with trailing comma permitted)(since C99) of enumerator, each of which has the form:\n\n|                                                                       |       |     |\n|-----------------------------------------------------------------------|-------|-----|\n| enumeration-constant attr-spec-seq \uFEFF(optional)                         | \\(1\\) |     |\n| enumeration-constant attr-spec-seq \uFEFF(optional) `=` constant-expression | \\(2\\) |     |\n\nwhere\n\n[TABLE]\n\nAs with [struct](struct \"c/language/struct\") or [union](union \"c/language/union\"), a declaration that introduced an enumerated type and one or more enumeration constants may also declare one or more objects of that type or type derived from it.\n\n```\nenum color { RED, GREEN, BLUE } c = RED, *cp = &c;\n// introduces the type enum color\n// the integer constants RED, GREEN, BLUE\n// the object c of type enum color\n// the object cp of type pointer to enum color\n```\n\n### Explanation\n\nEach enumeration-constant that appears in the body of an enumeration specifier becomes an [integer constant](constant_expression \"c/language/constant expression\") with type int(until C23) in the enclosing scope and can be used whenever integer constants are required (e.g. as a case label or as a non-VLA array size).\n\n[TABLE]\n\n```\nenum color { RED, GREEN, BLUE } r = RED;\nswitch(r)\n{\ncase RED:\n    puts(\"red\");\n    break;\ncase GREEN:\n    puts(\"green\");\n    break;\ncase BLUE:\n    puts(\"blue\");\n    break;\n}\n```\n\nIf enumeration-constant is followed by = constant-expression, its value is the value of that constant expression. If enumeration-constant is not followed by = constant-expression, its value is the value one greater than the value of the previous enumerator in the same enumeration. The value of the first enumerator (if it does not use = constant-expression) is zero.\n\n```\nenum Foo { A, B, C = 10, D, E = 1, F, G = F + C };\n// A=0, B=1, C=10, D=11, E=1, F=2, G=12\n```\n\nThe identifier itself, if used, becomes the name of the enumerated type in the tags [name space](name_space \"c/language/name space\") and requires the use of the keyword enum (unless typedef'd into the ordinary name space).\n\n```\nenum color { RED, GREEN, BLUE };\nenum color r = RED; // OK\n// color x = GREEN: // Error: color is not in ordinary name space\ntypedef enum color color_t;\ncolor_t x = GREEN; // OK\n```\n\nEach enumerated type without a fixed underlying type(since C23) is [compatible](type#Compatible_types \"c/language/type\") with one of: char, a signed integer type, or an unsigned integer type (excluding bool and the bit-precise integer types)(since C23). It is implementation-defined which type is compatible with any given enumerated type, but whatever it is, it must be capable of representing all enumerator values of that enumeration. For all enumerations with a fixed underlying type, the enumerated type is compatible with the underlying type of the enumeration.(since C23)\n\n[TABLE]\n\nEnumerated types are integer types, and as such can be used anywhere other integer types can, including in [implicit conversions](conversion \"c/language/conversion\") and [arithmetic operators](operator_arithmetic \"c/language/operator arithmetic\").\n\n```\nenum { ONE = 1, TWO } e;\nlong n = ONE; // promotion\ndouble d = ONE; // conversion\ne = 1.2; // conversion, e is now ONE\ne = e + 1; // e is now TWO\n```\n\n### Notes\n\nUnlike [struct](struct \"c/language/struct\") or [union](union \"c/language/union\"), there are no forward-declared enums in C:\n\n```\nenum Color; // Error: no forward-declarations for enums in C\nenum Color { RED, GREEN, BLUE };\n```\n\nEnumerations permit the declaration of named constants in a more convenient and structured fashion than does `#define`; they are visible in the debugger, obey scope rules, and participate in the type system.\n\n```\n#define TEN 10\nstruct S { int x : TEN; }; // OK\n```\n\nor\n\n```\nenum { TEN = 10 };\nstruct S { int x : TEN; }; // also OK\n```\n\nSince C23 [constexpr](constexpr \"c/language/constexpr\") can be used for the same purpose:\n\n```\nconstexpr int TEN = 10;\nstruct S { int x : TEN; }; // also OK\n```\n\nMoreover, as a [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") does not establish its scope in C, an enumeration type and its enumeration constants may be introduced in the member specification of the former, and their scope is the same as of the former, afterwards.\n\n```\nstruct Element\n{\n    int z;\n    enum State { SOLID, LIQUID, GAS, PLASMA } state;\n} oxygen = { 8, GAS };\n \n// type enum State and its enumeration constants stay visible here, e.g.\nvoid foo(void)\n{\n    enum State e = LIQUID; // OK\n    printf(\"%d %d %d \", e, oxygen.state, PLASMA); // prints 1 2 3\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    enum TV { FOX = 11, CNN = 25, ESPN = 15, HBO = 22, MAX = 30, NBC = 32 };\n \n    printf(\"List of cable stations:\\n\");\n    printf(\" FOX: \\t%2d\\n\", FOX);\n    printf(\" HBO: \\t%2d\\n\", HBO);\n    printf(\" MAX: \\t%2d\\n\", MAX);\n}\n```\n\nOutput:\n\n```\nList of cable stations:\n FOX:   11\n HBO:   22\n MAX:   30\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.2.5/21 Types (p: 39)\n  - 6.7.2.2 Enumeration specifiers (p: 107-112)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.2.5/16 Types (p: 32)\n  - 6.7.2.2 Enumeration specifiers (p: 84-85)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.2.5/16 Types (p: 41)\n  - 6.7.2.2 Enumeration specifiers (p: 117-118)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.2.5/16 Types (p: 35)\n  - 6.7.2.2 Enumeration specifiers (p: 105-106)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.2.5 Types\n  - 3.5.2.2 Enumeration specifiers\n\n### Keywords\n\n[`enum`](../keyword/enum \"c/keyword/enum\")\n\n### See also\n\n|                                                                                                                      |     |\n|----------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/enum \"cpp/language/enum\") for enumeration declaration |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/enum](https://en.cppreference.com/w/c/language/enum)"
- name: erf
  summary: Errors are reported as specified in math_errhandling
  description: "# erf, erff, erfl\n\n[TABLE]\n\n1-3) Computes the [error function](https://en.wikipedia.org/wiki/Error_function \"enwiki:Error function\") of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `erfl` is called. Otherwise, if `arg` has integer type or the type `double`, `erf` is called. Otherwise, `erff` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, value of the error function of `arg`, that is \\\\\\frac{2}{\\sqrt{\\pi} }\\int\\_{0}^{arg}{e^{-{t^2} }\\mathsf{d}t}\\\\2/√π∫_(arg0)*e*^(-t²)d*t*, is returned. If a range error occurs due to underflow, the correct result (after rounding), that is \\\\\\frac{2\\cdot arg}{\\sqrt{\\pi} }\\\\2\\*arg/√π, is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, ±0 is returned\n- If the argument is ±∞, ±1 is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nUnderflow is guaranteed if `|``arg``|`` ``<`` `[`DBL_MIN`](http://en.cppreference.com/w/c/types/limits)`*``(`[`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt)`(``π``)``/``2``)`. \\\\\\operatorname{erf}(\\frac{x}{\\sigma \\sqrt{2} })\\\\erf(\n\nx/σ√2) is the probability that a measurement whose errors are subject to a normal distribution with standard deviation \\\\\\sigma\\\\σ is less than \\\\x\\\\x away from the mean value.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \ndouble phi(double x1, double x2)\n{\n    return (erf(x2 / sqrt(2)) - erf(x1 / sqrt(2))) / 2;\n}\n \nint main(void)\n{\n    puts(\"normal variate probabilities:\");\n    for (int n = -4; n < 4; ++n)\n        printf(\"[%2d:%2d]: %5.2f%%\\n\", n, n + 1, 100 * phi(n, n + 1));\n \n    puts(\"special values:\");\n    printf(\"erf(-0) = %f\\n\", erf(-0.0));\n    printf(\"erf(Inf) = %f\\n\", erf(INFINITY));\n}\n```\n\nOutput:\n\n```\nnormal variate probabilities:\n[-4:-3]:  0.13%\n[-3:-2]:  2.14%\n[-2:-1]: 13.59%\n[-1: 0]: 34.13%\n[ 0: 1]: 34.13%\n[ 1: 2]: 13.59%\n[ 2: 3]:  2.14%\n[ 3: 4]:  0.13%\nspecial values:\nerf(-0) = -0.000000\nerf(Inf) = 1.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.1 The erf functions (p: 249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.1 The erf functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.1 The erf functions (p: 230)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.1 The erf functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                              |\n|--------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Erf.\"](https://mathworld.wolfram.com/Erf.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/erf](https://en.cppreference.com/w/c/numeric/math/erf)"
- name: erfc
  summary: If a range error occurs due to underflow, the correct result (after rounding) is returned
  description: "# erfc, erfcf, erfcl\n\n[TABLE]\n\n1-3) Computes the [complementary error function](https://en.wikipedia.org/wiki/Complementary_error_function \"enwiki:Complementary error function\") of `arg`, that is `1.0`` ``-`` `[`erf`](http://en.cppreference.com/w/c/numeric/math/erf)`(``arg``)`, but without loss of precision for large `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `erfcl` is called. Otherwise, if `arg` has integer type or the type `double`, `erfc` is called. Otherwise, `erfcf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, value of the complementary error function of `arg`, that is \\\\\\frac{2}{\\sqrt{\\pi} }\\int\\_{arg}^{\\infty}{e^{-{t^2} }\\mathsf{d}t}\\\\2/√π∫_(∞arg)*e*^(-t²)d*t* or \\\\{\\small 1-\\operatorname{erf}(arg)}\\\\1-erf(arg), is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is +∞, +0 is returned.\n- If the argument is -∞, 2 is returned.\n- If the argument is NaN, NaN is returned.\n\n### Notes\n\nFor the IEEE-compatible type `double`, underflow is guaranteed if `arg` \\> `26.55`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \ndouble normalCDF(double x) // Phi(-∞, x) aka N(x)\n{\n    return erfc(-x / sqrt(2)) / 2;\n}\n \nint main(void)\n{\n    puts(\"normal cumulative distribution function:\");\n    for(double n = 0; n < 1; n += 0.1)\n        printf(\"normalCDF(%.2f) %5.2f%%\\n\", n, 100 * normalCDF(n));\n \n    printf(\"special values:\\n\"\n           \"erfc(-Inf) = %f\\n\"\n           \"erfc(Inf) = %f\\n\",\n           erfc(-INFINITY),\n           erfc(INFINITY));\n}\n```\n\nOutput:\n\n```\nnormal cumulative distribution function:\nnormalCDF(0.00) 50.00%\nnormalCDF(0.10) 53.98%\nnormalCDF(0.20) 57.93%\nnormalCDF(0.30) 61.79%\nnormalCDF(0.40) 65.54%\nnormalCDF(0.50) 69.15%\nnormalCDF(0.60) 72.57%\nnormalCDF(0.70) 75.80%\nnormalCDF(0.80) 78.81%\nnormalCDF(0.90) 81.59%\nnormalCDF(1.00) 84.13%\nspecial values:\nerfc(-Inf) = 2.000000\nerfc(Inf) = 0.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.2 The erfc functions (p: 249-250)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.2 The erfc functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.2 The erfc functions (p: 230)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.2 The erfc functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                |\n|----------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Erfc.\"](https://mathworld.wolfram.com/Erfc.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/erfc](https://en.cppreference.com/w/c/numeric/math/erfc)"
- name: erfcf
  summary: If a range error occurs due to underflow, the correct result (after rounding) is returned
  description: "# erfc, erfcf, erfcl\n\n[TABLE]\n\n1-3) Computes the [complementary error function](https://en.wikipedia.org/wiki/Complementary_error_function \"enwiki:Complementary error function\") of `arg`, that is `1.0`` ``-`` `[`erf`](http://en.cppreference.com/w/c/numeric/math/erf)`(``arg``)`, but without loss of precision for large `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `erfcl` is called. Otherwise, if `arg` has integer type or the type `double`, `erfc` is called. Otherwise, `erfcf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, value of the complementary error function of `arg`, that is \\\\\\frac{2}{\\sqrt{\\pi} }\\int\\_{arg}^{\\infty}{e^{-{t^2} }\\mathsf{d}t}\\\\2/√π∫_(∞arg)*e*^(-t²)d*t* or \\\\{\\small 1-\\operatorname{erf}(arg)}\\\\1-erf(arg), is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is +∞, +0 is returned.\n- If the argument is -∞, 2 is returned.\n- If the argument is NaN, NaN is returned.\n\n### Notes\n\nFor the IEEE-compatible type `double`, underflow is guaranteed if `arg` \\> `26.55`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \ndouble normalCDF(double x) // Phi(-∞, x) aka N(x)\n{\n    return erfc(-x / sqrt(2)) / 2;\n}\n \nint main(void)\n{\n    puts(\"normal cumulative distribution function:\");\n    for(double n = 0; n < 1; n += 0.1)\n        printf(\"normalCDF(%.2f) %5.2f%%\\n\", n, 100 * normalCDF(n));\n \n    printf(\"special values:\\n\"\n           \"erfc(-Inf) = %f\\n\"\n           \"erfc(Inf) = %f\\n\",\n           erfc(-INFINITY),\n           erfc(INFINITY));\n}\n```\n\nOutput:\n\n```\nnormal cumulative distribution function:\nnormalCDF(0.00) 50.00%\nnormalCDF(0.10) 53.98%\nnormalCDF(0.20) 57.93%\nnormalCDF(0.30) 61.79%\nnormalCDF(0.40) 65.54%\nnormalCDF(0.50) 69.15%\nnormalCDF(0.60) 72.57%\nnormalCDF(0.70) 75.80%\nnormalCDF(0.80) 78.81%\nnormalCDF(0.90) 81.59%\nnormalCDF(1.00) 84.13%\nspecial values:\nerfc(-Inf) = 2.000000\nerfc(Inf) = 0.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.2 The erfc functions (p: 249-250)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.2 The erfc functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.2 The erfc functions (p: 230)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.2 The erfc functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                |\n|----------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Erfc.\"](https://mathworld.wolfram.com/Erfc.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/erfc](https://en.cppreference.com/w/c/numeric/math/erfc)"
- name: erfcl
  summary: If a range error occurs due to underflow, the correct result (after rounding) is returned
  description: "# erfc, erfcf, erfcl\n\n[TABLE]\n\n1-3) Computes the [complementary error function](https://en.wikipedia.org/wiki/Complementary_error_function \"enwiki:Complementary error function\") of `arg`, that is `1.0`` ``-`` `[`erf`](http://en.cppreference.com/w/c/numeric/math/erf)`(``arg``)`, but without loss of precision for large `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `erfcl` is called. Otherwise, if `arg` has integer type or the type `double`, `erfc` is called. Otherwise, `erfcf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, value of the complementary error function of `arg`, that is \\\\\\frac{2}{\\sqrt{\\pi} }\\int\\_{arg}^{\\infty}{e^{-{t^2} }\\mathsf{d}t}\\\\2/√π∫_(∞arg)*e*^(-t²)d*t* or \\\\{\\small 1-\\operatorname{erf}(arg)}\\\\1-erf(arg), is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is +∞, +0 is returned.\n- If the argument is -∞, 2 is returned.\n- If the argument is NaN, NaN is returned.\n\n### Notes\n\nFor the IEEE-compatible type `double`, underflow is guaranteed if `arg` \\> `26.55`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \ndouble normalCDF(double x) // Phi(-∞, x) aka N(x)\n{\n    return erfc(-x / sqrt(2)) / 2;\n}\n \nint main(void)\n{\n    puts(\"normal cumulative distribution function:\");\n    for(double n = 0; n < 1; n += 0.1)\n        printf(\"normalCDF(%.2f) %5.2f%%\\n\", n, 100 * normalCDF(n));\n \n    printf(\"special values:\\n\"\n           \"erfc(-Inf) = %f\\n\"\n           \"erfc(Inf) = %f\\n\",\n           erfc(-INFINITY),\n           erfc(INFINITY));\n}\n```\n\nOutput:\n\n```\nnormal cumulative distribution function:\nnormalCDF(0.00) 50.00%\nnormalCDF(0.10) 53.98%\nnormalCDF(0.20) 57.93%\nnormalCDF(0.30) 61.79%\nnormalCDF(0.40) 65.54%\nnormalCDF(0.50) 69.15%\nnormalCDF(0.60) 72.57%\nnormalCDF(0.70) 75.80%\nnormalCDF(0.80) 78.81%\nnormalCDF(0.90) 81.59%\nnormalCDF(1.00) 84.13%\nspecial values:\nerfc(-Inf) = 2.000000\nerfc(Inf) = 0.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.2 The erfc functions (p: 249-250)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.2 The erfc functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.2 The erfc functions (p: 230)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.2 The erfc functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                |\n|----------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Erfc.\"](https://mathworld.wolfram.com/Erfc.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/erfc](https://en.cppreference.com/w/c/numeric/math/erfc)"
- name: erff
  summary: Errors are reported as specified in math_errhandling
  description: "# erf, erff, erfl\n\n[TABLE]\n\n1-3) Computes the [error function](https://en.wikipedia.org/wiki/Error_function \"enwiki:Error function\") of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `erfl` is called. Otherwise, if `arg` has integer type or the type `double`, `erf` is called. Otherwise, `erff` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, value of the error function of `arg`, that is \\\\\\frac{2}{\\sqrt{\\pi} }\\int\\_{0}^{arg}{e^{-{t^2} }\\mathsf{d}t}\\\\2/√π∫_(arg0)*e*^(-t²)d*t*, is returned. If a range error occurs due to underflow, the correct result (after rounding), that is \\\\\\frac{2\\cdot arg}{\\sqrt{\\pi} }\\\\2\\*arg/√π, is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, ±0 is returned\n- If the argument is ±∞, ±1 is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nUnderflow is guaranteed if `|``arg``|`` ``<`` `[`DBL_MIN`](http://en.cppreference.com/w/c/types/limits)`*``(`[`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt)`(``π``)``/``2``)`. \\\\\\operatorname{erf}(\\frac{x}{\\sigma \\sqrt{2} })\\\\erf(\n\nx/σ√2) is the probability that a measurement whose errors are subject to a normal distribution with standard deviation \\\\\\sigma\\\\σ is less than \\\\x\\\\x away from the mean value.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \ndouble phi(double x1, double x2)\n{\n    return (erf(x2 / sqrt(2)) - erf(x1 / sqrt(2))) / 2;\n}\n \nint main(void)\n{\n    puts(\"normal variate probabilities:\");\n    for (int n = -4; n < 4; ++n)\n        printf(\"[%2d:%2d]: %5.2f%%\\n\", n, n + 1, 100 * phi(n, n + 1));\n \n    puts(\"special values:\");\n    printf(\"erf(-0) = %f\\n\", erf(-0.0));\n    printf(\"erf(Inf) = %f\\n\", erf(INFINITY));\n}\n```\n\nOutput:\n\n```\nnormal variate probabilities:\n[-4:-3]:  0.13%\n[-3:-2]:  2.14%\n[-2:-1]: 13.59%\n[-1: 0]: 34.13%\n[ 0: 1]: 34.13%\n[ 1: 2]: 13.59%\n[ 2: 3]:  2.14%\n[ 3: 4]:  0.13%\nspecial values:\nerf(-0) = -0.000000\nerf(Inf) = 1.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.1 The erf functions (p: 249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.1 The erf functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.1 The erf functions (p: 230)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.1 The erf functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                              |\n|--------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Erf.\"](https://mathworld.wolfram.com/Erf.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/erf](https://en.cppreference.com/w/c/numeric/math/erf)"
- name: erfl
  summary: Errors are reported as specified in math_errhandling
  description: "# erf, erff, erfl\n\n[TABLE]\n\n1-3) Computes the [error function](https://en.wikipedia.org/wiki/Error_function \"enwiki:Error function\") of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `erfl` is called. Otherwise, if `arg` has integer type or the type `double`, `erf` is called. Otherwise, `erff` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, value of the error function of `arg`, that is \\\\\\frac{2}{\\sqrt{\\pi} }\\int\\_{0}^{arg}{e^{-{t^2} }\\mathsf{d}t}\\\\2/√π∫_(arg0)*e*^(-t²)d*t*, is returned. If a range error occurs due to underflow, the correct result (after rounding), that is \\\\\\frac{2\\cdot arg}{\\sqrt{\\pi} }\\\\2\\*arg/√π, is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, ±0 is returned\n- If the argument is ±∞, ±1 is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nUnderflow is guaranteed if `|``arg``|`` ``<`` `[`DBL_MIN`](http://en.cppreference.com/w/c/types/limits)`*``(`[`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt)`(``π``)``/``2``)`. \\\\\\operatorname{erf}(\\frac{x}{\\sigma \\sqrt{2} })\\\\erf(\n\nx/σ√2) is the probability that a measurement whose errors are subject to a normal distribution with standard deviation \\\\\\sigma\\\\σ is less than \\\\x\\\\x away from the mean value.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \ndouble phi(double x1, double x2)\n{\n    return (erf(x2 / sqrt(2)) - erf(x1 / sqrt(2))) / 2;\n}\n \nint main(void)\n{\n    puts(\"normal variate probabilities:\");\n    for (int n = -4; n < 4; ++n)\n        printf(\"[%2d:%2d]: %5.2f%%\\n\", n, n + 1, 100 * phi(n, n + 1));\n \n    puts(\"special values:\");\n    printf(\"erf(-0) = %f\\n\", erf(-0.0));\n    printf(\"erf(Inf) = %f\\n\", erf(INFINITY));\n}\n```\n\nOutput:\n\n```\nnormal variate probabilities:\n[-4:-3]:  0.13%\n[-3:-2]:  2.14%\n[-2:-1]: 13.59%\n[-1: 0]: 34.13%\n[ 0: 1]: 34.13%\n[ 1: 2]: 13.59%\n[ 2: 3]:  2.14%\n[ 3: 4]:  0.13%\nspecial values:\nerf(-0) = -0.000000\nerf(Inf) = 1.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.1 The erf functions (p: 249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.1 The erf functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.1 The erf functions (p: 230)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.1 The erf functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                              |\n|--------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Erf.\"](https://mathworld.wolfram.com/Erf.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/erf](https://en.cppreference.com/w/c/numeric/math/erf)"
- name: errno
  summary: errno is a preprocessor macro (but see note below) that expands to a thread-local(since C11) modifiable lvalue of type int
  description: "# errno\n\n[TABLE]\n\n`errno` is a preprocessor macro (but see note below) that expands to a thread-local(since C11) modifiable lvalue of type `int`. Several standard library functions indicate errors by writing positive integers to `errno`. Typically, the value of `errno` is set to one of the error codes listed in `<errno.h>` as macro constants beginning with the letter `E` followed by uppercase letters or digits.\n\nThe value of `errno` is `​0​` at program startup, and although library functions are allowed to write positive integers to `errno` whether or not an error occurred, library functions never store `​0​` in `errno`.\n\nLibrary functions [`perror`](../io/perror \"c/io/perror\") and [`strerror`](../string/byte/strerror \"c/string/byte/strerror\") can be used to obtain textual descriptions of the error conditions that correspond to the current `errno` value.\n\nNote: Until C11, the C standards had contradictory requirements, in that they said that `errno` is a macro but *also* that \"it is unspecified whether `errno` is a macro or an identifier declared with external linkage\". C11 fixes this, requiring that it be defined as a macro (see also WG14 [N1338](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1338.htm)).\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n \nvoid show_errno(void)\n{\n    const char *err_info = \"unknown error\";\n    switch (errno) {\n    case EDOM:\n        err_info = \"domain error\";\n        break;\n    case EILSEQ:\n        err_info = \"illegal sequence\";\n        break;\n    case ERANGE:\n        err_info = \"pole or range error\";\n        break;\n    case 0:\n        err_info = \"no error\";\n    }\n    fputs(err_info, stdout);\n    puts(\" occurred\");\n}\n \nint main(void)\n{\n    fputs(\"MATH_ERRNO is \", stdout);\n    puts(math_errhandling & MATH_ERRNO ? \"set\" : \"not set\");\n \n    errno = 0;\n    1.0/0.0;\n    show_errno();\n \n    errno = 0;\n    acos(+1.1);\n    show_errno();\n \n    errno = 0;\n    log(0.0);\n    show_errno();\n \n    errno = 0;\n    sin(0.0);\n    show_errno();\n}\n```\n\nPossible output:\n\n```\nMATH_ERRNO is set\nno error occurred\ndomain error occurred\npole or range error occurred\nno error occurred\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.5 Errors \\<errno.h\\> (p: 205)\n  - K.3.1.3 Use of errno (p: 584)\n  - K.3.2 Errors \\<errno.h\\> (p: 585)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.5 Errors \\<errno.h\\> (p: 186)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.1.3 Errors \\<errno.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/error/errno](https://en.cppreference.com/w/c/error/errno)"
- name: Error handling
  summary: The standard library provides bounds-checked versions of some existing functions (gets_s, fopen_s, printf_s, strcpy_s, wcscpy_s, mbstowcs_s, qsort_s, getenv_s, etc)
  description: "# Error handling\n\n### Error numbers\n\n[TABLE]\n\n### Assertions\n\n[TABLE]\n\n[TABLE]\n\n### Notes\n\nSince C23, [`static_assert`](language/_static_assert \"c/language/ Static assert\") is itself a keyword, which may also be a predefined macro, so `<assert.h>` no longer provides it.\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.2 Diagnostics \\<assert.h\\> (p: 186-187)\n  - 7.5 Errors \\<errno.h\\> (p: 205)\n  - 7.19 Common definitions \\<stddef.h\\> (p: 288)\n  - 7.20 Integer types \\<stdint.h\\> (p: 289-295)\n  - 7.21 Input/output \\<stdio.h\\> (p: 296-339)\n  - 7.22 General utilities \\<stdlib.h\\> (p: 340-360)\n  - K.3.1.3 Use of errno (p: 584)\n  - K.3.2/2 errno_t (p: 585)\n  - K.3.3/2 rsize_t (p: 585)\n  - K.3.4/2 RSIZE_MAX (p: 585)\n  - 7.31.3 Errors \\<errno.h\\> (p: 455)\n  - 7.31.10 Integer types \\<stdint.h\\> (p: 456)\n  - 7.31.11 Input/output \\<stdio.h\\> (p: 456)\n  - 7.31.12 General utilities \\<stdlib.h\\> (p: 456)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.2 Diagnostics \\<assert.h\\> (p: 169)\n  - 7.5 Errors \\<errno.h\\> (p: 186)\n  - 7.26.3 Errors \\<errno.h\\> (p: 401)\n  - 7.26.8 Integer types \\<stdint.h\\> (p: 401)\n  - 7.26.9 Input/output \\<stdio.h\\> (p: 402)\n  - 7.26.10 General utilities \\<stdlib.h\\> (p: 402)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.2 DIAGNOSTICS \\<assert.h\\>\n  - 4.1.3 Errors \\<errno.h\\>\n  - 4.13.1 Errors \\<errno.h\\>\n  - 4.13.6 Input/output \\<stdio.h\\>\n  - 4.13.7 General utilities \\<stdlib.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/error](https://en.cppreference.com/w/c/error)"
- name: Error numbers
  summary: Each of the macros defined in <errno.h> expands to an integer constant expression with type int and with a unique positive value
  description: "# Error numbers\n\nEach of the macros defined in `<errno.h>` expands to an integer constant expression with type `int` and with a unique positive value. The following constants are defined by ISO C. The implementation may define more, as long as they begin with `'E'` followed by digits or uppercase letters.\n\n[TABLE]\n\n### Notes\n\nMany additional errno constants are [defined by POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html) and by the [C++ standard library](https://en.cppreference.com/w/cpp/error/errno_macros \"cpp/error/errno macros\"), and individual implementations may define even more, e.g. `errno(3)` on Linux or `intro(2)` on BSD and OS X.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <string.h>\n \nint main(void)\n{\n    errno = 0;\n    printf(\"log(-1.0) = %f\\n\", log(-1.0));\n    printf(\"%s\\n\\n\",strerror(errno));\n \n    errno = 0;\n    printf(\"log(0.0)  = %f\\n\", log(0.0));\n    printf(\"%s\\n\",strerror(errno));\n}\n```\n\nPossible output:\n\n```\nlog(-1.0) = nan\nNumerical argument out of domain\n \nlog(0.0)  = -inf\nNumerical result out of range\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.5/2 Errors \\<errno.h\\> (p: 205)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.5/2 Errors \\<errno.h\\> (p: 186)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.1.3 Errors \\<errno.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/error/errno_macros](https://en.cppreference.com/w/c/error/errno_macros)"
- name: Escape sequences
  summary: Escape sequences are used to represent certain special characters within string literals and character constants
  description: "# Escape sequences\n\nEscape sequences are used to represent certain special characters within [string literals](string_literal \"c/language/string literal\") and [character constants](character_constant \"c/language/character constant\").\n\nThe following escape sequences are available. ISO C requires a diagnostic if the backslash is followed by any character not listed here:\n\n[TABLE]\n\n[TABLE]\n\n### Notes\n\n`\\0` is the most commonly used octal escape sequence, because it represents the terminating null character in null-terminated strings.\n\nThe new-line character `\\n` has special meaning when used in [text mode I/O](../io \"c/io\"): it is converted to the OS-specific newline byte or byte sequence.\n\nOctal escape sequences have a length limit of three octal digits but terminate at the first character that is not a valid octal digit if encountered sooner.\n\nHexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal or character constant (char, char8_t(since C23), char16_t, char32_t(since C11), or wchar_t), the result is unspecified.\n\n|                                                                                                                                                                                                                                                                       |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| A universal character name in a narrow string literal or a 16-bit string literal(since C11) may map to more than one code unit, e.g. `\\U0001f34c` is 4 char code units in UTF-8 (`\\xF0\\x9F\\x8D\\x8C`) and 2 char16_t code units in UTF-16 (`\\xD83C\\xDF4C`)(since C11). | (since C99) |\n\n[TABLE]\n\n|                                                                                                                                                                                                                                                                                                            |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The question mark escape sequence `\\?` is used to prevent [trigraphs](operator_alternative \"c/language/operator alternative\") from being interpreted inside string literals: a string such as `\"??/\"` is compiled as `\"\\\"`, but if the second question mark is escaped, as in `\"?\\?/\"`, it becomes `\"??/\"` | (until C23) |\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"This\\nis\\na\\ntest\\n\\nShe said, \\\"How are you?\\\"\\n\");\n}\n```\n\nOutput:\n\n```\nThis\nis\na\ntest\n \nShe said, \"How are you?\"\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 5.2.2 Character display semantics (p: 18-19)\n  - 6.4.3 Universal Character names (p: 44)\n  - 6.4.4.4 Character constants (p: 48-50)\n- C11 standard (ISO/IEC 9899:2011):\n  - 5.2.2 Character display semantics (p: 24-25)\n  - 6.4.3 Universal Character names (p: 61)\n  - 6.4.4.4 Character constants (p: 67-70)\n- C99 standard (ISO/IEC 9899:1999):\n  - 5.2.2 Character display semantics (p: 19-20)\n  - 6.4.3 Universal Character names (p: 53)\n  - 6.4.4.4 Character constants (p: 59-61)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 2.2.2 Character display semantics\n  - 3.1.3.4 Character constants\n\n### See also\n\n- [ASCII chart](ascii \"c/language/ascii\")\n\n|                                                                                                                   |     |\n|-------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/escape \"cpp/language/escape\") for Escape sequences |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/escape](https://en.cppreference.com/w/c/language/escape)"
- name: exit
  summary: Causes normal program termination to occur
  description: "# exit\n\n[TABLE]\n\nCauses normal program termination to occur.\n\nSeveral cleanup steps are performed:\n\n- functions passed to [`atexit`](atexit \"c/program/atexit\") are called, in reverse order of registration\n- all C streams are flushed and closed\n- files created by [`tmpfile`](../io/tmpfile \"c/io/tmpfile\") are removed\n- control is returned to the host environment. If `exit_code` is zero or [`EXIT_SUCCESS`](exit_status \"c/program/EXIT status\"), an implementation-defined status indicating successful termination is returned. If `exit_code` is [`EXIT_FAILURE`](exit_status \"c/program/EXIT status\"), an implementation-defined status indicating unsuccessful termination is returned. In other cases implementation-defined status value is returned.\n\n### Notes\n\nThe functions registered with [`at_quick_exit`](at_quick_exit \"c/program/at quick exit\") are not called.\n\nThe behavior is undefined if a program calls `exit` more than once, or if it calls `exit` and [`quick_exit`](quick_exit \"c/program/quick exit\")\n\nThe behavior is undefined if during a call to a function registered with [`atexit`](atexit \"c/program/atexit\"), the function exits with [`longjmp`](longjmp \"c/program/longjmp\").\n\nReturning from the [the main function](../language/main_function \"c/language/main function\"), either by a `return` statement or by reaching the end of the function, executes `exit()`, passing the argument of the return statement (or `​0​` if implicit return was used) as `exit_code`.\n\n### Parameters\n\n|           |     |                            |\n|-----------|-----|----------------------------|\n| exit_code | \\-  | exit status of the program |\n\n### Return value\n\n(none)\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE *fp = fopen(\"data.txt\",\"r\");\n    if (fp == NULL)\n    {\n       fprintf(stderr, \"error opening file data.txt in function main()\\n\");\n       exit( EXIT_FAILURE );\n    }\n    fclose(fp);\n    printf(\"Normal Return\\n\");\n    return EXIT_SUCCESS ;\n}\n```\n\nPossible output:\n\n```\nerror opening file data.txt in function main()\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.4.4 The exit function (p: 256)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.4.4 The exit function (p: 351-352)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.4.3 The exit function (p: 315-316)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.4.3 The exit function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/exit](https://en.cppreference.com/w/c/program/exit)"
- name: EXIT_FAILURE
  summary: The EXIT_SUCCESS and EXIT_FAILURE macros expand into integral expressions that can be used as arguments to the exit function (and, therefore, as the values to return from the main function), and indicate program execution status
  description: "# EXIT_SUCCESS, EXIT_FAILURE\n\n[TABLE]\n\nThe `EXIT_SUCCESS` and `EXIT_FAILURE` macros expand into integral expressions that can be used as arguments to the [`exit`](exit \"c/program/exit\") function (and, therefore, as the values to return from the [main function](../language/main_function \"c/language/main function\")), and indicate program execution status.\n\n| Constant       | Explanation                         |\n|----------------|-------------------------------------|\n| `EXIT_SUCCESS` | successful execution of a program   |\n| `EXIT_FAILURE` | unsuccessful execution of a program |\n\n### Notes\n\nBoth `EXIT_SUCCESS` and the value zero indicate successful program execution status (see [`exit`](exit \"c/program/exit\")), although it is not required that `EXIT_SUCCESS` equals zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE *fp = fopen(\"data.txt\",\"r\");\n    if (fp == NULL)\n    {\n       fprintf(stderr, \"fopen() failed in file %s at line # %d\", __FILE__,__LINE__);\n       exit(EXIT_FAILURE);\n    }\n \n    /* Normal processing continues here. */\n    fclose(fp);\n    printf(\"Normal Return\\n\");\n \n    return EXIT_SUCCESS;\n}\n```\n\nOutput:\n\n```\nfopen() failed in file main.cpp at line # 9\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22/3 General utilities \\<stdlib.h\\> (p: 248)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22/3 General utilities \\<stdlib.h\\> (p: 340)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20/3 General utilities \\<stdlib.h\\> (p: 306)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10 General utilities \\<stdlib.h\\>\n\n### See also\n\n|                                                                                                                                                       |     |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/utility/program/EXIT_status \"cpp/utility/program/EXIT status\") for `EXIT_SUCCESS, EXIT_FAILURE` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/EXIT_status](https://en.cppreference.com/w/c/program/EXIT_status)"
- name: EXIT_SUCCESS
  summary: The EXIT_SUCCESS and EXIT_FAILURE macros expand into integral expressions that can be used as arguments to the exit function (and, therefore, as the values to return from the main function), and indicate program execution status
  description: "# EXIT_SUCCESS, EXIT_FAILURE\n\n[TABLE]\n\nThe `EXIT_SUCCESS` and `EXIT_FAILURE` macros expand into integral expressions that can be used as arguments to the [`exit`](exit \"c/program/exit\") function (and, therefore, as the values to return from the [main function](../language/main_function \"c/language/main function\")), and indicate program execution status.\n\n| Constant       | Explanation                         |\n|----------------|-------------------------------------|\n| `EXIT_SUCCESS` | successful execution of a program   |\n| `EXIT_FAILURE` | unsuccessful execution of a program |\n\n### Notes\n\nBoth `EXIT_SUCCESS` and the value zero indicate successful program execution status (see [`exit`](exit \"c/program/exit\")), although it is not required that `EXIT_SUCCESS` equals zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE *fp = fopen(\"data.txt\",\"r\");\n    if (fp == NULL)\n    {\n       fprintf(stderr, \"fopen() failed in file %s at line # %d\", __FILE__,__LINE__);\n       exit(EXIT_FAILURE);\n    }\n \n    /* Normal processing continues here. */\n    fclose(fp);\n    printf(\"Normal Return\\n\");\n \n    return EXIT_SUCCESS;\n}\n```\n\nOutput:\n\n```\nfopen() failed in file main.cpp at line # 9\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22/3 General utilities \\<stdlib.h\\> (p: 248)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22/3 General utilities \\<stdlib.h\\> (p: 340)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20/3 General utilities \\<stdlib.h\\> (p: 306)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10 General utilities \\<stdlib.h\\>\n\n### See also\n\n|                                                                                                                                                       |     |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/utility/program/EXIT_status \"cpp/utility/program/EXIT status\") for `EXIT_SUCCESS, EXIT_FAILURE` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/EXIT_status](https://en.cppreference.com/w/c/program/EXIT_status)"
- name: exp
  summary: If no errors occur, the base-e exponential of arg (earg) is returned
  description: "# exp, expf, expl\n\n[TABLE]\n\n1-3) Computes e ([Euler's number](https://en.wikipedia.org/wiki/E_(mathematical_constant) \"enwiki:E (mathematical constant)\"), 2.7182818...) raised to the given power `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `expl` is called. Otherwise, if `arg` has integer type or the type `double`, `exp` is called. Otherwise, `expf` is called. If `arg` is complex or imaginary, then the macro invokes the corresponding complex function ([`cexpf`](http://en.cppreference.com/w/c/numeric/complex/cexp), [`cexp`](http://en.cppreference.com/w/c/numeric/complex/cexp), [`cexpl`](http://en.cppreference.com/w/c/numeric/complex/cexp)).\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the base-*e* exponential of `arg` (e^(arg)) is returned.\n\nIf a range error occurs due to overflow, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, 1 is returned\n- If the argument is -∞, +0 is returned\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nFor IEEE-compatible type `double`, overflow is guaranteed if 709.8 \\< arg, and underflow is guaranteed if arg \\< -708.4.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"exp(1) = %f\\n\", exp(1));\n    printf(\"FV of $100, continuously compounded at 3%% for 1 year = %f\\n\",\n            100*exp(0.03));\n    // special values\n    printf(\"exp(-0) = %f\\n\", exp(-0.0));\n    printf(\"exp(-Inf) = %f\\n\", exp(-INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"exp(710) = %f\\n\", exp(710));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_OVERFLOW))\n        puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nexp(1) = 2.718282\nFV of $100, continuously compounded at 3% for 1 year = 103.045453\nexp(-0) = 1.000000\nexp(-Inf) = 0.000000\nexp(710) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.6.1 The exp functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.1 The exp functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.1 The exp functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.1 The exp functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.1 The exp functions (p: 242)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.1 The exp functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.1 The exp functions (p: 223)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.1 The exp functions (p: 458)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.1 The exp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/exp](https://en.cppreference.com/w/c/numeric/math/exp)"
- name: exp2
  summary: If no errors occur, the base-2 exponential of n (2n) is returned
  description: "# exp2, exp2f, exp2l\n\n[TABLE]\n\n1-3) Computes 2 raised to the given power `n`.\n\n4) Type-generic macro: If `n` has type `long double`, `exp2l` is called. Otherwise, if `n` has integer type or the type `double`, `exp2` is called. Otherwise, `exp2f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| n   | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the base-*2* exponential of `n` (2^(n)) is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, 1 is returned\n- If the argument is -∞, +0 is returned\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"exp2(5) = %f\\n\", exp2(5));\n    printf(\"exp2(0.5) = %f\\n\", exp2(0.5));\n    printf(\"exp2(-4) = %f\\n\", exp2(-4));\n    // special values\n    printf(\"exp2(-0.9) = %f\\n\", exp2(-0.9));\n    printf(\"exp2(-Inf) = %f\\n\", exp2(-INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"exp2(1024) = %f\\n\", exp2(1024));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nexp2(5) = 32.000000\nexp2(0.5) = 1.414214\nexp2(-4) = 0.062500\nexp2(-0.9) = 0.535887\nexp2(-Inf) = 0.000000\nexp2(1024) = Inf\n    errno == ERANGE: Result too large\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.2 The exp2 functions (p: 177)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.2 The exp2 functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.2 The exp2 functions (p: 242-243)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.2 The exp2 functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.2 The exp2 functions (p: 223)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.2 The exp2 functions (p: 458)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/exp2](https://en.cppreference.com/w/c/numeric/math/exp2)"
- name: exp2f
  summary: If no errors occur, the base-2 exponential of n (2n) is returned
  description: "# exp2, exp2f, exp2l\n\n[TABLE]\n\n1-3) Computes 2 raised to the given power `n`.\n\n4) Type-generic macro: If `n` has type `long double`, `exp2l` is called. Otherwise, if `n` has integer type or the type `double`, `exp2` is called. Otherwise, `exp2f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| n   | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the base-*2* exponential of `n` (2^(n)) is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, 1 is returned\n- If the argument is -∞, +0 is returned\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"exp2(5) = %f\\n\", exp2(5));\n    printf(\"exp2(0.5) = %f\\n\", exp2(0.5));\n    printf(\"exp2(-4) = %f\\n\", exp2(-4));\n    // special values\n    printf(\"exp2(-0.9) = %f\\n\", exp2(-0.9));\n    printf(\"exp2(-Inf) = %f\\n\", exp2(-INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"exp2(1024) = %f\\n\", exp2(1024));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nexp2(5) = 32.000000\nexp2(0.5) = 1.414214\nexp2(-4) = 0.062500\nexp2(-0.9) = 0.535887\nexp2(-Inf) = 0.000000\nexp2(1024) = Inf\n    errno == ERANGE: Result too large\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.2 The exp2 functions (p: 177)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.2 The exp2 functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.2 The exp2 functions (p: 242-243)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.2 The exp2 functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.2 The exp2 functions (p: 223)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.2 The exp2 functions (p: 458)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/exp2](https://en.cppreference.com/w/c/numeric/math/exp2)"
- name: exp2l
  summary: If no errors occur, the base-2 exponential of n (2n) is returned
  description: "# exp2, exp2f, exp2l\n\n[TABLE]\n\n1-3) Computes 2 raised to the given power `n`.\n\n4) Type-generic macro: If `n` has type `long double`, `exp2l` is called. Otherwise, if `n` has integer type or the type `double`, `exp2` is called. Otherwise, `exp2f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| n   | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the base-*2* exponential of `n` (2^(n)) is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, 1 is returned\n- If the argument is -∞, +0 is returned\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"exp2(5) = %f\\n\", exp2(5));\n    printf(\"exp2(0.5) = %f\\n\", exp2(0.5));\n    printf(\"exp2(-4) = %f\\n\", exp2(-4));\n    // special values\n    printf(\"exp2(-0.9) = %f\\n\", exp2(-0.9));\n    printf(\"exp2(-Inf) = %f\\n\", exp2(-INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"exp2(1024) = %f\\n\", exp2(1024));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nexp2(5) = 32.000000\nexp2(0.5) = 1.414214\nexp2(-4) = 0.062500\nexp2(-0.9) = 0.535887\nexp2(-Inf) = 0.000000\nexp2(1024) = Inf\n    errno == ERANGE: Result too large\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.2 The exp2 functions (p: 177)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.2 The exp2 functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.2 The exp2 functions (p: 242-243)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.2 The exp2 functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.2 The exp2 functions (p: 223)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.2 The exp2 functions (p: 458)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/exp2](https://en.cppreference.com/w/c/numeric/math/exp2)"
- name: expf
  summary: If no errors occur, the base-e exponential of arg (earg) is returned
  description: "# exp, expf, expl\n\n[TABLE]\n\n1-3) Computes e ([Euler's number](https://en.wikipedia.org/wiki/E_(mathematical_constant) \"enwiki:E (mathematical constant)\"), 2.7182818...) raised to the given power `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `expl` is called. Otherwise, if `arg` has integer type or the type `double`, `exp` is called. Otherwise, `expf` is called. If `arg` is complex or imaginary, then the macro invokes the corresponding complex function ([`cexpf`](http://en.cppreference.com/w/c/numeric/complex/cexp), [`cexp`](http://en.cppreference.com/w/c/numeric/complex/cexp), [`cexpl`](http://en.cppreference.com/w/c/numeric/complex/cexp)).\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the base-*e* exponential of `arg` (e^(arg)) is returned.\n\nIf a range error occurs due to overflow, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, 1 is returned\n- If the argument is -∞, +0 is returned\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nFor IEEE-compatible type `double`, overflow is guaranteed if 709.8 \\< arg, and underflow is guaranteed if arg \\< -708.4.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"exp(1) = %f\\n\", exp(1));\n    printf(\"FV of $100, continuously compounded at 3%% for 1 year = %f\\n\",\n            100*exp(0.03));\n    // special values\n    printf(\"exp(-0) = %f\\n\", exp(-0.0));\n    printf(\"exp(-Inf) = %f\\n\", exp(-INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"exp(710) = %f\\n\", exp(710));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_OVERFLOW))\n        puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nexp(1) = 2.718282\nFV of $100, continuously compounded at 3% for 1 year = 103.045453\nexp(-0) = 1.000000\nexp(-Inf) = 0.000000\nexp(710) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.6.1 The exp functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.1 The exp functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.1 The exp functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.1 The exp functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.1 The exp functions (p: 242)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.1 The exp functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.1 The exp functions (p: 223)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.1 The exp functions (p: 458)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.1 The exp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/exp](https://en.cppreference.com/w/c/numeric/math/exp)"
- name: expl
  summary: If no errors occur, the base-e exponential of arg (earg) is returned
  description: "# exp, expf, expl\n\n[TABLE]\n\n1-3) Computes e ([Euler's number](https://en.wikipedia.org/wiki/E_(mathematical_constant) \"enwiki:E (mathematical constant)\"), 2.7182818...) raised to the given power `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `expl` is called. Otherwise, if `arg` has integer type or the type `double`, `exp` is called. Otherwise, `expf` is called. If `arg` is complex or imaginary, then the macro invokes the corresponding complex function ([`cexpf`](http://en.cppreference.com/w/c/numeric/complex/cexp), [`cexp`](http://en.cppreference.com/w/c/numeric/complex/cexp), [`cexpl`](http://en.cppreference.com/w/c/numeric/complex/cexp)).\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the base-*e* exponential of `arg` (e^(arg)) is returned.\n\nIf a range error occurs due to overflow, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, 1 is returned\n- If the argument is -∞, +0 is returned\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nFor IEEE-compatible type `double`, overflow is guaranteed if 709.8 \\< arg, and underflow is guaranteed if arg \\< -708.4.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"exp(1) = %f\\n\", exp(1));\n    printf(\"FV of $100, continuously compounded at 3%% for 1 year = %f\\n\",\n            100*exp(0.03));\n    // special values\n    printf(\"exp(-0) = %f\\n\", exp(-0.0));\n    printf(\"exp(-Inf) = %f\\n\", exp(-INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"exp(710) = %f\\n\", exp(710));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_OVERFLOW))\n        puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nexp(1) = 2.718282\nFV of $100, continuously compounded at 3% for 1 year = 103.045453\nexp(-0) = 1.000000\nexp(-Inf) = 0.000000\nexp(710) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.6.1 The exp functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.1 The exp functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.1 The exp functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.1 The exp functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.1 The exp functions (p: 242)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.1 The exp functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.1 The exp functions (p: 223)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.1 The exp functions (p: 458)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.1 The exp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/exp](https://en.cppreference.com/w/c/numeric/math/exp)"
- name: expm1
  summary: If no errors occur earg-1 is returned
  description: "# expm1, expm1f, expm1l\n\n[TABLE]\n\n1-3) Computes the *e* (Euler's number, `2.7182818`) raised to the given power `arg`, minus `1.0`. This function is more accurate than the expression [`exp`](http://en.cppreference.com/w/c/numeric/math/exp)`(``arg``)``-``1.0` if `arg` is close to zero.\n\n4) Type-generic macro: If `arg` has type `long double`, `expm1l` is called. Otherwise, if `arg` has integer type or the type `double`, `expm1` is called. Otherwise, `expm1f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur e^(arg)-1 is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in `math_errhandling`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, it is returned, unmodified\n- If the argument is -∞, -1 is returned\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nThe functions `expm1` and [`log1p`](log1p \"c/numeric/math/log1p\") are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)^(n)-1 can be expressed as `expm1``(``n ``*`` `[`log1p`](http://en.cppreference.com/w/c/numeric/math/log1p)`(``x``)``)`. These functions also simplify writing accurate inverse hyperbolic functions.\n\nFor IEEE-compatible type `double`, overflow is guaranteed if 709.8 \\< arg.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"expm1(1) = %f\\n\", expm1(1));\n    printf(\"Interest earned in 2 days on $100, compounded daily at 1%%\\n\"\n           \" on a 30/360 calendar = %f\\n\",\n           100*expm1(2*log1p(0.01/360)));\n    printf(\"exp(1e-16)-1 = %g, but expm1(1e-16) = %g\\n\",\n           exp(1e-16)-1, expm1(1e-16));\n    // special values\n    printf(\"expm1(-0) = %f\\n\", expm1(-0.0));\n    printf(\"expm1(-Inf) = %f\\n\", expm1(-INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"expm1(710) = %f\\n\", expm1(710));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nexpm1(1) = 1.718282\nInterest earned in 2 days on $100, compounded daily at 1%\n on a 30/360 calendar = 0.005556\nexp(1e-16)-1 = 0, but expm1(1e-16) = 1e-16\nexpm1(-0) = -0.000000\nexpm1(-Inf) = -1.000000\nexpm1(710) = inf\n    errno == ERANGE: Result too large\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.3 The expm1 functions (p: 177)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.3 The expm1 functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.3 The expm1 functions (p: 243)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.3 The expm1 functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.3 The expm1 functions (p: 223-224)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.3 The expm1 functions (p: 458)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/expm1](https://en.cppreference.com/w/c/numeric/math/expm1)"
- name: expm1f
  summary: If no errors occur earg-1 is returned
  description: "# expm1, expm1f, expm1l\n\n[TABLE]\n\n1-3) Computes the *e* (Euler's number, `2.7182818`) raised to the given power `arg`, minus `1.0`. This function is more accurate than the expression [`exp`](http://en.cppreference.com/w/c/numeric/math/exp)`(``arg``)``-``1.0` if `arg` is close to zero.\n\n4) Type-generic macro: If `arg` has type `long double`, `expm1l` is called. Otherwise, if `arg` has integer type or the type `double`, `expm1` is called. Otherwise, `expm1f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur e^(arg)-1 is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in `math_errhandling`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, it is returned, unmodified\n- If the argument is -∞, -1 is returned\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nThe functions `expm1` and [`log1p`](log1p \"c/numeric/math/log1p\") are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)^(n)-1 can be expressed as `expm1``(``n ``*`` `[`log1p`](http://en.cppreference.com/w/c/numeric/math/log1p)`(``x``)``)`. These functions also simplify writing accurate inverse hyperbolic functions.\n\nFor IEEE-compatible type `double`, overflow is guaranteed if 709.8 \\< arg.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"expm1(1) = %f\\n\", expm1(1));\n    printf(\"Interest earned in 2 days on $100, compounded daily at 1%%\\n\"\n           \" on a 30/360 calendar = %f\\n\",\n           100*expm1(2*log1p(0.01/360)));\n    printf(\"exp(1e-16)-1 = %g, but expm1(1e-16) = %g\\n\",\n           exp(1e-16)-1, expm1(1e-16));\n    // special values\n    printf(\"expm1(-0) = %f\\n\", expm1(-0.0));\n    printf(\"expm1(-Inf) = %f\\n\", expm1(-INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"expm1(710) = %f\\n\", expm1(710));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nexpm1(1) = 1.718282\nInterest earned in 2 days on $100, compounded daily at 1%\n on a 30/360 calendar = 0.005556\nexp(1e-16)-1 = 0, but expm1(1e-16) = 1e-16\nexpm1(-0) = -0.000000\nexpm1(-Inf) = -1.000000\nexpm1(710) = inf\n    errno == ERANGE: Result too large\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.3 The expm1 functions (p: 177)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.3 The expm1 functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.3 The expm1 functions (p: 243)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.3 The expm1 functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.3 The expm1 functions (p: 223-224)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.3 The expm1 functions (p: 458)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/expm1](https://en.cppreference.com/w/c/numeric/math/expm1)"
- name: expm1l
  summary: If no errors occur earg-1 is returned
  description: "# expm1, expm1f, expm1l\n\n[TABLE]\n\n1-3) Computes the *e* (Euler's number, `2.7182818`) raised to the given power `arg`, minus `1.0`. This function is more accurate than the expression [`exp`](http://en.cppreference.com/w/c/numeric/math/exp)`(``arg``)``-``1.0` if `arg` is close to zero.\n\n4) Type-generic macro: If `arg` has type `long double`, `expm1l` is called. Otherwise, if `arg` has integer type or the type `double`, `expm1` is called. Otherwise, `expm1f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur e^(arg)-1 is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in `math_errhandling`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, it is returned, unmodified\n- If the argument is -∞, -1 is returned\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nThe functions `expm1` and [`log1p`](log1p \"c/numeric/math/log1p\") are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)^(n)-1 can be expressed as `expm1``(``n ``*`` `[`log1p`](http://en.cppreference.com/w/c/numeric/math/log1p)`(``x``)``)`. These functions also simplify writing accurate inverse hyperbolic functions.\n\nFor IEEE-compatible type `double`, overflow is guaranteed if 709.8 \\< arg.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"expm1(1) = %f\\n\", expm1(1));\n    printf(\"Interest earned in 2 days on $100, compounded daily at 1%%\\n\"\n           \" on a 30/360 calendar = %f\\n\",\n           100*expm1(2*log1p(0.01/360)));\n    printf(\"exp(1e-16)-1 = %g, but expm1(1e-16) = %g\\n\",\n           exp(1e-16)-1, expm1(1e-16));\n    // special values\n    printf(\"expm1(-0) = %f\\n\", expm1(-0.0));\n    printf(\"expm1(-Inf) = %f\\n\", expm1(-INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"expm1(710) = %f\\n\", expm1(710));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nexpm1(1) = 1.718282\nInterest earned in 2 days on $100, compounded daily at 1%\n on a 30/360 calendar = 0.005556\nexp(1e-16)-1 = 0, but expm1(1e-16) = 1e-16\nexpm1(-0) = -0.000000\nexpm1(-Inf) = -1.000000\nexpm1(710) = inf\n    errno == ERANGE: Result too large\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.3 The expm1 functions (p: 177)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.3 The expm1 functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.3 The expm1 functions (p: 243)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.3 The expm1 functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.3 The expm1 functions (p: 223-224)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.3 The expm1 functions (p: 458)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/expm1](https://en.cppreference.com/w/c/numeric/math/expm1)"
- name: Expressions
  summary: An expression is a sequence of operators and their operands, that specifies a computation
  description: "# Expressions\n\nAn expression is a sequence of *operators* and their *operands*, that specifies a computation.\n\nExpression evaluation may produce a result (e.g., evaluation of `2+2` produces the result `4`), may generate side-effects (e.g. evaluation of [`printf`](http://en.cppreference.com/w/c/io/fprintf)`(``\"%d\"``,``4``)` sends the character `'4'` to the standard output stream), and may designate objects or functions.\n\n#### General\n\n- [value categories](value_category \"c/language/value category\") (lvalue, non-lvalue object, function designator) classify expressions by their values\n- [order of evaluation](eval_order \"c/language/eval order\") of arguments and subexpressions specifies the order in which intermediate results are obtained\n\n### Operators\n\n[TABLE]\n\n- [operator precedence](operator_precedence \"c/language/operator precedence\") defines the order in which operators are bound to their arguments\n- [alternative representations](operator_alternative \"c/language/operator alternative\") are alternative spellings for some operators\n\n#### Conversions\n\n- [Implicit conversions](conversion \"c/language/conversion\") take place when types of operands do not match the expectations of operators\n- [Casts](cast \"c/language/cast\") may be used to explicitly convert values from one type to another.\n\n#### Other\n\n- [constant expressions](constant_expression \"c/language/constant expression\") can be evaluated at compile time and used in compile-time context (non-VLA (since C99)array sizes, static initializers, etc)\n\n[TABLE]\n\n[TABLE]\n\n### Primary expressions\n\nThe operands of any operator may be other expressions or they may be *primary expressions* (e.g. in `1+2*3`, the operands of operator+ are the subexpression `2*3` and the primary expression `1`).\n\nPrimary expressions are any of the following:\n\n1) Constants and literals (e.g. `2` or `\"Hello, world\"`)\n\n2) Suitably declared [identifiers](identifier \"c/language/identifier\") (e.g. `n` or [`printf`](http://en.cppreference.com/w/c/io/fprintf))\n\n|                                                       |             |\n|-------------------------------------------------------|-------------|\n| 3) [Generic selections](generic \"c/language/generic\") | (since C11) |\n\nAny expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator.\n\n#### Constants and literals\n\nConstant values of certain types may be embedded in the source code of a C program using specialized expressions known as literals (for lvalue expressions) and constants (for non-lvalue expressions)\n\n- [integer constants](integer_constant \"c/language/integer constant\") are decimal, octal, or hexadecimal numbers of integer type.\n- [character constants](character_constant \"c/language/character constant\") are individual characters of type `int` suitable for conversion to a character type or of type `char8_t`,(since C23) `char16_t`, `char32_t`, or (since C11)`wchar_t`\n- [floating constants](floating_constant \"c/language/floating constant\") are values of type `float`, `double`, or `long double`\n\n[TABLE]\n\n- [string literals](string_literal \"c/language/string literal\") are sequences of characters of type `char[]`, `char8_t[]`(since C23), `char16_t[]`, `char32_t[]`,(since C11) or `wchar_t[]` that represent null-terminated strings\n\n[TABLE]\n\n### Unevaluated expressions\n\nThe operands of the [`sizeof` operator](sizeof \"c/language/sizeof\") are expressions that are not evaluated (unless they are VLAs)(since C99). Thus, [`size_t`](http://en.cppreference.com/w/c/types/size_t)` n ``=`` ``sizeof``(`[`printf`](http://en.cppreference.com/w/c/io/fprintf)`(``\"%d\"``, ``4``)``)``;` does not perform console output.\n\n|                                                                                                                                                                                                                                                                         |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The operands of the [`_Alignof` operator](_alignof \"c/language/ Alignof\"), the controlling expression of a [generic selection](generic \"c/language/generic\"), and size expressions of VLAs that are operands of `_Alignof` are also expressions that are not evaluated. | (since C11) |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5 Expressions (p: 55-75)\n  - 6.6 Constant expressions (p: 76-77)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5 Expressions (p: 76-105)\n  - 6.6 Constant expressions (p: 106-107)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5 Expressions (p: 67-94)\n  - 6.6 Constant expressions (p: 95-96)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.3 EXPRESSIONS\n  - 3.4 CONSTANT EXPRESSIONS\n\n### See also\n\n|                                                                                                                        |     |\n|------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/expressions \"cpp/language/expressions\") for Expressions |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/expressions](https://en.cppreference.com/w/c/language/expressions)"
- name: extern
  summary: ''
  description: "# C keywords: extern\n\n### Usage\n\n- [static duration storage-class specifier](../language/storage_duration \"c/language/storage duration\") with either internal or more usually external linkage.\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/extern](https://en.cppreference.com/w/c/keyword/extern)"
- name: External and tentative definitions
  summary: 'At the top level of a translation unit (that is, a source file with all the #includes after the preprocessor), every C program is a sequence of declarations, which declare functions and objects with external or internal linkage'
  description: "# External and tentative definitions\n\nAt the top level of a [translation unit](translation_phases \"c/language/translation phases\") (that is, a source file with all the \\#includes after the preprocessor), every C program is a sequence of [declarations](declarations \"c/language/declarations\"), which declare functions and objects with [external or internal linkage](storage_duration \"c/language/storage duration\"). These declarations are known as *external declarations* because they appear outside of any function.\n\n```\nextern int n; // external declaration with external linkage\nint b = 1;    // external definition with external linkage\nstatic const char *c = \"abc\"; // external definition with internal linkage\nint f(void) {  // external definition with external linkage\n    int a = 1; // non-external\n    return b; \n}\nstatic void x(void) { // external definition with internal linkage\n}\n```\n\nObjects declared with an external declaration have static [storage duration](storage_duration \"c/language/storage duration\"), and as such cannot use `auto` or `register` specifiers except that `auto` can be used for type inference(since C23). The identifiers introduced by external declarations have [file scope](scope \"c/language/scope\").\n\n### Tentative definitions\n\nA *tentative definition* is an external declaration without an initializer, and either without a [storage-class specifier](storage_duration \"c/language/storage duration\") or with the specifier `static`.\n\nA *tentative definition* is a declaration that may or may not act as a definition. If an actual external definition is found earlier or later in the same translation unit, then the tentative definition just acts as a declaration.\n\n```\nint i1 = 1;     // definition, external linkage\nint i1;         // tentative definition, acts as declaration because i1 is defined\nextern int i1;  // declaration, refers to the earlier definition\n \nextern int i2 = 3; // definition, external linkage\nint i2;            // tentative definition, acts as declaration because i2 is defined\nextern int i2;     // declaration, refers to the external linkage definition\n```\n\nIf there are no definitions in the same translation unit, then the tentative definition acts as an actual definition that [empty-initializes](initialization#Empty_initialization \"c/language/initialization\") the object.\n\n```\nint i3;        // tentative definition, external linkage\nint i3;        // tentative definition, external linkage\nextern int i3; // declaration, external linkage\n// in this translation unit, i3 is defined as if by \"int i3 = 0;\"\n```\n\nUnlike the [extern](storage_duration \"c/language/storage duration\") declarations, which don't change the linkage of an identifier if a previous declaration established it, tentative definitions may disagree in linkage with another declaration of the same identifier. If two declarations for the same identifier are in scope and have different linkage, the behavior is undefined:\n\n```\nstatic int i4 = 2; // definition, internal linkage\nint i4;            // Undefined behavior: linkage disagreement with previous line\nextern int i4;     // declaration, refers to the internal linkage definition\n \nstatic int i5; // tentative definition, internal linkage\nint i5;        // Undefined behavior: linkage disagreement with previous line\nextern int i5; // refers to previous, whose linkage is internal\n```\n\nA tentative definition with internal linkage must have complete type.\n\n```\nstatic int i[]; // Error, incomplete type in a static tentative definition\nint i[]; // OK, equivalent to int i[1] = {0}; unless redeclared later in this file\n```\n\n### One definition rule\n\nEach translation unit may have zero or one external definition of every identifier with [internal linkage](storage_duration \"c/language/storage duration\") (a `static` global).\n\nIf an identifier with internal linkage is used in any expression other than a non-VLA,(since C99) [`sizeof`](sizeof \"c/language/sizeof\"), [`_Alignof`](_alignof \"c/language/ Alignof\")(since C11), or [`typeof`](typeof \"c/language/typeof\")(since C23), there must be one and only one external definition for that identifier in the translation unit.\n\nThe entire program may have zero or one external definition of every identifier with [external linkage](storage_duration \"c/language/storage duration\").\n\nIf an identifier with external linkage is used in any expression other than a non-VLA,(since C99) [`sizeof`](sizeof \"c/language/sizeof\"), [`_Alignof`](_alignof \"c/language/ Alignof\")(since C11), or [`typeof`](typeof \"c/language/typeof\")(since C23), there must be one and only one external definition for that identifier somewhere in the entire program.\n\n### Notes\n\n|                                                                                                                                                                                              |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Inline definitions in different translation units are not constrained by one definition rule. See [`inline`](inline \"c/language/inline\") for the details on the inline function definitions. | (since C99) |\n\nSee [storage duration and linkage](storage_duration \"c/language/storage duration\") for the meaning of the keyword `extern` with declarations at file scope\n\nSee [definitions](declarations#Definitions \"c/language/declarations\") for the distinction between declarations and definitions.\n\nTentative definitions were invented to standardize various pre-C89 approaches to forward declaring identifiers with internal linkage.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.9 External definitions (p: 113-116)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.9 External definitions (p: 155-159)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.9 External definitions (p: 140-144)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.7 EXTERNAL DEFINITIONS\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/extern](https://en.cppreference.com/w/c/language/extern)"
- name: fabs
  summary: The functions with decimal floating point parameters are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# fabs, fabsf, fabsl, fabsd32, fabsd64, fabsd128\n\n[TABLE]\n\n1-6) Computes the absolute value of a floating point value `arg`.\n\n|                                                                                                                                                                                                            |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions with decimal floating point parameters are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n7) Type-generic macro: If the argument has type `_Decimal128`, `_Decimal64`, `_Decimal32`,(since C23)`long double`, `double`, or `float`, `fabsd128`, `fabsd64`, `fabsd32`,(since C23)`fabsl`, `fabs`, or `fabsf` is called, respectively. Otherwise, if the argument has integer type, `fabs` is called. Otherwise, if the argument is complex, then the macro invokes the corresponding complex function ([`cabsf`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabs`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabsl`](../complex/cabs \"c/numeric/complex/cabs\")). Otherwise, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                 |\n|-------|-----|---------------------------------|\n| arg   | \\-  | floating point value            |\n| arith | \\-  | floating point or integer value |\n\n### Return value\n\nIf successful, returns the absolute value of `arg` (\\\\\\small \\|arg\\| \\\\\\|arg\\|). The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, +0 is returned\n- If the argument is ±∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \n#define PI 3.14159\n \n// This numerical integration assumes all area is positive.\ndouble integrate(double f(double),\n                 double a, double b, // assume a < b\n                 unsigned steps) // assume steps > 0\n{\n    const double dx = (b - a) / steps;\n    double sum = 0.0;\n    for (double x = a; x < b; x += dx)\n        sum += fabs(f(x));\n    return dx * sum;\n}\n \nint main(void)\n{\n    printf(\"fabs(+3) = %f\\n\", fabs(+3.0));\n    printf(\"fabs(-3) = %f\\n\", fabs(-3.0));\n    // special values\n    printf(\"fabs(-0) = %f\\n\", fabs(-0.0));\n    printf(\"fabs(-Inf) = %f\\n\", fabs(-INFINITY));\n \n    printf(\"Area under sin(x) in [-PI, PI] = %f\\n\", integrate(sin, -PI, PI, 5101));\n}\n```\n\nOutput:\n\n```\nfabs(+3) = 3.000000\nfabs(-3) = 3.000000\nfabs(-0) = 0.000000\nfabs(-Inf) = inf\nArea under sin(x) in [-PI, PI] = 4.000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.7.2 The fabs functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.4.2 The fabs functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.2 The fabs functions (p: 181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.2 The fabs functions (p: 382)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.2 The fabs functions (p: 248)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.2 The fabs functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.2 The fabs functions (p: 228-229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.2 The fabs functions (p: 460)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.2 The fabs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fabs](https://en.cppreference.com/w/c/numeric/math/fabs)"
- name: fabsd128
  summary: The functions with decimal floating point parameters are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# fabs, fabsf, fabsl, fabsd32, fabsd64, fabsd128\n\n[TABLE]\n\n1-6) Computes the absolute value of a floating point value `arg`.\n\n|                                                                                                                                                                                                            |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions with decimal floating point parameters are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n7) Type-generic macro: If the argument has type `_Decimal128`, `_Decimal64`, `_Decimal32`,(since C23)`long double`, `double`, or `float`, `fabsd128`, `fabsd64`, `fabsd32`,(since C23)`fabsl`, `fabs`, or `fabsf` is called, respectively. Otherwise, if the argument has integer type, `fabs` is called. Otherwise, if the argument is complex, then the macro invokes the corresponding complex function ([`cabsf`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabs`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabsl`](../complex/cabs \"c/numeric/complex/cabs\")). Otherwise, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                 |\n|-------|-----|---------------------------------|\n| arg   | \\-  | floating point value            |\n| arith | \\-  | floating point or integer value |\n\n### Return value\n\nIf successful, returns the absolute value of `arg` (\\\\\\small \\|arg\\| \\\\\\|arg\\|). The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, +0 is returned\n- If the argument is ±∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \n#define PI 3.14159\n \n// This numerical integration assumes all area is positive.\ndouble integrate(double f(double),\n                 double a, double b, // assume a < b\n                 unsigned steps) // assume steps > 0\n{\n    const double dx = (b - a) / steps;\n    double sum = 0.0;\n    for (double x = a; x < b; x += dx)\n        sum += fabs(f(x));\n    return dx * sum;\n}\n \nint main(void)\n{\n    printf(\"fabs(+3) = %f\\n\", fabs(+3.0));\n    printf(\"fabs(-3) = %f\\n\", fabs(-3.0));\n    // special values\n    printf(\"fabs(-0) = %f\\n\", fabs(-0.0));\n    printf(\"fabs(-Inf) = %f\\n\", fabs(-INFINITY));\n \n    printf(\"Area under sin(x) in [-PI, PI] = %f\\n\", integrate(sin, -PI, PI, 5101));\n}\n```\n\nOutput:\n\n```\nfabs(+3) = 3.000000\nfabs(-3) = 3.000000\nfabs(-0) = 0.000000\nfabs(-Inf) = inf\nArea under sin(x) in [-PI, PI] = 4.000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.7.2 The fabs functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.4.2 The fabs functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.2 The fabs functions (p: 181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.2 The fabs functions (p: 382)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.2 The fabs functions (p: 248)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.2 The fabs functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.2 The fabs functions (p: 228-229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.2 The fabs functions (p: 460)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.2 The fabs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fabs](https://en.cppreference.com/w/c/numeric/math/fabs)"
- name: fabsd32
  summary: The functions with decimal floating point parameters are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# fabs, fabsf, fabsl, fabsd32, fabsd64, fabsd128\n\n[TABLE]\n\n1-6) Computes the absolute value of a floating point value `arg`.\n\n|                                                                                                                                                                                                            |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions with decimal floating point parameters are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n7) Type-generic macro: If the argument has type `_Decimal128`, `_Decimal64`, `_Decimal32`,(since C23)`long double`, `double`, or `float`, `fabsd128`, `fabsd64`, `fabsd32`,(since C23)`fabsl`, `fabs`, or `fabsf` is called, respectively. Otherwise, if the argument has integer type, `fabs` is called. Otherwise, if the argument is complex, then the macro invokes the corresponding complex function ([`cabsf`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabs`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabsl`](../complex/cabs \"c/numeric/complex/cabs\")). Otherwise, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                 |\n|-------|-----|---------------------------------|\n| arg   | \\-  | floating point value            |\n| arith | \\-  | floating point or integer value |\n\n### Return value\n\nIf successful, returns the absolute value of `arg` (\\\\\\small \\|arg\\| \\\\\\|arg\\|). The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, +0 is returned\n- If the argument is ±∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \n#define PI 3.14159\n \n// This numerical integration assumes all area is positive.\ndouble integrate(double f(double),\n                 double a, double b, // assume a < b\n                 unsigned steps) // assume steps > 0\n{\n    const double dx = (b - a) / steps;\n    double sum = 0.0;\n    for (double x = a; x < b; x += dx)\n        sum += fabs(f(x));\n    return dx * sum;\n}\n \nint main(void)\n{\n    printf(\"fabs(+3) = %f\\n\", fabs(+3.0));\n    printf(\"fabs(-3) = %f\\n\", fabs(-3.0));\n    // special values\n    printf(\"fabs(-0) = %f\\n\", fabs(-0.0));\n    printf(\"fabs(-Inf) = %f\\n\", fabs(-INFINITY));\n \n    printf(\"Area under sin(x) in [-PI, PI] = %f\\n\", integrate(sin, -PI, PI, 5101));\n}\n```\n\nOutput:\n\n```\nfabs(+3) = 3.000000\nfabs(-3) = 3.000000\nfabs(-0) = 0.000000\nfabs(-Inf) = inf\nArea under sin(x) in [-PI, PI] = 4.000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.7.2 The fabs functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.4.2 The fabs functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.2 The fabs functions (p: 181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.2 The fabs functions (p: 382)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.2 The fabs functions (p: 248)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.2 The fabs functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.2 The fabs functions (p: 228-229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.2 The fabs functions (p: 460)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.2 The fabs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fabs](https://en.cppreference.com/w/c/numeric/math/fabs)"
- name: fabsd64
  summary: The functions with decimal floating point parameters are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# fabs, fabsf, fabsl, fabsd32, fabsd64, fabsd128\n\n[TABLE]\n\n1-6) Computes the absolute value of a floating point value `arg`.\n\n|                                                                                                                                                                                                            |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions with decimal floating point parameters are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n7) Type-generic macro: If the argument has type `_Decimal128`, `_Decimal64`, `_Decimal32`,(since C23)`long double`, `double`, or `float`, `fabsd128`, `fabsd64`, `fabsd32`,(since C23)`fabsl`, `fabs`, or `fabsf` is called, respectively. Otherwise, if the argument has integer type, `fabs` is called. Otherwise, if the argument is complex, then the macro invokes the corresponding complex function ([`cabsf`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabs`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabsl`](../complex/cabs \"c/numeric/complex/cabs\")). Otherwise, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                 |\n|-------|-----|---------------------------------|\n| arg   | \\-  | floating point value            |\n| arith | \\-  | floating point or integer value |\n\n### Return value\n\nIf successful, returns the absolute value of `arg` (\\\\\\small \\|arg\\| \\\\\\|arg\\|). The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, +0 is returned\n- If the argument is ±∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \n#define PI 3.14159\n \n// This numerical integration assumes all area is positive.\ndouble integrate(double f(double),\n                 double a, double b, // assume a < b\n                 unsigned steps) // assume steps > 0\n{\n    const double dx = (b - a) / steps;\n    double sum = 0.0;\n    for (double x = a; x < b; x += dx)\n        sum += fabs(f(x));\n    return dx * sum;\n}\n \nint main(void)\n{\n    printf(\"fabs(+3) = %f\\n\", fabs(+3.0));\n    printf(\"fabs(-3) = %f\\n\", fabs(-3.0));\n    // special values\n    printf(\"fabs(-0) = %f\\n\", fabs(-0.0));\n    printf(\"fabs(-Inf) = %f\\n\", fabs(-INFINITY));\n \n    printf(\"Area under sin(x) in [-PI, PI] = %f\\n\", integrate(sin, -PI, PI, 5101));\n}\n```\n\nOutput:\n\n```\nfabs(+3) = 3.000000\nfabs(-3) = 3.000000\nfabs(-0) = 0.000000\nfabs(-Inf) = inf\nArea under sin(x) in [-PI, PI] = 4.000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.7.2 The fabs functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.4.2 The fabs functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.2 The fabs functions (p: 181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.2 The fabs functions (p: 382)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.2 The fabs functions (p: 248)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.2 The fabs functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.2 The fabs functions (p: 228-229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.2 The fabs functions (p: 460)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.2 The fabs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fabs](https://en.cppreference.com/w/c/numeric/math/fabs)"
- name: fabsf
  summary: The functions with decimal floating point parameters are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# fabs, fabsf, fabsl, fabsd32, fabsd64, fabsd128\n\n[TABLE]\n\n1-6) Computes the absolute value of a floating point value `arg`.\n\n|                                                                                                                                                                                                            |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions with decimal floating point parameters are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n7) Type-generic macro: If the argument has type `_Decimal128`, `_Decimal64`, `_Decimal32`,(since C23)`long double`, `double`, or `float`, `fabsd128`, `fabsd64`, `fabsd32`,(since C23)`fabsl`, `fabs`, or `fabsf` is called, respectively. Otherwise, if the argument has integer type, `fabs` is called. Otherwise, if the argument is complex, then the macro invokes the corresponding complex function ([`cabsf`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabs`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabsl`](../complex/cabs \"c/numeric/complex/cabs\")). Otherwise, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                 |\n|-------|-----|---------------------------------|\n| arg   | \\-  | floating point value            |\n| arith | \\-  | floating point or integer value |\n\n### Return value\n\nIf successful, returns the absolute value of `arg` (\\\\\\small \\|arg\\| \\\\\\|arg\\|). The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, +0 is returned\n- If the argument is ±∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \n#define PI 3.14159\n \n// This numerical integration assumes all area is positive.\ndouble integrate(double f(double),\n                 double a, double b, // assume a < b\n                 unsigned steps) // assume steps > 0\n{\n    const double dx = (b - a) / steps;\n    double sum = 0.0;\n    for (double x = a; x < b; x += dx)\n        sum += fabs(f(x));\n    return dx * sum;\n}\n \nint main(void)\n{\n    printf(\"fabs(+3) = %f\\n\", fabs(+3.0));\n    printf(\"fabs(-3) = %f\\n\", fabs(-3.0));\n    // special values\n    printf(\"fabs(-0) = %f\\n\", fabs(-0.0));\n    printf(\"fabs(-Inf) = %f\\n\", fabs(-INFINITY));\n \n    printf(\"Area under sin(x) in [-PI, PI] = %f\\n\", integrate(sin, -PI, PI, 5101));\n}\n```\n\nOutput:\n\n```\nfabs(+3) = 3.000000\nfabs(-3) = 3.000000\nfabs(-0) = 0.000000\nfabs(-Inf) = inf\nArea under sin(x) in [-PI, PI] = 4.000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.7.2 The fabs functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.4.2 The fabs functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.2 The fabs functions (p: 181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.2 The fabs functions (p: 382)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.2 The fabs functions (p: 248)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.2 The fabs functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.2 The fabs functions (p: 228-229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.2 The fabs functions (p: 460)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.2 The fabs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fabs](https://en.cppreference.com/w/c/numeric/math/fabs)"
- name: fabsl
  summary: The functions with decimal floating point parameters are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# fabs, fabsf, fabsl, fabsd32, fabsd64, fabsd128\n\n[TABLE]\n\n1-6) Computes the absolute value of a floating point value `arg`.\n\n|                                                                                                                                                                                                            |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions with decimal floating point parameters are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n7) Type-generic macro: If the argument has type `_Decimal128`, `_Decimal64`, `_Decimal32`,(since C23)`long double`, `double`, or `float`, `fabsd128`, `fabsd64`, `fabsd32`,(since C23)`fabsl`, `fabs`, or `fabsf` is called, respectively. Otherwise, if the argument has integer type, `fabs` is called. Otherwise, if the argument is complex, then the macro invokes the corresponding complex function ([`cabsf`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabs`](../complex/cabs \"c/numeric/complex/cabs\"), [`cabsl`](../complex/cabs \"c/numeric/complex/cabs\")). Otherwise, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                 |\n|-------|-----|---------------------------------|\n| arg   | \\-  | floating point value            |\n| arith | \\-  | floating point or integer value |\n\n### Return value\n\nIf successful, returns the absolute value of `arg` (\\\\\\small \\|arg\\| \\\\\\|arg\\|). The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, +0 is returned\n- If the argument is ±∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \n#define PI 3.14159\n \n// This numerical integration assumes all area is positive.\ndouble integrate(double f(double),\n                 double a, double b, // assume a < b\n                 unsigned steps) // assume steps > 0\n{\n    const double dx = (b - a) / steps;\n    double sum = 0.0;\n    for (double x = a; x < b; x += dx)\n        sum += fabs(f(x));\n    return dx * sum;\n}\n \nint main(void)\n{\n    printf(\"fabs(+3) = %f\\n\", fabs(+3.0));\n    printf(\"fabs(-3) = %f\\n\", fabs(-3.0));\n    // special values\n    printf(\"fabs(-0) = %f\\n\", fabs(-0.0));\n    printf(\"fabs(-Inf) = %f\\n\", fabs(-INFINITY));\n \n    printf(\"Area under sin(x) in [-PI, PI] = %f\\n\", integrate(sin, -PI, PI, 5101));\n}\n```\n\nOutput:\n\n```\nfabs(+3) = 3.000000\nfabs(-3) = 3.000000\nfabs(-0) = 0.000000\nfabs(-Inf) = inf\nArea under sin(x) in [-PI, PI] = 4.000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.7.2 The fabs functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.4.2 The fabs functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.2 The fabs functions (p: 181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.2 The fabs functions (p: 382)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.2 The fabs functions (p: 248)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.2 The fabs functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.2 The fabs functions (p: 228-229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.2 The fabs functions (p: 460)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.2 The fabs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fabs](https://en.cppreference.com/w/c/numeric/math/fabs)"
- name: 'false'
  summary: ''
  description: "# C keywords: false (since C23)\n\n### Usage\n\n- [predefined boolean constant](../language/bool_constant \"c/language/bool constant\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/false](https://en.cppreference.com/w/c/keyword/false)"
- name: fclose
  summary: Closes the given file stream
  description: "# fclose\n\n[TABLE]\n\nCloses the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.\n\nWhether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by [`setbuf`](setbuf \"c/io/setbuf\") or [`setvbuf`](setvbuf \"c/io/setvbuf\"), if any, is also disassociated and deallocated if automatic allocation was used.\n\nThe behavior is undefined if the value of the pointer `stream` is used after `fclose` returns.\n\n### Parameters\n\n|        |     |                          |\n|--------|-----|--------------------------|\n| stream | \\-  | the file stream to close |\n\n### Return value\n\n`​0​` on success, [`EOF`](../io \"c/io\") otherwise\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char* fname = \"/tmp/unique_name.txt\"; // or tmpnam(NULL);\n    int is_ok = EXIT_FAILURE;\n \n    FILE* fp = fopen(fname, \"w+\");\n    if (!fp) {\n        perror(\"File opening failed\");\n        return is_ok;\n    }\n    fputs(\"Hello, world!\\n\", fp);\n    rewind(fp);\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = fgetc(fp)) != EOF) // standard C I/O file reading loop\n        putchar(c);\n \n    if (ferror(fp))\n        puts(\"I/O error when reading\");\n    else if (feof(fp)) {\n        puts(\"End of file is reached successfully\");\n        is_ok = EXIT_SUCCESS;\n    }\n \n    fclose(fp);\n    remove(fname);\n    return is_ok;\n}\n```\n\nPossible output:\n\n```\nHello, world!\nEnd of file is reached successfully\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.5.1 The fclose function (p: 304)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.5.1 The fclose function (p: 270)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.5.1 The fclose function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fclose](https://en.cppreference.com/w/c/io/fclose)"
- name: fdim
  summary: If successful, returns the positive difference between x and y
  description: "# fdim, fdimf, fdiml\n\n[TABLE]\n\n1-3) Returns the positive difference between `x` and `y`, that is, if `x>y`, returns `x-y`, otherwise (if `x≤y`), returns +0.\n\n4) Type-generic macro: If any argument has type `long double`, `fdiml` is called. Otherwise, if any argument has integer type or has type `double`, `fdim` is called. Otherwise, `fdimf` is called.\n\n### Parameters\n\n|      |     |                      |\n|------|-----|----------------------|\n| x, y | \\-  | floating point value |\n\n### Return value\n\nIf successful, returns the positive difference between x and y.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct value (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in `math_errhandling`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If either argument is NaN, NaN is returned\n\n### Notes\n\nEquivalent to [`fmax`](http://en.cppreference.com/w/c/numeric/math/fmax)`(``x``-``y, ``0``)` except for the NaN handling requirements.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"fdim(4, 1) = %f, fdim(1, 4)=%f\\n\", fdim(4,1), fdim(1,4));\n    printf(\"fdim(4,-1) = %f, fdim(1,-4)=%f\\n\", fdim(4,-1), fdim(1,-4));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"fdim(1e308, -1e308) = %f\\n\", fdim(1e308, -1e308));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nfdim(4, 1) = 3.000000, fdim(1, 4)=0.000000\nfdim(4,-1) = 5.000000, fdim(1,-4)=5.000000\nfdim(1e308, -1e308) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.12.1 The fdim functions (p: 187-188)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.9.1 The fdim functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.12.1 The fdim functions (p: 257)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.9.1 The fdim functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.12.1 The fdim functions (p: 238)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.9.1 The fdim functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fdim](https://en.cppreference.com/w/c/numeric/math/fdim)"
- name: fdimf
  summary: If successful, returns the positive difference between x and y
  description: "# fdim, fdimf, fdiml\n\n[TABLE]\n\n1-3) Returns the positive difference between `x` and `y`, that is, if `x>y`, returns `x-y`, otherwise (if `x≤y`), returns +0.\n\n4) Type-generic macro: If any argument has type `long double`, `fdiml` is called. Otherwise, if any argument has integer type or has type `double`, `fdim` is called. Otherwise, `fdimf` is called.\n\n### Parameters\n\n|      |     |                      |\n|------|-----|----------------------|\n| x, y | \\-  | floating point value |\n\n### Return value\n\nIf successful, returns the positive difference between x and y.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct value (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in `math_errhandling`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If either argument is NaN, NaN is returned\n\n### Notes\n\nEquivalent to [`fmax`](http://en.cppreference.com/w/c/numeric/math/fmax)`(``x``-``y, ``0``)` except for the NaN handling requirements.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"fdim(4, 1) = %f, fdim(1, 4)=%f\\n\", fdim(4,1), fdim(1,4));\n    printf(\"fdim(4,-1) = %f, fdim(1,-4)=%f\\n\", fdim(4,-1), fdim(1,-4));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"fdim(1e308, -1e308) = %f\\n\", fdim(1e308, -1e308));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nfdim(4, 1) = 3.000000, fdim(1, 4)=0.000000\nfdim(4,-1) = 5.000000, fdim(1,-4)=5.000000\nfdim(1e308, -1e308) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.12.1 The fdim functions (p: 187-188)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.9.1 The fdim functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.12.1 The fdim functions (p: 257)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.9.1 The fdim functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.12.1 The fdim functions (p: 238)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.9.1 The fdim functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fdim](https://en.cppreference.com/w/c/numeric/math/fdim)"
- name: fdiml
  summary: If successful, returns the positive difference between x and y
  description: "# fdim, fdimf, fdiml\n\n[TABLE]\n\n1-3) Returns the positive difference between `x` and `y`, that is, if `x>y`, returns `x-y`, otherwise (if `x≤y`), returns +0.\n\n4) Type-generic macro: If any argument has type `long double`, `fdiml` is called. Otherwise, if any argument has integer type or has type `double`, `fdim` is called. Otherwise, `fdimf` is called.\n\n### Parameters\n\n|      |     |                      |\n|------|-----|----------------------|\n| x, y | \\-  | floating point value |\n\n### Return value\n\nIf successful, returns the positive difference between x and y.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct value (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in `math_errhandling`.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If either argument is NaN, NaN is returned\n\n### Notes\n\nEquivalent to [`fmax`](http://en.cppreference.com/w/c/numeric/math/fmax)`(``x``-``y, ``0``)` except for the NaN handling requirements.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"fdim(4, 1) = %f, fdim(1, 4)=%f\\n\", fdim(4,1), fdim(1,4));\n    printf(\"fdim(4,-1) = %f, fdim(1,-4)=%f\\n\", fdim(4,-1), fdim(1,-4));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"fdim(1e308, -1e308) = %f\\n\", fdim(1e308, -1e308));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nfdim(4, 1) = 3.000000, fdim(1, 4)=0.000000\nfdim(4,-1) = 5.000000, fdim(1,-4)=5.000000\nfdim(1e308, -1e308) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.12.1 The fdim functions (p: 187-188)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.9.1 The fdim functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.12.1 The fdim functions (p: 257)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.9.1 The fdim functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.12.1 The fdim functions (p: 238)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.9.1 The fdim functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fdim](https://en.cppreference.com/w/c/numeric/math/fdim)"
- name: FE_ALL_EXCEPT
  summary: All these macro constants (except FE_ALL_EXCEPT) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions
  description: "# FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT\n\n[TABLE]\n\nAll these macro constants (except `FE_ALL_EXCEPT`) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.\n\nThe macro constant `FE_ALL_EXCEPT`, which expands to the bitwise OR of all other `FE_*`, is always defined and is zero if floating-point exceptions are not supported by the implementation.\n\n| Constant        | Explanation                                                                                       |\n|-----------------|---------------------------------------------------------------------------------------------------|\n| `FE_DIVBYZERO`  | pole error occurred in an earlier floating-point operation                                        |\n| `FE_INEXACT`    | inexact result: rounding was necessary to store the result of an earlier floating-point operation |\n| `FE_INVALID`    | domain error occurred in an earlier floating-point operation                                      |\n| `FE_OVERFLOW`   | the result of an earlier floating-point operation was too large to be representable               |\n| `FE_UNDERFLOW`  | the result of an earlier floating-point operation was subnormal with a loss of precision          |\n| `FE_ALL_EXCEPT` | bitwise OR of all supported floating-point exceptions                                             |\n\nThe implementation may define additional macro constants in `<fenv.h>` to identify additional floating-point exceptions. All such constants begin with `FE_` followed by at least one uppercase letter.\n\nSee [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\") for further details.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nvoid show_fe_exceptions(void)\n{\n    printf(\"exceptions raised:\");\n    if(fetestexcept(FE_DIVBYZERO)) printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))   printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))   printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))  printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW)) printf(\" FE_UNDERFLOW\");\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    printf(\"MATH_ERREXCEPT is %s\\n\",\n           math_errhandling & MATH_ERREXCEPT ? \"set\" : \"not set\");\n \n    printf(\"0.0/0.0 = %f\\n\", 0.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/0.0 = %f\\n\", 1.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/10.0 = %f\\n\", 1.0/10.0);\n    show_fe_exceptions();\n \n    printf(\"sqrt(-1) = %f\\n\", sqrt(-1));\n    show_fe_exceptions();\n \n    printf(\"DBL_MAX*2.0 = %f\\n\", DBL_MAX*2.0);\n    show_fe_exceptions();\n \n    printf(\"nextafter(DBL_MIN/pow(2.0,52),0.0) = %.1f\\n\",\n                      nextafter(DBL_MIN/pow(2.0,52),0.0));\n    show_fe_exceptions();\n}\n```\n\nPossible output:\n\n```\nMATH_ERREXCEPT is set\n0.0/0.0 = nan\nexceptions raised: FE_INVALID\n1.0/0.0 = inf\nexceptions raised: FE_DIVBYZERO\n1.0/10.0 = 0.100000\nexceptions raised: FE_INEXACT\nsqrt(-1) = -nan\nexceptions raised: FE_INVALID\nDBL_MAX*2.0 = inf\nexceptions raised: FE_INEXACT FE_OVERFLOW\nnextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0\nexceptions raised: FE_INEXACT FE_UNDERFLOW\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/6 Floating-point environment \\<fenv.h\\> (p: 207)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/5 Floating-point environment \\<fenv.h\\> (p: 188)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions](https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions)"
- name: FE_DFL_ENV
  summary: The macro constant FE_DFL_ENV expands to an expression of type const fenv_t*, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup
  description: "# FE_DFL_ENV\n\n[TABLE]\n\nThe macro constant `FE_DFL_ENV` expands to an expression of type `const fenv_t*`, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.\n\nAdditional macros that begin with `FE_` followed by uppercase letters, and have the type `const fenv_t*`, may be supported by an implementation.\n\n### Example\n\n```\n#include <stdio.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf(\"current exceptions raised: \");\n    if(fetestexcept(FE_DIVBYZERO))     printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))       printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))       printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))      printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW))     printf(\" FE_UNDERFLOW\");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(\" none\");\n    printf(\"\\n\");\n}\n \nvoid show_fe_rounding_method(void)\n{\n    printf(\"current rounding method:    \");\n    switch (fegetround()) {\n           case FE_TONEAREST:  printf (\"FE_TONEAREST\");  break;\n           case FE_DOWNWARD:   printf (\"FE_DOWNWARD\");   break;\n           case FE_UPWARD:     printf (\"FE_UPWARD\");     break;\n           case FE_TOWARDZERO: printf (\"FE_TOWARDZERO\"); break;\n           default:            printf (\"unknown\");\n    };\n    printf(\"\\n\");\n}\n \nvoid show_fe_environment(void)\n{\n    show_fe_exceptions();\n    show_fe_rounding_method();\n} \n \nint main()\n{\n    printf(\"On startup:\\n\");\n    show_fe_environment();\n \n    // Change environment\n    fesetround(FE_DOWNWARD);     // change rounding mode\n    feraiseexcept(FE_INVALID);   // raise exception\n    printf(\"\\nBefore restoration:\\n\");\n    show_fe_environment();\n \n    fesetenv(FE_DFL_ENV);    // restore\n    printf(\"\\nAfter restoring default environment:\\n\");\n    show_fe_environment();\n}\n```\n\nOutput:\n\n```\nOn startup:\ncurrent exceptions raised:  none\ncurrent rounding method:    FE_TONEAREST\n \nBefore restoration:\ncurrent exceptions raised:  FE_INVALID\ncurrent rounding method:    FE_DOWNWARD\n \nAfter restoring default environment:\ncurrent exceptions raised:  none\ncurrent rounding method:    FE_TONEAREST\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/9 Floating-point environment \\<fenv.h\\> (p: 208)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: 188-189)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_DFL_ENV](https://en.cppreference.com/w/c/numeric/fenv/FE_DFL_ENV)"
- name: FE_DIVBYZERO
  summary: All these macro constants (except FE_ALL_EXCEPT) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions
  description: "# FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT\n\n[TABLE]\n\nAll these macro constants (except `FE_ALL_EXCEPT`) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.\n\nThe macro constant `FE_ALL_EXCEPT`, which expands to the bitwise OR of all other `FE_*`, is always defined and is zero if floating-point exceptions are not supported by the implementation.\n\n| Constant        | Explanation                                                                                       |\n|-----------------|---------------------------------------------------------------------------------------------------|\n| `FE_DIVBYZERO`  | pole error occurred in an earlier floating-point operation                                        |\n| `FE_INEXACT`    | inexact result: rounding was necessary to store the result of an earlier floating-point operation |\n| `FE_INVALID`    | domain error occurred in an earlier floating-point operation                                      |\n| `FE_OVERFLOW`   | the result of an earlier floating-point operation was too large to be representable               |\n| `FE_UNDERFLOW`  | the result of an earlier floating-point operation was subnormal with a loss of precision          |\n| `FE_ALL_EXCEPT` | bitwise OR of all supported floating-point exceptions                                             |\n\nThe implementation may define additional macro constants in `<fenv.h>` to identify additional floating-point exceptions. All such constants begin with `FE_` followed by at least one uppercase letter.\n\nSee [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\") for further details.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nvoid show_fe_exceptions(void)\n{\n    printf(\"exceptions raised:\");\n    if(fetestexcept(FE_DIVBYZERO)) printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))   printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))   printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))  printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW)) printf(\" FE_UNDERFLOW\");\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    printf(\"MATH_ERREXCEPT is %s\\n\",\n           math_errhandling & MATH_ERREXCEPT ? \"set\" : \"not set\");\n \n    printf(\"0.0/0.0 = %f\\n\", 0.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/0.0 = %f\\n\", 1.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/10.0 = %f\\n\", 1.0/10.0);\n    show_fe_exceptions();\n \n    printf(\"sqrt(-1) = %f\\n\", sqrt(-1));\n    show_fe_exceptions();\n \n    printf(\"DBL_MAX*2.0 = %f\\n\", DBL_MAX*2.0);\n    show_fe_exceptions();\n \n    printf(\"nextafter(DBL_MIN/pow(2.0,52),0.0) = %.1f\\n\",\n                      nextafter(DBL_MIN/pow(2.0,52),0.0));\n    show_fe_exceptions();\n}\n```\n\nPossible output:\n\n```\nMATH_ERREXCEPT is set\n0.0/0.0 = nan\nexceptions raised: FE_INVALID\n1.0/0.0 = inf\nexceptions raised: FE_DIVBYZERO\n1.0/10.0 = 0.100000\nexceptions raised: FE_INEXACT\nsqrt(-1) = -nan\nexceptions raised: FE_INVALID\nDBL_MAX*2.0 = inf\nexceptions raised: FE_INEXACT FE_OVERFLOW\nnextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0\nexceptions raised: FE_INEXACT FE_UNDERFLOW\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/6 Floating-point environment \\<fenv.h\\> (p: 207)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/5 Floating-point environment \\<fenv.h\\> (p: 188)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions](https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions)"
- name: FE_DOWNWARD
  summary: Each of these macro constants expands to a nonnegative integer constant expression, which can be used with fesetround and fegetround to indicate one of the supported floating-point rounding modes
  description: "# FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD\n\n[TABLE]\n\nEach of these macro constants expands to a nonnegative integer constant expression, which can be used with [`fesetround`](feround \"c/numeric/fenv/feround\") and [`fegetround`](feround \"c/numeric/fenv/feround\") to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in [`<fenv.h>`](../fenv \"c/numeric/fenv\"), which should all begin with `FE_` followed by at least one uppercase letter. Each macro is only defined if it is supported.\n\n| Constant        | Explanation                                  |\n|-----------------|----------------------------------------------|\n| `FE_DOWNWARD`   | rounding towards negative infinity           |\n| `FE_TONEAREST`  | rounding towards nearest representable value |\n| `FE_TOWARDZERO` | rounding towards zero                        |\n| `FE_UPWARD`     | rounding towards positive infinity           |\n\nAdditional rounding modes may be supported by an implementation.\n\nThe current rounding mode affects the following:\n\n- results of floating-point arithmetic operators outside of constant expressions\n\n```\ndouble x = 1;\nx / 10; // 0.09999999999999999167332731531132594682276248931884765625 or\n        // 0.1000000000000000055511151231257827021181583404541015625\n```\n\n- results of standard library [mathematical functions](../math \"c/numeric/math\")\n\n```\nsqrt(2); // 1.41421356237309492343001693370752036571502685546875 or\n         // 1.4142135623730951454746218587388284504413604736328125\n```\n\n- floating-point to floating-point implicit conversion and casts\n\n```\ndouble d = 1 + DBL_EPSILON;\nfloat f = d; // 1.00000000000000000000000 or\n             // 1.00000011920928955078125\n```\n\n- string conversions such as [`strtod`](../../string/byte/strtof \"c/string/byte/strtof\") or [`printf`](../../io/fprintf \"c/io/fprintf\")\n\n```\nstrtof(\"0.1\", NULL); // 0.0999999940395355224609375 or\n                     // 0.100000001490116119384765625\n```\n\n- the library rounding functions [`nearbyint`](../math/nearbyint \"c/numeric/math/nearbyint\"), [`rint`](../math/rint \"c/numeric/math/rint\"), [`lrint`](../math/rint \"c/numeric/math/rint\")\n\n```\nlrint(2.1); // 2 or 3\n```\n\nThe current rounding mode does NOT affect the following:\n\n- floating-point to integer implicit conversion and casts (always towards zero)\n- results of floating-point arithmetic operators in constant expressions executed at compile time (always to nearest)\n- the library functions [`round`](../math/round \"c/numeric/math/round\"), [`lround`](../math/round \"c/numeric/math/round\"), [`llround`](../math/round \"c/numeric/math/round\"), [`ceil`](../math/ceil \"c/numeric/math/ceil\"), [`floor`](../math/floor \"c/numeric/math/floor\"), [`trunc`](../math/trunc \"c/numeric/math/trunc\")\n\nAs with any [floating-point environment](../fenv \"c/numeric/fenv\") functionality, rounding is only guaranteed if `#pragma STDC FENV_ACCESS ON` is set.\n\nCompilers that do not support the pragma may offer their own ways to support current rounding mode. For example Clang and GCC have the option `-frounding-math` intended to disable optimizations that would change the meaning of rounding-sensitive code.\n\n### Example\n\n```\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main()\n{\n    fesetround(FE_DOWNWARD);\n    puts(\"rounding down: \");\n    printf(\"           pi = %.22f\\n\", acosf(-1));\n    printf(\"strtof(\\\"1.1\\\") = %.22f\\n\", strtof(\"1.1\", NULL));\n    printf(\"    rint(2.1) = %.22f\\n\\n\", rintf(2.1));\n    fesetround(FE_UPWARD);\n    puts(\"rounding up: \");\n    printf(\"           pi = %.22f\\n\", acosf(-1));\n    printf(\"strtof(\\\"1.1\\\") = %.22f\\n\", strtof(\"1.1\", NULL));\n    printf(\"    rint(2.1) = %.22f\\n\", rintf(2.1));\n}\n```\n\nOutput:\n\n```\nrounding down:\n           pi = 3.1415925025939941406250\nstrtof(\"1.1\") = 1.0999999046325683593750\n    rint(2.1) = 2.0000000000000000000000\n \nrounding up:\n           pi = 3.1415927410125732421875\nstrtof(\"1.1\") = 1.1000000238418579101563\n    rint(2.1) = 3.0000000000000000000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: 151)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: 207)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/7 Floating-point environment \\<fenv.h\\> (p: 188)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_round](https://en.cppreference.com/w/c/numeric/fenv/FE_round)"
- name: FE_INEXACT
  summary: All these macro constants (except FE_ALL_EXCEPT) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions
  description: "# FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT\n\n[TABLE]\n\nAll these macro constants (except `FE_ALL_EXCEPT`) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.\n\nThe macro constant `FE_ALL_EXCEPT`, which expands to the bitwise OR of all other `FE_*`, is always defined and is zero if floating-point exceptions are not supported by the implementation.\n\n| Constant        | Explanation                                                                                       |\n|-----------------|---------------------------------------------------------------------------------------------------|\n| `FE_DIVBYZERO`  | pole error occurred in an earlier floating-point operation                                        |\n| `FE_INEXACT`    | inexact result: rounding was necessary to store the result of an earlier floating-point operation |\n| `FE_INVALID`    | domain error occurred in an earlier floating-point operation                                      |\n| `FE_OVERFLOW`   | the result of an earlier floating-point operation was too large to be representable               |\n| `FE_UNDERFLOW`  | the result of an earlier floating-point operation was subnormal with a loss of precision          |\n| `FE_ALL_EXCEPT` | bitwise OR of all supported floating-point exceptions                                             |\n\nThe implementation may define additional macro constants in `<fenv.h>` to identify additional floating-point exceptions. All such constants begin with `FE_` followed by at least one uppercase letter.\n\nSee [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\") for further details.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nvoid show_fe_exceptions(void)\n{\n    printf(\"exceptions raised:\");\n    if(fetestexcept(FE_DIVBYZERO)) printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))   printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))   printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))  printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW)) printf(\" FE_UNDERFLOW\");\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    printf(\"MATH_ERREXCEPT is %s\\n\",\n           math_errhandling & MATH_ERREXCEPT ? \"set\" : \"not set\");\n \n    printf(\"0.0/0.0 = %f\\n\", 0.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/0.0 = %f\\n\", 1.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/10.0 = %f\\n\", 1.0/10.0);\n    show_fe_exceptions();\n \n    printf(\"sqrt(-1) = %f\\n\", sqrt(-1));\n    show_fe_exceptions();\n \n    printf(\"DBL_MAX*2.0 = %f\\n\", DBL_MAX*2.0);\n    show_fe_exceptions();\n \n    printf(\"nextafter(DBL_MIN/pow(2.0,52),0.0) = %.1f\\n\",\n                      nextafter(DBL_MIN/pow(2.0,52),0.0));\n    show_fe_exceptions();\n}\n```\n\nPossible output:\n\n```\nMATH_ERREXCEPT is set\n0.0/0.0 = nan\nexceptions raised: FE_INVALID\n1.0/0.0 = inf\nexceptions raised: FE_DIVBYZERO\n1.0/10.0 = 0.100000\nexceptions raised: FE_INEXACT\nsqrt(-1) = -nan\nexceptions raised: FE_INVALID\nDBL_MAX*2.0 = inf\nexceptions raised: FE_INEXACT FE_OVERFLOW\nnextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0\nexceptions raised: FE_INEXACT FE_UNDERFLOW\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/6 Floating-point environment \\<fenv.h\\> (p: 207)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/5 Floating-point environment \\<fenv.h\\> (p: 188)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions](https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions)"
- name: FE_INVALID
  summary: All these macro constants (except FE_ALL_EXCEPT) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions
  description: "# FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT\n\n[TABLE]\n\nAll these macro constants (except `FE_ALL_EXCEPT`) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.\n\nThe macro constant `FE_ALL_EXCEPT`, which expands to the bitwise OR of all other `FE_*`, is always defined and is zero if floating-point exceptions are not supported by the implementation.\n\n| Constant        | Explanation                                                                                       |\n|-----------------|---------------------------------------------------------------------------------------------------|\n| `FE_DIVBYZERO`  | pole error occurred in an earlier floating-point operation                                        |\n| `FE_INEXACT`    | inexact result: rounding was necessary to store the result of an earlier floating-point operation |\n| `FE_INVALID`    | domain error occurred in an earlier floating-point operation                                      |\n| `FE_OVERFLOW`   | the result of an earlier floating-point operation was too large to be representable               |\n| `FE_UNDERFLOW`  | the result of an earlier floating-point operation was subnormal with a loss of precision          |\n| `FE_ALL_EXCEPT` | bitwise OR of all supported floating-point exceptions                                             |\n\nThe implementation may define additional macro constants in `<fenv.h>` to identify additional floating-point exceptions. All such constants begin with `FE_` followed by at least one uppercase letter.\n\nSee [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\") for further details.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nvoid show_fe_exceptions(void)\n{\n    printf(\"exceptions raised:\");\n    if(fetestexcept(FE_DIVBYZERO)) printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))   printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))   printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))  printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW)) printf(\" FE_UNDERFLOW\");\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    printf(\"MATH_ERREXCEPT is %s\\n\",\n           math_errhandling & MATH_ERREXCEPT ? \"set\" : \"not set\");\n \n    printf(\"0.0/0.0 = %f\\n\", 0.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/0.0 = %f\\n\", 1.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/10.0 = %f\\n\", 1.0/10.0);\n    show_fe_exceptions();\n \n    printf(\"sqrt(-1) = %f\\n\", sqrt(-1));\n    show_fe_exceptions();\n \n    printf(\"DBL_MAX*2.0 = %f\\n\", DBL_MAX*2.0);\n    show_fe_exceptions();\n \n    printf(\"nextafter(DBL_MIN/pow(2.0,52),0.0) = %.1f\\n\",\n                      nextafter(DBL_MIN/pow(2.0,52),0.0));\n    show_fe_exceptions();\n}\n```\n\nPossible output:\n\n```\nMATH_ERREXCEPT is set\n0.0/0.0 = nan\nexceptions raised: FE_INVALID\n1.0/0.0 = inf\nexceptions raised: FE_DIVBYZERO\n1.0/10.0 = 0.100000\nexceptions raised: FE_INEXACT\nsqrt(-1) = -nan\nexceptions raised: FE_INVALID\nDBL_MAX*2.0 = inf\nexceptions raised: FE_INEXACT FE_OVERFLOW\nnextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0\nexceptions raised: FE_INEXACT FE_UNDERFLOW\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/6 Floating-point environment \\<fenv.h\\> (p: 207)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/5 Floating-point environment \\<fenv.h\\> (p: 188)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions](https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions)"
- name: FE_OVERFLOW
  summary: All these macro constants (except FE_ALL_EXCEPT) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions
  description: "# FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT\n\n[TABLE]\n\nAll these macro constants (except `FE_ALL_EXCEPT`) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.\n\nThe macro constant `FE_ALL_EXCEPT`, which expands to the bitwise OR of all other `FE_*`, is always defined and is zero if floating-point exceptions are not supported by the implementation.\n\n| Constant        | Explanation                                                                                       |\n|-----------------|---------------------------------------------------------------------------------------------------|\n| `FE_DIVBYZERO`  | pole error occurred in an earlier floating-point operation                                        |\n| `FE_INEXACT`    | inexact result: rounding was necessary to store the result of an earlier floating-point operation |\n| `FE_INVALID`    | domain error occurred in an earlier floating-point operation                                      |\n| `FE_OVERFLOW`   | the result of an earlier floating-point operation was too large to be representable               |\n| `FE_UNDERFLOW`  | the result of an earlier floating-point operation was subnormal with a loss of precision          |\n| `FE_ALL_EXCEPT` | bitwise OR of all supported floating-point exceptions                                             |\n\nThe implementation may define additional macro constants in `<fenv.h>` to identify additional floating-point exceptions. All such constants begin with `FE_` followed by at least one uppercase letter.\n\nSee [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\") for further details.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nvoid show_fe_exceptions(void)\n{\n    printf(\"exceptions raised:\");\n    if(fetestexcept(FE_DIVBYZERO)) printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))   printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))   printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))  printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW)) printf(\" FE_UNDERFLOW\");\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    printf(\"MATH_ERREXCEPT is %s\\n\",\n           math_errhandling & MATH_ERREXCEPT ? \"set\" : \"not set\");\n \n    printf(\"0.0/0.0 = %f\\n\", 0.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/0.0 = %f\\n\", 1.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/10.0 = %f\\n\", 1.0/10.0);\n    show_fe_exceptions();\n \n    printf(\"sqrt(-1) = %f\\n\", sqrt(-1));\n    show_fe_exceptions();\n \n    printf(\"DBL_MAX*2.0 = %f\\n\", DBL_MAX*2.0);\n    show_fe_exceptions();\n \n    printf(\"nextafter(DBL_MIN/pow(2.0,52),0.0) = %.1f\\n\",\n                      nextafter(DBL_MIN/pow(2.0,52),0.0));\n    show_fe_exceptions();\n}\n```\n\nPossible output:\n\n```\nMATH_ERREXCEPT is set\n0.0/0.0 = nan\nexceptions raised: FE_INVALID\n1.0/0.0 = inf\nexceptions raised: FE_DIVBYZERO\n1.0/10.0 = 0.100000\nexceptions raised: FE_INEXACT\nsqrt(-1) = -nan\nexceptions raised: FE_INVALID\nDBL_MAX*2.0 = inf\nexceptions raised: FE_INEXACT FE_OVERFLOW\nnextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0\nexceptions raised: FE_INEXACT FE_UNDERFLOW\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/6 Floating-point environment \\<fenv.h\\> (p: 207)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/5 Floating-point environment \\<fenv.h\\> (p: 188)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions](https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions)"
- name: FE_TONEAREST
  summary: Each of these macro constants expands to a nonnegative integer constant expression, which can be used with fesetround and fegetround to indicate one of the supported floating-point rounding modes
  description: "# FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD\n\n[TABLE]\n\nEach of these macro constants expands to a nonnegative integer constant expression, which can be used with [`fesetround`](feround \"c/numeric/fenv/feround\") and [`fegetround`](feround \"c/numeric/fenv/feround\") to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in [`<fenv.h>`](../fenv \"c/numeric/fenv\"), which should all begin with `FE_` followed by at least one uppercase letter. Each macro is only defined if it is supported.\n\n| Constant        | Explanation                                  |\n|-----------------|----------------------------------------------|\n| `FE_DOWNWARD`   | rounding towards negative infinity           |\n| `FE_TONEAREST`  | rounding towards nearest representable value |\n| `FE_TOWARDZERO` | rounding towards zero                        |\n| `FE_UPWARD`     | rounding towards positive infinity           |\n\nAdditional rounding modes may be supported by an implementation.\n\nThe current rounding mode affects the following:\n\n- results of floating-point arithmetic operators outside of constant expressions\n\n```\ndouble x = 1;\nx / 10; // 0.09999999999999999167332731531132594682276248931884765625 or\n        // 0.1000000000000000055511151231257827021181583404541015625\n```\n\n- results of standard library [mathematical functions](../math \"c/numeric/math\")\n\n```\nsqrt(2); // 1.41421356237309492343001693370752036571502685546875 or\n         // 1.4142135623730951454746218587388284504413604736328125\n```\n\n- floating-point to floating-point implicit conversion and casts\n\n```\ndouble d = 1 + DBL_EPSILON;\nfloat f = d; // 1.00000000000000000000000 or\n             // 1.00000011920928955078125\n```\n\n- string conversions such as [`strtod`](../../string/byte/strtof \"c/string/byte/strtof\") or [`printf`](../../io/fprintf \"c/io/fprintf\")\n\n```\nstrtof(\"0.1\", NULL); // 0.0999999940395355224609375 or\n                     // 0.100000001490116119384765625\n```\n\n- the library rounding functions [`nearbyint`](../math/nearbyint \"c/numeric/math/nearbyint\"), [`rint`](../math/rint \"c/numeric/math/rint\"), [`lrint`](../math/rint \"c/numeric/math/rint\")\n\n```\nlrint(2.1); // 2 or 3\n```\n\nThe current rounding mode does NOT affect the following:\n\n- floating-point to integer implicit conversion and casts (always towards zero)\n- results of floating-point arithmetic operators in constant expressions executed at compile time (always to nearest)\n- the library functions [`round`](../math/round \"c/numeric/math/round\"), [`lround`](../math/round \"c/numeric/math/round\"), [`llround`](../math/round \"c/numeric/math/round\"), [`ceil`](../math/ceil \"c/numeric/math/ceil\"), [`floor`](../math/floor \"c/numeric/math/floor\"), [`trunc`](../math/trunc \"c/numeric/math/trunc\")\n\nAs with any [floating-point environment](../fenv \"c/numeric/fenv\") functionality, rounding is only guaranteed if `#pragma STDC FENV_ACCESS ON` is set.\n\nCompilers that do not support the pragma may offer their own ways to support current rounding mode. For example Clang and GCC have the option `-frounding-math` intended to disable optimizations that would change the meaning of rounding-sensitive code.\n\n### Example\n\n```\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main()\n{\n    fesetround(FE_DOWNWARD);\n    puts(\"rounding down: \");\n    printf(\"           pi = %.22f\\n\", acosf(-1));\n    printf(\"strtof(\\\"1.1\\\") = %.22f\\n\", strtof(\"1.1\", NULL));\n    printf(\"    rint(2.1) = %.22f\\n\\n\", rintf(2.1));\n    fesetround(FE_UPWARD);\n    puts(\"rounding up: \");\n    printf(\"           pi = %.22f\\n\", acosf(-1));\n    printf(\"strtof(\\\"1.1\\\") = %.22f\\n\", strtof(\"1.1\", NULL));\n    printf(\"    rint(2.1) = %.22f\\n\", rintf(2.1));\n}\n```\n\nOutput:\n\n```\nrounding down:\n           pi = 3.1415925025939941406250\nstrtof(\"1.1\") = 1.0999999046325683593750\n    rint(2.1) = 2.0000000000000000000000\n \nrounding up:\n           pi = 3.1415927410125732421875\nstrtof(\"1.1\") = 1.1000000238418579101563\n    rint(2.1) = 3.0000000000000000000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: 151)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: 207)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/7 Floating-point environment \\<fenv.h\\> (p: 188)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_round](https://en.cppreference.com/w/c/numeric/fenv/FE_round)"
- name: FE_TOWARDZERO
  summary: Each of these macro constants expands to a nonnegative integer constant expression, which can be used with fesetround and fegetround to indicate one of the supported floating-point rounding modes
  description: "# FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD\n\n[TABLE]\n\nEach of these macro constants expands to a nonnegative integer constant expression, which can be used with [`fesetround`](feround \"c/numeric/fenv/feround\") and [`fegetround`](feround \"c/numeric/fenv/feround\") to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in [`<fenv.h>`](../fenv \"c/numeric/fenv\"), which should all begin with `FE_` followed by at least one uppercase letter. Each macro is only defined if it is supported.\n\n| Constant        | Explanation                                  |\n|-----------------|----------------------------------------------|\n| `FE_DOWNWARD`   | rounding towards negative infinity           |\n| `FE_TONEAREST`  | rounding towards nearest representable value |\n| `FE_TOWARDZERO` | rounding towards zero                        |\n| `FE_UPWARD`     | rounding towards positive infinity           |\n\nAdditional rounding modes may be supported by an implementation.\n\nThe current rounding mode affects the following:\n\n- results of floating-point arithmetic operators outside of constant expressions\n\n```\ndouble x = 1;\nx / 10; // 0.09999999999999999167332731531132594682276248931884765625 or\n        // 0.1000000000000000055511151231257827021181583404541015625\n```\n\n- results of standard library [mathematical functions](../math \"c/numeric/math\")\n\n```\nsqrt(2); // 1.41421356237309492343001693370752036571502685546875 or\n         // 1.4142135623730951454746218587388284504413604736328125\n```\n\n- floating-point to floating-point implicit conversion and casts\n\n```\ndouble d = 1 + DBL_EPSILON;\nfloat f = d; // 1.00000000000000000000000 or\n             // 1.00000011920928955078125\n```\n\n- string conversions such as [`strtod`](../../string/byte/strtof \"c/string/byte/strtof\") or [`printf`](../../io/fprintf \"c/io/fprintf\")\n\n```\nstrtof(\"0.1\", NULL); // 0.0999999940395355224609375 or\n                     // 0.100000001490116119384765625\n```\n\n- the library rounding functions [`nearbyint`](../math/nearbyint \"c/numeric/math/nearbyint\"), [`rint`](../math/rint \"c/numeric/math/rint\"), [`lrint`](../math/rint \"c/numeric/math/rint\")\n\n```\nlrint(2.1); // 2 or 3\n```\n\nThe current rounding mode does NOT affect the following:\n\n- floating-point to integer implicit conversion and casts (always towards zero)\n- results of floating-point arithmetic operators in constant expressions executed at compile time (always to nearest)\n- the library functions [`round`](../math/round \"c/numeric/math/round\"), [`lround`](../math/round \"c/numeric/math/round\"), [`llround`](../math/round \"c/numeric/math/round\"), [`ceil`](../math/ceil \"c/numeric/math/ceil\"), [`floor`](../math/floor \"c/numeric/math/floor\"), [`trunc`](../math/trunc \"c/numeric/math/trunc\")\n\nAs with any [floating-point environment](../fenv \"c/numeric/fenv\") functionality, rounding is only guaranteed if `#pragma STDC FENV_ACCESS ON` is set.\n\nCompilers that do not support the pragma may offer their own ways to support current rounding mode. For example Clang and GCC have the option `-frounding-math` intended to disable optimizations that would change the meaning of rounding-sensitive code.\n\n### Example\n\n```\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main()\n{\n    fesetround(FE_DOWNWARD);\n    puts(\"rounding down: \");\n    printf(\"           pi = %.22f\\n\", acosf(-1));\n    printf(\"strtof(\\\"1.1\\\") = %.22f\\n\", strtof(\"1.1\", NULL));\n    printf(\"    rint(2.1) = %.22f\\n\\n\", rintf(2.1));\n    fesetround(FE_UPWARD);\n    puts(\"rounding up: \");\n    printf(\"           pi = %.22f\\n\", acosf(-1));\n    printf(\"strtof(\\\"1.1\\\") = %.22f\\n\", strtof(\"1.1\", NULL));\n    printf(\"    rint(2.1) = %.22f\\n\", rintf(2.1));\n}\n```\n\nOutput:\n\n```\nrounding down:\n           pi = 3.1415925025939941406250\nstrtof(\"1.1\") = 1.0999999046325683593750\n    rint(2.1) = 2.0000000000000000000000\n \nrounding up:\n           pi = 3.1415927410125732421875\nstrtof(\"1.1\") = 1.1000000238418579101563\n    rint(2.1) = 3.0000000000000000000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: 151)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: 207)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/7 Floating-point environment \\<fenv.h\\> (p: 188)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_round](https://en.cppreference.com/w/c/numeric/fenv/FE_round)"
- name: FE_UNDERFLOW
  summary: All these macro constants (except FE_ALL_EXCEPT) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions
  description: "# FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT\n\n[TABLE]\n\nAll these macro constants (except `FE_ALL_EXCEPT`) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.\n\nThe macro constant `FE_ALL_EXCEPT`, which expands to the bitwise OR of all other `FE_*`, is always defined and is zero if floating-point exceptions are not supported by the implementation.\n\n| Constant        | Explanation                                                                                       |\n|-----------------|---------------------------------------------------------------------------------------------------|\n| `FE_DIVBYZERO`  | pole error occurred in an earlier floating-point operation                                        |\n| `FE_INEXACT`    | inexact result: rounding was necessary to store the result of an earlier floating-point operation |\n| `FE_INVALID`    | domain error occurred in an earlier floating-point operation                                      |\n| `FE_OVERFLOW`   | the result of an earlier floating-point operation was too large to be representable               |\n| `FE_UNDERFLOW`  | the result of an earlier floating-point operation was subnormal with a loss of precision          |\n| `FE_ALL_EXCEPT` | bitwise OR of all supported floating-point exceptions                                             |\n\nThe implementation may define additional macro constants in `<fenv.h>` to identify additional floating-point exceptions. All such constants begin with `FE_` followed by at least one uppercase letter.\n\nSee [math_errhandling](../math/math_errhandling \"c/numeric/math/math errhandling\") for further details.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nvoid show_fe_exceptions(void)\n{\n    printf(\"exceptions raised:\");\n    if(fetestexcept(FE_DIVBYZERO)) printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))   printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))   printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))  printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW)) printf(\" FE_UNDERFLOW\");\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    printf(\"MATH_ERREXCEPT is %s\\n\",\n           math_errhandling & MATH_ERREXCEPT ? \"set\" : \"not set\");\n \n    printf(\"0.0/0.0 = %f\\n\", 0.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/0.0 = %f\\n\", 1.0/0.0);\n    show_fe_exceptions();\n \n    printf(\"1.0/10.0 = %f\\n\", 1.0/10.0);\n    show_fe_exceptions();\n \n    printf(\"sqrt(-1) = %f\\n\", sqrt(-1));\n    show_fe_exceptions();\n \n    printf(\"DBL_MAX*2.0 = %f\\n\", DBL_MAX*2.0);\n    show_fe_exceptions();\n \n    printf(\"nextafter(DBL_MIN/pow(2.0,52),0.0) = %.1f\\n\",\n                      nextafter(DBL_MIN/pow(2.0,52),0.0));\n    show_fe_exceptions();\n}\n```\n\nPossible output:\n\n```\nMATH_ERREXCEPT is set\n0.0/0.0 = nan\nexceptions raised: FE_INVALID\n1.0/0.0 = inf\nexceptions raised: FE_DIVBYZERO\n1.0/10.0 = 0.100000\nexceptions raised: FE_INEXACT\nsqrt(-1) = -nan\nexceptions raised: FE_INVALID\nDBL_MAX*2.0 = inf\nexceptions raised: FE_INEXACT FE_OVERFLOW\nnextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0\nexceptions raised: FE_INEXACT FE_UNDERFLOW\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/6 Floating-point environment \\<fenv.h\\> (p: 207)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/5 Floating-point environment \\<fenv.h\\> (p: 188)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions](https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions)"
- name: FE_UPWARD
  summary: Each of these macro constants expands to a nonnegative integer constant expression, which can be used with fesetround and fegetround to indicate one of the supported floating-point rounding modes
  description: "# FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD\n\n[TABLE]\n\nEach of these macro constants expands to a nonnegative integer constant expression, which can be used with [`fesetround`](feround \"c/numeric/fenv/feround\") and [`fegetround`](feround \"c/numeric/fenv/feround\") to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in [`<fenv.h>`](../fenv \"c/numeric/fenv\"), which should all begin with `FE_` followed by at least one uppercase letter. Each macro is only defined if it is supported.\n\n| Constant        | Explanation                                  |\n|-----------------|----------------------------------------------|\n| `FE_DOWNWARD`   | rounding towards negative infinity           |\n| `FE_TONEAREST`  | rounding towards nearest representable value |\n| `FE_TOWARDZERO` | rounding towards zero                        |\n| `FE_UPWARD`     | rounding towards positive infinity           |\n\nAdditional rounding modes may be supported by an implementation.\n\nThe current rounding mode affects the following:\n\n- results of floating-point arithmetic operators outside of constant expressions\n\n```\ndouble x = 1;\nx / 10; // 0.09999999999999999167332731531132594682276248931884765625 or\n        // 0.1000000000000000055511151231257827021181583404541015625\n```\n\n- results of standard library [mathematical functions](../math \"c/numeric/math\")\n\n```\nsqrt(2); // 1.41421356237309492343001693370752036571502685546875 or\n         // 1.4142135623730951454746218587388284504413604736328125\n```\n\n- floating-point to floating-point implicit conversion and casts\n\n```\ndouble d = 1 + DBL_EPSILON;\nfloat f = d; // 1.00000000000000000000000 or\n             // 1.00000011920928955078125\n```\n\n- string conversions such as [`strtod`](../../string/byte/strtof \"c/string/byte/strtof\") or [`printf`](../../io/fprintf \"c/io/fprintf\")\n\n```\nstrtof(\"0.1\", NULL); // 0.0999999940395355224609375 or\n                     // 0.100000001490116119384765625\n```\n\n- the library rounding functions [`nearbyint`](../math/nearbyint \"c/numeric/math/nearbyint\"), [`rint`](../math/rint \"c/numeric/math/rint\"), [`lrint`](../math/rint \"c/numeric/math/rint\")\n\n```\nlrint(2.1); // 2 or 3\n```\n\nThe current rounding mode does NOT affect the following:\n\n- floating-point to integer implicit conversion and casts (always towards zero)\n- results of floating-point arithmetic operators in constant expressions executed at compile time (always to nearest)\n- the library functions [`round`](../math/round \"c/numeric/math/round\"), [`lround`](../math/round \"c/numeric/math/round\"), [`llround`](../math/round \"c/numeric/math/round\"), [`ceil`](../math/ceil \"c/numeric/math/ceil\"), [`floor`](../math/floor \"c/numeric/math/floor\"), [`trunc`](../math/trunc \"c/numeric/math/trunc\")\n\nAs with any [floating-point environment](../fenv \"c/numeric/fenv\") functionality, rounding is only guaranteed if `#pragma STDC FENV_ACCESS ON` is set.\n\nCompilers that do not support the pragma may offer their own ways to support current rounding mode. For example Clang and GCC have the option `-frounding-math` intended to disable optimizations that would change the meaning of rounding-sensitive code.\n\n### Example\n\n```\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main()\n{\n    fesetround(FE_DOWNWARD);\n    puts(\"rounding down: \");\n    printf(\"           pi = %.22f\\n\", acosf(-1));\n    printf(\"strtof(\\\"1.1\\\") = %.22f\\n\", strtof(\"1.1\", NULL));\n    printf(\"    rint(2.1) = %.22f\\n\\n\", rintf(2.1));\n    fesetround(FE_UPWARD);\n    puts(\"rounding up: \");\n    printf(\"           pi = %.22f\\n\", acosf(-1));\n    printf(\"strtof(\\\"1.1\\\") = %.22f\\n\", strtof(\"1.1\", NULL));\n    printf(\"    rint(2.1) = %.22f\\n\", rintf(2.1));\n}\n```\n\nOutput:\n\n```\nrounding down:\n           pi = 3.1415925025939941406250\nstrtof(\"1.1\") = 1.0999999046325683593750\n    rint(2.1) = 2.0000000000000000000000\n \nrounding up:\n           pi = 3.1415927410125732421875\nstrtof(\"1.1\") = 1.1000000238418579101563\n    rint(2.1) = 3.0000000000000000000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: 151)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6/8 Floating-point environment \\<fenv.h\\> (p: 207)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6/7 Floating-point environment \\<fenv.h\\> (p: 188)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/FE_round](https://en.cppreference.com/w/c/numeric/fenv/FE_round)"
- name: feclearexcept
  summary: Attempts to clear the floating-point exceptions that are listed in the bitmask argument excepts, which is a bitwise OR of the floating-point exception macros
  description: "# feclearexcept\n\n[TABLE]\n\nAttempts to clear the floating-point exceptions that are listed in the bitmask argument `excepts`, which is a bitwise OR of the [floating-point exception macros](fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\n### Parameters\n\n|         |     |                                              |\n|---------|-----|----------------------------------------------|\n| excepts | \\-  | bitmask listing the exception flags to clear |\n\n### Return value\n\n`​0​` if all indicated exceptions were successfully cleared or if `excepts` is zero. Returns a non-zero value on error.\n\n### Example\n\n```\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \n/*\n * A possible implementation of hypot which makes use of many advanced\n * floating-point features.\n */\ndouble hypot_demo(double a, double b) {\n  const int range_problem = FE_OVERFLOW | FE_UNDERFLOW;\n  feclearexcept(range_problem);\n  // try a fast algorithm\n  double result = sqrt(a * a + b * b);\n  if (!fetestexcept(range_problem))  // no overflow or underflow\n    return result;                   // return the fast result\n  // do a more complicated calculation to avoid overflow or underflow\n  int a_exponent,b_exponent;\n  frexp(a, &a_exponent);\n  frexp(b, &b_exponent);\n \n  if (a_exponent - b_exponent > DBL_MAX_EXP)\n    return fabs(a) + fabs(b);        // we can ignore the smaller value\n  // scale so that fabs(a) is near 1\n  double a_scaled = scalbn(a, -a_exponent);\n  double b_scaled = scalbn(b, -a_exponent);\n  // overflow and underflow is now impossible \n  result = sqrt(a_scaled * a_scaled + b_scaled * b_scaled);\n  // undo scaling\n  return scalbn(result, a_exponent);\n}\n \nint main(void)\n{\n  // Normal case takes the fast route\n  printf(\"hypot(%f, %f) = %f\\n\", 3.0, 4.0, hypot_demo(3.0, 4.0));\n  // Extreme case takes the slow but more accurate route\n  printf(\"hypot(%e, %e) = %e\\n\", DBL_MAX / 2.0, \n                                DBL_MAX / 2.0, \n                                hypot_demo(DBL_MAX / 2.0, DBL_MAX / 2.0));\n \n  return 0;\n}\n```\n\nOutput:\n\n```\nhypot(3.000000, 4.000000) = 5.000000\nhypot(8.988466e+307, 8.988466e+307) = 1.271161e+308\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.2.1 The feclearexcept function (p: 209)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.2.1 The feclearexcept function (p: 190)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/feclearexcept](https://en.cppreference.com/w/c/numeric/fenv/feclearexcept)"
- name: fegetenv
  summary: 1) Attempts to store the status of the floating-point environment in the object pointed to by envp
  description: "# fegetenv, fesetenv\n\n[TABLE]\n\n1\\) Attempts to store the status of the floating-point environment in the object pointed to by `envp`.\n\n2\\) Attempts to establish the floating-point environment from the object pointed to by `envp`. The value of that object must be previously obtained by a call to [`feholdexcept`](feholdexcept \"c/numeric/fenv/feholdexcept\") or `fegetenv` or be a floating-point macro constant. If any of the floating-point status flags are set in `envp`, they become set in the environment (and are then testable with [`fetestexcept`](fetestexcept \"c/numeric/fenv/fetestexcept\")), but the corresponding floating-point exceptions are not raised (execution continues uninterrupted)\n\n### Parameters\n\n|      |     |                                                                                                 |\n|------|-----|-------------------------------------------------------------------------------------------------|\n| envp | \\-  | pointer to the object of type `fenv_t` which holds the status of the floating-point environment |\n\n### Return value\n\n`​0​` on success, non-zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf(\"current exceptions raised: \");\n    if(fetestexcept(FE_DIVBYZERO))     printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))       printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))       printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))      printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW))     printf(\" FE_UNDERFLOW\");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(\" none\");\n    printf(\"\\n\");\n}\n \nvoid show_fe_rounding_method(void)\n{\n    printf(\"current rounding method:    \");\n    switch (fegetround()) {\n           case FE_TONEAREST:  printf (\"FE_TONEAREST\");  break;\n           case FE_DOWNWARD:   printf (\"FE_DOWNWARD\");   break;\n           case FE_UPWARD:     printf (\"FE_UPWARD\");     break;\n           case FE_TOWARDZERO: printf (\"FE_TOWARDZERO\"); break;\n           default:            printf (\"unknown\");\n    };\n    printf(\"\\n\");\n}\n \nvoid show_fe_environment(void)\n{\n    show_fe_exceptions();\n    show_fe_rounding_method();\n}    \n \nint main(void)\n{\n    fenv_t curr_env;\n    int rtn;\n \n    /* Show default environment. */\n    show_fe_environment();\n    printf(\"\\n\");\n \n    /* Perform some computation under default environment. */\n    printf(\"+11.5 -> %+4.1f\\n\", rint(+11.5)); /* midway between two integers */\n    printf(\"+12.5 -> %+4.1f\\n\", rint(+12.5)); /* midway between two integers */\n    show_fe_environment();\n    printf(\"\\n\");\n \n    /* Save current environment. */\n    rtn = fegetenv(&curr_env);\n \n    /* Perform some computation with new rounding method. */\n    feclearexcept(FE_ALL_EXCEPT);\n    fesetround(FE_DOWNWARD);\n    printf(\"1.0/0.0 = %f\\n\", 1.0/0.0);\n    printf(\"+11.5 -> %+4.1f\\n\", rint(+11.5));\n    printf(\"+12.5 -> %+4.1f\\n\", rint(+12.5));\n    show_fe_environment();\n    printf(\"\\n\");\n \n    /* Restore previous environment. */\n    rtn = fesetenv(&curr_env);\n    show_fe_environment();\n \n    return 0;\n}\n```\n\nOutput:\n\n```\ncurrent exceptions raised: none\ncurrent rounding method:   FE_TONEAREST\n \n+11.5 -> +12.0\n+12.5 -> +12.0\ncurrent exceptions raised: FE_INEXACT\ncurrent rounding method:   FE_TONEAREST\n \n1.0/0.0 = inf\n+11.5 -> +11.0\n+12.5 -> +12.0\ncurrent exceptions raised: FE_DIVBYZERO FE_INEXACT\ncurrent rounding method:   FE_DOWNWARD\n \ncurrent exceptions raised: FE_INEXACT\ncurrent rounding method:   FE_TONEAREST\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.4.1 The fegetenv function (p: 213)\n  - 7.6.4.3 The fesetenv function (p: 214)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.4.1 The fegetenv function (p: 194)\n  - 7.6.4.3 The fesetenv function (p: 195)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/feenv](https://en.cppreference.com/w/c/numeric/fenv/feenv)"
- name: fegetexceptflag
  summary: 1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument excepts, which is a bitwise OR of the floating-point exception macros
  description: "# fegetexceptflag, fesetexceptflag\n\n[TABLE]\n\n1\\) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument `excepts`, which is a bitwise OR of the [floating-point exception macros](fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\n2\\) Attempts to copy the full contents of the floating-point exception flags that are listed in `excepts` from `flagp` into the floating-point environment. Does not raise any exceptions, only modifies the flags.\n\nThe full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in `flagp` in implementation-defined format.\n\n### Parameters\n\n|         |     |                                                                              |\n|---------|-----|------------------------------------------------------------------------------|\n| flagp   | \\-  | pointer to an `fexcept_t` object where the flags will be stored or read from |\n| excepts | \\-  | bitmask listing the exception flags to get/set                               |\n\n### Return value\n\n`​0​` on success, non-zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf(\"current exceptions raised: \");\n    if(fetestexcept(FE_DIVBYZERO))     printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))       printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))       printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))      printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW))     printf(\" FE_UNDERFLOW\");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(\" none\");\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    fexcept_t excepts;\n \n    /* Setup a \"current\" set of exception flags. */\n    feraiseexcept(FE_INVALID);\n    show_fe_exceptions();\n \n    /* Save current exception flags. */\n    fegetexceptflag(&excepts,FE_ALL_EXCEPT);\n \n    /* Temporarily raise two other exceptions. */\n    feclearexcept(FE_ALL_EXCEPT);\n    feraiseexcept(FE_OVERFLOW | FE_INEXACT);\n    show_fe_exceptions();\n \n    /* Restore previous exception flags. */\n    fesetexceptflag(&excepts,FE_ALL_EXCEPT);\n    show_fe_exceptions();\n \n    return 0;\n}\n```\n\nOutput:\n\n```\ncurrent exceptions raised: FE_INVALID\ncurrent exceptions raised: FE_INEXACT FE_OVERFLOW\ncurrent exceptions raised: FE_INVALID\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.2.2 The fegetexceptflag function (p: 210)\n  - 7.6.2.4 The fesetexceptflag function (p: 211)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.2.2 The fegetexceptflag function (p: 191)\n  - 7.6.2.4 The fesetexceptflag function (p: 192)\n\n### See also\n\n|                                                                                                                                                         |     |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/fenv/feexceptflag \"cpp/numeric/fenv/feexceptflag\") for `fegetexceptflag, fesetexceptflag` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/feexceptflag](https://en.cppreference.com/w/c/numeric/fenv/feexceptflag)"
- name: fegetround
  summary: 1) Attempts to establish the floating-point rounding direction equal to the argument round, which is expected to be one of the floating-point rounding macros
  description: "# fegetround, fesetround\n\n[TABLE]\n\n1\\) Attempts to establish the floating-point rounding direction equal to the argument `round`, which is expected to be one of the [floating-point rounding macros](fe_round \"c/numeric/fenv/FE round\").\n\n2\\) Returns the value of the [floating-point rounding macro](fe_round \"c/numeric/fenv/FE round\") that corresponds to the current rounding direction.\n\n### Parameters\n\n|       |     |                                                                                                 |\n|-------|-----|-------------------------------------------------------------------------------------------------|\n| round | \\-  | rounding direction, one of [floating-point rounding macros](fe_round \"c/numeric/fenv/FE round\") |\n\n### Return value\n\n1\\) `​0​` on success, non-zero otherwise.\n\n2\\) the [floating-point rounding macro](fe_round \"c/numeric/fenv/FE round\") describing the current rounding direction or a negative value if the direction cannot be determined.\n\n### Notes\n\nThe current rounding mode, reflecting the effects of the most recent `fesetround`, can also be queried with [`FLT_ROUNDS`](../../types/limits/flt_rounds \"c/types/limits/FLT ROUNDS\").\n\n### Example\n\n```\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nvoid show_fe_current_rounding_direction(void)\n{\n    printf(\"current rounding direction:  \");\n    switch (fegetround()) {\n           case FE_TONEAREST:  printf (\"FE_TONEAREST\");  break;\n           case FE_DOWNWARD:   printf (\"FE_DOWNWARD\");   break;\n           case FE_UPWARD:     printf (\"FE_UPWARD\");     break;\n           case FE_TOWARDZERO: printf (\"FE_TOWARDZERO\"); break;\n           default:            printf (\"unknown\");\n    };\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    /* Default rounding direction */\n    show_fe_current_rounding_direction();\n    printf(\"+11.5 -> %+4.1f\\n\", rint(+11.5)); /* midway between two integers */\n    printf(\"+12.5 -> %+4.1f\\n\", rint(+12.5)); /* midway between two integers */\n \n    /* Save current rounding direction. */\n    int curr_direction = fegetround();\n \n    /* Temporarily change current rounding direction. */\n    fesetround(FE_DOWNWARD);\n    show_fe_current_rounding_direction();\n    printf(\"+11.5 -> %+4.1f\\n\", rint(+11.5));\n    printf(\"+12.5 -> %+4.1f\\n\", rint(+12.5));\n \n    /* Restore default rounding direction. */\n    fesetround(curr_direction);\n    show_fe_current_rounding_direction();\n \n    return 0;\n}\n```\n\nPossible output:\n\n```\ncurrent rounding direction:  FE_TONEAREST\n+11.5 -> +12.0\n+12.5 -> +12.0\ncurrent rounding direction:  FE_DOWNWARD\n+11.5 -> +11.0\n+12.5 -> +12.0\ncurrent rounding direction:  FE_TONEAREST\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.6.3.1 The fegetround function (p: TBD)\n  - 7.6.3.2 The fesetround function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.6.3.1 The fegetround function (p: TBD)\n  - 7.6.3.2 The fesetround function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.3.1 The fegetround function (p: 212)\n  - 7.6.3.2 The fesetround function (p: 212-213)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.3.1 The fegetround function (p: 193)\n  - 7.6.3.2 The fesetround function (p: 193-194)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/feround](https://en.cppreference.com/w/c/numeric/fenv/feround)"
- name: feholdexcept
  summary: 'First, saves the current floating-point environment to the object pointed to by envp (similar to fegetenv), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by feupdateenv or fesetenv'
  description: "# feholdexcept\n\n[TABLE]\n\nFirst, saves the current floating-point environment to the object pointed to by `envp` (similar to [`fegetenv`](feenv \"c/numeric/fenv/feenv\")), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by [`feupdateenv`](feupdateenv \"c/numeric/fenv/feupdateenv\") or [`fesetenv`](feenv \"c/numeric/fenv/feenv\").\n\nThis function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to [`feupdateenv`](feupdateenv \"c/numeric/fenv/feupdateenv\") after clearing the unwanted exceptions.\n\n### Parameters\n\n|      |     |                                                                                            |\n|------|-----|--------------------------------------------------------------------------------------------|\n| envp | \\-  | pointer to the object of type `fenv_t` where the floating-point environment will be stored |\n\n### Return value\n\n`​0​` on success, non-zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <fenv.h>\n#include <float.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf(\"current exceptions raised: \");\n    if(fetestexcept(FE_DIVBYZERO))     printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))       printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))       printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))      printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW))     printf(\" FE_UNDERFLOW\");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(\" none\");\n    printf(\"\\n\");\n}\n \ndouble x2 (double x)   /* times two */\n{\n    fenv_t curr_excepts;\n \n    /* Save and clear current f-p environment. */\n    feholdexcept(&curr_excepts);\n \n    /* Raise inexact and overflow exceptions. */\n    printf(\"In x2():  x = %f\\n\", x=x*2.0);\n    show_fe_exceptions();\n    feclearexcept(FE_INEXACT);   /* hide inexact exception from caller */\n \n    /* Merge caller's exceptions (FE_INVALID)        */\n    /* with remaining x2's exceptions (FE_OVERFLOW). */\n    feupdateenv(&curr_excepts);\n    return x;\n}\n \nint main(void)\n{    \n    feclearexcept(FE_ALL_EXCEPT);\n    feraiseexcept(FE_INVALID);   /* some computation with invalid argument */\n    show_fe_exceptions();\n    printf(\"x2(DBL_MAX) = %f\\n\", x2(DBL_MAX));\n    show_fe_exceptions();\n \n    return 0;\n}\n```\n\nOutput:\n\n```\ncurrent exceptions raised:  FE_INVALID\nIn x2():  x = inf\ncurrent exceptions raised:  FE_INEXACT FE_OVERFLOW\nx2(DBL_MAX) = inf\ncurrent exceptions raised:  FE_INVALID FE_OVERFLOW\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.4.2 The feholdexcept function (p: 213-214)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.4.2 The feholdexcept function (p: 194-195)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/feholdexcept](https://en.cppreference.com/w/c/numeric/fenv/feholdexcept)"
- name: feof
  summary: Checks if the end of the given file stream has been reached
  description: "# feof\n\n[TABLE]\n\nChecks if the end of the given file stream has been reached.\n\n### Parameters\n\n|        |     |                          |\n|--------|-----|--------------------------|\n| stream | \\-  | the file stream to check |\n\n### Return value\n\nnonzero value if the end of the stream has been reached, otherwise `​0​`\n\n### Notes\n\nThis function only reports the stream state as reported by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a [`fgetc`](fgetc \"c/io/fgetc\"), which returned the last byte of a file, `feof` returns zero. The next [`fgetc`](fgetc \"c/io/fgetc\") fails and changes the stream state to *end-of-file*. Only then `feof` returns non-zero.\n\nIn typical usage, input stream processing stops on any error; `feof` and [`ferror`](ferror \"c/io/ferror\") are then used to distinguish between different error conditions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char* fname = \"/tmp/unique_name.txt\"; // or tmpnam(NULL);\n    int is_ok = EXIT_FAILURE;\n \n    FILE* fp = fopen(fname, \"w+\");\n    if (!fp) {\n        perror(\"File opening failed\");\n        return is_ok;\n    }\n    fputs(\"Hello, world!\\n\", fp);\n    rewind(fp);\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = fgetc(fp)) != EOF) // standard C I/O file reading loop\n        putchar(c);\n \n    if (ferror(fp))\n        puts(\"I/O error when reading\");\n    else if (feof(fp)) {\n        puts(\"End of file is reached successfully\");\n        is_ok = EXIT_SUCCESS;\n    }\n \n    fclose(fp);\n    remove(fname);\n    return is_ok;\n}\n```\n\nPossible output:\n\n```\nHello, world!\nEnd of file is reached successfully\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.10.2 The feof function (p: 339)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.10.2 The feof function (p: 305)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.10.2 The feof function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/feof](https://en.cppreference.com/w/c/io/feof)"
- name: feraiseexcept
  summary: Attempts to raise all floating-point exceptions listed in excepts (a bitwise OR of the floating-point exception macros)
  description: "# feraiseexcept\n\n[TABLE]\n\nAttempts to raise all floating-point exceptions listed in `excepts` (a bitwise OR of the [floating-point exception macros](fe_exceptions \"c/numeric/fenv/FE exceptions\")). If one of the exceptions is [`FE_OVERFLOW`](fe_exceptions \"c/numeric/fenv/FE exceptions\") or [`FE_UNDERFLOW`](http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions), this function may additionally raise [`FE_INEXACT`](fe_exceptions \"c/numeric/fenv/FE exceptions\"). The order in which the exceptions are raised is unspecified, except that [`FE_OVERFLOW`](fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_UNDERFLOW`](http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions) are always raised before [`FE_INEXACT`](fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\n### Parameters\n\n|         |     |                                              |\n|---------|-----|----------------------------------------------|\n| excepts | \\-  | bitmask listing the exception flags to raise |\n\n### Return value\n\n`​0​` if all listed exceptions were raised, non-zero value otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf(\"current exceptions raised: \");\n    if(fetestexcept(FE_DIVBYZERO))     printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))       printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))       printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))      printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW))     printf(\" FE_UNDERFLOW\");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(\" none\");\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"\\n\");\n}\n \ndouble some_computation(void)\n{\n    /* Computation reaches a state that causes overflow. */\n    int r = feraiseexcept(FE_OVERFLOW | FE_INEXACT);\n    printf(\"feraiseexcept() %s\\n\", (r?\"fails\":\"succeeds\"));\n    return 0.0;\n}\n \nint main(void)\n{\n    some_computation();\n    show_fe_exceptions();\n \n    return 0;\n}\n```\n\nOutput:\n\n```\nferaiseexcept() succeeds\ncurrent exceptions raised:  FE_INEXACT FE_OVERFLOW\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.2.3 The feraiseexcept function (p: 210)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.2.3 The feraiseexcept function (p: 191)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/feraiseexcept](https://en.cppreference.com/w/c/numeric/fenv/feraiseexcept)"
- name: ferror
  summary: Checks the given stream for errors
  description: "# ferror\n\n[TABLE]\n\nChecks the given stream for errors.\n\n### Parameters\n\n|        |     |                          |\n|--------|-----|--------------------------|\n| stream | \\-  | the file stream to check |\n\n### Return value\n\nNonzero value if the file stream has errors occurred, `​0​` otherwise\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    char* fname = tmpnam(NULL);\n    FILE* f = fopen(fname, \"wb\");\n    fputs(\"\\xff\\xff\\n\", f); // not a valid UTF-8 character sequence\n    fclose(f);\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    f = fopen(fname, \"rb\");\n    wint_t ch;\n    while ((ch=fgetwc(f)) != WEOF) // attempt to read as UTF-8 fails\n          printf(\"%#x \", ch);\n \n    if (feof(f))\n        puts(\"EOF indicator set\");\n    if (ferror(f))\n        puts(\"Error indicator set\");\n}\n```\n\nOutput:\n\n```\nError indicator set\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.10.3 The ferror function (p: 339)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.10.3 The ferror function (p: 305)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.10.3 The ferror function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/ferror](https://en.cppreference.com/w/c/io/ferror)"
- name: fesetenv
  summary: 1) Attempts to store the status of the floating-point environment in the object pointed to by envp
  description: "# fegetenv, fesetenv\n\n[TABLE]\n\n1\\) Attempts to store the status of the floating-point environment in the object pointed to by `envp`.\n\n2\\) Attempts to establish the floating-point environment from the object pointed to by `envp`. The value of that object must be previously obtained by a call to [`feholdexcept`](feholdexcept \"c/numeric/fenv/feholdexcept\") or `fegetenv` or be a floating-point macro constant. If any of the floating-point status flags are set in `envp`, they become set in the environment (and are then testable with [`fetestexcept`](fetestexcept \"c/numeric/fenv/fetestexcept\")), but the corresponding floating-point exceptions are not raised (execution continues uninterrupted)\n\n### Parameters\n\n|      |     |                                                                                                 |\n|------|-----|-------------------------------------------------------------------------------------------------|\n| envp | \\-  | pointer to the object of type `fenv_t` which holds the status of the floating-point environment |\n\n### Return value\n\n`​0​` on success, non-zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf(\"current exceptions raised: \");\n    if(fetestexcept(FE_DIVBYZERO))     printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))       printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))       printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))      printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW))     printf(\" FE_UNDERFLOW\");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(\" none\");\n    printf(\"\\n\");\n}\n \nvoid show_fe_rounding_method(void)\n{\n    printf(\"current rounding method:    \");\n    switch (fegetround()) {\n           case FE_TONEAREST:  printf (\"FE_TONEAREST\");  break;\n           case FE_DOWNWARD:   printf (\"FE_DOWNWARD\");   break;\n           case FE_UPWARD:     printf (\"FE_UPWARD\");     break;\n           case FE_TOWARDZERO: printf (\"FE_TOWARDZERO\"); break;\n           default:            printf (\"unknown\");\n    };\n    printf(\"\\n\");\n}\n \nvoid show_fe_environment(void)\n{\n    show_fe_exceptions();\n    show_fe_rounding_method();\n}    \n \nint main(void)\n{\n    fenv_t curr_env;\n    int rtn;\n \n    /* Show default environment. */\n    show_fe_environment();\n    printf(\"\\n\");\n \n    /* Perform some computation under default environment. */\n    printf(\"+11.5 -> %+4.1f\\n\", rint(+11.5)); /* midway between two integers */\n    printf(\"+12.5 -> %+4.1f\\n\", rint(+12.5)); /* midway between two integers */\n    show_fe_environment();\n    printf(\"\\n\");\n \n    /* Save current environment. */\n    rtn = fegetenv(&curr_env);\n \n    /* Perform some computation with new rounding method. */\n    feclearexcept(FE_ALL_EXCEPT);\n    fesetround(FE_DOWNWARD);\n    printf(\"1.0/0.0 = %f\\n\", 1.0/0.0);\n    printf(\"+11.5 -> %+4.1f\\n\", rint(+11.5));\n    printf(\"+12.5 -> %+4.1f\\n\", rint(+12.5));\n    show_fe_environment();\n    printf(\"\\n\");\n \n    /* Restore previous environment. */\n    rtn = fesetenv(&curr_env);\n    show_fe_environment();\n \n    return 0;\n}\n```\n\nOutput:\n\n```\ncurrent exceptions raised: none\ncurrent rounding method:   FE_TONEAREST\n \n+11.5 -> +12.0\n+12.5 -> +12.0\ncurrent exceptions raised: FE_INEXACT\ncurrent rounding method:   FE_TONEAREST\n \n1.0/0.0 = inf\n+11.5 -> +11.0\n+12.5 -> +12.0\ncurrent exceptions raised: FE_DIVBYZERO FE_INEXACT\ncurrent rounding method:   FE_DOWNWARD\n \ncurrent exceptions raised: FE_INEXACT\ncurrent rounding method:   FE_TONEAREST\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.4.1 The fegetenv function (p: 213)\n  - 7.6.4.3 The fesetenv function (p: 214)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.4.1 The fegetenv function (p: 194)\n  - 7.6.4.3 The fesetenv function (p: 195)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/feenv](https://en.cppreference.com/w/c/numeric/fenv/feenv)"
- name: fesetexceptflag
  summary: 1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument excepts, which is a bitwise OR of the floating-point exception macros
  description: "# fegetexceptflag, fesetexceptflag\n\n[TABLE]\n\n1\\) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument `excepts`, which is a bitwise OR of the [floating-point exception macros](fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\n2\\) Attempts to copy the full contents of the floating-point exception flags that are listed in `excepts` from `flagp` into the floating-point environment. Does not raise any exceptions, only modifies the flags.\n\nThe full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in `flagp` in implementation-defined format.\n\n### Parameters\n\n|         |     |                                                                              |\n|---------|-----|------------------------------------------------------------------------------|\n| flagp   | \\-  | pointer to an `fexcept_t` object where the flags will be stored or read from |\n| excepts | \\-  | bitmask listing the exception flags to get/set                               |\n\n### Return value\n\n`​0​` on success, non-zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf(\"current exceptions raised: \");\n    if(fetestexcept(FE_DIVBYZERO))     printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))       printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))       printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))      printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW))     printf(\" FE_UNDERFLOW\");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(\" none\");\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    fexcept_t excepts;\n \n    /* Setup a \"current\" set of exception flags. */\n    feraiseexcept(FE_INVALID);\n    show_fe_exceptions();\n \n    /* Save current exception flags. */\n    fegetexceptflag(&excepts,FE_ALL_EXCEPT);\n \n    /* Temporarily raise two other exceptions. */\n    feclearexcept(FE_ALL_EXCEPT);\n    feraiseexcept(FE_OVERFLOW | FE_INEXACT);\n    show_fe_exceptions();\n \n    /* Restore previous exception flags. */\n    fesetexceptflag(&excepts,FE_ALL_EXCEPT);\n    show_fe_exceptions();\n \n    return 0;\n}\n```\n\nOutput:\n\n```\ncurrent exceptions raised: FE_INVALID\ncurrent exceptions raised: FE_INEXACT FE_OVERFLOW\ncurrent exceptions raised: FE_INVALID\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.2.2 The fegetexceptflag function (p: 210)\n  - 7.6.2.4 The fesetexceptflag function (p: 211)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.2.2 The fegetexceptflag function (p: 191)\n  - 7.6.2.4 The fesetexceptflag function (p: 192)\n\n### See also\n\n|                                                                                                                                                         |     |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/fenv/feexceptflag \"cpp/numeric/fenv/feexceptflag\") for `fegetexceptflag, fesetexceptflag` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/feexceptflag](https://en.cppreference.com/w/c/numeric/fenv/feexceptflag)"
- name: fesetround
  summary: 1) Attempts to establish the floating-point rounding direction equal to the argument round, which is expected to be one of the floating-point rounding macros
  description: "# fegetround, fesetround\n\n[TABLE]\n\n1\\) Attempts to establish the floating-point rounding direction equal to the argument `round`, which is expected to be one of the [floating-point rounding macros](fe_round \"c/numeric/fenv/FE round\").\n\n2\\) Returns the value of the [floating-point rounding macro](fe_round \"c/numeric/fenv/FE round\") that corresponds to the current rounding direction.\n\n### Parameters\n\n|       |     |                                                                                                 |\n|-------|-----|-------------------------------------------------------------------------------------------------|\n| round | \\-  | rounding direction, one of [floating-point rounding macros](fe_round \"c/numeric/fenv/FE round\") |\n\n### Return value\n\n1\\) `​0​` on success, non-zero otherwise.\n\n2\\) the [floating-point rounding macro](fe_round \"c/numeric/fenv/FE round\") describing the current rounding direction or a negative value if the direction cannot be determined.\n\n### Notes\n\nThe current rounding mode, reflecting the effects of the most recent `fesetround`, can also be queried with [`FLT_ROUNDS`](../../types/limits/flt_rounds \"c/types/limits/FLT ROUNDS\").\n\n### Example\n\n```\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nvoid show_fe_current_rounding_direction(void)\n{\n    printf(\"current rounding direction:  \");\n    switch (fegetround()) {\n           case FE_TONEAREST:  printf (\"FE_TONEAREST\");  break;\n           case FE_DOWNWARD:   printf (\"FE_DOWNWARD\");   break;\n           case FE_UPWARD:     printf (\"FE_UPWARD\");     break;\n           case FE_TOWARDZERO: printf (\"FE_TOWARDZERO\"); break;\n           default:            printf (\"unknown\");\n    };\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    /* Default rounding direction */\n    show_fe_current_rounding_direction();\n    printf(\"+11.5 -> %+4.1f\\n\", rint(+11.5)); /* midway between two integers */\n    printf(\"+12.5 -> %+4.1f\\n\", rint(+12.5)); /* midway between two integers */\n \n    /* Save current rounding direction. */\n    int curr_direction = fegetround();\n \n    /* Temporarily change current rounding direction. */\n    fesetround(FE_DOWNWARD);\n    show_fe_current_rounding_direction();\n    printf(\"+11.5 -> %+4.1f\\n\", rint(+11.5));\n    printf(\"+12.5 -> %+4.1f\\n\", rint(+12.5));\n \n    /* Restore default rounding direction. */\n    fesetround(curr_direction);\n    show_fe_current_rounding_direction();\n \n    return 0;\n}\n```\n\nPossible output:\n\n```\ncurrent rounding direction:  FE_TONEAREST\n+11.5 -> +12.0\n+12.5 -> +12.0\ncurrent rounding direction:  FE_DOWNWARD\n+11.5 -> +11.0\n+12.5 -> +12.0\ncurrent rounding direction:  FE_TONEAREST\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.6.3.1 The fegetround function (p: TBD)\n  - 7.6.3.2 The fesetround function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.6.3.1 The fegetround function (p: TBD)\n  - 7.6.3.2 The fesetround function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.3.1 The fegetround function (p: 212)\n  - 7.6.3.2 The fesetround function (p: 212-213)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.3.1 The fegetround function (p: 193)\n  - 7.6.3.2 The fesetround function (p: 193-194)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/feround](https://en.cppreference.com/w/c/numeric/fenv/feround)"
- name: fetestexcept
  summary: Determines which of the specified subset of the floating-point exceptions are currently set
  description: "# fetestexcept\n\n[TABLE]\n\nDetermines which of the specified subset of the floating-point exceptions are currently set. The argument `excepts` is a bitwise OR of the [floating-point exception macros](fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\n### Parameters\n\n|         |     |                                             |\n|---------|-----|---------------------------------------------|\n| excepts | \\-  | bitmask listing the exception flags to test |\n\n### Return value\n\nBitwise OR of the floating-point exception macros that are both included in `excepts` and correspond to floating-point exceptions currently set.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <float.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf(\"current exceptions raised: \");\n    if(fetestexcept(FE_DIVBYZERO))     printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))       printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))       printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))      printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW))     printf(\" FE_UNDERFLOW\");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(\" none\");\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    /* Show default set of exception flags. */\n    show_fe_exceptions();\n \n    /* Perform some computations which raise exceptions. */\n    printf(\"1.0/0.0     = %f\\n\", 1.0/0.0);        /* FE_DIVBYZERO            */\n    printf(\"1.0/10.0    = %f\\n\", 1.0/10.0);       /* FE_INEXACT              */\n    printf(\"sqrt(-1)    = %f\\n\", sqrt(-1));       /* FE_INVALID              */\n    printf(\"DBL_MAX*2.0 = %f\\n\", DBL_MAX*2.0);    /* FE_INEXACT FE_OVERFLOW  */\n    printf(\"nextafter(DBL_MIN/pow(2.0,52),0.0) = %.1f\\n\",\n           nextafter(DBL_MIN/pow(2.0,52),0.0));   /* FE_INEXACT FE_UNDERFLOW */\n    show_fe_exceptions();\n \n    return 0;\n}\n```\n\nOutput:\n\n```\ncurrent exceptions raised:  none\n1.0/0.0     = inf\n1.0/10.0    = 0.100000\nsqrt(-1)    = -nan\nDBL_MAX*2.0 = inf\nnextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0\ncurrent exceptions raised:  FE_DIVBYZERO FE_INEXACT FE_INVALID FE_OVERFLOW FE_UNDERFLOW\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.2.5 The fetestexcept function (p: 211-212)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.2.5 The fetestexcept function (p: 192-193)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/fetestexcept](https://en.cppreference.com/w/c/numeric/fenv/fetestexcept)"
- name: feupdateenv
  summary: First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by envp (similar to fesetenv), then raises the floating-point exceptions that were saved
  description: "# feupdateenv\n\n[TABLE]\n\nFirst, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by `envp` (similar to [`fesetenv`](feenv \"c/numeric/fenv/feenv\")), then raises the floating-point exceptions that were saved.\n\nThis function may be used to end the non-stop mode established by an earlier call to [`feholdexcept`](feholdexcept \"c/numeric/fenv/feholdexcept\").\n\n### Parameters\n\n|      |     |                                                                                                                                                                                                                |\n|------|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| envp | \\-  | pointer to the object of type `fenv_t` set by an earlier call to [`feholdexcept`](feholdexcept \"c/numeric/fenv/feholdexcept\") or `fegetenv` or equal to [`FE_DFL_ENV`](fe_dfl_env \"c/numeric/fenv/FE DFL ENV\") |\n\n### Return value\n\n`​0​` on success, non-zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <fenv.h>\n#include <float.h>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_fe_exceptions(void)\n{\n    printf(\"current exceptions raised: \");\n    if(fetestexcept(FE_DIVBYZERO))     printf(\" FE_DIVBYZERO\");\n    if(fetestexcept(FE_INEXACT))       printf(\" FE_INEXACT\");\n    if(fetestexcept(FE_INVALID))       printf(\" FE_INVALID\");\n    if(fetestexcept(FE_OVERFLOW))      printf(\" FE_OVERFLOW\");\n    if(fetestexcept(FE_UNDERFLOW))     printf(\" FE_UNDERFLOW\");\n    if(fetestexcept(FE_ALL_EXCEPT)==0) printf(\" none\");\n    printf(\"\\n\");\n}\n \ndouble x2 (double x)   /* times two */\n{\n    fenv_t curr_excepts;\n \n    /* Save and clear current f-p environment. */\n    feholdexcept(&curr_excepts);\n \n    /* Raise inexact and overflow exceptions. */\n    printf(\"In x2():  x = %f\\n\", x=x*2.0);\n    show_fe_exceptions();\n    feclearexcept(FE_INEXACT);   /* hide inexact exception from caller */\n \n    /* Merge caller's exceptions (FE_INVALID)        */\n    /* with remaining x2's exceptions (FE_OVERFLOW). */\n    feupdateenv(&curr_excepts);\n    return x;\n}\n \nint main(void)\n{    \n    feclearexcept(FE_ALL_EXCEPT);\n    feraiseexcept(FE_INVALID);   /* some computation with invalid argument */\n    show_fe_exceptions();\n    printf(\"x2(DBL_MAX) = %f\\n\", x2(DBL_MAX));\n    show_fe_exceptions();\n \n    return 0;\n}\n```\n\nOutput:\n\n```\ncurrent exceptions raised:  FE_INVALID\nIn x2():  x = inf\ncurrent exceptions raised:  FE_INEXACT FE_OVERFLOW\nx2(DBL_MAX) = inf\ncurrent exceptions raised:  FE_INVALID FE_OVERFLOW\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6.4.4 The feupdateenv function (p: 214-215)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6.4.4 The feupdateenv function (p: 195-196)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv/feupdateenv](https://en.cppreference.com/w/c/numeric/fenv/feupdateenv)"
- name: fflush
  summary: For output streams (and for update streams on which the last operation was output), writes any unwritten data from the stream's buffer to the associated output device
  description: "# fflush\n\n[TABLE]\n\nFor output streams (and for update streams on which the last operation was output), writes any unwritten data from the `stream`'s buffer to the associated output device.\n\nFor input streams (and for update streams on which the last operation was input), the behavior is undefined.\n\nIf `stream` is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.\n\n### Parameters\n\n|        |     |                              |\n|--------|-----|------------------------------|\n| stream | \\-  | the file stream to write out |\n\n### Return value\n\nReturns zero on success. Otherwise [`EOF`](../io \"c/io\") is returned and the error indicator of the file stream is set.\n\n### Notes\n\nPOSIX [extends the specification of fflush](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html) by defining its effects on an input stream, as long as that stream represents a file or another seekable device: in that case the POSIX file pointer is repositioned to match the C stream pointer (which effectively undoes any read buffering) and the effects of any [`ungetc`](ungetc \"c/io/ungetc\") or [`ungetwc`](ungetwc \"c/io/ungetwc\") that weren't yet read back from the stream are discarded.\n\nMicrosoft also extends the specification of fflush by defining its effects on an input stream: in Visual Studio 2013 and prior, it [discarded the input buffer](https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9yky46tz(v=vs.120)), in Visual Studio 2015 and newer, it [has no effect, buffers are retained](https://msdn.microsoft.com/en-us/library/9yky46tz.aspx).\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.5.2 The fflush function (p: 305)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.5.2 The fflush function (p: 270-271)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.5.2 The fflush function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fflush](https://en.cppreference.com/w/c/io/fflush)"
- name: fgetc
  summary: On success, returns the obtained character as an unsigned char converted to an int
  description: "# fgetc, getc\n\n[TABLE]\n\n1) Reads the next character from the given input stream.\n\n2) Same as `fgetc`, except that if `getc` is implemented as a macro, it may evaluate stream more than once, so the corresponding argument should never be an expression with side effects.\n\n### Parameters\n\n|        |     |                            |\n|--------|-----|----------------------------|\n| stream | \\-  | to read the character from |\n\n### Return value\n\nOn success, returns the obtained character as an `unsigned char` converted to an `int`. On failure, returns [`EOF`](../io \"c/io\").\n\nIf the failure has been caused by end-of-file condition, additionally sets the *eof* indicator (see [`feof()`](feof \"c/io/feof\")) on `stream`. If the failure has been caused by some other error, sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char* fname = \"/tmp/unique_name.txt\"; // or tmpnam(NULL);\n    int is_ok = EXIT_FAILURE;\n \n    FILE* fp = fopen(fname, \"w+\");\n    if (!fp) {\n        perror(\"File opening failed\");\n        return is_ok;\n    }\n    fputs(\"Hello, world!\\n\", fp);\n    rewind(fp);\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = fgetc(fp)) != EOF) // standard C I/O file reading loop\n        putchar(c);\n \n    if (ferror(fp))\n        puts(\"I/O error when reading\");\n    else if (feof(fp)) {\n        puts(\"End of file is reached successfully\");\n        is_ok = EXIT_SUCCESS;\n    }\n \n    fclose(fp);\n    remove(fname);\n    return is_ok;\n}\n```\n\nPossible output:\n\n```\nHello, world!\nEnd of file is reached successfully\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.7.1 The fgetc function (p: 240-241)\n  - 7.21.7.5 The getc function (p: 242)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.7.1 The fgetc function (p: 330)\n  - 7.21.7.5 The getc function (p: 332)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.1 The fgetc function (p: 296)\n  - 7.19.7.5 The getc function (p: 297-298)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.1 The fgetc function\n  - 4.9.7.5 The getc function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fgetc](https://en.cppreference.com/w/c/io/fgetc)"
- name: fgetpos
  summary: Obtains the file position indicator and the current parse state (if any) for the file stream stream and stores them in the object pointed to by pos
  description: "# fgetpos\n\n[TABLE]\n\nObtains the file position indicator and the current parse state (if any) for the file stream `stream` and stores them in the object pointed to by `pos`. The value stored is only meaningful as the input to [`fsetpos`](fsetpos \"c/io/fsetpos\").\n\n### Parameters\n\n|        |     |                                                                                              |\n|--------|-----|----------------------------------------------------------------------------------------------|\n| stream | \\-  | file stream to examine                                                                       |\n| pos    | \\-  | pointer to a [`fpos_t`](fpos_t \"c/io/fpos t\") object to store the file position indicator to |\n\n### Return value\n\n`​0​` upon success, nonzero value otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n \nint main(void)\n{\n    // prepare a file holding 4 values of type double\n    enum {SIZE = 4};\n    FILE* fp = fopen(\"test.bin\", \"wb\");\n    assert(fp);\n    int rc = fwrite((double[SIZE]){1.1, 2.2, 3.3, 4.4}, sizeof(double), SIZE, fp);\n    assert(rc == SIZE);\n    fclose(fp);\n \n    // demo using fsetpos to return to the beginning of a file\n    fp = fopen(\"test.bin\", \"rb\");\n    fpos_t pos;\n    fgetpos(fp, &pos);               // store start of file in pos\n    double d;\n    rc = fread(&d, sizeof d, 1, fp); // read the first double\n    assert(rc == 1);\n    printf(\"First value in the file: %.1f\\n\", d);\n    fsetpos(fp,&pos);                 // move file position back to the start of the file\n    rc = fread(&d, sizeof d, 1, fp);  // read the first double again\n    assert(rc == 1);\n    printf(\"First value in the file again: %.1f\\n\", d);\n    fclose(fp);\n \n    // demo error handling\n    rc = fsetpos(stdin, &pos);\n    if(rc) perror(\"could not fsetpos stdin\");\n}\n```\n\nOutput:\n\n```\nFirst value in the file: 1.1\nFirst value in the file again: 1.1\ncould not fsetpos stdin: Illegal seek\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.9.1 The fgetpos function (p: 336)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.9.1 The fgetpos function (p: 302)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.9.1 The fgetpos function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fgetpos](https://en.cppreference.com/w/c/io/fgetpos)"
- name: fgets
  summary: Reads at most count - 1 characters from the given file stream and stores them in the character array pointed to by str
  description: "# fgets\n\n[TABLE]\n\nReads at most `count - 1` characters from the given file stream and stores them in the character array pointed to by `str`. Parsing stops if a newline character is found, in which case `str` will contain that newline character, or if end-of-file occurs. If bytes are read and no errors occur, writes a null character at the position immediately after the last character written to `str`.\n\n### Parameters\n\n|        |     |                                                                       |\n|--------|-----|-----------------------------------------------------------------------|\n| str    | \\-  | pointer to an element of a char array                                 |\n| count  | \\-  | maximum number of characters to write (typically the length of `str`) |\n| stream | \\-  | file stream to read the data from                                     |\n\n### Return value\n\n`str` on success, null pointer on failure.\n\nIf the end-of-file condition is encountered, sets the *eof* indicator on `stream` (see [`feof()`](feof \"c/io/feof\")). This is only a failure if it causes no bytes to be read, in which case a null pointer is returned and the contents of the array pointed to by `str` are not altered (i.e. the first byte is not overwritten with a null character).\n\nIf the failure has been caused by some other error, sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`. The contents of the array pointed to by `str` are indeterminate (it may not even be null-terminated).\n\n### Notes\n\n[POSIX additionally requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html) that `fgets` sets [`errno`](../error/errno \"c/error/errno\") if a read error occurs.\n\nAlthough the standard specification is [unclear](https://stackoverflow.com/questions/23388620) in the cases where `count<=1`, common implementations do\n\n- if `count < 1`, do nothing, report error\n- if `count == 1`,\n  - some implementations do nothing, report error,\n  - others read nothing, store zero in `str[0]`, report success\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE* tmpf = tmpfile();\n    fputs(\"Alan Turing\\n\", tmpf);\n    fputs(\"John von Neumann\\n\", tmpf);\n    fputs(\"Alonzo Church\\n\", tmpf);\n \n    rewind(tmpf);\n \n    char buf[8];\n    while (fgets(buf, sizeof buf, tmpf) != NULL)\n          printf(\"\\\"%s\\\"\\n\", buf);\n \n    if (feof(tmpf))\n       puts(\"End of file reached\");\n}\n```\n\nOutput:\n\n```\n\"Alan Tu\"\n\"ring\n\"\n\"John vo\"\n\"n Neuma\"\n\"nn\n\"\n\"Alonzo \"\n\"Church\n\"\nEnd of file reached\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.7.2 The fgets function (p: 241)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.7.2 The fgets function (p: 331)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.2 The fgets function (p: 296)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.2 The fgets function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fgets](https://en.cppreference.com/w/c/io/fgets)"
- name: fgetwc
  summary: Reads the next wide character from the given input stream
  description: "# fgetwc, getwc\n\n[TABLE]\n\nReads the next wide character from the given input stream. `getwc()` may be implemented as a macro and may evaluate `stream` more than once.\n\n### Parameters\n\n|        |     |                                 |\n|--------|-----|---------------------------------|\n| stream | \\-  | to read the wide character from |\n\n### Return value\n\nThe next wide character from the stream or `WEOF` on failure.\n\nIf the failure has been caused by end-of-file condition, additionally sets the *eof* indicator (see [`feof()`](feof \"c/io/feof\")) on `stream`. If the failure has been caused by some other error, sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`.\n\nIf an encoding error occurred, additionally sets [`errno`](../error/errno \"c/error/errno\") to `EILSEQ`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n#include <errno.h>\n#include <locale.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    FILE *fp = fopen(\"fgetwc.dat\", \"w\");\n    if(!fp) {\n        perror(\"Can't open file for writing\");\n        return EXIT_FAILURE;\n    }\n    fputs(\"кошка\\n\", fp);\n    fclose(fp);\n \n    fp = fopen(\"fgetwc.dat\", \"r\");\n    if(!fp) {\n        perror(\"Can't open file for reading\");\n        return EXIT_FAILURE;\n    }\n    wint_t wc;\n    errno = 0;\n    while ((wc = fgetwc(fp)) != WEOF)\n        putwchar(wc);\n \n    if (ferror(fp)) {\n        if (errno == EILSEQ)\n            puts(\"Character encoding error while reading.\");\n        else\n            puts(\"I/O error when reading\");\n    } else if (feof(fp))\n        puts(\"End of file reached successfully\");\n \n    fclose(fp);\n}\n```\n\nOutput:\n\n```\nкошка\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.3.1 The fgetwc function (p: 307-308)\n  - 7.29.3.6 The getwc function (p: 309)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.3.1 The fgetwc function (p: 421-422)\n  - 7.29.3.6 The getwc function (p: 424)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.3.1 The fgetwc function (p: 367)\n  - 7.24.3.6 The getwc function (p: 369)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fgetwc](https://en.cppreference.com/w/c/io/fgetwc)"
- name: fgetws
  summary: Reads at most count - 1 wide characters from the given file stream and stores them in str
  description: "# fgetws\n\n[TABLE]\n\nReads at most `count - 1` wide characters from the given file stream and stores them in `str`. The produced wide string is always null-terminated. Parsing stops if end-of-file occurs or a newline wide character is found, in which case `str` will contain that wide newline character.\n\n### Parameters\n\n|        |     |                                       |\n|--------|-----|---------------------------------------|\n| str    | \\-  | wide string to read the characters to |\n| count  | \\-  | the length of `str`                   |\n| stream | \\-  | file stream to read the data from     |\n\n### Return value\n\n`str` on success, a null pointer on an error\n\n### Example\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.29.3.2 The fgetws function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.3.2 The fgetws function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.3.2 The fgetws function (p: 422)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.3.2 The fgetws function (p: 367-368)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fgetws](https://en.cppreference.com/w/c/io/fgetws)"
- name: FILE
  summary: Each FILE object denotes a C stream
  description: "# FILE\n\n[TABLE]\n\nEach `FILE` object denotes a C stream.\n\nC standard does not specify whether `FILE` is a complete object type. While it may be possible to copy a valid `FILE`, using a pointer to such a copy as an argument for an I/O function invokes unspecified behavior. In other words, `FILE` may be semantically non-copyable.\n\nI/O streams can be used for both unformatted and formatted input and output. Furthermore, the functions that handle input and output can also be locale-sensitive, such that wide/multibyte conversions are performed as necessary.\n\n### Stream state\n\nBesides the system-specific information necessary to access the device (*e.g.,* a POSIX file descriptor), each `FILE` object directly or indirectly holds the following:\n\n1.  (C95) Character width: unset, narrow, or wide.\n2.  (C95) Parse state for conversions between multibyte and wide characters (an object of type [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\"))\n3.  Buffering state: unbuffered, line-buffered, fully buffered.\n4.  The buffer, which may be replaced by an external, user-provided buffer.\n5.  I/O mode: input, output, or update (both input and output).\n6.  Binary/text mode indicator.\n7.  End-of-file status indicator.\n8.  Error status indicator.\n9.  File position indicator, accessible as an object of type [`fpos_t`](fpos_t \"c/io/fpos t\"), which, for wide streams, includes parse state.\n10. (C11) Reentrant lock used to prevent data races when multiple threads read, write, position, or query the position of a stream.\n\n#### Narrow and wide orientation\n\nA newly opened stream has no orientation. The first call to `fwide` or to any I/O function establishes the orientation: a wide I/O function makes the stream wide-oriented; a narrow I/O function makes the stream narrow-oriented. Once set, the orientation can be changed with only [`freopen`](freopen \"c/io/freopen\"). Narrow I/O functions cannot be called on a wide-oriented stream; wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") or [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with the conversion state as described by the stream. Unlike the multibyte character strings that are valid in a program, multibyte character sequences in the file may contain embedded nulls and do not have to begin or end in the initial shift state.\n\nThe conversion state of a stream with wide orientation is established by the C locale that is installed at the time the stream's orientation is set.\n\n#### Binary and text modes\n\nA *text stream* is an ordered sequence of characters that can be composed into lines; a line can be decomposed into zero or more characters plus a terminating `'\\n'` (“newline”) character. Whether the last line requires a terminating `'\\n'` is implementation-defined. Furthermore, characters may have to be added, altered, or deleted on input and output to conform to the conventions for representing text in the OS (in particular, C streams on Windows OS convert `'\\n'` to `'\\r\\n'` on output, and convert `'\\r\\n'` to `'\\n'` on input).\n\nData read in from a text stream is guaranteed to compare equal to the data that were earlier written out to that stream only if each of the following is true:\n\n- The data consist of only printing characters and/or the control characters `'\\t'` and `'\\n'` (in particular, on Windows OS, the character `'\\0x1A'` terminates input).\n- No `'\\n'` character is immediately preceded by space characters (such space characters may disappear when such output is later read as input).\n- The last character is `'\\n'`.\n\nA *binary stream* is an ordered sequence of characters that can transparently record internal data. Data read in from a binary stream always equal the data that were earlier written out to that stream, except that an implementation is allowed to append an indeterminate number of null characters to the end of the stream. A wide binary stream doesn't need to end in the initial shift state.\n\n### Notes\n\nPOSIX explicitly requires that the `LC_CTYPE` facet of the currently installed C locale be stored within the `FILE` object the moment the stream's orientation becomes wide; POSIX requires that this `LC_CTYPE` facet be used for all future I/O on this stream until the orientation is changed, regardless of any subsequent call to [`setlocale`](../locale/setlocale \"c/locale/setlocale\").\n\nIt is intended that each line of text be composed of data that are essentially human-readable. POSIX implementations do not distinguish between text and binary streams (there is no special mapping for `'\\n'` or any other characters).\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21 Input/output \\<stdio.h\\> (p: 217-247)\n  - 7.29 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 295-325)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21 Input/output \\<stdio.h\\> (p: 296-339)\n  - 7.29 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 402-446)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19 Input/output \\<stdio.h\\> (p: 262-305)\n  - 7.24 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 348-392)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9 INPUT/OUTPUT \\<stdio.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/FILE](https://en.cppreference.com/w/c/io/FILE)"
- name: File input/output
  summary: The <stdio.h> header provides generic file operation support and supplies functions with narrow character input/output capabilities
  description: "# File input/output\n\nThe `<stdio.h>` header provides generic file operation support and supplies functions with narrow character input/output capabilities.\n\nThe [`<wchar.h>`](string/wide \"c/string/wide\") header supplies functions with wide character input/output capabilities.\n\nI/O streams are denoted by objects of type [`FILE`](io/file \"c/io/FILE\") that can only be accessed and manipulated through pointers of type [`FILE`](http://en.cppreference.com/w/c/io/FILE)`*`. Each stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).\n\n### Types\n\n[TABLE]\n\n### Predefined standard streams\n\n[TABLE]\n\n### Functions\n\n[TABLE]\n\n### Macro constants\n\n[TABLE]\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21 Input/output \\<stdio.h\\> (p: TBD)\n  - 7.29 Extended multibyte and wide character utilities \\<wchar.h\\> (p: TBD)\n  - 7.31.11 Input/output \\<stdio.h\\> (p: TBD)\n  - 7.31.16 Extended multibyte and wide character utilities \\<wchar.h\\> (p: TBD)\n  - K.3.5 Input/output \\<stdio.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21 Input/output \\<stdio.h\\> (p: TBD)\n  - 7.29 Extended multibyte and wide character utilities \\<wchar.h\\> (p: TBD)\n  - 7.31.11 Input/output \\<stdio.h\\> (p: TBD)\n  - 7.31.16 Extended multibyte and wide character utilities \\<wchar.h\\> (p: TBD)\n  - K.3.5 Input/output \\<stdio.h\\> (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21 Input/output \\<stdio.h\\> (p: 296-339)\n  - 7.29 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 402-446)\n  - 7.31.11 Input/output \\<stdio.h\\> (p: 456)\n  - 7.31.16 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 456)\n  - K.3.5 Input/output \\<stdio.h\\> (p: 586-603)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19 Input/output \\<stdio.h\\> (p: 262-305)\n  - 7.24 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 348-392)\n  - 7.26.9 Input/output \\<stdio.h\\> (p: 402)\n  - 7.26.12 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 402)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9 INPUT/OUTPUT \\<stdio.h\\>\n  - 4.13.6 Input/output \\<stdio.h\\>\n\n### See also\n\n|                                                                                                      |     |\n|------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/io/c \"cpp/io/c\") for C-style file input/output |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io](https://en.cppreference.com/w/c/io)"
- name: File scope
  summary: If the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has file scope, which terminates at the end of the translation unit
  description: "# File scope\n\nIf the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has file scope, which terminates at the end of the translation unit.\n\nSo, placement of an identifier's declaration (in a declarator or type specifier) outside any block or list of parameters means that the identifier has file scope. File scope of an identifier extends from the declaration to the end of the translation unit in which the declaration appears.\n\n### Example\n\nIdentifiers a, b, f, and g have file scope.\n\n```\n#include <stdio.h>\n \nint a = 1;\nstatic int b = 2;\n \nvoid f (void) {printf(\"from function f()\\n\");}\nstatic void g (void) {printf(\"from function g()\\n\");}\n \nint main(void)\n{\n    f();\n    g();\n \n    return 0;\n}\n/* end of this translation unit, end of file scope */\n```\n\nPossible output:\n\n```\nfrom function f()\nfrom function g()\n```\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/file_scope](https://en.cppreference.com/w/c/language/file_scope)"
- name: Fixed width integer types
  summary: The implementation may define typedef names intN_t, int_fastN_t, int_leastN_t, uintN_t, uint_fastN_t, and uint_leastN_t when N is not 8, 16, 32 or 64
  description: "# Fixed width integer types (since C99)\n\n### Types\n\n[TABLE]\n\nThe implementation may define typedef names `int`*`N`*`_t`, `int_fast`*`N`*`_t`, `int_least`*`N`*`_t`, `uint`*`N`*`_t`, `uint_fast`*`N`*`_t`, and `uint_least`*`N`*`_t` when *N* is not 8, 16, 32 or 64. Typedef names of the form `int`*`N`*`_t` may only be defined if the implementation supports an integer type of that width with no padding. Thus, uint24_t denotes an unsigned integer type with a width of exactly 24 bits.\n\nEach of the macros listed in below is defined if and only if the implementation defines the corresponding typedef name. The macros `INT`*`N`*`_C` and `UINT`*`N`*`_C` correspond to the typedef names `int_least`*`N`*`_t` and `uint_least`*`N`*`_t`, respectively.\n\n### Macro constants\n\n[TABLE]\n\n### Function macros for minimum-width integer constants\n\n[TABLE]\n\n```\n#include <stdint.h>\nUINT64_C(0x123) // might expand to 0x123ULL or 0x123UL\n```\n\n### Format macro constants\n\n| Defined in header `<inttypes.h>` |     |\n|----------------------------------|-----|\n\n#### Format constants for the [`fprintf`](../io/fprintf \"c/io/fprintf\") family of functions\n\nEach of the `PRI` macros listed here is defined if and only if the implementation defines the corresponding typedef name.\n\n[TABLE]\n\n#### Format constants for the [`fscanf`](../io/fscanf \"c/io/fscanf\") family of functions\n\nEach of the `SCN` macros listed in here is defined if and only if the implementation defines the corresponding typedef name and has a suitable [`fscanf`](../io/fscanf \"c/io/fscanf\") length modifier for the type.\n\n[TABLE]\n\n### Example\n\nSee also [C++ compatibility note](https://en.cppreference.com/w/cpp/language/user_literal#Notes \"cpp/language/user literal\") regarding spaces before [format macros](#Format_macro_constants) used in this example.\n\n```\n#include <inttypes.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"%zu\\n\", sizeof(int64_t));\n    printf(\"%s\\n\", PRId64);\n    printf(\"%+\" PRId64 \"\\n\", INT64_MIN);\n    printf(\"%+\" PRId64 \"\\n\", INT64_MAX);\n \n    int64_t n = 7;\n    printf(\"%+\" PRId64 \"\\n\", n);\n}\n```\n\nPossible output:\n\n```\n8\nlld\n-9223372036854775808\n+9223372036854775807\n+7\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.8.1 Macros for format specifiers (p: TBD)\n  - 7.18 Integer types \\<stdint.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.1 Macros for format specifiers (p: 158-159)\n  - 7.18 Integer types \\<stdint.h\\> (p: 212-216)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.1 Macros for format specifiers (p: 217-218)\n  - 7.18 Integer types \\<stdint.h\\> (p: 289-295)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.1 Macros for format specifiers (p: 198-199)\n  - 7.18 Integer types \\<stdint.h\\> (p: 255-261)\n\n### See also\n\n- [Arithmetic types](../language/arithmetic_types \"c/language/arithmetic types\")\n\n|                                                                                                                                                                                                                                                          |     |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/types/integer \"cpp/types/integer\") for Fixed width integer types                                                                                                                                   |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/user_literal \"cpp/language/user literal\") for User-defined literals ([formatting macros note](https://en.cppreference.com/w/cpp/language/user_literal#Notes \"cpp/language/user literal\")) |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types/integer](https://en.cppreference.com/w/c/types/integer)"
- name: float
  summary: ''
  description: "# C keywords: float\n\n### Usage\n\n- [`float` type](../language/types \"c/language/types\"): as the declaration of the type\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/float](https://en.cppreference.com/w/c/keyword/float)"
- name: float_t
  summary: The types float_t and double_t are floating types at least as wide as float and double, respectively, and such that double_t is at least as wide as float_t
  description: "# float_t, double_t\n\n[TABLE]\n\nThe types `float_t` and `double_t` are floating types at least as wide as `float` and `double`, respectively, and such that `double_t` is at least as wide as `float_t`. The value of [`FLT_EVAL_METHOD`](../../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\") determines the types of `float_t` and `double_t`.\n\n| FLT_EVAL_METHOD | Explanation                                                                   |\n|-----------------|-------------------------------------------------------------------------------|\n| `0`             | `float_t` and `double_t` are equivalent to `float` and `double`, respectively |\n| `1`             | both `float_t` and `double_t` are equivalent to `double`                      |\n| `2`             | both `float_t` and `double_t` are equivalent to `long double`                 |\n| `other`         | both `float_t` and `double_t` are implementation defined                      |\n\n### Example\n\n```\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"%d\\n\", FLT_EVAL_METHOD);\n    printf(\"%zu  %zu\\n\", sizeof(float),sizeof(float_t));\n    printf(\"%zu  %zu\\n\", sizeof(double),sizeof(double_t));\n    return 0;\n}\n```\n\nPossible output:\n\n```\n0\n4  4\n8  8\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12 Mathematics \\<math.h\\> (p: 231)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12 Mathematics \\<math.h\\> (p: 212)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/float_t](https://en.cppreference.com/w/c/numeric/math/float_t)"
- name: Floating constant
  summary: Allows values of floating type to be used directly in expressions
  description: "# Floating constant\n\nAllows values of floating type to be used directly in expressions.\n\n### Syntax\n\nA floating constant is a [non-lvalue](value_category \"c/language/value category\") expression having the form:\n\n|                                                   |     |     |\n|---------------------------------------------------|-----|-----|\n| significand exponent \uFEFF(optional) suffix \uFEFF(optional) |     |     |\n\nWhere the significand has the form\n\n|                                                           |     |     |\n|-----------------------------------------------------------|-----|-----|\n| whole-number \uFEFF(optional) `.`(optional) fraction \uFEFF(optional) |     |     |\n\nThe exponent has the form\n\n|                                                    |       |             |\n|----------------------------------------------------|-------|-------------|\n| `e` \\| `E` exponent-sign \uFEFF(optional) digit-sequence | \\(1\\) |             |\n| `p` \\| `P` exponent-sign \uFEFF(optional) digit-sequence | \\(2\\) | (since C99) |\n\n1) The exponent syntax for a decimal floating-point constant\n\n2) The exponent syntax for hexadecimal floating-point constant\n\n|                                                                                                                  |             |\n|------------------------------------------------------------------------------------------------------------------|-------------|\n| Optional single quotes (`'`) can be inserted between the digits as a separator, they are ignored when compiling. | (since C23) |\n\n### Explanation\n\n[TABLE]\n\nFor a *decimal floating constant*, the significand is interpreted as a decimal rational number, and the digit-sequence of the exponent is interpreted as the integer power of 10 to which the significand has to be scaled.\n\n```\ndouble d = 1.2e3; // decimal fraction 1.2 scaled by 10^3, that is 1200.0\n```\n\n#### Suffixes\n\nAn unsuffixed floating constant has type `double`. If suffix is the letter `f` or `F`, the floating constant has type `float`. If suffix is the letter `l` or `L`, the floating constant has type `long double`.\n\n[TABLE]\n\n#### Optional parts\n\nIf the exponent is present and fractional part is not used, the decimal separator may be omitted:\n\n```\ndouble x = 1e0; // floating-point 1.0 (period not used)\n```\n\nFor decimal floating constants, the exponent part is optional. If it is omitted, the period is not optional, and either the whole-number or the fraction must be present.\n\n```\ndouble x = 1.; // floating-point 1.0 (fractional part optional)\ndouble y = .1; // floating-point 0.1 (whole-number part optional)\n```\n\n|                                                                                                                                                         |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| For hexadecimal floating constants, the exponent is not optional to avoid ambiguity resulting from an `f` suffix being mistaken as a hexadecimal digit. | (since C99) |\n\n#### Representable values\n\nThe result of evaluating a floating constant is either the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value, chosen in an implementation-defined manner (in other words, [default rounding direction](../numeric/fenv/fe_round \"c/numeric/fenv/FE round\") during translation is implementation-defined).\n\nAll floating constants of the same source form convert to the same internal format with the same value. Floating constants of different source forms, e.g. `1.23` and `1.230`, need not to convert to the same internal format and value.\n\n[TABLE]\n\n[TABLE]\n\n### Notes\n\nDefault [rounding direction](../numeric/fenv/fe_round \"c/numeric/fenv/FE round\") and [precision](../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\") are in effect when the floating constants are converted into internal representations, and [floating-point exceptions](../numeric/fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are not raised even if [` #pragma STDC FENV_ACCESS`](../preprocessor/impl \"c/preprocessor/impl\") is in effect (for execution-time conversion of character strings, [`strtod`](../string/byte/strtof \"c/string/byte/strtof\") can be used). Note that this differs from [arithmetic constant expressions](constant_expression \"c/language/constant expression\") of floating type.\n\nLetters in the floating constants are case-insensitive, except that uppercase and lowercase cannot be both used in suffixes for decimal floating-point types(since C23): `0x1.ep+3` and `0X1.EP+3` represent the same floating-point value `15.0`.\n\nThe decimal point specified by [`setlocale`](../locale/setlocale \"c/locale/setlocale\") has no effect on the syntax of floating constants: the decimal point character is always the period.\n\nUnlike integers, not every floating value can be represented directly by decimal or even hexadecimal(since C99) constant syntax: macros [`NAN`](../numeric/math/nan \"c/numeric/math/NAN\") and [`INFINITY`](../numeric/math/infinity \"c/numeric/math/INFINITY\") as well as functions such as [`nan`](../numeric/math/nan \"c/numeric/math/nan\") offer ways to generate those special values(since C99). Note that `0x1.FFFFFEp128f`, which might appear to be an IEEE float NaN, in fact overflows to an infinity in that format.\n\nThere are no negative floating constants; an expression such as `-1.2` is the [arithmetic operator](operator_arithmetic \"c/language/operator arithmetic\") unary minus applied to the floating constant `1.2`. Note that the special value negative zero may be constructed with `-0.0`.\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"15.0     = %a\\n\", 15.0);\n    printf(\"0x1.ep+3 = %f\\n\", 0x1.ep+3);\n \n    // Constants outside the range of type double.\n    printf(\"+2.0e+308 --> %g\\n\",  2.0e+308);\n    printf(\"+1.0e-324 --> %g\\n\",  1.0e-324);\n    printf(\"-1.0e-324 --> %g\\n\", -1.0e-324);\n    printf(\"-2.0e+308 --> %g\\n\", -2.0e+308);\n}\n```\n\nOutput:\n\n```\n15.0     = 0x1.ep+3\n0x1.ep+3 = 15.000000\n+2.0e+308 --> inf\n+1.0e-324 --> 0\n-1.0e-324 --> -0\n-2.0e+308 --> -inf\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.4.4.2 Floating constants (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.4.4.2 Floating constants (p: 47-48)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.4.4.2 Floating constants (p: 65-66)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.4.4.2 Floating constants (p: 57-58)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.3.1 Floating constants\n\n### See also\n\n|                                                                                                                                             |     |\n|---------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/floating_literal \"cpp/language/floating literal\") for Floating-point literal |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/floating_constant](https://en.cppreference.com/w/c/language/floating_constant)"
- name: Floating-point environment
  summary: The floating-point environment is the set of floating-point status flags and control modes supported by the implementation
  description: "# Floating-point environment\n\nThe floating-point environment is the set of floating-point status flags and control modes supported by the implementation. It is thread-local, each thread inherits the initial state of its floating-point environment from the parent thread. Floating-point operations modify the floating-point status flags to indicate abnormal results or auxiliary information. The state of floating-point control modes affects the outcomes of some floating-point operations.\n\nThe floating-point environment access and modification is only meaningful when [` #pragma STDC FENV_ACCESS`](https://en.cppreference.com/w/cpp/preprocessor/impl \"cpp/preprocessor/impl\") is set to `ON`. Otherwise the implementation is free to assume that floating-point control modes are always the default ones and that floating-point status flags are never tested or modified. In practice, few current compilers, such as HP aCC, Oracle Studio, and IBM XL, support the \\#pragma explicitly, but most compilers allow meaningful access to the floating-point environment anyway.\n\n### Types\n\n| Defined in header `<fenv.h>` |                                                                    |\n|------------------------------|--------------------------------------------------------------------|\n| `fenv_t`                     | The type representing the entire floating-point environment        |\n| `fexcept_t`                  | The type representing all floating-point status flags collectively |\n\n### Functions\n\n[TABLE]\n\n### Macros\n\n[TABLE]\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.6 Floating-point environment \\<fenv.h\\> (p: TBD)\n  - 7.31.4 Floating-point environment \\<fenv.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.6 Floating-point environment \\<fenv.h\\> (p: 150-156)\n  - 7.31.4 Floating-point environment \\<fenv.h\\> (p: 332)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.6 Floating-point environment \\<fenv.h\\> (p: 206-215)\n  - 7.31.4 Floating-point environment \\<fenv.h\\> (p: 455)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.6 Floating-point environment \\<fenv.h\\> (p: 187-196)\n\n### See also\n\n|                                                                                                                         |     |\n|-------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/fenv \"cpp/numeric/fenv\") for `Floating-point environment` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/fenv](https://en.cppreference.com/w/c/numeric/fenv)"
- name: floor
  summary: If no errors occur, the largest integer value not greater than arg, that is ⌊arg⌋, is returned
  description: "# floor, floorf, floorl\n\n[TABLE]\n\n1-3) Computes the largest integer value not greater than `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `floorl` is called. Otherwise, if `arg` has integer type or the type `double`, `floor` is called. Otherwise, `floorf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the largest integer value not greater than `arg`, that is ⌊arg⌋, is returned.\n\nReturn value\n\nArgument\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If arg is NaN, NaN is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"floor(+2.7) = %+.1f\\n\", floor(2.7));\n    printf(\"floor(-2.7) = %+.1f\\n\", floor(-2.7));\n    printf(\"floor(-0.0) = %+.1f\\n\", floor(-0.0));\n    printf(\"floor(-Inf) = %+f\\n\",   floor(-INFINITY));\n}\n```\n\nPossible output:\n\n```\nfloor(+2.7) = +2.0\nfloor(-2.7) = -3.0\nfloor(-0.0) = -0.0\nfloor(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.2 The floor functions (p: 251)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.2 The floor functions (p: 526)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.2 The floor functions (p: 232)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.2 The floor functions (p: 463)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.3 The floor function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/floor](https://en.cppreference.com/w/c/numeric/math/floor)"
- name: floorf
  summary: If no errors occur, the largest integer value not greater than arg, that is ⌊arg⌋, is returned
  description: "# floor, floorf, floorl\n\n[TABLE]\n\n1-3) Computes the largest integer value not greater than `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `floorl` is called. Otherwise, if `arg` has integer type or the type `double`, `floor` is called. Otherwise, `floorf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the largest integer value not greater than `arg`, that is ⌊arg⌋, is returned.\n\nReturn value\n\nArgument\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If arg is NaN, NaN is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"floor(+2.7) = %+.1f\\n\", floor(2.7));\n    printf(\"floor(-2.7) = %+.1f\\n\", floor(-2.7));\n    printf(\"floor(-0.0) = %+.1f\\n\", floor(-0.0));\n    printf(\"floor(-Inf) = %+f\\n\",   floor(-INFINITY));\n}\n```\n\nPossible output:\n\n```\nfloor(+2.7) = +2.0\nfloor(-2.7) = -3.0\nfloor(-0.0) = -0.0\nfloor(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.2 The floor functions (p: 251)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.2 The floor functions (p: 526)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.2 The floor functions (p: 232)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.2 The floor functions (p: 463)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.3 The floor function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/floor](https://en.cppreference.com/w/c/numeric/math/floor)"
- name: floorl
  summary: If no errors occur, the largest integer value not greater than arg, that is ⌊arg⌋, is returned
  description: "# floor, floorf, floorl\n\n[TABLE]\n\n1-3) Computes the largest integer value not greater than `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `floorl` is called. Otherwise, if `arg` has integer type or the type `double`, `floor` is called. Otherwise, `floorf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the largest integer value not greater than `arg`, that is ⌊arg⌋, is returned.\n\nReturn value\n\nArgument\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If arg is NaN, NaN is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"floor(+2.7) = %+.1f\\n\", floor(2.7));\n    printf(\"floor(-2.7) = %+.1f\\n\", floor(-2.7));\n    printf(\"floor(-0.0) = %+.1f\\n\", floor(-0.0));\n    printf(\"floor(-Inf) = %+f\\n\",   floor(-INFINITY));\n}\n```\n\nPossible output:\n\n```\nfloor(+2.7) = +2.0\nfloor(-2.7) = -3.0\nfloor(-0.0) = -0.0\nfloor(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.2 The floor functions (p: 251)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.2 The floor functions (p: 526)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.2 The floor functions (p: 232)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.2 The floor functions (p: 463)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.3 The floor function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/floor](https://en.cppreference.com/w/c/numeric/math/floor)"
- name: FLT_EVAL_METHOD
  summary: Specifies range and precision of floating-point values obtained from floating-point constants and from all operations (operators, implicit conversions of operands) except assignment, cast, and library function call
  description: "# FLT_EVAL_METHOD\n\n[TABLE]\n\nSpecifies range and precision of floating-point values obtained from floating-point constants and from all operations (operators, implicit conversions of operands) except assignment, cast, and library function call.\n\n| Value                       | Explanation                                                                                                                                                                   |\n|-----------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| negative values except `-1` | implementation-defined behavior                                                                                                                                               |\n| `-1`                        | the default precision is not known                                                                                                                                            |\n| `0`                         | all operations and constants evaluate in the range and precision of the type used. Additionally, `float_t` and `double_t` are equivalent to `float` and `double` respectively |\n| `1`                         | all operations and constants evaluate in the range and precision of `double`. Additionally, both `float_t` and `double_t` are equivalent to `double`                          |\n| `2`                         | all operations and constants evaluate in the range and precision of `long double`. Additionally, both `float_t` and `double_t` are equivalent to `long double`                |\n\n### Notes\n\nRegardless of the value of `FLT_EVAL_METHOD`, any floating-point expression may be *contracted*, that is, calculated as if all intermediate results have infinite range and precision (unless [\\#pragma](../../preprocessor/impl \"c/preprocessor/impl\") `STDC FP_CONTRACT` is off)\n\nCast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location.\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD](https://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD)"
- name: FLT_ROUNDS
  summary: Returns the current rounding direction of floating-point arithmetic operations
  description: "# FLT_ROUNDS\n\n[TABLE]\n\nReturns the current rounding direction of floating-point arithmetic operations.\n\n| Value        | Explanation                                                                                                       |\n|--------------|-------------------------------------------------------------------------------------------------------------------|\n| `-1`         | the default rounding direction is not known                                                                       |\n| `0`          | toward zero; same meaning as [`FE_TOWARDZERO`](../../numeric/fenv/fe_round \"c/numeric/fenv/FE round\")             |\n| `1`          | to nearest; same meaning as [`FE_TONEAREST`](../../numeric/fenv/fe_round \"c/numeric/fenv/FE round\")               |\n| `2`          | towards positive infinity; same meaning as [`FE_UPWARD`](../../numeric/fenv/fe_round \"c/numeric/fenv/FE round\")   |\n| `3`          | towards negative infinity; same meaning as [`FE_DOWNWARD`](../../numeric/fenv/fe_round \"c/numeric/fenv/FE round\") |\n| other values | implementation-defined behavior                                                                                   |\n\n### Notes\n\nThe rounding mode can be changed with [`fesetround`](../../numeric/fenv/feround \"c/numeric/fenv/feround\") and `FLT_ROUNDS` reflects that change.\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types/limits/FLT_ROUNDS](https://en.cppreference.com/w/c/types/limits/FLT_ROUNDS)"
- name: fma
  summary: If successful, returns the value of (x*y) + z as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation)
  description: "# fma, fmaf, fmal\n\n[TABLE]\n\n1-3) Computes `(x*y) + z` as if to infinite precision and rounded only once to fit the result type.\n\n4-6) If the macro constants `FP_FAST_FMA`, `FP_FAST_FMAF`, or `FP_FAST_FMAL` are defined, the corresponding function `fmaf`, `fma`, or `fmal` evaluates faster (in addition to being more precise) than the expression `x*y+z` for `float`, `double`, and `long double` arguments, respectively. If defined, these macros evaluate to integer `1`.\n\n7) Type-generic macro: If any argument has type `long double`, `fmal` is called. Otherwise, if any argument has integer type or has type `double`, `fma` is called. Otherwise, `fmaf` is called.\n\n### Parameters\n\n|         |     |                       |\n|---------|-----|-----------------------|\n| x, y, z | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the value of `(x*y) + z` as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct value (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `x*y` is an exact infinity and z is an infinity with the opposite sign, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If x or y are NaN, NaN is returned\n- If z is NaN, and `x*y` aren't 0\\*Inf or Inf\\*0, then NaN is returned (without [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")).\n\n### Notes\n\nThis operation is commonly implemented in hardware as [fused multiply-add](https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation \"enwiki:Multiply–accumulate operation\") CPU instruction. If supported by hardware, the appropriate `FP_FAST_FMA*` macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fma.html) that the situation where the value `x*y` is invalid and z is a NaN is a domain error.\n\nDue to its infinite intermediate precision, `fma` is a common building block of other correctly-rounded mathematical operations, such as [`sqrt`](sqrt \"c/numeric/math/sqrt\") or even the division (where not provided by the CPU, e.g. Itanium).\n\nAs with all floating-point expressions, the expression `(x*y) + z` may be compiled as a fused mutiply-add unless the [` #pragma`](../../preprocessor/impl \"c/preprocessor/impl\") `STDC FP_CONTRACT` is off.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    // demo the difference between fma and built-in operators\n    double in = 0.1;\n    printf(\"0.1 double is %.23f (%a)\\n\", in, in);\n    printf(\"0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3),\"\n           \" or 1.0 if rounded to double\\n\");\n    double expr_result = 0.1 * 10 - 1;\n    printf(\"0.1 * 10 - 1 = %g : 1 subtracted after \"\n           \"intermediate rounding to 1.0\\n\", expr_result);\n    double fma_result = fma(0.1, 10, -1);\n    printf(\"fma(0.1, 10, -1) = %g (%a)\\n\", fma_result, fma_result);\n \n    // fma use in double-double arithmetic\n    printf(\"\\nin double-double arithmetic, 0.1 * 10 is representable as \");\n    double high = 0.1 * 10;\n    double low = fma(0.1, 10, -high);\n    printf(\"%g + %g\\n\\n\", high, low);\n \n    //error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"fma(+Inf, 10, -Inf) = %f\\n\", fma(INFINITY, 10, -INFINITY));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\n0.1 double is 0.10000000000000000555112 (0x1.999999999999ap-4)\n0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3), or 1.0 if rounded to double\n0.1 * 10 - 1 = 0 : 1 subtracted after intermediate rounding to 1.0\nfma(0.1, 10, -1) = 5.55112e-17 (0x1p-54)\n \nin double-double arithmetic, 0.1 * 10 is representable as 1 + 5.55112e-17\n \nfma(+Inf, 10, -Inf) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.13.1 The fma functions (p: 188-189)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.10.1 The fma functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.13.1 The fma functions (p: 258)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.10.1 The fma functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.13.1 The fma functions (p: 239)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.10.1 The fma functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fma](https://en.cppreference.com/w/c/numeric/math/fma)"
- name: fmaf
  summary: If successful, returns the value of (x*y) + z as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation)
  description: "# fma, fmaf, fmal\n\n[TABLE]\n\n1-3) Computes `(x*y) + z` as if to infinite precision and rounded only once to fit the result type.\n\n4-6) If the macro constants `FP_FAST_FMA`, `FP_FAST_FMAF`, or `FP_FAST_FMAL` are defined, the corresponding function `fmaf`, `fma`, or `fmal` evaluates faster (in addition to being more precise) than the expression `x*y+z` for `float`, `double`, and `long double` arguments, respectively. If defined, these macros evaluate to integer `1`.\n\n7) Type-generic macro: If any argument has type `long double`, `fmal` is called. Otherwise, if any argument has integer type or has type `double`, `fma` is called. Otherwise, `fmaf` is called.\n\n### Parameters\n\n|         |     |                       |\n|---------|-----|-----------------------|\n| x, y, z | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the value of `(x*y) + z` as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct value (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `x*y` is an exact infinity and z is an infinity with the opposite sign, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If x or y are NaN, NaN is returned\n- If z is NaN, and `x*y` aren't 0\\*Inf or Inf\\*0, then NaN is returned (without [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")).\n\n### Notes\n\nThis operation is commonly implemented in hardware as [fused multiply-add](https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation \"enwiki:Multiply–accumulate operation\") CPU instruction. If supported by hardware, the appropriate `FP_FAST_FMA*` macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fma.html) that the situation where the value `x*y` is invalid and z is a NaN is a domain error.\n\nDue to its infinite intermediate precision, `fma` is a common building block of other correctly-rounded mathematical operations, such as [`sqrt`](sqrt \"c/numeric/math/sqrt\") or even the division (where not provided by the CPU, e.g. Itanium).\n\nAs with all floating-point expressions, the expression `(x*y) + z` may be compiled as a fused mutiply-add unless the [` #pragma`](../../preprocessor/impl \"c/preprocessor/impl\") `STDC FP_CONTRACT` is off.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    // demo the difference between fma and built-in operators\n    double in = 0.1;\n    printf(\"0.1 double is %.23f (%a)\\n\", in, in);\n    printf(\"0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3),\"\n           \" or 1.0 if rounded to double\\n\");\n    double expr_result = 0.1 * 10 - 1;\n    printf(\"0.1 * 10 - 1 = %g : 1 subtracted after \"\n           \"intermediate rounding to 1.0\\n\", expr_result);\n    double fma_result = fma(0.1, 10, -1);\n    printf(\"fma(0.1, 10, -1) = %g (%a)\\n\", fma_result, fma_result);\n \n    // fma use in double-double arithmetic\n    printf(\"\\nin double-double arithmetic, 0.1 * 10 is representable as \");\n    double high = 0.1 * 10;\n    double low = fma(0.1, 10, -high);\n    printf(\"%g + %g\\n\\n\", high, low);\n \n    //error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"fma(+Inf, 10, -Inf) = %f\\n\", fma(INFINITY, 10, -INFINITY));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\n0.1 double is 0.10000000000000000555112 (0x1.999999999999ap-4)\n0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3), or 1.0 if rounded to double\n0.1 * 10 - 1 = 0 : 1 subtracted after intermediate rounding to 1.0\nfma(0.1, 10, -1) = 5.55112e-17 (0x1p-54)\n \nin double-double arithmetic, 0.1 * 10 is representable as 1 + 5.55112e-17\n \nfma(+Inf, 10, -Inf) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.13.1 The fma functions (p: 188-189)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.10.1 The fma functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.13.1 The fma functions (p: 258)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.10.1 The fma functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.13.1 The fma functions (p: 239)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.10.1 The fma functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fma](https://en.cppreference.com/w/c/numeric/math/fma)"
- name: fmal
  summary: If successful, returns the value of (x*y) + z as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation)
  description: "# fma, fmaf, fmal\n\n[TABLE]\n\n1-3) Computes `(x*y) + z` as if to infinite precision and rounded only once to fit the result type.\n\n4-6) If the macro constants `FP_FAST_FMA`, `FP_FAST_FMAF`, or `FP_FAST_FMAL` are defined, the corresponding function `fmaf`, `fma`, or `fmal` evaluates faster (in addition to being more precise) than the expression `x*y+z` for `float`, `double`, and `long double` arguments, respectively. If defined, these macros evaluate to integer `1`.\n\n7) Type-generic macro: If any argument has type `long double`, `fmal` is called. Otherwise, if any argument has integer type or has type `double`, `fma` is called. Otherwise, `fmaf` is called.\n\n### Parameters\n\n|         |     |                       |\n|---------|-----|-----------------------|\n| x, y, z | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the value of `(x*y) + z` as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct value (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be raised\n- If `x*y` is an exact infinity and z is an infinity with the opposite sign, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If x or y are NaN, NaN is returned\n- If z is NaN, and `x*y` aren't 0\\*Inf or Inf\\*0, then NaN is returned (without [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")).\n\n### Notes\n\nThis operation is commonly implemented in hardware as [fused multiply-add](https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation \"enwiki:Multiply–accumulate operation\") CPU instruction. If supported by hardware, the appropriate `FP_FAST_FMA*` macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fma.html) that the situation where the value `x*y` is invalid and z is a NaN is a domain error.\n\nDue to its infinite intermediate precision, `fma` is a common building block of other correctly-rounded mathematical operations, such as [`sqrt`](sqrt \"c/numeric/math/sqrt\") or even the division (where not provided by the CPU, e.g. Itanium).\n\nAs with all floating-point expressions, the expression `(x*y) + z` may be compiled as a fused mutiply-add unless the [` #pragma`](../../preprocessor/impl \"c/preprocessor/impl\") `STDC FP_CONTRACT` is off.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    // demo the difference between fma and built-in operators\n    double in = 0.1;\n    printf(\"0.1 double is %.23f (%a)\\n\", in, in);\n    printf(\"0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3),\"\n           \" or 1.0 if rounded to double\\n\");\n    double expr_result = 0.1 * 10 - 1;\n    printf(\"0.1 * 10 - 1 = %g : 1 subtracted after \"\n           \"intermediate rounding to 1.0\\n\", expr_result);\n    double fma_result = fma(0.1, 10, -1);\n    printf(\"fma(0.1, 10, -1) = %g (%a)\\n\", fma_result, fma_result);\n \n    // fma use in double-double arithmetic\n    printf(\"\\nin double-double arithmetic, 0.1 * 10 is representable as \");\n    double high = 0.1 * 10;\n    double low = fma(0.1, 10, -high);\n    printf(\"%g + %g\\n\\n\", high, low);\n \n    //error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"fma(+Inf, 10, -Inf) = %f\\n\", fma(INFINITY, 10, -INFINITY));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\n0.1 double is 0.10000000000000000555112 (0x1.999999999999ap-4)\n0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3), or 1.0 if rounded to double\n0.1 * 10 - 1 = 0 : 1 subtracted after intermediate rounding to 1.0\nfma(0.1, 10, -1) = 5.55112e-17 (0x1p-54)\n \nin double-double arithmetic, 0.1 * 10 is representable as 1 + 5.55112e-17\n \nfma(+Inf, 10, -Inf) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.13.1 The fma functions (p: 188-189)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.10.1 The fma functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.13.1 The fma functions (p: 258)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.10.1 The fma functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.13.1 The fma functions (p: 239)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.10.1 The fma functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fma](https://en.cppreference.com/w/c/numeric/math/fma)"
- name: fmax
  summary: If successful, returns the larger of two floating point values
  description: "# fmax, fmaxf, fmaxl\n\n[TABLE]\n\n1-3) Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).\n\n4) Type-generic macro: If any argument has type `long double`, `fmaxl` is called. Otherwise, if any argument has integer type or has type `double`, `fmax` is called. Otherwise, `fmaxf` is called.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If one of the two arguments is NaN, the value of the other argument is returned.\n- Only if both arguments are NaN is NaN returned.\n\n### Notes\n\nThis function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"fmax(2,1)    = %f\\n\", fmax(2,1));\n    printf(\"fmax(-Inf,0) = %f\\n\", fmax(-INFINITY,0));\n    printf(\"fmax(NaN,-1) = %f\\n\", fmax(NAN,-1));\n}\n```\n\nOutput:\n\n```\nfmax(2,1)    = 2.000000\nfmax(-Inf,0) = 0.000000\nfmax(NaN,-1) = -1.000000\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.12.2 The fmax functions (p: 188)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 397)\n  - F.10.9.2 The fmax functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.12.2 The fmax functions (p: 257-258)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.9.2 The fmax functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.12.2 The fmax functions (p: 238-239)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.9.2 The fmax functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fmax](https://en.cppreference.com/w/c/numeric/math/fmax)"
- name: fmaxf
  summary: If successful, returns the larger of two floating point values
  description: "# fmax, fmaxf, fmaxl\n\n[TABLE]\n\n1-3) Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).\n\n4) Type-generic macro: If any argument has type `long double`, `fmaxl` is called. Otherwise, if any argument has integer type or has type `double`, `fmax` is called. Otherwise, `fmaxf` is called.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If one of the two arguments is NaN, the value of the other argument is returned.\n- Only if both arguments are NaN is NaN returned.\n\n### Notes\n\nThis function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"fmax(2,1)    = %f\\n\", fmax(2,1));\n    printf(\"fmax(-Inf,0) = %f\\n\", fmax(-INFINITY,0));\n    printf(\"fmax(NaN,-1) = %f\\n\", fmax(NAN,-1));\n}\n```\n\nOutput:\n\n```\nfmax(2,1)    = 2.000000\nfmax(-Inf,0) = 0.000000\nfmax(NaN,-1) = -1.000000\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.12.2 The fmax functions (p: 188)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 397)\n  - F.10.9.2 The fmax functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.12.2 The fmax functions (p: 257-258)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.9.2 The fmax functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.12.2 The fmax functions (p: 238-239)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.9.2 The fmax functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fmax](https://en.cppreference.com/w/c/numeric/math/fmax)"
- name: fmaxl
  summary: If successful, returns the larger of two floating point values
  description: "# fmax, fmaxf, fmaxl\n\n[TABLE]\n\n1-3) Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).\n\n4) Type-generic macro: If any argument has type `long double`, `fmaxl` is called. Otherwise, if any argument has integer type or has type `double`, `fmax` is called. Otherwise, `fmaxf` is called.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If one of the two arguments is NaN, the value of the other argument is returned.\n- Only if both arguments are NaN is NaN returned.\n\n### Notes\n\nThis function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"fmax(2,1)    = %f\\n\", fmax(2,1));\n    printf(\"fmax(-Inf,0) = %f\\n\", fmax(-INFINITY,0));\n    printf(\"fmax(NaN,-1) = %f\\n\", fmax(NAN,-1));\n}\n```\n\nOutput:\n\n```\nfmax(2,1)    = 2.000000\nfmax(-Inf,0) = 0.000000\nfmax(NaN,-1) = -1.000000\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.12.2 The fmax functions (p: 188)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 397)\n  - F.10.9.2 The fmax functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.12.2 The fmax functions (p: 257-258)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.9.2 The fmax functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.12.2 The fmax functions (p: 238-239)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.9.2 The fmax functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fmax](https://en.cppreference.com/w/c/numeric/math/fmax)"
- name: fmin
  summary: If successful, returns the smaller of two floating point values
  description: "# fmin, fminf, fminl\n\n[TABLE]\n\n1-3) Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).\n\n4) Type-generic macro: If any argument has type `long double`, `fminl` is called. Otherwise, if any argument has integer type or has type `double`, `fmin` is called. Otherwise, `fminf` is called.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If one of the two arguments is NaN, the value of the other argument is returned\n- Only if both arguments are NaN, NaN is returned\n\n### Notes\n\nThis function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"fmin(2,1)    = %f\\n\", fmin(2,1));\n    printf(\"fmin(-Inf,0) = %f\\n\", fmin(-INFINITY,0));\n    printf(\"fmin(NaN,-1) = %f\\n\", fmin(NAN,-1));\n}\n```\n\nPossible output:\n\n```\nfmin(2,1)    = 1.000000\nfmin(-Inf,0) = -inf\nfmin(NaN,-1) = -1.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.12.3 The fmin functions (p: 258)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.9.3 The fmin functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.12.3 The fmin functions (p: 239)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.9.3 The fmin functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fmin](https://en.cppreference.com/w/c/numeric/math/fmin)"
- name: fminf
  summary: If successful, returns the smaller of two floating point values
  description: "# fmin, fminf, fminl\n\n[TABLE]\n\n1-3) Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).\n\n4) Type-generic macro: If any argument has type `long double`, `fminl` is called. Otherwise, if any argument has integer type or has type `double`, `fmin` is called. Otherwise, `fminf` is called.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If one of the two arguments is NaN, the value of the other argument is returned\n- Only if both arguments are NaN, NaN is returned\n\n### Notes\n\nThis function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"fmin(2,1)    = %f\\n\", fmin(2,1));\n    printf(\"fmin(-Inf,0) = %f\\n\", fmin(-INFINITY,0));\n    printf(\"fmin(NaN,-1) = %f\\n\", fmin(NAN,-1));\n}\n```\n\nPossible output:\n\n```\nfmin(2,1)    = 1.000000\nfmin(-Inf,0) = -inf\nfmin(NaN,-1) = -1.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.12.3 The fmin functions (p: 258)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.9.3 The fmin functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.12.3 The fmin functions (p: 239)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.9.3 The fmin functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fmin](https://en.cppreference.com/w/c/numeric/math/fmin)"
- name: fminl
  summary: If successful, returns the smaller of two floating point values
  description: "# fmin, fminf, fminl\n\n[TABLE]\n\n1-3) Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).\n\n4) Type-generic macro: If any argument has type `long double`, `fminl` is called. Otherwise, if any argument has integer type or has type `double`, `fmin` is called. Otherwise, `fminf` is called.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If one of the two arguments is NaN, the value of the other argument is returned\n- Only if both arguments are NaN, NaN is returned\n\n### Notes\n\nThis function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"fmin(2,1)    = %f\\n\", fmin(2,1));\n    printf(\"fmin(-Inf,0) = %f\\n\", fmin(-INFINITY,0));\n    printf(\"fmin(NaN,-1) = %f\\n\", fmin(NAN,-1));\n}\n```\n\nPossible output:\n\n```\nfmin(2,1)    = 1.000000\nfmin(-Inf,0) = -inf\nfmin(NaN,-1) = -1.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.12.3 The fmin functions (p: 258)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.9.3 The fmin functions (p: 530)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.12.3 The fmin functions (p: 239)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.9.3 The fmin functions (p: 466)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fmin](https://en.cppreference.com/w/c/numeric/math/fmin)"
- name: fmod
  summary: The floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where n is x/y with its fractional part truncated
  description: "# fmod, fmodf, fmodl\n\n[TABLE]\n\n1-3) Computes the floating-point remainder of the division operation `x/y`.\n\n4) Type-generic macro: If any argument has type `long double`, `fmodl` is called. Otherwise, if any argument has integer type or has type `double`, `fmod` is called. Otherwise, `fmodf` is called.\n\nThe floating-point remainder of the division operation `x/y` calculated by this function is exactly the value `x - n*y`, where `n` is `x/y` with its fractional part truncated.\n\nThe returned value has the same sign as `x` and is less or equal to `y` in magnitude.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the floating-point remainder of the division `x/y` as defined above.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `y` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `x` is ±0 and `y` is not zero, ±0 is returned\n- If `x` is ±∞ and `y` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `y` is ±0 and `x` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `y` is ±∞ and `x` is finite, `x` is returned.\n- If either argument is NaN, NaN is returned\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fmod.html) that a domain error occurs if `x` is infinite or `y` is zero.\n\n`fmod`, but not [`remainder`](remainder \"c/numeric/math/remainder\") is useful for doing silent wrapping of floating-point types to unsigned integer types: `(``0.0`` ``<=`` ``(``y ``=`` fmod``(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0`` ``)``)`` ``?`` y ``:`` ``65536.0`` ``+`` y``)` is in the range `[-0.0 .. 65535.0]`, which corresponds to `unsigned short`, but [`remainder`](http://en.cppreference.com/w/c/numeric/math/remainder)`(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0``)` is in the range `[-32767.0, +32768.0]`, which is outside of the range of `signed short`.\n\nThe `double` version of `fmod` behaves as if implemented as follows:\n\n```\ndouble fmod(double x, double y)\n{\n#pragma STDC FENV_ACCESS ON\n    double result = remainder(fabs(x), (y = fabs(y)));\n    if (signbit(result)) result += y;\n    return copysign(result, x);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"fmod(+5.1, +3.0) = %.1f\\n\", fmod(5.1,3));\n    printf(\"fmod(-5.1, +3.0) = %.1f\\n\", fmod(-5.1,3));\n    printf(\"fmod(+5.1, -3.0) = %.1f\\n\", fmod(5.1,-3));\n    printf(\"fmod(-5.1, -3.0) = %.1f\\n\", fmod(-5.1,-3));\n \n    // special values\n    printf(\"fmod(+0.0, 1.0) = %.1f\\n\", fmod(0, 1));\n    printf(\"fmod(-0.0, 1.0) = %.1f\\n\", fmod(-0.0, 1));\n    printf(\"fmod(+5.1, Inf) = %.1f\\n\", fmod(5.1, INFINITY));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"fmod(+5.1, 0) = %.1f\\n\", fmod(5.1, 0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nfmod(+5.1, +3.0) = 2.1\nfmod(-5.1, +3.0) = -2.1\nfmod(+5.1, -3.0) = 2.1\nfmod(-5.1, -3.0) = -2.1\nfmod(+0.0, 1.0) = 0.0\nfmod(-0.0, 1.0) = -0.0\nfmod(+5.1, Inf) = 5.1\nfmod(+5.1, 0) = nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.10.1 The fmod functions (p: 185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 274-275)\n  - F.10.7.1 The fmod functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.10.1 The fmod functions (p: 254)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.7.1 The fmod functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.10.1 The fmod functions (p: 235)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.7.1 The fmod functions (p: 465)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.4 The fmod function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fmod](https://en.cppreference.com/w/c/numeric/math/fmod)"
- name: fmodf
  summary: The floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where n is x/y with its fractional part truncated
  description: "# fmod, fmodf, fmodl\n\n[TABLE]\n\n1-3) Computes the floating-point remainder of the division operation `x/y`.\n\n4) Type-generic macro: If any argument has type `long double`, `fmodl` is called. Otherwise, if any argument has integer type or has type `double`, `fmod` is called. Otherwise, `fmodf` is called.\n\nThe floating-point remainder of the division operation `x/y` calculated by this function is exactly the value `x - n*y`, where `n` is `x/y` with its fractional part truncated.\n\nThe returned value has the same sign as `x` and is less or equal to `y` in magnitude.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the floating-point remainder of the division `x/y` as defined above.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `y` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `x` is ±0 and `y` is not zero, ±0 is returned\n- If `x` is ±∞ and `y` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `y` is ±0 and `x` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `y` is ±∞ and `x` is finite, `x` is returned.\n- If either argument is NaN, NaN is returned\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fmod.html) that a domain error occurs if `x` is infinite or `y` is zero.\n\n`fmod`, but not [`remainder`](remainder \"c/numeric/math/remainder\") is useful for doing silent wrapping of floating-point types to unsigned integer types: `(``0.0`` ``<=`` ``(``y ``=`` fmod``(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0`` ``)``)`` ``?`` y ``:`` ``65536.0`` ``+`` y``)` is in the range `[-0.0 .. 65535.0]`, which corresponds to `unsigned short`, but [`remainder`](http://en.cppreference.com/w/c/numeric/math/remainder)`(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0``)` is in the range `[-32767.0, +32768.0]`, which is outside of the range of `signed short`.\n\nThe `double` version of `fmod` behaves as if implemented as follows:\n\n```\ndouble fmod(double x, double y)\n{\n#pragma STDC FENV_ACCESS ON\n    double result = remainder(fabs(x), (y = fabs(y)));\n    if (signbit(result)) result += y;\n    return copysign(result, x);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"fmod(+5.1, +3.0) = %.1f\\n\", fmod(5.1,3));\n    printf(\"fmod(-5.1, +3.0) = %.1f\\n\", fmod(-5.1,3));\n    printf(\"fmod(+5.1, -3.0) = %.1f\\n\", fmod(5.1,-3));\n    printf(\"fmod(-5.1, -3.0) = %.1f\\n\", fmod(-5.1,-3));\n \n    // special values\n    printf(\"fmod(+0.0, 1.0) = %.1f\\n\", fmod(0, 1));\n    printf(\"fmod(-0.0, 1.0) = %.1f\\n\", fmod(-0.0, 1));\n    printf(\"fmod(+5.1, Inf) = %.1f\\n\", fmod(5.1, INFINITY));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"fmod(+5.1, 0) = %.1f\\n\", fmod(5.1, 0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nfmod(+5.1, +3.0) = 2.1\nfmod(-5.1, +3.0) = -2.1\nfmod(+5.1, -3.0) = 2.1\nfmod(-5.1, -3.0) = -2.1\nfmod(+0.0, 1.0) = 0.0\nfmod(-0.0, 1.0) = -0.0\nfmod(+5.1, Inf) = 5.1\nfmod(+5.1, 0) = nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.10.1 The fmod functions (p: 185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 274-275)\n  - F.10.7.1 The fmod functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.10.1 The fmod functions (p: 254)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.7.1 The fmod functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.10.1 The fmod functions (p: 235)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.7.1 The fmod functions (p: 465)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.4 The fmod function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fmod](https://en.cppreference.com/w/c/numeric/math/fmod)"
- name: fmodl
  summary: The floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where n is x/y with its fractional part truncated
  description: "# fmod, fmodf, fmodl\n\n[TABLE]\n\n1-3) Computes the floating-point remainder of the division operation `x/y`.\n\n4) Type-generic macro: If any argument has type `long double`, `fmodl` is called. Otherwise, if any argument has integer type or has type `double`, `fmod` is called. Otherwise, `fmodf` is called.\n\nThe floating-point remainder of the division operation `x/y` calculated by this function is exactly the value `x - n*y`, where `n` is `x/y` with its fractional part truncated.\n\nThe returned value has the same sign as `x` and is less or equal to `y` in magnitude.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the floating-point remainder of the division `x/y` as defined above.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `y` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `x` is ±0 and `y` is not zero, ±0 is returned\n- If `x` is ±∞ and `y` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `y` is ±0 and `x` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `y` is ±∞ and `x` is finite, `x` is returned.\n- If either argument is NaN, NaN is returned\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fmod.html) that a domain error occurs if `x` is infinite or `y` is zero.\n\n`fmod`, but not [`remainder`](remainder \"c/numeric/math/remainder\") is useful for doing silent wrapping of floating-point types to unsigned integer types: `(``0.0`` ``<=`` ``(``y ``=`` fmod``(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0`` ``)``)`` ``?`` y ``:`` ``65536.0`` ``+`` y``)` is in the range `[-0.0 .. 65535.0]`, which corresponds to `unsigned short`, but [`remainder`](http://en.cppreference.com/w/c/numeric/math/remainder)`(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0``)` is in the range `[-32767.0, +32768.0]`, which is outside of the range of `signed short`.\n\nThe `double` version of `fmod` behaves as if implemented as follows:\n\n```\ndouble fmod(double x, double y)\n{\n#pragma STDC FENV_ACCESS ON\n    double result = remainder(fabs(x), (y = fabs(y)));\n    if (signbit(result)) result += y;\n    return copysign(result, x);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"fmod(+5.1, +3.0) = %.1f\\n\", fmod(5.1,3));\n    printf(\"fmod(-5.1, +3.0) = %.1f\\n\", fmod(-5.1,3));\n    printf(\"fmod(+5.1, -3.0) = %.1f\\n\", fmod(5.1,-3));\n    printf(\"fmod(-5.1, -3.0) = %.1f\\n\", fmod(-5.1,-3));\n \n    // special values\n    printf(\"fmod(+0.0, 1.0) = %.1f\\n\", fmod(0, 1));\n    printf(\"fmod(-0.0, 1.0) = %.1f\\n\", fmod(-0.0, 1));\n    printf(\"fmod(+5.1, Inf) = %.1f\\n\", fmod(5.1, INFINITY));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"fmod(+5.1, 0) = %.1f\\n\", fmod(5.1, 0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nfmod(+5.1, +3.0) = 2.1\nfmod(-5.1, +3.0) = -2.1\nfmod(+5.1, -3.0) = 2.1\nfmod(-5.1, -3.0) = -2.1\nfmod(+0.0, 1.0) = 0.0\nfmod(-0.0, 1.0) = -0.0\nfmod(+5.1, Inf) = 5.1\nfmod(+5.1, 0) = nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.10.1 The fmod functions (p: 185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 274-275)\n  - F.10.7.1 The fmod functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.10.1 The fmod functions (p: 254)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.7.1 The fmod functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.10.1 The fmod functions (p: 235)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.7.1 The fmod functions (p: 465)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.6.4 The fmod function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fmod](https://en.cppreference.com/w/c/numeric/math/fmod)"
- name: fopen
  summary: The format of filename is implementation-defined, and does not necessarily refer to a file (e.g
  description: "# fopen, fopen_s\n\n[TABLE]\n\n1) Opens a file indicated by `filename` and returns a pointer to the file stream associated with that file. `mode` is used to determine the file access mode.\n\n2) Same as (1), except that the pointer to the file stream is written to `streamptr` and the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `streamptr` is a null pointer\n- `filename` is a null pointer\n- `mode` is a null pointer\n\nAs with all bounds-checked functions, `fopen_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|           |     |                                                                                     |\n|-----------|-----|-------------------------------------------------------------------------------------|\n| filename  | \\-  | file name to associate the file stream to                                           |\n| mode      | \\-  | null-terminated character string determining [file access mode](#File_access_flags) |\n| streamptr | \\-  | pointer to a pointer where the function stores the result (an out-parameter)        |\n\n### File access flags\n\n[TABLE]\n\n### Return value\n\n1) If successful, returns a pointer to the new file stream. The stream is fully buffered unless `filename` refers to an interactive device. On error, returns a null pointer. [POSIX requires](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html) that [`errno`](../error/errno \"c/error/errno\") be set in this case.\n\n2) If successful, returns zero and a pointer to the new file stream is written to `*streamptr`. On error, returns a non-zero error code and writes the null pointer to `*streamptr` (unless `streamptr` is a null pointer itself).\n\n### Notes\n\nThe format of `filename` is implementation-defined, and does not necessarily refer to a file (e.g. it may be the console or another device accessible though filesystem API). On platforms that support them, `filename` may include absolute or relative filesystem path.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char* fname = \"/tmp/unique_name.txt\"; // or tmpnam(NULL);\n    int is_ok = EXIT_FAILURE;\n \n    FILE* fp = fopen(fname, \"w+\");\n    if (!fp) {\n        perror(\"File opening failed\");\n        return is_ok;\n    }\n    fputs(\"Hello, world!\\n\", fp);\n    rewind(fp);\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = fgetc(fp)) != EOF) // standard C I/O file reading loop\n        putchar(c);\n \n    if (ferror(fp))\n        puts(\"I/O error when reading\");\n    else if (feof(fp)) {\n        puts(\"End of file is reached successfully\");\n        is_ok = EXIT_SUCCESS;\n    }\n \n    fclose(fp);\n    remove(fname);\n    return is_ok;\n}\n```\n\nPossible output:\n\n```\nHello, world!\nEnd of file is reached successfully\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.5.3 The fopen function (p: 223-224)\n  - K.3.5.2.1 The fopen_s function (p: 428-429)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.5.3 The fopen function (p: 305-306)\n  - K.3.5.2.1 The fopen_s function (p: 588-590)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.5.3 The fopen function (p: 271-272)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.5.3 The fopen function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fopen](https://en.cppreference.com/w/c/io/fopen)"
- name: fopen_s
  summary: The format of filename is implementation-defined, and does not necessarily refer to a file (e.g
  description: "# fopen, fopen_s\n\n[TABLE]\n\n1) Opens a file indicated by `filename` and returns a pointer to the file stream associated with that file. `mode` is used to determine the file access mode.\n\n2) Same as (1), except that the pointer to the file stream is written to `streamptr` and the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `streamptr` is a null pointer\n- `filename` is a null pointer\n- `mode` is a null pointer\n\nAs with all bounds-checked functions, `fopen_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|           |     |                                                                                     |\n|-----------|-----|-------------------------------------------------------------------------------------|\n| filename  | \\-  | file name to associate the file stream to                                           |\n| mode      | \\-  | null-terminated character string determining [file access mode](#File_access_flags) |\n| streamptr | \\-  | pointer to a pointer where the function stores the result (an out-parameter)        |\n\n### File access flags\n\n[TABLE]\n\n### Return value\n\n1) If successful, returns a pointer to the new file stream. The stream is fully buffered unless `filename` refers to an interactive device. On error, returns a null pointer. [POSIX requires](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html) that [`errno`](../error/errno \"c/error/errno\") be set in this case.\n\n2) If successful, returns zero and a pointer to the new file stream is written to `*streamptr`. On error, returns a non-zero error code and writes the null pointer to `*streamptr` (unless `streamptr` is a null pointer itself).\n\n### Notes\n\nThe format of `filename` is implementation-defined, and does not necessarily refer to a file (e.g. it may be the console or another device accessible though filesystem API). On platforms that support them, `filename` may include absolute or relative filesystem path.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char* fname = \"/tmp/unique_name.txt\"; // or tmpnam(NULL);\n    int is_ok = EXIT_FAILURE;\n \n    FILE* fp = fopen(fname, \"w+\");\n    if (!fp) {\n        perror(\"File opening failed\");\n        return is_ok;\n    }\n    fputs(\"Hello, world!\\n\", fp);\n    rewind(fp);\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = fgetc(fp)) != EOF) // standard C I/O file reading loop\n        putchar(c);\n \n    if (ferror(fp))\n        puts(\"I/O error when reading\");\n    else if (feof(fp)) {\n        puts(\"End of file is reached successfully\");\n        is_ok = EXIT_SUCCESS;\n    }\n \n    fclose(fp);\n    remove(fname);\n    return is_ok;\n}\n```\n\nPossible output:\n\n```\nHello, world!\nEnd of file is reached successfully\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.5.3 The fopen function (p: 223-224)\n  - K.3.5.2.1 The fopen_s function (p: 428-429)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.5.3 The fopen function (p: 305-306)\n  - K.3.5.2.1 The fopen_s function (p: 588-590)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.5.3 The fopen function (p: 271-272)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.5.3 The fopen function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fopen](https://en.cppreference.com/w/c/io/fopen)"
- name: for
  summary: ''
  description: "# C keywords: for\n\n### Usage\n\n- [`for` loop](../language/for \"c/language/for\"): as the declaration of the loop\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/for](https://en.cppreference.com/w/c/keyword/for)"
- name: for loop
  summary: Executes a loop
  description: "# for loop\n\nExecutes a loop.\n\nUsed as a shorter equivalent of [while loop](while \"c/language/while\").\n\n### Syntax\n\n|                                                                                                                          |     |     |\n|--------------------------------------------------------------------------------------------------------------------------|-----|-----|\n| attr-spec-seq(since C23)(optional) `for` `(` init-clause `;` cond-expression `;` iteration-expression `)` loop-statement |     |     |\n\n### Explanation\n\nBehaves as follows:\n\n- init-clause may be an expression or a declaration(since C99).\n  - An init-clause, which is an expression, is evaluated once, before the first evaluation of cond-expression and its result is discarded.\n\n[TABLE]\n\n- cond-expression is evaluated before the loop body. If the result of the expression is zero, the loop statement is exited immediately.\n- iteration-expression is evaluated after the loop body and its result is discarded. After evaluating iteration-expression, control is transferred to cond-expression.\n\ninit-clause, cond-expression, and iteration-expression are all optional. If cond-expression is omitted, it is replaced with a non-zero integer constant, which makes the loop endless:\n\n```\nfor(;;) {\n   printf(\"endless loop!\");\n}\n```\n\nloop-statement is not optional, but it may be a null statement:\n\n```\nfor(int n = 0; n < 10; ++n, printf(\"%d\\n\", n))\n    ; // null statement\n```\n\nIf the execution of the loop needs to be terminated at some point, a [break statement](break \"c/language/break\") can be used anywhere within the loop-statement.\n\nThe [continue statement](continue \"c/language/continue\") used anywhere within the loop-statement transfers control to iteration-expression.\n\nA program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its cond-expression, iteration-expression or loop-statement. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where cond-expression is omitted or is a constant expression; `for(;;)` is always an endless loop.\n\n|                                                                                                                                                                                                                                                                 |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| As with all other selection and iteration statements, the for statement establishes [block scope](scope \"c/language/scope\"): any identifier introduced in the init-clause, cond-expression, or iteration-expression goes out of scope after the loop-statement. | (since C99) |\n\n|                                                                                                                        |             |\n|------------------------------------------------------------------------------------------------------------------------|-------------|\n| attr-spec-seq is an optional list of [attributes](attributes \"c/language/attributes\"), applied to the `for` statement. | (since C23) |\n\n### Keywords\n\n[`for`](../keyword/for \"c/keyword/for\")\n\n### Notes\n\nThe expression statement used as loop-statement establishes its own block scope, distinct from the scope of init-clause, unlike in C++:\n\n```\nfor (int i = 0; ; ) {\n    long i = 1;   // valid C, invalid C++\n    // ...\n}\n```\n\nIt is possible to enter the body of a loop using [goto](goto \"c/language/goto\"). When entering a loop in this manner, init-clause and cond-expression are not executed. (If control then reaches the end of the loop body, repetition may occur including execution of cond-expression.)\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\nenum { SIZE = 8 };\nint main(void)\n{\n    int array[SIZE];\n    for(size_t i = 0 ; i < SIZE; ++i)\n        array [i] = rand() % 2;\n    printf(\"Array filled!\\n\");\n    for (size_t i = 0; i < SIZE; ++i)\n        printf(\"%d \", array[i]);\n    putchar('\\n');\n}\n```\n\nPossible output:\n\n```\nArray filled!\n1 0 1 1 1 1 0 0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.8.5.3 The for statement (p: 110)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.8.5.3 The for statement (p: 151)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.8.5.3 The for statement (p: 136)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.6.5.3 The for statement\n\n### See also\n\n|                                                                                                       |     |\n|-------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/for \"cpp/language/for\") for `for` loop |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/for](https://en.cppreference.com/w/c/language/for)"
- name: fortran
  summary: ''
  description: "# C keywords: fortran\n\n### Usage\n\n- conditionally-supported type specifier for Fortran language linkage. May be used with [function declarations](../language/function_declaration \"c/language/function declaration\") and other [external declarations](../language/extern \"c/language/extern\") to indicate that the calling convention and name mangling is suitable for linking with translation units written in the Fortran programming language.\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/fortran](https://en.cppreference.com/w/c/keyword/fortran)"
- name: FP_INFINITE
  summary: The FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN macros each represent a distinct category of floating-point numbers
  description: "# FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN\n\n[TABLE]\n\nThe `FP_NORMAL`, `FP_SUBNORMAL`, `FP_ZERO`, `FP_INFINITE`, `FP_NAN` macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.\n\n| Constant       | Explanation                                                                                                         |\n|----------------|---------------------------------------------------------------------------------------------------------------------|\n| `FP_NORMAL`    | indicates that the value is *normal*, i.e. not an infinity, subnormal, not-a-number or zero                         |\n| `FP_SUBNORMAL` | indicates that the value is [*subnormal*](https://en.wikipedia.org/wiki/Subnormal_number \"enwiki:Subnormal number\") |\n| `FP_ZERO`      | indicates that the value is positive or negative zero                                                               |\n| `FP_INFINITE`  | indicates that the value is not representable by the underlying type (positive or negative infinity)                |\n| `FP_NAN`       | indicates that the value is not-a-number (NaN)                                                                      |\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nconst char *show_classification(double x) {\n    switch(fpclassify(x)) {\n        case FP_INFINITE:  return \"Inf\";\n        case FP_NAN:       return \"NaN\";\n        case FP_NORMAL:    return \"normal\";\n        case FP_SUBNORMAL: return \"subnormal\";\n        case FP_ZERO:      return \"zero\";\n        default:           return \"unknown\";\n    }\n}\nint main(void)\n{\n    printf(\"1.0/0.0 is %s\\n\", show_classification(1/0.0));\n    printf(\"0.0/0.0 is %s\\n\", show_classification(0.0/0.0));\n    printf(\"DBL_MIN/2 is %s\\n\", show_classification(DBL_MIN/2));\n    printf(\"-0.0 is %s\\n\", show_classification(-0.0));\n    printf(\" 1.0 is %s\\n\", show_classification(1.0));\n}\n```\n\nOutput:\n\n```\n1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n 1.0 is normal\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/6 FP_NORMAL, ... (p: 169-170)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/6 FP_NORMAL, ... (p: 232)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/6 FP_NORMAL, ... (p: 213)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/FP_categories](https://en.cppreference.com/w/c/numeric/math/FP_categories)"
- name: FP_NAN
  summary: The FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN macros each represent a distinct category of floating-point numbers
  description: "# FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN\n\n[TABLE]\n\nThe `FP_NORMAL`, `FP_SUBNORMAL`, `FP_ZERO`, `FP_INFINITE`, `FP_NAN` macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.\n\n| Constant       | Explanation                                                                                                         |\n|----------------|---------------------------------------------------------------------------------------------------------------------|\n| `FP_NORMAL`    | indicates that the value is *normal*, i.e. not an infinity, subnormal, not-a-number or zero                         |\n| `FP_SUBNORMAL` | indicates that the value is [*subnormal*](https://en.wikipedia.org/wiki/Subnormal_number \"enwiki:Subnormal number\") |\n| `FP_ZERO`      | indicates that the value is positive or negative zero                                                               |\n| `FP_INFINITE`  | indicates that the value is not representable by the underlying type (positive or negative infinity)                |\n| `FP_NAN`       | indicates that the value is not-a-number (NaN)                                                                      |\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nconst char *show_classification(double x) {\n    switch(fpclassify(x)) {\n        case FP_INFINITE:  return \"Inf\";\n        case FP_NAN:       return \"NaN\";\n        case FP_NORMAL:    return \"normal\";\n        case FP_SUBNORMAL: return \"subnormal\";\n        case FP_ZERO:      return \"zero\";\n        default:           return \"unknown\";\n    }\n}\nint main(void)\n{\n    printf(\"1.0/0.0 is %s\\n\", show_classification(1/0.0));\n    printf(\"0.0/0.0 is %s\\n\", show_classification(0.0/0.0));\n    printf(\"DBL_MIN/2 is %s\\n\", show_classification(DBL_MIN/2));\n    printf(\"-0.0 is %s\\n\", show_classification(-0.0));\n    printf(\" 1.0 is %s\\n\", show_classification(1.0));\n}\n```\n\nOutput:\n\n```\n1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n 1.0 is normal\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/6 FP_NORMAL, ... (p: 169-170)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/6 FP_NORMAL, ... (p: 232)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/6 FP_NORMAL, ... (p: 213)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/FP_categories](https://en.cppreference.com/w/c/numeric/math/FP_categories)"
- name: FP_NORMAL
  summary: The FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN macros each represent a distinct category of floating-point numbers
  description: "# FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN\n\n[TABLE]\n\nThe `FP_NORMAL`, `FP_SUBNORMAL`, `FP_ZERO`, `FP_INFINITE`, `FP_NAN` macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.\n\n| Constant       | Explanation                                                                                                         |\n|----------------|---------------------------------------------------------------------------------------------------------------------|\n| `FP_NORMAL`    | indicates that the value is *normal*, i.e. not an infinity, subnormal, not-a-number or zero                         |\n| `FP_SUBNORMAL` | indicates that the value is [*subnormal*](https://en.wikipedia.org/wiki/Subnormal_number \"enwiki:Subnormal number\") |\n| `FP_ZERO`      | indicates that the value is positive or negative zero                                                               |\n| `FP_INFINITE`  | indicates that the value is not representable by the underlying type (positive or negative infinity)                |\n| `FP_NAN`       | indicates that the value is not-a-number (NaN)                                                                      |\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nconst char *show_classification(double x) {\n    switch(fpclassify(x)) {\n        case FP_INFINITE:  return \"Inf\";\n        case FP_NAN:       return \"NaN\";\n        case FP_NORMAL:    return \"normal\";\n        case FP_SUBNORMAL: return \"subnormal\";\n        case FP_ZERO:      return \"zero\";\n        default:           return \"unknown\";\n    }\n}\nint main(void)\n{\n    printf(\"1.0/0.0 is %s\\n\", show_classification(1/0.0));\n    printf(\"0.0/0.0 is %s\\n\", show_classification(0.0/0.0));\n    printf(\"DBL_MIN/2 is %s\\n\", show_classification(DBL_MIN/2));\n    printf(\"-0.0 is %s\\n\", show_classification(-0.0));\n    printf(\" 1.0 is %s\\n\", show_classification(1.0));\n}\n```\n\nOutput:\n\n```\n1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n 1.0 is normal\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/6 FP_NORMAL, ... (p: 169-170)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/6 FP_NORMAL, ... (p: 232)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/6 FP_NORMAL, ... (p: 213)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/FP_categories](https://en.cppreference.com/w/c/numeric/math/FP_categories)"
- name: FP_SUBNORMAL
  summary: The FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN macros each represent a distinct category of floating-point numbers
  description: "# FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN\n\n[TABLE]\n\nThe `FP_NORMAL`, `FP_SUBNORMAL`, `FP_ZERO`, `FP_INFINITE`, `FP_NAN` macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.\n\n| Constant       | Explanation                                                                                                         |\n|----------------|---------------------------------------------------------------------------------------------------------------------|\n| `FP_NORMAL`    | indicates that the value is *normal*, i.e. not an infinity, subnormal, not-a-number or zero                         |\n| `FP_SUBNORMAL` | indicates that the value is [*subnormal*](https://en.wikipedia.org/wiki/Subnormal_number \"enwiki:Subnormal number\") |\n| `FP_ZERO`      | indicates that the value is positive or negative zero                                                               |\n| `FP_INFINITE`  | indicates that the value is not representable by the underlying type (positive or negative infinity)                |\n| `FP_NAN`       | indicates that the value is not-a-number (NaN)                                                                      |\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nconst char *show_classification(double x) {\n    switch(fpclassify(x)) {\n        case FP_INFINITE:  return \"Inf\";\n        case FP_NAN:       return \"NaN\";\n        case FP_NORMAL:    return \"normal\";\n        case FP_SUBNORMAL: return \"subnormal\";\n        case FP_ZERO:      return \"zero\";\n        default:           return \"unknown\";\n    }\n}\nint main(void)\n{\n    printf(\"1.0/0.0 is %s\\n\", show_classification(1/0.0));\n    printf(\"0.0/0.0 is %s\\n\", show_classification(0.0/0.0));\n    printf(\"DBL_MIN/2 is %s\\n\", show_classification(DBL_MIN/2));\n    printf(\"-0.0 is %s\\n\", show_classification(-0.0));\n    printf(\" 1.0 is %s\\n\", show_classification(1.0));\n}\n```\n\nOutput:\n\n```\n1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n 1.0 is normal\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/6 FP_NORMAL, ... (p: 169-170)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/6 FP_NORMAL, ... (p: 232)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/6 FP_NORMAL, ... (p: 213)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/FP_categories](https://en.cppreference.com/w/c/numeric/math/FP_categories)"
- name: FP_ZERO
  summary: The FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN macros each represent a distinct category of floating-point numbers
  description: "# FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN\n\n[TABLE]\n\nThe `FP_NORMAL`, `FP_SUBNORMAL`, `FP_ZERO`, `FP_INFINITE`, `FP_NAN` macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.\n\n| Constant       | Explanation                                                                                                         |\n|----------------|---------------------------------------------------------------------------------------------------------------------|\n| `FP_NORMAL`    | indicates that the value is *normal*, i.e. not an infinity, subnormal, not-a-number or zero                         |\n| `FP_SUBNORMAL` | indicates that the value is [*subnormal*](https://en.wikipedia.org/wiki/Subnormal_number \"enwiki:Subnormal number\") |\n| `FP_ZERO`      | indicates that the value is positive or negative zero                                                               |\n| `FP_INFINITE`  | indicates that the value is not representable by the underlying type (positive or negative infinity)                |\n| `FP_NAN`       | indicates that the value is not-a-number (NaN)                                                                      |\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nconst char *show_classification(double x) {\n    switch(fpclassify(x)) {\n        case FP_INFINITE:  return \"Inf\";\n        case FP_NAN:       return \"NaN\";\n        case FP_NORMAL:    return \"normal\";\n        case FP_SUBNORMAL: return \"subnormal\";\n        case FP_ZERO:      return \"zero\";\n        default:           return \"unknown\";\n    }\n}\nint main(void)\n{\n    printf(\"1.0/0.0 is %s\\n\", show_classification(1/0.0));\n    printf(\"0.0/0.0 is %s\\n\", show_classification(0.0/0.0));\n    printf(\"DBL_MIN/2 is %s\\n\", show_classification(DBL_MIN/2));\n    printf(\"-0.0 is %s\\n\", show_classification(-0.0));\n    printf(\" 1.0 is %s\\n\", show_classification(1.0));\n}\n```\n\nOutput:\n\n```\n1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n 1.0 is normal\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/6 FP_NORMAL, ... (p: 169-170)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/6 FP_NORMAL, ... (p: 232)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/6 FP_NORMAL, ... (p: 213)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/FP_categories](https://en.cppreference.com/w/c/numeric/math/FP_categories)"
- name: fpclassify
  summary: 'Categorizes floating point value arg into the following categories: zero, subnormal, normal, infinite, NAN, or implementation-defined category'
  description: "# fpclassify\n\n[TABLE]\n\nCategorizes floating point value `arg` into the following categories: zero, subnormal, normal, infinite, NAN, or implementation-defined category. The macro returns an integral value.\n\n[`FLT_EVAL_METHOD`](../../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\") is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that: a normal long double value might become subnormal when converted to double and zero when converted to float.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nOne of [`FP_INFINITE`](fp_categories \"c/numeric/math/FP categories\"), [`FP_NAN`](fp_categories \"c/numeric/math/FP categories\"), [`FP_NORMAL`](fp_categories \"c/numeric/math/FP categories\"), [`FP_SUBNORMAL`](fp_categories \"c/numeric/math/FP categories\"), [`FP_ZERO`](fp_categories \"c/numeric/math/FP categories\") or implementation-defined type, specifying the category of `arg`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nconst char *show_classification(double x) {\n    switch(fpclassify(x)) {\n        case FP_INFINITE:  return \"Inf\";\n        case FP_NAN:       return \"NaN\";\n        case FP_NORMAL:    return \"normal\";\n        case FP_SUBNORMAL: return \"subnormal\";\n        case FP_ZERO:      return \"zero\";\n        default:           return \"unknown\";\n    }\n}\nint main(void)\n{\n    printf(\"1.0/0.0 is %s\\n\", show_classification(1/0.0));\n    printf(\"0.0/0.0 is %s\\n\", show_classification(0.0/0.0));\n    printf(\"DBL_MIN/2 is %s\\n\", show_classification(DBL_MIN/2));\n    printf(\"-0.0 is %s\\n\", show_classification(-0.0));\n    printf(\"1.0 is %s\\n\", show_classification(1.0));\n}\n```\n\nOutput:\n\n```\n1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n1.0 is normal\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.3.1 The fpclassify macro (p: 235)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.3.1 The fpclassify macro (p: 216)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/fpclassify](https://en.cppreference.com/w/c/numeric/math/fpclassify)"
- name: fpos_t
  summary: fpos_t is a non-array complete object type, can be used to store (by fgetpos) and restore (by fsetpos) the position and multibyte parser state (if any) for a C stream
  description: "# fpos_t\n\n[TABLE]\n\n`fpos_t` is a non-array complete object type, can be used to store (by [`fgetpos`](fgetpos \"c/io/fgetpos\")) and restore (by [`fsetpos`](fsetpos \"c/io/fsetpos\")) the position and multibyte parser state (if any) for a C stream.\n\n|                                                                                                                                                                                                                                                                        |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The multibyte parser state of a wide-oriented C stream is represented by a [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object, whose value is stored as part of the value of a `fpos_t` object by [`fgetpos`](fgetpos \"c/io/fgetpos\"). | (since C95) |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.1 Introduction (p: 217-218)\n  - 7.21.2 Streams (p: 218-219)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.1 Introduction (p: 296-298)\n  - 7.21.2 Streams (p: 298-299)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.1 Introduction (p: 262-264)\n  - 7.19.2 Streams (p: 264-265)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.1 Introduction\n  - 4.9.2 Streams\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fpos_t](https://en.cppreference.com/w/c/io/fpos_t)"
- name: fprintf
  summary: 'Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:'
  description: "# printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:\n\n1) Writes the results to the output stream [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to the output stream `stream`.\n\n3) Writes the results to a character string `buffer`. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz` - 1 characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `stream` or `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `sprintf_s` only), the string to be stored in `buffer` (including the trailing null) would exceed `bufsz`\n\nAs with all bounds-checked functions, `printf_s` , `fprintf_s`, `sprintf_s`, and `snprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a character string to write to                                                                                                                                                                                                                                                                                                                                                                                                |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                      |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) number of characters transmitted to the output stream or negative value if an output error or an encoding error (for string and character conversion specifiers) occurred\n\n3) number of characters written to `buffer` (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n4) number of characters (not including the terminating null character) which would have been written to `buffer` if `bufsz` was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nThe C standard and [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) specify that the behavior of `sprintf` and its variants is undefined when an argument overlaps with the destination buffer. Example:\n\n```\nsprintf(dst, \"%s and %s\", dst, t); // <- broken: undefined behavior\n```\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) that [`errno`](../error/errno \"c/error/errno\") is set on error. It also specifies additional conversion specifications, most notably support for argument reordering (`n$` immediately after `%` indicates `n`^(th) argument).\n\nCalling `snprintf` with zero `bufsz` and null pointer for `buffer` is useful to determine the necessary buffer size to contain the output:\n\n```\nconst char fmt[] = \"sqrt(2) = %f\";\nint sz = snprintf(NULL, 0, fmt, sqrt(2));\nchar buf[sz + 1]; // note +1 for terminating null byte\nsnprintf(buf, sizeof buf, fmt, sqrt(2));\n```\n\n`snprintf_s`, just like `snprintf`, but unlike `sprintf_s`, will truncate the output to fit in `bufsz-1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n \nint main(void)\n{\n    const char* s = \"Hello\";\n    printf(\"Strings:\\n\"); // same as puts(\"Strings\");\n    printf(\" padding:\\n\");\n    printf(\"\\t[%10s]\\n\", s);\n    printf(\"\\t[%-10s]\\n\", s);\n    printf(\"\\t[%*s]\\n\", 10, s);\n    printf(\" truncating:\\n\");\n    printf(\"\\t%.4s\\n\", s);\n    printf(\"\\t%.*s\\n\", 3, s);\n \n    printf(\"Characters:\\t%c %%\\n\", 'A');\n \n    printf(\"Integers:\\n\");\n    printf(\"\\tDecimal:\\t%i %d %.6i %i %.0i %+i %i\\n\",\n                         1, 2,   3, 0,   0,  4,-4);\n    printf(\"\\tHexadecimal:\\t%x %x %X %#x\\n\", 5, 10, 10, 6);\n    printf(\"\\tOctal:\\t\\t%o %#o %#o\\n\", 10, 10, 4);\n \n    printf(\"Floating point:\\n\");\n    printf(\"\\tRounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    printf(\"\\tPadding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    printf(\"\\tScientific:\\t%E %e\\n\", 1.5, 1.5);\n    printf(\"\\tHexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n    printf(\"\\tSpecial values:\\t0/0=%g 1/0=%g\\n\", 0.0/0.0, 1.0/0.0);\n \n    printf(\"Fixed-width types:\\n\");\n    printf(\"\\tLargest 32-bit value is %\" PRIu32 \" or %#\" PRIx32 \"\\n\",\n                                     UINT32_MAX,     UINT32_MAX );\n}\n```\n\nPossible output:\n\n```\nStrings:\n padding:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n truncating:\n        Hell\n        Hel\nCharacters:        A %\nIntegers:\n        Decimal:        1 2 000003 0  +4 -4\n        Hexadecimal:        5 a A 0x6\n        Octal:                12 012 04\nFloating point:\n        Rounding:        1.500000 2 1.30000000000000004440892098500626\n        Padding:        01.50 1.50  1.50\n        Scientific:        1.500000E+00 1.500000e+00\n        Hexadecimal:        0x1.8p+0 0X1.8P+0\n        Special values:        0/0=-nan 1/0=inf\nFixed-width types:\n        Largest 32-bit value is 4294967295 or 0xffffffff\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.1 The fprintf function (p: 225-230)\n  - 7.21.6.3 The printf function (p: 236)\n  - 7.21.6.5 The snprintf function (p: 237)\n  - 7.21.6.6 The sprintf function (p: 237)\n  - K.3.5.3.1 The fprintf_s function (p: 430)\n  - K.3.5.3.3 The printf_s function (p: 432)\n  - K.3.5.3.5 The snprintf_s function (p: 432-433)\n  - K.3.5.3.6 The sprintf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.1 The fprintf function (p: 309-316)\n  - 7.21.6.3 The printf function (p: 324)\n  - 7.21.6.5 The snprintf function (p: 325)\n  - 7.21.6.6 The sprintf function (p: 325-326)\n  - K.3.5.3.1 The fprintf_s function (p: 591)\n  - K.3.5.3.3 The printf_s function (p: 593-594)\n  - K.3.5.3.5 The snprintf_s function (p: 594-595)\n  - K.3.5.3.6 The sprintf_s function (p: 595-596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.1 The fprintf function (p: 274-282)\n  - 7.19.6.3 The printf function (p: 290)\n  - 7.19.6.5 The snprintf function (p: 290-291)\n  - 7.19.6.6 The sprintf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.1 The fprintf function\n  - 4.9.6.3 The printf function\n  - 4.9.6.5 The sprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fprintf](https://en.cppreference.com/w/c/io/fprintf)"
- name: fprintf_s
  summary: 'Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:'
  description: "# printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:\n\n1) Writes the results to the output stream [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to the output stream `stream`.\n\n3) Writes the results to a character string `buffer`. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz` - 1 characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `stream` or `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `sprintf_s` only), the string to be stored in `buffer` (including the trailing null) would exceed `bufsz`\n\nAs with all bounds-checked functions, `printf_s` , `fprintf_s`, `sprintf_s`, and `snprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a character string to write to                                                                                                                                                                                                                                                                                                                                                                                                |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                      |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) number of characters transmitted to the output stream or negative value if an output error or an encoding error (for string and character conversion specifiers) occurred\n\n3) number of characters written to `buffer` (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n4) number of characters (not including the terminating null character) which would have been written to `buffer` if `bufsz` was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nThe C standard and [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) specify that the behavior of `sprintf` and its variants is undefined when an argument overlaps with the destination buffer. Example:\n\n```\nsprintf(dst, \"%s and %s\", dst, t); // <- broken: undefined behavior\n```\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) that [`errno`](../error/errno \"c/error/errno\") is set on error. It also specifies additional conversion specifications, most notably support for argument reordering (`n$` immediately after `%` indicates `n`^(th) argument).\n\nCalling `snprintf` with zero `bufsz` and null pointer for `buffer` is useful to determine the necessary buffer size to contain the output:\n\n```\nconst char fmt[] = \"sqrt(2) = %f\";\nint sz = snprintf(NULL, 0, fmt, sqrt(2));\nchar buf[sz + 1]; // note +1 for terminating null byte\nsnprintf(buf, sizeof buf, fmt, sqrt(2));\n```\n\n`snprintf_s`, just like `snprintf`, but unlike `sprintf_s`, will truncate the output to fit in `bufsz-1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n \nint main(void)\n{\n    const char* s = \"Hello\";\n    printf(\"Strings:\\n\"); // same as puts(\"Strings\");\n    printf(\" padding:\\n\");\n    printf(\"\\t[%10s]\\n\", s);\n    printf(\"\\t[%-10s]\\n\", s);\n    printf(\"\\t[%*s]\\n\", 10, s);\n    printf(\" truncating:\\n\");\n    printf(\"\\t%.4s\\n\", s);\n    printf(\"\\t%.*s\\n\", 3, s);\n \n    printf(\"Characters:\\t%c %%\\n\", 'A');\n \n    printf(\"Integers:\\n\");\n    printf(\"\\tDecimal:\\t%i %d %.6i %i %.0i %+i %i\\n\",\n                         1, 2,   3, 0,   0,  4,-4);\n    printf(\"\\tHexadecimal:\\t%x %x %X %#x\\n\", 5, 10, 10, 6);\n    printf(\"\\tOctal:\\t\\t%o %#o %#o\\n\", 10, 10, 4);\n \n    printf(\"Floating point:\\n\");\n    printf(\"\\tRounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    printf(\"\\tPadding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    printf(\"\\tScientific:\\t%E %e\\n\", 1.5, 1.5);\n    printf(\"\\tHexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n    printf(\"\\tSpecial values:\\t0/0=%g 1/0=%g\\n\", 0.0/0.0, 1.0/0.0);\n \n    printf(\"Fixed-width types:\\n\");\n    printf(\"\\tLargest 32-bit value is %\" PRIu32 \" or %#\" PRIx32 \"\\n\",\n                                     UINT32_MAX,     UINT32_MAX );\n}\n```\n\nPossible output:\n\n```\nStrings:\n padding:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n truncating:\n        Hell\n        Hel\nCharacters:        A %\nIntegers:\n        Decimal:        1 2 000003 0  +4 -4\n        Hexadecimal:        5 a A 0x6\n        Octal:                12 012 04\nFloating point:\n        Rounding:        1.500000 2 1.30000000000000004440892098500626\n        Padding:        01.50 1.50  1.50\n        Scientific:        1.500000E+00 1.500000e+00\n        Hexadecimal:        0x1.8p+0 0X1.8P+0\n        Special values:        0/0=-nan 1/0=inf\nFixed-width types:\n        Largest 32-bit value is 4294967295 or 0xffffffff\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.1 The fprintf function (p: 225-230)\n  - 7.21.6.3 The printf function (p: 236)\n  - 7.21.6.5 The snprintf function (p: 237)\n  - 7.21.6.6 The sprintf function (p: 237)\n  - K.3.5.3.1 The fprintf_s function (p: 430)\n  - K.3.5.3.3 The printf_s function (p: 432)\n  - K.3.5.3.5 The snprintf_s function (p: 432-433)\n  - K.3.5.3.6 The sprintf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.1 The fprintf function (p: 309-316)\n  - 7.21.6.3 The printf function (p: 324)\n  - 7.21.6.5 The snprintf function (p: 325)\n  - 7.21.6.6 The sprintf function (p: 325-326)\n  - K.3.5.3.1 The fprintf_s function (p: 591)\n  - K.3.5.3.3 The printf_s function (p: 593-594)\n  - K.3.5.3.5 The snprintf_s function (p: 594-595)\n  - K.3.5.3.6 The sprintf_s function (p: 595-596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.1 The fprintf function (p: 274-282)\n  - 7.19.6.3 The printf function (p: 290)\n  - 7.19.6.5 The snprintf function (p: 290-291)\n  - 7.19.6.6 The sprintf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.1 The fprintf function\n  - 4.9.6.3 The printf function\n  - 4.9.6.5 The sprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fprintf](https://en.cppreference.com/w/c/io/fprintf)"
- name: fputc
  summary: Writes a character ch to the given output stream stream
  description: "# fputc, putc\n\n[TABLE]\n\nWrites a character `ch` to the given output stream `stream`. `putc()` may be implemented as a macro and evaluate `stream` more than once, so the corresponding argument should never be an expression with side effects.\n\nInternally, the character is converted to `unsigned char` just before being written.\n\n### Parameters\n\n|        |     |                         |\n|--------|-----|-------------------------|\n| ch     | \\-  | character to be written |\n| stream | \\-  | output stream           |\n\n### Return value\n\nOn success, returns the written character.\n\nOn failure, returns [`EOF`](../io \"c/io\") and sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`.\n\n### Example\n\nShows `putc` with error checking\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int ret_code = 0;\n    for (char c = 'a'; (ret_code != EOF) && (c != 'z'); c++)\n        ret_code = putc(c, stdout);\n \n    // Test whether EOF was reached.\n    if (ret_code == EOF && ferror(stdout))\n    {\n        perror(\"putc()\");\n        fprintf(stderr, \"putc() failed in file %s at line # %d\\n\",\n                __FILE__, __LINE__ - 7);\n        exit(EXIT_FAILURE);\n    }\n    putc('\\n', stdout);\n \n    return EXIT_SUCCESS;\n}\n```\n\nOutput:\n\n```\nabcdefghijklmnopqrstuvwxy\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.7.3 The fputc function (p: TBD)\n  - 7.21.7.7 The putc function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.7.3 The fputc function (p: TBD)\n  - 7.21.7.7 The putc function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.7.3 The fputc function (p: 331)\n  - 7.21.7.7 The putc function (p: 333)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.3 The fputc function (p: 297)\n  - 7.19.7.8 The putc function (p: 299)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.3 The fputc function\n  - 4.9.7.8 The putc function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fputc](https://en.cppreference.com/w/c/io/fputc)"
- name: fputs
  summary: Writes every character from the null-terminated string str to the output stream stream, as if by repeatedly executing fputc
  description: "# fputs\n\n[TABLE]\n\nWrites every character from the null-terminated string `str` to the output stream `stream`, as if by repeatedly executing [`fputc`](fputc \"c/io/fputc\").\n\nThe terminating null character from `str` is not written.\n\n### Parameters\n\n|        |     |                                                |\n|--------|-----|------------------------------------------------|\n| str    | \\-  | null-terminated character string to be written |\n| stream | \\-  | output stream                                  |\n\n### Return value\n\nOn success, returns a non-negative value\n\nOn failure, returns [`EOF`](../io \"c/io\") and sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`.\n\n### Notes\n\nThe related function [`puts`](puts \"c/io/puts\") appends a newline character to the output, while `fputs` writes the string unmodified.\n\nDifferent implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant such as zero.\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    int rc = fputs(\"Hello World\", stdout);\n \n    if (rc == EOF)\n       perror(\"fputs()\"); // POSIX requires that errno is set\n}\n```\n\nOutput:\n\n```\nHello World\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.7.4 The fputs function (p: 331-332)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.4 The fputs function (p: 297)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.4 The fputs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fputs](https://en.cppreference.com/w/c/io/fputs)"
- name: fputwc
  summary: Writes a wide character ch to the given output stream stream
  description: "# fputwc, putwc\n\n[TABLE]\n\nWrites a wide character `ch` to the given output stream `stream`.\n\n2) May be implemented as a macro and may evaluate `stream` more than once.\n\n### Parameters\n\n|        |     |                              |\n|--------|-----|------------------------------|\n| ch     | \\-  | wide character to be written |\n| stream | \\-  | the output stream            |\n\n### Return value\n\nReturns a copy of `ch` on success.\n\nOn failure, returns `WEOF` and sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`.\n\nIf an encoding error occurred, additionally sets [`errno`](../error/errno \"c/error/errno\") to [`EILSEQ`](../error/errno_macros \"c/error/errno macros\").\n\n### Example\n\n```\n#include <errno.h>\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    errno = 0;\n    if (fputwc(L'🍌', stdout) == WEOF)\n    {\n        if (errno == EILSEQ)\n            puts(\"Encoding error in fputwc.\");\n        else\n            puts(\"I/O error in fputwc.\");\n        return EXIT_FAILURE;\n    }\n}\n```\n\nPossible output:\n\n```\n🍌\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.31.3.3 The fputwc function (p: 430)\n  - 7.31.3.8 The putwc function (p: 431-432)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.3.3 The fputwc function (p: 308)\n  - 7.29.3.8 The putwc function (p: 310)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.3.3 The fputwc function (p: 422-423)\n  - 7.29.3.8 The putwc function (p: 424)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.3.3 The fputwc function (p: 368)\n  - 7.24.3.8 The putwc function (p: 370)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fputwc](https://en.cppreference.com/w/c/io/fputwc)"
- name: fputws
  summary: Writes every character from the null-terminated wide string str to the output stream stream, as if by repeatedly executing fputwc
  description: "# fputws\n\n[TABLE]\n\nWrites every character from the null-terminated wide string `str` to the output stream `stream`, as if by repeatedly executing [`fputwc`](fputwc \"c/io/fputwc\").\n\nThe terminating null wide character from `str` is not written.\n\n### Parameters\n\n|        |     |                                           |\n|--------|-----|-------------------------------------------|\n| str    | \\-  | null-terminated wide string to be written |\n| stream | \\-  | output stream                             |\n\n### Return value\n\nOn success, returns a non-negative value\n\nOn failure, returns [`EOF`](../io \"c/io\") and sets the *error* indicator (see [`ferror`](ferror \"c/io/ferror\")) on `stream`.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    int rc = fputws(L\"御休みなさい\", stdout);\n \n    if (rc == EOF)\n       perror(\"fputws()\"); // POSIX requires that errno is set\n}\n```\n\nOutput:\n\n```\n御休みなさい\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.3.4 The fputws function (p: 423)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.3.4 The fputws function (p: 368)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fputws](https://en.cppreference.com/w/c/io/fputws)"
- name: fread
  summary: Reads up to count objects into the array buffer from the given input stream stream as if by calling fgetc size times for each object, and storing the results, in the order obtained, into the successive positions of buffer, which is reinterpreted as an array of unsigned char
  description: "# fread\n\n[TABLE]\n\nReads up to `count` objects into the array `buffer` from the given input stream `stream` as if by calling [`fgetc`](fgetc \"c/io/fgetc\") `size` times for each object, and storing the results, in the order obtained, into the successive positions of `buffer`, which is reinterpreted as an array of `unsigned char`. The file position indicator for the stream is advanced by the number of characters read.\n\nIf an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.\n\n### Parameters\n\n|        |     |                                                        |\n|--------|-----|--------------------------------------------------------|\n| buffer | \\-  | pointer to the array where the read objects are stored |\n| size   | \\-  | size of each object in bytes                           |\n| count  | \\-  | the number of the objects to be read                   |\n| stream | \\-  | the stream to read                                     |\n\n### Return value\n\nNumber of objects read successfully, which may be less than `count` if an error or end-of-file condition occurs.\n\nIf `size` or `count` is zero, `fread` returns zero and performs no other action.\n\n`fread` does not distinguish between end-of-file and error, and callers must use [`feof`](feof \"c/io/feof\") and [`ferror`](ferror \"c/io/ferror\") to determine which occurred.\n\n### Example\n\n```\n#include <stdio.h>\n \nenum { SIZE = 5 };\n \nint main(void)\n{\n    const double a[SIZE] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    printf(\"Array has size %ld bytes, element size: %ld\\n\", sizeof a, sizeof *a);\n    FILE *fp = fopen(\"test.bin\", \"wb\"); // must use binary mode\n    fwrite(a, sizeof *a, SIZE, fp); // writes an array of doubles\n    fclose(fp);\n \n    double b[SIZE];\n    fp = fopen(\"test.bin\",\"rb\");\n    const size_t ret_code = fread(b, sizeof b[0], SIZE, fp); // reads an array of doubles\n    if (ret_code == SIZE)\n    {\n        printf(\"Array at %p read successfully, contents:\\n\", (void*)&a);\n        for (int n = 0; n != SIZE; ++n)\n            printf(\"%f \", b[n]);\n        putchar('\\n');\n    }\n    else // error handling\n    {\n        if (feof(fp))\n            printf(\"Error reading test.bin: unexpected end of file\\n\");\n        else if (ferror(fp))\n            perror(\"Error reading test.bin\");\n    }\n \n    fclose(fp);\n}\n```\n\nPossible output:\n\n```\nArray has size 40 bytes, element size: 8\nArray at 0x1337f00d6960 read successfully, contents:\n1.000000 2.000000 3.000000 4.000000 5.000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.8.1 The fread function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.8.1 The fread function (p: 243-244)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.8.1 The fread function (p: 335)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.8.1 The fread function (p: 301)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.8.1 The fread function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fread](https://en.cppreference.com/w/c/io/fread)"
- name: free
  summary: Deallocates the space previously allocated by malloc(), calloc(), aligned_alloc(),(since C11) or realloc()
  description: "# free\n\n[TABLE]\n\nDeallocates the space previously allocated by [`malloc()`](malloc \"c/memory/malloc\"), [`calloc()`](calloc \"c/memory/calloc\"), `aligned_alloc()`,(since C11) or [`realloc()`](realloc \"c/memory/realloc\").\n\nIf `ptr` is a null pointer, the function does nothing.\n\nThe behavior is undefined if the value of `ptr` does not equal a value returned earlier by [`malloc()`](malloc \"c/memory/malloc\"), [`calloc()`](calloc \"c/memory/calloc\"), [`realloc()`](realloc \"c/memory/realloc\"), or `aligned_alloc()`(since C11).\n\nThe behavior is undefined if the memory area referred to by `ptr` has already been deallocated, that is, `free()`, `free_sized()`, `free_aligned_sized()`(since C23), or [`realloc()`](realloc \"c/memory/realloc\") has already been called with `ptr` as the argument and no calls to [`malloc()`](malloc \"c/memory/malloc\"), [`calloc()`](calloc \"c/memory/calloc\"), [`realloc()`](realloc \"c/memory/realloc\"), or `aligned_alloc()`(since C11) resulted in a pointer equal to `ptr` afterwards.\n\nThe behavior is undefined if after `free()` returns, an access is made through the pointer `ptr` (unless another allocation function happened to result in a pointer value equal to `ptr`).\n\n[TABLE]\n\n### Parameters\n\n|     |     |                                     |\n|-----|-----|-------------------------------------|\n| ptr | \\-  | pointer to the memory to deallocate |\n\n### Return value\n\n(none)\n\n### Notes\n\nThe function accepts (and does nothing with) the null pointer to reduce the amount of special-casing. Whether allocation succeeds or not, the pointer returned by an allocation function can be passed to `free()`.\n\n### Example\n\n```\n#include <stdlib.h>\n \nint main(void)\n{\n    int *p1 = malloc(10*sizeof *p1);\n    free(p1); // every allocated pointer must be freed\n \n    int *p2 = calloc(10, sizeof *p2);\n    int *p3 = realloc(p2, 1000*sizeof *p3);\n    if(p3) // p3 not null means p2 was freed by realloc\n       free(p3);\n    else // p3 null means p2 was not freed\n       free(p2);\n}\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.24.3.3 The free function\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.3.3 The free function (p: 254)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.3.3 The free function (p: 348)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.3.2 The free function (p: 313)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.3.2 The free function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/memory/free](https://en.cppreference.com/w/c/memory/free)"
- name: free_aligned_sized
  summary: If ptr is a null pointer or the result obtained from a call to aligned_alloc, where alignment is equal to the requested allocation alignment and size is equal to the requested allocation size, this function is equivalent to free(ptr)
  description: "# free_aligned_sized\n\n[TABLE]\n\nIf `ptr` is a null pointer or the result obtained from a call to `aligned_alloc`, where `alignment` is equal to the requested allocation alignment and `size` is equal to the requested allocation size, this function is equivalent to [`free`](http://en.cppreference.com/w/c/memory/free)`(``ptr``)`. Otherwise, the behavior is undefined.\n\nNote: The result of an [`malloc`](malloc \"c/memory/malloc\"), [`calloc`](calloc \"c/memory/calloc\"), or [`realloc`](realloc \"c/memory/realloc\") call may not be passed to `free_aligned_sized`.\n\n### Parameters\n\n|           |     |                                     |\n|-----------|-----|-------------------------------------|\n| ptr       | \\-  | pointer to the memory to deallocate |\n| alignment | \\-  | alignment of memory to deallocate   |\n| size      | \\-  | size of memory to deallocate        |\n\n### Return value\n\n(none)\n\n### Example\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/memory/free_aligned_sized](https://en.cppreference.com/w/c/memory/free_aligned_sized)"
- name: free_sized
  summary: Deallocates the space previously allocated by malloc(), calloc(), or realloc() (but not aligned_alloc())
  description: "# free_sized\n\n[TABLE]\n\nDeallocates the space previously allocated by [`malloc()`](malloc \"c/memory/malloc\"), [`calloc()`](calloc \"c/memory/calloc\"), or [`realloc()`](realloc \"c/memory/realloc\") (but not `aligned_alloc()`).\n\n### Parameters\n\n|      |     |                                                            |\n|------|-----|------------------------------------------------------------|\n| ptr  | \\-  | pointer to the memory to deallocate                        |\n| size | \\-  | size of memory previously passed to an allocation function |\n\n### Return value\n\n(none)\n\n### Notes\n\n### Possible implementation\n\n```\nvoid free_sized(void* ptr, size_t /*size*/)\n{\n    free(ptr);\n}\n```\n\n### Example\n\n```\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n \ntypedef struct\n{\n    size_t size;     // current number of elements\n    size_t capacity; // reserved number of elements\n    void** data;\n} PtrVector;\n \nPtrVector vector_create(size_t initial_capacity)\n{\n    PtrVector ret =\n    {\n        .capacity = initial_capacity,\n        .data = (void**) malloc(initial_capacity * sizeof(void*))\n    };\n    return ret;\n}\n \nvoid vector_delete(PtrVector* self)\n{\n    free_sized(self->data, self->capacity * sizeof(void*));\n}\n \nvoid vector_push_back(PtrVector* self, void* value)\n{\n    if (self->size == self->capacity)\n    {\n        self->capacity *= 2;\n        self->data = (void**) realloc(self->data, self->capacity * sizeof(void*));\n    }\n    self->data[self->size++] = value;\n}\n \nint main()\n{\n    int data = 42;\n    float pi = 3.141592f;\n    PtrVector v = vector_create(8);\n    vector_push_back(&v, &data);\n    vector_push_back(&v, &pi);\n    printf(\"data[0] = %i\\n\", *(int*)v.data[0]);\n    printf(\"data[1] = %f\\n\", *(float*)v.data[1]);\n    vector_delete(&v);\n}\n```\n\nOutput:\n\n```\ndata[0] = 42\ndata[1] = 3.141592\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.24.3.4 The free_sized function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/memory/free_sized](https://en.cppreference.com/w/c/memory/free_sized)"
- name: freopen
  summary: freopen is the only way to change the narrow/wide orientation of a stream once it has been established by an I/O operation or by fwide
  description: "# freopen, freopen_s\n\n[TABLE]\n\n1) First, attempts to close the file associated with `stream`, ignoring any errors. Then, if `filename` is not null, attempts to open the file specified by `filename` using `mode` as if by [`fopen`](fopen \"c/io/fopen\"), and associates that file with the file stream pointed to by `stream`. If `filename` is a null pointer, then the function attempts to reopen the file that is already associated with `stream` (it is implementation defined which mode changes are allowed in this case).\n\n2) Same as (1), except that `mode` is treated as in `fopen_s` and that the pointer to the file stream is written to `newstreamptr` and the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `newstreamptr` is a null pointer\n- `stream` is a null pointer\n- `mode` is a null pointer\n\nAs with all bounds-checked functions, `freopen_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|              |     |                                                                                         |\n|--------------|-----|-----------------------------------------------------------------------------------------|\n| filename     | \\-  | file name to associate the file stream to                                               |\n| mode         | \\-  | null-terminated character string determining new [file access mode](#File_access_flags) |\n| stream       | \\-  | the file stream to modify                                                               |\n| newstreamptr | \\-  | pointer to a pointer where the function stores the result (an out-parameter)            |\n\n### File access flags\n\n[TABLE]\n\n### Return value\n\n1) A copy of the value of `stream` on success, null pointer on failure.\n\n2) zero on success (and a copy of the value of `stream` is written to `*newstreamptr`, non-zero on error (and null pointer is written to `*newstreamptr` unless `newstreamptr` is itself a null pointer).\n\n### Notes\n\n`freopen` is the only way to change the narrow/wide orientation of a stream once it has been established by an I/O operation or by `fwide`.\n\nMicrosoft CRT version of `freopen` does not support any mode changes when `filename` is a null pointer and treats this as an error (see [documentation](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/freopen-wfreopen)). A possible workaround is the non-standard function [`_setmode()`](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setmode).\n\n### Example\n\nThe following code redirects `stdout` to a file.\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    puts(\"stdout is printed to console\");\n    if (freopen(\"redir.txt\", \"w\", stdout) == NULL)\n    {\n       perror(\"freopen() failed\");\n       return EXIT_FAILURE;\n    }\n    puts(\"stdout is redirected to a file\"); // this is written to redir.txt\n    fclose(stdout);\n    return EXIT_SUCCESS;\n}\n```\n\nOutput:\n\n```\nstdout is printed to console\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.5.4 The freopen function (p: 224-225)\n  - K.3.5.2.2 The freopen_s function (p: 429-430)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.5.4 The freopen function (p: 307)\n  - K.3.5.2.2 The freopen_s function (p: 590)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.5.4 The freopen function (p: 272-273)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.5.4 The freopen function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/freopen](https://en.cppreference.com/w/c/io/freopen)"
- name: freopen_s
  summary: freopen is the only way to change the narrow/wide orientation of a stream once it has been established by an I/O operation or by fwide
  description: "# freopen, freopen_s\n\n[TABLE]\n\n1) First, attempts to close the file associated with `stream`, ignoring any errors. Then, if `filename` is not null, attempts to open the file specified by `filename` using `mode` as if by [`fopen`](fopen \"c/io/fopen\"), and associates that file with the file stream pointed to by `stream`. If `filename` is a null pointer, then the function attempts to reopen the file that is already associated with `stream` (it is implementation defined which mode changes are allowed in this case).\n\n2) Same as (1), except that `mode` is treated as in `fopen_s` and that the pointer to the file stream is written to `newstreamptr` and the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `newstreamptr` is a null pointer\n- `stream` is a null pointer\n- `mode` is a null pointer\n\nAs with all bounds-checked functions, `freopen_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|              |     |                                                                                         |\n|--------------|-----|-----------------------------------------------------------------------------------------|\n| filename     | \\-  | file name to associate the file stream to                                               |\n| mode         | \\-  | null-terminated character string determining new [file access mode](#File_access_flags) |\n| stream       | \\-  | the file stream to modify                                                               |\n| newstreamptr | \\-  | pointer to a pointer where the function stores the result (an out-parameter)            |\n\n### File access flags\n\n[TABLE]\n\n### Return value\n\n1) A copy of the value of `stream` on success, null pointer on failure.\n\n2) zero on success (and a copy of the value of `stream` is written to `*newstreamptr`, non-zero on error (and null pointer is written to `*newstreamptr` unless `newstreamptr` is itself a null pointer).\n\n### Notes\n\n`freopen` is the only way to change the narrow/wide orientation of a stream once it has been established by an I/O operation or by `fwide`.\n\nMicrosoft CRT version of `freopen` does not support any mode changes when `filename` is a null pointer and treats this as an error (see [documentation](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/freopen-wfreopen)). A possible workaround is the non-standard function [`_setmode()`](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setmode).\n\n### Example\n\nThe following code redirects `stdout` to a file.\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    puts(\"stdout is printed to console\");\n    if (freopen(\"redir.txt\", \"w\", stdout) == NULL)\n    {\n       perror(\"freopen() failed\");\n       return EXIT_FAILURE;\n    }\n    puts(\"stdout is redirected to a file\"); // this is written to redir.txt\n    fclose(stdout);\n    return EXIT_SUCCESS;\n}\n```\n\nOutput:\n\n```\nstdout is printed to console\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.5.4 The freopen function (p: 224-225)\n  - K.3.5.2.2 The freopen_s function (p: 429-430)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.5.4 The freopen function (p: 307)\n  - K.3.5.2.2 The freopen_s function (p: 590)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.5.4 The freopen function (p: 272-273)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.5.4 The freopen function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/freopen](https://en.cppreference.com/w/c/io/freopen)"
- name: frexp
  summary: If arg is zero, returns zero and stores zero in *exp
  description: "# frexp, frexpf, frexpl\n\n[TABLE]\n\n1-3) Decomposes given floating point value `x` into a normalized fraction and an integral power of two.\n\n4) Type-generic macro: If `arg` has type `long double`, `frexpl` is called. Otherwise, if `arg` has integer type or the type `double`, `frexp` is called. Otherwise, `frexpf` is called, respectively.\n\n### Parameters\n\n|     |     |                                                   |\n|-----|-----|---------------------------------------------------|\n| arg | \\-  | floating point value                              |\n| exp | \\-  | pointer to integer value to store the exponent to |\n\n### Return value\n\nIf `arg` is zero, returns zero and stores zero in `*exp`.\n\nOtherwise (if `arg` is not zero), if no errors occur, returns the value `x` in the range `(-1;-0.5], [0.5; 1)` and stores an integer value in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp) such that x×2^((\\*exp))=arg.\n\nIf the value to be stored in `*exp` is outside the range of `int`, the behavior is unspecified.\n\nIf `arg` is not a floating-point number, the behavior is unspecified.\n\n### Error handling\n\nThis function is not subject to any errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `arg` is ±0, it is returned, unmodified, and `0` is stored in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n- If `arg` is ±∞, it is returned, and an unspecified value is stored in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n- If `arg` is NaN, NaN is returned, and an unspecified value is stored in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n- No floating-point exceptions are raised.\n- If [`FLT_RADIX`](../../types/limits \"c/types/limits\") is 2 (or a power of 2), the returned value is exact, [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\nOn a binary system (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `frexp` may be implemented as\n\n```\n{\n    *exp = (value == 0) ? 0 : (int)(1 + logb(value));\n    return scalbn(value, -(*exp));\n}\n```\n\nThe function `frexp`, together with its dual, [`ldexp`](ldexp \"c/numeric/math/ldexp\"), can be used to manipulate the representation of a floating-point number without direct bit manipulations.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.0f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = ilogb(f);\n    printf(\"logb()/ilogb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.4 The frexp functions (p: 243)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.4 The frexp functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.4 The frexp functions (p: 224)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.4 The frexp functions (p: 458)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.2 The frexp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/frexp](https://en.cppreference.com/w/c/numeric/math/frexp)"
- name: frexpf
  summary: If arg is zero, returns zero and stores zero in *exp
  description: "# frexp, frexpf, frexpl\n\n[TABLE]\n\n1-3) Decomposes given floating point value `x` into a normalized fraction and an integral power of two.\n\n4) Type-generic macro: If `arg` has type `long double`, `frexpl` is called. Otherwise, if `arg` has integer type or the type `double`, `frexp` is called. Otherwise, `frexpf` is called, respectively.\n\n### Parameters\n\n|     |     |                                                   |\n|-----|-----|---------------------------------------------------|\n| arg | \\-  | floating point value                              |\n| exp | \\-  | pointer to integer value to store the exponent to |\n\n### Return value\n\nIf `arg` is zero, returns zero and stores zero in `*exp`.\n\nOtherwise (if `arg` is not zero), if no errors occur, returns the value `x` in the range `(-1;-0.5], [0.5; 1)` and stores an integer value in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp) such that x×2^((\\*exp))=arg.\n\nIf the value to be stored in `*exp` is outside the range of `int`, the behavior is unspecified.\n\nIf `arg` is not a floating-point number, the behavior is unspecified.\n\n### Error handling\n\nThis function is not subject to any errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `arg` is ±0, it is returned, unmodified, and `0` is stored in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n- If `arg` is ±∞, it is returned, and an unspecified value is stored in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n- If `arg` is NaN, NaN is returned, and an unspecified value is stored in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n- No floating-point exceptions are raised.\n- If [`FLT_RADIX`](../../types/limits \"c/types/limits\") is 2 (or a power of 2), the returned value is exact, [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\nOn a binary system (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `frexp` may be implemented as\n\n```\n{\n    *exp = (value == 0) ? 0 : (int)(1 + logb(value));\n    return scalbn(value, -(*exp));\n}\n```\n\nThe function `frexp`, together with its dual, [`ldexp`](ldexp \"c/numeric/math/ldexp\"), can be used to manipulate the representation of a floating-point number without direct bit manipulations.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.0f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = ilogb(f);\n    printf(\"logb()/ilogb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.4 The frexp functions (p: 243)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.4 The frexp functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.4 The frexp functions (p: 224)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.4 The frexp functions (p: 458)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.2 The frexp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/frexp](https://en.cppreference.com/w/c/numeric/math/frexp)"
- name: frexpl
  summary: If arg is zero, returns zero and stores zero in *exp
  description: "# frexp, frexpf, frexpl\n\n[TABLE]\n\n1-3) Decomposes given floating point value `x` into a normalized fraction and an integral power of two.\n\n4) Type-generic macro: If `arg` has type `long double`, `frexpl` is called. Otherwise, if `arg` has integer type or the type `double`, `frexp` is called. Otherwise, `frexpf` is called, respectively.\n\n### Parameters\n\n|     |     |                                                   |\n|-----|-----|---------------------------------------------------|\n| arg | \\-  | floating point value                              |\n| exp | \\-  | pointer to integer value to store the exponent to |\n\n### Return value\n\nIf `arg` is zero, returns zero and stores zero in `*exp`.\n\nOtherwise (if `arg` is not zero), if no errors occur, returns the value `x` in the range `(-1;-0.5], [0.5; 1)` and stores an integer value in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp) such that x×2^((\\*exp))=arg.\n\nIf the value to be stored in `*exp` is outside the range of `int`, the behavior is unspecified.\n\nIf `arg` is not a floating-point number, the behavior is unspecified.\n\n### Error handling\n\nThis function is not subject to any errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `arg` is ±0, it is returned, unmodified, and `0` is stored in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n- If `arg` is ±∞, it is returned, and an unspecified value is stored in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n- If `arg` is NaN, NaN is returned, and an unspecified value is stored in `*`[`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n- No floating-point exceptions are raised.\n- If [`FLT_RADIX`](../../types/limits \"c/types/limits\") is 2 (or a power of 2), the returned value is exact, [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\nOn a binary system (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `frexp` may be implemented as\n\n```\n{\n    *exp = (value == 0) ? 0 : (int)(1 + logb(value));\n    return scalbn(value, -(*exp));\n}\n```\n\nThe function `frexp`, together with its dual, [`ldexp`](ldexp \"c/numeric/math/ldexp\"), can be used to manipulate the representation of a floating-point number without direct bit manipulations.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.0f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = ilogb(f);\n    printf(\"logb()/ilogb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.4 The frexp functions (p: 243)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.4 The frexp functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.4 The frexp functions (p: 224)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.4 The frexp functions (p: 458)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.2 The frexp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/frexp](https://en.cppreference.com/w/c/numeric/math/frexp)"
- name: fscanf
  summary: Reads data from a variety of sources, interprets it according to format and stores the results into given locations
  description: "# scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s\n\n[TABLE]\n\nReads data from a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) reads the data from file stream `stream`\n\n3) reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%c` into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `scanf_s` , `fscanf_s`, and `sscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                           |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or [`EOF`](../io \"c/io\") if input failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Complexity\n\nNot guaranteed. Notably, some implementations of `sscanf` are O(N), where `N ``=`` `[`strlen`](http://en.cppreference.com/w/c/string/byte/strlen)`(``buffer``)` [\\[1\\]](https://sourceware.org/bugzilla/show_bug.cgi?id=17577).\n\n### Notes\n\nBecause most conversion specifiers first consume all consecutive whitespace, code such as\n\n```\nscanf(\"%d\", &a);\nscanf(\"%d\", &b);\n```\n\nwill read two integers that are entered on different lines (second `%d` will consume the newline left over by the first) or on the same line, separated by spaces or tabs (second `%d` will consume the spaces or tabs). The conversion specifiers that do not consume leading whitespace, such as `%c`, can be made to do so by using a whitespace character in the format string:\n\n```\nscanf(\"%d\", &a);\nscanf(\" %c\", &c); // consume all consecutive whitespace after %d, then read a char\n```\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stddef.h>\n#include <locale.h>\n \nint main(void)\n{\n    int i, j;\n    float x, y;\n    char str1[10], str2[4];\n    wchar_t warr[2];\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    char input[] = \"25 54.32E-1 Thompson 56789 0123 56ß水\";\n    /* parse as follows:\n       %d: an integer\n       %f: a floating-point value\n       %9s: a string of at most 9 non-whitespace characters\n       %2d: two-digit integer (digits 5 and 6)\n       %f:  a floating-point value (digits 7, 8, 9)\n       %*d: an integer which isn't stored anywhere\n       ' ': all consecutive whitespace\n       %3[0-9]: a string of at most 3 decimal digits (digits 5 and 6)\n       %2lc: two wide characters, using multibyte to wide conversion  */\n    int ret = sscanf(input, \"%d%f%9s%2d%f%*d %3[0-9]%2lc\",\n                     &i, &x, str1, &j, &y, str2, warr);\n \n    printf(\"Converted %d fields:\\n\"\n           \"i = %d\\n\"\n           \"x = %f\\n\"\n           \"str1 = %s\\n\"\n           \"j = %d\\n\"\n           \"y = %f\\n\"\n           \"str2 = %s\\n\"\n           \"warr[0] = U+%x\\n\"\n           \"warr[1] = U+%x\\n\",\n           ret, i, x, str1, j, y, str2, warr[0], warr[1]);\n \n#ifdef __STDC_LIB_EXT1__\n    int n = sscanf_s(input, \"%d%f%s\", &i, &x, str1, (rsize_t)sizeof str1);\n    // writes 25 to i, 5.432 to x, the 9 bytes \"Thompson\\0\" to str1, and 3 to n.\n#endif\n}\n```\n\nPossible output:\n\n```\nConverted 7 fields:\ni = 25\nx = 5.432000\nstr1 = Thompson\nj = 56\ny = 789.000000\nstr2 = 56\nwarr[0] = U+df\nwarr[1] = U+6c34\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.2 The fscanf function (p: 231-236)\n  - 7.21.6.4 The scanf function (p: 236-237)\n  - 7.21.6.7 The sscanf function (p: 238-239)\n  - K.3.5.3.2 The fscanf_s function (p: 430-431)\n  - K.3.5.3.4 The scanf_s function (p: 432)\n  - K.3.5.3.7 The sscanf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.2 The fscanf function (p: 317-324)\n  - 7.21.6.4 The scanf function (p: 325)\n  - 7.21.6.7 The sscanf function (p: 326)\n  - K.3.5.3.2 The fscanf_s function (p: 592-593)\n  - K.3.5.3.4 The scanf_s function (p: 594)\n  - K.3.5.3.7 The sscanf_s function (p: 596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.2 The fscanf function (p: 282-289)\n  - 7.19.6.4 The scanf function (p: 290)\n  - 7.19.6.7 The sscanf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.2 The fscanf function\n  - 4.9.6.4 The scanf function\n  - 4.9.6.6 The sscanf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fscanf](https://en.cppreference.com/w/c/io/fscanf)"
- name: fscanf_s
  summary: Reads data from a variety of sources, interprets it according to format and stores the results into given locations
  description: "# scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s\n\n[TABLE]\n\nReads data from a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) reads the data from file stream `stream`\n\n3) reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%c` into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `scanf_s` , `fscanf_s`, and `sscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                           |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or [`EOF`](../io \"c/io\") if input failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Complexity\n\nNot guaranteed. Notably, some implementations of `sscanf` are O(N), where `N ``=`` `[`strlen`](http://en.cppreference.com/w/c/string/byte/strlen)`(``buffer``)` [\\[1\\]](https://sourceware.org/bugzilla/show_bug.cgi?id=17577).\n\n### Notes\n\nBecause most conversion specifiers first consume all consecutive whitespace, code such as\n\n```\nscanf(\"%d\", &a);\nscanf(\"%d\", &b);\n```\n\nwill read two integers that are entered on different lines (second `%d` will consume the newline left over by the first) or on the same line, separated by spaces or tabs (second `%d` will consume the spaces or tabs). The conversion specifiers that do not consume leading whitespace, such as `%c`, can be made to do so by using a whitespace character in the format string:\n\n```\nscanf(\"%d\", &a);\nscanf(\" %c\", &c); // consume all consecutive whitespace after %d, then read a char\n```\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stddef.h>\n#include <locale.h>\n \nint main(void)\n{\n    int i, j;\n    float x, y;\n    char str1[10], str2[4];\n    wchar_t warr[2];\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    char input[] = \"25 54.32E-1 Thompson 56789 0123 56ß水\";\n    /* parse as follows:\n       %d: an integer\n       %f: a floating-point value\n       %9s: a string of at most 9 non-whitespace characters\n       %2d: two-digit integer (digits 5 and 6)\n       %f:  a floating-point value (digits 7, 8, 9)\n       %*d: an integer which isn't stored anywhere\n       ' ': all consecutive whitespace\n       %3[0-9]: a string of at most 3 decimal digits (digits 5 and 6)\n       %2lc: two wide characters, using multibyte to wide conversion  */\n    int ret = sscanf(input, \"%d%f%9s%2d%f%*d %3[0-9]%2lc\",\n                     &i, &x, str1, &j, &y, str2, warr);\n \n    printf(\"Converted %d fields:\\n\"\n           \"i = %d\\n\"\n           \"x = %f\\n\"\n           \"str1 = %s\\n\"\n           \"j = %d\\n\"\n           \"y = %f\\n\"\n           \"str2 = %s\\n\"\n           \"warr[0] = U+%x\\n\"\n           \"warr[1] = U+%x\\n\",\n           ret, i, x, str1, j, y, str2, warr[0], warr[1]);\n \n#ifdef __STDC_LIB_EXT1__\n    int n = sscanf_s(input, \"%d%f%s\", &i, &x, str1, (rsize_t)sizeof str1);\n    // writes 25 to i, 5.432 to x, the 9 bytes \"Thompson\\0\" to str1, and 3 to n.\n#endif\n}\n```\n\nPossible output:\n\n```\nConverted 7 fields:\ni = 25\nx = 5.432000\nstr1 = Thompson\nj = 56\ny = 789.000000\nstr2 = 56\nwarr[0] = U+df\nwarr[1] = U+6c34\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.2 The fscanf function (p: 231-236)\n  - 7.21.6.4 The scanf function (p: 236-237)\n  - 7.21.6.7 The sscanf function (p: 238-239)\n  - K.3.5.3.2 The fscanf_s function (p: 430-431)\n  - K.3.5.3.4 The scanf_s function (p: 432)\n  - K.3.5.3.7 The sscanf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.2 The fscanf function (p: 317-324)\n  - 7.21.6.4 The scanf function (p: 325)\n  - 7.21.6.7 The sscanf function (p: 326)\n  - K.3.5.3.2 The fscanf_s function (p: 592-593)\n  - K.3.5.3.4 The scanf_s function (p: 594)\n  - K.3.5.3.7 The sscanf_s function (p: 596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.2 The fscanf function (p: 282-289)\n  - 7.19.6.4 The scanf function (p: 290)\n  - 7.19.6.7 The sscanf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.2 The fscanf function\n  - 4.9.6.4 The scanf function\n  - 4.9.6.6 The sscanf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fscanf](https://en.cppreference.com/w/c/io/fscanf)"
- name: fseek
  summary: Sets the file position indicator for the file stream stream to the value pointed to by offset
  description: "# fseek\n\n[TABLE]\n\nSets the file position indicator for the file stream `stream` to the value pointed to by `offset`.\n\nIf the `stream` is open in binary mode, the new position is exactly `offset` bytes measured from the beginning of the file if `origin` is [`SEEK_SET`](../io \"c/io\"), from the current file position if `origin` is [`SEEK_CUR`](../io \"c/io\"), and from the end of the file if `origin` is [`SEEK_END`](../io \"c/io\"). Binary streams are not required to support [`SEEK_END`](../io \"c/io\"), in particular if additional null bytes are output.\n\nIf the `stream` is open in text mode, the only supported values for `offset` are zero (which works with any `origin`) and a value returned by an earlier call to [`ftell`](ftell \"c/io/ftell\") on a stream associated with the same file (which only works with `origin` of [`SEEK_SET`](../io \"c/io\")).\n\nIf the `stream` is wide-oriented, the restrictions of both text and binary streams apply (result of [`ftell`](ftell \"c/io/ftell\") is allowed with [`SEEK_SET`](../io \"c/io\") and zero offset is allowed from [`SEEK_SET`](../io \"c/io\") and [`SEEK_CUR`](../io \"c/io\"), but not [`SEEK_END`](../io \"c/io\")).\n\nIn addition to changing the file position indicator, `fseek` undoes the effects of [`ungetc`](ungetc \"c/io/ungetc\") and clears the end-of-file status, if applicable.\n\nIf a read or write error occurs, the error indicator for the stream ([`ferror`](ferror \"c/io/ferror\")) is set and the file position is unaffected.\n\n### Parameters\n\n|        |     |                                                                                                                                                                  |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | file stream to modify                                                                                                                                            |\n| offset | \\-  | number of characters to shift the position relative to origin                                                                                                    |\n| origin | \\-  | position to which `offset` is added. It can have one of the following values: [`SEEK_SET`](../io \"c/io\"), [`SEEK_CUR`](../io \"c/io\"), [`SEEK_END`](../io \"c/io\") |\n\n### Return value\n\n`​0​` upon success, nonzero value otherwise.\n\n### Notes\n\nAfter seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.\n\nFor text streams, the only valid values of `offset` are `​0​` (applicable to any `origin`) and a value returned by an earlier call to [`ftell`](ftell \"c/io/ftell\") (only applicable to `SEEK_SET`).\n\nPOSIX allows seeking beyond the existing end of file. If an output is performed after this seek, any read from the gap will return zero bytes. Where supported by the filesystem, this creates a *sparse file*.\n\nPOSIX also requires that fseek first performs [`fflush`](fflush \"c/io/fflush\") if there are any unwritten data (but whether the shift state is restored is implementation-defined).\n\n### Example\n\n`fseek` with error checking:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    /* Prepare an array of double values. */\n    #define SIZE 5\n    double A[SIZE] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    /* Write array to a file. */\n    FILE * fp = fopen(\"test.bin\", \"wb\");\n    fwrite(A, sizeof(double), SIZE, fp);\n    fclose (fp);\n \n    /* Read the double values into array B. */\n    double B[SIZE];\n    fp = fopen(\"test.bin\", \"rb\");\n \n    /* Set the file position indicator in front of third double value. */\n    if (fseek(fp, sizeof(double) * 2L, SEEK_SET) != 0)\n    {\n        fprintf(stderr, \"fseek() failed in file %s at line # %d\\n\", __FILE__, __LINE__ - 2);\n        fclose(fp);\n        return EXIT_FAILURE;\n    }\n \n    int ret_code = fread(B, sizeof(double), 1, fp); /* read one double value  */\n    printf(\"ret_code == %d\\n\", ret_code);           /* print the number of values read */\n    printf(\"B[0] == %.1f\\n\", B[0]);                 /* print one value */\n \n    fclose(fp);\n    return EXIT_SUCCESS;\n}\n```\n\nPossible output:\n\n```\nret_code == 1\nB[0] == 3.0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.9.2 The fseek function (p: 245)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.9.2 The fseek function (p: 336-337)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.9.2 The fseek function (p: 302-303)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.9.2 The fseek function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fseek](https://en.cppreference.com/w/c/io/fseek)"
- name: fsetpos
  summary: Sets the file position indicator and the multibyte parsing state (if any) for the file stream stream according to the value pointed to by pos
  description: "# fsetpos\n\n[TABLE]\n\nSets the file position indicator and the multibyte parsing state (if any) for the file stream `stream` according to the value pointed to by `pos`.\n\nBesides establishing new parse state and position, a call to this function undoes the effects of [`ungetc`](ungetc \"c/io/ungetc\") and clears the end-of-file state, if it is set.\n\nIf a read or write error occurs, the error indicator ([`ferror`](ferror \"c/io/ferror\")) for the stream is set.\n\n### Parameters\n\n|        |     |                                                                                                     |\n|--------|-----|-----------------------------------------------------------------------------------------------------|\n| stream | \\-  | file stream to modify                                                                               |\n| pos    | \\-  | pointer to a [`fpos_t`](fpos_t \"c/io/fpos t\") object to use as new value of file position indicator |\n\n### Return value\n\n`​0​` upon success, nonzero value otherwise.\n\n### Notes\n\nAfter seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.\n\n### Example\n\nfsetpos with error checking\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    /* Prepare an array of f-p values. */\n    #define SIZE 5\n    double A[SIZE] = {1.,2.,3.,4.,5.};\n    /* Write array to a file. */\n    FILE * fp = fopen(\"test.bin\", \"wb\");\n    fwrite(A,sizeof(double),SIZE,fp);\n    fclose (fp);\n \n    /* Read the f-p values into array B. */\n    double B[SIZE];\n    fp = fopen(\"test.bin\",\"rb\");\n    fpos_t pos;\n    if (fgetpos(fp,&pos) != 0)      /* current position: start of file */\n    {\n       perror(\"fgetpos()\");\n       fprintf(stderr,\"fgetpos() failed in file %s at line # %d\\n\", __FILE__,__LINE__-3);\n       exit(EXIT_FAILURE);\n    }\n \n    int ret_code = fread(B,sizeof(double),1,fp);   /* read one f-p value */\n    /* current position: after reading one f-p value */\n    printf(\"%.1f; read count = %d\\n\", B[0], ret_code);   /* print one f-p value and ret_code */\n \n    if (fsetpos(fp,&pos) != 0)   /* reset current position to start of file */\n    {\n       if (ferror(fp))\n       {\n          perror(\"fsetpos()\");\n          fprintf(stderr,\"fsetpos() failed in file %s at line # %d\\n\", __FILE__,__LINE__-5);\n          exit(EXIT_FAILURE);\n       }\n    }\n \n    ret_code = fread(B,sizeof(double),1,fp);   /* reread first f-p value */\n    printf(\"%.1f; read count = %d\\n\", B[0], ret_code);   /* print one f-p value and ret_code */\n    fclose(fp);\n \n    return EXIT_SUCCESS; \n}\n```\n\nOutput:\n\n```\n1.0; read count = 1\n1.0; read count = 1\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.9.3 The fsetpos function (p: 337)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.9.3 The fsetpos function (p: 303)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.9.3 The fsetpos function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fsetpos](https://en.cppreference.com/w/c/io/fsetpos)"
- name: ftell
  summary: Returns the file position indicator for the file stream stream
  description: "# ftell\n\n[TABLE]\n\nReturns the file position indicator for the file stream `stream`.\n\nIf the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.\n\nIf the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to [`fseek()`](fseek \"c/io/fseek\").\n\n### Parameters\n\n|        |     |                        |\n|--------|-----|------------------------|\n| stream | \\-  | file stream to examine |\n\n### Return value\n\nFile position indicator on success or `-1L` if failure occurs.\n\nOn error, the `errno` variable is set to implementation-defined positive value.\n\n### Example\n\nDemonstrates `ftell()` with error checking. Writes then reads a few floating-point (FP) values to/from a file.\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \n/* If the condition is not met then exit the program with error message. */\nvoid check(_Bool condition, const char* func, int line)\n{\n    if (condition)\n        return;\n    perror(func);\n    fprintf(stderr, \"%s failed in file %s at line # %d\\n\", func, __FILE__, line - 1);\n    exit(EXIT_FAILURE);\n}\n \nint main(void)\n{\n    /* Prepare an array of FP values. */\n    #define SIZE 5\n    double A[SIZE] = {1.1,2.,3.,4.,5.};\n \n    /* Write array to a file. */\n    const char* fname = \"/tmp/test.bin\";\n    FILE* file = fopen(fname, \"wb\");\n    check(file != NULL, \"fopen()\", __LINE__);\n \n    const int write_count = fwrite(A, sizeof(double), SIZE, file);\n    check(write_count == SIZE, \"fwrite()\", __LINE__);\n \n    fclose(file);\n \n    /* Read the FP values into array B. */\n    double B[SIZE];\n    file = fopen(fname, \"rb\");\n    check(file != NULL, \"fopen()\", __LINE__);\n \n    long int pos = ftell(file); /* position indicator at start of file */\n    check(pos != -1L, \"ftell()\", __LINE__);\n    printf(\"pos: %ld\\n\", pos);\n \n    const int read_count = fread(B, sizeof(double), 1, file); /* read one FP value */\n    check(read_count == 1, \"fread()\", __LINE__);\n \n    pos = ftell(file); /* position indicator after reading one FP value */\n    check(pos != -1L, \"ftell()\", __LINE__);\n    printf(\"pos: %ld\\n\", pos);\n    printf(\"B[0]: %.1f\\n\", B[0]); /* print one FP value */\n \n    return EXIT_SUCCESS;\n}\n```\n\nPossible output:\n\n```\npos: 0\npos: 8\nB[0]: 1.1\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.9.4 The ftell function (p: 337-338)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.9.4 The ftell function (p: 303-304)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.9.4 The ftell function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/ftell](https://en.cppreference.com/w/c/io/ftell)"
- name: Function declarations
  summary: A function declaration introduces an identifier that designates a function and, optionally, specifies the types of the function parameters (the prototype)
  description: "# Function declarations\n\nA function declaration introduces an [identifier](identifier \"c/language/identifier\") that designates a function and, optionally, specifies the types of the function parameters (the *prototype*). Function declarations (unlike [definitions](function_definition \"c/language/function definition\")) may appear at block scope as well as file scope.\n\n### Syntax\n\nIn the [declaration grammar](declarations \"c/language/declarations\") of a function declaration, the type-specifier sequence, possibly modified by the declarator, designates the *return type* (which may be any type other than array or function type), and the declarator has one of three forms:\n\n|                                                                  |       |             |\n|------------------------------------------------------------------|-------|-------------|\n| noptr-declarator `(` parameter-list `)` attr-spec-seq(optional)  | \\(1\\) |             |\n| noptr-declarator `(` identifier-list `)` attr-spec-seq(optional) | \\(2\\) | (until C23) |\n| noptr-declarator `(` `)` attr-spec-seq(optional)                 | \\(3\\) |             |\n\nwhere\n\n|                  |     |                                                                                                                                                                                                                             |\n|------------------|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| noptr-declarator | \\-  | any [declarator](declarations#Declarators \"c/language/declarations\") except unparenthesized pointer declarator. The identifier that is contained in this declarator is the identifier that becomes the function designator. |\n| parameter-list   | \\-  | either the single keyword `void` or a comma-separated list of *parameters*, which may end with an [ellipsis parameter](variadic \"c/language/variadic\")                                                                      |\n| identifier-list  | \\-  | comma-separated list of identifiers, only possible if this declarator is used as part of old-style [function definition](function_definition \"c/language/function definition\")                                              |\n| attr-spec-seq    | \\-  | (C23)an optional list of [attributes](attributes \"c/language/attributes\"), applied to the function type                                                                                                                     |\n\n1) New-style (C89) function declaration. This declaration both introduces the function designator itself and also serves as a function prototype for any future [function call expressions](operator_other#Function_call \"c/language/operator other\"), forcing conversions from argument expressions to the declared parameter types and compile-time checks for the number of arguments.\n\n```\nint max(int a, int b); // declaration\nint n = max(12.01, 3.14); // OK, conversion from double to int\n```\n\n2) (until C23) Old-style (K&R) function definition. This declaration does not introduce a prototype and any future [function call expressions](operator_other#Function_call \"c/language/operator other\") will perform default argument promotions and will invoke undefined behavior if the number of arguments doesn't match the number of parameters.\n\n```\nint max(a, b) \n    int a, b; // definition expects ints; the second call is undefined\n{\n    return a > b ? a : b;\n}\n \nint n = max(true, (char)'a'); // calls max with two int args (after promotions)\n \nint n = max(12.01f, 3.14); // calls max with two double args (after promotions)\n```\n\n3) Non-prototype function declaration. This declaration does not introduce a prototype(until C23). A new style function declaration equivalent to the parameter-list `void`(since C23).\n\n### Explanation\n\nThe return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in [declarations](declarations \"c/language/declarations\"), must be a non-array object type or the type `void`. If the function declaration is not a definition, the return type can be [incomplete](type#Incomplete_types \"c/language/type\"). The return type cannot be cvr-qualified: any qualified return type is adjusted to its unqualified version for the purpose of constructing the function type.\n\n```\nvoid f(char *s);                    // return type is void\nint sum(int a, int b);              // return type of sum is int.\nint (*foo(const void *p))[3];       // return type is pointer to array of 3 int\n \ndouble const bar(void);             // declares function of type double(void)\ndouble (*barp)(void) = bar;         // OK: barp is a pointer to double(void)\ndouble const (*barpc)(void) = barp; // OK: barpc is also a pointer to double(void)\n```\n\nFunction declarators can be combined with other declarators as long as they can share their type specifiers and qualifiers\n\n```\nint f(void), *fip(), (*pfi)(), *ap[3]; // declares two functions and two objects\ninline int g(int), n; // Error: inline qualifier is for functions only\ntypedef int array_t[3];\narray_t a, h(); // Error: array type cannot be a return type for a function\n```\n\nIf a function declaration appears outside of any function, the identifier it introduces has [file scope](scope \"c/language/scope\") and [external linkage](storage_duration \"c/language/storage duration\"), unless `static` is used or an earlier static declaration is visible. If the declaration occurs inside another function, the identifier has block scope (and also either internal or external linkage).\n\n```\nint main(void)\n{\n    int f(int); // external linkage, block scope\n    f(1); // definition needs to be available somewhere in the program\n}\n```\n\nThe parameters in a declaration that is not part of a [function definition](function_definition \"c/language/function definition\")(until C23) do not need to be named:\n\n```\nint f(int, int); // declaration\n// int f(int, int) { return 7; } // Error: parameters must be named in definitions\n// This definition is allowed since C23\n```\n\nEach parameter in a parameter-list is a [declaration](declarations \"c/language/declarations\") that introduced a single variable, with the following additional properties:\n\n- the identifier in the declarator is optional (except if this function declaration is part of a function definition)(until C23)\n\n```\nint f(int, double); // OK\nint g(int a, double b); // also OK\n// int f(int, double) { return 1; } // Error: definition must name parameters\n// This definition is allowed since C23\n```\n\n- the only [storage class specifier](storage_duration \"c/language/storage duration\") allowed for parameters is `register`, and it is ignored in function declarations that are not definitions\n\n```\nint f(static int x); // Error\nint f(int [static 10]); // OK (array index static is not a storage class specifier)\n```\n\n- any parameter of array type is adjusted to the corresponding pointer type, which may be qualified if there are qualifiers between the square brackets of the array declarator(since C99)\n\n```\nint f(int[]); // declares int f(int*)\nint g(const int[10]); // declares int g(const int*)\nint h(int[const volatile]); // declares int h(int * const volatile)\nint x(int[*]); // declares int x(int*)\n```\n\n- any parameter of function type is adjusted to the corresponding pointer type\n\n```\nint f(char g(double)); // declares int f(char (*g)(double))\nint h(int(void)); // declares int h(int (*)(void))\n```\n\n- the parameter list may terminate with `, ...` or be `...`(since C23), see [variadic functions](variadic \"c/language/variadic\") for details.\n\n```\nint f(int, ...);\n```\n\n- parameters cannot have type `void` (but can have type pointer to void). The special parameter list that consists entirely of the keyword `void` is used to declare functions that take no parameters.\n\n```\nint f(void); // OK\nint g(void x); // Error\n```\n\n- any identifier that appears in a parameter list that could be treated as a typedef name or as a parameter name is treated as a typedef name: `int`` f``(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`, `[`uintptr_t`](http://en.cppreference.com/w/c/types/integer)`)` is parsed as a new-style declarator for a function taking two unnamed parameters of type size_t and uintptr_t, not an old-style declarator that begins the definition of a function taking two parameters named \"size_t\" and \"uintptr_t\"\n- parameters may have incomplete type and may use the VLA notation \\[\\*\\](since C99) (except that in a [function definition](function_definition \"c/language/function definition\"), the parameter types after array-to-pointer and function-to-pointer adjustment must be complete)\n\n|                                                                                                              |             |\n|--------------------------------------------------------------------------------------------------------------|-------------|\n| [Attribute specifier sequences](attributes \"c/language/attributes\") can also applied to function parameters. | (since C23) |\n\nSee [function call operator](operator_other#Function_call \"c/language/operator other\") for other details on the mechanics of a function call and [return](return \"c/language/return\") for returning from functions.\n\n### Notes\n\n[TABLE]\n\nUnlike in a [function definition](function_definition \"c/language/function definition\"), the parameter list may be inherited from a typedef\n\n```\ntypedef int p(int q, int r); // p is a function type int(int, int)\np f; // declares int f(int, int)\n```\n\n[TABLE]\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published              | Correct behavior                           |\n|-----------------------------------------------------------------------------|------------|------------------------------------|--------------------------------------------|\n| [DR 423](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_423) | C89        | the return type might be qualified | the return type is implicitly disqualified |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.6.3 Function declarators (including prototypes) (p: 96-98)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.6.3 Function declarators (including prototypes) (p: 133-136)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.5.3 Function declarators (including prototypes) (p: 118-121)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.5.4.3 Function declarators (including prototypes)\n\n### See also\n\n|                                                                                                                           |     |\n|---------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/function \"cpp/language/function\") for Function declaration |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/function_declaration](https://en.cppreference.com/w/c/language/function_declaration)"
- name: Function definitions
  summary: A function definition associates the function body (a sequence of declarations and statements) with the function name and parameter list
  description: "# Function definitions\n\nA function definition associates the function body (a sequence of declarations and statements) with the function name and parameter list. Unlike [function declaration](function_declaration \"c/language/function declaration\"), function definitions are allowed at file scope only (there are no nested functions).\n\nC supports two different forms of function definitions:\n\n|                                                                                           |       |             |\n|-------------------------------------------------------------------------------------------|-------|-------------|\n| attr-spec-seq(optional) specifiers-and-qualifiers parameter-list-declarator function-body | \\(1\\) |             |\n| specifiers-and-qualifiers identifier-list-declarator declaration-list function-body       | \\(2\\) | (until C23) |\n\nwhere\n\n[TABLE]\n\n1) New-style (C89) function definition. This definition both introduces the function itself and serves as a function prototype for any future [function call expressions](operator_other#Function_call \"c/language/operator other\"), forcing conversions from argument expressions to the declared parameter types.\n\n```\nint max(int a, int b)\n{\n    return a>b?a:b;\n}\n \ndouble g(void)\n{\n    return 0.1;\n}\n```\n\n2) (until C23) Old-style (K&R) function definition. This definition does not behave as a prototype and any future [function call expressions](operator_other#Function_call \"c/language/operator other\") will perform default argument promotions.\n\n```\nint max(a, b)\nint a, b;\n{\n    return a>b?a:b;\n}\ndouble g()\n{\n    return 0.1;\n}\n```\n\n### Explanation\n\nAs with [function declarations](function_declaration \"c/language/function declaration\"), the return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in [declarations](declarations \"c/language/declarations\"), must be a complete non-array object type or the type `void`. If the return type would be cvr-qualified, it is adjusted to its unqualified version for the purpose of constructing the function type.\n\n```\nvoid f(char *s) { puts(s); } // return type is void\nint sum(int a, int b) { return a+b: } // return type is int\nint (*foo(const void *p))[3] { // return type is pointer to array of 3 int\n    return malloc(sizeof(int[3]));\n}\n```\n\nAs with [function declarations](function_declaration \"c/language/function declaration\"), the types of the parameters are adjusted from functions to pointers and from arrays to pointers for the purpose of constructing the function type and the top-level cvr-qualifiers of all parameter types are ignored for the purpose of determining [compatible function type](type#Compatible_types \"c/language/type\").\n\n|                                                                                                                                                                                                                                                                                                                                               |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Unlike [function declarations](function_declaration \"c/language/function declaration\"), unnamed formal parameters are not allowed (otherwise, there would be conflicts in old-style (K&R) function definitions), they must be named even if they are not used within the function. The only exception is the special parameter list `(void)`. | (until C23) |\n| Formal parameters may be unnamed in function definitions, because old-style (K&R) function definitions has been removed. Unnamed parameters are inaccessible by name within the function body.                                                                                                                                                | (since C23) |\n\n```\nint f(int, int); // declaration\n// int f(int, int) { return 7; } // Error until C23, OK since C23\nint f(int a, int b) { return 7; } // definition\nint g(void) { return 8; } // OK: void doesn't declare a parameter\n```\n\nWithin the function body, every named parameter is an [lvalue](value_category \"c/language/value category\") expression, they have automatic [storage duration](storage_duration \"c/language/storage duration\") and [block scope](scope \"c/language/scope\"). The layout of the parameters in memory (or if they are stored in memory at all) is unspecified: it is a part of the [calling convention](https://en.wikipedia.org/wiki/Calling_convention \"enwiki:Calling convention\").\n\n```\nint main(int ac, char **av)\n{\n    ac = 2; // parameters are lvalues\n    av = (char *[]){\"abc\", \"def\", NULL};\n    f(ac, av);\n}\n```\n\nSee [function call operator](operator_other#Function_call \"c/language/operator other\") for other details on the mechanics of a function call and [return](return \"c/language/return\") for returning from functions.\n\n[TABLE]\n\n### Notes\n\nThe argument list must be explicitly present in the declarator, it cannot be inherited from a typedef\n\n```\ntypedef int p(int q, int r); // p is a function type int(int, int)\np f { return q + r; } // Error\n```\n\n[TABLE]\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published              | Correct behavior                           |\n|-----------------------------------------------------------------------------|------------|------------------------------------|--------------------------------------------|\n| [DR 423](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_423) | C89        | the return type might be qualified | the return type is implicitly disqualified |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.9.1 Function definitions (p: 113-115)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.9.1 Function definitions (p: 156-158)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.9.1 Function definitions (p: 141-143)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.7.1 Function definitions\n\n### See also\n\n|                                                                                                                                              |     |\n|----------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/function#Function_definition \"cpp/language/function\") for Function definition |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/function_definition](https://en.cppreference.com/w/c/language/function_definition)"
- name: Functions
  summary: A function is a C language construct that associates a compound statement (the function body) with an identifier (the function name)
  description: "# Functions\n\nA function is a C language construct that associates a [compound statement](statements#Compound_statements \"c/language/statements\") (the function body) with an [identifier](identifier \"c/language/identifier\") (the function name). Every C program begins execution from the [main function](main_function \"c/language/main function\"), which either terminates, or invokes other, user-defined or library functions.\n\n```\n// function definition.\n// defines a function with the name \"sum\" and with the body \"{ return x+y; }\"\nint sum(int x, int y) \n{\n    return x + y;\n}\n```\n\nA function is introduced by a [function declaration](function_declaration \"c/language/function declaration\") or a [function definition](function_definition \"c/language/function definition\").\n\nFunctions may accept zero or more *parameters*, which are initialized from the *arguments* of a [function call operator](operator_other#Function_call \"c/language/operator other\"), and may return a value to its caller by means of the [return statement](return \"c/language/return\").\n\n```\nint n = sum(1, 2); // parameters x and y are initialized with the arguments 1 and 2\n```\n\nThe body of a function is provided in a [function definition](function_definition \"c/language/function definition\"). Each non-[inline](inline \"c/language/inline\")(since C99) function that is used in an expression (unless [unevaluated](expressions#Unevaluated_expressions \"c/language/expressions\")) must be [defined only once](extern#One_definition_rule \"c/language/extern\") in a program.\n\nThere are no nested functions (except where allowed through non-standard compiler extensions): each function definition must appear at file scope, and functions have no access to the local variables from the caller:\n\n```\nint main(void) // the main function definition\n{\n    int sum(int, int); // function declaration (may appear at any scope)\n    int x = 1;  // local variable in main\n    sum(1, 2); // function call\n \n//    int sum(int a, int b) // error: no nested functions\n//    {\n//        return  a + b; \n//    }\n}\nint sum(int a, int b) // function definition\n{\n//    return x + a + b; //  error: main's x is not accessible within sum\n    return a + b;\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.6.3 Function declarators (including prototypes) (p: 96-98)\n  - 6.9.1 Function definitions (p: 113-115)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.6.3 Function declarators (including prototypes) (p: 133-136)\n  - 6.9.1 Function definitions (p: 156-158)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.5.3 Function declarators (including prototypes) (p: 118-121)\n  - 6.9.1 Function definitions (p: 141-143)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.5.4.3 Function declarators (including prototypes)\n  - 3.7.1 Function definitions\n\n### See also\n\n|                                                                                                                          |     |\n|--------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/function \"cpp/language/function\") for Declaring functions |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/functions](https://en.cppreference.com/w/c/language/functions)"
- name: fwide
  summary: If mode > 0, attempts to make stream wide-oriented
  description: "# fwide\n\n[TABLE]\n\nIf `mode > 0`, attempts to make `stream` wide-oriented. If `mode < 0`, attempts to make `stream` byte-oriented. If `mode==0`, only queries the current orientation of the stream.\n\nIf the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.\n\n### Parameters\n\n|        |     |                                                                                                                        |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | pointer to the C I/O stream to modify or query                                                                         |\n| mode   | \\-  | integer value greater than zero to set the stream wide, less than zero to set the stream narrow, or zero to query only |\n\n### Return value\n\nAn integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.\n\n### Example\n\nThe following code sets and resets the stream orientation.\n\n```\n#include <wchar.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nvoid show_orientation(int n)\n{\n    n < 0 ? puts(\"\\tnarrow orientation\"):\n    n > 0 ? puts(\"\\twide orientation\"):\n            puts(\"\\tno orientation\");\n}\n \nvoid try_read(FILE* fp)\n{\n    int c = fgetc(fp);\n    if(c == EOF)\n        puts(\"\\tnarrow character read failed\");\n    else\n        printf(\"\\tnarrow character read '%c'\\n\", c);\n \n    wint_t wc = fgetwc(fp);\n    if(wc == WEOF)\n        puts(\"\\twide character read failed\");\n    else\n        printf(\"\\twide character read '%lc'\\n\", wc);\n}\n \nint main(void)\n{\n    enum fwide_orientation { narrow = -1, query, wide };\n \n    FILE* fp = fopen(\"main.cpp\", \"r\");\n    if (!fp)\n    {\n        perror(\"fopen() failed\");\n        return EXIT_FAILURE;\n    }\n \n    puts(\"1) A newly opened stream has no orientation.\");\n    show_orientation(fwide(fp, query));\n \n    puts(\"2) Establish byte orientation.\");\n    show_orientation(fwide(fp, narrow));\n    try_read(fp);\n \n    puts(\"3) Only freopen() can reset stream orientation.\");\n    if (freopen(\"main.cpp\", \"r\", fp) == NULL)\n    {\n       perror(\"freopen() failed\");\n       return EXIT_FAILURE;\n    }\n \n    puts(\"4) A reopened stream has no orientation.\");\n    show_orientation(fwide(fp, query));\n \n    puts(\"5) Establish wide orientation.\");\n    show_orientation(fwide(fp, wide));\n    try_read(fp);\n \n    fclose(fp);\n}\n```\n\nPossible output:\n\n```\n1) A newly opened stream has no orientation.\n        no orientation\n2) Establish byte orientation.\n        narrow orientation\n        narrow character read '#'\n        wide character read failed\n3) Only freopen() can reset stream orientation.\n4) A reopened stream has no orientation.\n        no orientation\n5) Establish wide orientation.\n        wide orientation\n        narrow character read failed\n        wide character read '#'\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.3.5 The fwide function (p: 309)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.3.5 The fwide function (p: 423)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.3.5 The fwide function (p: 369)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwide](https://en.cppreference.com/w/c/io/fwide)"
- name: fwprintf
  summary: Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# wprintf, fwprintf, swprintf, wprintf_s, fwprintf_s, swprintf_s, snwprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) If `bufsz` is greater than zero, writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. If `bufsz` is zero, nothing is written (and `buffer` may be a null pointer).\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (only for `swprintf_s`) the number of wide characters to be written, including the null, would exceed `bufsz`.\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by s. As with all bounds-checked functions, `wprintf_s` , `fwprintf_s`, `swprintf_s`, and `snwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a wide character string to write to                                                                                                                                                                                                                                                                                                                                                                                           |\n| bufsz  | \\-  | up to `bufsz-1` wide characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                 |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) Number of wide characters written if successful or negative value if an error occurred.\n\n3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than `size` (including when `size` is zero).\n\n4,5) Number of wide characters written if successful or negative value if an error occurred.\n\n6) Number of wide characters (not counting the terminating null) that were written to `buffer`. Returns a negative value on encoding errors and on overflow. Returns zero on all other errors.\n\n7) Number of wide characters (not counting the terminating null) that would have been written to `buffer` had `bufsz` been sufficiently large, or a negative value if an error occurs. (meaning, write was successful and complete only if the return is nonnegative and less than `bufsz`)\n\n### Notes\n\nWhile narrow strings provide [`snprintf`](fprintf \"c/io/fprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until `snwprintf_s`)(since C11), and in order to determine the buffer size, the program may need to call `swprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`snwprintf_s`, unlike `swprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    char narrow_str[] = \"z\\u00df\\u6c34\\U0001f34c\";\n                    // or \"zß水🍌\"\n                    // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator\n    setlocale(LC_ALL, \"en_US.utf8\");\n    swprintf(warr, sizeof warr/sizeof *warr,\n              L\"Converted from UTF-8: '%s'\", narrow_str);\n    wprintf(L\"%ls\\n\", warr);\n}\n```\n\nOutput:\n\n```\nConverted from UTF-8: 'zß水🍌'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.1 The fwprintf function (p: 403-410)\n  - 7.29.2.3 The swprintf function (p: 416)\n  - 7.29.2.11 The wprintf function (p: 421)\n  - K.3.9.1.1 The fwprintf_s function (p: 628)\n  - K.3.9.1.4 The swprintf_s function (p: 630-631)\n  - K.3.9.1.13 The wprintf_s function (p: 637-638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.1 The fwprintf function (p: 349-356)\n  - 7.24.2.3 The swprintf function (p: 362)\n  - 7.24.2.11 The wprintf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwprintf](https://en.cppreference.com/w/c/io/fwprintf)"
- name: fwprintf_s
  summary: Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# wprintf, fwprintf, swprintf, wprintf_s, fwprintf_s, swprintf_s, snwprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) If `bufsz` is greater than zero, writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. If `bufsz` is zero, nothing is written (and `buffer` may be a null pointer).\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (only for `swprintf_s`) the number of wide characters to be written, including the null, would exceed `bufsz`.\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by s. As with all bounds-checked functions, `wprintf_s` , `fwprintf_s`, `swprintf_s`, and `snwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a wide character string to write to                                                                                                                                                                                                                                                                                                                                                                                           |\n| bufsz  | \\-  | up to `bufsz-1` wide characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                 |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) Number of wide characters written if successful or negative value if an error occurred.\n\n3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than `size` (including when `size` is zero).\n\n4,5) Number of wide characters written if successful or negative value if an error occurred.\n\n6) Number of wide characters (not counting the terminating null) that were written to `buffer`. Returns a negative value on encoding errors and on overflow. Returns zero on all other errors.\n\n7) Number of wide characters (not counting the terminating null) that would have been written to `buffer` had `bufsz` been sufficiently large, or a negative value if an error occurs. (meaning, write was successful and complete only if the return is nonnegative and less than `bufsz`)\n\n### Notes\n\nWhile narrow strings provide [`snprintf`](fprintf \"c/io/fprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until `snwprintf_s`)(since C11), and in order to determine the buffer size, the program may need to call `swprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`snwprintf_s`, unlike `swprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    char narrow_str[] = \"z\\u00df\\u6c34\\U0001f34c\";\n                    // or \"zß水🍌\"\n                    // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator\n    setlocale(LC_ALL, \"en_US.utf8\");\n    swprintf(warr, sizeof warr/sizeof *warr,\n              L\"Converted from UTF-8: '%s'\", narrow_str);\n    wprintf(L\"%ls\\n\", warr);\n}\n```\n\nOutput:\n\n```\nConverted from UTF-8: 'zß水🍌'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.1 The fwprintf function (p: 403-410)\n  - 7.29.2.3 The swprintf function (p: 416)\n  - 7.29.2.11 The wprintf function (p: 421)\n  - K.3.9.1.1 The fwprintf_s function (p: 628)\n  - K.3.9.1.4 The swprintf_s function (p: 630-631)\n  - K.3.9.1.13 The wprintf_s function (p: 637-638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.1 The fwprintf function (p: 349-356)\n  - 7.24.2.3 The swprintf function (p: 362)\n  - 7.24.2.11 The wprintf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwprintf](https://en.cppreference.com/w/c/io/fwprintf)"
- name: fwrite
  summary: Writes count of objects from the given array buffer to the output stream stream
  description: "# fwrite\n\n[TABLE]\n\nWrites `count` of objects from the given array `buffer` to the output stream `stream`. The objects are written as if by reinterpreting each object as an array of `unsigned char` and calling [`fputc`](fputc \"c/io/fputc\") `size` times for each object to write those `unsigned char`s into `stream`, in order. The file position indicator for the stream is advanced by the number of characters written.\n\nIf an error occurs, the resulting value of the file position indicator for the stream is indeterminate.\n\n### Parameters\n\n|        |     |                                                        |\n|--------|-----|--------------------------------------------------------|\n| buffer | \\-  | pointer to the first object in the array to be written |\n| size   | \\-  | size of each object                                    |\n| count  | \\-  | the number of the objects to be written                |\n| stream | \\-  | pointer to the output stream                           |\n\n### Return value\n\nThe number of objects written successfully, which may be less than `count` if an error occurs.\n\nIf `size` or `count` is zero, `fwrite` returns zero and performs no other action.\n\n### Example\n\n```\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nenum { SIZE = 5 };\n \nint main(void)\n{\n    double a[SIZE] = {1, 2, 3, 4, 5};\n    FILE* f1 = fopen(\"file.bin\", \"wb\");\n    assert(f1);\n    size_t r1 = fwrite(a, sizeof a[0], SIZE, f1);\n    printf(\"wrote %zu elements out of %d requested\\n\", r1, SIZE);\n    fclose(f1);\n \n    double b[SIZE];\n    FILE* f2 = fopen(\"file.bin\", \"rb\");\n    size_t r2 = fread(b, sizeof b[0], SIZE, f2);\n    fclose(f2);\n    printf(\"read back: \");\n    for (size_t i = 0; i < r2; ++i)\n        printf(\"%0.2f \", b[i]);\n}\n```\n\nOutput:\n\n```\nwrote 5 elements out of 5 requested\nread back: 1.00 2.00 3.00 4.00 5.00\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.8.2 The fwrite function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.8.2 The fwrite function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.8.2 The fwrite function (p: 335-336)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.8.2 The fwrite function (p: 301-302)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.8.2 The fwrite function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwrite](https://en.cppreference.com/w/c/io/fwrite)"
- name: fwscanf
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into given locations
  description: "# wscanf, fwscanf, swscanf, wscanf_s, fwscanf_s, swscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%lc` into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs all bounds-checked functions, `wscanf_s`, `fwscanf_s`, and `swscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../string/wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                      |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <string.h>\n \n#define NUM_VARS   3\n#define ERR_READ   2\n#define ERR_WRITE  3\n \nint main(void) {\n    wchar_t state[64];\n    wchar_t capital[64];\n    unsigned int population = 0;\n    int elevation = 0;\n    int age = 0;\n    float pi = 0;\n \n#if INTERACTIVE_MODE\n    wprintf(L\"Enter state, age, and pi value: \");\n    if (wscanf(L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#else\n    wchar_t* input = L\"California 170 3.141592\";\n    if (swscanf(input, L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#endif\n    wprintf(L\"State: %ls\\nAge  : %d years\\nPi   : %.5f\\n\\n\", state, age, pi);\n \n    FILE* fp = tmpfile();\n    if (fp) {\n        // write some data to temp file\n        if (!fwprintf(fp, L\"Mississippi Jackson 420000 807\")) {\n            fprintf(stderr, \"Error writing to file.\\n\");\n            fclose(fp);\n            return ERR_WRITE;\n        }\n        // rewind file pointer\n        rewind(fp);\n \n        // read data into variables\n        fwscanf(fp, L\"%ls%ls%u%d\", state, capital, &population, &elevation);\n        wprintf(L\"State  : %ls\\nCapital: %ls\\nJackson population (in 2020): %u\\n\"\n                L\"Highest elevation: %dft\\n\",\n                state, capital, population, elevation);\n        fclose(fp);\n    }\n}\n```\n\nPossible output:\n\n```\nState: California\nAge  : 170 years\nPi   : 3.14159\n \nState  : Mississippi\nCapital: Jackson\nJackson population (in 2020): 420000\nHighest elevation: 807ft\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.2 The fwscanf function (p: 410-416)\n  - 7.29.2.4 The swscanf function (p: 417)\n  - 7.29.2.12 The wscanf function (p: 421)\n  - K.3.9.1.2 The fwscanf_s function (p: 628-629)\n  - K.3.9.1.5 The swscanf_s function (p: 631)\n  - K.3.9.1.14 The wscanf_s function (p: 638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.2 The fwscanf function (p: 356-362)\n  - 7.24.2.4 The swscanf function (p: 362)\n  - 7.24.2.12 The wscanf function (p: 366-367)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwscanf](https://en.cppreference.com/w/c/io/fwscanf)"
- name: fwscanf_s
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into given locations
  description: "# wscanf, fwscanf, swscanf, wscanf_s, fwscanf_s, swscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%lc` into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs all bounds-checked functions, `wscanf_s`, `fwscanf_s`, and `swscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../string/wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                      |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <string.h>\n \n#define NUM_VARS   3\n#define ERR_READ   2\n#define ERR_WRITE  3\n \nint main(void) {\n    wchar_t state[64];\n    wchar_t capital[64];\n    unsigned int population = 0;\n    int elevation = 0;\n    int age = 0;\n    float pi = 0;\n \n#if INTERACTIVE_MODE\n    wprintf(L\"Enter state, age, and pi value: \");\n    if (wscanf(L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#else\n    wchar_t* input = L\"California 170 3.141592\";\n    if (swscanf(input, L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#endif\n    wprintf(L\"State: %ls\\nAge  : %d years\\nPi   : %.5f\\n\\n\", state, age, pi);\n \n    FILE* fp = tmpfile();\n    if (fp) {\n        // write some data to temp file\n        if (!fwprintf(fp, L\"Mississippi Jackson 420000 807\")) {\n            fprintf(stderr, \"Error writing to file.\\n\");\n            fclose(fp);\n            return ERR_WRITE;\n        }\n        // rewind file pointer\n        rewind(fp);\n \n        // read data into variables\n        fwscanf(fp, L\"%ls%ls%u%d\", state, capital, &population, &elevation);\n        wprintf(L\"State  : %ls\\nCapital: %ls\\nJackson population (in 2020): %u\\n\"\n                L\"Highest elevation: %dft\\n\",\n                state, capital, population, elevation);\n        fclose(fp);\n    }\n}\n```\n\nPossible output:\n\n```\nState: California\nAge  : 170 years\nPi   : 3.14159\n \nState  : Mississippi\nCapital: Jackson\nJackson population (in 2020): 420000\nHighest elevation: 807ft\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.2 The fwscanf function (p: 410-416)\n  - 7.29.2.4 The swscanf function (p: 417)\n  - 7.29.2.12 The wscanf function (p: 421)\n  - K.3.9.1.2 The fwscanf_s function (p: 628-629)\n  - K.3.9.1.5 The swscanf_s function (p: 631)\n  - K.3.9.1.14 The wscanf_s function (p: 638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.2 The fwscanf function (p: 356-362)\n  - 7.24.2.4 The swscanf function (p: 362)\n  - 7.24.2.12 The wscanf function (p: 366-367)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwscanf](https://en.cppreference.com/w/c/io/fwscanf)"
- name: Generic selection
  summary: Provides a way to choose one of several expressions at compile time, based on a type of a controlling expression
  description: "# Generic selection (since C11)\n\nProvides a way to choose one of several expressions at compile time, based on a type of a controlling expression\n\n### Syntax\n\n|                                                                |     |             |\n|----------------------------------------------------------------|-----|-------------|\n| `_Generic` `(` controlling-expression `,` association-list `)` |     | (since C11) |\n\nwhere association-list is a comma-separated list of associations, each of which has the syntax\n\n|                          |     |     |\n|--------------------------|-----|-----|\n| type-name `:` expression |     |     |\n| `default` `:` expression |     |     |\n\nwhere\n\n|                        |     |                                                                                                                                                                                                               |\n|------------------------|-----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| type-name              | \\-  | any complete [object type](type \"c/language/type\") that isn't variably-modified (that is, not VLA or pointer to VLA).                                                                                         |\n| controlling-expression | \\-  | any expression (except for the [comma operator](operator_other#Comma_operator \"c/language/operator other\")) whose type must be compatible with one of the type-names if the `default` association is not used |\n| expression             | \\-  | any expression (except for the [comma operator](operator_other#Comma_operator \"c/language/operator other\")) of any type and value category                                                                    |\n\nNo two type-names in the association-list may specify [compatible types](type#Compatible_types \"c/language/type\"). There may be only one association that uses the keyword `default`. If `default` is not used and none of the type-names are compatible with the type of the controlling expression, the program will not compile.\n\n### Explanation\n\nFirst, the type of controlling-expression undergoes [lvalue conversions](conversion#Lvalue_conversions \"c/language/conversion\"). The conversion is performed in type domain only: it discards the top-level cvr-qualifiers and atomicity and applies array-to-pointer/function-to-pointer transformations to the type of the controlling expression, without initiating any side-effects or calculating any values.\n\nThe type after conversion is compared with type-names from the list of associations.\n\nIf the type is [compatible](type#Compatible_types \"c/language/type\") with the type-name of one of the associations, then the type, value, and [value category](value_category \"c/language/value category\") of the generic selection are the type, value, and value category of the expression that appears after the colon for that type-name.\n\nIf none of the type-names are compatible with the type of the controlling-expression, and the `default` association is provided, then the type, value, and value category of the generic selection are the type, value, and value category of the expression after the `default :` label.\n\n### Notes\n\nThe controlling-expression and the expressions of the selections that are not chosen are never evaluated.\n\nBecause of the lvalue conversions, `\"abc\"` matches `char*` and not `char[4]` and `(int const){0}` matches `int`, and not `const int`.\n\nAll [value categories](value_category \"c/language/value category\"), including function designators and void expressions, are allowed as expressions in a generic selection, and if selected, the generic selection itself has the same value category.\n\nThe [type-generic math macros](../numeric/tgmath \"c/numeric/tgmath\") from [`<tgmath.h>`](../numeric/tgmath \"c/numeric/tgmath\"), introduced in C99, were implemented in compiler-specific manner. Generic selections, introduced in C11, gave the programmers the ability to write similar type-dependent code.\n\nGeneric selection is similar to overloading in C++ (where one of several functions is chosen at compile time based on the types of the arguments), except that it makes the selection between arbitrary expressions.\n\n### Keywords\n\n[`_Generic`](../keyword/_generic \"c/keyword/ Generic\"), [`default`](../keyword/default \"c/keyword/default\")\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \n// Possible implementation of the tgmath.h macro cbrt\n#define cbrt(X) _Generic((X), \\\n              long double: cbrtl, \\\n                  default: cbrt,  \\\n                    float: cbrtf  \\\n              )(X)\n \nint main(void)\n{\n    double x = 8.0;\n    const float y = 3.375;\n    printf(\"cbrt(8.0) = %f\\n\", cbrt(x)); // selects the default cbrt\n    printf(\"cbrtf(3.375) = %f\\n\", cbrt(y)); // converts const float to float,\n                                            // then selects cbrtf\n}\n```\n\nOutput:\n\n```\ncbrt(8.0) = 2.000000\ncbrtf(3.375) = 1.500000\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                                            | Correct behavior |\n|-----------------------------------------------------------------------------|------------|----------------------------------------------------------------------------------|------------------|\n| [DR 481](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_481) | C11        | it was underspecified if the controlling expression undergoes lvalue conversions | it undergoes     |\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.5.1.1 Generic selection (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.1.1 Generic selection (p: 56-57)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.1.1 Generic selection (p: 78-79)\n\n### See also\n\n|                                                                                                                  |     |\n|------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/templates \"cpp/language/templates\") for Templates |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/generic](https://en.cppreference.com/w/c/language/generic)"
- name: getc
  summary: On success, returns the obtained character as an unsigned char converted to an int
  description: "# fgetc, getc\n\n[TABLE]\n\n1) Reads the next character from the given input stream.\n\n2) Same as `fgetc`, except that if `getc` is implemented as a macro, it may evaluate stream more than once, so the corresponding argument should never be an expression with side effects.\n\n### Parameters\n\n|        |     |                            |\n|--------|-----|----------------------------|\n| stream | \\-  | to read the character from |\n\n### Return value\n\nOn success, returns the obtained character as an `unsigned char` converted to an `int`. On failure, returns [`EOF`](../io \"c/io\").\n\nIf the failure has been caused by end-of-file condition, additionally sets the *eof* indicator (see [`feof()`](feof \"c/io/feof\")) on `stream`. If the failure has been caused by some other error, sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char* fname = \"/tmp/unique_name.txt\"; // or tmpnam(NULL);\n    int is_ok = EXIT_FAILURE;\n \n    FILE* fp = fopen(fname, \"w+\");\n    if (!fp) {\n        perror(\"File opening failed\");\n        return is_ok;\n    }\n    fputs(\"Hello, world!\\n\", fp);\n    rewind(fp);\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = fgetc(fp)) != EOF) // standard C I/O file reading loop\n        putchar(c);\n \n    if (ferror(fp))\n        puts(\"I/O error when reading\");\n    else if (feof(fp)) {\n        puts(\"End of file is reached successfully\");\n        is_ok = EXIT_SUCCESS;\n    }\n \n    fclose(fp);\n    remove(fname);\n    return is_ok;\n}\n```\n\nPossible output:\n\n```\nHello, world!\nEnd of file is reached successfully\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.7.1 The fgetc function (p: 240-241)\n  - 7.21.7.5 The getc function (p: 242)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.7.1 The fgetc function (p: 330)\n  - 7.21.7.5 The getc function (p: 332)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.1 The fgetc function (p: 296)\n  - 7.19.7.5 The getc function (p: 297-298)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.1 The fgetc function\n  - 4.9.7.5 The getc function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fgetc](https://en.cppreference.com/w/c/io/fgetc)"
- name: getchar
  summary: Reads the next character from stdin
  description: "# getchar\n\n[TABLE]\n\nReads the next character from [`stdin`](std_streams \"c/io/std streams\").\n\nEquivalent to [`getc`](http://en.cppreference.com/w/c/io/fgetc)`(`[`stdin`](http://en.cppreference.com/w/c/io/std_streams)`)`.\n\n### Parameters\n\n(none)\n\n### Return value\n\nThe obtained character on success or [`EOF`](../io \"c/io\") on failure.\n\nIf the failure has been caused by end-of-file condition, additionally sets the *eof* indicator (see [`feof()`](feof \"c/io/feof\")) on [`stdin`](std_streams \"c/io/std streams\"). If the failure has been caused by some other error, sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on [`stdin`](std_streams \"c/io/std streams\").\n\n### Example\n\nDemonstrates `getchar` with error checking\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    for (int ch; (ch = getchar()) != EOF;) // read/print \"abcde\" from stdin\n        printf(\"%c\", ch);\n \n    // Test reason for reaching EOF.\n    if (feof(stdin)) // if failure caused by end-of-file condition\n        puts(\"End of file reached\");\n    else if (ferror(stdin)) // if failure caused by some other error\n    {\n        perror(\"getchar()\");\n        fprintf(stderr, \"getchar() failed in file %s at line # %d\\n\",\n                __FILE__, __LINE__ - 9);\n        exit(EXIT_FAILURE);\n    }\n \n    return EXIT_SUCCESS;\n}\n```\n\nPossible output:\n\n```\nabcde\nEnd of file reached\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.7.6 The getchar function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.7.6 The getchar function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.7.6 The getchar function (p: 332)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.6 The getchar function (p: 298)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.6 The getchar function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/getchar](https://en.cppreference.com/w/c/io/getchar)"
- name: getenv
  summary: On POSIX systems, the environment variables are also accessible through the global variable environ, declared as extern char **environ; in <unistd.h>, and through the optional third argument, envp, of the main function
  description: "# getenv, getenv_s\n\n[TABLE]\n\n1) Searches for an environmental variable with name `name` in the host-specified environment list and returns a pointer to the string that is associated with the matched environment variable. The set of environmental variables and methods of altering it are implementation-defined.\n\nThis function is not required to be thread-safe. Another call to `getenv`, as well as a call to the POSIX functions [`setenv()`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html), [`unsetenv()`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html), and [`putenv()`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html) may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.\n\nModifying the string returned by `getenv` invokes undefined behavior.\n\n2) Same as (1), except that the values of the environment variable is written to the user-provided buffer `value` (unless null) and the number of bytes written is stored in the user-provided location `*len` (unless null). If the environment variable is not set in the environment, zero is written to `*len` (unless null) and `'\\0'` is written to `value[0]` (unless null). In addition, the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `name` is a null pointer\n- `valuesz` is greater than `RSIZE_MAX`\n- `value` is a null pointer and `valuesz` is not zero\n\nAs with all bounds-checked functions, `getenv_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../program \"c/program\").\n\n### Parameters\n\n|         |     |                                                                                                                 |\n|---------|-----|-----------------------------------------------------------------------------------------------------------------|\n| name    | \\-  | null-terminated character string identifying the name of the environmental variable to look for                 |\n| len     | \\-  | pointer to a user-provided location where `getenv_s` will store the length of the environment variable          |\n| value   | \\-  | pointer to a user-provided character array where `getenv_s` will store the contents of the environment variable |\n| valuesz | \\-  | maximum number of characters that `getenv_s` is allowed to write to `dest` (size of the buffer)                 |\n\n### Return value\n\n1) character string identifying the value of the environmental variable or null pointer if such variable is not found.\n\n2) zero if the environment variable was found, non-zero if it was not found or if a runtime constraint violation occurred. On any error, writes zero to `*len` (unless `len` is a null pointer).\n\n### Notes\n\nOn POSIX systems, the [environment variables](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08) are also accessible through the global variable `environ`, declared as `extern char **environ;` in `<unistd.h>`, and through the optional third argument, `envp`, of [the main function](../language/main_function \"c/language/main function\").\n\nThe call to `getenv_s` with a null pointer for `value` and zero for `valuesz` is used to determine the size of the buffer required to hold the entire result.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char *name = \"PATH\";\n    const char *env_p = getenv(name);\n    if (env_p)\n        printf(\"Your %s is %s\\n\", name, env_p);\n}\n```\n\nPossible output:\n\n```\nYour PATH is /home/gamer/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/share/games\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.22.4.6 The getenv function (p: TBD)\n  - K.3.6.2.1 The getenv_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.4.6 The getenv function (p: 256-257)\n  - K.3.6.2.1 The getenv_s function (p: 440-441)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.4.6 The getenv function (p: 352-353)\n  - K.3.6.2.1 The getenv_s function (p: 606-607)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.4.5 The getenv function (p: 317)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.4.4 The getenv function\n\n### See also\n\n|                                                                                                                         |     |\n|-------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/utility/program/getenv \"cpp/utility/program/getenv\") for `getenv` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/getenv](https://en.cppreference.com/w/c/program/getenv)"
- name: getenv_s
  summary: On POSIX systems, the environment variables are also accessible through the global variable environ, declared as extern char **environ; in <unistd.h>, and through the optional third argument, envp, of the main function
  description: "# getenv, getenv_s\n\n[TABLE]\n\n1) Searches for an environmental variable with name `name` in the host-specified environment list and returns a pointer to the string that is associated with the matched environment variable. The set of environmental variables and methods of altering it are implementation-defined.\n\nThis function is not required to be thread-safe. Another call to `getenv`, as well as a call to the POSIX functions [`setenv()`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html), [`unsetenv()`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html), and [`putenv()`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html) may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.\n\nModifying the string returned by `getenv` invokes undefined behavior.\n\n2) Same as (1), except that the values of the environment variable is written to the user-provided buffer `value` (unless null) and the number of bytes written is stored in the user-provided location `*len` (unless null). If the environment variable is not set in the environment, zero is written to `*len` (unless null) and `'\\0'` is written to `value[0]` (unless null). In addition, the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `name` is a null pointer\n- `valuesz` is greater than `RSIZE_MAX`\n- `value` is a null pointer and `valuesz` is not zero\n\nAs with all bounds-checked functions, `getenv_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../program \"c/program\").\n\n### Parameters\n\n|         |     |                                                                                                                 |\n|---------|-----|-----------------------------------------------------------------------------------------------------------------|\n| name    | \\-  | null-terminated character string identifying the name of the environmental variable to look for                 |\n| len     | \\-  | pointer to a user-provided location where `getenv_s` will store the length of the environment variable          |\n| value   | \\-  | pointer to a user-provided character array where `getenv_s` will store the contents of the environment variable |\n| valuesz | \\-  | maximum number of characters that `getenv_s` is allowed to write to `dest` (size of the buffer)                 |\n\n### Return value\n\n1) character string identifying the value of the environmental variable or null pointer if such variable is not found.\n\n2) zero if the environment variable was found, non-zero if it was not found or if a runtime constraint violation occurred. On any error, writes zero to `*len` (unless `len` is a null pointer).\n\n### Notes\n\nOn POSIX systems, the [environment variables](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08) are also accessible through the global variable `environ`, declared as `extern char **environ;` in `<unistd.h>`, and through the optional third argument, `envp`, of [the main function](../language/main_function \"c/language/main function\").\n\nThe call to `getenv_s` with a null pointer for `value` and zero for `valuesz` is used to determine the size of the buffer required to hold the entire result.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char *name = \"PATH\";\n    const char *env_p = getenv(name);\n    if (env_p)\n        printf(\"Your %s is %s\\n\", name, env_p);\n}\n```\n\nPossible output:\n\n```\nYour PATH is /home/gamer/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/share/games\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.22.4.6 The getenv function (p: TBD)\n  - K.3.6.2.1 The getenv_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.4.6 The getenv function (p: 256-257)\n  - K.3.6.2.1 The getenv_s function (p: 440-441)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.4.6 The getenv function (p: 352-353)\n  - K.3.6.2.1 The getenv_s function (p: 606-607)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.4.5 The getenv function (p: 317)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.4.4 The getenv function\n\n### See also\n\n|                                                                                                                         |     |\n|-------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/utility/program/getenv \"cpp/utility/program/getenv\") for `getenv` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/getenv](https://en.cppreference.com/w/c/program/getenv)"
- name: gets
  summary: str on success, a null pointer on failure
  description: "# gets, gets_s\n\n[TABLE]\n\n1) Reads [`stdin`](std_streams \"c/io/std streams\") into the character array pointed to by `str` until a newline character is found or end-of-file occurs. A null character is written immediately after the last character read into the array. The newline character is discarded but not stored in the buffer.\n\n2) Reads characters from [`stdin`](std_streams \"c/io/std streams\") until a newline is found or end-of-file occurs. Writes only at most `n-1` characters into the array pointed to by `str`, and always writes the terminating null character (unless str is a null pointer). The newline character, if found, is discarded and does not count toward the number of characters written to the buffer.\n\nThe following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `n` is zero\n- `n` is greater than `RSIZE_MAX`\n- `str` is a null pointer\n- endline or eof not encountered after storing `n-1` characters to the buffer.\n\nIn any case, `gets_s` first finishes reading and discarding the characters from [`stdin`](std_streams \"c/io/std streams\") until new-line character, end-of-file condition, or read error before calling the constraint handler.\n\nAs with all bounds-checked functions, `gets_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|     |     |                                |\n|-----|-----|--------------------------------|\n| str | \\-  | character string to be written |\n\n### Return value\n\n`str` on success, a null pointer on failure.\n\nIf the failure has been caused by end of file condition, additionally sets the *eof* indicator (see [`feof()`](feof \"c/io/feof\")) on [`stdin`](std_streams \"c/io/std streams\"). If the failure has been caused by some other error, sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on [`stdin`](std_streams \"c/io/std streams\").\n\n### Notes\n\nThe `gets()` function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely (unless the program runs in an environment which restricts what can appear on `stdin`). For this reason, the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard. [`fgets()`](fgets \"c/io/fgets\") and `gets_s()` are the recommended replacements.\n\n**Never use `gets()`.**\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - K.3.5.4.1 The gets_s function (p: 602-603)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.7 The gets function (p: 298)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.7 The gets function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/gets](https://en.cppreference.com/w/c/io/gets)"
- name: gets_s
  summary: str on success, a null pointer on failure
  description: "# gets, gets_s\n\n[TABLE]\n\n1) Reads [`stdin`](std_streams \"c/io/std streams\") into the character array pointed to by `str` until a newline character is found or end-of-file occurs. A null character is written immediately after the last character read into the array. The newline character is discarded but not stored in the buffer.\n\n2) Reads characters from [`stdin`](std_streams \"c/io/std streams\") until a newline is found or end-of-file occurs. Writes only at most `n-1` characters into the array pointed to by `str`, and always writes the terminating null character (unless str is a null pointer). The newline character, if found, is discarded and does not count toward the number of characters written to the buffer.\n\nThe following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `n` is zero\n- `n` is greater than `RSIZE_MAX`\n- `str` is a null pointer\n- endline or eof not encountered after storing `n-1` characters to the buffer.\n\nIn any case, `gets_s` first finishes reading and discarding the characters from [`stdin`](std_streams \"c/io/std streams\") until new-line character, end-of-file condition, or read error before calling the constraint handler.\n\nAs with all bounds-checked functions, `gets_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|     |     |                                |\n|-----|-----|--------------------------------|\n| str | \\-  | character string to be written |\n\n### Return value\n\n`str` on success, a null pointer on failure.\n\nIf the failure has been caused by end of file condition, additionally sets the *eof* indicator (see [`feof()`](feof \"c/io/feof\")) on [`stdin`](std_streams \"c/io/std streams\"). If the failure has been caused by some other error, sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on [`stdin`](std_streams \"c/io/std streams\").\n\n### Notes\n\nThe `gets()` function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely (unless the program runs in an environment which restricts what can appear on `stdin`). For this reason, the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard. [`fgets()`](fgets \"c/io/fgets\") and `gets_s()` are the recommended replacements.\n\n**Never use `gets()`.**\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - K.3.5.4.1 The gets_s function (p: 602-603)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.7 The gets function (p: 298)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.7 The gets function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/gets](https://en.cppreference.com/w/c/io/gets)"
- name: getwc
  summary: Reads the next wide character from the given input stream
  description: "# fgetwc, getwc\n\n[TABLE]\n\nReads the next wide character from the given input stream. `getwc()` may be implemented as a macro and may evaluate `stream` more than once.\n\n### Parameters\n\n|        |     |                                 |\n|--------|-----|---------------------------------|\n| stream | \\-  | to read the wide character from |\n\n### Return value\n\nThe next wide character from the stream or `WEOF` on failure.\n\nIf the failure has been caused by end-of-file condition, additionally sets the *eof* indicator (see [`feof()`](feof \"c/io/feof\")) on `stream`. If the failure has been caused by some other error, sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`.\n\nIf an encoding error occurred, additionally sets [`errno`](../error/errno \"c/error/errno\") to `EILSEQ`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n#include <errno.h>\n#include <locale.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    FILE *fp = fopen(\"fgetwc.dat\", \"w\");\n    if(!fp) {\n        perror(\"Can't open file for writing\");\n        return EXIT_FAILURE;\n    }\n    fputs(\"кошка\\n\", fp);\n    fclose(fp);\n \n    fp = fopen(\"fgetwc.dat\", \"r\");\n    if(!fp) {\n        perror(\"Can't open file for reading\");\n        return EXIT_FAILURE;\n    }\n    wint_t wc;\n    errno = 0;\n    while ((wc = fgetwc(fp)) != WEOF)\n        putwchar(wc);\n \n    if (ferror(fp)) {\n        if (errno == EILSEQ)\n            puts(\"Character encoding error while reading.\");\n        else\n            puts(\"I/O error when reading\");\n    } else if (feof(fp))\n        puts(\"End of file reached successfully\");\n \n    fclose(fp);\n}\n```\n\nOutput:\n\n```\nкошка\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.3.1 The fgetwc function (p: 307-308)\n  - 7.29.3.6 The getwc function (p: 309)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.3.1 The fgetwc function (p: 421-422)\n  - 7.29.3.6 The getwc function (p: 424)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.3.1 The fgetwc function (p: 367)\n  - 7.24.3.6 The getwc function (p: 369)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fgetwc](https://en.cppreference.com/w/c/io/fgetwc)"
- name: getwchar
  summary: Reads the next wide character from stdin
  description: "# getwchar\n\n[TABLE]\n\nReads the next wide character from [`stdin`](std_streams \"c/io/std streams\").\n\n### Parameters\n\n(none)\n\n### Return value\n\nthe obtained wide character or `WEOF` if an error has occurred or the end of file reached\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.3.7 The getwchar function (p: 424)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.3.7 The getwchar function (p: 369-370)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/getwchar](https://en.cppreference.com/w/c/io/getwchar)"
- name: gmtime
  summary: gmtime may not be thread-safe
  description: "# gmtime, gmtime_r, gmtime_s\n\n[TABLE]\n\n1) Converts given time since epoch (a [`time_t`](time_t \"c/chrono/time t\") value pointed to by `timer`) into calendar time, expressed in Coordinated Universal Time (UTC) in the [`struct tm`](tm \"c/chrono/tm\") format. The result is stored in static storage and a pointer to that static storage is returned.\n\n2) Same as (1), except that the function uses user-provided storage `buf` for the result.\n\n3) Same as (1), except that the function uses user-provided storage `buf` for the result and that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `timer` or `buf` is a null pointer\n\nAs with all bounds-checked functions, `gmtime_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<time.h>`](../chrono \"c/chrono\").\n\n### Parameters\n\n|       |     |                                                                                                     |\n|-------|-----|-----------------------------------------------------------------------------------------------------|\n| timer | \\-  | pointer to a [`time_t`](time_t \"c/chrono/time t\") object to convert                                 |\n| buf   | \\-  | pointer to a `struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm) object to store the result |\n\n### Return value\n\n1) pointer to a static internal [`tm`](tm \"c/chrono/tm\") object on success, or null pointer otherwise. The structure may be shared between `gmtime`, [`localtime`](localtime \"c/chrono/localtime\"), and [`ctime`](ctime \"c/chrono/ctime\") and may be overwritten on each invocation.\n\n2-3) copy of the `buf` pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to UTC)\n\n### Notes\n\n`gmtime` may not be thread-safe.\n\nPOSIX requires that `gmtime` and `gmtime_r` set [`errno`](../error/errno \"c/error/errno\") to [`EOVERFLOW`](../error/errno_macros \"c/error/errno macros\") if they fail because the argument is too large.\n\nThe implementation of `gmtime_s` in [Microsoft CRT](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/gmtime-s-gmtime32-s-gmtime64-s?view=vs-2019) is incompatible with the C standard since it has reversed parameter order.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#define _XOPEN_SOURCE // for putenv\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>   // for putenv\n \nint main(void)\n{\n    time_t t = time(NULL);\n    printf(\"UTC:       %s\", asctime(gmtime(&t)));\n    printf(\"local:     %s\", asctime(localtime(&t)));\n    // POSIX-specific\n    putenv(\"TZ=Asia/Singapore\");\n    printf(\"Singapore: %s\", asctime(localtime(&t)));\n \n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n    asctime_s(str,sizeof str,gmtime_s(&t, &buf));\n    printf(\"UTC:       %s\", str);\n    asctime_s(str,sizeof str,localtime_s(&t, &buf));\n    printf(\"local:     %s\", str);\n#endif\n}\n```\n\nPossible output:\n\n```\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\nSingapore: Fri Sep 15 22:22:05 2017\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.3.3 The gmtime function (p: 288)\n  - K.3.8.2.3 The gmtime_s function (p: 454-455)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.3.3 The gmtime function (p: 393-394)\n  - K.3.8.2.3 The gmtime_s function (p: 626-627)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.3 The gmtime function (p: 343)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.3 The gmtime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/gmtime](https://en.cppreference.com/w/c/chrono/gmtime)"
- name: gmtime_r
  summary: gmtime may not be thread-safe
  description: "# gmtime, gmtime_r, gmtime_s\n\n[TABLE]\n\n1) Converts given time since epoch (a [`time_t`](time_t \"c/chrono/time t\") value pointed to by `timer`) into calendar time, expressed in Coordinated Universal Time (UTC) in the [`struct tm`](tm \"c/chrono/tm\") format. The result is stored in static storage and a pointer to that static storage is returned.\n\n2) Same as (1), except that the function uses user-provided storage `buf` for the result.\n\n3) Same as (1), except that the function uses user-provided storage `buf` for the result and that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `timer` or `buf` is a null pointer\n\nAs with all bounds-checked functions, `gmtime_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<time.h>`](../chrono \"c/chrono\").\n\n### Parameters\n\n|       |     |                                                                                                     |\n|-------|-----|-----------------------------------------------------------------------------------------------------|\n| timer | \\-  | pointer to a [`time_t`](time_t \"c/chrono/time t\") object to convert                                 |\n| buf   | \\-  | pointer to a `struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm) object to store the result |\n\n### Return value\n\n1) pointer to a static internal [`tm`](tm \"c/chrono/tm\") object on success, or null pointer otherwise. The structure may be shared between `gmtime`, [`localtime`](localtime \"c/chrono/localtime\"), and [`ctime`](ctime \"c/chrono/ctime\") and may be overwritten on each invocation.\n\n2-3) copy of the `buf` pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to UTC)\n\n### Notes\n\n`gmtime` may not be thread-safe.\n\nPOSIX requires that `gmtime` and `gmtime_r` set [`errno`](../error/errno \"c/error/errno\") to [`EOVERFLOW`](../error/errno_macros \"c/error/errno macros\") if they fail because the argument is too large.\n\nThe implementation of `gmtime_s` in [Microsoft CRT](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/gmtime-s-gmtime32-s-gmtime64-s?view=vs-2019) is incompatible with the C standard since it has reversed parameter order.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#define _XOPEN_SOURCE // for putenv\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>   // for putenv\n \nint main(void)\n{\n    time_t t = time(NULL);\n    printf(\"UTC:       %s\", asctime(gmtime(&t)));\n    printf(\"local:     %s\", asctime(localtime(&t)));\n    // POSIX-specific\n    putenv(\"TZ=Asia/Singapore\");\n    printf(\"Singapore: %s\", asctime(localtime(&t)));\n \n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n    asctime_s(str,sizeof str,gmtime_s(&t, &buf));\n    printf(\"UTC:       %s\", str);\n    asctime_s(str,sizeof str,localtime_s(&t, &buf));\n    printf(\"local:     %s\", str);\n#endif\n}\n```\n\nPossible output:\n\n```\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\nSingapore: Fri Sep 15 22:22:05 2017\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.3.3 The gmtime function (p: 288)\n  - K.3.8.2.3 The gmtime_s function (p: 454-455)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.3.3 The gmtime function (p: 393-394)\n  - K.3.8.2.3 The gmtime_s function (p: 626-627)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.3 The gmtime function (p: 343)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.3 The gmtime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/gmtime](https://en.cppreference.com/w/c/chrono/gmtime)"
- name: gmtime_s
  summary: gmtime may not be thread-safe
  description: "# gmtime, gmtime_r, gmtime_s\n\n[TABLE]\n\n1) Converts given time since epoch (a [`time_t`](time_t \"c/chrono/time t\") value pointed to by `timer`) into calendar time, expressed in Coordinated Universal Time (UTC) in the [`struct tm`](tm \"c/chrono/tm\") format. The result is stored in static storage and a pointer to that static storage is returned.\n\n2) Same as (1), except that the function uses user-provided storage `buf` for the result.\n\n3) Same as (1), except that the function uses user-provided storage `buf` for the result and that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `timer` or `buf` is a null pointer\n\nAs with all bounds-checked functions, `gmtime_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<time.h>`](../chrono \"c/chrono\").\n\n### Parameters\n\n|       |     |                                                                                                     |\n|-------|-----|-----------------------------------------------------------------------------------------------------|\n| timer | \\-  | pointer to a [`time_t`](time_t \"c/chrono/time t\") object to convert                                 |\n| buf   | \\-  | pointer to a `struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm) object to store the result |\n\n### Return value\n\n1) pointer to a static internal [`tm`](tm \"c/chrono/tm\") object on success, or null pointer otherwise. The structure may be shared between `gmtime`, [`localtime`](localtime \"c/chrono/localtime\"), and [`ctime`](ctime \"c/chrono/ctime\") and may be overwritten on each invocation.\n\n2-3) copy of the `buf` pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to UTC)\n\n### Notes\n\n`gmtime` may not be thread-safe.\n\nPOSIX requires that `gmtime` and `gmtime_r` set [`errno`](../error/errno \"c/error/errno\") to [`EOVERFLOW`](../error/errno_macros \"c/error/errno macros\") if they fail because the argument is too large.\n\nThe implementation of `gmtime_s` in [Microsoft CRT](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/gmtime-s-gmtime32-s-gmtime64-s?view=vs-2019) is incompatible with the C standard since it has reversed parameter order.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#define _XOPEN_SOURCE // for putenv\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>   // for putenv\n \nint main(void)\n{\n    time_t t = time(NULL);\n    printf(\"UTC:       %s\", asctime(gmtime(&t)));\n    printf(\"local:     %s\", asctime(localtime(&t)));\n    // POSIX-specific\n    putenv(\"TZ=Asia/Singapore\");\n    printf(\"Singapore: %s\", asctime(localtime(&t)));\n \n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n    asctime_s(str,sizeof str,gmtime_s(&t, &buf));\n    printf(\"UTC:       %s\", str);\n    asctime_s(str,sizeof str,localtime_s(&t, &buf));\n    printf(\"local:     %s\", str);\n#endif\n}\n```\n\nPossible output:\n\n```\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\nSingapore: Fri Sep 15 22:22:05 2017\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.3.3 The gmtime function (p: 288)\n  - K.3.8.2.3 The gmtime_s function (p: 454-455)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.3.3 The gmtime function (p: 393-394)\n  - K.3.8.2.3 The gmtime_s function (p: 626-627)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.3 The gmtime function (p: 343)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.3 The gmtime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/gmtime](https://en.cppreference.com/w/c/chrono/gmtime)"
- name: goto
  summary: ''
  description: "# C keywords: goto\n\n### Usage\n\n- [`goto` statement](../language/goto \"c/language/goto\"): as the declaration of the statement\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/goto](https://en.cppreference.com/w/c/keyword/goto)"
- name: goto statement
  summary: Transfers control unconditionally to the desired location
  description: "# goto statement\n\nTransfers control unconditionally to the desired location.\n\nUsed when it is otherwise impossible to transfer control to the desired location using conventional constructs.\n\n### Syntax\n\n|                                          |     |     |\n|------------------------------------------|-----|-----|\n| attr-spec-seq(optional) `goto` label `;` |     |     |\n\n|               |     |                                                                                                         |\n|---------------|-----|---------------------------------------------------------------------------------------------------------|\n| label         | \\-  | target [label](statements#Labels \"c/language/statements\") for the `goto` statement                      |\n| attr-spec-seq | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the `goto` statement |\n\n### Explanation\n\nThe `goto` statement causes an unconditional jump (transfer of control) to the statement prefixed by the named label (which must appear in the same function as the goto statement), except when this jump would enter the scope of a [variable-length array](array \"c/language/array\") or another [variably-modified type](declarations \"c/language/declarations\").(since C99)\n\nA label is an identifier followed by a colon (`:`) and a statement(until C23). Labels are the only identifiers that have *function scope*: they can be used (in a goto statement) anywhere in the same function in which they appear. There may be multiple labels before any statement.\n\n[TABLE]\n\n### Keywords\n\n[`goto`](../keyword/goto \"c/keyword/goto\")\n\n### Notes\n\n|                                                                                                                                                                                               |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Because declarations are not statements, a label before a declaration must use a null statement (a semicolon immediately after the colon). Same applies to a label before the end of a block. | (until C23) |\n\nC++ imposes additional limitations on the `goto` statement, but allows labels before declarations (which are statements in C++).\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    // goto can be used to leave a multi-level loop easily\n    for (int x = 0; x < 3; x++) {\n        for (int y = 0; y < 3; y++) {\n            printf(\"(%d;%d)\\n\",x,y);\n            if (x + y >= 3) goto endloop;\n        }\n    }\nendloop:;\n}\n```\n\nOutput:\n\n```\n(0;0)\n(0;1)\n(0;2)\n(1;0)\n(1;1)\n(1;2)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.8.6.1 The goto statement (p: 110-111)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.8.6.1 The goto statement (p: 152-153)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.8.6.1 The goto statement (p: 137-138)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.6.6.1 The goto statement\n\n### See also\n\n|                                                                                                               |     |\n|---------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/goto \"cpp/language/goto\") for `goto` statement |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/goto](https://en.cppreference.com/w/c/language/goto)"
- name: History of C
  summary: ''
  description: "# History of C\n\n## Early C\n\n- 1969: B created, based on BCPL, to replace PDP-7 assembler as the system programming language for Unix\n  - added operators `++`, `--`, compound assignment, remained a typeless language like BCPL\n- 1971: NB (\"new B\") created when porting B to PDP-11\n  - types (`int`, `char`, arrays and pointers), array-to-pointer conversion, compilation to machine code\n- 1972: Language renamed to C\n  - `struct`, operators `&&` and `||`, preprocessor, portable I/O\n- 1973: Unix re-written in C\n  - `unsigned`, `long`, `union`, enumerations, increased type safety\n- 1978: The C Programming Language, 1st edition\n\n## Standard C\n\n- 1983: ANSI established X3J11 committee\n- 1988: The C Programming Language, 2nd edition\n- 1989: **C89**, the ANSI C standard published\n\n1.  codified existing practices\n2.  new features: `volatile`, `enum`, `signed`, `void`, locales\n3.  From C++: `const`, function prototypes\n\n- 1990: **C90**, the ANSI C standard accepted as ISO/IEC 9899:1990\n- 1994: Technical corrigendum 1 (ISO/IEC 9899:1990/Cor.1:1994)\n  - [44 small changes](https://open-std.org/JTC1/SC22/WG14/www/docs/tc1.htm)\n- 1995: **C95** (ISO/IEC 9899:1990/Amd.1:1995) ([online store](https://infostore.saiglobal.com/store/Details.aspx?DocN=isoc000767513))\n\n1.  greatly expanded wide and multibyte character support (`<wctype.h>`, `<wchar.h>`, additions and changes to stream I/O, etc)\n2.  digraphs, `<iso646.h>`,\n\n- 1996: Technical corrigendum 2 (ISO/IEC 9899:1990/Cor.2:1996)\n  - [24 small changes](https://open-std.org/JTC1/SC22/WG14/www/docs/tc2.htm)\n- 1999: **C99** (ISO/IEC 9899:1999)\n\n1.  new features: `bool`, `long long`, `<stdint.h>`, `<inttypes.h>`, `restrict`, compound literals, variable length arrays, flexible array members, designated initializers, `<fenv.h>`, variadic macros, complex numbers, `__func__`, hexadecimal floating point format (`%a`), monetary formatting in [`lconv`](../locale/lconv \"c/locale/lconv\"), [`isblank`](../string/byte/isblank \"c/string/byte/isblank\"), concatenation of narrow and wide string literals, trailing comma in enumerations, empty arguments in function-like macros, `STDC_*` pragmas, `va_copy`, null return of [`tmpnam`](../io/tmpnam \"c/io/tmpnam\"), null pointer in [`setvbuf`](../io/setvbuf \"c/io/setvbuf\"), `hh` and `ll` length-specifiers in [`printf`](../io/fprintf \"c/io/fprintf\"), [`snprintf`](../io/fprintf \"c/io/fprintf\"), [`_Exit`](../program/_exit \"c/program/ Exit\"), `<tgmath.h>`, POSIX-like [`strftime`](../chrono/strftime \"c/chrono/strftime\") specifiers\n2.  from C++: `inline`, mix declarations and code, declarations in the init-clause of the for loop, `//` comments, universal character names in source code\n3.  removed implicit functions and implicit `int`\n\n- 2001: Technical corrigendum 1 (ISO/IEC 9899:1999/Cor.1:2001)\n  - [11 defects fixed](https://open-std.org/JTC1/SC22/WG14/www/docs/9899tc1/.)\n- 2004: Technical corrigendum 2 (ISO/IEC 9899:1999/Cor.2:2004)\n- 2004: Unicode TR (ISO/IEC TR 19769:2004) ([ISO store](https://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=33907)) ([N1040](https://open-std.org/JTC1/SC22/WG14/www/docs/n1040.pdf) November 7, 2003 draft)\n- 2007: Technical corrigendum 3 (ISO/IEC 9899:1999/Cor.3:2007) ([N1256](https://open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf) September 7, 2007 draft)\n  - deprecated [`gets`](../io/gets \"c/io/gets\")\n- 2007: Bounds-checking interfaces TR (ISO/IEC TR 24731-1:2007) ([ISO store](https://www.iso.org/iso/catalogue_detail.htm?csnumber=38841)) ([N1225](https://open-std.org/JTC1/SC22/WG14/www/docs/n1225.pdf) March 28, 2007 draft)\n- 2008: Embedded TR (ISO/IEC TR 18037:2008) ([ISO store](https://www.iso.org/iso/catalogue_detail.htm?csnumber=51126)) ([N1021](https://open-std.org/JTC1/SC22/WG14/www/docs/n1021.pdf) September 24, 2003 draft)\n- 2009: Decimal floating-point TR (ISO/IEC TR 24732:2009) ([ISO store](https://www.iso.org/iso/catalogue_detail.htm?csnumber=38842)) ([N1241](https://open-std.org/JTC1/SC22/WG14/www/docs/n1241.pdf) July 5, 2007 draft)\n- 2009: Mathematical special functions TR (ISO/IEC TR 24747:2009) ([ISO store](https://www.iso.org/iso/catalogue_detail.htm?csnumber=38857)) ([N1182](https://open-std.org/JTC1/SC22/WG14/www/docs/n1182.pdf) August 2, 2006 draft)\n- 2010: Dynamic allocations functions TR (ISO/IEC TR 24731-2:2010) ([ISO store](https://www.iso.org/iso/catalogue_detail.htm?csnumber=51678)) ([N1388](https://open-std.org/JTC1/SC22/WG14/www/docs/n1388.pdf) June 1, 2009 draft)\n- 2011: **C11** (ISO/IEC 9899:2011) ([ISO store](https://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=57853)) ([ANSI store](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS%2fISO%2fIEC+9899-2012#.UGCvLIHyaHM)) ([N1570](https://open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf) April 12, 2011 draft)\n\n1.  thread-aware memory model, `<stdatomic.h>`, `<threads.h>`, type-generic functions, `alignas`/`alignof`, `noreturn`, `static_assert`, analyzability extensions, extensions to complex and imaginary types, anonymous structures and unions, exclusive file open mode, [`quick_exit`](../program/quick_exit \"c/program/quick exit\")\n2.  removed [`gets`](../io/gets \"c/io/gets\")\n3.  from Bounds-checking interfaces TR: bounds-checking interfaces,\n4.  from Unicode TR: `char16_t`, `char32_t`, and `<uchar.h>`\n\n- 2012: Technical corrigendum 1 (ISO/IEC 9899:2011/Cor 1:2012) ([ISO store](https://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=61717))\n  - Fixes [DR 411](https://open-std.org/JTC1/SC22/WG14/www/docs/n2244.htm#dr_411)\n- 2013: Secure Coding Rules TS (ISO/IEC TS 17961:2013) ([ISO store](https://www.iso.org/iso/catalogue_detail.htm?csnumber=61134)) ([N1718](https://open-std.org/JTC1/SC22/WG14/www/docs/n1718.pdf) May 30, 2013)\n- 2014: FP TS part 1: Binary floating-point arithmetic (ISO/IEC TS 18661-1:2014) ([ISO store](https://www.iso.org/iso/catalogue_detail.htm?csnumber=63146)) ([N1778](https://open-std.org/JTC1/SC22/WG14/www/docs/n1778.pdf) 2013 draft)\n\n1.  provides changes to C11 (mostly to Annex F) that cover all basic requirements and some recommendations of IEC 60559:2011 (C11 was built on IEC 60559:1989)\n\n- 2015: FP TS part 2: Decimal floating-point arithmetic (ISO/IEC TS 18661-2:2015) ([ISO store](https://www.iso.org/iso/home/store/catalogue_ics/catalogue_detail_ics.htm?csnumber=68882)) ([N1912](https://open-std.org/JTC1/SC22/WG14/www/docs/n1912.pdf) 2015 draft)\n\n1.  provides changes to C11 to support all the requirements, plus some basic recommendations, of IEC 60559:2011 for decimal floating-point arithmetic. This supersedes ISO/IEC TR 24732:2009.\n\n- 2015: FP TS part 3: Interchange and extended types (ISO/IEC TS 18661-3:2015) ([ISO store](https://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=65615)) ([N1945](https://open-std.org/JTC1/SC22/WG14/www/docs/n1945.pdf) 2015 draft)\n\n1.  provides changes to C11 to support the recommendations of IEC 60559:2011 for extended floating‐point formats and the interchange formats, both arithmetic and non-arithmetic.\n\n- 2015: FP TS part 4: Supplementary functions (ISO/IEC TS 18661-4:2015) ([ISO store](https://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=65616)) ([N1950](https://open-std.org/JTC1/SC22/WG14/www/docs/n1950.pdf) 2015 draft)\n\n1.  provides changes to C11 to support all mathematical operations recommended by IEC 60559:2011, including trigonometry in π units, inverse square root, compounded interest, etc.\n\n- 2016: FP TS part 5: Supplementary attributes (ISO/IEC TS 18661-5:2016) ([ISO store](https://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=65617)) ([N2004](https://open-std.org/JTC1/SC22/WG14/www/docs/n2004.pdf) 2016 draft)\n\n1.  provides changes to C11 to support all supplementary attributes (evaluation model, exception handling, reproducibility, etc) recommended by IEC 60559:2011\n\n- 2018: **C17** (ISO/IEC 9899:2018) ([ISO Store](https://www.iso.org/standard/74528.html)) ([Final draft](https://files.lhmouse.com/standards/ISO%20C%20N2176.pdf))\n\n[Main Article: C17](../17 \"c/17\")\n\n[TABLE]\n\n### Future development\n\n- Parallelism TS (Draft [N2017](https://open-std.org/JTC1/SC22/WG14/www/docs/n2017.pdf) 2016-03-10)\n- Transactional Memory TS (Draft [N1961](https://open-std.org/JTC1/SC22/WG14/www/docs/n1961.pdf) 2015-09-23)\n- **C23** (Latest draft [n3096](https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf) 2023-04-01)\n\n1.  List of issues that were not granted DR status: ([N2556](https://open-std.org/JTC1/SC22/WG14/www/docs/n2556.pdf) 2020-08-02)\n\n[Main Article: C23](../23 \"c/23\")\n\nNext major C language standard revision\n\n[TABLE]\n\n### See also\n\n|                                                                                                                   |     |\n|-------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/history \"cpp/language/history\") for History of C++ |     |\n\n### External links\n\n|     |                                                                                                            |\n|-----|------------------------------------------------------------------------------------------------------------|\n| 1\\. | [The Development of the C Language](https://www.bell-labs.com/usr/dmr/www/chist.html) by Dennis M. Ritchie |\n| 2\\. | [Rationale for the C99 standard](https://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf)        |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/history](https://en.cppreference.com/w/c/language/history)"
- name: HUGE_VAL
  summary: The HUGE_VALF, HUGE_VAL and HUGE_VALL macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see math_errhandling)
  description: "# HUGE_VALF, HUGE_VAL, HUGE_VALL\n\n[TABLE]\n\nThe `HUGE_VALF`, `HUGE_VAL` and `HUGE_VALL` macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\")).\n\n| Constant    | Explanation                                                                                                                  |\n|-------------|------------------------------------------------------------------------------------------------------------------------------|\n| `HUGE_VALF` | Expands to positive `float` expression that indicates overflow                                                               |\n| `HUGE_VAL`  | Expands to positive `double` expression that indicates overflow, not necessarily representable as a `float`                  |\n| `HUGE_VALL` | Expands to positive `long double` expression that indicates overflow, not necessarily representable as a `float` or `double` |\n\nOn implementations that support floating-point infinities, these macros always expand to the positive infinities of `float`, `double`, and `long double`, respectively.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    const double result = 1.0 / 0.0;\n    printf(\"1.0/0.0 == %f\\n\", result);\n    if (result == HUGE_VAL)\n        puts(\"1.0/0.0 == HUGE_VAL\");\n}\n```\n\nPossible output:\n\n```\n1.0/0.0 == inf\n1.0/0.0 == HUGE_VAL\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n  - F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n  - F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 231)\n  - F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 517)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 212)\n  - F.9/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 454)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5 HUGE_VAL\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/HUGE_VAL](https://en.cppreference.com/w/c/numeric/math/HUGE_VAL)"
- name: HUGE_VALF
  summary: The HUGE_VALF, HUGE_VAL and HUGE_VALL macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see math_errhandling)
  description: "# HUGE_VALF, HUGE_VAL, HUGE_VALL\n\n[TABLE]\n\nThe `HUGE_VALF`, `HUGE_VAL` and `HUGE_VALL` macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\")).\n\n| Constant    | Explanation                                                                                                                  |\n|-------------|------------------------------------------------------------------------------------------------------------------------------|\n| `HUGE_VALF` | Expands to positive `float` expression that indicates overflow                                                               |\n| `HUGE_VAL`  | Expands to positive `double` expression that indicates overflow, not necessarily representable as a `float`                  |\n| `HUGE_VALL` | Expands to positive `long double` expression that indicates overflow, not necessarily representable as a `float` or `double` |\n\nOn implementations that support floating-point infinities, these macros always expand to the positive infinities of `float`, `double`, and `long double`, respectively.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    const double result = 1.0 / 0.0;\n    printf(\"1.0/0.0 == %f\\n\", result);\n    if (result == HUGE_VAL)\n        puts(\"1.0/0.0 == HUGE_VAL\");\n}\n```\n\nPossible output:\n\n```\n1.0/0.0 == inf\n1.0/0.0 == HUGE_VAL\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n  - F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n  - F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 231)\n  - F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 517)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 212)\n  - F.9/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 454)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5 HUGE_VAL\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/HUGE_VAL](https://en.cppreference.com/w/c/numeric/math/HUGE_VAL)"
- name: HUGE_VALL
  summary: The HUGE_VALF, HUGE_VAL and HUGE_VALL macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see math_errhandling)
  description: "# HUGE_VALF, HUGE_VAL, HUGE_VALL\n\n[TABLE]\n\nThe `HUGE_VALF`, `HUGE_VAL` and `HUGE_VALL` macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\")).\n\n| Constant    | Explanation                                                                                                                  |\n|-------------|------------------------------------------------------------------------------------------------------------------------------|\n| `HUGE_VALF` | Expands to positive `float` expression that indicates overflow                                                               |\n| `HUGE_VAL`  | Expands to positive `double` expression that indicates overflow, not necessarily representable as a `float`                  |\n| `HUGE_VALL` | Expands to positive `long double` expression that indicates overflow, not necessarily representable as a `float` or `double` |\n\nOn implementations that support floating-point infinities, these macros always expand to the positive infinities of `float`, `double`, and `long double`, respectively.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    const double result = 1.0 / 0.0;\n    printf(\"1.0/0.0 == %f\\n\", result);\n    if (result == HUGE_VAL)\n        puts(\"1.0/0.0 == HUGE_VAL\");\n}\n```\n\nPossible output:\n\n```\n1.0/0.0 == inf\n1.0/0.0 == HUGE_VAL\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n  - F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n  - F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 231)\n  - F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 517)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 212)\n  - F.9/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 454)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5 HUGE_VAL\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/HUGE_VAL](https://en.cppreference.com/w/c/numeric/math/HUGE_VAL)"
- name: hypot
  summary: The value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length x and y, or the distance of the point (x,y) from the origin (0,0), or the magnitude of a complex number x+iy
  description: "# hypot, hypotf, hypotl\n\n[TABLE]\n\n1-3) Computes the square root of the sum of the squares of `x` and `y`, without undue overflow or underflow at intermediate stages of the computation.\n\n4) Type-generic macro: If any argument has type `long double`, the long double version of the function is called. Otherwise, if any argument has integer type or has type `double`, the double version of the function is called. Otherwise, the `float` version of the function is called.\n\nThe value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length `x` and `y`, or the distance of the point `(x,y)` from the origin `(0,0)`, or the magnitude of a complex number `x+`*`i`*`y`.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| x   | \\-  | floating point value |\n| y   | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the hypotenuse of a right-angled triangle, \\\\\\scriptsize{\\sqrt{x^2+y^2} }\\\\√x²+y², is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- `hypot(x, y)`, `hypot(y, x)`, and `hypot(x, -y)` are equivalent\n- if one of the arguments is ±0, `hypot` is equivalent to [`fabs`](http://en.cppreference.com/w/c/numeric/math/fabs) called with the non-zero argument\n- if one of the arguments is ±∞, `hypot` returns +∞ even if the other argument is NaN\n- otherwise, if any of the arguments is NaN, NaN is returned\n\n### Notes\n\nImplementations usually guarantee precision of less than 1 ulp ([units in the last place](https://en.wikipedia.org/wiki/Unit_in_the_last_place \"enwiki:Unit in the last place\")): [GNU](http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c), [BSD](http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c).\n\n`hypot(x, y)` is equivalent to [`cabs`](http://en.cppreference.com/w/c/numeric/complex/cabs)`(``x ``+`` I``*``y``)`.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/hypot.html) that underflow may only occur when both arguments are subnormal and the correct result is also subnormal (this forbids naive implementations).\n\n`hypot(INFINITY, NAN)` returns +∞, but [`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt)`(``INFINITY``*``INFINITY``+``NAN``*``NAN``)` returns NaN.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    // typical usage\n    printf(\"(1,1) cartesian is (%f,%f) polar\\n\", hypot(1,1), atan2(1,1));\n    // special values\n    printf(\"hypot(NAN,INFINITY) = %f\\n\", hypot(NAN,INFINITY));\n    // error handling \n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"hypot(DBL_MAX,DBL_MAX) = %f\\n\", hypot(DBL_MAX,DBL_MAX));\n    if(errno == ERANGE)         perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\n(1,1) cartesian is (1.414214,0.785398) polar\nhypot(NAN,INFINITY) = inf\nhypot(DBL_MAX,DBL_MAX) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.3 The hypot functions (p: 181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.3 The hypot functions (p: 382)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.3 The hypot functions (p: 248)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.3 The hypot functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.3 The hypot functions (p: 229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.3 The hypot functions (p: 461)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/hypot](https://en.cppreference.com/w/c/numeric/math/hypot)"
- name: hypotf
  summary: The value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length x and y, or the distance of the point (x,y) from the origin (0,0), or the magnitude of a complex number x+iy
  description: "# hypot, hypotf, hypotl\n\n[TABLE]\n\n1-3) Computes the square root of the sum of the squares of `x` and `y`, without undue overflow or underflow at intermediate stages of the computation.\n\n4) Type-generic macro: If any argument has type `long double`, the long double version of the function is called. Otherwise, if any argument has integer type or has type `double`, the double version of the function is called. Otherwise, the `float` version of the function is called.\n\nThe value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length `x` and `y`, or the distance of the point `(x,y)` from the origin `(0,0)`, or the magnitude of a complex number `x+`*`i`*`y`.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| x   | \\-  | floating point value |\n| y   | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the hypotenuse of a right-angled triangle, \\\\\\scriptsize{\\sqrt{x^2+y^2} }\\\\√x²+y², is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- `hypot(x, y)`, `hypot(y, x)`, and `hypot(x, -y)` are equivalent\n- if one of the arguments is ±0, `hypot` is equivalent to [`fabs`](http://en.cppreference.com/w/c/numeric/math/fabs) called with the non-zero argument\n- if one of the arguments is ±∞, `hypot` returns +∞ even if the other argument is NaN\n- otherwise, if any of the arguments is NaN, NaN is returned\n\n### Notes\n\nImplementations usually guarantee precision of less than 1 ulp ([units in the last place](https://en.wikipedia.org/wiki/Unit_in_the_last_place \"enwiki:Unit in the last place\")): [GNU](http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c), [BSD](http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c).\n\n`hypot(x, y)` is equivalent to [`cabs`](http://en.cppreference.com/w/c/numeric/complex/cabs)`(``x ``+`` I``*``y``)`.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/hypot.html) that underflow may only occur when both arguments are subnormal and the correct result is also subnormal (this forbids naive implementations).\n\n`hypot(INFINITY, NAN)` returns +∞, but [`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt)`(``INFINITY``*``INFINITY``+``NAN``*``NAN``)` returns NaN.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    // typical usage\n    printf(\"(1,1) cartesian is (%f,%f) polar\\n\", hypot(1,1), atan2(1,1));\n    // special values\n    printf(\"hypot(NAN,INFINITY) = %f\\n\", hypot(NAN,INFINITY));\n    // error handling \n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"hypot(DBL_MAX,DBL_MAX) = %f\\n\", hypot(DBL_MAX,DBL_MAX));\n    if(errno == ERANGE)         perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\n(1,1) cartesian is (1.414214,0.785398) polar\nhypot(NAN,INFINITY) = inf\nhypot(DBL_MAX,DBL_MAX) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.3 The hypot functions (p: 181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.3 The hypot functions (p: 382)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.3 The hypot functions (p: 248)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.3 The hypot functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.3 The hypot functions (p: 229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.3 The hypot functions (p: 461)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/hypot](https://en.cppreference.com/w/c/numeric/math/hypot)"
- name: hypotl
  summary: The value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length x and y, or the distance of the point (x,y) from the origin (0,0), or the magnitude of a complex number x+iy
  description: "# hypot, hypotf, hypotl\n\n[TABLE]\n\n1-3) Computes the square root of the sum of the squares of `x` and `y`, without undue overflow or underflow at intermediate stages of the computation.\n\n4) Type-generic macro: If any argument has type `long double`, the long double version of the function is called. Otherwise, if any argument has integer type or has type `double`, the double version of the function is called. Otherwise, the `float` version of the function is called.\n\nThe value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length `x` and `y`, or the distance of the point `(x,y)` from the origin `(0,0)`, or the magnitude of a complex number `x+`*`i`*`y`.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| x   | \\-  | floating point value |\n| y   | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the hypotenuse of a right-angled triangle, \\\\\\scriptsize{\\sqrt{x^2+y^2} }\\\\√x²+y², is returned.\n\nIf a range error due to overflow occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- `hypot(x, y)`, `hypot(y, x)`, and `hypot(x, -y)` are equivalent\n- if one of the arguments is ±0, `hypot` is equivalent to [`fabs`](http://en.cppreference.com/w/c/numeric/math/fabs) called with the non-zero argument\n- if one of the arguments is ±∞, `hypot` returns +∞ even if the other argument is NaN\n- otherwise, if any of the arguments is NaN, NaN is returned\n\n### Notes\n\nImplementations usually guarantee precision of less than 1 ulp ([units in the last place](https://en.wikipedia.org/wiki/Unit_in_the_last_place \"enwiki:Unit in the last place\")): [GNU](http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c), [BSD](http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c).\n\n`hypot(x, y)` is equivalent to [`cabs`](http://en.cppreference.com/w/c/numeric/complex/cabs)`(``x ``+`` I``*``y``)`.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/hypot.html) that underflow may only occur when both arguments are subnormal and the correct result is also subnormal (this forbids naive implementations).\n\n`hypot(INFINITY, NAN)` returns +∞, but [`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt)`(``INFINITY``*``INFINITY``+``NAN``*``NAN``)` returns NaN.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    // typical usage\n    printf(\"(1,1) cartesian is (%f,%f) polar\\n\", hypot(1,1), atan2(1,1));\n    // special values\n    printf(\"hypot(NAN,INFINITY) = %f\\n\", hypot(NAN,INFINITY));\n    // error handling \n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"hypot(DBL_MAX,DBL_MAX) = %f\\n\", hypot(DBL_MAX,DBL_MAX));\n    if(errno == ERANGE)         perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\n(1,1) cartesian is (1.414214,0.785398) polar\nhypot(NAN,INFINITY) = inf\nhypot(DBL_MAX,DBL_MAX) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.3 The hypot functions (p: 181)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.4.3 The hypot functions (p: 382)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.3 The hypot functions (p: 248)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.3 The hypot functions (p: 524)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.3 The hypot functions (p: 229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.3 The hypot functions (p: 461)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/hypot](https://en.cppreference.com/w/c/numeric/math/hypot)"
- name: I
  summary: The I macro expands to either _Complex_I or _Imaginary_I
  description: "# I\n\n[TABLE]\n\nThe `I` macro expands to either [`_Complex_I`](complex_i \"c/numeric/complex/Complex I\") or [`_Imaginary_I`](imaginary_i \"c/numeric/complex/Imaginary I\"). If the implementation does not support imaginary types, then the macro always expands to [`_Complex_I`](complex_i \"c/numeric/complex/Complex I\").\n\nA program may undefine and perhaps then redefine the macro `I`.\n\n### Notes\n\nThe macro is not named `i`, which is the name of the imaginary unit in mathematics, because the name `i` was already used in many C programs, e.g. as a loop counter variable.\n\nThe macro `I` is often used to form complex numbers, with expressions such as `x + y*I`. If `I` is defined as [`_Complex_I`](complex_i \"c/numeric/complex/Complex I\"), then such expression may create a value with imaginary component `+0.0` even when `y` is `-0.0`, which is significant for complex number functions with branch cuts. The macro [`CMPLX`](cmplx \"c/numeric/complex/CMPLX\") provides a way to construct a complex number precisely.\n\nGCC provides a non-portable extension that allows imaginary constants to be specified with the suffix `i` on integer literals: `1.0fi`, `1.0i`, and `1.0li` are imaginary units in GNU C. A similar approach is part of standard C++ as of C++14 (`1.0if`, `1.0i`, and `1.0il` are the imaginary units in C++)\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    printf(\"I = %.1f%+.1fi\\n\", creal(I), cimag(I));\n \n    double complex z1 = I * I;     // imaginary unit squared\n    printf(\"I * I = %.1f%+.1fi\\n\", creal(z1), cimag(z1));\n \n    double complex z = 1.0 + 2.0*I; // usual way to form a complex number pre-C11\n    printf(\"z = %.1f%+.1fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\nI = 0.0+1.0i\nI * I = -1.0+0.0i\nz = 1.0+2.0i\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.1/6 I (p: 188)\n  - G.6/1 I (p: 537)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.1/4 I (p: 170)\n  - G.6/1 I (p: 472)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/I](https://en.cppreference.com/w/c/numeric/complex/I)"
- name: Identifier
  summary: An identifier is an arbitrarily long sequence of digits, underscores, lowercase and uppercase Latin letters, and Unicode characters specified using \u and \U escape notation(since C99), of class XID_Continue(since C23)
  description: "# Identifier\n\nAn *identifier* is an arbitrarily long sequence of digits, underscores, lowercase and uppercase Latin letters, and Unicode characters specified using `\\u` and `\\U` [escape](escape \"c/language/escape\") notation(since C99), of class [XID_Continue](https://www.unicode.org/reports/tr31/#Table_Lexical_Classes_for_Identifiers)(since C23). A valid identifier must begin with a non-digit character (Latin letter, underscore, or Unicode non-digit character(since C99)(until C23), or Unicode character of class [XID_Start](https://www.unicode.org/reports/tr31/#Table_Lexical_Classes_for_Identifiers))(since C23)). Identifiers are case-sensitive (lowercase and uppercase letters are distinct). Every identifier must conform to [Normalization Form C](https://www.unicode.org/charts/normalization/).(since C23)\n\n[TABLE]\n\nIdentifiers can denote the following types of entities:\n\n- [objects](object \"c/language/object\")\n- [functions](functions \"c/language/functions\")\n- tags ([struct](struct \"c/language/struct\"), [union](union \"c/language/union\"), or [enumerations](enum \"c/language/enum\"))\n- structure or union members\n- enumeration constants\n- [typedef](typedef \"c/language/typedef\") names\n- [label](statements#Labels \"c/language/statements\") names\n- [macro](../preprocessor/replace \"c/preprocessor/replace\") names\n- [macro parameter](../preprocessor/replace \"c/preprocessor/replace\") names\n\nEvery identifier other than macro names or macro parameter names has [scope](scope \"c/language/scope\"), belongs to a [name space](name_space \"c/language/name space\"), and may have [linkage](storage_duration \"c/language/storage duration\"). The same identifier can denote different entities at different points in the program, or may denote different entities at the same point if the entities are in different name spaces.\n\n### Reserved identifiers\n\nThe following identifiers are *reserved* and may not be declared in a program (doing so invokes undefined behavior):\n\n1.  The identifiers that are [keywords](../keyword \"c/keyword\") cannot be used for other purposes. In particular \\#define or \\#undef of an identifier that is identical to a keyword is not allowed.\n2.  All external identifiers that begin with an underscore.\n3.  All identifiers that begin with an underscore followed by a capital letter or by another underscore (these reserved identifiers allow the library to use numerous behind-the-scenes non-external macros and functions).\n4.  All external identifiers defined by the standard library (in hosted environment). This means that no user-supplied external names are allowed to match any library names, not even if declaring a function that is identical to a library function.\n5.  Identifiers declared as reserved for the implementation or future use by the standard library (see below).\n6.  Identifiers declared as potentially reserved and provided by the implementation (see below). (since C23)\n\nAll other identifiers are available. Identifiers that are not reserved or potentially reserved(since C23) can be used with no fear of unexpected collisions when moving programs from one compiler and library to another.\n\nNote: in C++, identifiers with a double underscore anywhere are reserved everywhere; in C, only the ones that begin with a double underscore are reserved.\n\n#### Reserved and potentially reserved identifiers in the library\n\nThe standard library reserves every identifier it provides. Reserved identifiers that have [external linkage](storage_duration \"c/language/storage duration\") (e.g. name of every standard function) are reserved regardless which header is included. Other reserved identifiers are reserved when any of its associated headers is included.\n\n[TABLE]\n\nFollowing identifiers are reserved or potentially reserved(since C23) for the implementation or future use by the standard library.\n\n- *function names*, all of which are potentially reserved(since C23)\n  - `cerf`, `cerfc`, `cexp2`, `cexpm1`, `clog10`, `clog1p`, `clog2`, `clgamma`, `ctgamma`, `csinpi`, `ccospi`, `ctanpi`, `casinpi`, `cacospi`, `catanpi`, `ccompoundn`, `cpown`, `cpowr`, `crootn`, `crsqrt`, `cexp10m1`, `cexp10`, `cexp2m1`, `clog10p1`, `clog2p1`, `clogp1`(since C23) and their -f and -l suffixed variants, in [`<complex.h>`](../numeric/complex \"c/numeric/complex\") (since C99)\n  - beginning with `is` or `to` followed by a lowercase letter, in [`<ctype.h>`](../string/byte \"c/string/byte\") and [`<wctype.h>`](../string/wide \"c/string/wide\")(since C95)\n  - beginning with `str` or `wcs`(since C23) followed by a lowercase letter, in [`<stdlib.h>`](../string/byte \"c/string/byte\") and [`<inttypes.h>`](../types/integer \"c/types/integer\")(since C23)\n  - beginning with `cr_`, in [`<math.h>`](../numeric/math \"c/numeric/math\") (since C23)\n  - beginning with `wcs` followed by a lowercase letter, in [`<wchar.h>`](../string/wide \"c/string/wide\") (since C95)\n  - beginning with `atomic_` followed by a lowercase letter, in [`<stdatomic.h>`](../thread \"c/thread\") (since C11)\n  - beginning with `cnd_`, `mtx_`, `thrd_` or `tss_` followed by a lowercase letter, in [`<threads.h>`](../thread \"c/thread\") (since C11)\n- *typedef names*, all of which are potentially reserved(since C23)\n  - beginning with `int` or `uint` and ending with `_t`, in [`<stdint.h>`](../types/integer \"c/types/integer\") (since C99)\n  - beginning with `atomic_` or `memory_` followed by a lowercase letter, in [`<stdatomic.h>`](../thread \"c/thread\") (since C11)\n  - beginning with `cnd_`, `mtx_`, `thrd_` or `tss_` followed by a lowercase letter, in [`<threads.h>`](../thread \"c/thread\") (since C11)\n- *macro names*\n  - beginning with `E` followed by a digit or an uppercase letter, in [`<errno.h>`](../error/errno_macros \"c/error/errno macros\")\n  - beginning with `FE_` followed by an uppercase letter, in [`<fenv.h>`](../numeric/fenv \"c/numeric/fenv\") (since C99)\n  - beginning with `DBL_`, `DEC32_`, `DEC64_`, `DEC128_`, `DEC_`, `FLT_`, or `LDBL_` followed by an uppercase letter, in [`<float.h>`](../types/limits \"c/types/limits\"); these identifiers are potentially reserved (since C23)\n  - beginning with `INT` or `UINT` and ending with `_MAX`, `_MIN`, `_WIDTH`(since C23), or `_C`, in [`<stdint.h>`](../types/integer \"c/types/integer\"); these identifiers are potentially reserved(since C23) (since C99)\n  - beginning with `PRI` or `SCN` followed by lowercase letter or the letter `X`, in [`<inttypes.h>`](../types/integer \"c/types/integer\"); these identifiers are potentially reserved(since C23) (since C99)\n  - beginning with `LC_` followed by an uppercase letter, in [`<locale.h>`](../locale/lc_categories \"c/locale/LC categories\")\n  - beginning with `FP_` followed by an uppercase letter, in [`<math.h>`](../numeric/math \"c/numeric/math\") (since C23)\n  - beginning with `MATH_` followed by an uppercase letter, in [`<math.h>`](../numeric/math \"c/numeric/math\"); these identifiers are potentially reserved (since C23)\n  - beginning with `SIG` or `SIG_` followed by an uppercase letter, in [`<signal.h>`](../program \"c/program\")\n  - beginning with `TIME_` followed by an uppercase letter, in [`<time.h>`](../chrono/timespec_get \"c/chrono/timespec get\") (since C11)\n  - beginning with `ATOMIC_` followed by an uppercase letter, in [`<stdatomic.h>`](../thread \"c/thread\"); these identifiers are potentially reserved(since C23) (since C11)\n- *enumeration constants*, all of which are potentially reserved(since C23)\n  - beginning with `memory_order_` followed by a lowercase letter, in [`<stdatomic.h>`](../thread \"c/thread\") (since C11)\n  - beginning with `cnd_`, `mtx_`, `thrd_` or `tss_` followed by a lowercase letter, in [`<threads.h>`](../thread \"c/thread\") (since C11)\n\n[TABLE]\n\n### Translation limits\n\nEven though there is no specific limit on the length of identifiers, early compilers had limits on the number of significant initial characters in identifiers and the linkers imposed stricter limits on the names with [external linkage](storage_duration \"c/language/storage duration\"). C requires that at least the following limits are supported by any standard-compliant implementation:\n\n[TABLE]\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 5.2.4.1 Translation limits (p: 19-20)\n  - 6.4.2 Identifiers (p: 43)\n  - 6.10.8 Predefined macro names (p: 127-129)\n  - 6.11.9 Predefined macro names (p: 130)\n  - 7.31 Future library directions (p: 332-333)\n  - K.3.1.2 Reserved identifiers (p: 425)\n- C11 standard (ISO/IEC 9899:2011):\n  - 5.2.4.1 Translation limits (p: 25-26)\n  - 6.4.2 Identifiers (p: 59-60)\n  - 6.10.8 Predefined macro names (p: 175-176)\n  - 6.11.9 Predefined macro names (p: 179)\n  - 7.31 Future library directions (p: 455-457)\n  - K.3.1.2 Reserved identifiers (p: 584)\n- C99 standard (ISO/IEC 9899:1999):\n  - 5.2.4.1 Translation limits (p: 20-21)\n  - 6.4.2 Identifiers (p: 51-52)\n  - 6.10.8 Predefined macro names (p: 160-161)\n  - 6.11.9 Predefined macro names (p: 163)\n  - 7.26 Future library directions (p: 401-402)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 2.2.4.1 Translation limits\n  - 3.1.2 Identifiers\n  - 3.8.8 Predefined macro names\n\n### See also\n\n|                                                                                                                        |     |\n|------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/identifiers \"cpp/language/identifiers\") for Identifiers |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/identifier](https://en.cppreference.com/w/c/language/identifier)"
- name: if
  summary: ''
  description: "# C keywords: if\n\n### Usage\n\n- [`if` statement](../language/if \"c/language/if\"): as the declaration of the `if` statement\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/if](https://en.cppreference.com/w/c/keyword/if)"
- name: if statement
  summary: Conditionally executes code
  description: "# if statement\n\nConditionally executes code.\n\nUsed where code needs to be executed only if some condition is true.\n\n### Syntax\n\n|                                                                                     |       |     |\n|-------------------------------------------------------------------------------------|-------|-----|\n| attr-spec-seq(optional) `if (` expression `)` statement-true                        | \\(1\\) |     |\n| attr-spec-seq(optional) `if (` expression `)` statement-true `else` statement-false | \\(2\\) |     |\n\n|                 |     |                                                                                                                                             |\n|-----------------|-----|---------------------------------------------------------------------------------------------------------------------------------------------|\n| attr-spec-seq   | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the `if` statement                                       |\n| expression      | \\-  | an [expression](expressions \"c/language/expressions\") of any scalar type                                                                    |\n| statement-true  | \\-  | any [statement](statements \"c/language/statements\") (often a compound statement), which is executed if expression compares not equal to `​0​` |\n| statement-false | \\-  | any [statement](statements \"c/language/statements\") (often a compound statement), which is executed if expression compares equal to `​0​`     |\n\n### Explanation\n\nexpression must be an expression of any [scalar type](type#Type_groups \"c/language/type\").\n\nIf expression compares not equal to the integer zero, statement-true is executed.\n\nIn the form (2), if expression compares equal to the integer zero, statement_false is executed.\n\n[TABLE]\n\n### Notes\n\nThe `else` is always associated with the closest preceding `if` (in other words, if statement-true is also an if statement, then that inner if statement must contain an `else` part as well):\n\n```\nint j = 1;\nif (i > 1)\n   if(j > 2)\n       printf(\"%d > 1 and %d > 2\\n\", i, j);\n    else // this else is part of if(j>2), not part of if(i>1) \n       printf(\"%d > 1 and %d <= 2\\n\", i, j);\n```\n\nIf statement-true is entered through a [goto](goto \"c/language/goto\"), statement-false is not executed.\n\n### Keywords\n\n[`if`](../keyword/if \"c/keyword/if\"), [`else`](../keyword/else \"c/keyword/else\")\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    int i = 2;\n    if (i > 2) {\n        printf(\"first is true\\n\");\n    } else {\n        printf(\"first is false\\n\");\n    }\n \n    i = 3;\n    if (i == 3) printf(\"i == 3\\n\");\n \n    if (i != 3) printf(\"i != 3 is true\\n\");\n    else        printf(\"i != 3 is false\\n\");\n}\n```\n\nOutput:\n\n```\nfirst is false\ni == 3\ni != 3 is false\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.8.4.1 The if statement (p: 108-109)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.8.4.1 The if statement (p: 148-149)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.8.4.1 The if statement (p: 133-134)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.6.4.1 The if statement\n\n### See also\n\n|                                                                                                         |     |\n|---------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/if \"cpp/language/if\") for `if` statement |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/if](https://en.cppreference.com/w/c/language/if)"
- name: ignore_handler_s
  summary: The function simply returns to the caller without performing any other action
  description: "# ignore_handler_s\n\n[TABLE]\n\nThe function simply returns to the caller without performing any other action.\n\nA pointer to this function can be passed to [set_constraint_handler_s](set_constraint_handler_s \"c/error/set constraint handler s\") to establish a runtime constraints violation handler that does nothing. As with all bounds-checked functions, `ignore_handler_s` is only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including `<stdlib.h>`.\n\n### Parameters\n\n|       |     |                                                                                                                                                                                                                                          |\n|-------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| msg   | \\-  | pointer to character string that describes the error                                                                                                                                                                                     |\n| ptr   | \\-  | pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected |\n| error | \\-  | the error about to be returned by the calling function, if it happens to be one of the functions that return errno_t                                                                                                                     |\n\n### Return value\n\n(none)\n\n### Notes\n\nIf `ignore_handler_s` is used as a the runtime constraints handler, the violations may be detected by examining the results of the bounds-checked function calls, which may be different for different functions (non-zero `errno_t`, null character written to the first byte of the output string, etc)\n\nIf `set_constraint_handler_s` is never called, the default handler is implementation-defined: it may be `abort_handler_s`, `ignore_handler_s`, or some other implementation-defined handler.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n#ifdef __STDC_LIB_EXT1__\n    char dst[2];\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcpy_s(dst, sizeof dst, \"Too long!\");\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n    set_constraint_handler_s(abort_handler_s);\n    r = strcpy_s(dst, sizeof dst, \"Too long!\");\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n#endif\n}\n```\n\nPossible output:\n\n```\ndst = \"\", r = 22\nabort_handler_s was called in response to a runtime-constraint violation.\n \nThe runtime-constraint violation was caused by the following expression in strcpy_s:\n(s1max <= (s2_len=strnlen_s(s2, s1max)) ) (in string_s.c:62)\n \nNote to end users: This program was terminated as a result\nof a bug present in the software. Please reach out to your\nsoftware's vendor to get more help.\nAborted\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - K.3.6.1.3 The ignore_handler_s function (p: 606)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/error/ignore_handler_s](https://en.cppreference.com/w/c/error/ignore_handler_s)"
- name: ilogb
  summary: Formally, the unbiased exponent is the integral part of logr|arg| as a signed integral value, for non-zero arg, where r is FLT_RADIX
  description: "# ilogb, ilogbf, ilogbl\n\n[TABLE]\n\n1-3) Extracts the value of the unbiased exponent from the floating-point argument `arg`, and returns it as a signed integer value.\n\n4) Type-generic macros: If `arg` has type `long double`, `ilogbl` is called. Otherwise, if `arg` has integer type or the type `double`, `ilogb` is called. Otherwise, `ilogbf` is called.\n\n5) Expands to integer constant expression whose value is either [`INT_MIN`](../../types/limits \"c/types/limits\") or `-`[`INT_MAX`](http://en.cppreference.com/w/c/types/limits).\n\n6) Expands to integer constant expression whose value is either [`INT_MIN`](../../types/limits \"c/types/limits\") or `+`[`INT_MAX`](http://en.cppreference.com/w/c/types/limits).\n\nFormally, the unbiased exponent is the integral part of log_(r)\\|arg\\| as a signed integral value, for non-zero arg, where `r` is [`FLT_RADIX`](../../types/limits \"c/types/limits\").\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the unbiased exponent of `arg` is returned as a signed int value.\n\nIf `arg` is zero, `FP_ILOGB0` is returned.\n\nIf `arg` is infinite, [`INT_MAX`](../../types/limits \"c/types/limits\") is returned.\n\nIf `arg` is a NaN, `FP_ILOGBNAN` is returned.\n\nIf the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") or smaller than [`INT_MIN`](../../types/limits \"c/types/limits\"), the return value is unspecified and a domain error or range error may occur\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nA domain error or range error may occur if `arg` is zero, infinite, or NaN.\n\nIf the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") or smaller than [`INT_MIN`](../../types/limits \"c/types/limits\"), a domain error or a range error may occur\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") or smaller than [`INT_MIN`](../../types/limits \"c/types/limits\"), [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `arg` is ±0, ±∞, or NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- In all other cases, the result is exact ([`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised) and [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\nIf `arg` is not zero, infinite, or NaN, the value returned is exactly equivalent to `(``int``)`[`logb`](http://en.cppreference.com/w/c/numeric/math/logb)`(``arg``)`.\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/ilogb.html) that a domain error occurs if `arg` is zero, infinite, NaN, or if the correct result is outside of the range of `int`.\n\nPOSIX also requires that, on XSI-conformant systems, the value returned when the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") is [`INT_MAX`](../../types/limits \"c/types/limits\") and the value returned when the correct result is less than [`INT_MIN`](../../types/limits \"c/types/limits\") is [`INT_MIN`](../../types/limits \"c/types/limits\").\n\nThe correct result can be represented as `int` on all known implementations. For overflow to occur, [`INT_MAX`](../../types/limits \"c/types/limits\") must be less than [`LDBL_MAX_EXP`](http://en.cppreference.com/w/c/types/limits)`*``log2``(`[`FLT_RADIX`](http://en.cppreference.com/w/c/types/limits)`)` or [`INT_MIN`](../../types/limits \"c/types/limits\") must be greater than `LDBL_MIN_EXP``-`[`LDBL_MANT_DIG`](http://en.cppreference.com/w/c/types/limits)`)``*``log2``(`[`FLT_RADIX`](http://en.cppreference.com/w/c/types/limits)`)`.\n\nThe value of the exponent returned by `ilogb` is always 1 less than the exponent retuned by [`frexp`](frexp \"c/numeric/math/frexp\") because of the different normalization requirements: for the exponent `e` returned by `ilogb`, \\|arg\\*r^(-e)\\| is between 1 and `r` (typically between `1` and `2`), but for the exponent `e` returned by [`frexp`](frexp \"c/numeric/math/frexp\"), \\|arg\\*2^(-e)\\| is between `0.5` and `1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.0f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = ilogb(f);\n    printf(\"logb()/ilogb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"ilogb(0) = %d\\n\", ilogb(0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nilogb(0) = -2147483648\n    FE_INVALID raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/8 Mathematics \\<math.h\\> (p: 232)\n  - 7.12.6.5 The ilogb functions (p: 244)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.5 The ilogb functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/8 Mathematics \\<math.h\\> (p: 213)\n  - 7.12.6.5 The ilogb functions (p: 224-225)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.5 The ilogb functions (p: 458)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/ilogb](https://en.cppreference.com/w/c/numeric/math/ilogb)"
- name: ilogbf
  summary: Formally, the unbiased exponent is the integral part of logr|arg| as a signed integral value, for non-zero arg, where r is FLT_RADIX
  description: "# ilogb, ilogbf, ilogbl\n\n[TABLE]\n\n1-3) Extracts the value of the unbiased exponent from the floating-point argument `arg`, and returns it as a signed integer value.\n\n4) Type-generic macros: If `arg` has type `long double`, `ilogbl` is called. Otherwise, if `arg` has integer type or the type `double`, `ilogb` is called. Otherwise, `ilogbf` is called.\n\n5) Expands to integer constant expression whose value is either [`INT_MIN`](../../types/limits \"c/types/limits\") or `-`[`INT_MAX`](http://en.cppreference.com/w/c/types/limits).\n\n6) Expands to integer constant expression whose value is either [`INT_MIN`](../../types/limits \"c/types/limits\") or `+`[`INT_MAX`](http://en.cppreference.com/w/c/types/limits).\n\nFormally, the unbiased exponent is the integral part of log_(r)\\|arg\\| as a signed integral value, for non-zero arg, where `r` is [`FLT_RADIX`](../../types/limits \"c/types/limits\").\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the unbiased exponent of `arg` is returned as a signed int value.\n\nIf `arg` is zero, `FP_ILOGB0` is returned.\n\nIf `arg` is infinite, [`INT_MAX`](../../types/limits \"c/types/limits\") is returned.\n\nIf `arg` is a NaN, `FP_ILOGBNAN` is returned.\n\nIf the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") or smaller than [`INT_MIN`](../../types/limits \"c/types/limits\"), the return value is unspecified and a domain error or range error may occur\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nA domain error or range error may occur if `arg` is zero, infinite, or NaN.\n\nIf the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") or smaller than [`INT_MIN`](../../types/limits \"c/types/limits\"), a domain error or a range error may occur\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") or smaller than [`INT_MIN`](../../types/limits \"c/types/limits\"), [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `arg` is ±0, ±∞, or NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- In all other cases, the result is exact ([`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised) and [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\nIf `arg` is not zero, infinite, or NaN, the value returned is exactly equivalent to `(``int``)`[`logb`](http://en.cppreference.com/w/c/numeric/math/logb)`(``arg``)`.\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/ilogb.html) that a domain error occurs if `arg` is zero, infinite, NaN, or if the correct result is outside of the range of `int`.\n\nPOSIX also requires that, on XSI-conformant systems, the value returned when the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") is [`INT_MAX`](../../types/limits \"c/types/limits\") and the value returned when the correct result is less than [`INT_MIN`](../../types/limits \"c/types/limits\") is [`INT_MIN`](../../types/limits \"c/types/limits\").\n\nThe correct result can be represented as `int` on all known implementations. For overflow to occur, [`INT_MAX`](../../types/limits \"c/types/limits\") must be less than [`LDBL_MAX_EXP`](http://en.cppreference.com/w/c/types/limits)`*``log2``(`[`FLT_RADIX`](http://en.cppreference.com/w/c/types/limits)`)` or [`INT_MIN`](../../types/limits \"c/types/limits\") must be greater than `LDBL_MIN_EXP``-`[`LDBL_MANT_DIG`](http://en.cppreference.com/w/c/types/limits)`)``*``log2``(`[`FLT_RADIX`](http://en.cppreference.com/w/c/types/limits)`)`.\n\nThe value of the exponent returned by `ilogb` is always 1 less than the exponent retuned by [`frexp`](frexp \"c/numeric/math/frexp\") because of the different normalization requirements: for the exponent `e` returned by `ilogb`, \\|arg\\*r^(-e)\\| is between 1 and `r` (typically between `1` and `2`), but for the exponent `e` returned by [`frexp`](frexp \"c/numeric/math/frexp\"), \\|arg\\*2^(-e)\\| is between `0.5` and `1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.0f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = ilogb(f);\n    printf(\"logb()/ilogb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"ilogb(0) = %d\\n\", ilogb(0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nilogb(0) = -2147483648\n    FE_INVALID raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/8 Mathematics \\<math.h\\> (p: 232)\n  - 7.12.6.5 The ilogb functions (p: 244)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.5 The ilogb functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/8 Mathematics \\<math.h\\> (p: 213)\n  - 7.12.6.5 The ilogb functions (p: 224-225)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.5 The ilogb functions (p: 458)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/ilogb](https://en.cppreference.com/w/c/numeric/math/ilogb)"
- name: ilogbl
  summary: Formally, the unbiased exponent is the integral part of logr|arg| as a signed integral value, for non-zero arg, where r is FLT_RADIX
  description: "# ilogb, ilogbf, ilogbl\n\n[TABLE]\n\n1-3) Extracts the value of the unbiased exponent from the floating-point argument `arg`, and returns it as a signed integer value.\n\n4) Type-generic macros: If `arg` has type `long double`, `ilogbl` is called. Otherwise, if `arg` has integer type or the type `double`, `ilogb` is called. Otherwise, `ilogbf` is called.\n\n5) Expands to integer constant expression whose value is either [`INT_MIN`](../../types/limits \"c/types/limits\") or `-`[`INT_MAX`](http://en.cppreference.com/w/c/types/limits).\n\n6) Expands to integer constant expression whose value is either [`INT_MIN`](../../types/limits \"c/types/limits\") or `+`[`INT_MAX`](http://en.cppreference.com/w/c/types/limits).\n\nFormally, the unbiased exponent is the integral part of log_(r)\\|arg\\| as a signed integral value, for non-zero arg, where `r` is [`FLT_RADIX`](../../types/limits \"c/types/limits\").\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the unbiased exponent of `arg` is returned as a signed int value.\n\nIf `arg` is zero, `FP_ILOGB0` is returned.\n\nIf `arg` is infinite, [`INT_MAX`](../../types/limits \"c/types/limits\") is returned.\n\nIf `arg` is a NaN, `FP_ILOGBNAN` is returned.\n\nIf the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") or smaller than [`INT_MIN`](../../types/limits \"c/types/limits\"), the return value is unspecified and a domain error or range error may occur\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nA domain error or range error may occur if `arg` is zero, infinite, or NaN.\n\nIf the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") or smaller than [`INT_MIN`](../../types/limits \"c/types/limits\"), a domain error or a range error may occur\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") or smaller than [`INT_MIN`](../../types/limits \"c/types/limits\"), [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `arg` is ±0, ±∞, or NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- In all other cases, the result is exact ([`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised) and [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\nIf `arg` is not zero, infinite, or NaN, the value returned is exactly equivalent to `(``int``)`[`logb`](http://en.cppreference.com/w/c/numeric/math/logb)`(``arg``)`.\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/ilogb.html) that a domain error occurs if `arg` is zero, infinite, NaN, or if the correct result is outside of the range of `int`.\n\nPOSIX also requires that, on XSI-conformant systems, the value returned when the correct result is greater than [`INT_MAX`](../../types/limits \"c/types/limits\") is [`INT_MAX`](../../types/limits \"c/types/limits\") and the value returned when the correct result is less than [`INT_MIN`](../../types/limits \"c/types/limits\") is [`INT_MIN`](../../types/limits \"c/types/limits\").\n\nThe correct result can be represented as `int` on all known implementations. For overflow to occur, [`INT_MAX`](../../types/limits \"c/types/limits\") must be less than [`LDBL_MAX_EXP`](http://en.cppreference.com/w/c/types/limits)`*``log2``(`[`FLT_RADIX`](http://en.cppreference.com/w/c/types/limits)`)` or [`INT_MIN`](../../types/limits \"c/types/limits\") must be greater than `LDBL_MIN_EXP``-`[`LDBL_MANT_DIG`](http://en.cppreference.com/w/c/types/limits)`)``*``log2``(`[`FLT_RADIX`](http://en.cppreference.com/w/c/types/limits)`)`.\n\nThe value of the exponent returned by `ilogb` is always 1 less than the exponent retuned by [`frexp`](frexp \"c/numeric/math/frexp\") because of the different normalization requirements: for the exponent `e` returned by `ilogb`, \\|arg\\*r^(-e)\\| is between 1 and `r` (typically between `1` and `2`), but for the exponent `e` returned by [`frexp`](frexp \"c/numeric/math/frexp\"), \\|arg\\*2^(-e)\\| is between `0.5` and `1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.0f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = ilogb(f);\n    printf(\"logb()/ilogb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"ilogb(0) = %d\\n\", ilogb(0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nilogb(0) = -2147483648\n    FE_INVALID raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/8 Mathematics \\<math.h\\> (p: 232)\n  - 7.12.6.5 The ilogb functions (p: 244)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.5 The ilogb functions (p: 521)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/8 Mathematics \\<math.h\\> (p: 213)\n  - 7.12.6.5 The ilogb functions (p: 224-225)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.5 The ilogb functions (p: 458)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/ilogb](https://en.cppreference.com/w/c/numeric/math/ilogb)"
- name: imaginary
  summary: This macro expands to the keyword _Imaginary
  description: "# imaginary\n\n[TABLE]\n\nThis macro expands to the keyword [`_Imaginary`](../../keyword/_imaginary \"c/keyword/ Imaginary\").\n\nThis is a convenience macro that makes it possible to use `float imaginary`, `double imaginary`, and `long double imaginary` as an alternative way to write the three pure imaginary C types `float _Imaginary`, `double _Imaginary`, and `long double _Imaginary`\n\nAs with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.\n\n[TABLE]\n\n### Notes\n\nPrograms are allowed to undefine and perhaps redefine the `imaginary` macro.\n\n### Example\n\n```\n#include <stdio.h>\n#include <complex.h>\n \nint main(void)\n{\n    double imaginary i = -2.0*I; // pure imaginary\n    double f = 1.0; // pure real\n    double complex z = f + i; // complex number\n    printf(\"z = %.1f%+.1fi\\n\", creal(z), cimag(z));\n}\n```\n\nOutput:\n\n```\nz = 1.0-2.0i\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.3.1/5 imaginary (p: 136)\n  - G.6/1 imaginary (p: 391-392)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.3.1/5 imaginary (p: 188)\n  - G.6/1 imaginary (p: 537)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.3.1/3 imaginary (p: 170)\n  - G.6/1 imaginary (p: 472)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/complex/imaginary](https://en.cppreference.com/w/c/numeric/complex/imaginary)"
- name: imaxabs
  summary: Computes the absolute value of an integer number
  description: "# abs, labs, llabs, imaxabs\n\n[TABLE]\n\nComputes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.\n\n### Parameters\n\n|     |     |               |\n|-----|-----|---------------|\n| n   | \\-  | integer value |\n\n### Return value\n\nThe absolute value of `n` (i.e. `|n|`), if it is representable.\n\n### Notes\n\nIn 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type `int`, [`INT_MIN`](../../types/limits \"c/types/limits\") is `-2147483648`, but the would-be result `2147483648` is greater than [`INT_MAX`](../../types/limits \"c/types/limits\"), which is `2147483647`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n \nint main(void)\n{\n    printf(\"abs(+3) = %d\\n\", abs(+3));\n    printf(\"abs(-3) = %d\\n\", abs(-3));\n \n//  printf(\"%+d\\n\", abs(INT_MIN)); // undefined behavior on 2's complement systems\n}\n```\n\nOutput:\n\n```\nabs(+3) = 3\nabs(-3) = 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.2.1 The imaxabs function (p: 159)\n  - 7.22.6.1 The abs, labs and llabs functions (p: 259)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.1 The imaxabs function (p: 218)\n  - 7.22.6.1 The abs, labs and llabs functions (p: 356)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.1 The imaxabs function (p: 199-200)\n  - 7.20.6.1 The abs, labs and llabs functions (p: 320)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.6.1 The abs function\n  - 4.10.6.3 The labs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/abs](https://en.cppreference.com/w/c/numeric/math/abs)"
- name: imaxdiv
  summary: Computes both the quotient and the remainder of the division of the numerator x by the denominator y
  description: "# div, ldiv, lldiv, imaxdiv\n\n[TABLE]\n\nComputes both the quotient and the remainder of the division of the numerator `x` by the denominator `y`.\n\n|                                                                                                                                                                                                       |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Computes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that `quot * y + rem == x`. | (until C99) |\n| Computes the quotient (the result of the expression `x / y`) and remainder (the result of the expression `x % y`) simultaneously.                                                                     | (since C99) |\n\n### Parameters\n\n|      |     |                |\n|------|-----|----------------|\n| x, y | \\-  | integer values |\n\n### Return value\n\nIf both the remainder and the quotient can be represented as objects of the corresponding type (`int`, `long`, `long long`, [`intmax_t`](http://en.cppreference.com/w/c/types/integer), respectively), returns both as an object of type `div_t`, `ldiv_t`, `lldiv_t`, `imaxdiv_t` defined as follows:\n\n## div_t\n\n```\nstruct div_t { int quot; int rem; };\n```\n\nor\n\n```\nstruct div_t { int rem; int quot; };\n```\n\n## ldiv_t\n\n```\nstruct ldiv_t { long quot; long rem; };\n```\n\nor\n\n```\nstruct ldiv_t { long rem; long quot; };\n```\n\n## lldiv_t\n\n```\nstruct lldiv_t { long long quot; long long rem; };\n```\n\nor\n\n```\nstruct lldiv_t { long long rem; long long quot; };\n```\n\n## imaxdiv_t\n\n```\nstruct imaxdiv_t { intmax_t quot; intmax_t rem; };\n```\n\nor\n\n```\nstruct imaxdiv_t { intmax_t rem; intmax_t quot; };\n```\n\nIf either the remainder or the quotient cannot be represented, the behavior is undefined.\n\n### Notes\n\nUntil C99, the rounding direction of the quotient and the sign of the remainder in the built-in division and remainder operators was implementation-defined if either of the operands was negative, but it was well-defined in `div` and `ldiv`.\n\nOn many platforms, a single CPU instruction obtains both the quotient and the remainder, and this function may leverage that, although compilers are generally able to merge nearby `/` and `%` where suitable.\n\n### Example\n\n```\n#include <assert.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nvoid reverse(char* first, char* last)\n{\n    for (--last; first < last; ++first, --last)\n    {\n        char c = *last;\n        *last = *first;\n        *first = c;\n    }\n}\n \n// returns empty buffer in case of buffer overflow\nchar* itoa(int n, int base, char* buf, size_t buf_size)\n{\n    assert(2 <= base && base <= 16 && buf && buf_size);\n    div_t dv = {.quot = n};\n    char* p = buf;\n    do\n    {\n        if (!--buf_size)\n            return (*buf = '\\0'), buf;\n        dv = div(dv.quot, base);\n        *p++ = \"0123456789abcdef\"[abs(dv.rem)];\n    }\n    while(dv.quot);\n    if (n < 0)\n        *p++ = '-';\n    *p = '\\0';\n    reverse(buf, p);\n    return buf;\n}\n \nint main(void)\n{\n    char buf[16];\n    printf(\"%s\\n\", itoa(0, 2, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(007, 3, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(12346, 10, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(-12346, 10, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(-42, 2, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(INT_MAX, 16, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(INT_MIN, 16, buf, sizeof buf));\n}\n```\n\nPossible output:\n\n```\n0\n21\n12346\n-12346\n-101010\n7fffffff\n-80000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.8.2.2 The imaxdiv function (p: TBD)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.2.2 The imaxdiv function (p: 159)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: 259)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.2 The imaxdiv function (p: 219)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: 356)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.2 The imaxdiv function (p: 200)\n  - 7.20.6.2 The div, ldiv and lldiv functions (p: 320)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10 div_t, ldiv_t\n  - 4.10.6.2 The div function\n  - 4.10.6.4 The ldiv function\n\n### See also\n\n[TABLE]\n\n### External links\n\n|     |                                                                                                                      |\n|-----|----------------------------------------------------------------------------------------------------------------------|\n| 1\\. | [Euclidean division](https://en.wikipedia.org/wiki/Euclidean_division \"enwiki:Euclidean division\") — From Wikipedia. |\n| 2\\. | [Modulo (and Truncated division)](https://en.wikipedia.org/wiki/Modulo \"enwiki:Modulo\") — From Wikipedia.            |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/div](https://en.cppreference.com/w/c/numeric/math/div)"
- name: Implicit conversions
  summary: 'When an expression is used in the context where a value of a different type is expected, conversion may occur:'
  description: "# Implicit conversions\n\nWhen an expression is used in the context where a value of a different type is expected, *conversion* may occur:\n\n```\nint n = 1L; // expression 1L has type long, int is expected\nn = 2.1; // expression 2.1 has type double, int is expected\nchar *p = malloc(10); // expression malloc(10) has type void*, char* is expected\n```\n\nConversions take place in the following situations:\n\n### Conversion as if by assignment\n\n- In the [assignment](operator_assignment \"c/language/operator assignment\") operator, the value of the right-hand operand is converted to the unqualified type of the left-hand operand.\n- In [scalar initialization](scalar_initialization \"c/language/scalar initialization\"), the value of the initializer expression is converted to the unqualified type of the object being initialized\n- In a [function-call expression](operator_other \"c/language/operator other\"), to a function that has a prototype, the value of each argument expression is converted to the type of the unqualified declared types of the corresponding parameter\n- In a [return statement](return \"c/language/return\"), the value of the operand of `return` is converted to an object having the return type of the function\n\nNote that actual assignment, in addition to the conversion, also removes extra range and precision from floating-point types and prohibits overlaps; those characteristics do not apply to conversion as if by assignment.\n\n### Default argument promotions\n\nIn a [function call expression](operator_other#Function_call \"c/language/operator other\") when the call is made to\n\n1) a [function without a prototype](function_declaration \"c/language/function declaration\") (until C23)\n\n2) a [variadic function](variadic \"c/language/variadic\"), where the argument expression is one of the trailing arguments that are matched against the ellipsis parameter\n\nEach argument of integer type undergoes *integer promotion* (see below), and each argument of type `float` is implicitly converted to the type `double`\n\n```\nint add_nums(int count, ...);\nint sum = add_nums(2, 'c', true); // add_nums is called with three ints: (2, 99, 1)\n```\n\n|                                                                                                                                                                                                                                                                                                                                                                                          |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Note that `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) and `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary) are not promoted to `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) and `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary) in this context. | (since C99) |\n\n### Usual arithmetic conversions\n\nThe arguments of the following arithmetic operators undergo implicit conversions for the purpose of obtaining the *common real type*, which is the type in which the calculation is performed:\n\n- [binary arithmetic](operator_arithmetic \"c/language/operator arithmetic\") \\*, /, %, +, -\n- [relational operators](operator_comparison \"c/language/operator comparison\") \\<, \\>, \\<=, \\>=, ==, !=\n- [binary bitwise arithmetic](operator_arithmetic \"c/language/operator arithmetic\") &, ^, \\|,\n- the [conditional operator](operator_other \"c/language/operator other\") ?:\n\n[TABLE]\n\n2) Otherwise, if one operand is `long double`, `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), or `long`` ``double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary) (since C99), the other operand is implicitly converted as follows:\n\n- integer or real floating type to `long double`\n\n[TABLE]\n\n3) Otherwise, if one operand is `double`, `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), or `double`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary) (since C99), the other operand is implicitly converted as follows:\n\n- integer or real floating type to `double`\n\n[TABLE]\n\n4) Otherwise, if one operand is `float`, `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex), or `float`` `[`imaginary`](http://en.cppreference.com/w/c/numeric/complex/imaginary) (since C99), the other operand is implicitly converted as follows:\n\n- integer type to `float` (the only real type possible is float, which remains as-is)\n\n[TABLE]\n\n5) Otherwise, both operands are integers. Both operands undergo *integer promotions* (see below); then, after integer promotion, one of the following cases applies:\n\n- If the types are the same, that type is the common type.\n- Else, the types are different:\n  - If the types have the same signedness (both signed or both unsigned), the operand whose type has the lesser *conversion rank*¹ is implicitly converted² to the other type.\n  - Else, the operands have different signedness:\n    - If the unsigned type has *conversion rank* greater than or equal to the rank of the signed type, then the operand with the signed type is implicitly converted to the unsigned type.\n    - Else, the unsigned type has *conversion rank* less than the signed type:\n      - If the signed type can represent all values of the unsigned type, then the operand with the unsigned type is implicitly converted to the signed type.\n      - Else, both operands undergo implicit conversion to the unsigned type counterpart of the signed operand's type.\n\n------------------------------------------------------------------------\n\n1\\. Refer to \"integer promotions\" below for the rules on ranking.\n\n2\\. Refer to \"integer conversions\" under \"implicit conversion semantics\" below.\n\n```\n1.f + 20000001; // int is converted to float, giving 20000000.00\n                // addition and then rounding to float gives 20000000.00\n \n(char)'a' + 1L; // first, char 'a', which is 97, is promoted to int\n                // different types: int and long\n                // same signedness: both signed\n                // different rank: long is of greater rank than int\n                // therefore, int 97 is converted to long 97\n                // the result is 97 + 1 = 98 of type signed long\n \n2u - 10; // different types: unsigned int and signed int\n         // different signedness\n         // same rank\n         // therefore, signed int 10 is converted to unsigned int 10\n         // since the arithmetic operation is performed for unsigned integers\n         // (see \"Arithmetic operators\" topic), the calculation performed is (2 - 10)\n         // modulo (2 raised to n), where n is the number of value bits of unsigned int\n         // if unsigned int is 32-bit long and there is no padding bits in its object\n         // representation, then the result is (-8) modulo (2 raised to 32) = 4294967288\n         // of type unsigned int\n \n5UL - 2ULL; // different types: unsigned long and unsigned long long\n            // same signedness\n            // different rank: rank of unsigned long long is greater\n            // therefore, unsigned long 5 is converted to unsigned long long 5\n            // since the arithmetic operation is performed for unsigned integers\n            // (see \"Arithmetic operators\" topic),\n            // if unsigned long long is 64-bit long, then\n            // the result is (5 - 2) modulo (2 raised to 64) = 3 of type\n            // unsigned long long\n \n0UL - 1LL; // different types: unsigned long and signed long long\n           // different signedness\n           // different rank: rank of signed long long is greater.\n           // if ULONG_MAX > LLONG_MAX, then signed long long cannot represent all\n           // unsigned long therefore, this is the last case: both operands are converted\n           // to unsigned long long unsigned long 0 is converted to unsigned long long 0\n           // long long 1 is converted to unsigned long long 1 since the arithmetic\n           // operation is performed for unsigned integers\n           // (see \"Arithmetic operators\" topic),\n           // if unsigned long long is 64-bit long, then  \n           // the calculation is (0 - 1) modulo (2 raised to 64)\n           // thus, the result is 18446744073709551615 (ULLONG_MAX) of type\n           // unsigned long long\n```\n\n[TABLE]\n\nAs always, the result of a floating-point operator may have greater range and precision than is indicated by its type (see [`FLT_EVAL_METHOD`](../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\")).\n\n|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Note: real and imaginary operands are not implicitly converted to complex because doing so would require extra computation, while producing undesirable results in certain cases involving infinities, NaNs and signed zeros. For example, if reals were converted to complex, 2.0×(3.0+i∞) would evaluate as (2.0+i0.0)×(3.0+i∞) ⇒ (2.0×3.0–0.0×∞) + i(2.0×∞+0.0×3.0) ⇒ NaN+i∞ rather than the correct 6.0+i∞. If imaginaries were converted to complex, i2.0×(∞+i3.0) would evaluate as (0.0+i2.0) × (∞+i3.0) ⇒ (0.0×∞ – 2.0×3.0) + i(0.0×3.0 + 2.0×∞) ⇒ NaN + i∞ instead of –6.0 + i∞. | (since C99) |\n\nNote: regardless of usual arithmetic conversions, the calculation may always be performed in a narrower type than specified by these rules under the [as-if rule](as_if \"c/language/as if\")\n\n### Value transformations\n\n#### Lvalue conversion\n\nAny [lvalue expression](value_category \"c/language/value category\") of any non-array type, when used in any context other than\n\n- as the operand of the [address-of operator](operator_member_access \"c/language/operator member access\") (if allowed)\n- as the operand of the pre/post [increment and decrement operators](operator_incdec \"c/language/operator incdec\").\n- as the left-hand operand of the [member access](operator_member_access \"c/language/operator member access\") (dot) operator.\n- as the left-hand operand of the [assignment and compound assignment](operator_assignment \"c/language/operator assignment\") operators.\n- as the operand of [sizeof](sizeof \"c/language/sizeof\")\n\nundergoes *lvalue conversion*: the type remains the same, but loses [const](const \"c/language/const\")/[volatile](volatile \"c/language/volatile\")/[restrict](restrict \"c/language/restrict\")-qualifiers and [atomic](atomic \"c/language/atomic\") properties, if any. The value remains the same, but loses its lvalue properties (the address may no longer be taken).\n\nIf the lvalue has incomplete type, the behavior is undefined.\n\nIf the lvalue designates an object of automatic storage duration whose address was never taken and if that object was uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.\n\nThis conversion models the memory load of the value of the object from its location.\n\n```\nvolatile int n = 1;\nint x = n;            // lvalue conversion on n reads the value of n\nvolatile int* p = &n; // no lvalue conversion: does not read the value of n\n```\n\n#### Array to pointer conversion\n\nAny [lvalue expression](value_category \"c/language/value category\") of [array type](array \"c/language/array\"), when used in any context other than\n\n- as the operand of the [address-of operator](operator_member_access \"c/language/operator member access\")\n- as the operand of [sizeof](sizeof \"c/language/sizeof\")\n- as the operand of [typeof](typeof \"c/language/typeof\") and [typeof_unqual](https://en.cppreference.com/mwiki/index.php?title=c/language/typeof_unqual&action=edit&redlink=1 \"c/language/typeof unqual (page does not exist)\") (since C23)\n- as the string literal used for [array initialization](array_initialization \"c/language/array initialization\")\n\nundergoes a conversion to the non-lvalue pointer to its first element.\n\nIf the array was declared [register](storage_duration \"c/language/storage duration\"), the behavior is undefined.\n\n```\nint a[3], b[3][4];\nint* p = a;      // conversion to &a[0]\nint (*q)[4] = b; // conversion to &b[0]\n```\n\n#### Function to pointer conversion\n\nAny function designator expression, when used in any context other than\n\n- as the operand of the [address-of operator](operator_member_access \"c/language/operator member access\")\n- as the operand of [sizeof](sizeof \"c/language/sizeof\")\n- as the operand of [typeof](typeof \"c/language/typeof\") and [typeof_unqual](https://en.cppreference.com/mwiki/index.php?title=c/language/typeof_unqual&action=edit&redlink=1 \"c/language/typeof unqual (page does not exist)\") (since C23)\n\nundergoes a conversion to the non-lvalue pointer to the function designated by the expression.\n\n```\nint f(int);\nint (*p)(int) = f; // conversion to &f\n(***p)(1); // repeated dereference to f and conversion back to &f\n```\n\n### Implicit conversion semantics\n\nImplicit conversion, whether *as if by assignment* or a *usual arithmetic conversion*, consists of two stages:\n\n1) value transformation (if applicable)\n\n2) one of the conversions listed below (if it can produce the target type)\n\n#### Compatible types\n\nConversion of a value of any type to any [compatible type](types#Compatible_types \"c/language/types\") is always a no-op and does not change the representation.\n\n```\nuint8_t (*a)[10];         // if uint8_t is a typedef to unsigned char\nunsigned char (*b)[] = a; // then these pointer types are compatible\n```\n\n#### Integer promotions\n\nInteger promotion is the implicit conversion of a value of any integer type with *rank* less or equal to *rank* of int or of a [bit-field](bit_field \"c/language/bit field\") of type `_Bool`(until C23)`bool`(since C23), `int`, `signed int`, `unsigned int`, to the value of type `int` or `unsigned int`.\n\nIf `int` can represent the entire range of values of the original type (or the range of values of the original bit-field), the value is converted to type `int`. Otherwise the value is converted to `unsigned int`.\n\n|                                                                                                                                                                                                        |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The value from a bit-field of a bit-precise integer type is converted to the corresponding bit-precise integer type. Otherwise, bit-precise integer types are exempt from the integer promotion rules. | (since C23) |\n\nInteger promotions preserve the value, including the sign:\n\n```\nint main(void)\n{\n    void f(); // old-style function declaration\n              // since C23, void f(...) has the same behavior wrt promotions\n    char x = 'a'; // integer conversion from int to char\n    f(x); // integer promotion from char back to int\n}\n \nvoid f(x) int x; {} // the function expects int\n```\n\n*rank* above is a property of every [integer type](type \"c/language/type\") and is defined as follows:\n\n1) the ranks of all signed integer types are different and increase with their precision: rank of `signed char` \\< rank of `short` \\< rank of `int` \\< rank of `long int` \\< rank of `long long int`\n\n2) the ranks of all signed integer types equal the ranks of the corresponding unsigned integer types\n\n3) the rank of any standard integer type is greater than the rank of any extended integer type or bit-precise integer type(since C23) of the same size (that is, rank of `__int64` \\< rank of `long long int`, but rank of `long long` \\< rank of `__int128` due to the rule (1))\n\n4) rank of `char` equals rank of `signed char` and rank of `unsigned char`\n\n5) the rank of `_Bool`(until C23)`bool`(since C23) is less than the rank of any other standard integer type\n\n6) the rank of any enumerated type equals the rank of its compatible integer type\n\n7) ranking is transitive: if rank of T1 \\< rank of T2 and rank of T2 \\< rank of T3 then rank of T1 \\< rank of T3\n\n|                                                                                                                                                                                                                                                                                                             |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| 8) the rank of a bit-precise signed integer type shall be greater than the rank of any standard integer type with less width or any bit-precise integer type with less width. 9) the rank of any bit-precise integer type relative to an extended integer type of the same width is implementation-defined. | (since C23) |\n\n10) any aspects of relative ranking of extended integer types not covered above are implementation defined.\n\nNote: integer promotions are applied only\n\n- as part of *usual arithmetic conversions* (see above)\n- as part of *default argument promotions* (see above)\n- to the operand of the unary arithmetic operators `+` and `-`\n- to the operand of the unary bitwise operator `~`\n- to both operands of the shift operators `<<` and `>>`\n\n[TABLE]\n\n#### Integer conversions\n\nA value of any integer type can be implicitly converted to any other integer type. Except where covered by promotions and boolean conversions above, the rules are:\n\n- if the target type can represent the value, the value is unchanged\n- otherwise, if the target type is unsigned, the value 2^(b), where b is the number of value bits in the target type, is repeatedly subtracted or added to the source value until the result fits in the target type. In other words, unsigned integers implement modulo arithmetic.\n- otherwise, if the target type is signed, the behavior is implementation-defined (which may include raising a signal)\n\n```\nchar x = 'a'; // int -> char, result unchanged\nunsigned char n = -123456; // target is unsigned, result is 192 (that is, -123456+483*256)\nsigned char m = 123456;    // target is signed, result is implementation-defined\nassert(sizeof(int) > -1);  // assert fails:\n                           // operator > requests conversion of -1 to size_t,\n                           // target is unsigned, result is SIZE_MAX\n```\n\n#### Real floating-integer conversions\n\nA finite value of any real floating type can be implicitly converted to any integer type. Except where covered by boolean conversion above, the rules are:\n\n- The fractional part is discarded (truncated towards zero).\n  - If the resulting value can be represented by the target type, that value is used\n  - otherwise, the behavior is undefined\n\n```\nint n = 3.14; // n == 3\nint x = 1e10; // undefined behavior for 32-bit int\n```\n\nA value of any integer type can be implicitly converted to any real floating type.\n\n- if the value can be represented exactly by the target type, it is unchanged\n- if the value can be represented, but cannot be represented exactly, the result is an implementation-defined choice of either the nearest higher or nearest lower value, although if IEEE arithmetic is supported, rounding is to nearest. It is unspecified whether [`FE_INEXACT`](../numeric/fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised in this case.\n- if the value cannot be represented, the behavior is undefined, although if IEEE arithmetic is supported, [`FE_INVALID`](../numeric/fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and the result value is unspecified.\n\nThe result of this conversion may have greater range and precision than its target type indicates (see [`FLT_EVAL_METHOD`](../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\")).\n\nIf control over [`FE_INEXACT`](../numeric/fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is needed in floating-to-integer conversions, [`rint`](../numeric/math/rint \"c/numeric/math/rint\") and [`nearbyint`](../numeric/math/nearbyint \"c/numeric/math/nearbyint\") may be used.\n\n```\ndouble d = 10; // d = 10.00\nfloat f = 20000001; // f = 20000000.00 (FE_INEXACT)\nfloat x = 1+(long long)FLT_MAX; // undefined behavior\n```\n\n#### Real floating point conversions\n\nA value of any real floating type can be implicitly converted to any other real floating type.\n\n- If the value can be represented by the target type exactly, it is unchanged\n- if the value can be represented, but cannot be represented exactly, the result is the nearest higher or the nearest lower value (in other words, rounding direction is implementation-defined), although if IEEE arithmetic is supported, rounding is to nearest\n- if the value cannot be represented, the behavior is undefined\n\nThe result of this conversion may have greater range and precision than its target type indicates (see [`FLT_EVAL_METHOD`](../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\")).\n\n```\ndouble d = 0.1; // d = 0.1000000000000000055511151231257827021181583404541015625\nfloat f = d;    // f = 0.100000001490116119384765625\nfloat x = 2*(double)FLT_MAX; // undefined\n```\n\n[TABLE]\n\n#### Pointer conversions\n\nA pointer to `void` can be implicitly converted to and from any pointer to object type with the following semantics:\n\n- If a pointer to object is converted to a pointer to void and back, its value compares equal to the original pointer.\n- No other guarantees are offered\n\n```\nint* p = malloc(10 * sizeof(int)); // malloc returns void*\n```\n\nA pointer to an unqualified type may be implicitly converted to the pointer to qualified version of that type (in other words, [const](const \"c/language/const\"), [volatile](volatile \"c/language/volatile\"), and [restrict](restrict \"c/language/restrict\") qualifiers can be added). The original pointer and the result compare equal.\n\n```\nint n;\nconst int* p = &n; // &n has type int*\n```\n\nAny integer [constant expression](constant_expression \"c/language/constant expression\") with value `​0​` as well as integer pointer expression with value zero cast to the type `void*` can be implicitly converted to any pointer type (both pointer to object and pointer to function). The result is the null pointer value of its type, guaranteed to compare unequal to any non-null pointer value of that type. This integer or void\\* expression is known as *null pointer constant* and the standard library provides one definition of this constant as the macro [`NULL`](../types/null \"c/types/NULL\").\n\n```\nint* p = 0;\ndouble* q = NULL;\n```\n\n### Notes\n\nAlthough signed integer overflow in any arithmetic operator is undefined behavior, overflowing a signed integer type in an integer conversion is merely unspecified behavior.\n\nOn the other hand, although unsigned integer overflow in any arithmetic operator (and in integer conversion) is a well-defined operation and follows the rules of modulo arithmetic, overflowing an unsigned integer in a floating-to-integer conversion is undefined behavior: the values of real floating type that can be converted to unsigned integer are the values from the open interval (-1; Unnn_MAX+1).\n\n```\nunsigned int n = -1.0; // undefined behavior\n```\n\nConversions between pointers and integers (except from pointer to `_Bool`(until C23)`bool`(since C23) and (since C99)from integer constant expression with the value zero to pointer), between pointers to objects (except where either to or from is a pointer to void) and conversions between pointers to functions (except when the functions have compatible types) are never implicit and require a [cast operator](cast \"c/language/cast\").\n\nThere are no conversions (implicit or explicit) between pointers to functions and pointers to objects (including void\\*) or integers.\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.3 Conversions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.3 Conversions (p: 37-41)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.3 Conversions (p: 50-56)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.3 Conversions (p: 42-48)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.2 Conversions\n\n### See also\n\n|                                                                                                                                     |     |\n|-------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/implicit_cast \"cpp/language/implicit cast\") for Implicit conversions |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/conversion](https://en.cppreference.com/w/c/language/conversion)"
- name: Increment/decrement operators
  summary: Increment/decrement operators are unary operators that increment/decrement the value of a variable by 1
  description: "# Increment/decrement operators\n\nIncrement/decrement operators are unary operators that increment/decrement the value of a variable by 1.\n\nThey can have postfix form:\n\n|           |     |     |\n|-----------|-----|-----|\n| expr `++` |     |     |\n| expr `--` |     |     |\n\nAs well as the prefix form:\n\n|           |     |     |\n|-----------|-----|-----|\n| `++` expr |     |     |\n| `--` expr |     |     |\n\nThe operand expr of both prefix and postfix increment or decrement must be a [modifiable lvalue](value_category \"c/language/value category\") of [integer type](type \"c/language/type\") (including `_Bool` and enums), real floating type, or a pointer type. It may be cvr-qualified, unqualified, or [atomic](atomic \"c/language/atomic\").\n\nThe result of the postfix increment and decrement operators is the value of expr.\n\nThe result of the prefix increment operator is the result of adding the value `1` to the value of expr: the expression `++e` is equivalent to `e += 1`. The result of the prefix decrement operator is the result of subtracting the value `1` from the value of expr: the expression `--e` is equivalent to `e -= 1`.\n\nIncrement operators initiate the side-effect of adding the value `1` of appropriate type to the operand. Decrement operators initiate the side-effect of subtracting the value `1` of appropriate type from the operand. As with any other side-effects, these operations complete at or before the next [sequence point](eval_order \"c/language/eval order\").\n\n```\nint a = 1;\nint b = a++; // stores 1+a (which is 2) to a\n             // returns the old value of a (which is 1)\n             // After this line, b == 1 and a == 2\na = 1;\nint c = ++a; // stores 1+a (which is 2) to a\n             // returns 1+a (which is 2)\n             // after this line, c == 2 and a == 2\n```\n\n|                                                                                                                                                                                                                            |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Post-increment or post-decrement on any [atomic variable](atomic \"c/language/atomic\") is an atomic read-modify-write operation with memory order [`memory_order_seq_cst`](../atomic/memory_order \"c/atomic/memory order\"). | (since C11) |\n\nSee [arithmetic operators](operator_arithmetic \"c/language/operator arithmetic\") for limitations on pointer arithmetic, as well as for implicit conversions applied to the operands.\n\n### Notes\n\nBecause of the side-effects involved, increment and decrement operators must be used with care to avoid undefined behavior due to violations of [sequencing rules](eval_order \"c/language/eval order\").\n\nIncrement/decrement operators are not defined for complex or imaginary types: the usual definition of adding/subtracting the real number 1 would have no effect on imaginary types, and making it add/subtract `i` for imaginaries but `1` for complex numbers would have made it handle `0+yi` different from `yi`.\n\nUnlike C++ (and some implementations of C), the increment/decrement expressions are never themselves lvalues: `&++a` is invalid.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int a = 1;\n    int b = 1;\n \n    printf(\"original values: a == %d, b == %d\\n\", a, b);\n    printf(\"result of postfix operators: a++ == %d, b-- == %d\\n\", a++, b--);\n    printf(\"after postfix operators applied: a == %d, b == %d\\n\", a, b);\n    printf(\"\\n\");\n \n    // Reset a and b.\n    a = 1;\n    b = 1;\n \n    printf(\"original values: a == %d, b == %d\\n\", a, b);\n    printf(\"result of prefix operators: ++a == %d, --b == %d\\n\", ++a, --b);\n    printf(\"after prefix operators applied: a == %d, b == %d\\n\", a, b);\n}\n```\n\nOutput:\n\n```\noriginal values: a == 1, b == 1\nresult of postfix operators: a++ == 1, b-- == 1\nafter postfix operators applied: a == 2, b == 0\n \noriginal values: a == 1, b == 1\nresult of prefix operators: ++a == 2, --b == 0\nafter prefix operators applied: a == 2, b == 0\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.5.2.4 Postfix increment and decrement operators (p: TBD)\n  - 6.5.3.1 Prefix increment and decrement operators (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.2.4 Postfix increment and decrement operators (p: TBD)\n  - 6.5.3.1 Prefix increment and decrement operators (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.2.4 Postfix increment and decrement operators (p: 85)\n  - 6.5.3.1 Prefix increment and decrement operators (p: 88)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5.2.4 Postfix increment and decrement operators (p: 75)\n  - 6.5.3.1 Prefix increment and decrement operators (p: 78)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.3.2.4 Postfix increment and decrement operators\n  - 3.3.3.1 Prefix increment and decrement operators\n\n### See also\n\n[Operator precedence](operator_precedence \"c/language/operator precedence\")\n\n[TABLE]\n\n|                                                                                                                                                  |     |\n|--------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/operator_incdec \"cpp/language/operator incdec\") for Increment/decrement operators |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/operator_incdec](https://en.cppreference.com/w/c/language/operator_incdec)"
- name: INFINITY
  summary: If the implementation supports floating-point infinities, the macro INFINITY expands to constant expression of type float which evaluates to positive or unsigned infinity
  description: "# INFINITY\n\n[TABLE]\n\nIf the implementation supports floating-point infinities, the macro `INFINITY` expands to constant expression of type `float` which evaluates to positive or unsigned infinity.\n\nIf the implementation does not support floating-point infinities, the macro `INFINITY` expands to a positive value that is guaranteed to overflow a `float` at compile time, and the use of this macro generates a compiler warning.\n\nThe style used to print an infinity is implementation defined.\n\n### Example\n\nShow style used to print an infinity and IEEE format.\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n \nint main(void)\n{\n    double f = INFINITY;\n    uint64_t fn; memcpy(&fn, &f, sizeof f);\n    printf(\"INFINITY:   %f %\" PRIx64 \"\\n\", f, fn);\n}\n```\n\nPossible output:\n\n```\nINFINITY:   inf 7ff0000000000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/4 INFINITY (p: 231-232)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/4 INFINITY (p: 212-213)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/INFINITY](https://en.cppreference.com/w/c/numeric/math/INFINITY)"
- name: Initialization
  summary: A declaration of an object may provide its initial value through the process known as initialization
  description: "# Initialization\n\nA [declaration](declarations \"c/language/declarations\") of an object may provide its initial value through the process known as *initialization*.\n\nFor each [declarator](declarations \"c/language/declarations\"), the initializer, if not omitted, may be one of the following:\n\n|                              |       |             |\n|------------------------------|-------|-------------|\n| `=` expression               | \\(1\\) |             |\n| `=` `{` initializer-list `}` | \\(2\\) |             |\n| `=` `{` `}`                  | \\(3\\) | (since C23) |\n\nwhere initializer-list is a non-empty comma-separated list of initializer \uFEFFs (with an optional trailing comma), where each initializer has one of three possible forms:\n\n|                                 |       |             |\n|---------------------------------|-------|-------------|\n| expression                      | \\(1\\) |             |\n| `{` initializer-list `}`        | \\(2\\) |             |\n| `{` `}`                         | \\(3\\) | (since C23) |\n| designator-list `=` initializer | \\(4\\) | (since C99) |\n\n[TABLE]\n\n### Explanation\n\nThe initializer specifies the initial value stored in an object.\n\n#### Explicit initialization\n\nIf an initializer is provided, see\n\n- [scalar initialization](scalar_initialization \"c/language/scalar initialization\") for the initialization of scalar types\n- [array initialization](array_initialization \"c/language/array initialization\") for the initialization of array types\n- [struct initialization](struct_initialization \"c/language/struct initialization\") for the initialization of struct and union types.\n\n#### Implicit initialization\n\nIf an initializer is not provided:\n\n- objects with automatic [storage duration](storage_duration \"c/language/storage duration\") are initialized to indeterminate values (which may be [trap representations](object \"c/language/object\"))\n- objects with static and thread-local [storage duration](storage_duration \"c/language/storage duration\") are empty-initialized\n\n#### Empty initialization\n\n|                                                                                         |             |\n|-----------------------------------------------------------------------------------------|-------------|\n| An object is empty-initialized if it is explicitly initialized from initializer `= {}`. | (since C23) |\n\nIn some cases, an object is empty-initialized if it is not initialized explicitly, that is:\n\n- pointers are initialized to null pointer values of their types\n- objects of integral types are initialized to unsigned zero\n- objects of floating types are initialized to positive zero\n- all elements of arrays, all members of structs, and the first members of unions are empty-initialized, recursively, plus all padding bits are initialized to zero\n\n(on platforms where null pointer values and floating zeroes have all-bit-zero representations, this form of initialization for statics is normally implemented by allocating them in the .bss section of the program image)\n\n### Notes\n\nWhen initializing an object of static or thread-local [storage duration](storage_duration \"c/language/storage duration\"), every expression in the initializer must be a [constant expression](constant_expression \"c/language/constant expression\") or [string literal](string_literal \"c/language/string literal\").\n\nInitializers cannot be used in declarations of objects of incomplete type, VLAs, and block-scope objects with linkage.\n\nThe initial values of function parameters are established as if by assignment from the arguments of a [function call](operator_other#Function_call \"c/language/operator other\"), rather than by initialization.\n\nIf an indeterminate value is used as an argument to any standard library call, the behavior is undefined. Otherwise, the result of any expression involving indeterminate values is an indeterminate value (e.g. `int n;`, `n` may not compare equal to itself and it may appear to change its value on subsequent reads)\n\n|                                                                                                                                                                                                                                                                                                                                                                     |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| There is no special construct in C corresponding to [value initialization](https://en.cppreference.com/w/cpp/language/value_initialization \"cpp/language/value initialization\") in C++; however, `= {0}` (or `(T){0}` in compound literals)(since C99) can be used instead, as the C standard does not allow empty structs, empty unions, or arrays of zero length. | (until C23) |\n| The empty initializer `= {}` (or `(T){}` in compound literals) can be used to achieve the same semantics as [value initialization](https://en.cppreference.com/w/cpp/language/value_initialization \"cpp/language/value initialization\") in C++.                                                                                                                     | (since C23) |\n\n### Example\n\n```\n#include <stdlib.h>\nint a[2]; // initializes a to {0, 0}\nint main(void)\n{\n    int i;          // initializes i to an indeterminate value\n    static int j;   // initializes j to 0\n    int k = 1;      // initializes k to 1\n \n    // initializes int x[3] to 1,3,5\n    // initializes int* p to &x[0]\n    int x[] = { 1, 3, 5 }, *p = x;\n \n    // initializes w (an array of two structs) to\n    // { { {1,0,0}, 0}, { {2,0,0}, 0} }\n    struct {int a[3], b;} w[] = {[0].a = {1}, [1].a[0] = 2};\n \n    // function call expression can be used for a local variable\n    char* ptr = malloc(10);\n    free(ptr);\n \n//  Error: objects with static storage duration require constant initializers\n//  static char* ptr = malloc(10);\n \n//  Error: VLA cannot be initialized\n//  int vla[n] = {0};\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.9 Initialization (p: 100-105)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.9 Initialization (p: 139-144)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.8 Initialization (p: 125-130)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 6.5.7 Initialization\n\n### See also\n\n|                                                                                                                                 |     |\n|---------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/initialization \"cpp/language/initialization\") for Initialization |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/initialization](https://en.cppreference.com/w/c/language/initialization)"
- name: inline
  summary: ''
  description: "# C keywords: inline (since C99)\n\n### Usage\n\n- [inline function specifier](../language/inline \"c/language/inline\") (since C99)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/inline](https://en.cppreference.com/w/c/keyword/inline)"
- name: Inline assembly
  summary: Inline assembly (typically introduced by the asm keyword) gives the ability to embed assembly language source code within a C program
  description: "# Inline assembly\n\nInline assembly (typically introduced by the `asm` keyword) gives the ability to embed assembly language source code within a C program.\n\nUnlike in C++, inline assembly is treated as an extension in C. It is conditionally supported and implementation defined, meaning that it may not be present and, even when provided by the implementation, it does not have a fixed meaning.\n\n### Syntax\n\n|                                |     |     |\n|--------------------------------|-----|-----|\n| `asm (` string_literal `)` `;` |     |     |\n\n### Explanation\n\nThis kind of inline assembly syntax is accepted by the C++ standard and called *asm-declaration* in C++. The string_literal is typically a short program written in assembly language, which is executed whenever this declaration is executed. Different C compilers have wildly varying rules for asm-declarations, and different conventions for the interaction with the surrounding C code.\n\nasm-declaration can appear inside a block (a function body or another compound statement), and, as all other declarations, this declaration can also appear outside a block.\n\n### Notes\n\nMSVC does not support inline assembly on the ARM and x64 processors, and only support the form introduced by `__asm` on x86 processors.\n\nWhen compiling in ISO C mode by GCC or Clang (e.g. with option `-std=c11`), `__asm__` must be used instead of `asm`.\n\n### Examples\n\nDemonstrates two kinds of inline assembly syntax offered by the GCC compiler. This program will only work correctly on x86-64 platform under Linux. Note that the \"standard inline assembly\" is also treated as an extension in the C standard.\n\n```\n#include <stdio.h>\n \nextern int func(void);\n// the definition of func is written in assembly language\n__asm__(\".globl func\\n\\t\"\n        \".type func, @function\\n\\t\"\n        \"func:\\n\\t\"\n        \".cfi_startproc\\n\\t\"\n        \"movl $7, %eax\\n\\t\"\n        \"ret\\n\\t\"\n        \".cfi_endproc\");\n \nint main(void)\n{\n    int n = func();\n    // gcc's extended inline assembly\n    __asm__ (\"leal (%0,%0,4),%0\"\n           : \"=r\" (n)\n           : \"0\" (n));\n    printf(\"7*5 = %d\\n\", n);\n    fflush(stdout); // flush is intentional\n \n    // standard inline assembly in C++\n    __asm__ (\"movq $60, %rax\\n\\t\" // the exit syscall number on Linux\n             \"movq $2,  %rdi\\n\\t\" // this program returns 2\n             \"syscall\");\n}\n```\n\nOutput:\n\n```\n7*5 = 35\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - J.5.10 The asm keyword (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - J.5.10 The asm keyword (p: 422)\n- C11 standard (ISO/IEC 9899:2011):\n  - J.5.10 The asm keyword (p: 580)\n- C99 standard (ISO/IEC 9899:1999):\n  - J.5.10 The asm keyword (p: 512)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - G.5.10 The asm keyword\n\n### See also\n\n|                                                                                                              |     |\n|--------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/asm \"cpp/language/asm\") for `asm` declaration |     |\n\n### External links\n\n|     |                                                                                                                                                                                |\n|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 1\\. | [GCC Inline Assembly HOWTO](https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)                                                                                  |\n| 2\\. | [IBM XL C/C++ Inline Assembly](https://pic.dhe.ibm.com/infocenter/comphelp/v121v141/topic/com.ibm.xlcpp121.aix.doc/language_ref/asm.html)                                      |\n| 3\\. | [Intel C++ Inline Assembly](https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-inline-assembly)                                                       |\n| 4\\. | [Visual Studio Inline Assembler](https://learn.microsoft.com/en-us/cpp/assembler/inline/inline-assembler.aspx)                                                                 |\n| 5\\. | [Sun Studio 12 Asm Statements](https://blogs.oracle.com/x86be/entry/gcc_style_asm_inlining_support)                                                                            |\n| 6\\. | [Inline assembly for Itanium-based HP-UX](https://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=4308e2f5bde02110e2f5bde02110275d6e10RCRD) |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/asm](https://en.cppreference.com/w/c/language/asm)"
- name: inline function specifier
  summary: Declares an inline function
  description: "# inline function specifier\n\nDeclares an [inline function](https://en.wikipedia.org/wiki/inline_function \"enwiki:inline function\").\n\n### Syntax\n\n|                               |     |             |\n|-------------------------------|-----|-------------|\n| `inline` function_declaration |     | (since C99) |\n\n### Explanation\n\nThe intent of the `inline` specifier is to serve as a hint for the compiler to perform optimizations, such as [function inlining](https://en.wikipedia.org/wiki/inline_expansion \"enwiki:inline expansion\"), which usually require the definition of a function to be visible at the call site. The compilers can (and usually do) ignore presence or absence of the `inline` specifier for the purpose of optimization.\n\nIf the compiler performs function inlining, it replaces a call of that function with its body, avoiding the overhead of a function call (placing data on stack and retrieving the result), which may result in a larger executable as the code for the function has to be repeated multiple times. The result is similar to [function-like macros](../preprocessor/replace \"c/preprocessor/replace\"), except that identifiers and macros used in the function refer to the definitions visible at the point of definition, not at the point of call.\n\nRegardless of whether inlining takes place, the following semantics of inline functions are guaranteed:\n\nAny function with internal linkage may be declared `static inline` with no other restrictions.\n\nA non-static inline function cannot define a non-const function-local static and cannot refer to a file-scope static.\n\n```\nstatic int x;\n \ninline void f(void)\n{\n    static int n = 1; // error: non-const static in a non-static inline function\n    int k = x; // error: non-static inline function accesses a static variable\n}\n```\n\nIf a non-static function is declared `inline`, then it must be defined in the same translation unit. The inline definition that does not use `extern` is not externally visible and does not prevent other translation units from defining the same function. This makes the `inline` keyword an alternative to `static` for defining functions inside header files, which may be included in multiple translation units of the same program.\n\nIf a function is declared `inline` in some translation units, it does not need to be declared `inline` everywhere: at most one translation unit may also provide a regular, non-inline non-static function, or a function declared `extern inline`. This one translation unit is said to provide the *external definition*. In order to avoid undefined behavior, one external definition must exist in the program if the name of the function with external linkage is used in an expression, see [one definition rule](extern#One_definition_rule \"c/language/extern\").\n\nThe address of an inline function with external linkage is always the address of the external definition, but when this address is used to make a function call, it's unspecified whether the *inline definition* (if present in the translation unit) or the *external definition* is called. The static objects defined within an inline definition are distinct from the static objects defined within the external definition:\n\n```\ninline const char *saddr(void) // the inline definition for use in this file\n{\n    static const char name[] = \"saddr\";\n    return name;\n}\n \nint compare_name(void)\n{\n    return saddr() == saddr(); // unspecified behavior, one call could be external\n}\n \nextern const char *saddr(void); // an external definition is generated, too\n```\n\nA C program should not depend on whether the inline version or the external version of a function is called, otherwise the behavior is unspecified.\n\n### Keywords\n\n[`inline`](../keyword/inline \"c/keyword/inline\")\n\n### Notes\n\nThe `inline` keyword was adopted from C++, but in C++, if a function is declared `inline`, it must be declared `inline` in every translation unit, and also every definition of an inline function must be exactly the same (in C, the definitions may be different, and depending on the differences only results in unspecified behavior). On the other hand, C++ allows non-const function-local statics and all function-local statics from different definitions of an inline function are the same in C++ but distinct in C.\n\n### Example\n\n[TABLE]\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.4 Function specifiers (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.4 Function specifiers (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.4 Function specifiers (p: 125-127)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.4 Function specifiers (p: 112-113)\n\n### See also\n\n|                                                                                                                     |     |\n|---------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/inline \"cpp/language/inline\") for `inline` specifier |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/inline](https://en.cppreference.com/w/c/language/inline)"
- name: int
  summary: ''
  description: "# C keywords: int\n\n### Usage\n\n- [`int` type](../language/types \"c/language/types\"): as the declaration of the type\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/int](https://en.cppreference.com/w/c/keyword/int)"
- name: Integer constant
  summary: Allows values of integer type to be used in expressions directly
  description: "# Integer constant\n\nAllows values of integer type to be used in expressions directly.\n\n### Syntax\n\nAn integer constant is a [non-lvalue](value_category \"c/language/value category\") expression of the form\n\n|                                            |       |             |\n|--------------------------------------------|-------|-------------|\n| decimal-constant integer-suffix \uFEFF(optional) | \\(1\\) |             |\n| octal-constant integer-suffix \uFEFF(optional)   | \\(2\\) |             |\n| hex-constant integer-suffix \uFEFF(optional)     | \\(3\\) |             |\n| binary-constant integer-suffix \uFEFF(optional)  | \\(4\\) | (since C23) |\n\nwhere\n\n- decimal-constant is a non-zero decimal digit (`1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`), followed by zero or more decimal digits (`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`)\n- octal-constant is the digit zero (`0`) followed by zero or more octal digits (`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`)\n- hex-constant is the character sequence `0x` or the character sequence `0X` followed by one or more hexadecimal digits (`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `a`, `A`, `b`, `B`, `c`, `C`, `d`, `D`, `e`, `E`, `f`, `F`)\n- binary-constant is the character sequence `0b` or the character sequence `0B` followed by one or more binary digits (`0`, `1`)\n- integer-suffix, if provided, may contain one of the following (except the unsigned prefix can be combined with one of the others; if two suffixes are used they can appear in any order):\n  - unsigned-suffix (the character `u` or the character `U`)\n  - long-suffix (the character `l` or the character `L`) or the long-long-suffix (the character sequence `ll` or the character sequence `LL`)(since C99)\n  - bit-precise-int-suffix (the character sequence `wb` or the character sequence `WB`) (since C23)\n\n|                                                                                                                   |             |\n|-------------------------------------------------------------------------------------------------------------------|-------------|\n| Optional single quotes (`'`) may be inserted between the digits as a separator. They are ignored by the compiler. | (since C23) |\n\n### Explanation\n\n1) Decimal integer constant (base 10, the first digit is the most significant).\n\n2) Octal integer constant (base 8, the first digit is the most significant).\n\n3) Hexadecimal integer constant (base 16, the first digit is the most significant, the letters `a` through `f` represent the decimal values 10 through 15).\n\n4) Binary integer constant (base 2, the first digit is the most significant).\n\nThe following variables are initialized to the same value:\n\n```\nint d = 42;\nint o = 052;\nint x = 0x2a;\nint X = 0X2A;\nint b = 0b101010; // C23\n```\n\nThe following variables are also initialized to the same value:\n\n```\nunsigned long long l1 = 18446744073709550592ull; // C99\nunsigned long long l2 = 18'446'744'073'709'550'592llu; // C23\nunsigned long long l3 = 1844'6744'0737'0955'0592uLL; // C23\nunsigned long long l4 = 184467'440737'0'95505'92LLU; // C23\n```\n\n### The type of the integer constant\n\nThe type of the integer constant is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.\n\n[TABLE]\n\nTypes allowed for integer constants\n\nIf the value of the integer constant is too big to fit in any of the types allowed by suffix/base combination, it does not have suffixes `wb`, `WB`, `uwb`, or `UWB`(since C23) and the compiler supports extended integer types (such as `__int128`), the constant may be given the extended integer type; otherwise, the program is ill-formed.\n\n### Notes\n\nLetters in the integer constants are case-insensitive: `0xDeAdBaBeU` and `0XdeadBABEu` represent the same number (one exception is the long-long-suffix, which is either `ll` or `LL`, never `lL` or `Ll`)(since C99).\n\nThere are no negative integer constants. Expressions such as `-1` apply the [unary minus operator](operator_arithmetic \"c/language/operator arithmetic\") to the value represented by the constant.\n\n|                                                                                                                                                                                                                                                                                                                                                                                                            |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| When used in a controlling expression of [` #if`](../preprocessor/conditional \"c/preprocessor/conditional\") or [` #elif`](../preprocessor/conditional \"c/preprocessor/conditional\"), all signed integer constants act as if they have type [`intmax_t`](../types/integer \"c/types/integer\") and all unsigned integer constants act as if they have type [`uintmax_t`](../types/integer \"c/types/integer\"). | (since C99) |\n\nInteger constants may be used in [integer constant expressions](constant_expression \"c/language/constant expression\").\n\nDue to [maximal munch](translation_phases#maximal_munch \"c/language/translation phases\"), hexadecimal integer constants ending in `e` and `E`, when followed by the operators `+` or `-`, must be separated from the operator with whitespace or parentheses in the source:\n\n```\nint x = 0xE+2;   // error\nint y = 0xa+2;   // OK\nint z = 0xE +2;  // OK\nint q = (0xE)+2; // OK\n```\n\nOtherwise, a single invalid preprocessing number token is formed, which causes further analysis to fail.\n\n### Example\n\n```\n#include <inttypes.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"123 = %d\\n\", 123);\n    printf(\"0123 = %d\\n\", 0123);\n    printf(\"0x123 = %d\\n\", 0x123);\n    printf(\"12345678901234567890ull = %llu\\n\", 12345678901234567890ull);\n    // the type is a 64-bit type (unsigned long long or possibly unsigned long)\n    // even without a long suffix\n    printf(\"12345678901234567890u = %\"PRIu64\"\\n\", 12345678901234567890u );\n \n    // printf(\"%lld\\n\", -9223372036854775808); // Error:\n        // the value 9223372036854775808 cannot fit in signed long long, which\n        // is the biggest type allowed for unsuffixed decimal integer constant\n \n    printf(\"%llu\\n\", -9223372036854775808ull );\n    // unary minus applied to unsigned value subtracts it from 2^64,\n    // this gives unsigned 9223372036854775808\n \n    printf(\"%lld\\n\", -9223372036854775807ll - 1);\n    // correct way to form signed value -9223372036854775808\n}\n```\n\nOutput:\n\n```\n123 = 123\n0123 = 83\n0x123 = 291\n12345678901234567890ull = 12345678901234567890\n12345678901234567890u = 12345678901234567890\n9223372036854775808\n-9223372036854775808\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.4.4.1 Integer constants (p: 57-60)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.4.4.1 Integer constants (p: 45-46)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.4.4.1 Integer constants (p: 62-64)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.4.4.1 Integer constants (p: 54-56)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.3.2 Integer constants\n\n### See also\n\n|                                                                                                                                    |     |\n|------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/integer_literal \"cpp/language/integer literal\") for Integer literal |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/integer_constant](https://en.cppreference.com/w/c/language/integer_constant)"
- name: isalnum
  summary: Checks if the given character is an alphanumeric character as classified by the current C locale
  description: "# isalnum\n\n[TABLE]\n\nChecks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:\n\n- digits (`0123456789`)\n- uppercase letters (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`)\n- lowercase letters (`abcdefghijklmnopqrstuvwxyz`)\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character is an alphanumeric character, `0` otherwise.\n\n### Example\n\nDemonstrates the use of `isalnum` with different locales (OS-specific).\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <locale.h>\n \nint main(void)\n{\n    unsigned char c = '\\xdf'; // German letter ß in ISO-8859-1\n \n    printf(\"isalnum('\\\\xdf') in default C locale returned %d\\n\", !!isalnum(c));\n \n    if(setlocale(LC_CTYPE, \"de_DE.iso88591\"))\n        printf(\"isalnum('\\\\xdf') in ISO-8859-1 locale returned %d\\n\", !!isalnum(c));\n}\n```\n\nPossible output:\n\n```\nisalnum('\\xdf') in default C locale returned 0\nisalnum('\\xdf') in ISO-8859-1 locale returned 1\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.1 The isalnum function (p: 145)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.1 The isalnum function (p: 200)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.1 The isalnum function (p: 181)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.1 The isalnum function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/isalnum](https://en.cppreference.com/w/c/string/byte/isalnum)"
- name: isalpha
  summary: Checks if the given character is an alphabetic character, i.e
  description: "# isalpha\n\n[TABLE]\n\nChecks if the given character is an alphabetic character, i.e. either an uppercase letter (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`), or a lowercase letter (`abcdefghijklmnopqrstuvwxyz`).\n\nIn locales other than `\"C\"`, an alphabetic character is a character for which [`isupper()`](isupper \"c/string/byte/isupper\") or [`islower()`](islower \"c/string/byte/islower\") returns `true` or any other character considered alphabetic by the locale. In any case, [`iscntrl()`](iscntrl \"c/string/byte/iscntrl\"), [`isdigit()`](isdigit \"c/string/byte/isdigit\"), [`ispunct()`](ispunct \"c/string/byte/ispunct\") and [`isspace()`](isspace \"c/string/byte/isspace\") will return `false` for this character.\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character is an alphabetic character, zero otherwise.\n\n### Example\n\nDemonstrates the use of `isalpha` with different locales (OS-specific).\n\n```\n#include <ctype.h>\n#include <stdio.h>\n#include <locale.h>\n \nint main(void)\n{\n    unsigned char c = '\\xdf'; // German letter ß in ISO-8859-1\n \n    printf(\"isalpha('\\\\xdf') in default C locale returned %d\\n\", !!isalpha(c));\n \n    setlocale(LC_CTYPE, \"de_DE.iso88591\");\n    printf(\"isalpha('\\\\xdf') in ISO-8859-1 locale returned %d\\n\", !!isalpha(c));\n}\n```\n\nPossible output:\n\n```\nisalpha('\\xdf') in default C locale returned 0\nisalpha('\\xdf') in ISO-8859-1 locale returned 1\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.2 The isalpha function (p: 145)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.2 The isalpha function (p: 200-201)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.2 The isalpha function (p: 181-182)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.2 The isalpha function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/isalpha](https://en.cppreference.com/w/c/string/byte/isalpha)"
- name: isblank
  summary: Checks if the given character is a blank character in the current C locale
  description: "# isblank\n\n[TABLE]\n\nChecks if the given character is a blank character in the current C locale. In the default C locale, only space (`0x20`) and horizontal tab (`0x09`) are classified as blank.\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character is a blank character, zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <limits.h>\n \nint main(void)\n{\n    for (int ndx=0; ndx<=UCHAR_MAX; ndx++)\n        if (isblank(ndx)) printf(\"0x%02x\\n\", ndx);\n}\n```\n\nOutput:\n\n```\n0x09\n0x20\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.3 The isblank function (p: 145)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.3 The isblank function (p: 201)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.3 The isblank function (p: 182)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/isblank](https://en.cppreference.com/w/c/string/byte/isblank)"
- name: iscntrl
  summary: Checks if the given character is a control character, i.e
  description: "# iscntrl\n\n[TABLE]\n\nChecks if the given character is a control character, i.e. codes `0x00-0x1F` and `0x7F`.\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character is a control character, zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <locale.h>\n \nint main(void)\n{\n    unsigned char c = '\\x94'; // the control code CCH in ISO-8859-1\n    printf(\"In the default C locale, \\\\x94 is %sa control character\\n\",\n           iscntrl(c) ? \"\" : \"not \" );\n    setlocale(LC_ALL, \"en_GB.iso88591\");\n    printf(\"In ISO-8859-1 locale, \\\\x94 is %sa control character\\n\",\n           iscntrl(c) ? \"\" : \"not \" );\n}\n```\n\nPossible output:\n\n```\nIn the default C locale, \\x94 is not a control character\nIn ISO-8859-1 locale, \\x94 is a control character\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.4 The iscntrl function (p: 146)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.4 The iscntrl function (p: 201)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.4 The iscntrl function (p: 182)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.3 The iscntrl function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/iscntrl](https://en.cppreference.com/w/c/string/byte/iscntrl)"
- name: isdigit
  summary: Checks if the given character is a numeric character (0123456789)
  description: "# isdigit\n\n[TABLE]\n\nChecks if the given character is a numeric character (`0123456789`).\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character is a numeric character, zero otherwise.\n\n### Notes\n\n`isdigit` and `isxdigit` are the only standard narrow character classification functions that are not affected by the currently installed C locale, although some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits.\n\n### Example\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <limits.h>\n \nint main(void)\n{\n    for (int ndx=0; ndx<=UCHAR_MAX; ndx++)\n        if (isdigit(ndx)) printf(\"%c\", ndx);\n    printf(\"\\n\");\n}\n```\n\nOutput:\n\n```\n0123456789\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.5 The isdigit function (p: 146)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.5 The isdigit function (p: 201)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.5 The isdigit function (p: 182)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.4 The isdigit function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/isdigit](https://en.cppreference.com/w/c/string/byte/isdigit)"
- name: isfinite
  summary: Determines if the given floating point number arg has finite value i.e
  description: "# isfinite\n\n[TABLE]\n\nDetermines if the given floating point number `arg` has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. The macro returns an integral value.\n\n[`FLT_EVAL_METHOD`](../../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\") is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nNonzero integral value if `arg` has finite value, `​0​` otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nint main(void)\n{\n    printf(\"isfinite(NAN)         = %d\\n\", isfinite(NAN));\n    printf(\"isfinite(INFINITY)    = %d\\n\", isfinite(INFINITY));\n    printf(\"isfinite(0.0)         = %d\\n\", isfinite(0.0));\n    printf(\"isfinite(DBL_MIN/2.0) = %d\\n\", isfinite(DBL_MIN/2.0));\n    printf(\"isfinite(1.0)         = %d\\n\", isfinite(1.0));\n    printf(\"isfinite(exp(800))    = %d\\n\", isfinite(exp(800)));\n}\n```\n\nPossible output:\n\n```\nisfinite(NAN)         = 0\nisfinite(INFINITY)    = 0\nisfinite(0.0)         = 1\nisfinite(DBL_MIN/2.0) = 1\nisfinite(1.0)         = 1\nisfinite(exp(800))    = 0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.3.2 The isfinite macro (p: 236)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.3.2 The isfinite macro (p: 216-217)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/isfinite](https://en.cppreference.com/w/c/numeric/math/isfinite)"
- name: isgraph
  summary: Checks if the given character has a graphical representation, i.e
  description: "# isgraph\n\n[TABLE]\n\nChecks if the given character has a graphical representation, i.e. it is either a number (`0123456789`), an uppercase letter (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`), a lowercase letter (`abcdefghijklmnopqrstuvwxyz`), or a punctuation character (`` !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ ``), or any graphical character specific to the current C locale.\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character has a graphical representation character, zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <locale.h>\n \nint main(void)\n{\n    unsigned char c = '\\xb6'; // the character ¶ in ISO-8859-1\n    printf(\"In the default C locale, \\\\xb6 is %sgraphical\\n\",\n           isgraph(c) ? \"\" : \"not \" );\n    setlocale(LC_ALL, \"en_GB.iso88591\");\n    printf(\"In ISO-8859-1 locale, \\\\xb6 is %sgraphical\\n\",\n           isgraph(c) ? \"\" : \"not \" );\n}\n```\n\nPossible output:\n\n```\nIn the default C locale, \\xb6 is not graphical\nIn ISO-8859-1 locale, \\xb6 is graphical\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.6 The isgraph function (p: 146)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.6 The isgraph function (p: 201-202)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.6 The isgraph function (p: 182-183)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.5 The isgraph function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/isgraph](https://en.cppreference.com/w/c/string/byte/isgraph)"
- name: isgreater
  summary: Determines if the floating point number x is greater than the floating-point number (y), without setting floating-point exceptions
  description: "# isgreater\n\n[TABLE]\n\nDetermines if the floating point number `x` is greater than the floating-point number (`y`), without setting floating-point exceptions.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| x   | \\-  | floating point value |\n| y   | \\-  | floating point value |\n\n### Return value\n\nNonzero integral value if `x > y`, `​0​` otherwise.\n\n### Notes\n\nThe built-in `operator>` for floating-point numbers may set [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") if one or both of the arguments is NaN. This function is a \"quiet\" version of `operator>`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"isgreater(2.0,1.0)      = %d\\n\", isgreater(2.0,1.0));\n    printf(\"isgreater(1.0,2.0)      = %d\\n\", isgreater(1.0,2.0));\n    printf(\"isgreater(INFINITY,1.0) = %d\\n\", isgreater(INFINITY,1.0));\n    printf(\"isgreater(1.0,NAN)      = %d\\n\", isgreater(1.0,NAN));\n \n    return 0;\n}\n```\n\nPossible output:\n\n```\nisgreater(2.0,1.0)      = 1\nisgreater(1.0,2.0)      = 0\nisgreater(INFINITY,1.0) = 1\nisgreater(1.0,NAN)      = 0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.14.1 The isgreater macro (p: 189)\n  - F.10.11 Comparison macros (p: 386-387)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.14.1 The isgreater macro (p: 259)\n  - F.10.11 Comparison macros (p: 531)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.14.1 The isgreater macro (p: 240)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/isgreater](https://en.cppreference.com/w/c/numeric/math/isgreater)"
- name: isgreaterequal
  summary: Determines if the floating point number x is greater than or equal to the floating-point number y, without setting floating-point exceptions
  description: "# isgreaterequal\n\n[TABLE]\n\nDetermines if the floating point number `x` is greater than or equal to the floating-point number `y`, without setting floating-point exceptions.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| x   | \\-  | floating point value |\n| y   | \\-  | floating point value |\n\n### Return value\n\nNonzero integral value if `x >= y`, `​0​` otherwise.\n\n### Notes\n\nThe built-in `operator>=` for floating-point numbers may raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") if one or both of the arguments is NaN. This function is a \"quiet\" version of `operator>=`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"isgreaterequal(2.0,1.0)      = %d\\n\", isgreaterequal(2.0,1.0));\n    printf(\"isgreaterequal(1.0,2.0)      = %d\\n\", isgreaterequal(1.0,2.0));\n    printf(\"isgreaterequal(1.0,1.0)      = %d\\n\", isgreaterequal(1.0,1.0));\n    printf(\"isgreaterequal(INFINITY,1.0) = %d\\n\", isgreaterequal(INFINITY,1.0));\n    printf(\"isgreaterequal(1.0,NAN)      = %d\\n\", isgreaterequal(1.0,NAN));\n \n    return 0;\n}\n```\n\nPossible output:\n\n```\nisgreaterequal(2.0,1.0)      = 1\nisgreaterequal(1.0,2.0)      = 0\nisgreaterequal(1.0,1.0)      = 1\nisgreaterequal(INFINITY,1.0) = 1\nisgreaterequal(1.0,NAN)      = 0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.14.2 The isgreaterequal macro (p: 259-260)\n  - F.10.11 Comparison macros (p: 531)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.14.2 The isgreaterequal macro (p: 240-241)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/isgreaterequal](https://en.cppreference.com/w/c/numeric/math/isgreaterequal)"
- name: isinf
  summary: Determines if the given floating-point number arg is positive or negative infinity
  description: "# isinf\n\n[TABLE]\n\nDetermines if the given floating-point number `arg` is positive or negative infinity. The macro returns an integral value.\n\n[`FLT_EVAL_METHOD`](../../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\") is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating-point value |\n\n### Return value\n\nNonzero integral value if `arg` has an infinite value, `​0​` otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nint main(void)\n{\n    printf(\"isinf(NAN)         = %d\\n\", isinf(NAN));\n    printf(\"isinf(INFINITY)    = %d\\n\", isinf(INFINITY));\n    printf(\"isinf(0.0)         = %d\\n\", isinf(0.0));\n    printf(\"isinf(DBL_MIN/2.0) = %d\\n\", isinf(DBL_MIN/2.0));\n    printf(\"isinf(1.0)         = %d\\n\", isinf(1.0));\n    printf(\"isinf(exp(800))    = %d\\n\", isinf(exp(800)));\n}\n```\n\nPossible output:\n\n```\nisinf(NAN)         = 0\nisinf(INFINITY)    = 1\nisinf(0.0)         = 0\nisinf(DBL_MIN/2.0) = 0\nisinf(1.0)         = 0\nisinf(exp(800))    = 1\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.3.3 The isinf macro (p: 172)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.3.3 The isinf macro (p: 236)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.3.3 The isinf macro (p: 217)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/isinf](https://en.cppreference.com/w/c/numeric/math/isinf)"
- name: isless
  summary: Determines if the floating point number x is less than the floating-point number y, without setting floating-point exceptions
  description: "# isless\n\n[TABLE]\n\nDetermines if the floating point number `x` is less than the floating-point number `y`, without setting floating-point exceptions.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| x   | \\-  | floating point value |\n| y   | \\-  | floating point value |\n\n### Return value\n\nNonzero integral value if `x < y`, `​0​` otherwise.\n\n### Notes\n\nThe built-in `operator<` for floating-point numbers may raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") if one or both of the arguments is NaN. This function is a \"quiet\" version of `operator<`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"isless(2.0,1.0)      = %d\\n\", isless(2.0,1.0));\n    printf(\"isless(1.0,2.0)      = %d\\n\", isless(1.0,2.0));\n    printf(\"isless(INFINITY,1.0) = %d\\n\", isless(INFINITY,1.0));\n    printf(\"isless(1.0,NAN)      = %d\\n\", isless(1.0,NAN));\n \n    return 0;\n}\n```\n\nPossible output:\n\n```\nisless(2.0,1.0)      = 0\nisless(1.0,2.0)      = 1\nisless(INFINITY,1.0) = 0\nisless(1.0,NAN)      = 0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.14.3 The isless macro (p: 260)\n  - F.10.11 Comparison macros (p: 531)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.14.3 The isless macro (p: 241)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/isless](https://en.cppreference.com/w/c/numeric/math/isless)"
- name: islessequal
  summary: Determines if the floating point number x is less than or equal to the floating-point number y, without setting floating-point exceptions
  description: "# islessequal\n\n[TABLE]\n\nDetermines if the floating point number `x` is less than or equal to the floating-point number `y`, without setting floating-point exceptions.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| x   | \\-  | floating point value |\n| y   | \\-  | floating point value |\n\n### Return value\n\nNonzero integral value if `x <= y`, `​0​` otherwise.\n\n### Notes\n\nThe built-in `operator<=` for floating-point numbers may raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") if one or both of the arguments is NaN. This function is a \"quiet\" version of `operator<=`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"islessequal(2.0,1.0)      = %d\\n\", islessequal(2.0,1.0));\n    printf(\"islessequal(1.0,2.0)      = %d\\n\", islessequal(1.0,2.0));\n    printf(\"islessequal(1.0,1.0)      = %d\\n\", islessequal(1.0,1.0));\n    printf(\"islessequal(INFINITY,1.0) = %d\\n\", islessequal(INFINITY,1.0));\n    printf(\"islessequal(1.0,NAN)      = %d\\n\", islessequal(1.0,NAN));\n \n    return 0;\n}\n```\n\nPossible output:\n\n```\nislessequal(2.0,1.0)      = 0\nislessequal(1.0,2.0)      = 1\nislessequal(1.0,1.0)      = 1\nislessequal(INFINITY,1.0) = 0\nislessequal(1.0,NAN)      = 0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.14.4 The islessequal macro (p: 260)\n  - F.10.11 Comparison macros (p: 531)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.14.4 The islessequal macro (p: 241)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/islessequal](https://en.cppreference.com/w/c/numeric/math/islessequal)"
- name: islessgreater
  summary: Determines if the floating point number x is less than or greater than the floating-point number y, without setting floating-point exceptions
  description: "# islessgreater\n\n[TABLE]\n\nDetermines if the floating point number `x` is less than or greater than the floating-point number `y`, without setting floating-point exceptions.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| x   | \\-  | floating point value |\n| y   | \\-  | floating point value |\n\n### Return value\n\nNonzero integral value if `x < y || x > y`, `​0​` otherwise.\n\n### Notes\n\nThe built-in `operator<` and `operator>` for floating-point numbers may raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") if one or both of the arguments is NaN. This function is a \"quiet\" version of the expression `x < y || x > y`. The macro does not evaluate x and y twice.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"islessgreater(2.0,1.0)      = %d\\n\", islessgreater(2.0,1.0));\n    printf(\"islessgreater(1.0,2.0)      = %d\\n\", islessgreater(1.0,2.0));\n    printf(\"islessgreater(1.0,1.0)      = %d\\n\", islessgreater(1.0,1.0));\n    printf(\"islessgreater(INFINITY,1.0) = %d\\n\", islessgreater(INFINITY,1.0));\n    printf(\"islessgreater(1.0,NAN)      = %d\\n\", islessgreater(1.0,NAN));\n \n    return 0;\n}\n```\n\nPossible output:\n\n```\nislessgreater(2.0,1.0)      = 1\nislessgreater(1.0,2.0)      = 1\nislessgreater(1.0,1.0)      = 0\nislessgreater(INFINITY,1.0) = 1\nislessgreater(1.0,NAN)      = 0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.14.5 The islessgreater macro (p: 261)\n  - F.10.11 Comparison macros (p: 531)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.14.5 The islessgreater macro (p: 241-242)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/islessgreater](https://en.cppreference.com/w/c/numeric/math/islessgreater)"
- name: islower
  summary: Checks if the given character is classified as a lowercase character according to the current C locale
  description: "# islower\n\n[TABLE]\n\nChecks if the given character is classified as a lowercase character according to the current C locale. In the default \"C\" locale, `islower` returns true only for the lowercase letters (`abcdefghijklmnopqrstuvwxyz`).\n\nIf `islower` returns `true`, it is guaranteed that [`iscntrl`](iscntrl \"c/string/byte/iscntrl\"), [`isdigit`](isdigit \"c/string/byte/isdigit\"), [`ispunct`](ispunct \"c/string/byte/ispunct\"), and [`isspace`](isspace \"c/string/byte/isspace\") return `false` for the same character in the same C locale.\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character is a lowercase letter, zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <locale.h>\n \nint main(void)\n{\n    unsigned char c = '\\xe5'; // letter å in ISO-8859-1\n    printf(\"In the default C locale, \\\\xe5 is %slowercase\\n\",\n           islower(c) ? \"\" : \"not \" );\n    setlocale(LC_ALL, \"en_GB.iso88591\");\n    printf(\"In ISO-8859-1 locale, \\\\xe5 is %slowercase\\n\",\n           islower(c) ? \"\" : \"not \" );\n}\n```\n\nPossible output:\n\n```\nIn the default C locale, \\xe5 is not lowercase\nIn ISO-8859-1 locale, \\xe5 is lowercase\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.7 The islower function (p: 146)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.7 The islower function (p: 202)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.7 The islower function (p: 183)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.6 The islower function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/islower](https://en.cppreference.com/w/c/string/byte/islower)"
- name: isnan
  summary: Determines if the given floating point number arg is a not-a-number (NaN) value
  description: "# isnan\n\n[TABLE]\n\nDetermines if the given floating point number `arg` is a not-a-number (NaN) value. The macro returns an integral value.\n\n[`FLT_EVAL_METHOD`](../../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\") is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that (this matters if the evaluation type supports NaNs, while the semantic type does not).\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nNonzero integral value if `arg` is a NaN, `​0​` otherwise.\n\n### Notes\n\nThere are many different NaN values with different sign bits and payloads, see [`nan`](nan \"c/numeric/math/nan\").\n\nNaN values never compare equal to themselves or to other NaN values. Copying a NaN may change its bit pattern.\n\nAnother way to test if a floating-point value is NaN is to compare it with itself: `bool is_nan(double x) { return x != x; }`\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nint main(void)\n{\n    printf(\"isnan(NAN)         = %d\\n\", isnan(NAN));\n    printf(\"isnan(INFINITY)    = %d\\n\", isnan(INFINITY));\n    printf(\"isnan(0.0)         = %d\\n\", isnan(0.0));\n    printf(\"isnan(DBL_MIN/2.0) = %d\\n\", isnan(DBL_MIN/2.0));\n    printf(\"isnan(0.0 / 0.0)   = %d\\n\", isnan(0.0/0.0));\n    printf(\"isnan(Inf - Inf)   = %d\\n\", isnan(INFINITY - INFINITY));\n}\n```\n\nPossible output:\n\n```\nisnan(NAN)         = 1\nisnan(INFINITY)    = 0\nisnan(0.0)         = 0\nisnan(DBL_MIN/2.0) = 0\nisnan(0.0 / 0.0)   = 1\nisnan(Inf - Inf)   = 1\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.3.4 The isnan macro (p: 236-237)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.3.4 The isnan macro (p: 217)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/isnan](https://en.cppreference.com/w/c/numeric/math/isnan)"
- name: isnormal
  summary: Determines if the given floating point number arg is normal, i.e
  description: "# isnormal\n\n[TABLE]\n\nDetermines if the given floating point number `arg` is normal, i.e. is neither zero, subnormal, infinite, nor `NaN`. The macro returns an integral value.\n\n[`FLT_EVAL_METHOD`](../../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\") is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nNonzero integral value if `arg` is normal, `​0​` otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nint main(void)\n{\n    printf(\"isnormal(NAN)         = %d\\n\", isnormal(NAN));\n    printf(\"isnormal(INFINITY)    = %d\\n\", isnormal(INFINITY));\n    printf(\"isnormal(0.0)         = %d\\n\", isnormal(0.0));\n    printf(\"isnormal(DBL_MIN/2.0) = %d\\n\", isnormal(DBL_MIN/2.0));\n    printf(\"isnormal(1.0)         = %d\\n\", isnormal(1.0));\n}\n```\n\nOutput:\n\n```\nisnormal(NAN)         = 0\nisnormal(INFINITY)    = 0\nisnormal(0.0)         = 0\nisnormal(DBL_MIN/2.0) = 0\nisnormal(1.0)         = 1\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.3.5 The isnormal macro (p: 237)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.3.5 The isnormal macro (p: 217-218)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/isnormal](https://en.cppreference.com/w/c/numeric/math/isnormal)"
- name: isprint
  summary: Checks if the given character can be printed, i.e
  description: "# isprint\n\n[TABLE]\n\nChecks if the given character can be printed, i.e. it is either a number (`0123456789`), an uppercase letter (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`), a lowercase letter (`abcdefghijklmnopqrstuvwxyz`), a punctuation character(`` !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ ``), or space, or any character classified as printable by the current C locale.\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character can be printed, zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <locale.h>\n \nint main(void)\n{\n    unsigned char c = '\\xa0'; // the non-breaking space in ISO-8859-1\n    printf(\"In the default C locale, \\\\xa0 is %sprintable\\n\", isprint(c)?\"\":\"not \");\n    setlocale(LC_ALL, \"en_GB.iso88591\");\n    printf(\"In ISO-8859-1 locale, \\\\xa0 is %sprintable\\n\", isprint(c)?\"\":\"not \");\n}\n```\n\nPossible output:\n\n```\nIn the default C locale, \\xa0 is not printable\nIn ISO-8859-1 locale, \\xa0 is printable\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.8 The isprint function (p: 146)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.8 The isprint function (p: 202)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.8 The isprint function (p: 183)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.7 The isprint function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/isprint](https://en.cppreference.com/w/c/string/byte/isprint)"
- name: ispunct
  summary: Checks if the given character is a punctuation character in the current C locale
  description: "# ispunct\n\n[TABLE]\n\nChecks if the given character is a punctuation character in the current C locale. The default C locale classifies the characters `` !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ `` as punctuation.\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character is a punctuation character, zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <locale.h>\n \nint main(void)\n{\n    unsigned char c = '\\xd7'; // the character × (multiplication sign) in ISO-8859-1\n    printf(\"In the default C locale, \\\\xd7 is %spunctuation\\n\",\n           ispunct(c) ? \"\" : \"not \" );\n    setlocale(LC_ALL, \"en_GB.iso88591\");\n    printf(\"In ISO-8859-1 locale, \\\\xd7 is %spunctuation\\n\",\n           ispunct(c) ? \"\" : \"not \" );\n}\n```\n\nPossible output:\n\n```\nIn the default C locale, \\xd7 is not punctuation\nIn ISO-8859-1 locale, \\xd7 is punctuation\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.9 The ispunct function (p: 146)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.9 The ispunct function (p: 202)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.9 The ispunct function (p: 183)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.8 The ispunct function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/ispunct](https://en.cppreference.com/w/c/string/byte/ispunct)"
- name: isspace
  summary: Checks if the given character is either
  description: "# isspace\n\n[TABLE]\n\nChecks if the given character is either\n\n- A standard white-space character:\n  - Space (0x20, `' '`),\n  - Form feed (0x0c, `'\\f'`),\n  - Line feed (0x0a, `'\\n'`),\n  - Carriage return (0x0d, `'\\r'`),\n  - Horizontal tab (0x09, `'\\t'`),\n  - Vertical tab (0x0b, `'\\v'`),\n- Or a locale-specific white-space character.\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](../../io \"c/io\").\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character is a whitespace character, zero otherwise.\n\n### Example\n\n```\n#include <ctype.h>\n#include <limits.h>\n#include <stdio.h>\n \nint main(void)\n{\n    for (int ndx = 0; ndx <= UCHAR_MAX; ndx++)\n        if (isspace(ndx))\n            printf(\"0x%02x \", ndx);\n}\n```\n\nOutput:\n\n```\n0x09 0x0a 0x0b 0x0c 0x0d 0x20\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.4.1.10 The isspace function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.10 The isspace function (p: 147)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.10 The isspace function (p: 202-203)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.10 The isspace function (p: 183-184)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.9 The isspace function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/isspace](https://en.cppreference.com/w/c/string/byte/isspace)"
- name: isunordered
  summary: Determines if the floating point numbers x and y are unordered, that is, one or both are NaN and thus cannot be meaningfully compared with each other
  description: "# isunordered\n\n[TABLE]\n\nDetermines if the floating point numbers `x` and `y` are unordered, that is, one or both are NaN and thus cannot be meaningfully compared with each other.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| x   | \\-  | floating point value |\n| y   | \\-  | floating point value |\n\n### Return value\n\nNonzero integral value if either `x` or `y` is NaN, `​0​` otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"isunordered(NAN,1.0) = %d\\n\", isunordered(NAN,1.0));\n    printf(\"isunordered(1.0,NAN) = %d\\n\", isunordered(1.0,NAN));\n    printf(\"isunordered(NAN,NAN) = %d\\n\", isunordered(NAN,NAN));\n    printf(\"isunordered(1.0,0.0) = %d\\n\", isunordered(1.0,0.0));\n \n    return 0;\n}\n```\n\nPossible output:\n\n```\nisunordered(NAN,1.0) = 1\nisunordered(1.0,NAN) = 1\nisunordered(NAN,NAN) = 1\nisunordered(1.0,0.0) = 0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.14.6 The isunordered macro (p: 261)\n  - F.10.11 Comparison macros (p: 531)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.14.6 The isunordered macro (p: 242)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/isunordered](https://en.cppreference.com/w/c/numeric/math/isunordered)"
- name: isupper
  summary: Checks if the given character is an uppercase character according to the current C locale
  description: "# isupper\n\n[TABLE]\n\nChecks if the given character is an uppercase character according to the current C locale. In the default \"C\" locale, `isupper` returns true only for the uppercase letters (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`).\n\nIf `isupper` returns `true`, it is guaranteed that [`iscntrl`](iscntrl \"c/string/byte/iscntrl\"), [`isdigit`](isdigit \"c/string/byte/isdigit\"), [`ispunct`](ispunct \"c/string/byte/ispunct\"), and [`isspace`](isspace \"c/string/byte/isspace\") return `false` for the same character in the same C locale.\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character is an uppercase letter, zero otherwise.\n\n### Example\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <locale.h>\n \nint main(void)\n{\n    unsigned char c = '\\xc6'; // letter Æ in ISO-8859-1\n    printf(\"In the default C locale, \\\\xc6 is %suppercase\\n\",\n           isupper(c) ? \"\" : \"not \" );\n    setlocale(LC_ALL, \"en_GB.iso88591\");\n    printf(\"In ISO-8859-1 locale, \\\\xc6 is %suppercase\\n\",\n           isupper(c) ? \"\" : \"not \" );\n}\n```\n\nPossible output:\n\n```\nIn the default C locale, \\xc6 is not uppercase\nIn ISO-8859-1 locale, \\xc6 is uppercase\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.11 The isupper function (p: 147)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.11 The isupper function (p: 203)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.11 The isupper function (p: 184)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.10 The isupper function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/isupper](https://en.cppreference.com/w/c/string/byte/isupper)"
- name: iswalnum
  summary: Checks if the given wide character is an alphanumeric character, i.e
  description: "# iswalnum\n\n[TABLE]\n\nChecks if the given wide character is an alphanumeric character, i.e. either a number (0123456789), an uppercase letter (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`), a lowercase letter (`abcdefghijklmnopqrstuvwxyz`) or any alphanumeric character specific to the current locale.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character is an alphanumeric character, zero otherwise.\n\n### Notes\n\n[ISO 30112](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) specifies which Unicode characters are include in POSIX alnum category.\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <wchar.h>\n#include <wctype.h>\n \nint main(void)\n{\n    wchar_t c = L'\\u13ad'; // the Cherokee letter HA ('Ꭽ')\n    printf(\"in the default locale, iswalnum(%#x) = %d\\n\", c, !!iswalnum(c));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"in Unicode locale, iswalnum(%#x) = %d\\n\", c, !!iswalnum(c));\n}\n```\n\nPossible output:\n\n```\nin the default locale, iswalnum(0x13ad) = 0\nin Unicode locale, iswalnum(0x13ad) = 1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - TBD The iswalnum function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.1 The iswalnum function (p: 327)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.1 The iswalnum function (p: 448)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.1 The iswalnum function (p: 394)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswalnum](https://en.cppreference.com/w/c/string/wide/iswalnum)"
- name: iswalpha
  summary: Checks if the given wide character is an alphabetic character, i.e
  description: "# iswalpha\n\n[TABLE]\n\nChecks if the given wide character is an alphabetic character, i.e. either an uppercase letter (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`), a lowercase letter (`abcdefghijklmnopqrstuvwxyz`) or any alphabetic character specific to the current locale.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character is an alphabetic character, zero otherwise.\n\n### Notes\n\n[ISO 30112](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) specifies which Unicode characters are include in POSIX alpha category.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nint main(void)\n{\n    wchar_t c = L'\\u0b83'; // Tamil sign Visarga ('ஃ')\n    printf(\"in the default locale, iswalpha(%#x) = %d\\n\", c, !!iswalpha(c));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"in Unicode locale, iswalpha(%#x) = %d\\n\", c, !!iswalpha(c));\n}\n```\n\nPossible output:\n\n```\nin the default locale, iswalpha(0xb83) = 0\nin Unicode locale, iswalpha(0xb83) = 1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - TBD The iswalpha function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.2 The iswalpha function (p: 327)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.2 The iswalpha function (p: 448-449)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.2 The iswalpha function (p: 394-395)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswalpha](https://en.cppreference.com/w/c/string/wide/iswalpha)"
- name: iswblank
  summary: Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale
  description: "# iswblank\n\n[TABLE]\n\nChecks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (`0x20`) and horizontal tab (`0x09`) are blank characters.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character is a blank character, zero otherwise.\n\n### Notes\n\n[ISO 30112](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) defines POSIX blank characters as Unicode characters U+0009, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008, U+200A, U+205F, and U+3000.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nint main(void)\n{\n    wchar_t c = L'\\u3000'; // Ideographic space ('　')\n    printf(\"In the default locale, iswblank(%#x) = %d\\n\", c, !!iswblank(c));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"In Unicode locale, iswblank(%#x) = %d\\n\", c, !!iswblank(c));\n}\n```\n\nOutput:\n\n```\nIn the default locale, iswblank(0x3000) = 0\nIn Unicode locale, iswblank(0x3000) = 1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.1.3 The iswblank function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.3 The iswblank function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.3 The iswblank function (p: 449)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.3 The iswblank function (p: 395)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswblank](https://en.cppreference.com/w/c/string/wide/iswblank)"
- name: iswcntrl
  summary: Checks if the given wide character is a control character, i.e
  description: "# iswcntrl\n\n[TABLE]\n\nChecks if the given wide character is a control character, i.e. codes `0x00-0x1F` and `0x7F` and any control characters specific to the current locale.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character is a control character, zero otherwise.\n\n### Notes\n\n[ISO 30112](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp)\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nint main(void)\n{\n    wchar_t c = L'\\u2028'; // the Unicode character \"line separator\"\n    printf(\"In the default locale, iswcntrl(%#x) = %d\\n\", c, !!iswcntrl(c));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"In Unicode locale, iswcntrl(%#x) = %d\\n\", c, !!iswcntrl(c));\n}\n```\n\nOutput:\n\n```\nIn the default locale, iswcntrl(0x2028) = 0\nIn Unicode locale, iswcntrl(0x2028) = 1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.1.4 The iswcntrl function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.4 The iswcntrl function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.4 The iswcntrl function (p: 449)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.4 The iswcntrl function (p: 395)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswcntrl](https://en.cppreference.com/w/c/string/wide/iswcntrl)"
- name: iswctype
  summary: Classifies the wide character wc using the current C locale's LC_CTYPE category identified by desc
  description: "# iswctype\n\n[TABLE]\n\nClassifies the wide character `wc` using the current C locale's [`LC_CTYPE`](../../locale/lc_categories \"c/locale/LC categories\") category identified by `desc`.\n\n### Parameters\n\n|      |     |                                                                                                                                                   |\n|------|-----|---------------------------------------------------------------------------------------------------------------------------------------------------|\n| wc   | \\-  | the wide character to classify                                                                                                                    |\n| desc | \\-  | the [`LC_CTYPE`](../../locale/lc_categories \"c/locale/LC categories\") category, obtained from a call to [`wctype`](wctype \"c/string/wide/wctype\") |\n\n### Return value\n\nNon-zero if the character `wc` has the property identified by `desc` in [`LC_CTYPE`](../../locale/lc_categories \"c/locale/LC categories\") facet of the current C locale, zero otherwise.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nconst char* classify(wchar_t wc, const char* cat)\n{\n    return iswctype(wc, wctype(cat)) ? \"true\" : \"false\";\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"ja_JP.UTF-8\");\n    puts(\"The character \\u6c34 is...\");\n    const char* cats[] = {\"digit\", \"alpha\", \"space\", \"cntrl\", \"jkanji\"};\n    for (int n = 0; n < 5; ++n)\n        printf(\"%s?\\t%s\\n\", cats[n], classify(L'\\u6c34', cats[n]));\n}\n```\n\nOutput:\n\n```\nThe character 水 is...\ndigit?  false\nalpha?  true\nspace?  false\ncntrl?  false\njkanji? true\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.2.1 The iswctype function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.2.1 The iswctype function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.2.1 The iswctype function (p: 451-452)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.2.1 The iswctype function (p: 397-398)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswctype](https://en.cppreference.com/w/c/string/wide/iswctype)"
- name: iswdigit
  summary: Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789
  description: "# iswdigit\n\n[TABLE]\n\nChecks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character is a numeric character, zero otherwise.\n\n### Notes\n\n`iswdigit` and [`iswxdigit`](iswxdigit \"c/string/wide/iswxdigit\") are the only standard wide character classification functions that are not affected by the currently installed C locale.\n\n### Example\n\nSome locales offer additional character classes that detect non-ASCII digits\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nvoid test(wchar_t a3, wchar_t u3, wchar_t j3)\n{\n    printf(\"\\t '%lc'  '%lc' '%lc'\\n\", a3, u3, j3);\n    printf(\"iswdigit: %d    %d    %d\\n\",\n           !!iswdigit(a3),\n           !!iswdigit(u3),\n           !!iswdigit(j3));\n    printf(\"jdigit:   %d    %d    %d\\n\",\n           !!iswctype(a3, wctype(\"jdigit\")),\n           !!iswctype(u3, wctype(\"jdigit\")),\n           !!iswctype(j3, wctype(\"jdigit\")));\n}\n \nint main(void)\n{\n    wchar_t a3 = L'3';  // the ASCII digit 3\n    wchar_t u3 = L'三'; // the CJK numeral 3\n    wchar_t j3 = L'３'; // the full-width digit 3\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    puts(\"In American locale:\");\n    test(a3, u3, j3);\n \n    setlocale(LC_ALL, \"ja_JP.utf8\");\n    puts(\"\\nIn Japanese locale:\");\n    test(a3, u3, j3);\n}\n```\n\nPossible output:\n\n```\nIn American locale:\n         '3'  '三' '３'\niswdigit: 1    0    0\njdigit:   0    0    0\n \nIn Japanese locale:\n         '3'  '三' '３'\niswdigit: 1    0    0\njdigit:   0    0    1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - TBD 7.30.2.1.5 The iswdigit function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.5 The iswdigit function (p: 327)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.5 The iswdigit function (p: 449)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.5 The iswdigit function (p: 395)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswdigit](https://en.cppreference.com/w/c/string/wide/iswdigit)"
- name: iswgraph
  summary: Checks if the given wide character has a graphical representation, i.e
  description: "# iswgraph\n\n[TABLE]\n\nChecks if the given wide character has a graphical representation, i.e. it is either a number (`0123456789`), an uppercase letter (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`), a lowercase letter (`abcdefghijklmnopqrstuvwxyz`), a punctuation character (`` !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ ``) or any graphical character specific to the current C locale.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character has a graphical representation character, zero otherwise.\n\n### Notes\n\n[ISO 30112](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) specifies which Unicode characters are include in POSIX graph category.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nint main(void)\n{\n    wchar_t c = L'\\u2602'; // the Unicode character Umbrella ('☂')\n    printf(\"in the default locale, iswgraph(%#x) = %d\\n\", c, !!iswgraph(c));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"in Unicode locale, iswgraph(%#x) = %d\\n\", c, !!iswgraph(c));\n}\n```\n\nOutput:\n\n```\nin the default locale, iswgraph(0x2602) = 0\nin Unicode locale, iswgraph(0x2602) = 1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.1.6 The iswgraph function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.6 The iswgraph function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.6 The iswgraph function (p: 449-450)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.6 The iswgraph function (p: 395-396)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswgraph](https://en.cppreference.com/w/c/string/wide/iswgraph)"
- name: iswlower
  summary: Checks if the given wide character is a lowercase letter, i.e
  description: "# iswlower\n\n[TABLE]\n\nChecks if the given wide character is a lowercase letter, i.e. one of `abcdefghijklmnopqrstuvwxyz` or any lowercase letter specific to the current locale.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character is an lowercase letter, zero otherwise.\n\n### Notes\n\n[ISO 30112](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) specifies which Unicode characters are include in POSIX lower category.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nint main(void)\n{\n    wchar_t c = L'\\u0444'; // Cyrillic small letter ef ('ф')\n    printf(\"In the default locale, iswlower(%#x) = %d\\n\", c, !!iswlower(c));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"In Unicode locale, iswlower(%#x) = %d\\n\", c, !!iswlower(c));\n}\n```\n\nOutput:\n\n```\nIn the default locale, iswlower(0x444) = 0\nIn Unicode locale, iswlower(0x444) = 1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.1.7 The iswlower function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.7 The iswlower function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.7 The iswlower function (p: 450)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.7 The iswlower function (p: 396)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswlower](https://en.cppreference.com/w/c/string/wide/iswlower)"
- name: iswprint
  summary: Checks if the given wide character can be printed, i.e
  description: "# iswprint\n\n[TABLE]\n\nChecks if the given wide character can be printed, i.e. it is either a number (`0123456789`), an uppercase letter (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`), a lowercase letter (`abcdefghijklmnopqrstuvwxyz`), a punctuation character (`` !\"#$%&'()*+,-./:;<=>?@[\\]^_`{!}~ ``), space or any printable character specific to the current C locale.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character can be printed, zero otherwise.\n\n### Notes\n\n[ISO 30112](http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) specifies which Unicode characters are included in POSIX print category.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nint main(void)\n{\n    wchar_t c = L'\\u2002'; // Unicode character 'EN SPACE'\n    printf(\"in the default locale, iswprint(%#x) = %d\\n\", c, !!iswprint(c));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"in Unicode locale, iswprint(%#x) = %d\\n\", c, !!iswprint(c));\n    wchar_t c2 = L'\\x82'; // break permitted\n    printf(\"in Unicode locale, iswprint(%#x) = %d\\n\", c2, !!iswprint(c2));\n}\n```\n\nOutput:\n\n```\nin the default locale, iswprint(0x2002) = 0\nin Unicode locale, iswprint(0x2002) = 1\nin Unicode locale, iswprint(0x82) = 0\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.1.8 The iswprint function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.8 The iswprint function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.8 The iswprint function (p: 450)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.8 The iswprint function (p: 396)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswprint](https://en.cppreference.com/w/c/string/wide/iswprint)"
- name: iswpunct
  summary: Checks if the given wide character is a punctuation character, i.e
  description: "# iswpunct\n\n[TABLE]\n\nChecks if the given wide character is a punctuation character, i.e. it is one of `` !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ `` or any punctuation character specific to the current locale.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character is a punctuation character, zero otherwise.\n\n### Notes\n\n[ISO 30112](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) specifies which Unicode characters are include in POSIX punct category.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n \nint main(void)\n{\n    const wchar_t c = L'\\u2051'; // Two asterisks ('⁑')\n    printf(\"in the default locale, iswpunct(%#x) = %d\\n\", c, !!iswpunct(c));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"in Unicode locale, iswpunct(%#x) = %d\\n\", c, !!iswpunct(c));\n}\n```\n\nOutput:\n\n```\nin the default locale, iswpunct(0x2051) = 0\nin Unicode locale, iswpunct(0x2051) = 1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.1.9 The iswpunct function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.9 The iswpunct function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.9 The iswpunct function (p: 450)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.9 The iswpunct function (p: 396)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswpunct](https://en.cppreference.com/w/c/string/wide/iswpunct)"
- name: iswspace
  summary: Checks if the given wide character is a whitespace character, i.e
  description: "# iswspace\n\n[TABLE]\n\nChecks if the given wide character is a whitespace character, i.e. either space (`0x20`), form feed (`0x0c`), line feed (`0x0a`), carriage return (`0x0d`), horizontal tab (`0x09`), vertical tab (`0x0b`) or any whitespace character specific to the current locale.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character is a whitespace character, zero otherwise.\n\n### Notes\n\n[ISO 30112](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nint main(void)\n{\n    wchar_t c = L'\\u2003'; // Unicode character 'EM SPACE'\n    printf(\"In the default locale, iswspace(%#x) = %d\\n\", c, !!iswspace(c));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"In Unicode locale, iswspace(%#x) = %d\\n\", c, !!iswspace(c));\n}\n```\n\nOutput:\n\n```\nIn the default locale, iswspace(0x2003) = 0\nIn Unicode locale, iswspace(0x2003) = 1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.1.10 The iswspace function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.10 The iswspace function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.10 The iswspace function (p: 450-451)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.10 The iswspace function (p: 396-397)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswspace](https://en.cppreference.com/w/c/string/wide/iswspace)"
- name: iswupper
  summary: Checks if the given wide character is an uppercase letter, i.e
  description: "# iswupper\n\n[TABLE]\n\nChecks if the given wide character is an uppercase letter, i.e. one of `ABCDEFGHIJKLMNOPQRSTUVWXYZ` or any uppercase letter specific to the current locale.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character is an uppercase letter, zero otherwise.\n\n### Notes\n\n[ISO 30112](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) specifies which Unicode characters are include in POSIX upper category.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nint main(void)\n{\n    wchar_t c = L'\\u053d'; // Armenian capital letter xeh ('Խ')\n    printf(\"In the default locale, iswupper(%#x) = %d\\n\", c, !!iswupper(c));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"In Unicode locale, iswupper(%#x) = %d\\n\", c, !!iswupper(c));\n}\n```\n\nOutput:\n\n```\nIn the default locale, iswupper(0x53d) = 0\nIn Unicode locale, iswupper(0x53d) = 1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.1.11 The iswupper function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.11 The iswupper function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.11 The iswupper function (p: 451)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.11 The iswupper function (p: 397)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswupper](https://en.cppreference.com/w/c/string/wide/iswupper)"
- name: iswxdigit
  summary: Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e
  description: "# iswxdigit\n\n[TABLE]\n\nChecks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of `0123456789abcdefABCDEF`.\n\n### Parameters\n\n|     |     |                |\n|-----|-----|----------------|\n| ch  | \\-  | wide character |\n\n### Return value\n\nNon-zero value if the wide character is a hexadecimal numeric character, zero otherwise.\n\n### Notes\n\n[`iswdigit`](iswdigit \"c/string/wide/iswdigit\") and `iswxdigit` are the only standard wide character classification functions that are not affected by the currently installed C locale.\n\n### Example\n\nSome locales offer additional character classes that detect non-ASCII digits\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nvoid test(wchar_t a3, wchar_t u3, wchar_t j3)\n{\n    printf(\"\\t  '%lc'  '%lc' '%lc'\\n\", a3, u3, j3);\n    printf(\"iswxdigit: %d    %d    %d\\n\",\n           !!iswxdigit(a3),\n           !!iswxdigit(u3),\n           !!iswxdigit(j3));\n    printf(\"jdigit:    %d    %d    %d\\n\",\n           !!iswctype(a3, wctype(\"jdigit\")),\n           !!iswctype(u3, wctype(\"jdigit\")),\n           !!iswctype(j3, wctype(\"jdigit\")));\n}\n \nint main(void)\n{\n    wchar_t a3 = L'9';  // the ASCII digit 9\n    wchar_t u3 = L'〩'; // the CJK numeral 9\n    wchar_t j3 = L'９'; // the full-width digit 9\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    puts(\"In American locale:\");\n    test(a3, u3, j3);\n \n    setlocale(LC_ALL, \"ja_JP.utf8\");\n    puts(\"\\nIn Japanese locale:\");\n    test(a3, u3, j3);\n}\n```\n\nPossible output:\n\n```\nIn American locale:\n          '9'  '〩' '９'\niswxdigit: 1    0    0\njdigit:    0    0    0\n \nIn Japanese locale:\n          '9'  '〩' '９'\niswxdigit: 1    0    0\njdigit:    0    0    1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.1.12 The iswxdigit function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.1.12 The iswxdigit function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.1.12 The iswxdigit function (p: 451)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.1.12 The iswxdigit function (p: 397)\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/iswxdigit](https://en.cppreference.com/w/c/string/wide/iswxdigit)"
- name: isxdigit
  summary: Checks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF) or is classified as a hexadecimal character
  description: "# isxdigit\n\n[TABLE]\n\nChecks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF) or is classified as a hexadecimal character.\n\nThe behavior is undefined if the value of `ch` is not representable as `unsigned char` and is not equal to [`EOF`](http://en.cppreference.com/w/c/io).\n\n### Parameters\n\n|     |     |                       |\n|-----|-----|-----------------------|\n| ch  | \\-  | character to classify |\n\n### Return value\n\nNon-zero value if the character is an hexadecimal numeric character, zero otherwise.\n\n### Notes\n\n`isdigit` and `isxdigit` are the only standard narrow character classification functions that are not affected by the currently installed C locale, although some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits.\n\n### Example\n\n```\n#include <ctype.h>\n#include <limits.h>\n#include <stdio.h>\n \nint main(void)\n{\n    for (int ndx = 0; UCHAR_MAX >= ndx; ++ndx)\n        if (isxdigit(ndx))\n            printf(\"%c\", ndx);\n    printf(\"\\n\");\n}\n```\n\nOutput:\n\n```\n0123456789ABCDEFabcdef\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.1.12 The isxdigit function (p: 147)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.1.12 The isxdigit function (p: 203)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.1.12 The isxdigit function (p: 184)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.1.11 The isxdigit function\n\n### See also\n\n[TABLE]\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/isxdigit](https://en.cppreference.com/w/c/string/byte/isxdigit)"
- name: jmp_buf
  summary: The jmp_buf type is an array type suitable for storing information to restore a calling environment
  description: "# jmp_buf\n\n[TABLE]\n\nThe `jmp_buf` type is an array type suitable for storing information to restore a calling environment. The stored information is sufficient to restore execution at the correct block of the program and invocation of that block. The state of floating-point status flags, or open files, or any other data is not stored in an object of type `jmp_buf`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.13/2 Nonlocal jumps \\<setjmp.h\\> (p: 191)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.13/2 Nonlocal jumps \\<setjmp.h\\> (p: 262)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.13/2 Nonlocal jumps \\<setjmp.h\\> (p: 243)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.6 NON-LOCAL JUMPS \\<setjmp.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/jmp_buf](https://en.cppreference.com/w/c/program/jmp_buf)"
- name: kill_dependency
  summary: Informs the compiler that the dependency tree started by an memory_order_consume atomic load operation does not extend past the return value of kill_dependency; that is, the argument does not carry a dependency into the return value
  description: "# kill_dependency\n\n[TABLE]\n\nInforms the compiler that the dependency tree started by an [`memory_order_consume`](memory_order \"c/atomic/memory order\") atomic load operation does not extend past the return value of `kill_dependency`; that is, the argument does not carry a dependency into the return value.\n\nThe function is implemented as a macro. `A` is the type of `y`.\n\n### Parameters\n\n|     |     |                                                                           |\n|-----|-----|---------------------------------------------------------------------------|\n| y   | \\-  | the expression whose return value is to be removed from a dependency tree |\n\n### Return value\n\nReturns `y`, no longer a part of a dependency tree.\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.17.3.1 The kill_dependency macro (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.3.1 The kill_dependency macro (p: 203-204)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.3.1 The kill_dependency macro (p: 278)\n\n### See also\n\n|                                                                                                                                  |     |\n|----------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/atomic/kill_dependency \"cpp/atomic/kill dependency\") for `kill_dependency` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/kill_dependency](https://en.cppreference.com/w/c/atomic/kill_dependency)"
- name: labs
  summary: Computes the absolute value of an integer number
  description: "# abs, labs, llabs, imaxabs\n\n[TABLE]\n\nComputes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.\n\n### Parameters\n\n|     |     |               |\n|-----|-----|---------------|\n| n   | \\-  | integer value |\n\n### Return value\n\nThe absolute value of `n` (i.e. `|n|`), if it is representable.\n\n### Notes\n\nIn 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type `int`, [`INT_MIN`](../../types/limits \"c/types/limits\") is `-2147483648`, but the would-be result `2147483648` is greater than [`INT_MAX`](../../types/limits \"c/types/limits\"), which is `2147483647`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n \nint main(void)\n{\n    printf(\"abs(+3) = %d\\n\", abs(+3));\n    printf(\"abs(-3) = %d\\n\", abs(-3));\n \n//  printf(\"%+d\\n\", abs(INT_MIN)); // undefined behavior on 2's complement systems\n}\n```\n\nOutput:\n\n```\nabs(+3) = 3\nabs(-3) = 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.2.1 The imaxabs function (p: 159)\n  - 7.22.6.1 The abs, labs and llabs functions (p: 259)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.1 The imaxabs function (p: 218)\n  - 7.22.6.1 The abs, labs and llabs functions (p: 356)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.1 The imaxabs function (p: 199-200)\n  - 7.20.6.1 The abs, labs and llabs functions (p: 320)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.6.1 The abs function\n  - 4.10.6.3 The labs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/abs](https://en.cppreference.com/w/c/numeric/math/abs)"
- name: LC_ALL
  summary: Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of setlocale
  description: "# LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME\n\n[TABLE]\n\nEach of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of [`setlocale`](setlocale \"c/locale/setlocale\").\n\n| Constant      | Explanation                                                   |\n|---------------|---------------------------------------------------------------|\n| `LC_ALL`      | selects the entire C locale                                   |\n| `LC_COLLATE`  | selects the collation category of the C locale                |\n| `LC_CTYPE`    | selects the character classification category of the C locale |\n| `LC_MONETARY` | selects the monetary formatting category of the C locale      |\n| `LC_NUMERIC`  | selects the numeric formatting category of the C locale       |\n| `LC_TIME`     | selects the time formatting category of the C locale          |\n\nAdditional macro constants, with names that begin with `LC_` followed by at least one uppercase letter, may be defined in `locale.h`. For example, the POSIX specification requires `LC_MESSAGES` (which controls, among other things, [`perror`](../io/perror \"c/io/perror\") and [`strerror`](../string/byte/strerror \"c/string/byte/strerror\")), ISO/IEC 30112:2014 ([2014 draft](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf)) additionally defines `LC_IDENTIFICATION`, `LC_XLITERATE`, `LC_NAME`, `LC_ADDRESS`, `LC_TELEPHONE`, `LC_PAPER`, `LC_MEASUREMENT`, and `LC_KEYBOARD`, which are supported by the GNU C library (except for `LC_XLITERATE`).\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <time.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.UTF-8\"); // the C locale will be the UTF-8 enabled English\n    setlocale(LC_NUMERIC, \"de_DE.utf8\"); // decimal dot will be German\n    setlocale(LC_TIME, \"ja_JP.utf8\");    // date/time formatting will be Japanese\n    wchar_t str[100];\n    time_t t = time(NULL);\n    wcsftime(str, 100, L\"%A %c\", localtime(&t));\n    wprintf(L\"Number: %.2f\\nDate: %Ls\\n\", 3.14, str);\n}\n```\n\nPossible output:\n\n```\nNumber: 3,14\nDate: 金曜日 2023年09月15日 20時04分14秒\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.11/3 Localization \\<locale.h\\> (p: 224)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.11/3 Localization \\<locale.h\\> (p: 205)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.4 LOCALIZATION \\<locale.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/locale/LC_categories](https://en.cppreference.com/w/c/locale/LC_categories)"
- name: LC_COLLATE
  summary: Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of setlocale
  description: "# LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME\n\n[TABLE]\n\nEach of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of [`setlocale`](setlocale \"c/locale/setlocale\").\n\n| Constant      | Explanation                                                   |\n|---------------|---------------------------------------------------------------|\n| `LC_ALL`      | selects the entire C locale                                   |\n| `LC_COLLATE`  | selects the collation category of the C locale                |\n| `LC_CTYPE`    | selects the character classification category of the C locale |\n| `LC_MONETARY` | selects the monetary formatting category of the C locale      |\n| `LC_NUMERIC`  | selects the numeric formatting category of the C locale       |\n| `LC_TIME`     | selects the time formatting category of the C locale          |\n\nAdditional macro constants, with names that begin with `LC_` followed by at least one uppercase letter, may be defined in `locale.h`. For example, the POSIX specification requires `LC_MESSAGES` (which controls, among other things, [`perror`](../io/perror \"c/io/perror\") and [`strerror`](../string/byte/strerror \"c/string/byte/strerror\")), ISO/IEC 30112:2014 ([2014 draft](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf)) additionally defines `LC_IDENTIFICATION`, `LC_XLITERATE`, `LC_NAME`, `LC_ADDRESS`, `LC_TELEPHONE`, `LC_PAPER`, `LC_MEASUREMENT`, and `LC_KEYBOARD`, which are supported by the GNU C library (except for `LC_XLITERATE`).\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <time.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.UTF-8\"); // the C locale will be the UTF-8 enabled English\n    setlocale(LC_NUMERIC, \"de_DE.utf8\"); // decimal dot will be German\n    setlocale(LC_TIME, \"ja_JP.utf8\");    // date/time formatting will be Japanese\n    wchar_t str[100];\n    time_t t = time(NULL);\n    wcsftime(str, 100, L\"%A %c\", localtime(&t));\n    wprintf(L\"Number: %.2f\\nDate: %Ls\\n\", 3.14, str);\n}\n```\n\nPossible output:\n\n```\nNumber: 3,14\nDate: 金曜日 2023年09月15日 20時04分14秒\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.11/3 Localization \\<locale.h\\> (p: 224)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.11/3 Localization \\<locale.h\\> (p: 205)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.4 LOCALIZATION \\<locale.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/locale/LC_categories](https://en.cppreference.com/w/c/locale/LC_categories)"
- name: LC_CTYPE
  summary: Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of setlocale
  description: "# LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME\n\n[TABLE]\n\nEach of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of [`setlocale`](setlocale \"c/locale/setlocale\").\n\n| Constant      | Explanation                                                   |\n|---------------|---------------------------------------------------------------|\n| `LC_ALL`      | selects the entire C locale                                   |\n| `LC_COLLATE`  | selects the collation category of the C locale                |\n| `LC_CTYPE`    | selects the character classification category of the C locale |\n| `LC_MONETARY` | selects the monetary formatting category of the C locale      |\n| `LC_NUMERIC`  | selects the numeric formatting category of the C locale       |\n| `LC_TIME`     | selects the time formatting category of the C locale          |\n\nAdditional macro constants, with names that begin with `LC_` followed by at least one uppercase letter, may be defined in `locale.h`. For example, the POSIX specification requires `LC_MESSAGES` (which controls, among other things, [`perror`](../io/perror \"c/io/perror\") and [`strerror`](../string/byte/strerror \"c/string/byte/strerror\")), ISO/IEC 30112:2014 ([2014 draft](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf)) additionally defines `LC_IDENTIFICATION`, `LC_XLITERATE`, `LC_NAME`, `LC_ADDRESS`, `LC_TELEPHONE`, `LC_PAPER`, `LC_MEASUREMENT`, and `LC_KEYBOARD`, which are supported by the GNU C library (except for `LC_XLITERATE`).\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <time.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.UTF-8\"); // the C locale will be the UTF-8 enabled English\n    setlocale(LC_NUMERIC, \"de_DE.utf8\"); // decimal dot will be German\n    setlocale(LC_TIME, \"ja_JP.utf8\");    // date/time formatting will be Japanese\n    wchar_t str[100];\n    time_t t = time(NULL);\n    wcsftime(str, 100, L\"%A %c\", localtime(&t));\n    wprintf(L\"Number: %.2f\\nDate: %Ls\\n\", 3.14, str);\n}\n```\n\nPossible output:\n\n```\nNumber: 3,14\nDate: 金曜日 2023年09月15日 20時04分14秒\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.11/3 Localization \\<locale.h\\> (p: 224)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.11/3 Localization \\<locale.h\\> (p: 205)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.4 LOCALIZATION \\<locale.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/locale/LC_categories](https://en.cppreference.com/w/c/locale/LC_categories)"
- name: LC_MONETARY
  summary: Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of setlocale
  description: "# LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME\n\n[TABLE]\n\nEach of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of [`setlocale`](setlocale \"c/locale/setlocale\").\n\n| Constant      | Explanation                                                   |\n|---------------|---------------------------------------------------------------|\n| `LC_ALL`      | selects the entire C locale                                   |\n| `LC_COLLATE`  | selects the collation category of the C locale                |\n| `LC_CTYPE`    | selects the character classification category of the C locale |\n| `LC_MONETARY` | selects the monetary formatting category of the C locale      |\n| `LC_NUMERIC`  | selects the numeric formatting category of the C locale       |\n| `LC_TIME`     | selects the time formatting category of the C locale          |\n\nAdditional macro constants, with names that begin with `LC_` followed by at least one uppercase letter, may be defined in `locale.h`. For example, the POSIX specification requires `LC_MESSAGES` (which controls, among other things, [`perror`](../io/perror \"c/io/perror\") and [`strerror`](../string/byte/strerror \"c/string/byte/strerror\")), ISO/IEC 30112:2014 ([2014 draft](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf)) additionally defines `LC_IDENTIFICATION`, `LC_XLITERATE`, `LC_NAME`, `LC_ADDRESS`, `LC_TELEPHONE`, `LC_PAPER`, `LC_MEASUREMENT`, and `LC_KEYBOARD`, which are supported by the GNU C library (except for `LC_XLITERATE`).\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <time.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.UTF-8\"); // the C locale will be the UTF-8 enabled English\n    setlocale(LC_NUMERIC, \"de_DE.utf8\"); // decimal dot will be German\n    setlocale(LC_TIME, \"ja_JP.utf8\");    // date/time formatting will be Japanese\n    wchar_t str[100];\n    time_t t = time(NULL);\n    wcsftime(str, 100, L\"%A %c\", localtime(&t));\n    wprintf(L\"Number: %.2f\\nDate: %Ls\\n\", 3.14, str);\n}\n```\n\nPossible output:\n\n```\nNumber: 3,14\nDate: 金曜日 2023年09月15日 20時04分14秒\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.11/3 Localization \\<locale.h\\> (p: 224)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.11/3 Localization \\<locale.h\\> (p: 205)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.4 LOCALIZATION \\<locale.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/locale/LC_categories](https://en.cppreference.com/w/c/locale/LC_categories)"
- name: LC_NUMERIC
  summary: Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of setlocale
  description: "# LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME\n\n[TABLE]\n\nEach of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of [`setlocale`](setlocale \"c/locale/setlocale\").\n\n| Constant      | Explanation                                                   |\n|---------------|---------------------------------------------------------------|\n| `LC_ALL`      | selects the entire C locale                                   |\n| `LC_COLLATE`  | selects the collation category of the C locale                |\n| `LC_CTYPE`    | selects the character classification category of the C locale |\n| `LC_MONETARY` | selects the monetary formatting category of the C locale      |\n| `LC_NUMERIC`  | selects the numeric formatting category of the C locale       |\n| `LC_TIME`     | selects the time formatting category of the C locale          |\n\nAdditional macro constants, with names that begin with `LC_` followed by at least one uppercase letter, may be defined in `locale.h`. For example, the POSIX specification requires `LC_MESSAGES` (which controls, among other things, [`perror`](../io/perror \"c/io/perror\") and [`strerror`](../string/byte/strerror \"c/string/byte/strerror\")), ISO/IEC 30112:2014 ([2014 draft](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf)) additionally defines `LC_IDENTIFICATION`, `LC_XLITERATE`, `LC_NAME`, `LC_ADDRESS`, `LC_TELEPHONE`, `LC_PAPER`, `LC_MEASUREMENT`, and `LC_KEYBOARD`, which are supported by the GNU C library (except for `LC_XLITERATE`).\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <time.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.UTF-8\"); // the C locale will be the UTF-8 enabled English\n    setlocale(LC_NUMERIC, \"de_DE.utf8\"); // decimal dot will be German\n    setlocale(LC_TIME, \"ja_JP.utf8\");    // date/time formatting will be Japanese\n    wchar_t str[100];\n    time_t t = time(NULL);\n    wcsftime(str, 100, L\"%A %c\", localtime(&t));\n    wprintf(L\"Number: %.2f\\nDate: %Ls\\n\", 3.14, str);\n}\n```\n\nPossible output:\n\n```\nNumber: 3,14\nDate: 金曜日 2023年09月15日 20時04分14秒\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.11/3 Localization \\<locale.h\\> (p: 224)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.11/3 Localization \\<locale.h\\> (p: 205)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.4 LOCALIZATION \\<locale.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/locale/LC_categories](https://en.cppreference.com/w/c/locale/LC_categories)"
- name: LC_TIME
  summary: Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of setlocale
  description: "# LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME\n\n[TABLE]\n\nEach of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of [`setlocale`](setlocale \"c/locale/setlocale\").\n\n| Constant      | Explanation                                                   |\n|---------------|---------------------------------------------------------------|\n| `LC_ALL`      | selects the entire C locale                                   |\n| `LC_COLLATE`  | selects the collation category of the C locale                |\n| `LC_CTYPE`    | selects the character classification category of the C locale |\n| `LC_MONETARY` | selects the monetary formatting category of the C locale      |\n| `LC_NUMERIC`  | selects the numeric formatting category of the C locale       |\n| `LC_TIME`     | selects the time formatting category of the C locale          |\n\nAdditional macro constants, with names that begin with `LC_` followed by at least one uppercase letter, may be defined in `locale.h`. For example, the POSIX specification requires `LC_MESSAGES` (which controls, among other things, [`perror`](../io/perror \"c/io/perror\") and [`strerror`](../string/byte/strerror \"c/string/byte/strerror\")), ISO/IEC 30112:2014 ([2014 draft](https://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf)) additionally defines `LC_IDENTIFICATION`, `LC_XLITERATE`, `LC_NAME`, `LC_ADDRESS`, `LC_TELEPHONE`, `LC_PAPER`, `LC_MEASUREMENT`, and `LC_KEYBOARD`, which are supported by the GNU C library (except for `LC_XLITERATE`).\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <time.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.UTF-8\"); // the C locale will be the UTF-8 enabled English\n    setlocale(LC_NUMERIC, \"de_DE.utf8\"); // decimal dot will be German\n    setlocale(LC_TIME, \"ja_JP.utf8\");    // date/time formatting will be Japanese\n    wchar_t str[100];\n    time_t t = time(NULL);\n    wcsftime(str, 100, L\"%A %c\", localtime(&t));\n    wprintf(L\"Number: %.2f\\nDate: %Ls\\n\", 3.14, str);\n}\n```\n\nPossible output:\n\n```\nNumber: 3,14\nDate: 金曜日 2023年09月15日 20時04分14秒\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.11/3 Localization \\<locale.h\\> (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.11/3 Localization \\<locale.h\\> (p: 224)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.11/3 Localization \\<locale.h\\> (p: 205)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.4 LOCALIZATION \\<locale.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/locale/LC_categories](https://en.cppreference.com/w/c/locale/LC_categories)"
- name: lconv
  summary: The struct lconv contains numeric and monetary formatting rules as defined by a C locale
  description: "# lconv\n\n[TABLE]\n\nThe struct `lconv` contains numeric and monetary formatting rules as defined by a C locale. Objects of this struct may be obtained with [`localeconv`](localeconv \"c/locale/localeconv\"). The members of `lconv` are values of type `char` and of type `char*`. Each `char*` member except `decimal_point` may be pointing at a null character (that is, at an empty C-string). The members of type `char` are all non-negative numbers, any of which may be [`CHAR_MAX`](../types/limits \"c/types/limits\") if the corresponding value is not available in the current C locale.\n\n### Member objects\n\n#### Non-monetary numeric formatting parameters\n\n[TABLE]\n\n#### Monetary numeric formatting parameters\n\n[TABLE]\n\n#### Local monetary numeric formatting parameters\n\n[TABLE]\n\n#### International monetary numeric formatting parameters\n\n[TABLE]\n\n  \nThe characters of the C-strings pointed to by `grouping` and `mon_grouping` are interpreted according to their numeric values. When the terminating `'\\0'` is encountered, the last value seen is assumed to repeat for the remainder of digits. If [`CHAR_MAX`](../types/limits \"c/types/limits\") is encountered, no further digits are grouped. The typical grouping of three digits at a time is `\"\\003\"`.\n\nThe values of `p_sep_by_space`, `n_sep_by_space`, `int_p_sep_by_space`, `int_n_sep_by_space` are interpreted as follows:\n\n|     |                                                                   |\n|-----|-------------------------------------------------------------------|\n| 0   | no space separates the currency symbol and the value              |\n| 1   | sign sticks to the currency symbol, value is separated by a space |\n| 2   | sign sticks to the value. Currency symbol is separated by a space |\n\nThe values of `p_sign_posn`, `n_sign_posn`, `int_p_sign_posn`, `int_n_sign_posn` are interpreted as follows:\n\n|     |                                                                                     |\n|-----|-------------------------------------------------------------------------------------|\n| 0   | parentheses around the value and the currency symbol are used to represent the sign |\n| 1   | sign before the value and the currency symbol                                       |\n| 2   | sign after the value and the currency symbol                                        |\n| 3   | sign before the currency symbol                                                     |\n| 4   | sign after the currency symbol                                                      |\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"ja_JP.UTF-8\");\n    struct lconv *lc = localeconv();\n    printf(\"Japanese currency symbol: %s(%s)\\n\", lc->currency_symbol, lc->int_curr_symbol);\n}\n```\n\nPossible output:\n\n```\nJapanese currency symbol: ￥(JPY )\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.11/2 Localization \\<locale.h\\> (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.11/2 Localization \\<locale.h\\> (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.11/2 Localization \\<locale.h\\> (p: 223)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.11/2 Localization \\<locale.h\\> (p: 204)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.4 LOCALIZATION \\<locale.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/locale/lconv](https://en.cppreference.com/w/c/locale/lconv)"
- name: ldexp
  summary: If no errors occur, arg multiplied by 2 to the power of exp (arg×2exp) is returned
  description: "# ldexp, ldexpf, ldexpl\n\n[TABLE]\n\n1-3) Multiplies a floating point value `arg` by the number 2 raised to the `exp` power.\n\n4) Type-generic macro: If `arg` has type `long double`, `ldexpl` is called. Otherwise, if `arg` has integer type or the type `double`, `ldexp` is called. Otherwise, `ldexpf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n| exp | \\-  | integer value        |\n\n### Return value\n\nIf no errors occur, `arg` multiplied by 2 to the power of `exp` (arg×2^(exp)) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- Unless a range error occurs, [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised (the result is exact)\n- Unless a range error occurs, the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is ±∞, it is returned, unmodified\n- If `exp` is 0, then `arg` is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\n### Notes\n\nOn binary systems (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `ldexp` is equivalent to [`scalbn`](scalbn \"c/numeric/math/scalbn\").\n\nThe function `ldexp` (\"load exponent\"), together with its dual, [`frexp`](frexp \"c/numeric/math/frexp\"), can be used to manipulate the representation of a floating-point number without direct bit manipulations.\n\nOn many implementations, `ldexp` is less efficient than multiplication or division by a power of two using arithmetic operators.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"ldexp(7, -4) = %f\\n\", ldexp(7, -4));\n    printf(\"ldexp(1, -1074) = %g (minimum positive subnormal double)\\n\",\n            ldexp(1, -1074));\n    printf(\"ldexp(nextafter(1,0), 1024) = %g (largest finite double)\\n\",\n            ldexp(nextafter(1,0), 1024));\n    // special values\n    printf(\"ldexp(-0, 10) = %f\\n\", ldexp(-0.0, 10));\n    printf(\"ldexp(-Inf, -1) = %f\\n\", ldexp(-INFINITY, -1));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"ldexp(1, 1024) = %f\\n\", ldexp(1, 1024));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nldexp(7, -4) = 0.437500\nldexp(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nldexp(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nldexp(-0, 10) = -0.000000\nldexp(-Inf, -1) = -inf\nldexp(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.6 The ldexp functions (p: 244)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.6 The ldexp functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.6 The ldexp functions (p: 225)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.6 The ldexp functions (p: 459)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.3 The ldexp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/ldexp](https://en.cppreference.com/w/c/numeric/math/ldexp)"
- name: ldexpf
  summary: If no errors occur, arg multiplied by 2 to the power of exp (arg×2exp) is returned
  description: "# ldexp, ldexpf, ldexpl\n\n[TABLE]\n\n1-3) Multiplies a floating point value `arg` by the number 2 raised to the `exp` power.\n\n4) Type-generic macro: If `arg` has type `long double`, `ldexpl` is called. Otherwise, if `arg` has integer type or the type `double`, `ldexp` is called. Otherwise, `ldexpf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n| exp | \\-  | integer value        |\n\n### Return value\n\nIf no errors occur, `arg` multiplied by 2 to the power of `exp` (arg×2^(exp)) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- Unless a range error occurs, [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised (the result is exact)\n- Unless a range error occurs, the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is ±∞, it is returned, unmodified\n- If `exp` is 0, then `arg` is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\n### Notes\n\nOn binary systems (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `ldexp` is equivalent to [`scalbn`](scalbn \"c/numeric/math/scalbn\").\n\nThe function `ldexp` (\"load exponent\"), together with its dual, [`frexp`](frexp \"c/numeric/math/frexp\"), can be used to manipulate the representation of a floating-point number without direct bit manipulations.\n\nOn many implementations, `ldexp` is less efficient than multiplication or division by a power of two using arithmetic operators.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"ldexp(7, -4) = %f\\n\", ldexp(7, -4));\n    printf(\"ldexp(1, -1074) = %g (minimum positive subnormal double)\\n\",\n            ldexp(1, -1074));\n    printf(\"ldexp(nextafter(1,0), 1024) = %g (largest finite double)\\n\",\n            ldexp(nextafter(1,0), 1024));\n    // special values\n    printf(\"ldexp(-0, 10) = %f\\n\", ldexp(-0.0, 10));\n    printf(\"ldexp(-Inf, -1) = %f\\n\", ldexp(-INFINITY, -1));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"ldexp(1, 1024) = %f\\n\", ldexp(1, 1024));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nldexp(7, -4) = 0.437500\nldexp(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nldexp(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nldexp(-0, 10) = -0.000000\nldexp(-Inf, -1) = -inf\nldexp(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.6 The ldexp functions (p: 244)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.6 The ldexp functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.6 The ldexp functions (p: 225)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.6 The ldexp functions (p: 459)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.3 The ldexp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/ldexp](https://en.cppreference.com/w/c/numeric/math/ldexp)"
- name: ldexpl
  summary: If no errors occur, arg multiplied by 2 to the power of exp (arg×2exp) is returned
  description: "# ldexp, ldexpf, ldexpl\n\n[TABLE]\n\n1-3) Multiplies a floating point value `arg` by the number 2 raised to the `exp` power.\n\n4) Type-generic macro: If `arg` has type `long double`, `ldexpl` is called. Otherwise, if `arg` has integer type or the type `double`, `ldexp` is called. Otherwise, `ldexpf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n| exp | \\-  | integer value        |\n\n### Return value\n\nIf no errors occur, `arg` multiplied by 2 to the power of `exp` (arg×2^(exp)) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- Unless a range error occurs, [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised (the result is exact)\n- Unless a range error occurs, the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is ±∞, it is returned, unmodified\n- If `exp` is 0, then `arg` is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\n### Notes\n\nOn binary systems (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `ldexp` is equivalent to [`scalbn`](scalbn \"c/numeric/math/scalbn\").\n\nThe function `ldexp` (\"load exponent\"), together with its dual, [`frexp`](frexp \"c/numeric/math/frexp\"), can be used to manipulate the representation of a floating-point number without direct bit manipulations.\n\nOn many implementations, `ldexp` is less efficient than multiplication or division by a power of two using arithmetic operators.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"ldexp(7, -4) = %f\\n\", ldexp(7, -4));\n    printf(\"ldexp(1, -1074) = %g (minimum positive subnormal double)\\n\",\n            ldexp(1, -1074));\n    printf(\"ldexp(nextafter(1,0), 1024) = %g (largest finite double)\\n\",\n            ldexp(nextafter(1,0), 1024));\n    // special values\n    printf(\"ldexp(-0, 10) = %f\\n\", ldexp(-0.0, 10));\n    printf(\"ldexp(-Inf, -1) = %f\\n\", ldexp(-INFINITY, -1));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"ldexp(1, 1024) = %f\\n\", ldexp(1, 1024));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nldexp(7, -4) = 0.437500\nldexp(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nldexp(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nldexp(-0, 10) = -0.000000\nldexp(-Inf, -1) = -inf\nldexp(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.6 The ldexp functions (p: 244)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.6 The ldexp functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.6 The ldexp functions (p: 225)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.6 The ldexp functions (p: 459)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.3 The ldexp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/ldexp](https://en.cppreference.com/w/c/numeric/math/ldexp)"
- name: ldiv
  summary: Computes both the quotient and the remainder of the division of the numerator x by the denominator y
  description: "# div, ldiv, lldiv, imaxdiv\n\n[TABLE]\n\nComputes both the quotient and the remainder of the division of the numerator `x` by the denominator `y`.\n\n|                                                                                                                                                                                                       |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Computes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that `quot * y + rem == x`. | (until C99) |\n| Computes the quotient (the result of the expression `x / y`) and remainder (the result of the expression `x % y`) simultaneously.                                                                     | (since C99) |\n\n### Parameters\n\n|      |     |                |\n|------|-----|----------------|\n| x, y | \\-  | integer values |\n\n### Return value\n\nIf both the remainder and the quotient can be represented as objects of the corresponding type (`int`, `long`, `long long`, [`intmax_t`](http://en.cppreference.com/w/c/types/integer), respectively), returns both as an object of type `div_t`, `ldiv_t`, `lldiv_t`, `imaxdiv_t` defined as follows:\n\n## div_t\n\n```\nstruct div_t { int quot; int rem; };\n```\n\nor\n\n```\nstruct div_t { int rem; int quot; };\n```\n\n## ldiv_t\n\n```\nstruct ldiv_t { long quot; long rem; };\n```\n\nor\n\n```\nstruct ldiv_t { long rem; long quot; };\n```\n\n## lldiv_t\n\n```\nstruct lldiv_t { long long quot; long long rem; };\n```\n\nor\n\n```\nstruct lldiv_t { long long rem; long long quot; };\n```\n\n## imaxdiv_t\n\n```\nstruct imaxdiv_t { intmax_t quot; intmax_t rem; };\n```\n\nor\n\n```\nstruct imaxdiv_t { intmax_t rem; intmax_t quot; };\n```\n\nIf either the remainder or the quotient cannot be represented, the behavior is undefined.\n\n### Notes\n\nUntil C99, the rounding direction of the quotient and the sign of the remainder in the built-in division and remainder operators was implementation-defined if either of the operands was negative, but it was well-defined in `div` and `ldiv`.\n\nOn many platforms, a single CPU instruction obtains both the quotient and the remainder, and this function may leverage that, although compilers are generally able to merge nearby `/` and `%` where suitable.\n\n### Example\n\n```\n#include <assert.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nvoid reverse(char* first, char* last)\n{\n    for (--last; first < last; ++first, --last)\n    {\n        char c = *last;\n        *last = *first;\n        *first = c;\n    }\n}\n \n// returns empty buffer in case of buffer overflow\nchar* itoa(int n, int base, char* buf, size_t buf_size)\n{\n    assert(2 <= base && base <= 16 && buf && buf_size);\n    div_t dv = {.quot = n};\n    char* p = buf;\n    do\n    {\n        if (!--buf_size)\n            return (*buf = '\\0'), buf;\n        dv = div(dv.quot, base);\n        *p++ = \"0123456789abcdef\"[abs(dv.rem)];\n    }\n    while(dv.quot);\n    if (n < 0)\n        *p++ = '-';\n    *p = '\\0';\n    reverse(buf, p);\n    return buf;\n}\n \nint main(void)\n{\n    char buf[16];\n    printf(\"%s\\n\", itoa(0, 2, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(007, 3, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(12346, 10, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(-12346, 10, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(-42, 2, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(INT_MAX, 16, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(INT_MIN, 16, buf, sizeof buf));\n}\n```\n\nPossible output:\n\n```\n0\n21\n12346\n-12346\n-101010\n7fffffff\n-80000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.8.2.2 The imaxdiv function (p: TBD)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.2.2 The imaxdiv function (p: 159)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: 259)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.2 The imaxdiv function (p: 219)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: 356)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.2 The imaxdiv function (p: 200)\n  - 7.20.6.2 The div, ldiv and lldiv functions (p: 320)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10 div_t, ldiv_t\n  - 4.10.6.2 The div function\n  - 4.10.6.4 The ldiv function\n\n### See also\n\n[TABLE]\n\n### External links\n\n|     |                                                                                                                      |\n|-----|----------------------------------------------------------------------------------------------------------------------|\n| 1\\. | [Euclidean division](https://en.wikipedia.org/wiki/Euclidean_division \"enwiki:Euclidean division\") — From Wikipedia. |\n| 2\\. | [Modulo (and Truncated division)](https://en.wikipedia.org/wiki/Modulo \"enwiki:Modulo\") — From Wikipedia.            |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/div](https://en.cppreference.com/w/c/numeric/math/div)"
- name: lgamma
  summary: If no errors occur, the value of the logarithm of the gamma function of arg, that is \(\log_{e}|{\int_0^\infty t^{arg-1} e^{-t} \mathsf{d}t}|\)loge|∫∞0targ-1 e-t dt|, is returned
  description: "# lgamma, lgammaf, lgammal\n\n[TABLE]\n\n1-3) Computes the natural logarithm of the absolute value of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function \"enwiki:Gamma function\") of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `lgammal` is called. Otherwise, if `arg` has integer type or the type `double`, `lgamma` is called. Otherwise, `lgammaf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the value of the logarithm of the gamma function of `arg`, that is \\\\\\log\\_{e}\\|{\\int_0^\\infty t^{arg-1} e^{-t} \\mathsf{d}t}\\|\\\\log_(e)\\|∫_(∞0)*t*^(arg-1) *e*^(-t) d*t*\\|, is returned.\n\nIf a pole error occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf `arg` is zero or is an integer less than zero, a pole error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is 1, +0 is returned.\n- If the argument is 2, +0 is returned.\n- If the argument is ±0, +∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is a negative integer, +∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is ±∞, +∞ is returned.\n- If the argument is NaN, NaN is returned.\n\n### Notes\n\nIf `arg` is a natural number, `lgamma(arg)` is the logarithm of the factorial of `arg - 1`.\n\nThe [POSIX version of `lgamma`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/lgamma.html) is not thread-safe: each execution of the function stores the sign of the gamma function of `arg` in the static external variable `signgam`. Some implementations provide `lgamma_r`, which takes a pointer to user-provided storage for singgam as the second parameter, and is thread-safe.\n\nThere is a non-standard function named `gamma` in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of `gamma` executes `lgamma`, but 4.4BSD version of `gamma` executes `tgamma`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"lgamma(10) = %f, log(9!) = %f\\n\", lgamma(10), log(2*3*4*5*6*7*8*9));\n    const double pi = acos(-1);\n    printf(\"lgamma(0.5) = %f, log(sqrt(pi)) = %f\\n\", log(sqrt(pi)), lgamma(0.5));\n    // special values\n    printf(\"lgamma(1) = %f\\n\", lgamma(1));\n    printf(\"lgamma(+Inf) = %f\\n\", lgamma(INFINITY));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lgamma(0) = %f\\n\", lgamma(0));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_DIVBYZERO))\n        puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlgamma(10) = 12.801827, log(9!) = 12.801827\nlgamma(0.5) = 0.572365, log(sqrt(pi)) = 0.572365\nlgamma(1) = 0.000000\nlgamma(+Inf) = inf\nlgamma(0) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.8.3 The lgamma functions (p: 182)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.5.3 The lgamma functions (p: 383)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.3 The lgamma functions (p: 250)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.3 The lgamma functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.3 The lgamma functions (p: 231)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.3 The lgamma functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                          |\n|------------------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Log Gamma Function.\"](https://mathworld.wolfram.com/LogGammaFunction.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/lgamma](https://en.cppreference.com/w/c/numeric/math/lgamma)"
- name: lgammaf
  summary: If no errors occur, the value of the logarithm of the gamma function of arg, that is \(\log_{e}|{\int_0^\infty t^{arg-1} e^{-t} \mathsf{d}t}|\)loge|∫∞0targ-1 e-t dt|, is returned
  description: "# lgamma, lgammaf, lgammal\n\n[TABLE]\n\n1-3) Computes the natural logarithm of the absolute value of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function \"enwiki:Gamma function\") of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `lgammal` is called. Otherwise, if `arg` has integer type or the type `double`, `lgamma` is called. Otherwise, `lgammaf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the value of the logarithm of the gamma function of `arg`, that is \\\\\\log\\_{e}\\|{\\int_0^\\infty t^{arg-1} e^{-t} \\mathsf{d}t}\\|\\\\log_(e)\\|∫_(∞0)*t*^(arg-1) *e*^(-t) d*t*\\|, is returned.\n\nIf a pole error occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf `arg` is zero or is an integer less than zero, a pole error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is 1, +0 is returned.\n- If the argument is 2, +0 is returned.\n- If the argument is ±0, +∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is a negative integer, +∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is ±∞, +∞ is returned.\n- If the argument is NaN, NaN is returned.\n\n### Notes\n\nIf `arg` is a natural number, `lgamma(arg)` is the logarithm of the factorial of `arg - 1`.\n\nThe [POSIX version of `lgamma`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/lgamma.html) is not thread-safe: each execution of the function stores the sign of the gamma function of `arg` in the static external variable `signgam`. Some implementations provide `lgamma_r`, which takes a pointer to user-provided storage for singgam as the second parameter, and is thread-safe.\n\nThere is a non-standard function named `gamma` in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of `gamma` executes `lgamma`, but 4.4BSD version of `gamma` executes `tgamma`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"lgamma(10) = %f, log(9!) = %f\\n\", lgamma(10), log(2*3*4*5*6*7*8*9));\n    const double pi = acos(-1);\n    printf(\"lgamma(0.5) = %f, log(sqrt(pi)) = %f\\n\", log(sqrt(pi)), lgamma(0.5));\n    // special values\n    printf(\"lgamma(1) = %f\\n\", lgamma(1));\n    printf(\"lgamma(+Inf) = %f\\n\", lgamma(INFINITY));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lgamma(0) = %f\\n\", lgamma(0));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_DIVBYZERO))\n        puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlgamma(10) = 12.801827, log(9!) = 12.801827\nlgamma(0.5) = 0.572365, log(sqrt(pi)) = 0.572365\nlgamma(1) = 0.000000\nlgamma(+Inf) = inf\nlgamma(0) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.8.3 The lgamma functions (p: 182)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.5.3 The lgamma functions (p: 383)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.3 The lgamma functions (p: 250)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.3 The lgamma functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.3 The lgamma functions (p: 231)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.3 The lgamma functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                          |\n|------------------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Log Gamma Function.\"](https://mathworld.wolfram.com/LogGammaFunction.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/lgamma](https://en.cppreference.com/w/c/numeric/math/lgamma)"
- name: lgammal
  summary: If no errors occur, the value of the logarithm of the gamma function of arg, that is \(\log_{e}|{\int_0^\infty t^{arg-1} e^{-t} \mathsf{d}t}|\)loge|∫∞0targ-1 e-t dt|, is returned
  description: "# lgamma, lgammaf, lgammal\n\n[TABLE]\n\n1-3) Computes the natural logarithm of the absolute value of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function \"enwiki:Gamma function\") of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `lgammal` is called. Otherwise, if `arg` has integer type or the type `double`, `lgamma` is called. Otherwise, `lgammaf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the value of the logarithm of the gamma function of `arg`, that is \\\\\\log\\_{e}\\|{\\int_0^\\infty t^{arg-1} e^{-t} \\mathsf{d}t}\\|\\\\log_(e)\\|∫_(∞0)*t*^(arg-1) *e*^(-t) d*t*\\|, is returned.\n\nIf a pole error occurs, [`+HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `+HUGE_VALF`, or `+HUGE_VALL` is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf `arg` is zero or is an integer less than zero, a pole error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is 1, +0 is returned.\n- If the argument is 2, +0 is returned.\n- If the argument is ±0, +∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is a negative integer, +∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is ±∞, +∞ is returned.\n- If the argument is NaN, NaN is returned.\n\n### Notes\n\nIf `arg` is a natural number, `lgamma(arg)` is the logarithm of the factorial of `arg - 1`.\n\nThe [POSIX version of `lgamma`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/lgamma.html) is not thread-safe: each execution of the function stores the sign of the gamma function of `arg` in the static external variable `signgam`. Some implementations provide `lgamma_r`, which takes a pointer to user-provided storage for singgam as the second parameter, and is thread-safe.\n\nThere is a non-standard function named `gamma` in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of `gamma` executes `lgamma`, but 4.4BSD version of `gamma` executes `tgamma`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"lgamma(10) = %f, log(9!) = %f\\n\", lgamma(10), log(2*3*4*5*6*7*8*9));\n    const double pi = acos(-1);\n    printf(\"lgamma(0.5) = %f, log(sqrt(pi)) = %f\\n\", log(sqrt(pi)), lgamma(0.5));\n    // special values\n    printf(\"lgamma(1) = %f\\n\", lgamma(1));\n    printf(\"lgamma(+Inf) = %f\\n\", lgamma(INFINITY));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lgamma(0) = %f\\n\", lgamma(0));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_DIVBYZERO))\n        puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlgamma(10) = 12.801827, log(9!) = 12.801827\nlgamma(0.5) = 0.572365, log(sqrt(pi)) = 0.572365\nlgamma(1) = 0.000000\nlgamma(+Inf) = inf\nlgamma(0) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.8.3 The lgamma functions (p: 182)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.5.3 The lgamma functions (p: 383)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.3 The lgamma functions (p: 250)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.3 The lgamma functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.3 The lgamma functions (p: 231)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.3 The lgamma functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                          |\n|------------------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Log Gamma Function.\"](https://mathworld.wolfram.com/LogGammaFunction.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/lgamma](https://en.cppreference.com/w/c/numeric/math/lgamma)"
- name: Lifetime
  summary: Every object in C exists, has a constant address, retains its last-stored value (except when the value is indeterminate), and, for VLA, retains its size(since C99) over a portion of program execution known as this object's lifetime
  description: "# Lifetime\n\nEvery [object](object \"c/language/object\") in C exists, has a constant address, retains its last-stored value (except when the value is indeterminate), and, for VLA, retains its size(since C99) over a portion of program execution known as this object's *lifetime*.\n\nFor the objects that are declared with automatic, static, and thread storage duration, lifetime equals their [storage duration](storage_duration \"c/language/storage duration\") (note the difference between non-VLA and VLA automatic storage duration).\n\nFor the objects with allocated storage duration, the lifetime begins when the allocation function returns (including the return from [`realloc`](../memory/realloc \"c/memory/realloc\")) and ends when the [`realloc`](../memory/realloc \"c/memory/realloc\") or deallocation function is called. Note that since allocated objects have no [declared type](object \"c/language/object\"), the type of the lvalue expression first used to access this object becomes its [effective type](object \"c/language/object\").\n\nAccessing an object outside of its lifetime is undefined behavior.\n\n```\nint* foo(void) {\n    int a = 17; // a has automatic storage duration\n    return &a;\n}  // lifetime of a ends\nint main(void) {\n    int* p = foo(); // p points to an object past lifetime (\"dangling pointer\")\n    int n = *p; // undefined behavior\n}\n```\n\nA pointer to an object (or one past the object) whose lifetime ended has indeterminate value.\n\n### Temporary lifetime\n\nStruct and union objects with array members (either direct or members of nested struct/union members) that are designated by [non-lvalue expressions](value_category \"c/language/value category\"), have *temporary lifetime*. Temporary lifetime begins when the expression that refers to such object is evaluated and ends at the next [sequence point](eval_order \"c/language/eval order\")(until C11)when the containing full expression or full declarator ends(since C11).\n\nAny attempt to modify an object with temporary lifetime results in undefined behavior.\n\n```\nstruct T { double a[4]; };\nstruct T f(void) { return (struct T){3.15}; }\ndouble g1(double* x) { return *x; }\nvoid g2(double* x) { *x = 1.0; }\nint main(void)\n{\n    double d = g1(f().a); // C99: UB access to a[0] in g1 whose lifetime ended\n                          //      at the sequence point at the start of g1\n                          // C11: OK, d is 3.15\n    g2(f().a); // C99: UB modification of a[0] whose lifetime ended at the sequence point\n               // C11: UB attempt to modify a temporary object\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.2.4 Storage durations of objects (p: 30)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.2.4 Storage durations of objects (p: 38-39)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.2.4 Storage durations of objects (p: 32)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.2.4 Storage durations of objects\n\n### See also\n\n|                                                                                                                      |     |\n|----------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/lifetime \"cpp/language/lifetime\") for Object lifetime |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/lifetime](https://en.cppreference.com/w/c/language/lifetime)"
- name: llabs
  summary: Computes the absolute value of an integer number
  description: "# abs, labs, llabs, imaxabs\n\n[TABLE]\n\nComputes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.\n\n### Parameters\n\n|     |     |               |\n|-----|-----|---------------|\n| n   | \\-  | integer value |\n\n### Return value\n\nThe absolute value of `n` (i.e. `|n|`), if it is representable.\n\n### Notes\n\nIn 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type `int`, [`INT_MIN`](../../types/limits \"c/types/limits\") is `-2147483648`, but the would-be result `2147483648` is greater than [`INT_MAX`](../../types/limits \"c/types/limits\"), which is `2147483647`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n \nint main(void)\n{\n    printf(\"abs(+3) = %d\\n\", abs(+3));\n    printf(\"abs(-3) = %d\\n\", abs(-3));\n \n//  printf(\"%+d\\n\", abs(INT_MIN)); // undefined behavior on 2's complement systems\n}\n```\n\nOutput:\n\n```\nabs(+3) = 3\nabs(-3) = 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.2.1 The imaxabs function (p: 159)\n  - 7.22.6.1 The abs, labs and llabs functions (p: 259)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.1 The imaxabs function (p: 218)\n  - 7.22.6.1 The abs, labs and llabs functions (p: 356)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.1 The imaxabs function (p: 199-200)\n  - 7.20.6.1 The abs, labs and llabs functions (p: 320)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.6.1 The abs function\n  - 4.10.6.3 The labs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/abs](https://en.cppreference.com/w/c/numeric/math/abs)"
- name: lldiv
  summary: Computes both the quotient and the remainder of the division of the numerator x by the denominator y
  description: "# div, ldiv, lldiv, imaxdiv\n\n[TABLE]\n\nComputes both the quotient and the remainder of the division of the numerator `x` by the denominator `y`.\n\n|                                                                                                                                                                                                       |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Computes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that `quot * y + rem == x`. | (until C99) |\n| Computes the quotient (the result of the expression `x / y`) and remainder (the result of the expression `x % y`) simultaneously.                                                                     | (since C99) |\n\n### Parameters\n\n|      |     |                |\n|------|-----|----------------|\n| x, y | \\-  | integer values |\n\n### Return value\n\nIf both the remainder and the quotient can be represented as objects of the corresponding type (`int`, `long`, `long long`, [`intmax_t`](http://en.cppreference.com/w/c/types/integer), respectively), returns both as an object of type `div_t`, `ldiv_t`, `lldiv_t`, `imaxdiv_t` defined as follows:\n\n## div_t\n\n```\nstruct div_t { int quot; int rem; };\n```\n\nor\n\n```\nstruct div_t { int rem; int quot; };\n```\n\n## ldiv_t\n\n```\nstruct ldiv_t { long quot; long rem; };\n```\n\nor\n\n```\nstruct ldiv_t { long rem; long quot; };\n```\n\n## lldiv_t\n\n```\nstruct lldiv_t { long long quot; long long rem; };\n```\n\nor\n\n```\nstruct lldiv_t { long long rem; long long quot; };\n```\n\n## imaxdiv_t\n\n```\nstruct imaxdiv_t { intmax_t quot; intmax_t rem; };\n```\n\nor\n\n```\nstruct imaxdiv_t { intmax_t rem; intmax_t quot; };\n```\n\nIf either the remainder or the quotient cannot be represented, the behavior is undefined.\n\n### Notes\n\nUntil C99, the rounding direction of the quotient and the sign of the remainder in the built-in division and remainder operators was implementation-defined if either of the operands was negative, but it was well-defined in `div` and `ldiv`.\n\nOn many platforms, a single CPU instruction obtains both the quotient and the remainder, and this function may leverage that, although compilers are generally able to merge nearby `/` and `%` where suitable.\n\n### Example\n\n```\n#include <assert.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nvoid reverse(char* first, char* last)\n{\n    for (--last; first < last; ++first, --last)\n    {\n        char c = *last;\n        *last = *first;\n        *first = c;\n    }\n}\n \n// returns empty buffer in case of buffer overflow\nchar* itoa(int n, int base, char* buf, size_t buf_size)\n{\n    assert(2 <= base && base <= 16 && buf && buf_size);\n    div_t dv = {.quot = n};\n    char* p = buf;\n    do\n    {\n        if (!--buf_size)\n            return (*buf = '\\0'), buf;\n        dv = div(dv.quot, base);\n        *p++ = \"0123456789abcdef\"[abs(dv.rem)];\n    }\n    while(dv.quot);\n    if (n < 0)\n        *p++ = '-';\n    *p = '\\0';\n    reverse(buf, p);\n    return buf;\n}\n \nint main(void)\n{\n    char buf[16];\n    printf(\"%s\\n\", itoa(0, 2, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(007, 3, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(12346, 10, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(-12346, 10, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(-42, 2, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(INT_MAX, 16, buf, sizeof buf));\n    printf(\"%s\\n\", itoa(INT_MIN, 16, buf, sizeof buf));\n}\n```\n\nPossible output:\n\n```\n0\n21\n12346\n-12346\n-101010\n7fffffff\n-80000000\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.8.2.2 The imaxdiv function (p: TBD)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.2.2 The imaxdiv function (p: 159)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: 259)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.2 The imaxdiv function (p: 219)\n  - 7.22.6.2 The div, ldiv and lldiv functions (p: 356)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.2 The imaxdiv function (p: 200)\n  - 7.20.6.2 The div, ldiv and lldiv functions (p: 320)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10 div_t, ldiv_t\n  - 4.10.6.2 The div function\n  - 4.10.6.4 The ldiv function\n\n### See also\n\n[TABLE]\n\n### External links\n\n|     |                                                                                                                      |\n|-----|----------------------------------------------------------------------------------------------------------------------|\n| 1\\. | [Euclidean division](https://en.wikipedia.org/wiki/Euclidean_division \"enwiki:Euclidean division\") — From Wikipedia. |\n| 2\\. | [Modulo (and Truncated division)](https://en.wikipedia.org/wiki/Modulo \"enwiki:Modulo\") — From Wikipedia.            |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/div](https://en.cppreference.com/w/c/numeric/math/div)"
- name: llrint
  summary: If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned
  description: "# rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the current rounding mode.\n\n5-7, 9-11) Rounds the floating-point argument `arg` to an integer value in integer format, using the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `rintl`, `lrintl`, `llrintl` is called. Otherwise, if `arg` has integer type or the type `double`, `rint`, `lrint`, `llrint` is called. Otherwise, `rintf`, `lrintf`, `llrintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lrint` or `llrint` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `rint` function:\n\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lrint` and `llrint` functions:\n\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lrint.html) that all cases where `lrint` or `llrint` raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nAs specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\"), [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be on non-IEEE floating-point platforms) raised by `rint` when rounding a non-integer finite value.\n\nThe only difference between `rint` and [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") is that [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `rint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is...\n\n- [`FE_DOWNWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`floor`](floor \"c/numeric/math/floor\").\n- [`FE_UPWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`ceil`](ceil \"c/numeric/math/ceil\").\n- [`FE_TOWARDZERO`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`trunc`](trunc \"c/numeric/math/trunc\")\n- [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` differs from [`round`](round \"c/numeric/math/round\") in that halfway cases are rounded to even rather than away from zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest (halfway cases to even):\\n\"\n           \"rint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nrint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n    printf(\"rounding down with lrint: \\nlrint(+2.3) = %ld  \", lrint(2.3));\n    printf(\"lrint(+2.5) = %ld  \", lrint(2.5));\n    printf(\"lrint(+3.5) = %ld\\n\", lrint(3.5));\n    printf(\"lrint(-2.3) = %ld  \", lrint(-2.3));\n    printf(\"lrint(-2.5) = %ld  \", lrint(-2.5));\n    printf(\"lrint(-3.5) = %ld\\n\", lrint(-3.5));\n \n    printf(\"lrint(-0.0) = %ld\\n\", lrint(-0.0));\n    printf(\"lrint(-Inf) = %ld\\n\", lrint(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"rint(1.1) = %.1f\\n\", rint(1.1));\n    if(fetestexcept(FE_INEXACT)) puts(\"    FE_INEXACT was raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lrint(LONG_MIN-2048.0) = %ld\\n\", lrint(LONG_MIN-2048.0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nrounding to nearest (halfway cases to even):\nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +4.0\nrint(-2.3) = -2.0  rint(-2.5) = -2.0  rint(-3.5) = -4.0\nrounding down: \nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +3.0\nrint(-2.3) = -3.0  rint(-2.5) = -3.0  rint(-3.5) = -4.0\nrounding down with lrint: \nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nrint(1.1) = 1.0\n    FE_INEXACT was raised\nlrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.4 The rint functions (p: 184)\n  - 7.12.9.5 The lrint and llrint functions (p: 184)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.4 The rint functions (p: 384)\n  - F.10.6.5 The lrint and llrint functions (p: 384)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.4 The rint functions (p: 252)\n  - 7.12.9.5 The lrint and llrint functions (p: 252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.4 The rint functions (p: 527)\n  - F.10.6.5 The lrint and llrint functions (p: 527)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.4 The rint functions (p: 232-233)\n  - 7.12.9.5 The lrint and llrint functions (p: 233)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.4 The rint functions (p: 463)\n  - F.9.6.5 The lrint and llrint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/rint](https://en.cppreference.com/w/c/numeric/math/rint)"
- name: llrintf
  summary: If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned
  description: "# rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the current rounding mode.\n\n5-7, 9-11) Rounds the floating-point argument `arg` to an integer value in integer format, using the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `rintl`, `lrintl`, `llrintl` is called. Otherwise, if `arg` has integer type or the type `double`, `rint`, `lrint`, `llrint` is called. Otherwise, `rintf`, `lrintf`, `llrintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lrint` or `llrint` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `rint` function:\n\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lrint` and `llrint` functions:\n\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lrint.html) that all cases where `lrint` or `llrint` raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nAs specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\"), [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be on non-IEEE floating-point platforms) raised by `rint` when rounding a non-integer finite value.\n\nThe only difference between `rint` and [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") is that [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `rint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is...\n\n- [`FE_DOWNWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`floor`](floor \"c/numeric/math/floor\").\n- [`FE_UPWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`ceil`](ceil \"c/numeric/math/ceil\").\n- [`FE_TOWARDZERO`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`trunc`](trunc \"c/numeric/math/trunc\")\n- [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` differs from [`round`](round \"c/numeric/math/round\") in that halfway cases are rounded to even rather than away from zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest (halfway cases to even):\\n\"\n           \"rint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nrint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n    printf(\"rounding down with lrint: \\nlrint(+2.3) = %ld  \", lrint(2.3));\n    printf(\"lrint(+2.5) = %ld  \", lrint(2.5));\n    printf(\"lrint(+3.5) = %ld\\n\", lrint(3.5));\n    printf(\"lrint(-2.3) = %ld  \", lrint(-2.3));\n    printf(\"lrint(-2.5) = %ld  \", lrint(-2.5));\n    printf(\"lrint(-3.5) = %ld\\n\", lrint(-3.5));\n \n    printf(\"lrint(-0.0) = %ld\\n\", lrint(-0.0));\n    printf(\"lrint(-Inf) = %ld\\n\", lrint(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"rint(1.1) = %.1f\\n\", rint(1.1));\n    if(fetestexcept(FE_INEXACT)) puts(\"    FE_INEXACT was raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lrint(LONG_MIN-2048.0) = %ld\\n\", lrint(LONG_MIN-2048.0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nrounding to nearest (halfway cases to even):\nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +4.0\nrint(-2.3) = -2.0  rint(-2.5) = -2.0  rint(-3.5) = -4.0\nrounding down: \nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +3.0\nrint(-2.3) = -3.0  rint(-2.5) = -3.0  rint(-3.5) = -4.0\nrounding down with lrint: \nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nrint(1.1) = 1.0\n    FE_INEXACT was raised\nlrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.4 The rint functions (p: 184)\n  - 7.12.9.5 The lrint and llrint functions (p: 184)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.4 The rint functions (p: 384)\n  - F.10.6.5 The lrint and llrint functions (p: 384)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.4 The rint functions (p: 252)\n  - 7.12.9.5 The lrint and llrint functions (p: 252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.4 The rint functions (p: 527)\n  - F.10.6.5 The lrint and llrint functions (p: 527)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.4 The rint functions (p: 232-233)\n  - 7.12.9.5 The lrint and llrint functions (p: 233)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.4 The rint functions (p: 463)\n  - F.9.6.5 The lrint and llrint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/rint](https://en.cppreference.com/w/c/numeric/math/rint)"
- name: llrintl
  summary: If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned
  description: "# rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the current rounding mode.\n\n5-7, 9-11) Rounds the floating-point argument `arg` to an integer value in integer format, using the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `rintl`, `lrintl`, `llrintl` is called. Otherwise, if `arg` has integer type or the type `double`, `rint`, `lrint`, `llrint` is called. Otherwise, `rintf`, `lrintf`, `llrintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lrint` or `llrint` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `rint` function:\n\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lrint` and `llrint` functions:\n\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lrint.html) that all cases where `lrint` or `llrint` raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nAs specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\"), [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be on non-IEEE floating-point platforms) raised by `rint` when rounding a non-integer finite value.\n\nThe only difference between `rint` and [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") is that [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `rint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is...\n\n- [`FE_DOWNWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`floor`](floor \"c/numeric/math/floor\").\n- [`FE_UPWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`ceil`](ceil \"c/numeric/math/ceil\").\n- [`FE_TOWARDZERO`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`trunc`](trunc \"c/numeric/math/trunc\")\n- [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` differs from [`round`](round \"c/numeric/math/round\") in that halfway cases are rounded to even rather than away from zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest (halfway cases to even):\\n\"\n           \"rint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nrint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n    printf(\"rounding down with lrint: \\nlrint(+2.3) = %ld  \", lrint(2.3));\n    printf(\"lrint(+2.5) = %ld  \", lrint(2.5));\n    printf(\"lrint(+3.5) = %ld\\n\", lrint(3.5));\n    printf(\"lrint(-2.3) = %ld  \", lrint(-2.3));\n    printf(\"lrint(-2.5) = %ld  \", lrint(-2.5));\n    printf(\"lrint(-3.5) = %ld\\n\", lrint(-3.5));\n \n    printf(\"lrint(-0.0) = %ld\\n\", lrint(-0.0));\n    printf(\"lrint(-Inf) = %ld\\n\", lrint(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"rint(1.1) = %.1f\\n\", rint(1.1));\n    if(fetestexcept(FE_INEXACT)) puts(\"    FE_INEXACT was raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lrint(LONG_MIN-2048.0) = %ld\\n\", lrint(LONG_MIN-2048.0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nrounding to nearest (halfway cases to even):\nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +4.0\nrint(-2.3) = -2.0  rint(-2.5) = -2.0  rint(-3.5) = -4.0\nrounding down: \nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +3.0\nrint(-2.3) = -3.0  rint(-2.5) = -3.0  rint(-3.5) = -4.0\nrounding down with lrint: \nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nrint(1.1) = 1.0\n    FE_INEXACT was raised\nlrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.4 The rint functions (p: 184)\n  - 7.12.9.5 The lrint and llrint functions (p: 184)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.4 The rint functions (p: 384)\n  - F.10.6.5 The lrint and llrint functions (p: 384)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.4 The rint functions (p: 252)\n  - 7.12.9.5 The lrint and llrint functions (p: 252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.4 The rint functions (p: 527)\n  - F.10.6.5 The lrint and llrint functions (p: 527)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.4 The rint functions (p: 232-233)\n  - 7.12.9.5 The lrint and llrint functions (p: 233)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.4 The rint functions (p: 463)\n  - F.9.6.5 The lrint and llrint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/rint](https://en.cppreference.com/w/c/numeric/math/rint)"
- name: llround
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned
  description: "# round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n5-7, 9-11) Computes the nearest integer value to `arg` (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `roundl`, `lroundl`, `llroundl` is called. Otherwise, if `arg` has integer type or the type `double`, `round`, `lround`, `llround` is called. Otherwise, `roundf`, `lroundf`, `llroundf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases away from zero, is returned.\n\nReturn value\n\nArgument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lround` or `llround` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `round`, `roundf`, and `roundl` function:\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lround` and `llround` families of functions:\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised by `round` when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `round` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lround.html) that all cases where `lround` or `llround` raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nThe `double` version of `round` behaves as if implemented as follows:\n\n```\n#include <math.h>\ndouble round(double x)\n{\n    return signbit(x) ? ceil(x - 0.5) : floor(x + 0.5);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // round\n    printf(\"round(+2.3) = %+.1f  \", round(2.3));\n    printf(\"round(+2.5) = %+.1f  \", round(2.5));\n    printf(\"round(+2.7) = %+.1f\\n\", round(2.7));\n    printf(\"round(-2.3) = %+.1f  \", round(-2.3));\n    printf(\"round(-2.5) = %+.1f  \", round(-2.5));\n    printf(\"round(-2.7) = %+.1f\\n\", round(-2.7));\n \n    printf(\"round(-0.0) = %+.1f\\n\", round(-0.0));\n    printf(\"round(-Inf) = %+f\\n\",   round(-INFINITY));\n \n    // lround\n    printf(\"lround(+2.3) = %ld  \", lround(2.3));\n    printf(\"lround(+2.5) = %ld  \", lround(2.5));\n    printf(\"lround(+2.7) = %ld\\n\", lround(2.7));\n    printf(\"lround(-2.3) = %ld  \", lround(-2.3));\n    printf(\"lround(-2.5) = %ld  \", lround(-2.5));\n    printf(\"lround(-2.7) = %ld\\n\", lround(-2.7));\n \n    printf(\"lround(-0.0) = %ld\\n\", lround(-0.0));\n    printf(\"lround(-Inf) = %ld\\n\", lround(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lround(LONG_MAX+1.5) = %ld\\n\", lround(LONG_MAX+1.5));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nround(+2.3) = +2.0  round(+2.5) = +3.0  round(+2.7) = +3.0\nround(-2.3) = -2.0  round(-2.5) = -3.0  round(-2.7) = -3.0\nround(-0.0) = -0.0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nlround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.6 The round functions (p: 184)\n  - 7.12.9.7 The lround and llround functions (p: 184-185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.6 The round functions (p: 384)\n  - F.10.6.7 The lround and llround functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.6 The round functions (p: 253)\n  - 7.12.9.7 The lround and llround functions (p: 253)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.6 The round functions (p: 527)\n  - F.10.6.7 The lround and llround functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.6 The round functions (p: 233)\n  - 7.12.9.7 The lround and llround functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.6 The round functions (p: 464)\n  - F.9.6.7 The lround and llround functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/round](https://en.cppreference.com/w/c/numeric/math/round)"
- name: llroundf
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned
  description: "# round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n5-7, 9-11) Computes the nearest integer value to `arg` (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `roundl`, `lroundl`, `llroundl` is called. Otherwise, if `arg` has integer type or the type `double`, `round`, `lround`, `llround` is called. Otherwise, `roundf`, `lroundf`, `llroundf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases away from zero, is returned.\n\nReturn value\n\nArgument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lround` or `llround` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `round`, `roundf`, and `roundl` function:\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lround` and `llround` families of functions:\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised by `round` when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `round` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lround.html) that all cases where `lround` or `llround` raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nThe `double` version of `round` behaves as if implemented as follows:\n\n```\n#include <math.h>\ndouble round(double x)\n{\n    return signbit(x) ? ceil(x - 0.5) : floor(x + 0.5);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // round\n    printf(\"round(+2.3) = %+.1f  \", round(2.3));\n    printf(\"round(+2.5) = %+.1f  \", round(2.5));\n    printf(\"round(+2.7) = %+.1f\\n\", round(2.7));\n    printf(\"round(-2.3) = %+.1f  \", round(-2.3));\n    printf(\"round(-2.5) = %+.1f  \", round(-2.5));\n    printf(\"round(-2.7) = %+.1f\\n\", round(-2.7));\n \n    printf(\"round(-0.0) = %+.1f\\n\", round(-0.0));\n    printf(\"round(-Inf) = %+f\\n\",   round(-INFINITY));\n \n    // lround\n    printf(\"lround(+2.3) = %ld  \", lround(2.3));\n    printf(\"lround(+2.5) = %ld  \", lround(2.5));\n    printf(\"lround(+2.7) = %ld\\n\", lround(2.7));\n    printf(\"lround(-2.3) = %ld  \", lround(-2.3));\n    printf(\"lround(-2.5) = %ld  \", lround(-2.5));\n    printf(\"lround(-2.7) = %ld\\n\", lround(-2.7));\n \n    printf(\"lround(-0.0) = %ld\\n\", lround(-0.0));\n    printf(\"lround(-Inf) = %ld\\n\", lround(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lround(LONG_MAX+1.5) = %ld\\n\", lround(LONG_MAX+1.5));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nround(+2.3) = +2.0  round(+2.5) = +3.0  round(+2.7) = +3.0\nround(-2.3) = -2.0  round(-2.5) = -3.0  round(-2.7) = -3.0\nround(-0.0) = -0.0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nlround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.6 The round functions (p: 184)\n  - 7.12.9.7 The lround and llround functions (p: 184-185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.6 The round functions (p: 384)\n  - F.10.6.7 The lround and llround functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.6 The round functions (p: 253)\n  - 7.12.9.7 The lround and llround functions (p: 253)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.6 The round functions (p: 527)\n  - F.10.6.7 The lround and llround functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.6 The round functions (p: 233)\n  - 7.12.9.7 The lround and llround functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.6 The round functions (p: 464)\n  - F.9.6.7 The lround and llround functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/round](https://en.cppreference.com/w/c/numeric/math/round)"
- name: llroundl
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned
  description: "# round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n5-7, 9-11) Computes the nearest integer value to `arg` (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `roundl`, `lroundl`, `llroundl` is called. Otherwise, if `arg` has integer type or the type `double`, `round`, `lround`, `llround` is called. Otherwise, `roundf`, `lroundf`, `llroundf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases away from zero, is returned.\n\nReturn value\n\nArgument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lround` or `llround` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `round`, `roundf`, and `roundl` function:\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lround` and `llround` families of functions:\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised by `round` when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `round` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lround.html) that all cases where `lround` or `llround` raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nThe `double` version of `round` behaves as if implemented as follows:\n\n```\n#include <math.h>\ndouble round(double x)\n{\n    return signbit(x) ? ceil(x - 0.5) : floor(x + 0.5);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // round\n    printf(\"round(+2.3) = %+.1f  \", round(2.3));\n    printf(\"round(+2.5) = %+.1f  \", round(2.5));\n    printf(\"round(+2.7) = %+.1f\\n\", round(2.7));\n    printf(\"round(-2.3) = %+.1f  \", round(-2.3));\n    printf(\"round(-2.5) = %+.1f  \", round(-2.5));\n    printf(\"round(-2.7) = %+.1f\\n\", round(-2.7));\n \n    printf(\"round(-0.0) = %+.1f\\n\", round(-0.0));\n    printf(\"round(-Inf) = %+f\\n\",   round(-INFINITY));\n \n    // lround\n    printf(\"lround(+2.3) = %ld  \", lround(2.3));\n    printf(\"lround(+2.5) = %ld  \", lround(2.5));\n    printf(\"lround(+2.7) = %ld\\n\", lround(2.7));\n    printf(\"lround(-2.3) = %ld  \", lround(-2.3));\n    printf(\"lround(-2.5) = %ld  \", lround(-2.5));\n    printf(\"lround(-2.7) = %ld\\n\", lround(-2.7));\n \n    printf(\"lround(-0.0) = %ld\\n\", lround(-0.0));\n    printf(\"lround(-Inf) = %ld\\n\", lround(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lround(LONG_MAX+1.5) = %ld\\n\", lround(LONG_MAX+1.5));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nround(+2.3) = +2.0  round(+2.5) = +3.0  round(+2.7) = +3.0\nround(-2.3) = -2.0  round(-2.5) = -3.0  round(-2.7) = -3.0\nround(-0.0) = -0.0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nlround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.6 The round functions (p: 184)\n  - 7.12.9.7 The lround and llround functions (p: 184-185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.6 The round functions (p: 384)\n  - F.10.6.7 The lround and llround functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.6 The round functions (p: 253)\n  - 7.12.9.7 The lround and llround functions (p: 253)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.6 The round functions (p: 527)\n  - F.10.6.7 The lround and llround functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.6 The round functions (p: 233)\n  - 7.12.9.7 The lround and llround functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.6 The round functions (p: 464)\n  - F.9.6.7 The lround and llround functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/round](https://en.cppreference.com/w/c/numeric/math/round)"
- name: localeconv
  summary: The localeconv function obtains a pointer to a static object of type lconv, which represents numeric and monetary formatting rules of the current C locale
  description: "# localeconv\n\n[TABLE]\n\nThe `localeconv` function obtains a pointer to a static object of type [`lconv`](lconv \"c/locale/lconv\"), which represents numeric and monetary formatting rules of the current C locale.\n\n### Parameters\n\n(none)\n\n### Return value\n\npointer to the current [`lconv`](lconv \"c/locale/lconv\") object.\n\n### Notes\n\nModifying the object references through the returned pointer is undefined behavior.\n\n`localeconv` modifies a static object, calling it from different threads without synchronization is undefined behavior.\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n \nint main(void)\n{\n  setlocale(LC_MONETARY, \"en_IN.utf8\");\n  struct lconv *lc = localeconv();\n  printf(\"Local Currency Symbol        : %s\\n\", lc->currency_symbol);\n  printf(\"International Currency Symbol: %s\\n\", lc->int_curr_symbol);\n}\n```\n\nOutput:\n\n```\nLocal Currency Symbol        : ₹\nInternational Currency Symbol: INR\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.11.2.1 The localeconv function (p: 225-230)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.11.2.1 The localeconv function (p: 206-211)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.4.2.1 The localeconv function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/locale/localeconv](https://en.cppreference.com/w/c/locale/localeconv)"
- name: Localization support
  summary: ''
  description: "# Localization support\n\n[TABLE]\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.11 Localization \\<locale.h\\> (p: 223-230)\n  - 7.31.6 Localization \\<locale.h\\> (p: 455)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.11 Localization \\<locale.h\\> (p: 204-211)\n  - 7.26.5 Localization \\<locale.h\\> (p: 401)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.4 LOCALIZATION \\<locale.h\\>\n  - 4.13.3 Localization \\<locale.h\\>\n\n### See also\n\n|                                                                                                     |     |\n|-----------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/locale \"cpp/locale\") for Localization library |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/locale](https://en.cppreference.com/w/c/locale)"
- name: localtime
  summary: The function localtime may not be thread-safe
  description: "# localtime, localtime_r, localtime_s\n\n[TABLE]\n\n1) Converts given time since epoch (a [`time_t`](time_t \"c/chrono/time t\") value pointed to by `timer`) into calendar time, expressed in local time, in the [`struct tm`](tm \"c/chrono/tm\") format. The result is stored in static storage and a pointer to that static storage is returned.\n\n2) Same as (1), except that the function uses user-provided storage `buf` for the result.\n\n3) Same as (1), except that the function uses user-provided storage `buf` for the result and that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `timer` or `buf` is a null pointer\n\nAs with all bounds-checked functions, `localtime_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<time.h>`](../chrono \"c/chrono\").\n\n### Parameters\n\n|       |     |                                                                                                     |\n|-------|-----|-----------------------------------------------------------------------------------------------------|\n| timer | \\-  | pointer to a [`time_t`](time_t \"c/chrono/time t\") object to convert                                 |\n| buf   | \\-  | pointer to a `struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm) object to store the result |\n\n### Return value\n\n1) pointer to a static internal [`tm`](tm \"c/chrono/tm\") object on success, or null pointer otherwise. The structure may be shared between [`gmtime`](gmtime \"c/chrono/gmtime\"), `localtime`, and [`ctime`](ctime \"c/chrono/ctime\") and may be overwritten on each invocation.\n\n2-3) copy of the `buf` pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to local calendar time)\n\n### Notes\n\nThe function `localtime` may not be thread-safe.\n\nPOSIX requires that `localtime` and `localtime_r` set [`errno`](../error/errno \"c/error/errno\") to [`EOVERFLOW`](../error/errno_macros \"c/error/errno macros\") if it fails because the argument is too large.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime.html) that the timezone information is determined by `localtime` and `localtime_r` as if by calling [`tzset`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tzset.html), which reads the environment variable `TZ`.\n\nThe implementation of `localtime_s` in [Microsoft CRT](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/localtime-s-localtime32-s-localtime64-s?view=vs-2019) is incompatible with the C standard since it has reversed parameter order and returns `errno_t`.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#define _XOPEN_SOURCE // for putenv\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>   // for putenv\n \nint main(void)\n{\n    time_t t = time(NULL);\n    printf(\"UTC:       %s\", asctime(gmtime(&t)));\n    printf(\"local:     %s\", asctime(localtime(&t)));\n    // POSIX-specific\n    putenv(\"TZ=Asia/Singapore\");\n    printf(\"Singapore: %s\", asctime(localtime(&t)));\n \n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n    asctime_s(str,sizeof str,gmtime_s(&t, &buf));\n    printf(\"UTC:       %s\", str);\n    asctime_s(str,sizeof str,localtime_s(&t, &buf));\n    printf(\"local:     %s\", str);\n#endif\n}\n```\n\nPossible output:\n\n```\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\nSingapore: Fri Sep 15 22:22:05 2017\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.3.4 The localtime function (p: 288)\n  - K.3.8.2.4 The localtime_s function (p: 455)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.3.4 The localtime function (p: 394)\n  - K.3.8.2.4 The localtime_s function (p: 627)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.4 The localtime function (p: 343)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.4 The localtime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/localtime](https://en.cppreference.com/w/c/chrono/localtime)"
- name: localtime_r
  summary: The function localtime may not be thread-safe
  description: "# localtime, localtime_r, localtime_s\n\n[TABLE]\n\n1) Converts given time since epoch (a [`time_t`](time_t \"c/chrono/time t\") value pointed to by `timer`) into calendar time, expressed in local time, in the [`struct tm`](tm \"c/chrono/tm\") format. The result is stored in static storage and a pointer to that static storage is returned.\n\n2) Same as (1), except that the function uses user-provided storage `buf` for the result.\n\n3) Same as (1), except that the function uses user-provided storage `buf` for the result and that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `timer` or `buf` is a null pointer\n\nAs with all bounds-checked functions, `localtime_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<time.h>`](../chrono \"c/chrono\").\n\n### Parameters\n\n|       |     |                                                                                                     |\n|-------|-----|-----------------------------------------------------------------------------------------------------|\n| timer | \\-  | pointer to a [`time_t`](time_t \"c/chrono/time t\") object to convert                                 |\n| buf   | \\-  | pointer to a `struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm) object to store the result |\n\n### Return value\n\n1) pointer to a static internal [`tm`](tm \"c/chrono/tm\") object on success, or null pointer otherwise. The structure may be shared between [`gmtime`](gmtime \"c/chrono/gmtime\"), `localtime`, and [`ctime`](ctime \"c/chrono/ctime\") and may be overwritten on each invocation.\n\n2-3) copy of the `buf` pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to local calendar time)\n\n### Notes\n\nThe function `localtime` may not be thread-safe.\n\nPOSIX requires that `localtime` and `localtime_r` set [`errno`](../error/errno \"c/error/errno\") to [`EOVERFLOW`](../error/errno_macros \"c/error/errno macros\") if it fails because the argument is too large.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime.html) that the timezone information is determined by `localtime` and `localtime_r` as if by calling [`tzset`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tzset.html), which reads the environment variable `TZ`.\n\nThe implementation of `localtime_s` in [Microsoft CRT](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/localtime-s-localtime32-s-localtime64-s?view=vs-2019) is incompatible with the C standard since it has reversed parameter order and returns `errno_t`.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#define _XOPEN_SOURCE // for putenv\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>   // for putenv\n \nint main(void)\n{\n    time_t t = time(NULL);\n    printf(\"UTC:       %s\", asctime(gmtime(&t)));\n    printf(\"local:     %s\", asctime(localtime(&t)));\n    // POSIX-specific\n    putenv(\"TZ=Asia/Singapore\");\n    printf(\"Singapore: %s\", asctime(localtime(&t)));\n \n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n    asctime_s(str,sizeof str,gmtime_s(&t, &buf));\n    printf(\"UTC:       %s\", str);\n    asctime_s(str,sizeof str,localtime_s(&t, &buf));\n    printf(\"local:     %s\", str);\n#endif\n}\n```\n\nPossible output:\n\n```\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\nSingapore: Fri Sep 15 22:22:05 2017\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.3.4 The localtime function (p: 288)\n  - K.3.8.2.4 The localtime_s function (p: 455)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.3.4 The localtime function (p: 394)\n  - K.3.8.2.4 The localtime_s function (p: 627)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.4 The localtime function (p: 343)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.4 The localtime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/localtime](https://en.cppreference.com/w/c/chrono/localtime)"
- name: localtime_s
  summary: The function localtime may not be thread-safe
  description: "# localtime, localtime_r, localtime_s\n\n[TABLE]\n\n1) Converts given time since epoch (a [`time_t`](time_t \"c/chrono/time t\") value pointed to by `timer`) into calendar time, expressed in local time, in the [`struct tm`](tm \"c/chrono/tm\") format. The result is stored in static storage and a pointer to that static storage is returned.\n\n2) Same as (1), except that the function uses user-provided storage `buf` for the result.\n\n3) Same as (1), except that the function uses user-provided storage `buf` for the result and that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `timer` or `buf` is a null pointer\n\nAs with all bounds-checked functions, `localtime_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<time.h>`](../chrono \"c/chrono\").\n\n### Parameters\n\n|       |     |                                                                                                     |\n|-------|-----|-----------------------------------------------------------------------------------------------------|\n| timer | \\-  | pointer to a [`time_t`](time_t \"c/chrono/time t\") object to convert                                 |\n| buf   | \\-  | pointer to a `struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm) object to store the result |\n\n### Return value\n\n1) pointer to a static internal [`tm`](tm \"c/chrono/tm\") object on success, or null pointer otherwise. The structure may be shared between [`gmtime`](gmtime \"c/chrono/gmtime\"), `localtime`, and [`ctime`](ctime \"c/chrono/ctime\") and may be overwritten on each invocation.\n\n2-3) copy of the `buf` pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to local calendar time)\n\n### Notes\n\nThe function `localtime` may not be thread-safe.\n\nPOSIX requires that `localtime` and `localtime_r` set [`errno`](../error/errno \"c/error/errno\") to [`EOVERFLOW`](../error/errno_macros \"c/error/errno macros\") if it fails because the argument is too large.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime.html) that the timezone information is determined by `localtime` and `localtime_r` as if by calling [`tzset`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tzset.html), which reads the environment variable `TZ`.\n\nThe implementation of `localtime_s` in [Microsoft CRT](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/localtime-s-localtime32-s-localtime64-s?view=vs-2019) is incompatible with the C standard since it has reversed parameter order and returns `errno_t`.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#define _XOPEN_SOURCE // for putenv\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>   // for putenv\n \nint main(void)\n{\n    time_t t = time(NULL);\n    printf(\"UTC:       %s\", asctime(gmtime(&t)));\n    printf(\"local:     %s\", asctime(localtime(&t)));\n    // POSIX-specific\n    putenv(\"TZ=Asia/Singapore\");\n    printf(\"Singapore: %s\", asctime(localtime(&t)));\n \n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n    asctime_s(str,sizeof str,gmtime_s(&t, &buf));\n    printf(\"UTC:       %s\", str);\n    asctime_s(str,sizeof str,localtime_s(&t, &buf));\n    printf(\"local:     %s\", str);\n#endif\n}\n```\n\nPossible output:\n\n```\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\nSingapore: Fri Sep 15 22:22:05 2017\nUTC:       Fri Sep 15 14:22:05 2017\nlocal:     Fri Sep 15 14:22:05 2017\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.3.4 The localtime function (p: 288)\n  - K.3.8.2.4 The localtime_s function (p: 455)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.3.4 The localtime function (p: 394)\n  - K.3.8.2.4 The localtime_s function (p: 627)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.4 The localtime function (p: 343)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.4 The localtime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/localtime](https://en.cppreference.com/w/c/chrono/localtime)"
- name: log
  summary: If no errors occur, the natural (base-e) logarithm of arg (ln(arg) or loge(arg)) is returned
  description: "# log, logf, logl\n\n[TABLE]\n\n1-3) Computes the natural (base *e*) logarithm of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `logl` is called. Otherwise, if `arg` has integer type or the type `double`, `log` is called. Otherwise, `logf` is called. If `arg` is complex or imaginary, then the macro invokes the corresponding complex function ([`clogf`](http://en.cppreference.com/w/c/numeric/complex/clog), [`clog`](http://en.cppreference.com/w/c/numeric/complex/clog), [`clogl`](http://en.cppreference.com/w/c/numeric/complex/clog)).\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the natural (base-*e*) logarithm of `arg` (ln(arg) or log_(e)(arg)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nPole error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is 1, +0 is returned\n- If the argument is negative, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log(1) = %f\\n\", log(1));\n    printf(\"base-5 logarithm of 125 = %f\\n\", log(125)/log(5));\n    // special values\n    printf(\"log(1) = %f\\n\", log(1));\n    printf(\"log(+Inf) = %f\\n\", log(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log(0) = %f\\n\", log(0));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nOutput:\n\n```\nlog(1) = 0.000000\nbase-5 logarithm of 125 = 3.000000\nlog(1) = 0.000000\nlog(+Inf) = inf\nlog(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.7 The log functions (p: 178-179)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.7 The log functions (p: 380)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.7 The log functions (p: 244-245)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.7 The log functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.7 The log functions (p: 225)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.7 The log functions (p: 459)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.4 The log function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log](https://en.cppreference.com/w/c/numeric/math/log)"
- name: log10
  summary: If no errors occur, the common (base-10) logarithm of arg (log10(arg) or lg(arg)) is returned
  description: "# log10, log10f, log10l\n\n[TABLE]\n\n1-3) Computes the common (base-*10*) logarithm of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `log10l` is called. Otherwise, if `arg` has integer type or the type `double`, `log10` is called. Otherwise, `log10f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the common (base-*10*) logarithm of `arg` (log₁₀(arg) or lg(arg)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nPole error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is 1, +0 is returned\n- If the argument is negative, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log10(1000) = %f\\n\", log10(1000));\n    printf(\"log10(0.001) = %f\\n\", log10(0.001));\n    printf(\"base-5 logarithm of 125 = %f\\n\", log10(125)/log10(5));\n    // special values\n    printf(\"log10(1) = %f\\n\", log10(1));\n    printf(\"log10(+Inf) = %f\\n\", log10(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log10(0) = %f\\n\", log10(0));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlog10(1000) = 3.000000\nlog10(0.001) = -3.000000\nbase-5 logarithm of 125 = 3.000000\nlog10(1) = 0.000000\nlog10(+Inf) = inf\nlog10(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.8 The log10 functions (p: 179)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.8 The log10 functions (p: 380)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.8 The log10 functions (p: 245)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.8 The log10 functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.8 The log10 functions (p: 225-226)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.8 The log10 functions (p: 459)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.5 The log10 function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log10](https://en.cppreference.com/w/c/numeric/math/log10)"
- name: log10f
  summary: If no errors occur, the common (base-10) logarithm of arg (log10(arg) or lg(arg)) is returned
  description: "# log10, log10f, log10l\n\n[TABLE]\n\n1-3) Computes the common (base-*10*) logarithm of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `log10l` is called. Otherwise, if `arg` has integer type or the type `double`, `log10` is called. Otherwise, `log10f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the common (base-*10*) logarithm of `arg` (log₁₀(arg) or lg(arg)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nPole error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is 1, +0 is returned\n- If the argument is negative, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log10(1000) = %f\\n\", log10(1000));\n    printf(\"log10(0.001) = %f\\n\", log10(0.001));\n    printf(\"base-5 logarithm of 125 = %f\\n\", log10(125)/log10(5));\n    // special values\n    printf(\"log10(1) = %f\\n\", log10(1));\n    printf(\"log10(+Inf) = %f\\n\", log10(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log10(0) = %f\\n\", log10(0));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlog10(1000) = 3.000000\nlog10(0.001) = -3.000000\nbase-5 logarithm of 125 = 3.000000\nlog10(1) = 0.000000\nlog10(+Inf) = inf\nlog10(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.8 The log10 functions (p: 179)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.8 The log10 functions (p: 380)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.8 The log10 functions (p: 245)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.8 The log10 functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.8 The log10 functions (p: 225-226)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.8 The log10 functions (p: 459)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.5 The log10 function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log10](https://en.cppreference.com/w/c/numeric/math/log10)"
- name: log10l
  summary: If no errors occur, the common (base-10) logarithm of arg (log10(arg) or lg(arg)) is returned
  description: "# log10, log10f, log10l\n\n[TABLE]\n\n1-3) Computes the common (base-*10*) logarithm of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `log10l` is called. Otherwise, if `arg` has integer type or the type `double`, `log10` is called. Otherwise, `log10f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the common (base-*10*) logarithm of `arg` (log₁₀(arg) or lg(arg)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nPole error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is 1, +0 is returned\n- If the argument is negative, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log10(1000) = %f\\n\", log10(1000));\n    printf(\"log10(0.001) = %f\\n\", log10(0.001));\n    printf(\"base-5 logarithm of 125 = %f\\n\", log10(125)/log10(5));\n    // special values\n    printf(\"log10(1) = %f\\n\", log10(1));\n    printf(\"log10(+Inf) = %f\\n\", log10(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log10(0) = %f\\n\", log10(0));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlog10(1000) = 3.000000\nlog10(0.001) = -3.000000\nbase-5 logarithm of 125 = 3.000000\nlog10(1) = 0.000000\nlog10(+Inf) = inf\nlog10(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.8 The log10 functions (p: 179)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.8 The log10 functions (p: 380)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.8 The log10 functions (p: 245)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.8 The log10 functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.8 The log10 functions (p: 225-226)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.8 The log10 functions (p: 459)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.5 The log10 function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log10](https://en.cppreference.com/w/c/numeric/math/log10)"
- name: log1p
  summary: If no errors occur ln(1+arg) is returned
  description: "# log1p, log1pf, log1pl\n\n[TABLE]\n\n1-3) Computes the natural (base `e`) logarithm of `1+arg`. This function is more precise than the expression [`log`](http://en.cppreference.com/w/c/numeric/math/log)`(``1``+``arg``)` if `arg` is close to zero.\n\n4) Type-generic macro: If `arg` has type `long double`, `log1pl` is called. Otherwise, if `arg` has integer type or the type `double`, `log1p` is called. Otherwise, `log1pf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur ln(1+arg) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, `-HUGE_VAL`, `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than -1.\n\nPole error may occur if `arg` is -1.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, it is returned unmodified\n- If the argument is -1, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is less than -1, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nThe functions [`expm1`](expm1 \"c/numeric/math/expm1\") and `log1p` are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)^(n)-1 can be expressed as [`expm1`](http://en.cppreference.com/w/c/numeric/math/expm1)`(``n ``*`` log1p``(``x``)``)`. These functions also simplify writing accurate inverse hyperbolic functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log1p(0) = %f\\n\", log1p(0));\n    printf(\"Interest earned in 2 days on $100, compounded daily at 1%%\\n\"\n           \" on a 30/360 calendar = %f\\n\",\n           100*expm1(2*log1p(0.01/360)));\n    printf(\"log(1+1e-16) = %g, but log1p(1e-16) = %g\\n\",\n           log(1+1e-16), log1p(1e-16));\n    // special values\n    printf(\"log1p(-0) = %f\\n\", log1p(-0.0));\n    printf(\"log1p(+Inf) = %f\\n\", log1p(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log1p(-1) = %f\\n\", log1p(-1));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlog1p(0) = 0.000000\nInterest earned in 2 days on $100, compounded daily at 1%\n on a 30/360 calendar = 0.005556\nlog(1+1e-16) = 0, but log1p(1e-16) = 1e-16\nlog1p(-0) = -0.000000\nlog1p(+Inf) = Inf\nlog1p(-1) = -Inf\n    errno == ERANGE: Result too large\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.9 The log1p functions (p: 245)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.9 The log1p functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.9 The log1p functions (p: 226)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.9 The log1p functions (p: 459)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log1p](https://en.cppreference.com/w/c/numeric/math/log1p)"
- name: log1pf
  summary: If no errors occur ln(1+arg) is returned
  description: "# log1p, log1pf, log1pl\n\n[TABLE]\n\n1-3) Computes the natural (base `e`) logarithm of `1+arg`. This function is more precise than the expression [`log`](http://en.cppreference.com/w/c/numeric/math/log)`(``1``+``arg``)` if `arg` is close to zero.\n\n4) Type-generic macro: If `arg` has type `long double`, `log1pl` is called. Otherwise, if `arg` has integer type or the type `double`, `log1p` is called. Otherwise, `log1pf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur ln(1+arg) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, `-HUGE_VAL`, `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than -1.\n\nPole error may occur if `arg` is -1.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, it is returned unmodified\n- If the argument is -1, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is less than -1, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nThe functions [`expm1`](expm1 \"c/numeric/math/expm1\") and `log1p` are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)^(n)-1 can be expressed as [`expm1`](http://en.cppreference.com/w/c/numeric/math/expm1)`(``n ``*`` log1p``(``x``)``)`. These functions also simplify writing accurate inverse hyperbolic functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log1p(0) = %f\\n\", log1p(0));\n    printf(\"Interest earned in 2 days on $100, compounded daily at 1%%\\n\"\n           \" on a 30/360 calendar = %f\\n\",\n           100*expm1(2*log1p(0.01/360)));\n    printf(\"log(1+1e-16) = %g, but log1p(1e-16) = %g\\n\",\n           log(1+1e-16), log1p(1e-16));\n    // special values\n    printf(\"log1p(-0) = %f\\n\", log1p(-0.0));\n    printf(\"log1p(+Inf) = %f\\n\", log1p(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log1p(-1) = %f\\n\", log1p(-1));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlog1p(0) = 0.000000\nInterest earned in 2 days on $100, compounded daily at 1%\n on a 30/360 calendar = 0.005556\nlog(1+1e-16) = 0, but log1p(1e-16) = 1e-16\nlog1p(-0) = -0.000000\nlog1p(+Inf) = Inf\nlog1p(-1) = -Inf\n    errno == ERANGE: Result too large\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.9 The log1p functions (p: 245)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.9 The log1p functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.9 The log1p functions (p: 226)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.9 The log1p functions (p: 459)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log1p](https://en.cppreference.com/w/c/numeric/math/log1p)"
- name: log1pl
  summary: If no errors occur ln(1+arg) is returned
  description: "# log1p, log1pf, log1pl\n\n[TABLE]\n\n1-3) Computes the natural (base `e`) logarithm of `1+arg`. This function is more precise than the expression [`log`](http://en.cppreference.com/w/c/numeric/math/log)`(``1``+``arg``)` if `arg` is close to zero.\n\n4) Type-generic macro: If `arg` has type `long double`, `log1pl` is called. Otherwise, if `arg` has integer type or the type `double`, `log1p` is called. Otherwise, `log1pf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur ln(1+arg) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, `-HUGE_VAL`, `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than -1.\n\nPole error may occur if `arg` is -1.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, it is returned unmodified\n- If the argument is -1, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is less than -1, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nThe functions [`expm1`](expm1 \"c/numeric/math/expm1\") and `log1p` are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)^(n)-1 can be expressed as [`expm1`](http://en.cppreference.com/w/c/numeric/math/expm1)`(``n ``*`` log1p``(``x``)``)`. These functions also simplify writing accurate inverse hyperbolic functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log1p(0) = %f\\n\", log1p(0));\n    printf(\"Interest earned in 2 days on $100, compounded daily at 1%%\\n\"\n           \" on a 30/360 calendar = %f\\n\",\n           100*expm1(2*log1p(0.01/360)));\n    printf(\"log(1+1e-16) = %g, but log1p(1e-16) = %g\\n\",\n           log(1+1e-16), log1p(1e-16));\n    // special values\n    printf(\"log1p(-0) = %f\\n\", log1p(-0.0));\n    printf(\"log1p(+Inf) = %f\\n\", log1p(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log1p(-1) = %f\\n\", log1p(-1));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlog1p(0) = 0.000000\nInterest earned in 2 days on $100, compounded daily at 1%\n on a 30/360 calendar = 0.005556\nlog(1+1e-16) = 0, but log1p(1e-16) = 1e-16\nlog1p(-0) = -0.000000\nlog1p(+Inf) = Inf\nlog1p(-1) = -Inf\n    errno == ERANGE: Result too large\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.9 The log1p functions (p: 245)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.9 The log1p functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.9 The log1p functions (p: 226)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.9 The log1p functions (p: 459)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log1p](https://en.cppreference.com/w/c/numeric/math/log1p)"
- name: log2
  summary: If no errors occur, the base-2 logarithm of arg (log2(arg) or lb(arg)) is returned
  description: "# log2, log2f, log2l\n\n[TABLE]\n\n1-3) Computes the base `2` logarithm of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `log2l` is called. Otherwise, if `arg` has integer type or the type `double`, `log2` is called. Otherwise, `log2f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the base-*2* logarithm of `arg` (log₂(arg) or lb(arg)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nPole error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is 1, +0 is returned\n- If the argument is negative, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nFor integer `arg`, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log2(65536) = %f\\n\", log2(65536));\n    printf(\"log2(0.125) = %f\\n\", log2(0.125));\n    printf(\"log2(0x020f) = %f (highest set bit is in position 9)\\n\", log2(0x020f));\n    printf(\"base-5 logarithm of 125 = %f\\n\", log2(125)/log2(5));\n    // special values\n    printf(\"log2(1) = %f\\n\", log2(1));\n    printf(\"log2(+Inf) = %f\\n\", log2(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log2(0) = %f\\n\", log2(0));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlog2(65536) = 16.000000\nlog2(0.125) = -3.000000\nlog2(0x020f) = 9.041659 (highest set bit is in position 9)\nbase-5 logarithm of 125 = 3.000000\nlog2(1) = 0.000000\nlog2(+Inf) = inf\nlog2(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.10 The log2 functions (p: 179)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.10 The log2 functions (p: 381)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.10 The log2 functions (p: 246)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.10 The log2 functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.10 The log2 functions (p: 226)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.10 The log2 functions (p: 459)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log2](https://en.cppreference.com/w/c/numeric/math/log2)"
- name: log2f
  summary: If no errors occur, the base-2 logarithm of arg (log2(arg) or lb(arg)) is returned
  description: "# log2, log2f, log2l\n\n[TABLE]\n\n1-3) Computes the base `2` logarithm of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `log2l` is called. Otherwise, if `arg` has integer type or the type `double`, `log2` is called. Otherwise, `log2f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the base-*2* logarithm of `arg` (log₂(arg) or lb(arg)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nPole error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is 1, +0 is returned\n- If the argument is negative, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nFor integer `arg`, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log2(65536) = %f\\n\", log2(65536));\n    printf(\"log2(0.125) = %f\\n\", log2(0.125));\n    printf(\"log2(0x020f) = %f (highest set bit is in position 9)\\n\", log2(0x020f));\n    printf(\"base-5 logarithm of 125 = %f\\n\", log2(125)/log2(5));\n    // special values\n    printf(\"log2(1) = %f\\n\", log2(1));\n    printf(\"log2(+Inf) = %f\\n\", log2(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log2(0) = %f\\n\", log2(0));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlog2(65536) = 16.000000\nlog2(0.125) = -3.000000\nlog2(0x020f) = 9.041659 (highest set bit is in position 9)\nbase-5 logarithm of 125 = 3.000000\nlog2(1) = 0.000000\nlog2(+Inf) = inf\nlog2(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.10 The log2 functions (p: 179)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.10 The log2 functions (p: 381)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.10 The log2 functions (p: 246)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.10 The log2 functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.10 The log2 functions (p: 226)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.10 The log2 functions (p: 459)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log2](https://en.cppreference.com/w/c/numeric/math/log2)"
- name: log2l
  summary: If no errors occur, the base-2 logarithm of arg (log2(arg) or lb(arg)) is returned
  description: "# log2, log2f, log2l\n\n[TABLE]\n\n1-3) Computes the base `2` logarithm of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `log2l` is called. Otherwise, if `arg` has integer type or the type `double`, `log2` is called. Otherwise, `log2f` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the base-*2* logarithm of `arg` (log₂(arg) or lb(arg)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nPole error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is 1, +0 is returned\n- If the argument is negative, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Notes\n\nFor integer `arg`, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log2(65536) = %f\\n\", log2(65536));\n    printf(\"log2(0.125) = %f\\n\", log2(0.125));\n    printf(\"log2(0x020f) = %f (highest set bit is in position 9)\\n\", log2(0x020f));\n    printf(\"base-5 logarithm of 125 = %f\\n\", log2(125)/log2(5));\n    // special values\n    printf(\"log2(1) = %f\\n\", log2(1));\n    printf(\"log2(+Inf) = %f\\n\", log2(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log2(0) = %f\\n\", log2(0));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nlog2(65536) = 16.000000\nlog2(0.125) = -3.000000\nlog2(0x020f) = 9.041659 (highest set bit is in position 9)\nbase-5 logarithm of 125 = 3.000000\nlog2(1) = 0.000000\nlog2(+Inf) = inf\nlog2(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.10 The log2 functions (p: 179)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.10 The log2 functions (p: 381)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.10 The log2 functions (p: 246)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.10 The log2 functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.10 The log2 functions (p: 226)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.10 The log2 functions (p: 459)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log2](https://en.cppreference.com/w/c/numeric/math/log2)"
- name: logb
  summary: Formally, the unbiased exponent is the signed integral part of logr|arg| (returned by this function as a floating-point value), for non-zero arg, where r is FLT_RADIX
  description: "# logb, logbf, logbl\n\n[TABLE]\n\n1-3) Extracts the value of the unbiased radix-independent exponent from the floating-point argument `arg`, and returns it as a floating-point value.\n\n4) Type-generic macros: If `arg` has type `long double`, `logbl` is called. Otherwise, if `arg` has integer type or the type `double`, `logb` is called. Otherwise, `logbf` is called.\n\nFormally, the unbiased exponent is the signed integral part of log_(r)\\|arg\\| (returned by this function as a floating-point value), for non-zero arg, where `r` is [`FLT_RADIX`](../../types/limits \"c/types/limits\"). If `arg` is subnormal, it is treated as though it was normalized.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the unbiased exponent of `arg` is returned as a signed floating-point value.\n\nIf a domain error occurs, an implementation-defined value is returned\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain or range error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `arg` is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `arg` is ±∞, +∞ is returned\n- If `arg` is NaN, NaN is returned.\n- In all other cases, the result is exact ([`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised) and [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/logb.html) that a pole error occurs if `arg` is ±0.\n\nThe value of the exponent returned by `logb` is always 1 less than the exponent retuned by [`frexp`](frexp \"c/numeric/math/frexp\") because of the different normalization requirements: for the exponent `e` returned by `logb`, \\|arg\\*r^(-e)\\| is between 1 and `r` (typically between `1` and `2`), but for the exponent `e` returned by [`frexp`](frexp \"c/numeric/math/frexp\"), \\|arg\\*2^(-e)\\| is between `0.5` and `1`.\n\n### Example\n\nCompares different floating-point decomposition functions.\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.0f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = logb(f);\n    printf(\"logb()/logb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"logb(0) = %f\\n\", logb(0));\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/logb() make 1.928906 * 2^6\nlogb(0) = -Inf\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.11 The logb functions (p: 179-180)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.11 The logb functions (p: 381)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.11 The logb functions (p: 246)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.11 The logb functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.11 The logb functions (p: 227)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.11 The logb functions (p: 459)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/logb](https://en.cppreference.com/w/c/numeric/math/logb)"
- name: logbf
  summary: Formally, the unbiased exponent is the signed integral part of logr|arg| (returned by this function as a floating-point value), for non-zero arg, where r is FLT_RADIX
  description: "# logb, logbf, logbl\n\n[TABLE]\n\n1-3) Extracts the value of the unbiased radix-independent exponent from the floating-point argument `arg`, and returns it as a floating-point value.\n\n4) Type-generic macros: If `arg` has type `long double`, `logbl` is called. Otherwise, if `arg` has integer type or the type `double`, `logb` is called. Otherwise, `logbf` is called.\n\nFormally, the unbiased exponent is the signed integral part of log_(r)\\|arg\\| (returned by this function as a floating-point value), for non-zero arg, where `r` is [`FLT_RADIX`](../../types/limits \"c/types/limits\"). If `arg` is subnormal, it is treated as though it was normalized.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the unbiased exponent of `arg` is returned as a signed floating-point value.\n\nIf a domain error occurs, an implementation-defined value is returned\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain or range error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `arg` is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `arg` is ±∞, +∞ is returned\n- If `arg` is NaN, NaN is returned.\n- In all other cases, the result is exact ([`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised) and [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/logb.html) that a pole error occurs if `arg` is ±0.\n\nThe value of the exponent returned by `logb` is always 1 less than the exponent retuned by [`frexp`](frexp \"c/numeric/math/frexp\") because of the different normalization requirements: for the exponent `e` returned by `logb`, \\|arg\\*r^(-e)\\| is between 1 and `r` (typically between `1` and `2`), but for the exponent `e` returned by [`frexp`](frexp \"c/numeric/math/frexp\"), \\|arg\\*2^(-e)\\| is between `0.5` and `1`.\n\n### Example\n\nCompares different floating-point decomposition functions.\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.0f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = logb(f);\n    printf(\"logb()/logb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"logb(0) = %f\\n\", logb(0));\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/logb() make 1.928906 * 2^6\nlogb(0) = -Inf\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.11 The logb functions (p: 179-180)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.11 The logb functions (p: 381)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.11 The logb functions (p: 246)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.11 The logb functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.11 The logb functions (p: 227)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.11 The logb functions (p: 459)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/logb](https://en.cppreference.com/w/c/numeric/math/logb)"
- name: logbl
  summary: Formally, the unbiased exponent is the signed integral part of logr|arg| (returned by this function as a floating-point value), for non-zero arg, where r is FLT_RADIX
  description: "# logb, logbf, logbl\n\n[TABLE]\n\n1-3) Extracts the value of the unbiased radix-independent exponent from the floating-point argument `arg`, and returns it as a floating-point value.\n\n4) Type-generic macros: If `arg` has type `long double`, `logbl` is called. Otherwise, if `arg` has integer type or the type `double`, `logb` is called. Otherwise, `logbf` is called.\n\nFormally, the unbiased exponent is the signed integral part of log_(r)\\|arg\\| (returned by this function as a floating-point value), for non-zero arg, where `r` is [`FLT_RADIX`](../../types/limits \"c/types/limits\"). If `arg` is subnormal, it is treated as though it was normalized.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the unbiased exponent of `arg` is returned as a signed floating-point value.\n\nIf a domain error occurs, an implementation-defined value is returned\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain or range error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `arg` is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `arg` is ±∞, +∞ is returned\n- If `arg` is NaN, NaN is returned.\n- In all other cases, the result is exact ([`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised) and [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/logb.html) that a pole error occurs if `arg` is ±0.\n\nThe value of the exponent returned by `logb` is always 1 less than the exponent retuned by [`frexp`](frexp \"c/numeric/math/frexp\") because of the different normalization requirements: for the exponent `e` returned by `logb`, \\|arg\\*r^(-e)\\| is between 1 and `r` (typically between `1` and `2`), but for the exponent `e` returned by [`frexp`](frexp \"c/numeric/math/frexp\"), \\|arg\\*2^(-e)\\| is between `0.5` and `1`.\n\n### Example\n\nCompares different floating-point decomposition functions.\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.0f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = logb(f);\n    printf(\"logb()/logb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"logb(0) = %f\\n\", logb(0));\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/logb() make 1.928906 * 2^6\nlogb(0) = -Inf\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.11 The logb functions (p: 179-180)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.11 The logb functions (p: 381)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.11 The logb functions (p: 246)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.11 The logb functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.11 The logb functions (p: 227)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.11 The logb functions (p: 459)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/logb](https://en.cppreference.com/w/c/numeric/math/logb)"
- name: logf
  summary: If no errors occur, the natural (base-e) logarithm of arg (ln(arg) or loge(arg)) is returned
  description: "# log, logf, logl\n\n[TABLE]\n\n1-3) Computes the natural (base *e*) logarithm of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `logl` is called. Otherwise, if `arg` has integer type or the type `double`, `log` is called. Otherwise, `logf` is called. If `arg` is complex or imaginary, then the macro invokes the corresponding complex function ([`clogf`](http://en.cppreference.com/w/c/numeric/complex/clog), [`clog`](http://en.cppreference.com/w/c/numeric/complex/clog), [`clogl`](http://en.cppreference.com/w/c/numeric/complex/clog)).\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the natural (base-*e*) logarithm of `arg` (ln(arg) or log_(e)(arg)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nPole error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is 1, +0 is returned\n- If the argument is negative, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log(1) = %f\\n\", log(1));\n    printf(\"base-5 logarithm of 125 = %f\\n\", log(125)/log(5));\n    // special values\n    printf(\"log(1) = %f\\n\", log(1));\n    printf(\"log(+Inf) = %f\\n\", log(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log(0) = %f\\n\", log(0));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nOutput:\n\n```\nlog(1) = 0.000000\nbase-5 logarithm of 125 = 3.000000\nlog(1) = 0.000000\nlog(+Inf) = inf\nlog(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.7 The log functions (p: 178-179)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.7 The log functions (p: 380)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.7 The log functions (p: 244-245)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.7 The log functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.7 The log functions (p: 225)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.7 The log functions (p: 459)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.4 The log function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log](https://en.cppreference.com/w/c/numeric/math/log)"
- name: Logical operators
  summary: Logical operators apply standard boolean algebra operations to their operands
  description: "# Logical operators\n\nLogical operators apply standard boolean algebra operations to their operands.\n\n| Operator | Operator name | Example  | Result                             |\n|----------|---------------|----------|------------------------------------|\n| `!`      | logical NOT   | `!a`     | the logical negation of **a**      |\n| `&&`     | logical AND   | `a && b` | the logical AND of **a** and **b** |\n| `||`     | logical OR    | `a || b` | the logical OR of **a** and **b**  |\n\n### Logical NOT\n\nThe logical NOT expression has the form\n\n|                |     |     |\n|----------------|-----|-----|\n| `!` expression |     |     |\n\nwhere\n\n|            |     |                                                                        |\n|------------|-----|------------------------------------------------------------------------|\n| expression | \\-  | an expression of any [scalar type](type#Type_groups \"c/language/type\") |\n\nThe logical NOT operator has type `int`. Its value is `​0​` if expression evaluates to a value that compares unequal to zero. Its value is `1` if expression evaluates to a value that compares equal to zero. (so `!E` is the same as `(0==E)`)\n\n```\n#include <stdbool.h>\n#include <stdio.h>\n#include <ctype.h>\nint main(void)\n{\n    bool b = !(2+2 == 4); // not true\n    printf(\"!(2+2==4) = %s\\n\", b ? \"true\" : \"false\");\n \n    int n = isspace('a'); // zero if 'a' is a space, nonzero otherwise\n    int x = !!n; // \"bang-bang\", common C idiom for mapping integers to [0,1]\n                 // (all non-zero values become 1)\n    char *a[2] = {\"nonspace\", \"space\"};\n    printf(\"%s\\n\", a[x]); // now x can be safely used as an index to array of 2 ints\n}\n```\n\nOutput:\n\n```\n!(2+2==4) = false\nnonspace\n```\n\n### Logical AND\n\nThe logical AND expression has the form\n\n|              |     |     |\n|--------------|-----|-----|\n| lhs `&&` rhs |     |     |\n\nwhere\n\n|     |     |                                                                                                |\n|-----|-----|------------------------------------------------------------------------------------------------|\n| lhs | \\-  | an expression of any scalar type                                                               |\n| rhs | \\-  | an expression of any scalar type, which is only evaluated if lhs does not compare equal to `​0​` |\n\nThe logical-AND operator has type `int` and the value `1` if both lhs and rhs compare unequal to zero. It has the value `​0​` otherwise (if either lhs or rhs or both compare equal to zero).\n\nThere is a [sequence point](eval_order \"c/language/eval order\") after the evaluation of lhs. If the result of lhs compares equal to zero, then rhs is not evaluated at all (so-called *short-circuit evaluation*)\n\n```\n#include <stdbool.h>\n#include <stdio.h>\nint main(void)\n{\n    bool b = 2+2==4 && 2*2==4; // b == true\n \n    1 > 2 && puts(\"this won't print\");\n \n    char *p = \"abc\";\n    if(p && *p) // common C idiom: if p is not null\n                // AND if p does not point at the end of the string\n    {           // (note that thanks to short-circuit evaluation, this\n                //  will not attempt to dereference a null pointer)\n    // ...      // ... then do some string processing\n    }\n}\n```\n\n### Logical OR\n\nThe logical OR expression has the form\n\n|              |     |     |\n|--------------|-----|-----|\n| lhs `||` rhs |     |     |\n\nwhere\n\n|     |     |                                                                                        |\n|-----|-----|----------------------------------------------------------------------------------------|\n| lhs | \\-  | an expression of any scalar type                                                       |\n| rhs | \\-  | an expression of any scalar type, which is only evaluated if lhs compares equal to `​0​` |\n\nThe logical-OR operator has type `int` and the value `1` if either lhs or rhs compare unequal to zero. It has value `​0​` otherwise (if both lhs and rhs compare equal to zero).\n\nThere is a [sequence point](eval_order \"c/language/eval order\") after the evaluation of lhs. If the result of lhs compares unequal to zero, then rhs is not evaluated at all (so-called *short-circuit evaluation*)\n\n```\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\nint main(void)\n{\n    bool b = 2+2 == 4 || 2+2 == 5; // true\n    printf(\"true or false = %s\\n\", b ? \"true\" : \"false\");\n \n    // logical OR can be used simialar to perl's \"or die\", as long as rhs has scalar type\n    fopen(\"test.txt\", \"r\") || printf(\"could not open test.txt: %s\\n\", strerror(errno));\n}\n```\n\nPossible output:\n\n```\ntrue or false = true\ncould not open test.txt: No such file or directory\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.3.3 Unary arithmetic operators (p: 89)\n  - 6.5.13 Logical AND operator (p: 99)\n  - 6.5.14 Logical OR operator (p: 99)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5.3.3 Unary arithmetic operators (p: 79)\n  - 6.5.13 Logical AND operator (p: 89)\n  - 6.5.14 Logical OR operator (p: 89)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.3.3.3 Unary arithmetic operators\n  - 3.3.13 Logical AND operator\n  - 3.3.14 Logical OR operator\n\n### See Also\n\n[Operator precedence](operator_precedence \"c/language/operator precedence\")\n\n[TABLE]\n\n### See also\n\n|                                                                                                                                        |     |\n|----------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/operator_logical \"cpp/language/operator logical\") for Logical operators |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/operator_logical](https://en.cppreference.com/w/c/language/operator_logical)"
- name: logl
  summary: If no errors occur, the natural (base-e) logarithm of arg (ln(arg) or loge(arg)) is returned
  description: "# log, logf, logl\n\n[TABLE]\n\n1-3) Computes the natural (base *e*) logarithm of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `logl` is called. Otherwise, if `arg` has integer type or the type `double`, `log` is called. Otherwise, `logf` is called. If `arg` is complex or imaginary, then the macro invokes the corresponding complex function ([`clogf`](http://en.cppreference.com/w/c/numeric/complex/clog), [`clog`](http://en.cppreference.com/w/c/numeric/complex/clog), [`clogl`](http://en.cppreference.com/w/c/numeric/complex/clog)).\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the natural (base-*e*) logarithm of `arg` (ln(arg) or log_(e)(arg)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error occurs, [`-HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `-HUGE_VALF`, or `-HUGE_VALL` is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nPole error may occur if `arg` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is ±0, -∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is 1, +0 is returned\n- If the argument is negative, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned\n- If the argument is NaN, NaN is returned\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"log(1) = %f\\n\", log(1));\n    printf(\"base-5 logarithm of 125 = %f\\n\", log(125)/log(5));\n    // special values\n    printf(\"log(1) = %f\\n\", log(1));\n    printf(\"log(+Inf) = %f\\n\", log(INFINITY));\n    //error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"log(0) = %f\\n\", log(0));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nOutput:\n\n```\nlog(1) = 0.000000\nbase-5 logarithm of 125 = 3.000000\nlog(1) = 0.000000\nlog(+Inf) = inf\nlog(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.7 The log functions (p: 178-179)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.3.7 The log functions (p: 380)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.7 The log functions (p: 244-245)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.7 The log functions (p: 522)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.7 The log functions (p: 225)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.7 The log functions (p: 459)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.4 The log function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/log](https://en.cppreference.com/w/c/numeric/math/log)"
- name: long
  summary: ''
  description: "# C keywords: long\n\n### Usage\n\n- [`long` type modifier](../language/types \"c/language/types\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/long](https://en.cppreference.com/w/c/keyword/long)"
- name: longjmp
  summary: Loads the execution context env saved by a previous call to setjmp
  description: "# longjmp\n\n[TABLE]\n\nLoads the execution context `env` saved by a previous call to [`setjmp`](setjmp \"c/program/setjmp\"). This function does not return. Control is transferred to the call site of the macro [`setjmp`](setjmp \"c/program/setjmp\") that set up `env`. That [`setjmp`](setjmp \"c/program/setjmp\") then returns the value, passed as the `status`.\n\nIf the function that called [`setjmp`](setjmp \"c/program/setjmp\") has exited (whether by return or by a different `longjmp` higher up the stack), the behavior is undefined. In other words, only long jumps up the call stack are allowed.\n\n|                                                                                                                          |             |\n|--------------------------------------------------------------------------------------------------------------------------|-------------|\n| Jumping across threads (if the function that called `setjmp` was executed by another thread) is also undefined behavior. | (since C11) |\n\n[TABLE]\n\n### Parameters\n\n|        |     |                                                                                                            |\n|--------|-----|------------------------------------------------------------------------------------------------------------|\n| env    | \\-  | variable referring to the execution state of the program saved by [`setjmp`](setjmp \"c/program/setjmp\")    |\n| status | \\-  | the value to return from [`setjmp`](setjmp \"c/program/setjmp\"). If it is equal to `​0​`, `1` is used instead |\n\n### Return value\n\n(none)\n\n### Notes\n\n`longjmp` is intended for handling unexpected error conditions where the function cannot return meaningfully. This is similar to exception handling in other programming languages.\n\n### Example\n\n```\n#include <stdio.h>\n#include <setjmp.h>\n#include <stdnoreturn.h>\n \njmp_buf my_jump_buffer;\n \nnoreturn void foo(int status) \n{\n    printf(\"foo(%d) called\\n\", status);\n    longjmp(my_jump_buffer, status + 1); // will return status+1 out of setjmp\n}\n \nint main(void)\n{\n    volatile int count = 0; // modified local vars in setjmp scope must be volatile\n    if (setjmp(my_jump_buffer) != 5) // compare against constant in an if\n        foo(++count);\n}\n```\n\nOutput:\n\n```\nfoo(1) called\nfoo(2) called\nfoo(3) called\nfoo(4) called\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.13.2.1 The longjmp macro (p: 191-192)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.13.2.1 The longjmp macro (p: 263-264)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.13.2.1 The longjmp macro (p: 244-245)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.6.2.1 The longjmp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/longjmp](https://en.cppreference.com/w/c/program/longjmp)"
- name: Lookup and name spaces
  summary: When an identifier is encountered in a C program, a lookup is performed to locate the declaration that introduced that identifier and that is currently in scope
  description: "# Lookup and name spaces\n\nWhen an [identifier](identifier \"c/language/identifier\") is encountered in a C program, a lookup is performed to locate the [declaration](declarations \"c/language/declarations\") that introduced that identifier and that is currently [in scope](scope \"c/language/scope\"). C allows more than one declaration for the same identifier to be in scope simultaneously if these identifiers belong to different categories, called *name spaces*:\n\n1) Label name space: all identifiers declared as [labels](statements#Labels \"c/language/statements\").\n\n2) Tag names: all identifiers declared as names of [structs](struct \"c/language/struct\"), [unions](union \"c/language/union\") and [enumerated types](enum \"c/language/enum\"). Note that all three kinds of tags share one name space.\n\n3) Member names: all identifiers declared as members of any one [struct](struct \"c/language/struct\") or [union](union \"c/language/union\"). Every struct and union introduces its own name space of this kind.\n\n|                                                                                                                                                                                                                                                                                                                                                      |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| 4) Global attribute name space: [attribute tokens](attributes \"c/language/attributes\") defined by the standard or implementation-defined attribute prefixes. 5) Non-standard attribute names: attribute names following attribute prefixes. Each attribute prefix has a separate name space for the implementation-defined attributes it introduces. | (since C23) |\n\n6) All other identifiers, called *ordinary identifiers* to distinguish from (1-5) (function names, object names, typedef names, enumeration constants).\n\nAt the point of lookup, the name space of an identifier is determined by the manner in which it is used:\n\n1) identifier appearing as the operand of a [goto statement](goto \"c/language/goto\") is looked up in the label name space.\n\n2) identifier that follows the keyword `struct`, `union`, or `enum` is looked up in the tag name space.\n\n3) identifier that follows the [member access](operator_member_access \"c/language/operator member access\") or member access through pointer operator is looked up in the name space of members of the type determined by the left-hand operand of the member access operator.\n\n|                                                                                                                                                                                                                                                                    |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| 4) identifier that directly appears in an attribute specifier (`[[...]]`) is looked up in the global attribute name space. 5) identifier that follows the `::` token following an attribute prefix is looked in the name space introduced by the attribute prefix. | (since C23) |\n\n6) all other identifiers are looked up in the name space of ordinary identifiers.\n\n### Notes\n\nThe names of [macros](../preprocessor/replace \"c/preprocessor/replace\") are not part of any name space because they are replaced by the preprocessor prior to semantic analysis.\n\nIt is common practice to inject struct/union/enum names into the name space of the ordinary identifiers using a [typedef](typedef \"c/language/typedef\") declaration:\n\n```\nstruct A { };       // introduces the name A in tag name space\ntypedef struct A A; // first, lookup for A after \"struct\" finds one in tag name space\n                    // then introduces the name A in the ordinary name space\nstruct A* p;        // OK, this A is looked up in the tag name space\nA* q;               // OK, this A is looked up in the ordinary name space\n```\n\nA well-known example of the same identifier being used across two name spaces is the identifier `stat` from the POSIX header `sys/stat.h`. It [names a function](http://pubs.opengroup.org/onlinepubs/9699919799/) when used as an ordinary identifier and [indicates a struct](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html) when used as a tag.\n\nUnlike in C++, enumeration constants are not struct members, and their name space is the name space of ordinary identifiers, and since there is no struct scope in C, their scope is the scope in which the struct declaration appears:\n\n```\nstruct tagged_union {\n   enum {INT, FLOAT, STRING} type;\n   union {\n      int integer;\n      float floating_point;\n      char *string;\n   };\n} tu;\n \ntu.type = INT; // OK in C, error in C++\n```\n\n|                                                                                                                                                                    |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If a standard attribute, an attribute prefix, or a non-standard attribute name is not supported, the invalid attribute itself is ignored without causing an error. | (since C23) |\n\n### Example\n\n```\nvoid foo (void) { return; } // ordinary name space, file scope\nstruct foo {      // tag name space, file scope\n    int foo;      // member name space for this struct foo, file scope\n    enum bar {    // tag name space, file scope\n        RED       // ordinary name space, file scope\n    } bar;        // member name space for this struct foo, file scope\n    struct foo* p; // OK: uses tag/file scope name \"foo\"\n};\nenum bar x; // OK: uses tag/file-scope bar\n// int foo; // Error: ordinary name space foo already in scope \n//union foo { int a, b; }; // Error: tag name space foo in scope\n \nint main(void)\n{\n    goto foo; // OK uses \"foo\" from label name space/function scope\n \n    struct foo { // tag name space, block scope (hides file scope)\n       enum bar x; // OK, uses \"bar\" from tag name space/file scope\n    };\n    typedef struct foo foo; // OK: uses foo from tag name space/block scope\n                            // defines block-scope ordinary foo (hides file scope)\n    (foo){.x=RED}; // uses ordinary/block-scope foo and ordinary/file-scope RED\n \nfoo:; // label name space, function scope\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.2.3 Name spaces of identifiers (p: 29-30)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.2.3 Name spaces of identifiers (p: 37)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.2.3 Name spaces of identifiers (p: 31)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.2.3 Name spaces of identifiers\n\n### See also\n\n|                                                                                                              |     |\n|--------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/lookup \"cpp/language/lookup\") for Name lookup |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/name_space](https://en.cppreference.com/w/c/language/name_space)"
- name: lrint
  summary: If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned
  description: "# rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the current rounding mode.\n\n5-7, 9-11) Rounds the floating-point argument `arg` to an integer value in integer format, using the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `rintl`, `lrintl`, `llrintl` is called. Otherwise, if `arg` has integer type or the type `double`, `rint`, `lrint`, `llrint` is called. Otherwise, `rintf`, `lrintf`, `llrintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lrint` or `llrint` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `rint` function:\n\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lrint` and `llrint` functions:\n\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lrint.html) that all cases where `lrint` or `llrint` raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nAs specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\"), [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be on non-IEEE floating-point platforms) raised by `rint` when rounding a non-integer finite value.\n\nThe only difference between `rint` and [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") is that [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `rint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is...\n\n- [`FE_DOWNWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`floor`](floor \"c/numeric/math/floor\").\n- [`FE_UPWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`ceil`](ceil \"c/numeric/math/ceil\").\n- [`FE_TOWARDZERO`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`trunc`](trunc \"c/numeric/math/trunc\")\n- [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` differs from [`round`](round \"c/numeric/math/round\") in that halfway cases are rounded to even rather than away from zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest (halfway cases to even):\\n\"\n           \"rint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nrint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n    printf(\"rounding down with lrint: \\nlrint(+2.3) = %ld  \", lrint(2.3));\n    printf(\"lrint(+2.5) = %ld  \", lrint(2.5));\n    printf(\"lrint(+3.5) = %ld\\n\", lrint(3.5));\n    printf(\"lrint(-2.3) = %ld  \", lrint(-2.3));\n    printf(\"lrint(-2.5) = %ld  \", lrint(-2.5));\n    printf(\"lrint(-3.5) = %ld\\n\", lrint(-3.5));\n \n    printf(\"lrint(-0.0) = %ld\\n\", lrint(-0.0));\n    printf(\"lrint(-Inf) = %ld\\n\", lrint(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"rint(1.1) = %.1f\\n\", rint(1.1));\n    if(fetestexcept(FE_INEXACT)) puts(\"    FE_INEXACT was raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lrint(LONG_MIN-2048.0) = %ld\\n\", lrint(LONG_MIN-2048.0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nrounding to nearest (halfway cases to even):\nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +4.0\nrint(-2.3) = -2.0  rint(-2.5) = -2.0  rint(-3.5) = -4.0\nrounding down: \nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +3.0\nrint(-2.3) = -3.0  rint(-2.5) = -3.0  rint(-3.5) = -4.0\nrounding down with lrint: \nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nrint(1.1) = 1.0\n    FE_INEXACT was raised\nlrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.4 The rint functions (p: 184)\n  - 7.12.9.5 The lrint and llrint functions (p: 184)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.4 The rint functions (p: 384)\n  - F.10.6.5 The lrint and llrint functions (p: 384)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.4 The rint functions (p: 252)\n  - 7.12.9.5 The lrint and llrint functions (p: 252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.4 The rint functions (p: 527)\n  - F.10.6.5 The lrint and llrint functions (p: 527)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.4 The rint functions (p: 232-233)\n  - 7.12.9.5 The lrint and llrint functions (p: 233)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.4 The rint functions (p: 463)\n  - F.9.6.5 The lrint and llrint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/rint](https://en.cppreference.com/w/c/numeric/math/rint)"
- name: lrintf
  summary: If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned
  description: "# rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the current rounding mode.\n\n5-7, 9-11) Rounds the floating-point argument `arg` to an integer value in integer format, using the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `rintl`, `lrintl`, `llrintl` is called. Otherwise, if `arg` has integer type or the type `double`, `rint`, `lrint`, `llrint` is called. Otherwise, `rintf`, `lrintf`, `llrintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lrint` or `llrint` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `rint` function:\n\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lrint` and `llrint` functions:\n\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lrint.html) that all cases where `lrint` or `llrint` raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nAs specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\"), [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be on non-IEEE floating-point platforms) raised by `rint` when rounding a non-integer finite value.\n\nThe only difference between `rint` and [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") is that [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `rint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is...\n\n- [`FE_DOWNWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`floor`](floor \"c/numeric/math/floor\").\n- [`FE_UPWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`ceil`](ceil \"c/numeric/math/ceil\").\n- [`FE_TOWARDZERO`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`trunc`](trunc \"c/numeric/math/trunc\")\n- [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` differs from [`round`](round \"c/numeric/math/round\") in that halfway cases are rounded to even rather than away from zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest (halfway cases to even):\\n\"\n           \"rint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nrint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n    printf(\"rounding down with lrint: \\nlrint(+2.3) = %ld  \", lrint(2.3));\n    printf(\"lrint(+2.5) = %ld  \", lrint(2.5));\n    printf(\"lrint(+3.5) = %ld\\n\", lrint(3.5));\n    printf(\"lrint(-2.3) = %ld  \", lrint(-2.3));\n    printf(\"lrint(-2.5) = %ld  \", lrint(-2.5));\n    printf(\"lrint(-3.5) = %ld\\n\", lrint(-3.5));\n \n    printf(\"lrint(-0.0) = %ld\\n\", lrint(-0.0));\n    printf(\"lrint(-Inf) = %ld\\n\", lrint(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"rint(1.1) = %.1f\\n\", rint(1.1));\n    if(fetestexcept(FE_INEXACT)) puts(\"    FE_INEXACT was raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lrint(LONG_MIN-2048.0) = %ld\\n\", lrint(LONG_MIN-2048.0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nrounding to nearest (halfway cases to even):\nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +4.0\nrint(-2.3) = -2.0  rint(-2.5) = -2.0  rint(-3.5) = -4.0\nrounding down: \nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +3.0\nrint(-2.3) = -3.0  rint(-2.5) = -3.0  rint(-3.5) = -4.0\nrounding down with lrint: \nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nrint(1.1) = 1.0\n    FE_INEXACT was raised\nlrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.4 The rint functions (p: 184)\n  - 7.12.9.5 The lrint and llrint functions (p: 184)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.4 The rint functions (p: 384)\n  - F.10.6.5 The lrint and llrint functions (p: 384)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.4 The rint functions (p: 252)\n  - 7.12.9.5 The lrint and llrint functions (p: 252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.4 The rint functions (p: 527)\n  - F.10.6.5 The lrint and llrint functions (p: 527)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.4 The rint functions (p: 232-233)\n  - 7.12.9.5 The lrint and llrint functions (p: 233)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.4 The rint functions (p: 463)\n  - F.9.6.5 The lrint and llrint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/rint](https://en.cppreference.com/w/c/numeric/math/rint)"
- name: lrintl
  summary: If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned
  description: "# rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the current rounding mode.\n\n5-7, 9-11) Rounds the floating-point argument `arg` to an integer value in integer format, using the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `rintl`, `lrintl`, `llrintl` is called. Otherwise, if `arg` has integer type or the type `double`, `rint`, `lrint`, `llrint` is called. Otherwise, `rintf`, `lrintf`, `llrintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lrint` or `llrint` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `rint` function:\n\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lrint` and `llrint` functions:\n\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lrint.html) that all cases where `lrint` or `llrint` raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nAs specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\"), [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be on non-IEEE floating-point platforms) raised by `rint` when rounding a non-integer finite value.\n\nThe only difference between `rint` and [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") is that [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `rint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is...\n\n- [`FE_DOWNWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`floor`](floor \"c/numeric/math/floor\").\n- [`FE_UPWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`ceil`](ceil \"c/numeric/math/ceil\").\n- [`FE_TOWARDZERO`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`trunc`](trunc \"c/numeric/math/trunc\")\n- [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` differs from [`round`](round \"c/numeric/math/round\") in that halfway cases are rounded to even rather than away from zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest (halfway cases to even):\\n\"\n           \"rint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nrint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n    printf(\"rounding down with lrint: \\nlrint(+2.3) = %ld  \", lrint(2.3));\n    printf(\"lrint(+2.5) = %ld  \", lrint(2.5));\n    printf(\"lrint(+3.5) = %ld\\n\", lrint(3.5));\n    printf(\"lrint(-2.3) = %ld  \", lrint(-2.3));\n    printf(\"lrint(-2.5) = %ld  \", lrint(-2.5));\n    printf(\"lrint(-3.5) = %ld\\n\", lrint(-3.5));\n \n    printf(\"lrint(-0.0) = %ld\\n\", lrint(-0.0));\n    printf(\"lrint(-Inf) = %ld\\n\", lrint(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"rint(1.1) = %.1f\\n\", rint(1.1));\n    if(fetestexcept(FE_INEXACT)) puts(\"    FE_INEXACT was raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lrint(LONG_MIN-2048.0) = %ld\\n\", lrint(LONG_MIN-2048.0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nrounding to nearest (halfway cases to even):\nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +4.0\nrint(-2.3) = -2.0  rint(-2.5) = -2.0  rint(-3.5) = -4.0\nrounding down: \nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +3.0\nrint(-2.3) = -3.0  rint(-2.5) = -3.0  rint(-3.5) = -4.0\nrounding down with lrint: \nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nrint(1.1) = 1.0\n    FE_INEXACT was raised\nlrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.4 The rint functions (p: 184)\n  - 7.12.9.5 The lrint and llrint functions (p: 184)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.4 The rint functions (p: 384)\n  - F.10.6.5 The lrint and llrint functions (p: 384)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.4 The rint functions (p: 252)\n  - 7.12.9.5 The lrint and llrint functions (p: 252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.4 The rint functions (p: 527)\n  - F.10.6.5 The lrint and llrint functions (p: 527)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.4 The rint functions (p: 232-233)\n  - 7.12.9.5 The lrint and llrint functions (p: 233)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.4 The rint functions (p: 463)\n  - F.9.6.5 The lrint and llrint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/rint](https://en.cppreference.com/w/c/numeric/math/rint)"
- name: lround
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned
  description: "# round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n5-7, 9-11) Computes the nearest integer value to `arg` (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `roundl`, `lroundl`, `llroundl` is called. Otherwise, if `arg` has integer type or the type `double`, `round`, `lround`, `llround` is called. Otherwise, `roundf`, `lroundf`, `llroundf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases away from zero, is returned.\n\nReturn value\n\nArgument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lround` or `llround` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `round`, `roundf`, and `roundl` function:\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lround` and `llround` families of functions:\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised by `round` when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `round` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lround.html) that all cases where `lround` or `llround` raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nThe `double` version of `round` behaves as if implemented as follows:\n\n```\n#include <math.h>\ndouble round(double x)\n{\n    return signbit(x) ? ceil(x - 0.5) : floor(x + 0.5);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // round\n    printf(\"round(+2.3) = %+.1f  \", round(2.3));\n    printf(\"round(+2.5) = %+.1f  \", round(2.5));\n    printf(\"round(+2.7) = %+.1f\\n\", round(2.7));\n    printf(\"round(-2.3) = %+.1f  \", round(-2.3));\n    printf(\"round(-2.5) = %+.1f  \", round(-2.5));\n    printf(\"round(-2.7) = %+.1f\\n\", round(-2.7));\n \n    printf(\"round(-0.0) = %+.1f\\n\", round(-0.0));\n    printf(\"round(-Inf) = %+f\\n\",   round(-INFINITY));\n \n    // lround\n    printf(\"lround(+2.3) = %ld  \", lround(2.3));\n    printf(\"lround(+2.5) = %ld  \", lround(2.5));\n    printf(\"lround(+2.7) = %ld\\n\", lround(2.7));\n    printf(\"lround(-2.3) = %ld  \", lround(-2.3));\n    printf(\"lround(-2.5) = %ld  \", lround(-2.5));\n    printf(\"lround(-2.7) = %ld\\n\", lround(-2.7));\n \n    printf(\"lround(-0.0) = %ld\\n\", lround(-0.0));\n    printf(\"lround(-Inf) = %ld\\n\", lround(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lround(LONG_MAX+1.5) = %ld\\n\", lround(LONG_MAX+1.5));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nround(+2.3) = +2.0  round(+2.5) = +3.0  round(+2.7) = +3.0\nround(-2.3) = -2.0  round(-2.5) = -3.0  round(-2.7) = -3.0\nround(-0.0) = -0.0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nlround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.6 The round functions (p: 184)\n  - 7.12.9.7 The lround and llround functions (p: 184-185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.6 The round functions (p: 384)\n  - F.10.6.7 The lround and llround functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.6 The round functions (p: 253)\n  - 7.12.9.7 The lround and llround functions (p: 253)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.6 The round functions (p: 527)\n  - F.10.6.7 The lround and llround functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.6 The round functions (p: 233)\n  - 7.12.9.7 The lround and llround functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.6 The round functions (p: 464)\n  - F.9.6.7 The lround and llround functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/round](https://en.cppreference.com/w/c/numeric/math/round)"
- name: lroundf
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned
  description: "# round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n5-7, 9-11) Computes the nearest integer value to `arg` (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `roundl`, `lroundl`, `llroundl` is called. Otherwise, if `arg` has integer type or the type `double`, `round`, `lround`, `llround` is called. Otherwise, `roundf`, `lroundf`, `llroundf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases away from zero, is returned.\n\nReturn value\n\nArgument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lround` or `llround` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `round`, `roundf`, and `roundl` function:\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lround` and `llround` families of functions:\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised by `round` when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `round` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lround.html) that all cases where `lround` or `llround` raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nThe `double` version of `round` behaves as if implemented as follows:\n\n```\n#include <math.h>\ndouble round(double x)\n{\n    return signbit(x) ? ceil(x - 0.5) : floor(x + 0.5);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // round\n    printf(\"round(+2.3) = %+.1f  \", round(2.3));\n    printf(\"round(+2.5) = %+.1f  \", round(2.5));\n    printf(\"round(+2.7) = %+.1f\\n\", round(2.7));\n    printf(\"round(-2.3) = %+.1f  \", round(-2.3));\n    printf(\"round(-2.5) = %+.1f  \", round(-2.5));\n    printf(\"round(-2.7) = %+.1f\\n\", round(-2.7));\n \n    printf(\"round(-0.0) = %+.1f\\n\", round(-0.0));\n    printf(\"round(-Inf) = %+f\\n\",   round(-INFINITY));\n \n    // lround\n    printf(\"lround(+2.3) = %ld  \", lround(2.3));\n    printf(\"lround(+2.5) = %ld  \", lround(2.5));\n    printf(\"lround(+2.7) = %ld\\n\", lround(2.7));\n    printf(\"lround(-2.3) = %ld  \", lround(-2.3));\n    printf(\"lround(-2.5) = %ld  \", lround(-2.5));\n    printf(\"lround(-2.7) = %ld\\n\", lround(-2.7));\n \n    printf(\"lround(-0.0) = %ld\\n\", lround(-0.0));\n    printf(\"lround(-Inf) = %ld\\n\", lround(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lround(LONG_MAX+1.5) = %ld\\n\", lround(LONG_MAX+1.5));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nround(+2.3) = +2.0  round(+2.5) = +3.0  round(+2.7) = +3.0\nround(-2.3) = -2.0  round(-2.5) = -3.0  round(-2.7) = -3.0\nround(-0.0) = -0.0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nlround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.6 The round functions (p: 184)\n  - 7.12.9.7 The lround and llround functions (p: 184-185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.6 The round functions (p: 384)\n  - F.10.6.7 The lround and llround functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.6 The round functions (p: 253)\n  - 7.12.9.7 The lround and llround functions (p: 253)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.6 The round functions (p: 527)\n  - F.10.6.7 The lround and llround functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.6 The round functions (p: 233)\n  - 7.12.9.7 The lround and llround functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.6 The round functions (p: 464)\n  - F.9.6.7 The lround and llround functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/round](https://en.cppreference.com/w/c/numeric/math/round)"
- name: lroundl
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned
  description: "# round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n5-7, 9-11) Computes the nearest integer value to `arg` (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `roundl`, `lroundl`, `llroundl` is called. Otherwise, if `arg` has integer type or the type `double`, `round`, `lround`, `llround` is called. Otherwise, `roundf`, `lroundf`, `llroundf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases away from zero, is returned.\n\nReturn value\n\nArgument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lround` or `llround` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `round`, `roundf`, and `roundl` function:\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lround` and `llround` families of functions:\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised by `round` when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `round` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lround.html) that all cases where `lround` or `llround` raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nThe `double` version of `round` behaves as if implemented as follows:\n\n```\n#include <math.h>\ndouble round(double x)\n{\n    return signbit(x) ? ceil(x - 0.5) : floor(x + 0.5);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // round\n    printf(\"round(+2.3) = %+.1f  \", round(2.3));\n    printf(\"round(+2.5) = %+.1f  \", round(2.5));\n    printf(\"round(+2.7) = %+.1f\\n\", round(2.7));\n    printf(\"round(-2.3) = %+.1f  \", round(-2.3));\n    printf(\"round(-2.5) = %+.1f  \", round(-2.5));\n    printf(\"round(-2.7) = %+.1f\\n\", round(-2.7));\n \n    printf(\"round(-0.0) = %+.1f\\n\", round(-0.0));\n    printf(\"round(-Inf) = %+f\\n\",   round(-INFINITY));\n \n    // lround\n    printf(\"lround(+2.3) = %ld  \", lround(2.3));\n    printf(\"lround(+2.5) = %ld  \", lround(2.5));\n    printf(\"lround(+2.7) = %ld\\n\", lround(2.7));\n    printf(\"lround(-2.3) = %ld  \", lround(-2.3));\n    printf(\"lround(-2.5) = %ld  \", lround(-2.5));\n    printf(\"lround(-2.7) = %ld\\n\", lround(-2.7));\n \n    printf(\"lround(-0.0) = %ld\\n\", lround(-0.0));\n    printf(\"lround(-Inf) = %ld\\n\", lround(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lround(LONG_MAX+1.5) = %ld\\n\", lround(LONG_MAX+1.5));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nround(+2.3) = +2.0  round(+2.5) = +3.0  round(+2.7) = +3.0\nround(-2.3) = -2.0  round(-2.5) = -3.0  round(-2.7) = -3.0\nround(-0.0) = -0.0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nlround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.6 The round functions (p: 184)\n  - 7.12.9.7 The lround and llround functions (p: 184-185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.6 The round functions (p: 384)\n  - F.10.6.7 The lround and llround functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.6 The round functions (p: 253)\n  - 7.12.9.7 The lround and llround functions (p: 253)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.6 The round functions (p: 527)\n  - F.10.6.7 The lround and llround functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.6 The round functions (p: 233)\n  - 7.12.9.7 The lround and llround functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.6 The round functions (p: 464)\n  - F.9.6.7 The lround and llround functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/round](https://en.cppreference.com/w/c/numeric/math/round)"
- name: Main function
  summary: Every C program coded to run in a hosted execution environment contains the definition (not the prototype) of a function named main, which is the designated start of the program
  description: "# Main function\n\nEvery C program coded to run in a hosted execution environment contains the definition (not the prototype) of a function named `main`, which is the designated start of the program.\n\n|                                                              |       |     |\n|--------------------------------------------------------------|-------|-----|\n| int `main` `(void)` `{` body `}`                             | \\(1\\) |     |\n| int `main` `(`int argc`,` char \\*argv\\[\\]`)` `{` body `}`    | \\(2\\) |     |\n| /\\* another implementation-defined signature \\*/ (since C99) | \\(3\\) |     |\n\n### Parameters\n\n|      |     |                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n|------|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| argc | \\-  | Non-negative value representing the number of arguments passed to the program from the environment in which the program is run.                                                                                                                                                                                                                                                                                                            |\n| argv | \\-  | Pointer to the first element of an array of `argc + 1` pointers, of which the last one is null and the previous ones, if any, point to strings that represent the arguments passed to the program from the host environment. If `argv[0]` is not a null pointer (or, equivalently, if `argc` \\> 0), it points to a string that represents the program name, which is empty if the program name is not available from the host environment. |\n\nThe names `argc` and `argv` stand for \"argument count\" and \"argument vector\", and are traditionally used, but other names may be chosen for the parameters, as well as different but equivalent declarations of their type: int main(int ac, char\\*\\* av) is equally valid.\n\nA common implementation-defined form of main is int main(int argc, char \\*argv\\[\\], char \\*envp\\[\\]), where a third argument, of type `char**`, pointing at [an array of pointers to the *execution environment variables*](https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html), is added.\n\n### Return value\n\nIf the return statement is used, the return value is used as the argument to the implicit call to [`exit()`](../program/exit \"c/program/exit\") (see below for details). The values zero and [`EXIT_SUCCESS`](../program/exit_status \"c/program/EXIT status\") indicate successful termination, the value [`EXIT_FAILURE`](../program/exit_status \"c/program/EXIT status\") indicates unsuccessful termination.\n\n### Explanation\n\nThe `main` function is called at program startup, after all objects with static storage duration are initialized. It is the designated entry point to a program that is executed in a *hosted* environment (that is, with an operating system). The name and type of the entry point to any *freestanding* program (boot loaders, OS kernels, etc) are implementation-defined.\n\nThe parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as *command line arguments*). The pointers argv\\[1\\] .. argv\\[argc-1\\] point at the first characters in each of these strings. argv\\[0\\] (if non-null) is the pointer to the initial character of a null-terminated multibyte string that represents the name used to invoke the program itself (or, if this is not supported by the host environment, argv\\[0\\]\\[0\\] is guaranteed to be zero).\n\nIf the host environment cannot supply both lowercase and uppercase letters, the command line arguments are converted to lowercase.\n\nThe strings are modifiable, and any modifications made persist until program termination, although these modifications do not propagate back to the host environment: they can be used, for example, with [`strtok`](../string/byte/strtok \"c/string/byte/strtok\").\n\nThe size of the array pointed to by `argv` is at least `argc+1`, and the last element, `argv[argc]`, is guaranteed to be a null pointer.\n\nThe `main` function has several special properties:\n\n1) A prototype for this function cannot be supplied by the program.\n\n2) If the return type of the main function is [compatible](type#Compatible_types \"c/language/type\") with `int`, then the return from the initial call to main (but not the return from any subsequent, recursive, call) is equivalent to executing the [`exit`](../program/exit \"c/program/exit\") function, with the value that the main function is returning passed as the argument (which then calls the functions registered with [`atexit`](../program/atexit \"c/program/atexit\"), flushes and closes all streams, and deletes the files created with [`tmpfile`](../io/tmpfile \"c/io/tmpfile\"), and returns control to the execution environment).\n\n3)\n\n|                                                                                                                                                                                                                                                                                                                                                                          |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If the main function executes a `return` that specifies no value or, which is the same, reaches the terminating `}` without executing a `return`, the termination status returned to the host environment is undefined.                                                                                                                                                  | (until C99) |\n| If the return type of the main function is not [compatible](type#Compatible_types \"c/language/type\") with `int` (e.g. `void main(void)`), the value returned to the host environment is unspecified. If the return type is compatible with `int` and control reaches the terminating `}`, the value returned to the environment is the same as if executing `return 0;`. | (since C99) |\n\n### Example\n\nDemonstrates how to inform a program about where to find its input and where to write its results. Invocation: ./a.out indatafile outdatafile\n\n```\n#include <stdio.h>\n \nint main(int argc, char *argv[])\n{\n    printf(\"argc = %d\\n\", argc);\n    for (int ndx = 0; ndx != argc; ++ndx)\n        printf(\"argv[%d] --> %s\\n\", ndx, argv[ndx]);\n    printf(\"argv[argc] = %p\\n\", (void*)argv[argc]);\n}\n```\n\nPossible output:\n\n```\nargc = 3\nargv[0] --> ./a.out\nargv[1] --> indatafile\nargv[2] --> outdatafile\nargv[argc] = (nil)\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 5.1.2.2.1 Program startup (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 5.1.2.2.1 Program startup (p: 10-11)\n- C11 standard (ISO/IEC 9899:2011):\n  - 5.1.2.2.1 Program startup (p: 13)\n- C99 standard (ISO/IEC 9899:1999):\n  - 5.1.2.2.1 Program startup (p: 12)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 5.1.2.2 Hosted environment\n\n### See also\n\n|                                                                                                                                |     |\n|--------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/main_function \"cpp/language/main function\") for `main` function |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/main_function](https://en.cppreference.com/w/c/language/main_function)"
- name: malloc
  summary: Allocates size bytes of uninitialized storage
  description: "# malloc\n\n[TABLE]\n\nAllocates `size` bytes of uninitialized storage.\n\nIf allocation succeeds, returns a pointer that is suitably aligned for any object type with [fundamental alignment](../language/object#Alignment \"c/language/object\").\n\nIf `size` is zero, the behavior of `malloc` is implementation-defined. For example, a null pointer may be returned. Alternatively, a non-null pointer may be returned; but such a pointer should not be [dereferenced](../language/operator_member_access \"c/language/operator member access\"), and should be passed to [`free`](free \"c/memory/free\") to avoid memory leaks.\n\n[TABLE]\n\n### Parameters\n\n|      |     |                             |\n|------|-----|-----------------------------|\n| size | \\-  | number of bytes to allocate |\n\n### Return value\n\nOn success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with [`free()`](free \"c/memory/free\") or [`realloc()`](realloc \"c/memory/realloc\").\n\nOn failure, returns a null pointer.\n\n### Example\n\n```\n#include <stdio.h>   \n#include <stdlib.h> \n \nint main(void) \n{\n    int *p1 = malloc(4*sizeof(int));  // allocates enough for an array of 4 int\n    int *p2 = malloc(sizeof(int[4])); // same, naming the type directly\n    int *p3 = malloc(4*sizeof *p3);   // same, without repeating the type name\n \n    if(p1) {\n        for(int n=0; n<4; ++n) // populate the array\n            p1[n] = n*n;\n        for(int n=0; n<4; ++n) // print it back out\n            printf(\"p1[%d] == %d\\n\", n, p1[n]);\n    }\n \n    free(p1);\n    free(p2);\n    free(p3);\n}\n```\n\nOutput:\n\n```\np1[0] == 0\np1[1] == 1\np1[2] == 4\np1[3] == 9\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.3.4 The malloc function (p: 254)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.3.4 The malloc function (p: 349)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.3.3 The malloc function (p: 314)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.3.3 The malloc function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/memory/malloc](https://en.cppreference.com/w/c/memory/malloc)"
- name: MATH_ERREXCEPT
  summary: The macro constant math_errhandling expands to an expression of type int that is either equal to MATH_ERRNO, or equal to MATH_ERREXCEPT, or equal to their bitwise OR (MATH_ERRNO | MATH_ERREXCEPT)
  description: "# MATH_ERRNO, MATH_ERREXCEPT, math_errhandling\n\n[TABLE]\n\nThe macro constant `math_errhandling` expands to an expression of type `int` that is either equal to `MATH_ERRNO`, or equal to `MATH_ERREXCEPT`, or equal to their bitwise OR (`MATH_ERRNO | MATH_ERREXCEPT`).\n\nThe value of `math_errhandling` indicates the type of error handling that is performed by the floating-point operators and [functions](../math \"c/numeric/math\"):\n\n| Constant         | Explanation                                                                                                                                                                                                                                                                                                    |\n|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `MATH_ERREXCEPT` | indicates that floating-point exceptions are used: at least [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\"), [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\"), and [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are defined in `<fenv.h>`. |\n| `MATH_ERRNO`     | indicates that floating-point operations use the variable [`errno`](../../error/errno \"c/error/errno\") to report errors.                                                                                                                                                                                       |\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), `math_errhandling & MATH_ERREXCEPT` is required to be non-zero.\n\nThe following floating-point error conditions are recognized:\n\n| Condition                    | Explanation                                                                                                                                                                        | errno                                                                                             | floating-point exception                                                                                   | Example                                                                                                                      |\n|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------|\n| Domain error                 | the argument is outside the range in which the operation is mathematically defined (the description of [each function](../math \"c/numeric/math\") lists the required domain errors) | [`EDOM`](../../error/errno_macros \"c/error/errno macros\")                                         | [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")                                       | [`acos`](http://en.cppreference.com/w/c/numeric/math/acos)`(``2``)`                                                          |\n| Pole error                   | the mathematical result of the function is exactly infinite or undefined                                                                                                           | [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")                                       | [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")                                     | [`log`](http://en.cppreference.com/w/c/numeric/math/log)`(``0.0``)`, `1.0/0.0`                                               |\n| Range error due to overflow  | the mathematical result is finite, but becomes infinite after rounding, or becomes the largest representable finite value after rounding down                                      | [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")                                       | [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")                                      | [`pow`](http://en.cppreference.com/w/c/numeric/math/pow)`(`[`DBL_MAX`](http://en.cppreference.com/w/c/types/limits)`,``2``)` |\n| Range error due to underflow | the result is non-zero, but becomes zero after rounding, or becomes subnormal with a loss of precision                                                                             | [`ERANGE`](../../error/errno_macros \"c/error/errno macros\") or unchanged (implementation-defined) | [`FE_UNDERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") or nothing (implementation-defined) | `DBL_TRUE_MIN/2`                                                                                                             |\n| Inexact result               | the result has to be rounded to fit in the destination type                                                                                                                        | unchanged                                                                                         | [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") or nothing (unspecified)              | [`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt)`(``2``)`, `1.0/10.0`                                              |\n\n### Notes\n\nWhether [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. [`rint`](rint \"c/numeric/math/rint\") vs [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\")).\n\nBefore C99, floating-point exceptions were not specified, [`EDOM`](http://en.cppreference.com/w/c/error/errno_macros) was required for any domain error, [`ERANGE`](http://en.cppreference.com/w/c/error/errno_macros) was required for overflows and implementation-defined for underflows.\n\n### Example\n\n```\n#include <stdio.h>\n#include <fenv.h>\n#include <math.h>\n#include <errno.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"MATH_ERRNO is %s\\n\", math_errhandling & MATH_ERRNO ? \"set\" : \"not set\");\n    printf(\"MATH_ERREXCEPT is %s\\n\",\n           math_errhandling & MATH_ERREXCEPT ? \"set\" : \"not set\");\n    feclearexcept(FE_ALL_EXCEPT);\n    errno = 0;\n    printf(\"log(0) = %f\\n\", log(0));\n    if(errno == ERANGE)\n        perror(\"errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO))\n        puts(\"FE_DIVBYZERO (pole error) reported\");\n}\n```\n\nPossible output:\n\n```\nMATH_ERRNO is set\nMATH_ERREXCEPT is set\nlog(0) = -inf\nerrno = ERANGE: Numerical result out of range\nFE_DIVBYZERO (pole error) reported\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/9 MATH_ERRNO, MATH_ERREXCEPT, math_errhandling (p: 170)\n  - F.10/4 MATH_ERREXCEPT, math_errhandling (p: 377)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/9 MATH_ERRNO, MATH_ERREXCEPT, math_errhandling (p: 233)\n  - F.10/4 MATH_ERREXCEPT, math_errhandling (p: 517)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/9 MATH_ERRNO, MATH_ERREXCEPT, math_errhandling (p: 214)\n  - F.9/4 MATH_ERREXCEPT, math_errhandling\\> (p: 454)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/math_errhandling](https://en.cppreference.com/w/c/numeric/math/math_errhandling)"
- name: math_errhandling
  summary: The macro constant math_errhandling expands to an expression of type int that is either equal to MATH_ERRNO, or equal to MATH_ERREXCEPT, or equal to their bitwise OR (MATH_ERRNO | MATH_ERREXCEPT)
  description: "# MATH_ERRNO, MATH_ERREXCEPT, math_errhandling\n\n[TABLE]\n\nThe macro constant `math_errhandling` expands to an expression of type `int` that is either equal to `MATH_ERRNO`, or equal to `MATH_ERREXCEPT`, or equal to their bitwise OR (`MATH_ERRNO | MATH_ERREXCEPT`).\n\nThe value of `math_errhandling` indicates the type of error handling that is performed by the floating-point operators and [functions](../math \"c/numeric/math\"):\n\n| Constant         | Explanation                                                                                                                                                                                                                                                                                                    |\n|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `MATH_ERREXCEPT` | indicates that floating-point exceptions are used: at least [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\"), [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\"), and [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are defined in `<fenv.h>`. |\n| `MATH_ERRNO`     | indicates that floating-point operations use the variable [`errno`](../../error/errno \"c/error/errno\") to report errors.                                                                                                                                                                                       |\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), `math_errhandling & MATH_ERREXCEPT` is required to be non-zero.\n\nThe following floating-point error conditions are recognized:\n\n| Condition                    | Explanation                                                                                                                                                                        | errno                                                                                             | floating-point exception                                                                                   | Example                                                                                                                      |\n|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------|\n| Domain error                 | the argument is outside the range in which the operation is mathematically defined (the description of [each function](../math \"c/numeric/math\") lists the required domain errors) | [`EDOM`](../../error/errno_macros \"c/error/errno macros\")                                         | [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")                                       | [`acos`](http://en.cppreference.com/w/c/numeric/math/acos)`(``2``)`                                                          |\n| Pole error                   | the mathematical result of the function is exactly infinite or undefined                                                                                                           | [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")                                       | [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")                                     | [`log`](http://en.cppreference.com/w/c/numeric/math/log)`(``0.0``)`, `1.0/0.0`                                               |\n| Range error due to overflow  | the mathematical result is finite, but becomes infinite after rounding, or becomes the largest representable finite value after rounding down                                      | [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")                                       | [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")                                      | [`pow`](http://en.cppreference.com/w/c/numeric/math/pow)`(`[`DBL_MAX`](http://en.cppreference.com/w/c/types/limits)`,``2``)` |\n| Range error due to underflow | the result is non-zero, but becomes zero after rounding, or becomes subnormal with a loss of precision                                                                             | [`ERANGE`](../../error/errno_macros \"c/error/errno macros\") or unchanged (implementation-defined) | [`FE_UNDERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") or nothing (implementation-defined) | `DBL_TRUE_MIN/2`                                                                                                             |\n| Inexact result               | the result has to be rounded to fit in the destination type                                                                                                                        | unchanged                                                                                         | [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") or nothing (unspecified)              | [`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt)`(``2``)`, `1.0/10.0`                                              |\n\n### Notes\n\nWhether [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. [`rint`](rint \"c/numeric/math/rint\") vs [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\")).\n\nBefore C99, floating-point exceptions were not specified, [`EDOM`](http://en.cppreference.com/w/c/error/errno_macros) was required for any domain error, [`ERANGE`](http://en.cppreference.com/w/c/error/errno_macros) was required for overflows and implementation-defined for underflows.\n\n### Example\n\n```\n#include <stdio.h>\n#include <fenv.h>\n#include <math.h>\n#include <errno.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"MATH_ERRNO is %s\\n\", math_errhandling & MATH_ERRNO ? \"set\" : \"not set\");\n    printf(\"MATH_ERREXCEPT is %s\\n\",\n           math_errhandling & MATH_ERREXCEPT ? \"set\" : \"not set\");\n    feclearexcept(FE_ALL_EXCEPT);\n    errno = 0;\n    printf(\"log(0) = %f\\n\", log(0));\n    if(errno == ERANGE)\n        perror(\"errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO))\n        puts(\"FE_DIVBYZERO (pole error) reported\");\n}\n```\n\nPossible output:\n\n```\nMATH_ERRNO is set\nMATH_ERREXCEPT is set\nlog(0) = -inf\nerrno = ERANGE: Numerical result out of range\nFE_DIVBYZERO (pole error) reported\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/9 MATH_ERRNO, MATH_ERREXCEPT, math_errhandling (p: 170)\n  - F.10/4 MATH_ERREXCEPT, math_errhandling (p: 377)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/9 MATH_ERRNO, MATH_ERREXCEPT, math_errhandling (p: 233)\n  - F.10/4 MATH_ERREXCEPT, math_errhandling (p: 517)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/9 MATH_ERRNO, MATH_ERREXCEPT, math_errhandling (p: 214)\n  - F.9/4 MATH_ERREXCEPT, math_errhandling\\> (p: 454)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/math_errhandling](https://en.cppreference.com/w/c/numeric/math/math_errhandling)"
- name: MATH_ERRNO
  summary: The macro constant math_errhandling expands to an expression of type int that is either equal to MATH_ERRNO, or equal to MATH_ERREXCEPT, or equal to their bitwise OR (MATH_ERRNO | MATH_ERREXCEPT)
  description: "# MATH_ERRNO, MATH_ERREXCEPT, math_errhandling\n\n[TABLE]\n\nThe macro constant `math_errhandling` expands to an expression of type `int` that is either equal to `MATH_ERRNO`, or equal to `MATH_ERREXCEPT`, or equal to their bitwise OR (`MATH_ERRNO | MATH_ERREXCEPT`).\n\nThe value of `math_errhandling` indicates the type of error handling that is performed by the floating-point operators and [functions](../math \"c/numeric/math\"):\n\n| Constant         | Explanation                                                                                                                                                                                                                                                                                                    |\n|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `MATH_ERREXCEPT` | indicates that floating-point exceptions are used: at least [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\"), [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\"), and [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are defined in `<fenv.h>`. |\n| `MATH_ERRNO`     | indicates that floating-point operations use the variable [`errno`](../../error/errno \"c/error/errno\") to report errors.                                                                                                                                                                                       |\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), `math_errhandling & MATH_ERREXCEPT` is required to be non-zero.\n\nThe following floating-point error conditions are recognized:\n\n| Condition                    | Explanation                                                                                                                                                                        | errno                                                                                             | floating-point exception                                                                                   | Example                                                                                                                      |\n|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------|\n| Domain error                 | the argument is outside the range in which the operation is mathematically defined (the description of [each function](../math \"c/numeric/math\") lists the required domain errors) | [`EDOM`](../../error/errno_macros \"c/error/errno macros\")                                         | [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")                                       | [`acos`](http://en.cppreference.com/w/c/numeric/math/acos)`(``2``)`                                                          |\n| Pole error                   | the mathematical result of the function is exactly infinite or undefined                                                                                                           | [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")                                       | [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")                                     | [`log`](http://en.cppreference.com/w/c/numeric/math/log)`(``0.0``)`, `1.0/0.0`                                               |\n| Range error due to overflow  | the mathematical result is finite, but becomes infinite after rounding, or becomes the largest representable finite value after rounding down                                      | [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")                                       | [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")                                      | [`pow`](http://en.cppreference.com/w/c/numeric/math/pow)`(`[`DBL_MAX`](http://en.cppreference.com/w/c/types/limits)`,``2``)` |\n| Range error due to underflow | the result is non-zero, but becomes zero after rounding, or becomes subnormal with a loss of precision                                                                             | [`ERANGE`](../../error/errno_macros \"c/error/errno macros\") or unchanged (implementation-defined) | [`FE_UNDERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") or nothing (implementation-defined) | `DBL_TRUE_MIN/2`                                                                                                             |\n| Inexact result               | the result has to be rounded to fit in the destination type                                                                                                                        | unchanged                                                                                         | [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") or nothing (unspecified)              | [`sqrt`](http://en.cppreference.com/w/c/numeric/math/sqrt)`(``2``)`, `1.0/10.0`                                              |\n\n### Notes\n\nWhether [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. [`rint`](rint \"c/numeric/math/rint\") vs [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\")).\n\nBefore C99, floating-point exceptions were not specified, [`EDOM`](http://en.cppreference.com/w/c/error/errno_macros) was required for any domain error, [`ERANGE`](http://en.cppreference.com/w/c/error/errno_macros) was required for overflows and implementation-defined for underflows.\n\n### Example\n\n```\n#include <stdio.h>\n#include <fenv.h>\n#include <math.h>\n#include <errno.h>\n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"MATH_ERRNO is %s\\n\", math_errhandling & MATH_ERRNO ? \"set\" : \"not set\");\n    printf(\"MATH_ERREXCEPT is %s\\n\",\n           math_errhandling & MATH_ERREXCEPT ? \"set\" : \"not set\");\n    feclearexcept(FE_ALL_EXCEPT);\n    errno = 0;\n    printf(\"log(0) = %f\\n\", log(0));\n    if(errno == ERANGE)\n        perror(\"errno == ERANGE\");\n    if(fetestexcept(FE_DIVBYZERO))\n        puts(\"FE_DIVBYZERO (pole error) reported\");\n}\n```\n\nPossible output:\n\n```\nMATH_ERRNO is set\nMATH_ERREXCEPT is set\nlog(0) = -inf\nerrno = ERANGE: Numerical result out of range\nFE_DIVBYZERO (pole error) reported\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12/9 MATH_ERRNO, MATH_ERREXCEPT, math_errhandling (p: 170)\n  - F.10/4 MATH_ERREXCEPT, math_errhandling (p: 377)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12/9 MATH_ERRNO, MATH_ERREXCEPT, math_errhandling (p: 233)\n  - F.10/4 MATH_ERREXCEPT, math_errhandling (p: 517)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12/9 MATH_ERRNO, MATH_ERREXCEPT, math_errhandling (p: 214)\n  - F.9/4 MATH_ERREXCEPT, math_errhandling\\> (p: 454)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/math_errhandling](https://en.cppreference.com/w/c/numeric/math/math_errhandling)"
- name: max_align_t
  summary: max_align_t is a type whose alignment requirement is at least as strict (as large) as that of every scalar type
  description: "# max_align_t\n\n[TABLE]\n\n`max_align_t` is a type whose alignment requirement is at least as strict (as large) as that of every scalar type.\n\n### Notes\n\nPointers returned by allocation functions such as [`malloc`](../memory/malloc \"c/memory/malloc\") are suitably aligned for any object, which means they are aligned at least as strictly as `max_align_t`.\n\n`max_align_t` is usually synonymous with the largest scalar type, which is `long double` on most platforms, and its alignment requirement is either 8 or 16.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stddef.h>\n#include <stdalign.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <inttypes.h>\n \nint main(void)\n{\n    size_t a = alignof(max_align_t);\n    printf(\"Alignment of max_align_t is %zu (%#zx)\\n\", a, a);\n \n    void *p = malloc(123);\n    printf(\"The address obtained from malloc(123) is %#\" PRIxPTR\"\\n\",\n            (uintptr_t)p);\n    free(p);\n}\n```\n\nPossible output:\n\n```\nAlignment of max_align_t is 16 (0x10)\nThe address obtained from malloc(123) is 0x1fa67010\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.19 Common definitions \\<stddef.h\\> (p: 211)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.19 Common definitions \\<stddef.h\\> (p: 288)\n\n### See also\n\n|                                                                                                                    |     |\n|--------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/types/max_align_t \"cpp/types/max align t\") for `max_align_t` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types/max_align_t](https://en.cppreference.com/w/c/types/max_align_t)"
- name: mblen
  summary: Determines the size, in bytes, of the multibyte character whose first byte is pointed to by s
  description: "# mblen\n\n[TABLE]\n\nDetermines the size, in bytes, of the multibyte character whose first byte is pointed to by `s`.\n\nIf `s` is a null pointer, resets the global conversion state and(until C23) determined whether shift sequences are used.\n\nThis function is equivalent to the call [`mbtowc`](http://en.cppreference.com/w/c/string/multibyte/mbtowc)`(``(``wchar_t``*``)``0``, s, n``)`, except that conversion state of [`mbtowc`](mbtowc \"c/string/multibyte/mbtowc\") is unaffected.\n\n### Parameters\n\n|     |     |                                                        |\n|-----|-----|--------------------------------------------------------|\n| s   | \\-  | pointer to the multibyte character                     |\n| n   | \\-  | limit on the number of bytes in s that can be examined |\n\n### Return value\n\nIf `s` is not a null pointer, returns the number of bytes that are contained in the multibyte character or `-1` if the first bytes pointed to by `s` do not form a valid multibyte character or `​0​` if `s` is pointing at the null charcter `'\\0'`.\n\nIf `s` is a null pointer, resets its internal conversion state to represent the initial shift state and(until C23) returns `​0​` if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).\n\n### Notes\n\n|                                                                                                                                                                                                                                                                                                                                                                                                                                               |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Each call to `mblen` updates the internal global conversion state (a static object of type [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\"), only known to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call `mblen` without synchronization: [`mbrlen`](mbrlen \"c/string/multibyte/mbrlen\") may be used instead. | (until C23) |\n| `mblen` is not allowed to have an internal state.                                                                                                                                                                                                                                                                                                                                                                                             | (since C23) |\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n// the number of characters in a multibyte string is the sum of mblen()'s\n// note: the simpler approach is mbstowcs(NULL, str, sz)\nsize_t strlen_mb(const char* ptr)\n{\n    size_t result = 0;\n    const char* end = ptr + strlen(ptr);\n    mblen(NULL, 0); // reset the conversion state\n    while(ptr < end) {\n        int next = mblen(ptr, end - ptr);\n        if (next == -1) {\n           perror(\"strlen_mb\");\n           break;\n        }\n        ptr += next;\n        ++result;\n    }\n    return result;\n}\n \nvoid dump_bytes(const char* str)\n{\n    for (const char* end = str + strlen(str); str != end; ++str)\n        printf(\"%02X \", (unsigned char)str[0]);\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char* str = \"z\\u00df\\u6c34\\U0001f34c\";\n    printf(\"The string \\\"%s\\\" consists of %zu characters, but %zu bytes: \",\n            str, strlen_mb(str), strlen(str));\n    dump_bytes(str);\n}\n```\n\nPossible output:\n\n```\nThe string \"zß水🍌\" consists of 4 characters, but 10 bytes: 7A C3 9F E6 B0 B4 F0 9F 8D 8C\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.7.1 The mblen function (p: 260)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.7.1 The mblen function (p: 357)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.7.1 The mblen function (p: 321)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.7.1 The mblen function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mblen](https://en.cppreference.com/w/c/string/multibyte/mblen)"
- name: mbrlen
  summary: Determines the size, in bytes, of the representation of a multibyte character
  description: "# mbrlen\n\n[TABLE]\n\nDetermines the size, in bytes, of the representation of a multibyte character.\n\nThis function is equivalent to the call [`mbrtowc`](http://en.cppreference.com/w/c/string/multibyte/mbrtowc)`(`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`, s, n, ps``?``ps``:``&``internal``)` for some hidden object `internal` of type [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\"), except that the expression `ps` is evaluated only once.\n\n### Parameters\n\n|     |     |                                                        |\n|-----|-----|--------------------------------------------------------|\n| s   | \\-  | pointer to an element of a multibyte character string  |\n| n   | \\-  | limit on the number of bytes in s that can be examined |\n| ps  | \\-  | pointer to the variable holding the conversion state   |\n\n### Return value\n\nThe first of the following that applies:\n\n- `​0​` if the next `n` or fewer bytes complete the null character or if `s` is a null pointer. Both cases reset the conversion state.\n- the number of bytes `[1...n]` that complete a valid multibyte character\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``2` if the next `n` bytes are part of a possibly valid multibyte character, which is still incomplete after examining all `n` bytes\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` if encoding error occurs. The value of [`errno`](../../error/errno \"c/error/errno\") is `EILSEQ`; the conversion state is unspecified.\n\n### Example\n\n```\n#include <locale.h>\n#include <string.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{   \n    // allow mbrlen() to work with UTF-8 multibyte encoding\n    setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    const char* str = u8\"水\";\n    size_t sz = strlen(str);\n \n    mbstate_t mb;\n    memset(&mb, 0, sizeof mb);\n    int len1 = mbrlen(str, 1, &mb);\n    if(len1 == -2) \n        printf(\"The first 1 byte of %s is an incomplete multibyte char\"\n               \" (mbrlen returns -2)\\n\", str);\n \n    int len2 = mbrlen(str+1, sz-1, &mb);\n    printf(\"The remaining %zu  bytes of %s hold %d bytes of the multibyte\"\n           \" character\\n\", sz-1, str, len2);\n \n    printf(\"Attempting to call mbrlen() in the middle of %s while in initial\"\n           \" shift state returns %zd\\n\", str, mbrlen(str+1, sz-1, &mb));\n}\n```\n\nOutput:\n\n```\nThe first 1 byte of 水 is an incomplete multibyte char (mbrlen returns -2)\nThe remaining 2  bytes of 水 hold 2 bytes of the multibyte character\nAttempting to call mbrlen() in the middle of 水 while in initial shift state returns -1\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.3.1 The mbrlen function (p: 442)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.3.1 The mbrlen function (p: 388)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbrlen](https://en.cppreference.com/w/c/string/multibyte/mbrlen)"
- name: mbrtoc16
  summary: Converts a single code point from its narrow multibyte character representation to its variable-length 16-bit wide character representation (typically, UTF-16)
  description: "# mbrtoc16\n\n[TABLE]\n\nConverts a single code point from its narrow multibyte character representation to its variable-length 16-bit wide character representation (typically, UTF-16).\n\nIf `s` is not a null pointer, inspects at most `n` bytes of the multibyte character string, beginning with the byte pointed to by `s` to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state `*ps`). If the function determines that the next multibyte character in `s` is complete and valid, converts it to the corresponding 16-bit wide character and stores it in `*pc16` (if `pc16` is not null).\n\nIf the multibyte character in `*s` corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, `*ps` is updated in such a way that the next call to `mbrtoc16` will write out the additional `char16_t`, without considering `*s`.\n\nIf `s` is a null pointer, the values of `n` and `pc16` are ignored and the call is equivalent to `mbrtoc16``(`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`, ``\"\"``, ``1``, ps``)`.\n\nIf the wide character produced is the null character, the conversion state `*ps` represents the initial shift state.\n\nIf the macro `__STDC_UTF_16__` is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. The macro is always defined and the encoding is always UTF-16.(since C23) In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\n### Parameters\n\n|      |     |                                                                                    |\n|------|-----|------------------------------------------------------------------------------------|\n| pc16 | \\-  | pointer to the location where the resulting 16-bit wide character will be written  |\n| s    | \\-  | pointer to the multibyte character string used as input                            |\n| n    | \\-  | limit on the number of bytes in s that can be examined                             |\n| ps   | \\-  | pointer to the conversion state object used when interpreting the multibyte string |\n\n### Return value\n\nThe first of the following that applies:\n\n- `​0​` if the character converted from `s` (and stored in `*pc16` if non-null) was the null character\n- the number of bytes `[1...n]` of the multibyte character successfully converted from `s`\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``3` if the next `char16_t` from a multi-`char16_t` character (e.g. a surrogate pair) has now been written to `*pc16`. No bytes are processed from the input in this case.\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``2` if the next `n` bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to `*pc16`.\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` if encoding error occurs. Nothing is written to `*pc16`, the value [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") is stored in [`errno`](../../error/errno \"c/error/errno\") and the value of `*ps` is unspecified.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <uchar.h>\n \nmbstate_t state;\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char in[] = u8\"zß水🍌\"; // or \"z\\u00df\\u6c34\\U0001F34C\"\n    const size_t in_sz = sizeof in / sizeof *in;\n \n    printf(\"Processing %zu UTF-8 code units: [ \", in_sz);\n    for (size_t n = 0; n < in_sz; ++n)\n        printf(\"%#x \", (unsigned char)in[n]);\n    puts(\"]\");\n \n    char16_t out[in_sz];\n    const char *p_in = in, *end = in + in_sz;\n    char16_t *p_out = out;\n    for (size_t rc; (rc = mbrtoc16(p_out, p_in, end - p_in, &state));)\n    {\n        if (rc == (size_t)-1)     // invalid input\n            break;\n        else if(rc == (size_t)-2) // truncated input\n            break;\n        else if(rc == (size_t)-3) // UTF-16 high surrogate\n            p_out += 1;\n        else\n        {\n            p_in += rc;\n            p_out += 1;\n        };\n    }\n \n    const size_t out_sz = p_out - out + 1;\n    printf(\"into %zu UTF-16 code units: [ \", out_sz);\n    for (size_t x = 0; x < out_sz; ++x)\n        printf(\"%#x \", out[x]);\n    puts(\"]\");\n}\n```\n\nOutput:\n\n```\nProcessing 11 UTF-8 code units: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c 0 ]\ninto 6 UTF-16 code units: [ 0x7a 0xdf 0x6c34 0xd83c 0xdf4c 0 ]\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.1.3 The mbrtoc16 function (p: 408-409)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.28.1.1 The mbrtoc16 function (p: 398-399)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbrtoc16](https://en.cppreference.com/w/c/string/multibyte/mbrtoc16)"
- name: mbrtoc32
  summary: Converts a single code point from its narrow multibyte character representation to its variable-length 32-bit wide character representation (but typically, UTF-32)
  description: "# mbrtoc32\n\n[TABLE]\n\nConverts a single code point from its narrow multibyte character representation to its variable-length 32-bit wide character representation (but typically, UTF-32).\n\nIf `s` is not a null pointer, inspects at most `n` bytes of the multibyte character string, beginning with the byte pointed to by `s` to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state `*ps`). If the function determines that the next multibyte character in `s` is complete and valid, converts it to the corresponding 32-bit wide character and stores it in `*pc32` (if `pc32` is not null).\n\nIf the multibyte character in `*s` corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, `*ps` is updated in such a way that the next calls to `mbrtoc32` will write out the additional char32_t, without considering `*s`.\n\nIf `s` is a null pointer, the values of `n` and `pc32` are ignored and the call is equivalent to `mbrtoc32``(`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`, ``\"\"``, ``1``, ps``)`.\n\nIf the wide character produced is the null character, the conversion state `*ps` represents the initial shift state.\n\nIf the macro `__STDC_UTF_32__` is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. The macro is always defined and the encoding is always UTF-32.(since C23) In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\n### Parameters\n\n|      |     |                                                                                    |\n|------|-----|------------------------------------------------------------------------------------|\n| pc32 | \\-  | pointer to the location where the resulting 32-bit wide character will be written  |\n| s    | \\-  | pointer to the multibyte character string used as input                            |\n| n    | \\-  | limit on the number of bytes in s that can be examined                             |\n| ps   | \\-  | pointer to the conversion state object used when interpreting the multibyte string |\n\n### Return value\n\nThe first of the following that applies:\n\n- `​0​` if the character converted from `s` (and stored in `*pc32` if non-null) was the null character\n- the number of bytes `[1...n]` of the multibyte character successfully converted from `s`\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``3` if the next `char32_t` from a multi-`char32_t` character has now been written to `*pc32`. No bytes are processed from the input in this case.\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``2` if the next `n` bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to `*pc32`.\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` if encoding error occurs. Nothing is written to `*pc32`, the value [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") is stored in [`errno`](../../error/errno \"c/error/errno\") and the value of `*ps` is unspecified.\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <string.h>\n#include <uchar.h>\n#include <assert.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    char in[] = u8\"zß水🍌\"; // or \"z\\u00df\\u6c34\\U0001F34C\"\n    const size_t in_size = sizeof in / sizeof *in;\n \n    printf(\"Processing %zu UTF-8 code units: [ \", in_size);\n    for (size_t i = 0; i < in_size; ++i)\n        printf(\"0x%02x \", (unsigned char)in[i]);\n \n    puts(\"]\");\n \n    char32_t out[in_size];\n    char32_t *p_out = out;\n    char *p_in = in, *end = in + in_size;\n    mbstate_t state;\n    memset(&state, 0, sizeof(state));\n    size_t rc;\n    while ((rc = mbrtoc32(p_out, p_in, end - p_in, &state)))\n    {\n        assert(rc != (size_t)-3); // no surrogate pairs in UTF-32\n        if (rc == (size_t)-1) break; // invalid input\n        if (rc == (size_t)-2) break; // truncated input\n        p_in += rc;\n        ++p_out;\n    }\n \n    size_t out_size = p_out+1 - out;\n    printf(\"into %zu UTF-32 code units: [ \", out_size);\n    for (size_t i = 0; i < out_size; ++i)\n        printf(\"0x%08X \", out[i]);\n \n    puts(\"]\");\n}\n```\n\nOutput:\n\n```\nProcessing 11 UTF-8 code units: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c 0x00 ]\ninto 5 UTF-32 code units: [ 0x0000007A 0x000000DF 0x00006C34 0x0001F34C 0x00000000 ]\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.1.5 The mbrtoc32 function (p: 410)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.28.1.3 The mbrtoc32 function (p: 293-294)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.28.1.3 The mbrtoc32 function (p: 400-401)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbrtoc32](https://en.cppreference.com/w/c/string/multibyte/mbrtoc32)"
- name: mbrtoc8
  summary: Converts a narrow multibyte character to UTF-8 encoding
  description: "# mbrtoc8\n\n[TABLE]\n\nConverts a narrow multibyte character to UTF-8 encoding.\n\nIf `s` is not a null pointer, inspects at most `n` bytes of the multibyte character string, beginning with the byte pointed to by `s` to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in `s` is complete and valid, converts it to UTF-8 and stores the first UTF-8 code unit in `*pc8` (if `pc8` is not null).\n\nIf UTF-8 encoding of the multibyte character in `*s` consists of more than one UTF-8 code unit, then after the first call to this function, `*ps` is updated in such a way that the next call to `mbrtoc8` will write out the additional UTF-8 code units, without considering `*s`.\n\nIf `s` is a null pointer, the values of `n` and `pc8` are ignored and the call is equivalent to `mbrtoc8(nullptr, \"\", 1, ps)`.\n\nIf UTF-8 code unit produced is `u8'\\0'`, the conversion state `*ps` represents the initial shift state.\n\nThe multibyte encoding used by this function is specified by the currently active C locale.\n\n### Parameters\n\n|     |     |                                                                                    |\n|-----|-----|------------------------------------------------------------------------------------|\n| pc8 | \\-  | pointer to the location where the resulting UTF-8 code units will be written       |\n| s   | \\-  | pointer to the multibyte character string used as input                            |\n| n   | \\-  | limit on the number of bytes in s that can be examined                             |\n| ps  | \\-  | pointer to the conversion state object used when interpreting the multibyte string |\n\n### Return value\n\nThe first of the following that applies:\n\n- `​0​` if the character converted from `s` (and stored in `*pc8` if non-null) was the null character\n- the number of bytes `[1...n]` of the multibyte character successfully converted from `s`\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``3` if the next UTF-8 code unit from a character whose encoding consists of multiple code units has now been written to `*pc8`. No bytes are processed from the input in this case.\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``2` if the next `n` bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to `*pc8`.\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` if encoding error occurs. Nothing is written to `*pc8`, the value [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") is stored in [`errno`](../../error/errno \"c/error/errno\") and the value of `*ps` is unspecified.\n\n### Example\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbrtoc8](https://en.cppreference.com/w/c/string/multibyte/mbrtoc8)"
- name: mbrtowc
  summary: Converts a narrow multibyte character to its wide character representation
  description: "# mbrtowc\n\n[TABLE]\n\nConverts a narrow multibyte character to its wide character representation.\n\nIf `s` is not a null pointer, inspects at most `n` bytes of the multibyte character string, beginning with the byte pointed to by `s` to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state `*ps`). If the function determines that the next multibyte character in `s` is complete and valid, converts it to the corresponding wide character and stores it in `*pwc` (if `pwc` is not null).\n\nIf `s` is a null pointer, the values of `n` and `pwc` are ignored and call is equivalent to `mbrtowc``(`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`, ``\"\"``, ``1``, ps``)`.\n\nIf the wide character produced is the null character, the conversion state stored in `*ps` is the initial shift state.\n\nIf the environment macro `__STDC_ISO_10646__` is defined, the values of type `wchar_t` are the same as the short identifiers of the characters in the Unicode required set (typically UTF-32 encoding); otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\n### Parameters\n\n|     |     |                                                                                       |\n|-----|-----|---------------------------------------------------------------------------------------|\n| pwc | \\-  | pointer to the location where the resulting wide character will be written            |\n| s   | \\-  | pointer to the multibyte character string used as input                               |\n| n   | \\-  | limit on the number of bytes in s that can be examined                                |\n| ps  | \\-  | pointer to the conversion state used when interpreting the multibyte character string |\n\n### Return value\n\nThe first of the following that applies:\n\n- `​0​` if the character converted from `s` (and stored in `pwc` if non-null) was the null character\n- the number of bytes `[1...n]` of the multibyte character successfully converted from `s`\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``2` if the next `n` bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to `*pwc`.\n- `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` if encoding error occurs. Nothing is written to `*pwc`, the value [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") is stored in [`errno`](../../error/errno \"c/error/errno\") and the value of `*ps` is left unspecified.\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    mbstate_t state;\n    memset(&state, 0, sizeof state);\n    char in[] = u8\"z\\u00df\\u6c34\\U0001F34C\"; // or u8\"zß水🍌\"\n    size_t in_sz = sizeof in / sizeof *in;\n \n    printf(\"Processing %zu UTF-8 code units: [ \", in_sz);\n    for(size_t n = 0; n < in_sz; ++n) printf(\"%#x \", (unsigned char)in[n]);\n    puts(\"]\");\n \n    wchar_t out[in_sz];\n    char *p_in = in, *end = in + in_sz;\n    wchar_t *p_out = out;\n    int rc;\n    while((rc = mbrtowc(p_out, p_in, end - p_in, &state)) > 0)\n    {\n        p_in += rc;\n        p_out += 1;\n    }\n \n    size_t out_sz = p_out - out + 1;\n    printf(\"into %zu wchar_t units: [ \", out_sz);\n    for(size_t x = 0; x < out_sz; ++x) printf(\"%#x \", out[x]);\n    puts(\"]\");\n}\n```\n\nOutput:\n\n```\nProcessing 11 UTF-8 code units: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c 0 ]\ninto 5 wchar_t units: [ 0x7a 0xdf 0x6c34 0x1f34c 0 ]\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.3.2 The mbrtowc function (p: 443)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.3.2 The mbrtowc function (p: 389)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbrtowc](https://en.cppreference.com/w/c/string/multibyte/mbrtowc)"
- name: mbsinit
  summary: If ps is not a null pointer, the mbsinit function determines whether the pointed-to mbstate_t object describes the initial conversion state
  description: "# mbsinit\n\n[TABLE]\n\nIf `ps` is not a null pointer, the `mbsinit` function determines whether the pointed-to [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\") object describes the initial conversion state.\n\n### Notes\n\nAlthough a zero-initialized [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\") always represents the initial conversion state, there may be other values of [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\") that also represent the initial conversion state.\n\n### Parameters\n\n|     |     |                                            |\n|-----|-----|--------------------------------------------|\n| ps  | \\-  | pointer to the mbstate_t object to examine |\n\n### Return value\n\n`​0​` if `ps` is not a null pointer and does not represent the initial conversion state, nonzero value otherwise.\n\n### Example\n\n```\n#include <locale.h>\n#include <string.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    // allow mbrlen() to work with UTF-8 multibyte encoding\n    setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    const char* str = u8\"水\"; // or u8\"\\u6c34\" or \"\\xe6\\xb0\\xb4\"\n    static mbstate_t mb; // zero-initialize\n    (void)mbrlen(&str[0], 1, &mb);\n    if (!mbsinit(&mb)) {\n        printf(\"After processing the first 1 byte of %s,\\n\"\n               \"the conversion state is not initial\\n\\n\", str);\n    }\n \n    (void)mbrlen(&str[1], strlen(str), &mb);\n    if (mbsinit(&mb)) {\n        printf(\"After processing the remaining 2 bytes of %s,\\n\"\n               \"the conversion state is initial conversion state\\n\", str);\n    }\n}\n```\n\nOutput:\n\n```\nAfter processing the first 1 byte of 水,\nthe conversion state is not initial\n \nAfter processing the remaining 2 bytes of 水,\nthe conversion state is initial conversion state\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.6.2.1 The mbsinit function (p: 322)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.2.1 The mbsinit function (p: 441-442)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.2.1 The mbsinit function (p: 387-388)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbsinit](https://en.cppreference.com/w/c/string/multibyte/mbsinit)"
- name: mbsrtowcs
  summary: 'Output:'
  description: "# mbsrtowcs, mbsrtowcs_s\n\n[TABLE]\n\n1) Converts a null-terminated multibyte character sequence, which begins in the conversion state described by `*ps`, from the array whose first element is pointed to by `*src` to its wide character representation. If `dst` is not null, converted characters are stored in the successive elements of the wchar_t array pointed to by `dst`. No more than `len` wide characters are written to the destination array. Each multibyte character is converted as if by a call to [`mbrtowc`](mbrtowc \"c/string/multibyte/mbrtowc\"). The conversion stops if:\n\n- The multibyte null character was converted and stored. `*src` is set to null pointer value and `*ps` represents the initial shift state.\n- An invalid multibyte character (according to the current C locale) was encountered. `*src` is set to point at the beginning of the first unconverted multibyte character.\n- the next wide character to be stored would exceed `len`. `*src` is set to point at the beginning of the first unconverted multibyte character. This condition is not checked if `dst` is a null pointer.\n\n2) Same as (1), except that\n\n- the function returns its result as an out-parameter `retval`\n- if no null character was written to `dst` after `len` wide characters were written, then `L'\\0'` is stored in `dst[len]`, which means len+1 total wide characters are written\n- the function clobbers the destination array from the terminating null and until `dstsz`\n- If `src` and `dst` overlap, the behavior is unspecified.\n- the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n&nbsp;\n\n- `retval`, `ps`, `src`, or `*src` is a null pointer\n- `dstsz` or `len` is greater than `RSIZE_MAX/sizeof(wchar_t)` (unless `dst` is null)\n- `dstsz` is not zero (unless `dst` is null)\n- There is no null character in the first `dstsz` multibyte characters in the `*src` array and `len` is greater than `dstsz` (unless `dst` is null)\n\nAs with all bounds-checked functions, `mbsrtowcs_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                               |\n|--------|-----|-------------------------------------------------------------------------------|\n| dst    | \\-  | pointer to wide character array where the results will be stored              |\n| src    | \\-  | pointer to pointer to the first element of a null-terminated multibyte string |\n| len    | \\-  | number of wide characters available in the array pointed to by dst            |\n| ps     | \\-  | pointer to the conversion state object                                        |\n| dstsz  | \\-  | max number of wide characters that will be written (size of the `dst` array)  |\n| retval | \\-  | pointer to a size_t object where the result will be stored                    |\n\n### Return value\n\n1) On success, returns the number of wide characters, excluding the terminating `L'\\0'`, written to the character array. If `dst` is a null pointer, returns the number of wide characters that would have been written given unlimited length. On conversion error (if invalid multibyte character was encountered), returns `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1`, stores [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") in [`errno`](../../error/errno \"c/error/errno\"), and leaves `*ps` in unspecified state.\n\n2) zero on success (in which case the number of wide characters excluding terminating zero that were, or would be written to `dst`, is stored in `*retval`), non-sero on error. In case of a runtime constraint violation, stores `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` in `*retval` (unless `retval` is null) and sets `dst[0]` to `L'\\0'` (unless `dst` is null or `dstmax` is zero or greater than `RSIZE_MAX`)\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <wchar.h>\n#include <string.h>\n \nvoid print_as_wide(const char* mbstr)\n{\n    mbstate_t state;\n    memset(&state, 0, sizeof state);\n    size_t len = 1 + mbsrtowcs(NULL, &mbstr, 0, &state);\n    wchar_t wstr[len];\n    mbsrtowcs(&wstr[0], &mbstr, len, &state);\n    wprintf(L\"Wide string: %ls \\n\", wstr);\n    wprintf(L\"The length, including L'\\\\0': %zu\\n\", len);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    print_as_wide(u8\"z\\u00df\\u6c34\\U0001f34c\"); // u8\"zß水🍌\"\n}\n```\n\nOutput:\n\n```\nWide string: zß水🍌\nThe length, including L'\\0': 5\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.4.1 The mbsrtowcs function (p: 445)\n  - K.3.9.3.2.1 The mbsrtowcs_s function (p: 648-649)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.4.1 The mbsrtowcs function (p: 391)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbsrtowcs](https://en.cppreference.com/w/c/string/multibyte/mbsrtowcs)"
- name: mbsrtowcs_s
  summary: 'Output:'
  description: "# mbsrtowcs, mbsrtowcs_s\n\n[TABLE]\n\n1) Converts a null-terminated multibyte character sequence, which begins in the conversion state described by `*ps`, from the array whose first element is pointed to by `*src` to its wide character representation. If `dst` is not null, converted characters are stored in the successive elements of the wchar_t array pointed to by `dst`. No more than `len` wide characters are written to the destination array. Each multibyte character is converted as if by a call to [`mbrtowc`](mbrtowc \"c/string/multibyte/mbrtowc\"). The conversion stops if:\n\n- The multibyte null character was converted and stored. `*src` is set to null pointer value and `*ps` represents the initial shift state.\n- An invalid multibyte character (according to the current C locale) was encountered. `*src` is set to point at the beginning of the first unconverted multibyte character.\n- the next wide character to be stored would exceed `len`. `*src` is set to point at the beginning of the first unconverted multibyte character. This condition is not checked if `dst` is a null pointer.\n\n2) Same as (1), except that\n\n- the function returns its result as an out-parameter `retval`\n- if no null character was written to `dst` after `len` wide characters were written, then `L'\\0'` is stored in `dst[len]`, which means len+1 total wide characters are written\n- the function clobbers the destination array from the terminating null and until `dstsz`\n- If `src` and `dst` overlap, the behavior is unspecified.\n- the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n&nbsp;\n\n- `retval`, `ps`, `src`, or `*src` is a null pointer\n- `dstsz` or `len` is greater than `RSIZE_MAX/sizeof(wchar_t)` (unless `dst` is null)\n- `dstsz` is not zero (unless `dst` is null)\n- There is no null character in the first `dstsz` multibyte characters in the `*src` array and `len` is greater than `dstsz` (unless `dst` is null)\n\nAs with all bounds-checked functions, `mbsrtowcs_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                               |\n|--------|-----|-------------------------------------------------------------------------------|\n| dst    | \\-  | pointer to wide character array where the results will be stored              |\n| src    | \\-  | pointer to pointer to the first element of a null-terminated multibyte string |\n| len    | \\-  | number of wide characters available in the array pointed to by dst            |\n| ps     | \\-  | pointer to the conversion state object                                        |\n| dstsz  | \\-  | max number of wide characters that will be written (size of the `dst` array)  |\n| retval | \\-  | pointer to a size_t object where the result will be stored                    |\n\n### Return value\n\n1) On success, returns the number of wide characters, excluding the terminating `L'\\0'`, written to the character array. If `dst` is a null pointer, returns the number of wide characters that would have been written given unlimited length. On conversion error (if invalid multibyte character was encountered), returns `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1`, stores [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") in [`errno`](../../error/errno \"c/error/errno\"), and leaves `*ps` in unspecified state.\n\n2) zero on success (in which case the number of wide characters excluding terminating zero that were, or would be written to `dst`, is stored in `*retval`), non-sero on error. In case of a runtime constraint violation, stores `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` in `*retval` (unless `retval` is null) and sets `dst[0]` to `L'\\0'` (unless `dst` is null or `dstmax` is zero or greater than `RSIZE_MAX`)\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <wchar.h>\n#include <string.h>\n \nvoid print_as_wide(const char* mbstr)\n{\n    mbstate_t state;\n    memset(&state, 0, sizeof state);\n    size_t len = 1 + mbsrtowcs(NULL, &mbstr, 0, &state);\n    wchar_t wstr[len];\n    mbsrtowcs(&wstr[0], &mbstr, len, &state);\n    wprintf(L\"Wide string: %ls \\n\", wstr);\n    wprintf(L\"The length, including L'\\\\0': %zu\\n\", len);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    print_as_wide(u8\"z\\u00df\\u6c34\\U0001f34c\"); // u8\"zß水🍌\"\n}\n```\n\nOutput:\n\n```\nWide string: zß水🍌\nThe length, including L'\\0': 5\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.4.1 The mbsrtowcs function (p: 445)\n  - K.3.9.3.2.1 The mbsrtowcs_s function (p: 648-649)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.4.1 The mbsrtowcs function (p: 391)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbsrtowcs](https://en.cppreference.com/w/c/string/multibyte/mbsrtowcs)"
- name: mbstate_t
  summary: The type mbstate_t is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules
  description: "# mbstate_t\n\n[TABLE]\n\nThe type `mbstate_t` is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of `mbstate_t` represents the initial conversion state, although other values of `mbstate_t` may exist that also represent the initial conversion state.\n\nPossible implementation of `mbstate_t` is a struct type holding an array representing the incomplete multibyte character, an integer counter indicating the number of bytes in the array that have been processed, and a representation of the current shift state.\n\nThe following functions should not be called from multiple threads without synchronization with the `mbstate_t*` argument of a null pointer due to possible data races: [`mbrlen`](mbrlen \"c/string/multibyte/mbrlen\"), [`mbrtowc`](mbrtowc \"c/string/multibyte/mbrtowc\"), [`mbsrtowcs`](mbsrtowcs \"c/string/multibyte/mbsrtowcs\"), [`mbtowc`](mbtowc \"c/string/multibyte/mbtowc\"), [`wcrtomb`](wcrtomb \"c/string/multibyte/wcrtomb\"), [`wcsrtombs`](wcsrtombs \"c/string/multibyte/wcsrtombs\"), [`wctomb`](wctomb \"c/string/multibyte/wctomb\").\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.1/2 Introduction (p: 402)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.1/2 Introduction (p: 348)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbstate_t](https://en.cppreference.com/w/c/string/multibyte/mbstate_t)"
- name: mbstowcs
  summary: In most implementations, mbstowcs updates a global static object of type mbstate_t as it processes through the string, and cannot be called simultaneously by two threads, mbsrtowcs should be used in such cases
  description: "# mbstowcs, mbstowcs_s\n\n[TABLE]\n\n1) Converts a multibyte character string from the array whose first element is pointed to by `src` to its wide character representation. Converted characters are stored in the successive elements of the array pointed to by `dst`. No more than `len` wide characters are written to the destination array.\n\nEach character is converted as if by a call to [`mbtowc`](mbtowc \"c/string/multibyte/mbtowc\"), except that the mbtowc conversion state is unaffected. The conversion stops if:\n\n\\* The multibyte null character was converted and stored.\n\n\\* An invalid (in the current C locale) multibyte character was encountered.\n\n\\* The next wide character to be stored would exceed `len`.\n\nIf `src` and `dst` overlap, the behavior is undefined\n\n2) Same as (1), except that\n\n\\* conversion is as-if by [`mbrtowc`](mbrtowc \"c/string/multibyte/mbrtowc\"), not [`mbtowc`](mbtowc \"c/string/multibyte/mbtowc\")\n\n\\* the function returns its result as an out-parameter `retval`\n\n\\* if no null character was written to `dst` after `len` wide characters were written, then `L'\\0'` is stored in `dst[len]`, which means len+1 total wide characters are written\n\n\\* if `dst` is a null pointer, the number of wide characters that would be produced is stored in `*retval`\n\n\\* the function clobbers the destination array from the terminating null and until `dstsz`\n\n\\* If `src` and `dst` overlap, the behavior is unspecified.\n\n\\* the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `retval` or `src` is a null pointer\n- `dstsz` or `len` is greater than `RSIZE_MAX/sizeof(wchar_t)` (unless `dst` is null)\n- `dstsz` is not zero (unless `dst` is null)\n- There is no null character in the first `dstsz` multibyte characters in the `src` array and `len` is greater than `dstsz` (unless `dst` is null)\n\nAs with all bounds-checked functions, `mbstowcs_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../../program \"c/program\").\n\n### Notes\n\nIn most implementations, `mbstowcs` updates a global static object of type [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\") as it processes through the string, and cannot be called simultaneously by two threads, [`mbsrtowcs`](mbsrtowcs \"c/string/multibyte/mbsrtowcs\") should be used in such cases.\n\nPOSIX specifies a common extension: if `dst` is a null pointer, this function returns the number of wide characters that would be written to `dst`, if converted. Similar behavior is standard for `mbstowcs_s` and for [`mbsrtowcs`](mbsrtowcs \"c/string/multibyte/mbsrtowcs\").\n\n### Parameters\n\n|        |     |                                                                               |\n|--------|-----|-------------------------------------------------------------------------------|\n| dst    | \\-  | pointer to wide character array where the wide string will be stored          |\n| src    | \\-  | pointer to the first element of a null-terminated multibyte string to convert |\n| len    | \\-  | number of wide characters available in the array pointed to by dst            |\n| dstsz  | \\-  | max number of wide characters that will be written (size of the `dst` array)  |\n| retval | \\-  | pointer to a size_t object where the result will be stored                    |\n\n### Return value\n\n1) On success, returns the number of wide characters, excluding the terminating `L'\\0'`, written to the destination array. On conversion error (if invalid multibyte character was encountered), returns `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1`.\n\n2) zero on success (in which case the number of wide characters excluding terminating zero that were, or would be written to `dst`, is stored in `*retval`), non-zero on error. In case of a runtime constraint violation, stores `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` in `*retval` (unless `retval` is null) and sets `dst[0]` to `L'\\0'` (unless `dst` is null or `dstmax` is zero or greater than `RSIZE_MAX`)\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <stdlib.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char* mbstr = u8\"z\\u00df\\u6c34\\U0001F34C\"; // or u8\"zß水🍌\"\n    wchar_t wstr[5];\n    mbstowcs(wstr, mbstr, 5);\n    wprintf(L\"MB string: %s\\n\", mbstr);\n    wprintf(L\"Wide string: %ls\\n\", wstr);\n}\n```\n\nOutput:\n\n```\nMB string: zß水🍌\nWide string: zß水🍌\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.8.1 The mbstowcs function (p: 359)\n  - K.3.6.5.1 The mbstowcs_s function (p: 611-612)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.8.1 The mbstowcs function (p: 323)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.8.1 The mbstowcs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbstowcs](https://en.cppreference.com/w/c/string/multibyte/mbstowcs)"
- name: mbstowcs_s
  summary: In most implementations, mbstowcs updates a global static object of type mbstate_t as it processes through the string, and cannot be called simultaneously by two threads, mbsrtowcs should be used in such cases
  description: "# mbstowcs, mbstowcs_s\n\n[TABLE]\n\n1) Converts a multibyte character string from the array whose first element is pointed to by `src` to its wide character representation. Converted characters are stored in the successive elements of the array pointed to by `dst`. No more than `len` wide characters are written to the destination array.\n\nEach character is converted as if by a call to [`mbtowc`](mbtowc \"c/string/multibyte/mbtowc\"), except that the mbtowc conversion state is unaffected. The conversion stops if:\n\n\\* The multibyte null character was converted and stored.\n\n\\* An invalid (in the current C locale) multibyte character was encountered.\n\n\\* The next wide character to be stored would exceed `len`.\n\nIf `src` and `dst` overlap, the behavior is undefined\n\n2) Same as (1), except that\n\n\\* conversion is as-if by [`mbrtowc`](mbrtowc \"c/string/multibyte/mbrtowc\"), not [`mbtowc`](mbtowc \"c/string/multibyte/mbtowc\")\n\n\\* the function returns its result as an out-parameter `retval`\n\n\\* if no null character was written to `dst` after `len` wide characters were written, then `L'\\0'` is stored in `dst[len]`, which means len+1 total wide characters are written\n\n\\* if `dst` is a null pointer, the number of wide characters that would be produced is stored in `*retval`\n\n\\* the function clobbers the destination array from the terminating null and until `dstsz`\n\n\\* If `src` and `dst` overlap, the behavior is unspecified.\n\n\\* the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `retval` or `src` is a null pointer\n- `dstsz` or `len` is greater than `RSIZE_MAX/sizeof(wchar_t)` (unless `dst` is null)\n- `dstsz` is not zero (unless `dst` is null)\n- There is no null character in the first `dstsz` multibyte characters in the `src` array and `len` is greater than `dstsz` (unless `dst` is null)\n\nAs with all bounds-checked functions, `mbstowcs_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../../program \"c/program\").\n\n### Notes\n\nIn most implementations, `mbstowcs` updates a global static object of type [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\") as it processes through the string, and cannot be called simultaneously by two threads, [`mbsrtowcs`](mbsrtowcs \"c/string/multibyte/mbsrtowcs\") should be used in such cases.\n\nPOSIX specifies a common extension: if `dst` is a null pointer, this function returns the number of wide characters that would be written to `dst`, if converted. Similar behavior is standard for `mbstowcs_s` and for [`mbsrtowcs`](mbsrtowcs \"c/string/multibyte/mbsrtowcs\").\n\n### Parameters\n\n|        |     |                                                                               |\n|--------|-----|-------------------------------------------------------------------------------|\n| dst    | \\-  | pointer to wide character array where the wide string will be stored          |\n| src    | \\-  | pointer to the first element of a null-terminated multibyte string to convert |\n| len    | \\-  | number of wide characters available in the array pointed to by dst            |\n| dstsz  | \\-  | max number of wide characters that will be written (size of the `dst` array)  |\n| retval | \\-  | pointer to a size_t object where the result will be stored                    |\n\n### Return value\n\n1) On success, returns the number of wide characters, excluding the terminating `L'\\0'`, written to the destination array. On conversion error (if invalid multibyte character was encountered), returns `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1`.\n\n2) zero on success (in which case the number of wide characters excluding terminating zero that were, or would be written to `dst`, is stored in `*retval`), non-zero on error. In case of a runtime constraint violation, stores `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` in `*retval` (unless `retval` is null) and sets `dst[0]` to `L'\\0'` (unless `dst` is null or `dstmax` is zero or greater than `RSIZE_MAX`)\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <stdlib.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char* mbstr = u8\"z\\u00df\\u6c34\\U0001F34C\"; // or u8\"zß水🍌\"\n    wchar_t wstr[5];\n    mbstowcs(wstr, mbstr, 5);\n    wprintf(L\"MB string: %s\\n\", mbstr);\n    wprintf(L\"Wide string: %ls\\n\", wstr);\n}\n```\n\nOutput:\n\n```\nMB string: zß水🍌\nWide string: zß水🍌\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.8.1 The mbstowcs function (p: 359)\n  - K.3.6.5.1 The mbstowcs_s function (p: 611-612)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.8.1 The mbstowcs function (p: 323)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.8.1 The mbstowcs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbstowcs](https://en.cppreference.com/w/c/string/multibyte/mbstowcs)"
- name: mbtowc
  summary: Converts a multibyte character whose first byte is pointed to by s to a wide character, written to *pwc if pwc is not null
  description: "# mbtowc\n\n[TABLE]\n\nConverts a multibyte character whose first byte is pointed to by `s` to a wide character, written to `*pwc` if `pwc` is not null.\n\nIf `s` is a null pointer, resets the global conversion state and determines whether shift sequences are used.\n\n### Notes\n\nEach call to `mbtowc` updates the internal global conversion state (a static object of type [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\"), known only to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call `mbtowc` without synchronization: [`mbrtowc`](mbrtowc \"c/string/multibyte/mbrtowc\") may be used instead.\n\n### Parameters\n\n|     |     |                                                        |\n|-----|-----|--------------------------------------------------------|\n| pwc | \\-  | pointer to the wide character for output               |\n| s   | \\-  | pointer to the multibyte character                     |\n| n   | \\-  | limit on the number of bytes in s that can be examined |\n\n### Return value\n\nIf `s` is not a null pointer, returns the number of bytes that are contained in the multibyte character or `-1` if the first bytes pointed to by `s` do not form a valid multibyte character or `​0​` if `s` is pointing at the null character `'\\0'`.\n\nIf `s` is a null pointer, resets its internal conversion state to represent the initial shift state and returns `​0​` if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n \n// print multibyte string to wide-oriented stdout\n// equivalent to wprintf(L\"%s\\n\", ptr);\nvoid print_mb(const char* ptr)\n{\n    mbtowc(NULL, 0, 0); // reset the conversion state\n    const char* end = ptr + strlen(ptr);\n    int ret = 0;\n    for (wchar_t wc; (ret = mbtowc(&wc, ptr, end - ptr)) > 0; ptr += ret)\n        wprintf(L\"%lc\", wc);\n    wprintf(L\"\\n\");\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    print_mb(u8\"z\\u00df\\u6c34\\U0001F34C\"); // or u8\"zß水🍌\"\n}\n```\n\nOutput:\n\n```\nzß水🍌\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.24.7.2 The mbtowc function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.7.2 The mbtowc function (p: 260)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.7.2 The mbtowc function (p: 358)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.7.2 The mbtowc function (p: 322)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.7.2 The mbtowc function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/mbtowc](https://en.cppreference.com/w/c/string/multibyte/mbtowc)"
- name: Member access operators
  summary: Member access operators allow access to the members of their operands
  description: "# Member access operators\n\nMember access operators allow access to the members of their operands.\n\n| Operator | Operator name                 | Example | Description                                                                                                          |\n|----------|-------------------------------|---------|----------------------------------------------------------------------------------------------------------------------|\n| `[]`     | array subscript               | `a[b]`  | access the **b**th element of array **a**                                                                            |\n| `*`      | pointer dereference           | `*a`    | dereference the pointer **a** to access the object or function it refers to                                          |\n| `&`      | address of                    | `&a`    | create a pointer that refers to the object or function **a**                                                         |\n| `.`      | member access                 | `a.b`   | access member **b** of [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") **a**               |\n| `->`     | member access through pointer | `a->b`  | access member **b** of [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") pointed to by **a** |\n\n### Subscript\n\nThe array subscript expression has the form\n\n|                                               |       |     |\n|-----------------------------------------------|-------|-----|\n| pointer-expression `[` integer-expression `]` | \\(1\\) |     |\n| integer-expression `[` pointer-expression `]` | \\(2\\) |     |\n\nwhere\n\n|                    |     |                                                                                          |\n|--------------------|-----|------------------------------------------------------------------------------------------|\n| pointer-expression | \\-  | an [expression](expressions \"c/language/expressions\") of type pointer to complete object |\n| integer-expression | \\-  | an [expression](expressions \"c/language/expressions\") of integer type                    |\n\nThe subscript operator expression is an [lvalue expression](value_category \"c/language/value category\") whose type is the type of the object pointed to by pointer-expression.\n\nBy definition, the subscript operator `E1[E2]` is exactly identical to `*((E1)+(E2))`. If pointer-expression is an array expression, it undergoes [lvalue-to-rvalue conversion](conversion \"c/language/conversion\") and becomes a pointer to the first element of the array.\n\nDue to the definition of the [addition between a pointer and an integer](operator_arithmetic \"c/language/operator arithmetic\"), the result is the element of the array with the index equal to the result of integer-expression (or, if pointer-expression was pointing at ith element of some array, the index of the result is i plus the result of integer-expression)\n\nNote: see [array](array \"c/language/array\") for the details on multidimensional arrays.\n\n```\n#include <stdio.h>\nint main(void)\n{\n    int a[3] = {1,2,3};\n    printf(\"%d %d\\n\", a[2],  // n == 3\n                      2[a]); // same, n == 3\n    a[2] = 7; // subscripts are lvalues\n \n    int n[2][3] = {{1,2,3},{4,5,6}};\n    int (*p)[3] = &n[1]; // elements of n are arrays\n    printf(\"%d %d %d\\n\", (*p)[0], p[0][1], p[0][2]); // access n[1][] via p\n    int x = n[1][2]; // applying [] again to the array n[1]\n    printf(\"%d\\n\", x);\n \n    printf(\"%c %c\\n\", \"abc\"[2], 2[\"abc\"]); // string literals are arrays too\n}\n```\n\nOutput:\n\n```\n3 3\n4 5 6\n6\nc c\n```\n\n### Dereference\n\nThe *dereference* or *indirection* expression has the form\n\n|                        |     |     |\n|------------------------|-----|-----|\n| `*` pointer-expression |     |     |\n\nwhere\n\n|                    |     |                                                                           |\n|--------------------|-----|---------------------------------------------------------------------------|\n| pointer-expression | \\-  | an [expression](expressions \"c/language/expressions\") of any pointer type |\n\nIf pointer-expression is a pointer to function, the result of the dereference operator is a function designator for that function.\n\nIf pointer-expression is a pointer to object, the result is an [lvalue expression](value_category \"c/language/value category\") that designates the pointed-to object.\n\nDereferencing a null pointer, a pointer to an object outside of its lifetime (a dangling pointer), a misaligned pointer, or a pointer with indeterminate value is undefined behavior, except when the dereference operator is nullified by applying the address-of operator to its result, as in `&*E`.\n\n```\n#include <stdio.h>\nint main(void)\n{\n    int n = 1;\n    int* p = &n;\n    printf(\"*p = %d\\n\", *p); // the value of *p is what's stored in n\n    *p = 7; // *p is lvalue\n    printf(\"*p = %d\\n\", *p);\n}\n```\n\nOutput:\n\n```\n*p = 1\n*p = 7\n```\n\n### Address of\n\nThe address-of expression has the form\n\n|                                   |       |     |\n|-----------------------------------|-------|-----|\n| `&` function                      | \\(1\\) |     |\n| `&` lvalue-expression             | \\(2\\) |     |\n| `&` `*` expression                | \\(3\\) |     |\n| `&` expression `[` expression `]` | \\(4\\) |     |\n\n1) address of a function\n\n2) address of an object\n\n3) special case: `&` and `*` cancel each other, neither one is evaluated\n\n4) special case: `&` and the `*` that is implied in `[]` cancel each other, only the addition implied in `[]` is evaluated.\n\nwhere\n\n|                   |     |                                                                                                                                                                                                                                       |\n|-------------------|-----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| lvalue-expression | \\-  | an [lvalue](value_category \"c/language/value category\") expression of any type that is not a [bit-field](bit_field \"c/language/bit field\") and does not have [register](storage_duration \"c/language/storage duration\") storage class |\n\nThe address-of operator produces the [non-lvalue](value_category \"c/language/value category\") address of its operand, suitable for initializing a pointer to the type of the operand. If the operand is a function designator (1), the result is a pointer to function. If the operand is an object (2), the result is a pointer to object.\n\nIf the operand is the dereference operator, no action is taken (so it's okay to apply &\\* to a null pointer), except that the result is not an lvalue.\n\nIf the operand is an array index expression, no action is taken other than the array-to-pointer conversion and the addition, so &a\\[N\\] is valid for an array of size N (obtaining a pointer one past the end is okay, dereferencing it is not, but dereference cancels out in this expression).\n\n```\nint f(char c) { return c;}\nint main(void)\n{\n   int n = 1;\n   int *p = &n; // address of object n\n   int (*fp)(char) = &f; // address of function f\n   int a[3] = {1,2,3};\n   int *beg=a, *end=&a[3]; // same as end = a+3\n}\n```\n\n### Member access\n\nThe member access expression has the form\n\n|                            |     |     |\n|----------------------------|-----|-----|\n| expression `.` member-name |     |     |\n\nwhere\n\n|             |     |                                                                                                                         |\n|-------------|-----|-------------------------------------------------------------------------------------------------------------------------|\n| expression  | \\-  | an expression of [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") type                         |\n| member-name | \\-  | an [identifier](identifier \"c/language/identifier\") that names a member of the struct or union designated by expression |\n\nThe member access expression designates the named member of the [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") designated by its left operand. It has the same [value category](value_category \"c/language/value category\") as its left operand.\n\nIf the left operand is [const](const \"c/language/const\") or [volatile](volatile \"c/language/volatile\") qualified, the result is also qualified. If the left operand is [atomic](atomic \"c/language/atomic\"), the behavior is undefined.\n\nNote: besides identifiers that name objects of struct or union type, the following expressions may have struct or union types: [assignment](operator_assignment \"c/language/operator assignment\"), [function call](operator_other#Function_call \"c/language/operator other\"), [comma operator](operator_other#Comma_operator \"c/language/operator other\"), [conditional operator](operator_other#Conditional_operator \"c/language/operator other\"), and [compound literal](compound_literal \"c/language/compound literal\").\n\n```\n#include <stdio.h>\nstruct s {int x;};\nstruct s f(void) { return (struct s){1}; }\nint main(void)\n{\n    struct s s;\n    s.x = 1; // ok, changes the member of s\n    int n = f().x; // f() is an expression of type struct s\n//  f().x = 1; // Error: this member access expression is not an lvalue\n \n    const struct s sc;\n//  sc.x = 3;  // Error: sc.x is const, can't be assigned\n \n    union { int x; double d; } u = {1};\n    u.d = 0.1; // changes the active member of the union\n}\n```\n\n### Member access through pointer\n\nThe member access expression has the form\n\n|                             |     |     |\n|-----------------------------|-----|-----|\n| expression `->` member-name |     |     |\n\nwhere\n\n|             |     |                                                                                                                                            |\n|-------------|-----|--------------------------------------------------------------------------------------------------------------------------------------------|\n| expression  | \\-  | an expression of type [pointer](pointer \"c/language/pointer\") to [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") |\n| member-name | \\-  | an [identifier](identifier \"c/language/identifier\") that names a member of the struct or union pointed by expression                       |\n\nThe member access through pointer expression designates the named member of the [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") type pointed to by its left operand. Its value category is always [lvalue](value_category \"c/language/value category\")\n\nIf the type pointed to by the left operand is [const](const \"c/language/const\") or [volatile](volatile \"c/language/volatile\") qualified, the result is also qualified. If the type pointed to by the left operand is [atomic](atomic \"c/language/atomic\"), the behavior is undefined.\n\n```\n#include <stdio.h>\nstruct s {int x;};\nint main(void)\n{\n    struct s s={1}, *p = &s;\n    p->x = 7; // changes the value of s.x through the pointer\n    printf(\"%d\\n\", p->x); // prints 7\n}\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                     | Applied to | Behavior as published                               | Correct behavior |\n|------------------------------------------------------------------------|------------|-----------------------------------------------------|------------------|\n| [DR 076](https://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_076.html) | C89        | unnessary indirection could not be cancelled by `&` | made cancellable |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.2.1 Array subscripting (p: 57-58)\n  - 6.5.2.3 Structure and union members (p: 58-59)\n  - 6.5.3.2 Address and indirection operators (p: 59-61)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.2.1 Array subscripting (p: 80)\n  - 6.5.2.3 Structure and union members (p: 82-84)\n  - 6.5.3.2 Address and indirection operators (p: 88-89)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5.2.1 Array subscripting (p: 70)\n  - 6.5.2.3 Structure and union members (p: 72-74)\n  - 6.5.3.2 Address and indirection operators (p: 78-79)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.3.2.1 Array subscripting\n  - 3.3.2.3 Structure and union members\n  - 3.3.3.2 Address and indirection operators\n\n### See also\n\n- [Operator precedence](operator_precedence \"c/language/operator precedence\")\n\n[TABLE]\n\n|                                                                                                                                                          |     |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/operator_member_access \"cpp/language/operator member access\") for Member access operators |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/operator_member_access](https://en.cppreference.com/w/c/language/operator_member_access)"
- name: memccpy
  summary: 'Copies bytes from the object pointed to by src to the object pointed to by dest, stopping after any of the next two conditions are satisfied:'
  description: "# memccpy\n\n[TABLE]\n\nCopies bytes from the object pointed to by `src` to the object pointed to by `dest`, stopping after *any* of the next two conditions are satisfied:\n\n- `count` bytes are copied\n- the byte `(unsigned char)c` is found (and copied).\n\nThe `src` and `dest` objects are interpreted as arrays of `unsigned char`.\n\nThe behavior is undefined if *any* condition is met:\n\n- access occurs beyond the end of the `dest` array;\n- the objects overlap (which is a violation of the [`restrict`](../../language/restrict \"c/language/restrict\") contract)\n- either `dest` or `src` is an invalid or null pointer\n\n### Parameters\n\n|       |     |                                                         |\n|-------|-----|---------------------------------------------------------|\n| dest  | \\-  | pointer to the object to copy to                        |\n| src   | \\-  | pointer to the object to copy from                      |\n| c     | \\-  | terminating byte, converted to `unsigned char` at first |\n| count | \\-  | number of bytes to copy                                 |\n\n### Return value\n\nIf the byte `(unsigned char)c` was found, `memccpy` returns a pointer to the next byte in `dest` after `(unsigned char)c`. Otherwise it returns a null pointer.\n\n### Notes\n\nThe function is identical to the [POSIX `memccpy`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/memccpy.html).\n\n`memccpy(dest, src, 0, count)` behaves similar to [`strncpy`](http://en.cppreference.com/w/c/string/byte/strncpy)`(``dest, src, count``)`, except that the former returns a pointer to the *end* of the buffer written, and does not zero-pad the destination array. Thus, `memccpy` is useful for efficiently concatenating multiple strings.\n\n```\nchar bigString[1000];\nchar* end = bigString + sizeof bigString;\n \nchar* p = memccpy(bigString, \"John, \", '\\0', sizeof bigString - 1);\nif (p)\n    p = memccpy(p - 1, \"Paul, \", '\\0', end - p);\nif (p)\n    p = memccpy(p - 1, \"George, \", '\\0', end - p);\nif (p)\n    p = memccpy(p - 1, \"Joel \", '\\0', end - p);\nif (!p)\n    end[-1] = '\\0';\n \nputs(bigString); // John, Paul, George, Joel\n```\n\n### Example\n\n```\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n \nint main(void)\n{\n    const char src[] = \"Stars: Altair, Sun, Vega.\";\n    const char terminal[] = {':', ' ', ',', '.', '!'};\n    char dest[sizeof src];\n    const char alt = '@';\n \n    for (size_t i = 0; i != sizeof terminal; ++i)\n    {\n        void* to = memccpy(dest, src, terminal[i], sizeof dest);\n \n        printf(\"Terminal '%c' (%s):\\t\\\"\", terminal[i], to ? \"found\" : \"absent\");\n \n        // if `terminal` character was not found - print the whole `dest`\n        to = to ? to : dest + sizeof dest;\n \n        for (char* from = dest; from != to; ++from)\n            putchar(isprint(*from) ? *from : alt);\n \n        puts(\"\\\"\");\n    }\n \n \n    puts(\"\\n\" \"Separate star names from distances (ly):\");\n    const char *star_distance[] = {\n        \"Arcturus : 37\", \"Vega : 25\", \"Capella : 43\", \"Rigel : 860\", \"Procyon : 11\"\n    };\n    char names_only[64];\n    char *first = names_only;\n    char *last = names_only + sizeof names_only;\n \n    for (size_t t = 0; t != (sizeof star_distance) / (sizeof star_distance[0]); ++t)\n    {\n        if (first)\n            first = memccpy(first, star_distance[t], ' ', last - first);\n        else\n            break;\n    }\n \n    if (first)\n    {\n        *first = '\\0';\n        puts(names_only);\n    }\n    else\n        puts(\"Buffer is too small.\");\n}\n```\n\nOutput:\n\n```\nTerminal ':' (found):   \"Stars:\"\nTerminal ' ' (found):   \"Stars: \"\nTerminal ',' (found):   \"Stars: Altair,\"\nTerminal '.' (found):   \"Stars: Altair, Sun, Vega.\"\nTerminal '!' (absent):  \"Stars: Altair, Sun, Vega.@\"\n \nSeparate star names from distances (ly):\nArcturus Vega Capella Rigel Procyon\n```\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/memccpy](https://en.cppreference.com/w/c/string/byte/memccpy)"
- name: memchr
  summary: The behavior is undefined if access occurs beyond the end of the array searched
  description: "# memchr\n\n[TABLE]\n\n1) Finds the first occurrence of `(unsigned char)ch` in the initial `count` bytes (each interpreted as `unsigned char`) of the object pointed to by `ptr`.\n\n2) Type-generic function equivalent to (1). Let `T` be an unqualified object type (including `void`).\n\n- If `ptr` is of type `const T*`, the return type is `const void*`.\n- Otherwise, if `ptr` is of type `T*`, the return type is `void*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(memchr)` or a function pointer is used), the actual function declaration (1) becomes visible.\n\nThe behavior is undefined if access occurs beyond the end of the array searched. The behavior is undefined if `ptr` is a null pointer.\n\n|                                                                                                                                                                                                                                              |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| This function behaves as if it reads the bytes sequentially and stops as soon as a matching bytes is found: if the array pointed to by `ptr` is smaller than `count`, but the match is found within the array, the behavior is well-defined. | (since C11) |\n\n### Parameters\n\n|       |     |                                      |\n|-------|-----|--------------------------------------|\n| ptr   | \\-  | pointer to the object to be examined |\n| ch    | \\-  | bytes to search for                  |\n| count | \\-  | max number of bytes to examine       |\n\n### Return value\n\nPointer to the location of the byte, or a null pointer if no such byte is found.\n\n### Example\n\n```\n#include <stdio.h>\n#include <string.h>\n \nint main(void)\n{\n    const char str[] = \"ABCDEFG\";\n    const int chars[] = {'D', 'd'};\n    for (size_t i = 0; i < sizeof chars / (sizeof chars[0]); ++i)\n    {\n        const int c = chars[i];   \n        const char *ps = memchr(str, c, strlen(str));\n        ps ? printf (\"character '%c'(%i) found: %s\\n\", c, c, ps)\n           : printf (\"character '%c'(%i) not found\\n\", c, c);\n    }\n    return 0;\n}\n```\n\nPossible output:\n\n```\ncharacter 'D'(68) found: DEFG\ncharacter 'd'(100) not found\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.5.1 The memchr function (p: 267-268)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.5.1 The memchr function (p: 367)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.5.1 The memchr function (p: 330)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.5.1 The memchr function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/memchr](https://en.cppreference.com/w/c/string/byte/memchr)"
- name: memcmp
  summary: Compares the first count bytes of the objects pointed to by lhs and rhs
  description: "# memcmp\n\n[TABLE]\n\nCompares the first `count` bytes of the objects pointed to by `lhs` and `rhs`. The comparison is done lexicographically.\n\nThe sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as `unsigned char`) that differ in the objects being compared.\n\nThe behavior is undefined if access occurs beyond the end of either object pointed to by `lhs` and `rhs`. The behavior is undefined if either `lhs` or `rhs` is a null pointer.\n\n### Parameters\n\n|          |     |                                    |\n|----------|-----|------------------------------------|\n| lhs, rhs | \\-  | pointers to the objects to compare |\n| count    | \\-  | number of bytes to examine         |\n\n### Return value\n\nNegative value if `lhs` appears before `rhs` in lexicographical order.\n\nZero if `lhs` and `rhs` compare equal, or if count is zero.\n\nPositive value if `lhs` appears after `rhs` in lexicographical order.\n\n### Notes\n\nThis function reads [object representations](../../language/object \"c/language/object\"), not the object values, and is typically meaningful for byte arrays only: structs may have padding bytes whose values are indeterminate, the values of any bytes beyond the last stored member in a union are indeterminate, and a type may have two or more representations for the same value (different encodings for +0 and -0 or for +0.0 and –0.0, indeterminate padding bits within the type).\n\n### Example\n\n```\n#include <stdio.h>\n#include <string.h>\n \nvoid demo(const char* lhs, const char* rhs, size_t sz)\n{\n    for(size_t n = 0; n < sz; ++n)\n        putchar(lhs[n]);\n \n    int rc = memcmp(lhs, rhs, sz);\n    const char *rel = rc < 0 ? \" precedes \" : rc > 0 ? \" follows \" : \" compares equal \";\n    fputs(rel, stdout);\n \n    for(size_t n = 0; n < sz; ++n)\n        putchar(rhs[n]);\n    puts(\" in lexicographical order\");\n}\n \nint main(void)\n{\n    char a1[] = {'a','b','c'};\n    char a2[sizeof a1] = {'a','b','d'};\n \n    demo(a1, a2, sizeof a1);\n    demo(a2, a1, sizeof a1);\n    demo(a1, a1, sizeof a1);\n}\n```\n\nOutput:\n\n```\nabc precedes abd in lexicographical order\nabd follows abc in lexicographical order\nabc compares equal to abc in lexicographical order\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.4.1 The memcmp function (p: 266)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.4.1 The memcmp function (p: 365)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.4.1 The memcmp function (p: 328)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.4.1 The memcmp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/memcmp](https://en.cppreference.com/w/c/string/byte/memcmp)"
- name: memcpy
  summary: memcpy may be used to set the effective type of an object obtained by an allocation function
  description: "# memcpy, memcpy_s\n\n[TABLE]\n\n1) Copies `count` characters from the object pointed to by `src` to the object pointed to by `dest`. Both objects are interpreted as arrays of `unsigned char`.\n\nThe behavior is undefined if access occurs beyond the end of the `dest` array. If the objects overlap (which is a violation of the [`restrict`](../../language/restrict \"c/language/restrict\") contract)(since C99), the behavior is undefined. The behavior is undefined if either `dest` or `src` is an invalid or null pointer.\n\n2) Same as (1), except that the following errors are detected at runtime and cause the entire destination range `[dest, dest+destsz)` to be zeroed out (if both `dest` and `destsz` are valid), as well as call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `dest` or `src` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX`\n- `count` is greater than `destsz` (buffer overflow would occur)\n- the source and the destination objects overlap\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `count` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `memcpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                                                                 |\n|--------|-----|-------------------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the object to copy to                                                                |\n| destsz | \\-  | max number of bytes to modify in the destination (typically the size of the destination object) |\n| src    | \\-  | pointer to the object to copy from                                                              |\n| count  | \\-  | number of bytes to copy                                                                         |\n\n### Return value\n\n1) Returns a copy of `dest`\n\n2) Returns zero on success and non-zero value on error. Also on error, if `dest` is not a null pointer and `destsz` is valid, writes `destsz` zero bytes in to the destination array.\n\n### Notes\n\n`memcpy` may be used to set the [effective type](../../language/object#Effective_type \"c/language/object\") of an object obtained by an allocation function.\n\n`memcpy` is the fastest library routine for memory-to-memory copy. It is usually more efficient than [`strcpy`](strcpy \"c/string/byte/strcpy\"), which must scan the data it copies or [`memmove`](memmove \"c/string/byte/memmove\"), which must take precautions to handle overlapping inputs.\n\nSeveral C compilers transform suitable memory-copying loops to `memcpy` calls.\n\nWhere [strict aliasing](../../language/object#Strict_aliasing \"c/language/object\") prohibits examining the same memory as values of two different types, `memcpy` may be used to convert the values.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    // simple usage\n    char source[] = \"once upon a midnight dreary...\", dest[4];\n    memcpy(dest, source, sizeof dest);\n    for(size_t n = 0; n < sizeof dest; ++n)\n        putchar(dest[n]);\n \n    // setting effective type of allocated memory to be int\n    int *p = malloc(3*sizeof(int));   // allocated memory has no effective type\n    int arr[3] = {1,2,3};\n    memcpy(p,arr,3*sizeof(int));      // allocated memory now has an effective type\n \n    // reinterpreting data\n    double d = 0.1;\n//    int64_t n = *(int64_t*)(&d); // strict aliasing violation\n    int64_t n;\n    memcpy(&n, &d, sizeof d); // OK\n    printf(\"\\n%a is %\" PRIx64 \" as an int64_t\\n\", d, n);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    char src[] = \"aaaaaaaaaa\";\n    char dst[] = \"xyxyxyxyxy\";\n    int r = memcpy_s(dst,sizeof dst,src,5);\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst,r);\n    r = memcpy_s(dst,5,src,10);            //  count is greater than destsz  \n    printf(\"dst = \\\"\");\n    for(size_t ndx=0; ndx<sizeof dst; ++ndx) {\n        char c = dst[ndx];\n        c ? printf(\"%c\", c) : printf(\"\\\\0\");\n    }\n    printf(\"\\\", r = %d\\n\", r);\n#endif\n}\n```\n\nPossible output:\n\n```\nonce\n0x1.999999999999ap-4 is 3fb999999999999a as an int64_t\ndst = \"aaaaayxyxy\", r = 0\ndst = \"\\0\\0\\0\\0\\0yxyxy\", r = 22\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.2.1 The memcpy function (p: 362)\n  - K.3.7.1.1 The memcpy_s function (p: 614)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.2.1 The memcpy function (p: 325)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.2.1 The memcpy function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/memcpy](https://en.cppreference.com/w/c/string/byte/memcpy)"
- name: memcpy_s
  summary: memcpy may be used to set the effective type of an object obtained by an allocation function
  description: "# memcpy, memcpy_s\n\n[TABLE]\n\n1) Copies `count` characters from the object pointed to by `src` to the object pointed to by `dest`. Both objects are interpreted as arrays of `unsigned char`.\n\nThe behavior is undefined if access occurs beyond the end of the `dest` array. If the objects overlap (which is a violation of the [`restrict`](../../language/restrict \"c/language/restrict\") contract)(since C99), the behavior is undefined. The behavior is undefined if either `dest` or `src` is an invalid or null pointer.\n\n2) Same as (1), except that the following errors are detected at runtime and cause the entire destination range `[dest, dest+destsz)` to be zeroed out (if both `dest` and `destsz` are valid), as well as call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `dest` or `src` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX`\n- `count` is greater than `destsz` (buffer overflow would occur)\n- the source and the destination objects overlap\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `count` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `memcpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                                                                 |\n|--------|-----|-------------------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the object to copy to                                                                |\n| destsz | \\-  | max number of bytes to modify in the destination (typically the size of the destination object) |\n| src    | \\-  | pointer to the object to copy from                                                              |\n| count  | \\-  | number of bytes to copy                                                                         |\n\n### Return value\n\n1) Returns a copy of `dest`\n\n2) Returns zero on success and non-zero value on error. Also on error, if `dest` is not a null pointer and `destsz` is valid, writes `destsz` zero bytes in to the destination array.\n\n### Notes\n\n`memcpy` may be used to set the [effective type](../../language/object#Effective_type \"c/language/object\") of an object obtained by an allocation function.\n\n`memcpy` is the fastest library routine for memory-to-memory copy. It is usually more efficient than [`strcpy`](strcpy \"c/string/byte/strcpy\"), which must scan the data it copies or [`memmove`](memmove \"c/string/byte/memmove\"), which must take precautions to handle overlapping inputs.\n\nSeveral C compilers transform suitable memory-copying loops to `memcpy` calls.\n\nWhere [strict aliasing](../../language/object#Strict_aliasing \"c/language/object\") prohibits examining the same memory as values of two different types, `memcpy` may be used to convert the values.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    // simple usage\n    char source[] = \"once upon a midnight dreary...\", dest[4];\n    memcpy(dest, source, sizeof dest);\n    for(size_t n = 0; n < sizeof dest; ++n)\n        putchar(dest[n]);\n \n    // setting effective type of allocated memory to be int\n    int *p = malloc(3*sizeof(int));   // allocated memory has no effective type\n    int arr[3] = {1,2,3};\n    memcpy(p,arr,3*sizeof(int));      // allocated memory now has an effective type\n \n    // reinterpreting data\n    double d = 0.1;\n//    int64_t n = *(int64_t*)(&d); // strict aliasing violation\n    int64_t n;\n    memcpy(&n, &d, sizeof d); // OK\n    printf(\"\\n%a is %\" PRIx64 \" as an int64_t\\n\", d, n);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    char src[] = \"aaaaaaaaaa\";\n    char dst[] = \"xyxyxyxyxy\";\n    int r = memcpy_s(dst,sizeof dst,src,5);\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst,r);\n    r = memcpy_s(dst,5,src,10);            //  count is greater than destsz  \n    printf(\"dst = \\\"\");\n    for(size_t ndx=0; ndx<sizeof dst; ++ndx) {\n        char c = dst[ndx];\n        c ? printf(\"%c\", c) : printf(\"\\\\0\");\n    }\n    printf(\"\\\", r = %d\\n\", r);\n#endif\n}\n```\n\nPossible output:\n\n```\nonce\n0x1.999999999999ap-4 is 3fb999999999999a as an int64_t\ndst = \"aaaaayxyxy\", r = 0\ndst = \"\\0\\0\\0\\0\\0yxyxy\", r = 22\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.2.1 The memcpy function (p: 362)\n  - K.3.7.1.1 The memcpy_s function (p: 614)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.2.1 The memcpy function (p: 325)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.2.1 The memcpy function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/memcpy](https://en.cppreference.com/w/c/string/byte/memcpy)"
- name: memmove
  summary: memmove may be used to set the effective type of an object obtained by an allocation function
  description: "# memmove, memmove_s\n\n[TABLE]\n\n1) Copies `count` characters from the object pointed to by `src` to the object pointed to by `dest`. Both objects are interpreted as arrays of `unsigned char`. The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to `dest`.\n\nThe behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if either `dest` or `src` is an invalid or null pointer.\n\n2) Same as (1), except when detecting the following errors at runtime, it zeroes out the entire destination range `[dest, dest+destsz)` (if both `dest` and `destsz` are valid) and calls the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `dest` or `src` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX`\n- `count` is greater than `destsz` (buffer overflow would occur)\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `count` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `memmove_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                                                                 |\n|--------|-----|-------------------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the object to copy to                                                                |\n| destsz | \\-  | max number of bytes to modify in the destination (typically the size of the destination object) |\n| src    | \\-  | pointer to the object to copy from                                                              |\n| count  | \\-  | number of bytes to copy                                                                         |\n\n### Return value\n\n1) Returns a copy of `dest`\n\n2) Returns zero on success and non-zero value on error. Also on error, if `dest` is not a null pointer and `destsz` is valid, writes `destsz` zero bytes in to the destination array.\n\n### Notes\n\n`memmove` may be used to set the [effective type](../../language/object#Effective_type \"c/language/object\") of an object obtained by an allocation function.\n\nDespite being specified \"as if\" a temporary buffer is used, actual implementations of this function do not incur the overhead or double copying or extra memory. A common approach (glibc and bsd libc) is to copy bytes forwards from the beginning of the buffer if the destination starts before the source, and backwards from the end otherwise, with a fall back to the more efficient [`memcpy`](memcpy \"c/string/byte/memcpy\") when there is no overlap at all.\n\nWhere [strict aliasing](../../language/object#Strict_aliasing \"c/language/object\") prohibits examining the same memory as values of two different types, `memmove` may be used to convert the values.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    char str[] = \"1234567890\";\n    puts(str);\n    memmove(str+4, str+3, 3); // copy from [4,5,6] to [5,6,7]\n    puts(str);\n \n    // setting effective type of allocated memory to be int\n    int *p = malloc(3*sizeof(int));   // allocated memory has no effective type\n    int arr[3] = {1,2,3};\n    memmove(p,arr,3*sizeof(int));     // allocated memory now has an effective type\n \n    // reinterpreting data\n    double d = 0.1;\n//    int64_t n = *(int64_t*)(&d); // strict aliasing violation\n    int64_t n;\n    memmove(&n, &d, sizeof d); // OK\n    printf(\"%a is %\" PRIx64 \" as an int64_t\\n\", d, n);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    char src[] = \"aaaaaaaaaa\";\n    char dst[] = \"xyxyxyxyxy\";\n    int r = memmove_s(dst,sizeof dst,src,5);\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst,r);\n    r = memmove_s(dst,5,src,10);            //  count is greater than destsz  \n    printf(\"dst = \\\"\");\n    for(size_t ndx=0; ndx<sizeof dst; ++ndx) {\n        char c = dst[ndx];\n        c ? printf(\"%c\", c) : printf(\"\\\\0\");\n    }\n    printf(\"\\\", r = %d\\n\", r);\n#endif\n}\n```\n\nPossible output:\n\n```\n1234567890\n1234456890\n0x1.999999999999ap-4 is 3fb999999999999a as an int64_t\ndst = \"aaaaayxyxy\", r = 0\ndst = \"\\0\\0\\0\\0\\0yxyxy\", r = 22\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.2.2 The memmove function (p: 264)\n  - K.3.7.1.2 The memmove_s function (p: 446)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.2.2 The memmove function (p: 363)\n  - K.3.7.1.2 The memmove_s function (p: 615)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.2.2 The memmove function (p: 326)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.2.2 The memmove function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/memmove](https://en.cppreference.com/w/c/string/byte/memmove)"
- name: memmove_s
  summary: memmove may be used to set the effective type of an object obtained by an allocation function
  description: "# memmove, memmove_s\n\n[TABLE]\n\n1) Copies `count` characters from the object pointed to by `src` to the object pointed to by `dest`. Both objects are interpreted as arrays of `unsigned char`. The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to `dest`.\n\nThe behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if either `dest` or `src` is an invalid or null pointer.\n\n2) Same as (1), except when detecting the following errors at runtime, it zeroes out the entire destination range `[dest, dest+destsz)` (if both `dest` and `destsz` are valid) and calls the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `dest` or `src` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX`\n- `count` is greater than `destsz` (buffer overflow would occur)\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `count` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `memmove_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                                                                 |\n|--------|-----|-------------------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the object to copy to                                                                |\n| destsz | \\-  | max number of bytes to modify in the destination (typically the size of the destination object) |\n| src    | \\-  | pointer to the object to copy from                                                              |\n| count  | \\-  | number of bytes to copy                                                                         |\n\n### Return value\n\n1) Returns a copy of `dest`\n\n2) Returns zero on success and non-zero value on error. Also on error, if `dest` is not a null pointer and `destsz` is valid, writes `destsz` zero bytes in to the destination array.\n\n### Notes\n\n`memmove` may be used to set the [effective type](../../language/object#Effective_type \"c/language/object\") of an object obtained by an allocation function.\n\nDespite being specified \"as if\" a temporary buffer is used, actual implementations of this function do not incur the overhead or double copying or extra memory. A common approach (glibc and bsd libc) is to copy bytes forwards from the beginning of the buffer if the destination starts before the source, and backwards from the end otherwise, with a fall back to the more efficient [`memcpy`](memcpy \"c/string/byte/memcpy\") when there is no overlap at all.\n\nWhere [strict aliasing](../../language/object#Strict_aliasing \"c/language/object\") prohibits examining the same memory as values of two different types, `memmove` may be used to convert the values.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    char str[] = \"1234567890\";\n    puts(str);\n    memmove(str+4, str+3, 3); // copy from [4,5,6] to [5,6,7]\n    puts(str);\n \n    // setting effective type of allocated memory to be int\n    int *p = malloc(3*sizeof(int));   // allocated memory has no effective type\n    int arr[3] = {1,2,3};\n    memmove(p,arr,3*sizeof(int));     // allocated memory now has an effective type\n \n    // reinterpreting data\n    double d = 0.1;\n//    int64_t n = *(int64_t*)(&d); // strict aliasing violation\n    int64_t n;\n    memmove(&n, &d, sizeof d); // OK\n    printf(\"%a is %\" PRIx64 \" as an int64_t\\n\", d, n);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    char src[] = \"aaaaaaaaaa\";\n    char dst[] = \"xyxyxyxyxy\";\n    int r = memmove_s(dst,sizeof dst,src,5);\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst,r);\n    r = memmove_s(dst,5,src,10);            //  count is greater than destsz  \n    printf(\"dst = \\\"\");\n    for(size_t ndx=0; ndx<sizeof dst; ++ndx) {\n        char c = dst[ndx];\n        c ? printf(\"%c\", c) : printf(\"\\\\0\");\n    }\n    printf(\"\\\", r = %d\\n\", r);\n#endif\n}\n```\n\nPossible output:\n\n```\n1234567890\n1234456890\n0x1.999999999999ap-4 is 3fb999999999999a as an int64_t\ndst = \"aaaaayxyxy\", r = 0\ndst = \"\\0\\0\\0\\0\\0yxyxy\", r = 22\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.2.2 The memmove function (p: 264)\n  - K.3.7.1.2 The memmove_s function (p: 446)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.2.2 The memmove function (p: 363)\n  - K.3.7.1.2 The memmove_s function (p: 615)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.2.2 The memmove function (p: 326)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.2.2 The memmove function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/memmove](https://en.cppreference.com/w/c/string/byte/memmove)"
- name: Memory model
  summary: Defines the semantics of computer memory storage for the purpose of the C abstract machine
  description: "# Memory model\n\nDefines the semantics of computer memory storage for the purpose of the C abstract machine.\n\nThe data storage (memory) available to a C program is one or more contiguous sequences of *bytes*. Each byte in memory has a unique *address*.\n\n### Byte\n\nA *byte* is the smallest addressable unit of memory. It is defined as a contiguous sequence of bits, large enough to hold any member of the *basic execution character set* ([the 96 characters](translation_phases \"c/language/translation phases\") that are required to be single-byte). C supports bytes of sizes 8 bits and greater.\n\nThe [types](types \"c/language/types\") `char`, `unsigned char`, and `signed char` use one byte for both storage and [value representation](object \"c/language/object\"). The number of bits in a byte is accessible as [`CHAR_BIT`](../types/limits \"c/types/limits\").\n\nFor use of bytes to representation values of other fundamental types (including big-endian and little-endian memory layouts), see [object representation](object#Object_representation \"c/language/object\")\n\n### Memory location\n\nA *memory location* is\n\n- an object of [scalar type](type#Type_groups \"c/language/type\") (arithmetic type, pointer type, enumeration type)\n- or the largest contiguous sequence of [bit-fields](bit_field \"c/language/bit field\") of non-zero length\n\n```\nstruct S\n{\n    char a;     // memory location #1\n    int b : 5;  // memory location #2\n    int c : 11, // memory location #2 (continued)\n          : 0,\n        d : 8;  // memory location #3\n    struct\n    {\n        int ee : 8; // memory location #4\n    } e;\n} obj; // The object 'obj' consists of 4 separate memory locations\n```\n\n[TABLE]\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 3.6 byte (p: 4)\n  - 3.14 memory location (p: 5)\n  - 5.1.2.4 Multi-threaded executions and data races (p: 17-21)\n- C99 standard (ISO/IEC 9899:1999):\n  - 3.6 byte (p: 4)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 1.6 DEFINITIONS OF TERMS\n\n### See also\n\n|                                                                                                                           |     |\n|---------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/memory_model \"cpp/language/memory model\") for Memory model |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/memory_model](https://en.cppreference.com/w/c/language/memory_model)"
- name: memory_order
  summary: memory_order specifies how memory accesses, including regular, non-atomic memory accesses, are to be ordered around an atomic operation
  description: "# memory_order\n\n[TABLE]\n\n`memory_order` specifies how memory accesses, including regular, non-atomic memory accesses, are to be ordered around an atomic operation. Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.\n\nThe default behavior of all atomic operations in the [language](../language/atomic \"c/language/atomic\") and the library provides for *sequentially consistent ordering* (see discussion below). That default can hurt performance, but the library's atomic operations can be given an additional `memory_order` argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce for that operation.\n\n### Constants\n\n| Defined in header `<stdatomic.h>` |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|-----------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Value                             | Explanation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| `memory_order_relaxed`            | Relaxed operation: there are no synchronization or ordering constraints imposed on other reads or writes, only this operation's atomicity is guaranteed (see [Relaxed ordering](#Relaxed_ordering) below).                                                                                                                                                                                                                                                                                                               |\n| `memory_order_consume`            | A load operation with this memory order performs a *consume operation* on the affected memory location: no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only (see [Release-Consume ordering](#Release-Consume_ordering) below).                                  |\n| `memory_order_acquire`            | A load operation with this memory order performs the *acquire operation* on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see [Release-Acquire ordering](#Release-Acquire_ordering) below).                                                                                                                                                             |\n| `memory_order_release`            | A store operation with this memory order performs the *release operation*: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see [Release-Acquire ordering](#Release-Acquire_ordering) below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see [Release-Consume ordering](#Release-Consume_ordering) below). |\n| `memory_order_acq_rel`            | A read-modify-write operation with this memory order is both an *acquire operation* and a *release operation*. No memory reads or writes in the current thread can be reordered before the load, nor after the store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.                                                                                                      |\n| `memory_order_seq_cst`            | A load operation with this memory order performs an *acquire operation*, a store performs a *release operation*, and read-modify-write performs both an *acquire operation* and a *release operation*, plus a single total order exists in which all threads observe all modifications in the same order (see [Sequentially-consistent ordering](#Sequentially-consistent_ordering) below).                                                                                                                              |\n\n#### Relaxed ordering\n\nAtomic operations tagged `memory_order_relaxed` are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.\n\nFor example, with `x` and `y` initially zero,\n\n`// Thread 1:`  \n`r1 ``=`` `[`atomic_load_explicit`](http://en.cppreference.com/w/c/atomic/atomic_load)`(``y, memory_order_relaxed``)``;`` ``// A`  \n[`atomic_store_explicit`](http://en.cppreference.com/w/c/atomic/atomic_store)`(``x, r1, memory_order_relaxed``)``;`` ``// B`  \n`// Thread 2:`  \n`r2 ``=`` `[`atomic_load_explicit`](http://en.cppreference.com/w/c/atomic/atomic_load)`(``x, memory_order_relaxed``)``;`` ``// C`  \n[`atomic_store_explicit`](http://en.cppreference.com/w/c/atomic/atomic_store)`(``y, ``42``, memory_order_relaxed``)``;`` ``// D`\n\nis allowed to produce `r1 == r2 == 42` because, although A is *sequenced-before* B within thread 1 and C is *sequenced before* D within thread 2, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x. The side-effect of D on y could be visible to the load A in thread 1 while the side effect of B on x could be visible to the load C in thread 2. In particular, this may occur if D is completed before C in thread 2, either due to compiler reordering or at runtime.\n\nTypical use for relaxed memory ordering is incrementing counters, such as the reference counters , since this only requires atomicity, but not ordering or synchronization .\n\n#### Release-Consume ordering\n\nIf an atomic store in thread A is tagged `memory_order_release`, an atomic load in thread B from the same variable is tagged `memory_order_consume`, and the load in thread B reads a value written by the store in thread A, then the store in thread A is *dependency-ordered before* the load in thread B.\n\nAll memory writes (non-atomic and relaxed atomic) that *happened-before* the atomic store from the point of view of thread A, become *visible side-effects* within those operations in thread B into which the load operation *carries dependency*, that is, once the atomic load is completed, those operators and functions in thread B that use the value obtained from the load are guaranteed to see what thread A wrote to memory.\n\nThe synchronization is established only between the threads *releasing* and *consuming* the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.\n\nOn all mainstream CPUs other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain).\n\nTypical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is [rcu_dereference](https://en.wikipedia.org/wiki/Read-copy-update \"enwiki:Read-copy-update\").\n\nNote that currently (2/2015) no known production compilers track dependency chains: consume operations are lifted to acquire operations.\n\n#### Release sequence\n\nIf some atomic is store-released and several other threads perform read-modify-write operations on that atomic, a \"release sequence\" is formed: all threads that perform the read-modify-writes to the same atomic synchronize with the first thread and each other even if they have no `memory_order_release` semantics. This makes single producer - multiple consumers situations possible without imposing unnecessary synchronization between individual consumer threads.\n\n#### Release-Acquire ordering\n\nIf an atomic store in thread A is tagged `memory_order_release`, an atomic load in thread B from the same variable is tagged `memory_order_acquire`, and the load in thread B reads a value written by the store in thread A, then the store in thread A *synchronizes-with* the load in thread B.\n\nAll memory writes (including non-atomic and relaxed atomic) that *happened-before* the atomic store from the point of view of thread A, become *visible side-effects* in thread B. That is, once the atomic load is completed, thread B is guaranteed to see everything thread A wrote to memory. This promise only holds if B actually returns the value that A stored, or a value from later in the release sequence.\n\nThe synchronization is established only between the threads *releasing* and *acquiring* the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.\n\nOn strongly-ordered systems — x86, SPARC TSO, IBM mainframe, etc. — release-acquire ordering is automatic for the majority of operations. No additional CPU instructions are issued for this synchronization mode; only certain compiler optimizations are affected (e.g., the compiler is prohibited from moving non-atomic stores past the atomic store-release or performing non-atomic loads earlier than the atomic load-acquire). On weakly-ordered systems (ARM, Itanium, PowerPC), special CPU load or memory fence instructions are used.\n\nMutual exclusion locks, such as [mutexes](../thread#Mutual_exclusion \"c/thread\") or [atomic spinlocks](atomic_flag_test_and_set \"c/atomic/atomic flag test and set\"), are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.\n\n#### Sequentially-consistent ordering\n\nAtomic operations tagged `memory_order_seq_cst` not only order memory the same way as release/acquire ordering (everything that *happened-before* a store in one thread becomes a *visible side effect* in the thread that did a load), but also establish a *single total modification order* of all atomic operations that are so tagged.\n\nFormally,\n\neach `memory_order_seq_cst` operation B that loads from atomic variable M, observes one of the following:\n\n- the result of the last operation A that modified M, which appears before B in the single total order,\n- OR, if there was such an A, B may observe the result of some modification on M that is not `memory_order_seq_cst` and does not *happen-before* A,\n- OR, if there wasn't such an A, B may observe the result of some unrelated modification of M that is not `memory_order_seq_cst`.\n\nIf there was a `memory_order_seq_cst` [`atomic_thread_fence`](atomic_thread_fence \"c/atomic/atomic thread fence\") operation X *sequenced-before* B, then B observes one of the following:\n\n- the last `memory_order_seq_cst` modification of M that appears before X in the single total order,\n- some unrelated modification of M that appears later in M's modification order.\n\nFor a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two `memory_order_seq_cst` [`atomic_thread_fence`](atomic_thread_fence \"c/atomic/atomic thread fence\")s X and Y, and if A is *sequenced-before* X, Y is *sequenced-before* B, and X appears before Y in the Single Total Order, then B observes either:\n\n- the effect of A,\n- some unrelated modification of M that appears after A in M's modification order.\n\nFor a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if\n\n- there is a `memory_order_seq_cst` [`atomic_thread_fence`](atomic_thread_fence \"c/atomic/atomic thread fence\") X such that A is *sequenced-before* X and X appears before B in the Single Total Order,\n- or, there is a `memory_order_seq_cst` [`atomic_thread_fence`](atomic_thread_fence \"c/atomic/atomic thread fence\") Y such that Y is *sequenced-before* B and A appears before Y in the Single Total Order,\n- or, there are `memory_order_seq_cst` [`atomic_thread_fence`](atomic_thread_fence \"c/atomic/atomic thread fence\")s X and Y such that A is *sequenced-before* X, Y is *sequenced-before* B, and X appears before Y in the Single Total Order.\n\nNote that this means that:\n\n1) as soon as atomic operations that are not tagged `memory_order_seq_cst` enter the picture, the sequential consistency is lost,\n\n2) the sequentially-consistent fences are only establishing total ordering for the fences themselves, not for the atomic operations in the general case (*sequenced-before* is not a cross-thread relationship, unlike *happens-before*).\n\nSequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.\n\nTotal sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.\n\n### Relationship with volatile\n\nWithin a thread of execution, accesses (reads and writes) through [volatile lvalues](../language/volatile \"c/language/volatile\") cannot be reordered past observable side-effects (including other volatile accesses) that are separated by a sequence point within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization.\n\nIn addition, volatile accesses are not atomic (concurrent read and write is a [data race](../language/memory_model \"c/language/memory model\")) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).\n\nOne notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics ([Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/volatile-cpp)), and thus volatiles may be used for inter-thread synchronization. Standard `volatile` semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a [`signal`](../program/signal \"c/program/signal\") handler that runs in the same thread when applied to [`sig_atomic_t`](http://en.cppreference.com/w/c/program/sig_atomic_t) variables.\n\n### Examples\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.17.1/4 memory_order (p: 200)\n  - 7.17.3 Order and consistency (p: 201-203)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.17.1/4 memory_order (p: 273)\n  - 7.17.3 Order and consistency (p: 275-277)\n\n### See also\n\n|                                                                                                                       |     |\n|-----------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/atomic/memory_order \"cpp/atomic/memory order\") for memory order |     |\n\n### External links\n\n|     |                                                                                                                                                                                                         |\n|-----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 1\\. | [MOESI protocol](https://en.wikipedia.org/wiki/MOESI_protocol \"enwiki:MOESI protocol\")                                                                                                                  |\n| 2\\. | [x86-TSO: A Rigorous and Usable Programmer’s Model for x86 Multiprocessors](https://www.cl.cam.ac.uk/~pes20/weakmemory/cacm.pdf) P. Sewell et. al., 2010                                                |\n| 3\\. | [A Tutorial Introduction to the ARM and POWER Relaxed Memory Models](https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf) P. Sewell et al, 2012                                                  |\n| 4\\. | [MESIF: A Two-Hop Cache Coherency Protocol for Point-to-Point Interconnects](https://researchspace.auckland.ac.nz/bitstream/handle/2292/11594/MESIF-2009.pdf?sequence=6) J.R. Goodman, H.H.J. Hum, 2009 |\n| 5\\. | [Memory Models](https://research.swtch.com/mm) Russ Cox, 2021                                                                                                                                           |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/atomic/memory_order](https://en.cppreference.com/w/c/atomic/memory_order)"
- name: memset
  summary: memset may be optimized away (under the as-if rules) if the object modified by this function is not accessed again for the rest of its lifetime (e.g., gcc bug 8537)
  description: "# memset, memset_explicit, memset_s\n\n[TABLE]\n\n1) Copies the value `(unsigned char)ch` into each of the first `count` characters of the object pointed to by `dest`.\n\nThe behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if `dest` is a null pointer.\n\n2) Same as (1), except that is safe for sensitive information.\n\n3) Same as (1), except that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function after storing `ch` in every location of the destination range `[dest, dest+destsz)` if `dest` and `destsz` are themselves valid:\n\n- `dest` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX`\n- `count` is greater than `destsz` (buffer overflow would occur)\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `count` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `memset_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                               |\n|--------|-----|-------------------------------|\n| dest   | \\-  | pointer to the object to fill |\n| ch     | \\-  | fill byte                     |\n| count  | \\-  | number of bytes to fill       |\n| destsz | \\-  | size of the destination array |\n\n### Return value\n\n1,2) A copy of `dest`\n\n3) zero on success, non-zero on error. Also on error, if `dest` is not a null pointer and `destsz` is valid, writes `destsz` fill bytes `ch` to the destination array.\n\n### Notes\n\n`memset` may be optimized away (under the [as-if](../../language/as_if \"c/language/as if\") rules) if the object modified by this function is not accessed again for the rest of its lifetime (e.g., [gcc bug 8537](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537)). For that reason, this function cannot be used to scrub memory (e.g., to fill an array that stored a password with zeroes).\n\nThis optimization is prohibited for `memset_explicit` and `memset_s`: they are guaranteed to perform the memory write.\n\nThird-party solutions for that include FreeBSD [`explicit_bzero`](https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero) or Microsoft [`SecureZeroMemory`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366877.aspx).\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    char str[] = \"ghghghghghghghghghghgh\";\n    puts(str);\n    memset(str,'a',5);\n    puts(str);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    int r = memset_s(str, sizeof str, 'b', 5);\n    printf(\"str = \\\"%s\\\", r = %d\\n\", str, r);\n    r = memset_s(str, 5, 'c', 10);   // count is greater than destsz  \n    printf(\"str = \\\"%s\\\", r = %d\\n\", str, r);\n#endif\n}\n```\n\nPossible output:\n\n```\nghghghghghghghghghghgh\naaaaahghghghghghghghgh\nstr = \"bbbbbhghghghghghghghgh\", r = 0\nstr = \"ccccchghghghghghghghgh\", r = 22\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.6.1 The memset function (p: 270)\n  - K.3.7.4.1 The memset_s function (p: 451)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.6.1 The memset function (p: 371)\n  - K.3.7.4.1 The memset_s function (p: 621-622)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.6.1 The memset function (p: 333)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.6.1 The memset function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/memset](https://en.cppreference.com/w/c/string/byte/memset)"
- name: memset_explicit
  summary: memset may be optimized away (under the as-if rules) if the object modified by this function is not accessed again for the rest of its lifetime (e.g., gcc bug 8537)
  description: "# memset, memset_explicit, memset_s\n\n[TABLE]\n\n1) Copies the value `(unsigned char)ch` into each of the first `count` characters of the object pointed to by `dest`.\n\nThe behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if `dest` is a null pointer.\n\n2) Same as (1), except that is safe for sensitive information.\n\n3) Same as (1), except that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function after storing `ch` in every location of the destination range `[dest, dest+destsz)` if `dest` and `destsz` are themselves valid:\n\n- `dest` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX`\n- `count` is greater than `destsz` (buffer overflow would occur)\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `count` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `memset_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                               |\n|--------|-----|-------------------------------|\n| dest   | \\-  | pointer to the object to fill |\n| ch     | \\-  | fill byte                     |\n| count  | \\-  | number of bytes to fill       |\n| destsz | \\-  | size of the destination array |\n\n### Return value\n\n1,2) A copy of `dest`\n\n3) zero on success, non-zero on error. Also on error, if `dest` is not a null pointer and `destsz` is valid, writes `destsz` fill bytes `ch` to the destination array.\n\n### Notes\n\n`memset` may be optimized away (under the [as-if](../../language/as_if \"c/language/as if\") rules) if the object modified by this function is not accessed again for the rest of its lifetime (e.g., [gcc bug 8537](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537)). For that reason, this function cannot be used to scrub memory (e.g., to fill an array that stored a password with zeroes).\n\nThis optimization is prohibited for `memset_explicit` and `memset_s`: they are guaranteed to perform the memory write.\n\nThird-party solutions for that include FreeBSD [`explicit_bzero`](https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero) or Microsoft [`SecureZeroMemory`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366877.aspx).\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    char str[] = \"ghghghghghghghghghghgh\";\n    puts(str);\n    memset(str,'a',5);\n    puts(str);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    int r = memset_s(str, sizeof str, 'b', 5);\n    printf(\"str = \\\"%s\\\", r = %d\\n\", str, r);\n    r = memset_s(str, 5, 'c', 10);   // count is greater than destsz  \n    printf(\"str = \\\"%s\\\", r = %d\\n\", str, r);\n#endif\n}\n```\n\nPossible output:\n\n```\nghghghghghghghghghghgh\naaaaahghghghghghghghgh\nstr = \"bbbbbhghghghghghghghgh\", r = 0\nstr = \"ccccchghghghghghghghgh\", r = 22\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.6.1 The memset function (p: 270)\n  - K.3.7.4.1 The memset_s function (p: 451)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.6.1 The memset function (p: 371)\n  - K.3.7.4.1 The memset_s function (p: 621-622)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.6.1 The memset function (p: 333)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.6.1 The memset function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/memset](https://en.cppreference.com/w/c/string/byte/memset)"
- name: memset_s
  summary: memset may be optimized away (under the as-if rules) if the object modified by this function is not accessed again for the rest of its lifetime (e.g., gcc bug 8537)
  description: "# memset, memset_explicit, memset_s\n\n[TABLE]\n\n1) Copies the value `(unsigned char)ch` into each of the first `count` characters of the object pointed to by `dest`.\n\nThe behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if `dest` is a null pointer.\n\n2) Same as (1), except that is safe for sensitive information.\n\n3) Same as (1), except that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function after storing `ch` in every location of the destination range `[dest, dest+destsz)` if `dest` and `destsz` are themselves valid:\n\n- `dest` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX`\n- `count` is greater than `destsz` (buffer overflow would occur)\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `count` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `memset_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                               |\n|--------|-----|-------------------------------|\n| dest   | \\-  | pointer to the object to fill |\n| ch     | \\-  | fill byte                     |\n| count  | \\-  | number of bytes to fill       |\n| destsz | \\-  | size of the destination array |\n\n### Return value\n\n1,2) A copy of `dest`\n\n3) zero on success, non-zero on error. Also on error, if `dest` is not a null pointer and `destsz` is valid, writes `destsz` fill bytes `ch` to the destination array.\n\n### Notes\n\n`memset` may be optimized away (under the [as-if](../../language/as_if \"c/language/as if\") rules) if the object modified by this function is not accessed again for the rest of its lifetime (e.g., [gcc bug 8537](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537)). For that reason, this function cannot be used to scrub memory (e.g., to fill an array that stored a password with zeroes).\n\nThis optimization is prohibited for `memset_explicit` and `memset_s`: they are guaranteed to perform the memory write.\n\nThird-party solutions for that include FreeBSD [`explicit_bzero`](https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero) or Microsoft [`SecureZeroMemory`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366877.aspx).\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    char str[] = \"ghghghghghghghghghghgh\";\n    puts(str);\n    memset(str,'a',5);\n    puts(str);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    int r = memset_s(str, sizeof str, 'b', 5);\n    printf(\"str = \\\"%s\\\", r = %d\\n\", str, r);\n    r = memset_s(str, 5, 'c', 10);   // count is greater than destsz  \n    printf(\"str = \\\"%s\\\", r = %d\\n\", str, r);\n#endif\n}\n```\n\nPossible output:\n\n```\nghghghghghghghghghghgh\naaaaahghghghghghghghgh\nstr = \"bbbbbhghghghghghghghgh\", r = 0\nstr = \"ccccchghghghghghghghgh\", r = 22\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.6.1 The memset function (p: 270)\n  - K.3.7.4.1 The memset_s function (p: 451)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.6.1 The memset function (p: 371)\n  - K.3.7.4.1 The memset_s function (p: 621-622)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.6.1 The memset function (p: 333)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.6.1 The memset function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/memset](https://en.cppreference.com/w/c/string/byte/memset)"
- name: mktime
  summary: Renormalizes local calendar time expressed as a struct tm object and also converts it to time since epoch as a time_t object
  description: "# mktime\n\n[TABLE]\n\nRenormalizes local calendar time expressed as a [`struct tm`](tm \"c/chrono/tm\") object and also converts it to time since epoch as a [`time_t`](time_t \"c/chrono/time t\") object. `arg->tm_wday` and `arg->tm_yday` are ignored. The values in `arg` are not checked for being out of range.\n\nA negative value of `arg->tm_isdst` causes `mktime` to attempt to determine if Daylight Saving Time was in effect in the specified time.\n\nIf the conversion to `time_t` is successful, the `arg` object is modified. All fields of `arg` are updated to fit their proper ranges. `arg->tm_wday` and `arg->tm_yday` are recalculated using information available in other fields.\n\n### Parameters\n\n|     |     |                                                                                        |\n|-----|-----|----------------------------------------------------------------------------------------|\n| arg | \\-  | pointer to a [`tm`](tm \"c/chrono/tm\") object specifying local calendar time to convert |\n\n### Return value\n\ntime since epoch as a [`time_t`](time_t \"c/chrono/time t\") object on success, or `-1` if `arg` cannot be represented as a [`time_t`](time_t \"c/chrono/time t\") object (POSIX also requires `EOVERFLOW` to be stored in [`errno`](../error/errno \"c/error/errno\") in this case).\n\n### Notes\n\nIf the `struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm) object was obtained from POSIX [`strptime`](http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html) or equivalent function, the value of `tm_isdst` is indeterminate, and needs to be set explicitly before calling `mktime`.\n\n### Example\n\n```\n#define _POSIX_C_SOURCE 200112L // for setenv on gcc\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    setenv(\"TZ\", \"/usr/share/zoneinfo/America/New_York\", 1); // POSIX-specific\n \n    struct tm tm = *localtime(&(time_t){time(NULL)});\n    printf(\"Today is           %s\", asctime(&tm));\n    printf(\"(DST is %s)\\n\", tm.tm_isdst ? \"in effect\" : \"not in effect\");\n    tm.tm_mon -= 100;  // tm_mon is now outside its normal range\n    mktime(&tm);       // tm_isdst is not set to -1; today's DST status is used\n    printf(\"100 months ago was %s\", asctime(&tm));\n    printf(\"(DST was %s)\\n\", tm.tm_isdst ? \"in effect\" : \"not in effect\");\n}\n```\n\nPossible output:\n\n```\nToday is           Fri Apr 22 11:53:36 2016\n(DST is in effect)\n100 months ago was Sat Dec 22 10:53:36 2007\n(DST was not in effect)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.2.3 The mktime function (p: 285-286)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.2.3 The mktime function (p: 390-391)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.2.3 The mktime function (p: 340-341)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.2.3 The mktime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/mktime](https://en.cppreference.com/w/c/chrono/mktime)"
- name: modf
  summary: If no errors occur, returns the fractional part of x with the same sign as x
  description: "# modf, modff, modfl\n\n[TABLE]\n\n1-3) Decomposes given floating point value `arg` into integral and fractional parts, each having the same type and sign as `arg`. The integral part (in floating-point format) is stored in the object pointed to by `iptr`.\n\n### Parameters\n\n|      |     |                                                               |\n|------|-----|---------------------------------------------------------------|\n| arg  | \\-  | floating point value                                          |\n| iptr | \\-  | pointer to floating point value to store the integral part to |\n\n### Return value\n\nIf no errors occur, returns the fractional part of `x` with the same sign as `x`. The integral part is put into the value pointed to by `iptr`.\n\nThe sum of the returned value and the value stored in `*iptr` gives `arg` (allowing for rounding).\n\n### Error handling\n\nThis function is not subject to any errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `arg` is ±0, ±0 is returned, and ±0 is stored in `*iptr`.\n- If `arg` is ±∞, ±0 is returned, and ±∞ is stored in `*iptr`.\n- If `arg` is NaN, NaN is returned, and NaN is stored in `*iptr`.\n- The returned value is exact, [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\nThis function behaves as if implemented as follows:\n\n```\ndouble modf(double value, double *iptr)\n{\n#pragma STDC FENV_ACCESS ON\n    int save_round = fegetround();\n    fesetround(FE_TOWARDZERO);\n    *iptr = std::nearbyint(value);\n    fesetround(save_round);\n    return copysign(isinf(value) ? 0.0 : value - (*iptr), value);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.2f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = ilogb(f);\n    printf(\"logb()/ilogb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n \n    // special values\n    f2 = modf(-0.0, &f3);\n    printf(\"modf(-0) makes %.2f + %.2f\\n\", f3, f2);\n    f2 = modf(-INFINITY, &f3);\n    printf(\"modf(-Inf) makes %.2f + %.2f\\n\", f3, f2);\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123.00 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nmodf(-0) makes -0.00 + -0.00\nmodf(-Inf) makes -INF + -0.00\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.12 The modf functions (p: 246-247)\n  - F.10.3.12 The modf functions (p: 523)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.12 The modf functions (p: 227)\n  - F.9.3.12 The modf functions (p: 460)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.6 The modf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/modf](https://en.cppreference.com/w/c/numeric/math/modf)"
- name: modff
  summary: If no errors occur, returns the fractional part of x with the same sign as x
  description: "# modf, modff, modfl\n\n[TABLE]\n\n1-3) Decomposes given floating point value `arg` into integral and fractional parts, each having the same type and sign as `arg`. The integral part (in floating-point format) is stored in the object pointed to by `iptr`.\n\n### Parameters\n\n|      |     |                                                               |\n|------|-----|---------------------------------------------------------------|\n| arg  | \\-  | floating point value                                          |\n| iptr | \\-  | pointer to floating point value to store the integral part to |\n\n### Return value\n\nIf no errors occur, returns the fractional part of `x` with the same sign as `x`. The integral part is put into the value pointed to by `iptr`.\n\nThe sum of the returned value and the value stored in `*iptr` gives `arg` (allowing for rounding).\n\n### Error handling\n\nThis function is not subject to any errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `arg` is ±0, ±0 is returned, and ±0 is stored in `*iptr`.\n- If `arg` is ±∞, ±0 is returned, and ±∞ is stored in `*iptr`.\n- If `arg` is NaN, NaN is returned, and NaN is stored in `*iptr`.\n- The returned value is exact, [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\nThis function behaves as if implemented as follows:\n\n```\ndouble modf(double value, double *iptr)\n{\n#pragma STDC FENV_ACCESS ON\n    int save_round = fegetround();\n    fesetround(FE_TOWARDZERO);\n    *iptr = std::nearbyint(value);\n    fesetround(save_round);\n    return copysign(isinf(value) ? 0.0 : value - (*iptr), value);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.2f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = ilogb(f);\n    printf(\"logb()/ilogb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n \n    // special values\n    f2 = modf(-0.0, &f3);\n    printf(\"modf(-0) makes %.2f + %.2f\\n\", f3, f2);\n    f2 = modf(-INFINITY, &f3);\n    printf(\"modf(-Inf) makes %.2f + %.2f\\n\", f3, f2);\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123.00 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nmodf(-0) makes -0.00 + -0.00\nmodf(-Inf) makes -INF + -0.00\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.12 The modf functions (p: 246-247)\n  - F.10.3.12 The modf functions (p: 523)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.12 The modf functions (p: 227)\n  - F.9.3.12 The modf functions (p: 460)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.6 The modf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/modf](https://en.cppreference.com/w/c/numeric/math/modf)"
- name: modfl
  summary: If no errors occur, returns the fractional part of x with the same sign as x
  description: "# modf, modff, modfl\n\n[TABLE]\n\n1-3) Decomposes given floating point value `arg` into integral and fractional parts, each having the same type and sign as `arg`. The integral part (in floating-point format) is stored in the object pointed to by `iptr`.\n\n### Parameters\n\n|      |     |                                                               |\n|------|-----|---------------------------------------------------------------|\n| arg  | \\-  | floating point value                                          |\n| iptr | \\-  | pointer to floating point value to store the integral part to |\n\n### Return value\n\nIf no errors occur, returns the fractional part of `x` with the same sign as `x`. The integral part is put into the value pointed to by `iptr`.\n\nThe sum of the returned value and the value stored in `*iptr` gives `arg` (allowing for rounding).\n\n### Error handling\n\nThis function is not subject to any errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If `arg` is ±0, ±0 is returned, and ±0 is stored in `*iptr`.\n- If `arg` is ±∞, ±0 is returned, and ±∞ is stored in `*iptr`.\n- If `arg` is NaN, NaN is returned, and NaN is stored in `*iptr`.\n- The returned value is exact, [the current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored\n\n### Notes\n\nThis function behaves as if implemented as follows:\n\n```\ndouble modf(double value, double *iptr)\n{\n#pragma STDC FENV_ACCESS ON\n    int save_round = fegetround();\n    fesetround(FE_TOWARDZERO);\n    *iptr = std::nearbyint(value);\n    fesetround(save_round);\n    return copysign(isinf(value) ? 0.0 : value - (*iptr), value);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n \nint main(void)\n{\n    double f = 123.45;\n    printf(\"Given the number %.2f or %a in hex,\\n\", f, f);\n \n    double f3;\n    double f2 = modf(f, &f3);\n    printf(\"modf() makes %.2f + %.2f\\n\", f3, f2);\n \n    int i;\n    f2 = frexp(f, &i);\n    printf(\"frexp() makes %f * 2^%d\\n\", f2, i);\n \n    i = ilogb(f);\n    printf(\"logb()/ilogb() make %f * %d^%d\\n\", f/scalbn(1.0, i), FLT_RADIX, i);\n \n    // special values\n    f2 = modf(-0.0, &f3);\n    printf(\"modf(-0) makes %.2f + %.2f\\n\", f3, f2);\n    f2 = modf(-INFINITY, &f3);\n    printf(\"modf(-Inf) makes %.2f + %.2f\\n\", f3, f2);\n}\n```\n\nPossible output:\n\n```\nGiven the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123.00 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nmodf(-0) makes -0.00 + -0.00\nmodf(-Inf) makes -INF + -0.00\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.12 The modf functions (p: 246-247)\n  - F.10.3.12 The modf functions (p: 523)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.12 The modf functions (p: 227)\n  - F.9.3.12 The modf functions (p: 460)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.4.6 The modf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/modf](https://en.cppreference.com/w/c/numeric/math/modf)"
- name: mtx_destroy
  summary: Destroys the mutex pointed to by mutex
  description: "# mtx_destroy\n\n[TABLE]\n\nDestroys the mutex pointed to by `mutex`.\n\nIf there are threads waiting on `mutex`, the behavior is undefined.\n\n### Parameters\n\n|       |     |                                 |\n|-------|-----|---------------------------------|\n| mutex | \\-  | pointer to the mutex to destroy |\n\n### Return value\n\n(none)\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.4.1 The mtx_destroy function (p: 277)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.4.1 The mtx_destroy function (p: 380)\n\n### See also\n\n|                                                                                                                                                                                                     |     |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/mutex/%7Emutex \"cpp/thread/mutex/~mutex\") for `~mutex`                                                                                 |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/timed_mutex/%7Etimed_mutex \"cpp/thread/timed mutex/~timed mutex\") for `~timed_mutex`                                                   |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/recursive_mutex/%7Erecursive_mutex \"cpp/thread/recursive mutex/~recursive mutex\") for `~recursive_mutex`                               |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/recursive_timed_mutex/%7Erecursive_timed_mutex \"cpp/thread/recursive timed mutex/~recursive timed mutex\") for `~recursive_timed_mutex` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/mtx_destroy](https://en.cppreference.com/w/c/thread/mtx_destroy)"
- name: mtx_init
  summary: Creates a new mutex object with type
  description: "# mtx_init\n\n[TABLE]\n\nCreates a new mutex object with `type`. The object pointed to by `mutex` is set to an identifier of the newly created mutex.\n\n`type` must have one of the following values:\n\n- [`mtx_plain`](mtx_types \"c/thread/mtx types\") - a simple, non-recursive mutex is created.\n- [`mtx_timed`](mtx_types \"c/thread/mtx types\") - a non-recursive mutex, that supports timeout, is created.\n- [`mtx_plain`](http://en.cppreference.com/w/c/thread/mtx_types)` ``|`` `[`mtx_recursive`](http://en.cppreference.com/w/c/thread/mtx_types) - a recursive mutex is created.\n- [`mtx_timed`](http://en.cppreference.com/w/c/thread/mtx_types)` ``|`` `[`mtx_recursive`](http://en.cppreference.com/w/c/thread/mtx_types) - a recursive mutex, that supports timeout, is created.\n\n### Parameters\n\n|       |     |                                    |\n|-------|-----|------------------------------------|\n| mutex | \\-  | pointer to the mutex to initialize |\n| type  | \\-  | the type of the mutex              |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") otherwise.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.4.2 The mtx_init function (p: 277-278)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.4.2 The mtx_init function (p: 381)\n\n### See also\n\n|                                                                                                                                                                                                |     |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/mutex/mutex \"cpp/thread/mutex/mutex\") for `mutex`                                                                                 |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/timed_mutex/timed_mutex \"cpp/thread/timed mutex/timed mutex\") for `timed_mutex`                                                   |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/recursive_mutex/recursive_mutex \"cpp/thread/recursive mutex/recursive mutex\") for `recursive_mutex`                               |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/recursive_timed_mutex/recursive_timed_mutex \"cpp/thread/recursive timed mutex/recursive timed mutex\") for `recursive_timed_mutex` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/mtx_init](https://en.cppreference.com/w/c/thread/mtx_init)"
- name: mtx_lock
  summary: Blocks the current thread until the mutex pointed to by mutex is locked
  description: "# mtx_lock\n\n[TABLE]\n\nBlocks the current thread until the mutex pointed to by `mutex` is locked.\n\nThe behavior is undefined if the current thread has already locked the mutex and the mutex is not recursive.\n\nPrior calls to [`mtx_unlock`](mtx_unlock \"c/thread/mtx unlock\") on the same mutex *synchronize-with* this operation, and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic)\n\n### Parameters\n\n|       |     |                              |\n|-------|-----|------------------------------|\n| mutex | \\-  | pointer to the mutex to lock |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") otherwise.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.4.3 The mtx_lock function (p: 278)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.4.3 The mtx_lock function (p: 381)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/mtx_lock](https://en.cppreference.com/w/c/thread/mtx_lock)"
- name: mtx_plain
  summary: When passed to mtx_init, identifies the type of a mutex to create
  description: "# mtx_plain, mtx_recursive, mtx_timed\n\n[TABLE]\n\nWhen passed to [`mtx_init`](mtx_init \"c/thread/mtx init\"), identifies the type of a mutex to create.\n\n| Constant        | Explanation     |\n|-----------------|-----------------|\n| `mtx_plain`     | plain mutex     |\n| `mtx_recursive` | recursive mutex |\n| `mtx_timed`     | timed mutex     |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.1/5 mtx_plain, mtx_recursive, mtx_timed (p: 274-275)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.1/5 mtx_plain, mtx_recursive, mtx_timed (p: 377)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/mtx_types](https://en.cppreference.com/w/c/thread/mtx_types)"
- name: mtx_recursive
  summary: When passed to mtx_init, identifies the type of a mutex to create
  description: "# mtx_plain, mtx_recursive, mtx_timed\n\n[TABLE]\n\nWhen passed to [`mtx_init`](mtx_init \"c/thread/mtx init\"), identifies the type of a mutex to create.\n\n| Constant        | Explanation     |\n|-----------------|-----------------|\n| `mtx_plain`     | plain mutex     |\n| `mtx_recursive` | recursive mutex |\n| `mtx_timed`     | timed mutex     |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.1/5 mtx_plain, mtx_recursive, mtx_timed (p: 274-275)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.1/5 mtx_plain, mtx_recursive, mtx_timed (p: 377)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/mtx_types](https://en.cppreference.com/w/c/thread/mtx_types)"
- name: mtx_timed
  summary: When passed to mtx_init, identifies the type of a mutex to create
  description: "# mtx_plain, mtx_recursive, mtx_timed\n\n[TABLE]\n\nWhen passed to [`mtx_init`](mtx_init \"c/thread/mtx init\"), identifies the type of a mutex to create.\n\n| Constant        | Explanation     |\n|-----------------|-----------------|\n| `mtx_plain`     | plain mutex     |\n| `mtx_recursive` | recursive mutex |\n| `mtx_timed`     | timed mutex     |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.1/5 mtx_plain, mtx_recursive, mtx_timed (p: 274-275)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.1/5 mtx_plain, mtx_recursive, mtx_timed (p: 377)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/mtx_types](https://en.cppreference.com/w/c/thread/mtx_types)"
- name: mtx_timedlock
  summary: Blocks the current thread until the mutex pointed to by mutex is locked or until the TIME_UTC based absolute calendar time point pointed to by time_point has been reached
  description: "# mtx_timedlock\n\n[TABLE]\n\nBlocks the current thread until the mutex pointed to by `mutex` is locked or until the `TIME_UTC` based absolute calendar time point pointed to by `time_point` has been reached.\n\nSince this function takes an absolute time, if a duration is required, the calendar time point must be calculated manually.\n\nThe behavior is undefined if the current thread has already locked the mutex and the mutex is not recursive.\n\nThe behavior is undefined if the mutex does not support timeout.\n\nPrior calls to [`mtx_unlock`](mtx_unlock \"c/thread/mtx unlock\") on the same mutex *synchronize-with* this operation (if this operation succeeds), and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic)\n\n### Parameters\n\n|            |     |                                                                           |\n|------------|-----|---------------------------------------------------------------------------|\n| mutex      | \\-  | pointer to the mutex to lock                                              |\n| time_point | \\-  | pointer to the absolute calendar time until which to wait for the timeout |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, `thrd_timedout` if the timeout time has been reached before the mutex is locked, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") if an error occurs.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.4.4 The mtx_timedlock function (p: 278)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.4.4 The mtx_timedlock function (p: 381-382)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                             |\n|-------------------------------------------------------------------------------------------------------------|\n| [GNU GCC Libc Manual: ISO-C-Mutexes](https://www.gnu.org/software/libc/manual/html_node/ISO-C-Mutexes.html) |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/mtx_timedlock](https://en.cppreference.com/w/c/thread/mtx_timedlock)"
- name: mtx_trylock
  summary: Tries to lock the mutex pointed to by mutex without blocking
  description: "# mtx_trylock\n\n[TABLE]\n\nTries to lock the mutex pointed to by `mutex` without blocking. Returns immediately if the mutex is already locked.\n\nPrior calls to [`mtx_unlock`](mtx_unlock \"c/thread/mtx unlock\") on the same mutex *synchronize-with* this operation (if this operation succeeds), and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic)\n\n### Parameters\n\n|       |     |                              |\n|-------|-----|------------------------------|\n| mutex | \\-  | pointer to the mutex to lock |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_busy`](thrd_errors \"c/thread/thrd errors\") if the mutex has already been locked or due to a spurious failure to acquire an available mutex, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") if an error occurs.\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                            | Correct behavior |\n|-----------------------------------------------------------------------------|------------|--------------------------------------------------|------------------|\n| [DR 470](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_470) | C11        | `mtx_trylock` was not allowed to fail spuriously | allowed          |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.4.5 The mtx_trylock function (p: 278-279)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.4.5 The mtx_trylock function (p: 382)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/mtx_trylock](https://en.cppreference.com/w/c/thread/mtx_trylock)"
- name: mtx_unlock
  summary: Unlocks the mutex pointed to by mutex
  description: "# mtx_unlock\n\n[TABLE]\n\nUnlocks the mutex pointed to by `mutex`.\n\nThe behavior is undefined if the mutex is not locked by the calling thread.\n\nThis function *synchronizes-with* subsequent [`mtx_lock`](mtx_lock \"c/thread/mtx lock\"), [`mtx_trylock`](mtx_trylock \"c/thread/mtx trylock\"), or [`mtx_timedlock`](mtx_timedlock \"c/thread/mtx timedlock\") on the same mutex. All lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic).\n\n### Parameters\n\n|       |     |                                |\n|-------|-----|--------------------------------|\n| mutex | \\-  | pointer to the mutex to unlock |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") otherwise.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.4.6 The mtx_unlock function (p: 279)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.4.6 The mtx_unlock function (p: 382)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/mtx_unlock](https://en.cppreference.com/w/c/thread/mtx_unlock)"
- name: nan
  summary: 'Converts the implementation-defined character string arg into the corresponding quiet NaN value, as if by calling the appropriate parsing function strtoX, as follows:'
  description: "# nan, nanf, nanl, nand32, nand64, nand128\n\n[TABLE]\n\nConverts the implementation-defined character string `arg` into the corresponding quiet NaN value, as if by calling the appropriate parsing function *`strtoX`*, as follows:\n\n- The call `nan(\"n-char-sequence\")`, where n-char-sequence is a sequence of digits, Latin letters, and underscores, is equivalent to the call `/*strtoX*/``(``\"NAN(n-char-sequence)\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"\")` is equivalent to the call `/*strtoX*/``(``\"NAN()\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"string\")`, where `string` is neither an n-char-sequence nor an empty string, is equivalent to the call `/*strtoX*/``(``\"NAN\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n\n1) The parsing function is [`strtof`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n2) The parsing function is [`strtod`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n3) The parsing function is [`strtold`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n4) The parsing function is `strtod32`.\n\n5) The parsing function is `strtod64`.\n\n6) The parsing function is `strtod128`.\n\n|                                                                                                                                                                                                          |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions returning decimal floating point values are declared if and only the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                           |\n|-----|-----|-----------------------------------------------------------|\n| arg | \\-  | narrow character string identifying the contents of a NaN |\n\n### Return value\n\nThe quiet NaN value that corresponds to the identifying string `arg` or zero if the implementation does not support quiet NaNs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), it also supports quiet NaNs.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n \nint main(void)\n{\n    double f1 = nan(\"1\");\n    uint64_t f1n; memcpy(&f1n, &f1, sizeof f1);\n    printf(\"nan(\\\"1\\\")   = %f (%\" PRIx64 \")\\n\", f1, f1n);\n \n    double f2 = nan(\"2\");\n    uint64_t f2n; memcpy(&f2n, &f2, sizeof f2);\n    printf(\"nan(\\\"2\\\")   = %f (%\" PRIx64 \")\\n\", f2, f2n);\n \n    double f3 = nan(\"0xF\");\n    uint64_t f3n; memcpy(&f3n, &f3, sizeof f3);\n    printf(\"nan(\\\"0xF\\\") = %f (%\" PRIx64 \")\\n\", f3, f3n);\n}\n```\n\nPossible output:\n\n```\nnan(\"1\")   = nan (7ff8000000000001)\nnan(\"2\")   = nan (7ff8000000000002)\nnan(\"0xF\") = nan (7ff800000000000f)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.2 The nan functions (p: 186-187)\n  - F.10.8.2 The nan functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.2 The nan functions (p: 256)\n  - F.10.8.2 The nan functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.2 The nan functions (p: 237)\n  - F.9.8.2 The fabs functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nan](https://en.cppreference.com/w/c/numeric/math/nan)"
- name: nand128
  summary: 'Converts the implementation-defined character string arg into the corresponding quiet NaN value, as if by calling the appropriate parsing function strtoX, as follows:'
  description: "# nan, nanf, nanl, nand32, nand64, nand128\n\n[TABLE]\n\nConverts the implementation-defined character string `arg` into the corresponding quiet NaN value, as if by calling the appropriate parsing function *`strtoX`*, as follows:\n\n- The call `nan(\"n-char-sequence\")`, where n-char-sequence is a sequence of digits, Latin letters, and underscores, is equivalent to the call `/*strtoX*/``(``\"NAN(n-char-sequence)\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"\")` is equivalent to the call `/*strtoX*/``(``\"NAN()\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"string\")`, where `string` is neither an n-char-sequence nor an empty string, is equivalent to the call `/*strtoX*/``(``\"NAN\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n\n1) The parsing function is [`strtof`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n2) The parsing function is [`strtod`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n3) The parsing function is [`strtold`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n4) The parsing function is `strtod32`.\n\n5) The parsing function is `strtod64`.\n\n6) The parsing function is `strtod128`.\n\n|                                                                                                                                                                                                          |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions returning decimal floating point values are declared if and only the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                           |\n|-----|-----|-----------------------------------------------------------|\n| arg | \\-  | narrow character string identifying the contents of a NaN |\n\n### Return value\n\nThe quiet NaN value that corresponds to the identifying string `arg` or zero if the implementation does not support quiet NaNs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), it also supports quiet NaNs.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n \nint main(void)\n{\n    double f1 = nan(\"1\");\n    uint64_t f1n; memcpy(&f1n, &f1, sizeof f1);\n    printf(\"nan(\\\"1\\\")   = %f (%\" PRIx64 \")\\n\", f1, f1n);\n \n    double f2 = nan(\"2\");\n    uint64_t f2n; memcpy(&f2n, &f2, sizeof f2);\n    printf(\"nan(\\\"2\\\")   = %f (%\" PRIx64 \")\\n\", f2, f2n);\n \n    double f3 = nan(\"0xF\");\n    uint64_t f3n; memcpy(&f3n, &f3, sizeof f3);\n    printf(\"nan(\\\"0xF\\\") = %f (%\" PRIx64 \")\\n\", f3, f3n);\n}\n```\n\nPossible output:\n\n```\nnan(\"1\")   = nan (7ff8000000000001)\nnan(\"2\")   = nan (7ff8000000000002)\nnan(\"0xF\") = nan (7ff800000000000f)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.2 The nan functions (p: 186-187)\n  - F.10.8.2 The nan functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.2 The nan functions (p: 256)\n  - F.10.8.2 The nan functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.2 The nan functions (p: 237)\n  - F.9.8.2 The fabs functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nan](https://en.cppreference.com/w/c/numeric/math/nan)"
- name: nand32
  summary: 'Converts the implementation-defined character string arg into the corresponding quiet NaN value, as if by calling the appropriate parsing function strtoX, as follows:'
  description: "# nan, nanf, nanl, nand32, nand64, nand128\n\n[TABLE]\n\nConverts the implementation-defined character string `arg` into the corresponding quiet NaN value, as if by calling the appropriate parsing function *`strtoX`*, as follows:\n\n- The call `nan(\"n-char-sequence\")`, where n-char-sequence is a sequence of digits, Latin letters, and underscores, is equivalent to the call `/*strtoX*/``(``\"NAN(n-char-sequence)\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"\")` is equivalent to the call `/*strtoX*/``(``\"NAN()\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"string\")`, where `string` is neither an n-char-sequence nor an empty string, is equivalent to the call `/*strtoX*/``(``\"NAN\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n\n1) The parsing function is [`strtof`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n2) The parsing function is [`strtod`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n3) The parsing function is [`strtold`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n4) The parsing function is `strtod32`.\n\n5) The parsing function is `strtod64`.\n\n6) The parsing function is `strtod128`.\n\n|                                                                                                                                                                                                          |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions returning decimal floating point values are declared if and only the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                           |\n|-----|-----|-----------------------------------------------------------|\n| arg | \\-  | narrow character string identifying the contents of a NaN |\n\n### Return value\n\nThe quiet NaN value that corresponds to the identifying string `arg` or zero if the implementation does not support quiet NaNs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), it also supports quiet NaNs.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n \nint main(void)\n{\n    double f1 = nan(\"1\");\n    uint64_t f1n; memcpy(&f1n, &f1, sizeof f1);\n    printf(\"nan(\\\"1\\\")   = %f (%\" PRIx64 \")\\n\", f1, f1n);\n \n    double f2 = nan(\"2\");\n    uint64_t f2n; memcpy(&f2n, &f2, sizeof f2);\n    printf(\"nan(\\\"2\\\")   = %f (%\" PRIx64 \")\\n\", f2, f2n);\n \n    double f3 = nan(\"0xF\");\n    uint64_t f3n; memcpy(&f3n, &f3, sizeof f3);\n    printf(\"nan(\\\"0xF\\\") = %f (%\" PRIx64 \")\\n\", f3, f3n);\n}\n```\n\nPossible output:\n\n```\nnan(\"1\")   = nan (7ff8000000000001)\nnan(\"2\")   = nan (7ff8000000000002)\nnan(\"0xF\") = nan (7ff800000000000f)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.2 The nan functions (p: 186-187)\n  - F.10.8.2 The nan functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.2 The nan functions (p: 256)\n  - F.10.8.2 The nan functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.2 The nan functions (p: 237)\n  - F.9.8.2 The fabs functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nan](https://en.cppreference.com/w/c/numeric/math/nan)"
- name: nand64
  summary: 'Converts the implementation-defined character string arg into the corresponding quiet NaN value, as if by calling the appropriate parsing function strtoX, as follows:'
  description: "# nan, nanf, nanl, nand32, nand64, nand128\n\n[TABLE]\n\nConverts the implementation-defined character string `arg` into the corresponding quiet NaN value, as if by calling the appropriate parsing function *`strtoX`*, as follows:\n\n- The call `nan(\"n-char-sequence\")`, where n-char-sequence is a sequence of digits, Latin letters, and underscores, is equivalent to the call `/*strtoX*/``(``\"NAN(n-char-sequence)\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"\")` is equivalent to the call `/*strtoX*/``(``\"NAN()\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"string\")`, where `string` is neither an n-char-sequence nor an empty string, is equivalent to the call `/*strtoX*/``(``\"NAN\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n\n1) The parsing function is [`strtof`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n2) The parsing function is [`strtod`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n3) The parsing function is [`strtold`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n4) The parsing function is `strtod32`.\n\n5) The parsing function is `strtod64`.\n\n6) The parsing function is `strtod128`.\n\n|                                                                                                                                                                                                          |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions returning decimal floating point values are declared if and only the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                           |\n|-----|-----|-----------------------------------------------------------|\n| arg | \\-  | narrow character string identifying the contents of a NaN |\n\n### Return value\n\nThe quiet NaN value that corresponds to the identifying string `arg` or zero if the implementation does not support quiet NaNs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), it also supports quiet NaNs.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n \nint main(void)\n{\n    double f1 = nan(\"1\");\n    uint64_t f1n; memcpy(&f1n, &f1, sizeof f1);\n    printf(\"nan(\\\"1\\\")   = %f (%\" PRIx64 \")\\n\", f1, f1n);\n \n    double f2 = nan(\"2\");\n    uint64_t f2n; memcpy(&f2n, &f2, sizeof f2);\n    printf(\"nan(\\\"2\\\")   = %f (%\" PRIx64 \")\\n\", f2, f2n);\n \n    double f3 = nan(\"0xF\");\n    uint64_t f3n; memcpy(&f3n, &f3, sizeof f3);\n    printf(\"nan(\\\"0xF\\\") = %f (%\" PRIx64 \")\\n\", f3, f3n);\n}\n```\n\nPossible output:\n\n```\nnan(\"1\")   = nan (7ff8000000000001)\nnan(\"2\")   = nan (7ff8000000000002)\nnan(\"0xF\") = nan (7ff800000000000f)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.2 The nan functions (p: 186-187)\n  - F.10.8.2 The nan functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.2 The nan functions (p: 256)\n  - F.10.8.2 The nan functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.2 The nan functions (p: 237)\n  - F.9.8.2 The fabs functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nan](https://en.cppreference.com/w/c/numeric/math/nan)"
- name: nanf
  summary: 'Converts the implementation-defined character string arg into the corresponding quiet NaN value, as if by calling the appropriate parsing function strtoX, as follows:'
  description: "# nan, nanf, nanl, nand32, nand64, nand128\n\n[TABLE]\n\nConverts the implementation-defined character string `arg` into the corresponding quiet NaN value, as if by calling the appropriate parsing function *`strtoX`*, as follows:\n\n- The call `nan(\"n-char-sequence\")`, where n-char-sequence is a sequence of digits, Latin letters, and underscores, is equivalent to the call `/*strtoX*/``(``\"NAN(n-char-sequence)\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"\")` is equivalent to the call `/*strtoX*/``(``\"NAN()\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"string\")`, where `string` is neither an n-char-sequence nor an empty string, is equivalent to the call `/*strtoX*/``(``\"NAN\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n\n1) The parsing function is [`strtof`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n2) The parsing function is [`strtod`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n3) The parsing function is [`strtold`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n4) The parsing function is `strtod32`.\n\n5) The parsing function is `strtod64`.\n\n6) The parsing function is `strtod128`.\n\n|                                                                                                                                                                                                          |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions returning decimal floating point values are declared if and only the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                           |\n|-----|-----|-----------------------------------------------------------|\n| arg | \\-  | narrow character string identifying the contents of a NaN |\n\n### Return value\n\nThe quiet NaN value that corresponds to the identifying string `arg` or zero if the implementation does not support quiet NaNs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), it also supports quiet NaNs.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n \nint main(void)\n{\n    double f1 = nan(\"1\");\n    uint64_t f1n; memcpy(&f1n, &f1, sizeof f1);\n    printf(\"nan(\\\"1\\\")   = %f (%\" PRIx64 \")\\n\", f1, f1n);\n \n    double f2 = nan(\"2\");\n    uint64_t f2n; memcpy(&f2n, &f2, sizeof f2);\n    printf(\"nan(\\\"2\\\")   = %f (%\" PRIx64 \")\\n\", f2, f2n);\n \n    double f3 = nan(\"0xF\");\n    uint64_t f3n; memcpy(&f3n, &f3, sizeof f3);\n    printf(\"nan(\\\"0xF\\\") = %f (%\" PRIx64 \")\\n\", f3, f3n);\n}\n```\n\nPossible output:\n\n```\nnan(\"1\")   = nan (7ff8000000000001)\nnan(\"2\")   = nan (7ff8000000000002)\nnan(\"0xF\") = nan (7ff800000000000f)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.2 The nan functions (p: 186-187)\n  - F.10.8.2 The nan functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.2 The nan functions (p: 256)\n  - F.10.8.2 The nan functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.2 The nan functions (p: 237)\n  - F.9.8.2 The fabs functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nan](https://en.cppreference.com/w/c/numeric/math/nan)"
- name: nanl
  summary: 'Converts the implementation-defined character string arg into the corresponding quiet NaN value, as if by calling the appropriate parsing function strtoX, as follows:'
  description: "# nan, nanf, nanl, nand32, nand64, nand128\n\n[TABLE]\n\nConverts the implementation-defined character string `arg` into the corresponding quiet NaN value, as if by calling the appropriate parsing function *`strtoX`*, as follows:\n\n- The call `nan(\"n-char-sequence\")`, where n-char-sequence is a sequence of digits, Latin letters, and underscores, is equivalent to the call `/*strtoX*/``(``\"NAN(n-char-sequence)\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"\")` is equivalent to the call `/*strtoX*/``(``\"NAN()\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n- The call `nan(\"string\")`, where `string` is neither an n-char-sequence nor an empty string, is equivalent to the call `/*strtoX*/``(``\"NAN\"``, ``(``char``**``)`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)``;`.\n\n1) The parsing function is [`strtof`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n2) The parsing function is [`strtod`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n3) The parsing function is [`strtold`](../../string/byte/strtof \"c/string/byte/strtof\").\n\n4) The parsing function is `strtod32`.\n\n5) The parsing function is `strtod64`.\n\n6) The parsing function is `strtod128`.\n\n|                                                                                                                                                                                                          |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions returning decimal floating point values are declared if and only the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                           |\n|-----|-----|-----------------------------------------------------------|\n| arg | \\-  | narrow character string identifying the contents of a NaN |\n\n### Return value\n\nThe quiet NaN value that corresponds to the identifying string `arg` or zero if the implementation does not support quiet NaNs.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), it also supports quiet NaNs.\n\n### Error handling\n\nThis function is not subject to any of the error conditions specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n \nint main(void)\n{\n    double f1 = nan(\"1\");\n    uint64_t f1n; memcpy(&f1n, &f1, sizeof f1);\n    printf(\"nan(\\\"1\\\")   = %f (%\" PRIx64 \")\\n\", f1, f1n);\n \n    double f2 = nan(\"2\");\n    uint64_t f2n; memcpy(&f2n, &f2, sizeof f2);\n    printf(\"nan(\\\"2\\\")   = %f (%\" PRIx64 \")\\n\", f2, f2n);\n \n    double f3 = nan(\"0xF\");\n    uint64_t f3n; memcpy(&f3n, &f3, sizeof f3);\n    printf(\"nan(\\\"0xF\\\") = %f (%\" PRIx64 \")\\n\", f3, f3n);\n}\n```\n\nPossible output:\n\n```\nnan(\"1\")   = nan (7ff8000000000001)\nnan(\"2\")   = nan (7ff8000000000002)\nnan(\"0xF\") = nan (7ff800000000000f)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.2 The nan functions (p: 186-187)\n  - F.10.8.2 The nan functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.2 The nan functions (p: 256)\n  - F.10.8.2 The nan functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.2 The nan functions (p: 237)\n  - F.9.8.2 The fabs functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nan](https://en.cppreference.com/w/c/numeric/math/nan)"
- name: nearbyint
  summary: The nearest integer value to arg, according to the current rounding mode, is returned
  description: "# nearbyint, nearbyintf, nearbyintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\").\n\n4) Type-generic macro: If `arg` has type `long double`, `nearbyintl` is called. Otherwise, if `arg` has integer type or the type `double`, `nearbyint` is called. Otherwise, `nearbyintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nThe nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nThis function is not subject to any of the errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\n### Notes\n\nThe only difference between `nearbyint` and [`rint`](rint \"c/numeric/math/rint\") is that `nearbyint` never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `nearbyint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), this function rounds to even in halfway cases (like [`rint`](rint \"c/numeric/math/rint\"), but unlike [`round`](round \"c/numeric/math/round\")).\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest:\\nnearbyint(+2.3) = %+.1f  \", nearbyint(2.3));\n    printf(\"nearbyint(+2.5) = %+.1f  \", nearbyint(2.5));\n    printf(\"nearbyint(+3.5) = %+.1f\\n\", nearbyint(3.5));\n    printf(\"nearbyint(-2.3) = %+.1f  \", nearbyint(-2.3));\n    printf(\"nearbyint(-2.5) = %+.1f  \", nearbyint(-2.5));\n    printf(\"nearbyint(-3.5) = %+.1f\\n\", nearbyint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nnearbyint(+2.3) = %+.1f  \", nearbyint(2.3));\n    printf(\"nearbyint(+2.5) = %+.1f  \", nearbyint(2.5));\n    printf(\"nearbyint(+3.5) = %+.1f\\n\", nearbyint(3.5));\n    printf(\"nearbyint(-2.3) = %+.1f  \", nearbyint(-2.3));\n    printf(\"nearbyint(-2.5) = %+.1f  \", nearbyint(-2.5));\n    printf(\"nearbyint(-3.5) = %+.1f\\n\", nearbyint(-3.5));\n \n    printf(\"nearbyint(-0.0) = %+.1f\\n\", nearbyint(-0.0));\n    printf(\"nearbyint(-Inf) = %+.1f\\n\", nearbyint(-INFINITY));\n}\n```\n\nOutput:\n\n```\nrounding to nearest:\nnearbyint(+2.3) = +2.0  nearbyint(+2.5) = +2.0  nearbyint(+3.5) = +4.0\nnearbyint(-2.3) = -2.0  nearbyint(-2.5) = -2.0  nearbyint(-3.5) = -4.0\nrounding down: \nnearbyint(+2.3) = +2.0  nearbyint(+2.5) = +2.0  nearbyint(+3.5) = +3.0\nnearbyint(-2.3) = -3.0  nearbyint(-2.5) = -3.0  nearbyint(-3.5) = -4.0\nnearbyint(-0.0) = -0.0\nnearbyint(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.3 The nearbyint functions (p: 251-252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.3 The nearbyint functions (p: 526)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.3 The nearbyint functions (p: 232)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.3 The nearbyint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nearbyint](https://en.cppreference.com/w/c/numeric/math/nearbyint)"
- name: nearbyintf
  summary: The nearest integer value to arg, according to the current rounding mode, is returned
  description: "# nearbyint, nearbyintf, nearbyintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\").\n\n4) Type-generic macro: If `arg` has type `long double`, `nearbyintl` is called. Otherwise, if `arg` has integer type or the type `double`, `nearbyint` is called. Otherwise, `nearbyintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nThe nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nThis function is not subject to any of the errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\n### Notes\n\nThe only difference between `nearbyint` and [`rint`](rint \"c/numeric/math/rint\") is that `nearbyint` never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `nearbyint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), this function rounds to even in halfway cases (like [`rint`](rint \"c/numeric/math/rint\"), but unlike [`round`](round \"c/numeric/math/round\")).\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest:\\nnearbyint(+2.3) = %+.1f  \", nearbyint(2.3));\n    printf(\"nearbyint(+2.5) = %+.1f  \", nearbyint(2.5));\n    printf(\"nearbyint(+3.5) = %+.1f\\n\", nearbyint(3.5));\n    printf(\"nearbyint(-2.3) = %+.1f  \", nearbyint(-2.3));\n    printf(\"nearbyint(-2.5) = %+.1f  \", nearbyint(-2.5));\n    printf(\"nearbyint(-3.5) = %+.1f\\n\", nearbyint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nnearbyint(+2.3) = %+.1f  \", nearbyint(2.3));\n    printf(\"nearbyint(+2.5) = %+.1f  \", nearbyint(2.5));\n    printf(\"nearbyint(+3.5) = %+.1f\\n\", nearbyint(3.5));\n    printf(\"nearbyint(-2.3) = %+.1f  \", nearbyint(-2.3));\n    printf(\"nearbyint(-2.5) = %+.1f  \", nearbyint(-2.5));\n    printf(\"nearbyint(-3.5) = %+.1f\\n\", nearbyint(-3.5));\n \n    printf(\"nearbyint(-0.0) = %+.1f\\n\", nearbyint(-0.0));\n    printf(\"nearbyint(-Inf) = %+.1f\\n\", nearbyint(-INFINITY));\n}\n```\n\nOutput:\n\n```\nrounding to nearest:\nnearbyint(+2.3) = +2.0  nearbyint(+2.5) = +2.0  nearbyint(+3.5) = +4.0\nnearbyint(-2.3) = -2.0  nearbyint(-2.5) = -2.0  nearbyint(-3.5) = -4.0\nrounding down: \nnearbyint(+2.3) = +2.0  nearbyint(+2.5) = +2.0  nearbyint(+3.5) = +3.0\nnearbyint(-2.3) = -3.0  nearbyint(-2.5) = -3.0  nearbyint(-3.5) = -4.0\nnearbyint(-0.0) = -0.0\nnearbyint(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.3 The nearbyint functions (p: 251-252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.3 The nearbyint functions (p: 526)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.3 The nearbyint functions (p: 232)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.3 The nearbyint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nearbyint](https://en.cppreference.com/w/c/numeric/math/nearbyint)"
- name: nearbyintl
  summary: The nearest integer value to arg, according to the current rounding mode, is returned
  description: "# nearbyint, nearbyintf, nearbyintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\").\n\n4) Type-generic macro: If `arg` has type `long double`, `nearbyintl` is called. Otherwise, if `arg` has integer type or the type `double`, `nearbyint` is called. Otherwise, `nearbyintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nThe nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nThis function is not subject to any of the errors specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\n### Notes\n\nThe only difference between `nearbyint` and [`rint`](rint \"c/numeric/math/rint\") is that `nearbyint` never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `nearbyint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), this function rounds to even in halfway cases (like [`rint`](rint \"c/numeric/math/rint\"), but unlike [`round`](round \"c/numeric/math/round\")).\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest:\\nnearbyint(+2.3) = %+.1f  \", nearbyint(2.3));\n    printf(\"nearbyint(+2.5) = %+.1f  \", nearbyint(2.5));\n    printf(\"nearbyint(+3.5) = %+.1f\\n\", nearbyint(3.5));\n    printf(\"nearbyint(-2.3) = %+.1f  \", nearbyint(-2.3));\n    printf(\"nearbyint(-2.5) = %+.1f  \", nearbyint(-2.5));\n    printf(\"nearbyint(-3.5) = %+.1f\\n\", nearbyint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nnearbyint(+2.3) = %+.1f  \", nearbyint(2.3));\n    printf(\"nearbyint(+2.5) = %+.1f  \", nearbyint(2.5));\n    printf(\"nearbyint(+3.5) = %+.1f\\n\", nearbyint(3.5));\n    printf(\"nearbyint(-2.3) = %+.1f  \", nearbyint(-2.3));\n    printf(\"nearbyint(-2.5) = %+.1f  \", nearbyint(-2.5));\n    printf(\"nearbyint(-3.5) = %+.1f\\n\", nearbyint(-3.5));\n \n    printf(\"nearbyint(-0.0) = %+.1f\\n\", nearbyint(-0.0));\n    printf(\"nearbyint(-Inf) = %+.1f\\n\", nearbyint(-INFINITY));\n}\n```\n\nOutput:\n\n```\nrounding to nearest:\nnearbyint(+2.3) = +2.0  nearbyint(+2.5) = +2.0  nearbyint(+3.5) = +4.0\nnearbyint(-2.3) = -2.0  nearbyint(-2.5) = -2.0  nearbyint(-3.5) = -4.0\nrounding down: \nnearbyint(+2.3) = +2.0  nearbyint(+2.5) = +2.0  nearbyint(+3.5) = +3.0\nnearbyint(-2.3) = -3.0  nearbyint(-2.5) = -3.0  nearbyint(-3.5) = -4.0\nnearbyint(-0.0) = -0.0\nnearbyint(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.3 The nearbyint functions (p: 251-252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.3 The nearbyint functions (p: 526)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.3 The nearbyint functions (p: 232)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.3 The nearbyint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nearbyint](https://en.cppreference.com/w/c/numeric/math/nearbyint)"
- name: nextafter
  summary: If no errors occur, the next representable value of from in the direction of to
  description: "# nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl\n\n[TABLE]\n\n1-3) First, converts both arguments to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned.\n\n4-6) First, converts the first argument to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned, converted from `long double` to the return type of the function without loss of range or precision.\n\n7) Type-generic macro: If any argument has type `long double`, `nextafterl` is called. Otherwise, if any argument has integer type or has type `double`, `nextafter` is called. Otherwise, `nextafterf` is called.\n\n8) Type-generic macro: If the argument `from` has type `long double`, `nexttowardl` is called. Otherwise, if `from` has integer type or the type `double`, `nexttoward` is called. Otherwise, `nexttowardf` is called.\n\n### Parameters\n\n|          |     |                       |\n|----------|-----|-----------------------|\n| from, to | \\-  | floating point values |\n\n### Return value\n\nIf no errors occur, the next representable value of `from` in the direction of `to`. is returned. If `from` equals `to`, then `to` is returned, converted to the type of the function.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned (with the same sign as `from`).\n\nIf a range error occurs due to underflow, the correct result is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if `from` is finite, but the expected result is an infinity, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- if `from` does not equal `to` and the result is subnormal or zero, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_UNDERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- in any case, the returned value is independent of the current rounding mode\n- if either `from` or `to` is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/nextafter.html) that the overflow and the underflow conditions are range errors ([`errno`](../../error/errno \"c/error/errno\") may be set).\n\nIEC 60559 recommends that `from` is returned whenever `from == to`. These functions return `to` instead, which makes the behavior around zero consistent: `nextafter(-0.0, +0.0)` returns `+0.0` and `nextafter(+0.0, -0.0)` returns `-0.0`.\n\n`nextafter` is typically implemented by manipulation of IEEE representation ([glibc](https://github.com/bminor/glibc/blob/master/math/s_nextafter.c) [musl](https://github.com/ifduyue/musl/blob/master/src/math/nextafter.c)).\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n#include <float.h>\n#include <fenv.h>\n \nint main(void)\n{\n    float from1 = 0, to1 = nextafterf(from1, 1);\n    printf(\"The next representable float after %.2f is %.20g (%a)\\n\", from1, to1, to1);\n \n    float from2 = 1, to2 = nextafterf(from2, 2);\n    printf(\"The next representable float after %.2f is %.20f (%a)\\n\", from2, to2, to2);\n \n    double from3 = nextafter(0.1, 0), to3 = 0.1;\n    printf(\"The number 0.1 lies between two valid doubles:\\n\"\n           \"    %.56f (%a)\\nand %.55f  (%a)\\n\", from3, from3, to3, to3);\n \n    // difference between nextafter and nexttoward:\n    long double dir = nextafterl(from1, 1); // first subnormal long double\n    float x = nextafterf(from1, dir); // first converts dir to float, giving 0\n    printf(\"Using nextafter, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n    x = nexttowardf(from1, dir);\n    printf(\"Using nexttoward, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n \n    // special values\n    {\n        #pragma STDC FENV_ACCESS ON\n        feclearexcept(FE_ALL_EXCEPT);\n        double from4 = DBL_MAX, to4 = nextafter(from4, INFINITY);\n        printf(\"The next representable double after %.2g (%a) is %.23f (%a)\\n\",\n               from4, from4, to4, to4);\n        if(fetestexcept(FE_OVERFLOW)) puts(\"   raised FE_OVERFLOW\");\n        if(fetestexcept(FE_INEXACT)) puts(\"   raised FE_INEXACT\");\n    } // end FENV_ACCESS block\n \n    float from5 = 0.0, to5 = nextafter(from5, -0.0);\n    printf(\"nextafter(+0.0, -0.0) gives %.2g (%a)\\n\", to5, to5);\n}\n```\n\nOutput:\n\n```\nThe next representable float after 0.00 is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable float after 1.00 is 1.00000011920928955078 (0x1.000002p+0)\nThe number 0.1 lies between two valid doubles:\n    0.09999999999999999167332731531132594682276248931884765625 (0x1.9999999999999p-4)\nand 0.1000000000000000055511151231257827021181583404541015625  (0x1.999999999999ap-4)\nUsing nextafter, next float after 0.00 (0x0p+0) is 0 (0x0p+0)\nUsing nexttoward, next float after 0.00 (0x0p+0) is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable double after 1.8e+308 (0x1.fffffffffffffp+1023) is inf (inf)\n   raised FE_OVERFLOW\n   raised FE_INEXACT\nnextafter(+0.0, -0.0) gives -0 (-0x0p+0)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.3 The nextafter functions (p: 187)\n  - 7.12.11.4 The nexttoward functions (p: 187)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.8.3 The nextafter functions (p: 386)\n  - F.10.8.4 The nexttoward functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.3 The nextafter functions (p: 256)\n  - 7.12.11.4 The nexttoward functions (p: 257)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.8.3 The nextafter functions (p: 529)\n  - F.10.8.4 The nexttoward functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.3 The nextafter functions (p: 237)\n  - 7.12.11.4 The nexttoward functions (p: 238)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.8.3 The nextafter functions (p: 466)\n  - F.9.8.4 The nexttoward functions (p: 466)\n\n### See also\n\n|                                                                                                                            |     |\n|----------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/math/nextafter \"cpp/numeric/math/nextafter\") for `nextafter` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nextafter](https://en.cppreference.com/w/c/numeric/math/nextafter)"
- name: nextafterf
  summary: If no errors occur, the next representable value of from in the direction of to
  description: "# nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl\n\n[TABLE]\n\n1-3) First, converts both arguments to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned.\n\n4-6) First, converts the first argument to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned, converted from `long double` to the return type of the function without loss of range or precision.\n\n7) Type-generic macro: If any argument has type `long double`, `nextafterl` is called. Otherwise, if any argument has integer type or has type `double`, `nextafter` is called. Otherwise, `nextafterf` is called.\n\n8) Type-generic macro: If the argument `from` has type `long double`, `nexttowardl` is called. Otherwise, if `from` has integer type or the type `double`, `nexttoward` is called. Otherwise, `nexttowardf` is called.\n\n### Parameters\n\n|          |     |                       |\n|----------|-----|-----------------------|\n| from, to | \\-  | floating point values |\n\n### Return value\n\nIf no errors occur, the next representable value of `from` in the direction of `to`. is returned. If `from` equals `to`, then `to` is returned, converted to the type of the function.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned (with the same sign as `from`).\n\nIf a range error occurs due to underflow, the correct result is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if `from` is finite, but the expected result is an infinity, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- if `from` does not equal `to` and the result is subnormal or zero, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_UNDERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- in any case, the returned value is independent of the current rounding mode\n- if either `from` or `to` is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/nextafter.html) that the overflow and the underflow conditions are range errors ([`errno`](../../error/errno \"c/error/errno\") may be set).\n\nIEC 60559 recommends that `from` is returned whenever `from == to`. These functions return `to` instead, which makes the behavior around zero consistent: `nextafter(-0.0, +0.0)` returns `+0.0` and `nextafter(+0.0, -0.0)` returns `-0.0`.\n\n`nextafter` is typically implemented by manipulation of IEEE representation ([glibc](https://github.com/bminor/glibc/blob/master/math/s_nextafter.c) [musl](https://github.com/ifduyue/musl/blob/master/src/math/nextafter.c)).\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n#include <float.h>\n#include <fenv.h>\n \nint main(void)\n{\n    float from1 = 0, to1 = nextafterf(from1, 1);\n    printf(\"The next representable float after %.2f is %.20g (%a)\\n\", from1, to1, to1);\n \n    float from2 = 1, to2 = nextafterf(from2, 2);\n    printf(\"The next representable float after %.2f is %.20f (%a)\\n\", from2, to2, to2);\n \n    double from3 = nextafter(0.1, 0), to3 = 0.1;\n    printf(\"The number 0.1 lies between two valid doubles:\\n\"\n           \"    %.56f (%a)\\nand %.55f  (%a)\\n\", from3, from3, to3, to3);\n \n    // difference between nextafter and nexttoward:\n    long double dir = nextafterl(from1, 1); // first subnormal long double\n    float x = nextafterf(from1, dir); // first converts dir to float, giving 0\n    printf(\"Using nextafter, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n    x = nexttowardf(from1, dir);\n    printf(\"Using nexttoward, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n \n    // special values\n    {\n        #pragma STDC FENV_ACCESS ON\n        feclearexcept(FE_ALL_EXCEPT);\n        double from4 = DBL_MAX, to4 = nextafter(from4, INFINITY);\n        printf(\"The next representable double after %.2g (%a) is %.23f (%a)\\n\",\n               from4, from4, to4, to4);\n        if(fetestexcept(FE_OVERFLOW)) puts(\"   raised FE_OVERFLOW\");\n        if(fetestexcept(FE_INEXACT)) puts(\"   raised FE_INEXACT\");\n    } // end FENV_ACCESS block\n \n    float from5 = 0.0, to5 = nextafter(from5, -0.0);\n    printf(\"nextafter(+0.0, -0.0) gives %.2g (%a)\\n\", to5, to5);\n}\n```\n\nOutput:\n\n```\nThe next representable float after 0.00 is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable float after 1.00 is 1.00000011920928955078 (0x1.000002p+0)\nThe number 0.1 lies between two valid doubles:\n    0.09999999999999999167332731531132594682276248931884765625 (0x1.9999999999999p-4)\nand 0.1000000000000000055511151231257827021181583404541015625  (0x1.999999999999ap-4)\nUsing nextafter, next float after 0.00 (0x0p+0) is 0 (0x0p+0)\nUsing nexttoward, next float after 0.00 (0x0p+0) is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable double after 1.8e+308 (0x1.fffffffffffffp+1023) is inf (inf)\n   raised FE_OVERFLOW\n   raised FE_INEXACT\nnextafter(+0.0, -0.0) gives -0 (-0x0p+0)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.3 The nextafter functions (p: 187)\n  - 7.12.11.4 The nexttoward functions (p: 187)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.8.3 The nextafter functions (p: 386)\n  - F.10.8.4 The nexttoward functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.3 The nextafter functions (p: 256)\n  - 7.12.11.4 The nexttoward functions (p: 257)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.8.3 The nextafter functions (p: 529)\n  - F.10.8.4 The nexttoward functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.3 The nextafter functions (p: 237)\n  - 7.12.11.4 The nexttoward functions (p: 238)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.8.3 The nextafter functions (p: 466)\n  - F.9.8.4 The nexttoward functions (p: 466)\n\n### See also\n\n|                                                                                                                            |     |\n|----------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/math/nextafter \"cpp/numeric/math/nextafter\") for `nextafter` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nextafter](https://en.cppreference.com/w/c/numeric/math/nextafter)"
- name: nextafterl
  summary: If no errors occur, the next representable value of from in the direction of to
  description: "# nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl\n\n[TABLE]\n\n1-3) First, converts both arguments to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned.\n\n4-6) First, converts the first argument to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned, converted from `long double` to the return type of the function without loss of range or precision.\n\n7) Type-generic macro: If any argument has type `long double`, `nextafterl` is called. Otherwise, if any argument has integer type or has type `double`, `nextafter` is called. Otherwise, `nextafterf` is called.\n\n8) Type-generic macro: If the argument `from` has type `long double`, `nexttowardl` is called. Otherwise, if `from` has integer type or the type `double`, `nexttoward` is called. Otherwise, `nexttowardf` is called.\n\n### Parameters\n\n|          |     |                       |\n|----------|-----|-----------------------|\n| from, to | \\-  | floating point values |\n\n### Return value\n\nIf no errors occur, the next representable value of `from` in the direction of `to`. is returned. If `from` equals `to`, then `to` is returned, converted to the type of the function.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned (with the same sign as `from`).\n\nIf a range error occurs due to underflow, the correct result is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if `from` is finite, but the expected result is an infinity, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- if `from` does not equal `to` and the result is subnormal or zero, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_UNDERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- in any case, the returned value is independent of the current rounding mode\n- if either `from` or `to` is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/nextafter.html) that the overflow and the underflow conditions are range errors ([`errno`](../../error/errno \"c/error/errno\") may be set).\n\nIEC 60559 recommends that `from` is returned whenever `from == to`. These functions return `to` instead, which makes the behavior around zero consistent: `nextafter(-0.0, +0.0)` returns `+0.0` and `nextafter(+0.0, -0.0)` returns `-0.0`.\n\n`nextafter` is typically implemented by manipulation of IEEE representation ([glibc](https://github.com/bminor/glibc/blob/master/math/s_nextafter.c) [musl](https://github.com/ifduyue/musl/blob/master/src/math/nextafter.c)).\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n#include <float.h>\n#include <fenv.h>\n \nint main(void)\n{\n    float from1 = 0, to1 = nextafterf(from1, 1);\n    printf(\"The next representable float after %.2f is %.20g (%a)\\n\", from1, to1, to1);\n \n    float from2 = 1, to2 = nextafterf(from2, 2);\n    printf(\"The next representable float after %.2f is %.20f (%a)\\n\", from2, to2, to2);\n \n    double from3 = nextafter(0.1, 0), to3 = 0.1;\n    printf(\"The number 0.1 lies between two valid doubles:\\n\"\n           \"    %.56f (%a)\\nand %.55f  (%a)\\n\", from3, from3, to3, to3);\n \n    // difference between nextafter and nexttoward:\n    long double dir = nextafterl(from1, 1); // first subnormal long double\n    float x = nextafterf(from1, dir); // first converts dir to float, giving 0\n    printf(\"Using nextafter, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n    x = nexttowardf(from1, dir);\n    printf(\"Using nexttoward, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n \n    // special values\n    {\n        #pragma STDC FENV_ACCESS ON\n        feclearexcept(FE_ALL_EXCEPT);\n        double from4 = DBL_MAX, to4 = nextafter(from4, INFINITY);\n        printf(\"The next representable double after %.2g (%a) is %.23f (%a)\\n\",\n               from4, from4, to4, to4);\n        if(fetestexcept(FE_OVERFLOW)) puts(\"   raised FE_OVERFLOW\");\n        if(fetestexcept(FE_INEXACT)) puts(\"   raised FE_INEXACT\");\n    } // end FENV_ACCESS block\n \n    float from5 = 0.0, to5 = nextafter(from5, -0.0);\n    printf(\"nextafter(+0.0, -0.0) gives %.2g (%a)\\n\", to5, to5);\n}\n```\n\nOutput:\n\n```\nThe next representable float after 0.00 is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable float after 1.00 is 1.00000011920928955078 (0x1.000002p+0)\nThe number 0.1 lies between two valid doubles:\n    0.09999999999999999167332731531132594682276248931884765625 (0x1.9999999999999p-4)\nand 0.1000000000000000055511151231257827021181583404541015625  (0x1.999999999999ap-4)\nUsing nextafter, next float after 0.00 (0x0p+0) is 0 (0x0p+0)\nUsing nexttoward, next float after 0.00 (0x0p+0) is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable double after 1.8e+308 (0x1.fffffffffffffp+1023) is inf (inf)\n   raised FE_OVERFLOW\n   raised FE_INEXACT\nnextafter(+0.0, -0.0) gives -0 (-0x0p+0)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.3 The nextafter functions (p: 187)\n  - 7.12.11.4 The nexttoward functions (p: 187)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.8.3 The nextafter functions (p: 386)\n  - F.10.8.4 The nexttoward functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.3 The nextafter functions (p: 256)\n  - 7.12.11.4 The nexttoward functions (p: 257)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.8.3 The nextafter functions (p: 529)\n  - F.10.8.4 The nexttoward functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.3 The nextafter functions (p: 237)\n  - 7.12.11.4 The nexttoward functions (p: 238)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.8.3 The nextafter functions (p: 466)\n  - F.9.8.4 The nexttoward functions (p: 466)\n\n### See also\n\n|                                                                                                                            |     |\n|----------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/math/nextafter \"cpp/numeric/math/nextafter\") for `nextafter` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nextafter](https://en.cppreference.com/w/c/numeric/math/nextafter)"
- name: nexttoward
  summary: If no errors occur, the next representable value of from in the direction of to
  description: "# nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl\n\n[TABLE]\n\n1-3) First, converts both arguments to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned.\n\n4-6) First, converts the first argument to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned, converted from `long double` to the return type of the function without loss of range or precision.\n\n7) Type-generic macro: If any argument has type `long double`, `nextafterl` is called. Otherwise, if any argument has integer type or has type `double`, `nextafter` is called. Otherwise, `nextafterf` is called.\n\n8) Type-generic macro: If the argument `from` has type `long double`, `nexttowardl` is called. Otherwise, if `from` has integer type or the type `double`, `nexttoward` is called. Otherwise, `nexttowardf` is called.\n\n### Parameters\n\n|          |     |                       |\n|----------|-----|-----------------------|\n| from, to | \\-  | floating point values |\n\n### Return value\n\nIf no errors occur, the next representable value of `from` in the direction of `to`. is returned. If `from` equals `to`, then `to` is returned, converted to the type of the function.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned (with the same sign as `from`).\n\nIf a range error occurs due to underflow, the correct result is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if `from` is finite, but the expected result is an infinity, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- if `from` does not equal `to` and the result is subnormal or zero, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_UNDERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- in any case, the returned value is independent of the current rounding mode\n- if either `from` or `to` is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/nextafter.html) that the overflow and the underflow conditions are range errors ([`errno`](../../error/errno \"c/error/errno\") may be set).\n\nIEC 60559 recommends that `from` is returned whenever `from == to`. These functions return `to` instead, which makes the behavior around zero consistent: `nextafter(-0.0, +0.0)` returns `+0.0` and `nextafter(+0.0, -0.0)` returns `-0.0`.\n\n`nextafter` is typically implemented by manipulation of IEEE representation ([glibc](https://github.com/bminor/glibc/blob/master/math/s_nextafter.c) [musl](https://github.com/ifduyue/musl/blob/master/src/math/nextafter.c)).\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n#include <float.h>\n#include <fenv.h>\n \nint main(void)\n{\n    float from1 = 0, to1 = nextafterf(from1, 1);\n    printf(\"The next representable float after %.2f is %.20g (%a)\\n\", from1, to1, to1);\n \n    float from2 = 1, to2 = nextafterf(from2, 2);\n    printf(\"The next representable float after %.2f is %.20f (%a)\\n\", from2, to2, to2);\n \n    double from3 = nextafter(0.1, 0), to3 = 0.1;\n    printf(\"The number 0.1 lies between two valid doubles:\\n\"\n           \"    %.56f (%a)\\nand %.55f  (%a)\\n\", from3, from3, to3, to3);\n \n    // difference between nextafter and nexttoward:\n    long double dir = nextafterl(from1, 1); // first subnormal long double\n    float x = nextafterf(from1, dir); // first converts dir to float, giving 0\n    printf(\"Using nextafter, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n    x = nexttowardf(from1, dir);\n    printf(\"Using nexttoward, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n \n    // special values\n    {\n        #pragma STDC FENV_ACCESS ON\n        feclearexcept(FE_ALL_EXCEPT);\n        double from4 = DBL_MAX, to4 = nextafter(from4, INFINITY);\n        printf(\"The next representable double after %.2g (%a) is %.23f (%a)\\n\",\n               from4, from4, to4, to4);\n        if(fetestexcept(FE_OVERFLOW)) puts(\"   raised FE_OVERFLOW\");\n        if(fetestexcept(FE_INEXACT)) puts(\"   raised FE_INEXACT\");\n    } // end FENV_ACCESS block\n \n    float from5 = 0.0, to5 = nextafter(from5, -0.0);\n    printf(\"nextafter(+0.0, -0.0) gives %.2g (%a)\\n\", to5, to5);\n}\n```\n\nOutput:\n\n```\nThe next representable float after 0.00 is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable float after 1.00 is 1.00000011920928955078 (0x1.000002p+0)\nThe number 0.1 lies between two valid doubles:\n    0.09999999999999999167332731531132594682276248931884765625 (0x1.9999999999999p-4)\nand 0.1000000000000000055511151231257827021181583404541015625  (0x1.999999999999ap-4)\nUsing nextafter, next float after 0.00 (0x0p+0) is 0 (0x0p+0)\nUsing nexttoward, next float after 0.00 (0x0p+0) is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable double after 1.8e+308 (0x1.fffffffffffffp+1023) is inf (inf)\n   raised FE_OVERFLOW\n   raised FE_INEXACT\nnextafter(+0.0, -0.0) gives -0 (-0x0p+0)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.3 The nextafter functions (p: 187)\n  - 7.12.11.4 The nexttoward functions (p: 187)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.8.3 The nextafter functions (p: 386)\n  - F.10.8.4 The nexttoward functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.3 The nextafter functions (p: 256)\n  - 7.12.11.4 The nexttoward functions (p: 257)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.8.3 The nextafter functions (p: 529)\n  - F.10.8.4 The nexttoward functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.3 The nextafter functions (p: 237)\n  - 7.12.11.4 The nexttoward functions (p: 238)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.8.3 The nextafter functions (p: 466)\n  - F.9.8.4 The nexttoward functions (p: 466)\n\n### See also\n\n|                                                                                                                            |     |\n|----------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/math/nextafter \"cpp/numeric/math/nextafter\") for `nextafter` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nextafter](https://en.cppreference.com/w/c/numeric/math/nextafter)"
- name: nexttowardf
  summary: If no errors occur, the next representable value of from in the direction of to
  description: "# nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl\n\n[TABLE]\n\n1-3) First, converts both arguments to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned.\n\n4-6) First, converts the first argument to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned, converted from `long double` to the return type of the function without loss of range or precision.\n\n7) Type-generic macro: If any argument has type `long double`, `nextafterl` is called. Otherwise, if any argument has integer type or has type `double`, `nextafter` is called. Otherwise, `nextafterf` is called.\n\n8) Type-generic macro: If the argument `from` has type `long double`, `nexttowardl` is called. Otherwise, if `from` has integer type or the type `double`, `nexttoward` is called. Otherwise, `nexttowardf` is called.\n\n### Parameters\n\n|          |     |                       |\n|----------|-----|-----------------------|\n| from, to | \\-  | floating point values |\n\n### Return value\n\nIf no errors occur, the next representable value of `from` in the direction of `to`. is returned. If `from` equals `to`, then `to` is returned, converted to the type of the function.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned (with the same sign as `from`).\n\nIf a range error occurs due to underflow, the correct result is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if `from` is finite, but the expected result is an infinity, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- if `from` does not equal `to` and the result is subnormal or zero, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_UNDERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- in any case, the returned value is independent of the current rounding mode\n- if either `from` or `to` is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/nextafter.html) that the overflow and the underflow conditions are range errors ([`errno`](../../error/errno \"c/error/errno\") may be set).\n\nIEC 60559 recommends that `from` is returned whenever `from == to`. These functions return `to` instead, which makes the behavior around zero consistent: `nextafter(-0.0, +0.0)` returns `+0.0` and `nextafter(+0.0, -0.0)` returns `-0.0`.\n\n`nextafter` is typically implemented by manipulation of IEEE representation ([glibc](https://github.com/bminor/glibc/blob/master/math/s_nextafter.c) [musl](https://github.com/ifduyue/musl/blob/master/src/math/nextafter.c)).\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n#include <float.h>\n#include <fenv.h>\n \nint main(void)\n{\n    float from1 = 0, to1 = nextafterf(from1, 1);\n    printf(\"The next representable float after %.2f is %.20g (%a)\\n\", from1, to1, to1);\n \n    float from2 = 1, to2 = nextafterf(from2, 2);\n    printf(\"The next representable float after %.2f is %.20f (%a)\\n\", from2, to2, to2);\n \n    double from3 = nextafter(0.1, 0), to3 = 0.1;\n    printf(\"The number 0.1 lies between two valid doubles:\\n\"\n           \"    %.56f (%a)\\nand %.55f  (%a)\\n\", from3, from3, to3, to3);\n \n    // difference between nextafter and nexttoward:\n    long double dir = nextafterl(from1, 1); // first subnormal long double\n    float x = nextafterf(from1, dir); // first converts dir to float, giving 0\n    printf(\"Using nextafter, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n    x = nexttowardf(from1, dir);\n    printf(\"Using nexttoward, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n \n    // special values\n    {\n        #pragma STDC FENV_ACCESS ON\n        feclearexcept(FE_ALL_EXCEPT);\n        double from4 = DBL_MAX, to4 = nextafter(from4, INFINITY);\n        printf(\"The next representable double after %.2g (%a) is %.23f (%a)\\n\",\n               from4, from4, to4, to4);\n        if(fetestexcept(FE_OVERFLOW)) puts(\"   raised FE_OVERFLOW\");\n        if(fetestexcept(FE_INEXACT)) puts(\"   raised FE_INEXACT\");\n    } // end FENV_ACCESS block\n \n    float from5 = 0.0, to5 = nextafter(from5, -0.0);\n    printf(\"nextafter(+0.0, -0.0) gives %.2g (%a)\\n\", to5, to5);\n}\n```\n\nOutput:\n\n```\nThe next representable float after 0.00 is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable float after 1.00 is 1.00000011920928955078 (0x1.000002p+0)\nThe number 0.1 lies between two valid doubles:\n    0.09999999999999999167332731531132594682276248931884765625 (0x1.9999999999999p-4)\nand 0.1000000000000000055511151231257827021181583404541015625  (0x1.999999999999ap-4)\nUsing nextafter, next float after 0.00 (0x0p+0) is 0 (0x0p+0)\nUsing nexttoward, next float after 0.00 (0x0p+0) is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable double after 1.8e+308 (0x1.fffffffffffffp+1023) is inf (inf)\n   raised FE_OVERFLOW\n   raised FE_INEXACT\nnextafter(+0.0, -0.0) gives -0 (-0x0p+0)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.3 The nextafter functions (p: 187)\n  - 7.12.11.4 The nexttoward functions (p: 187)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.8.3 The nextafter functions (p: 386)\n  - F.10.8.4 The nexttoward functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.3 The nextafter functions (p: 256)\n  - 7.12.11.4 The nexttoward functions (p: 257)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.8.3 The nextafter functions (p: 529)\n  - F.10.8.4 The nexttoward functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.3 The nextafter functions (p: 237)\n  - 7.12.11.4 The nexttoward functions (p: 238)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.8.3 The nextafter functions (p: 466)\n  - F.9.8.4 The nexttoward functions (p: 466)\n\n### See also\n\n|                                                                                                                            |     |\n|----------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/math/nextafter \"cpp/numeric/math/nextafter\") for `nextafter` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nextafter](https://en.cppreference.com/w/c/numeric/math/nextafter)"
- name: nexttowardl
  summary: If no errors occur, the next representable value of from in the direction of to
  description: "# nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl\n\n[TABLE]\n\n1-3) First, converts both arguments to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned.\n\n4-6) First, converts the first argument to the type of the function, then returns the next representable value of `from` in the direction of `to`. If `from` equals to `to`, `to` is returned, converted from `long double` to the return type of the function without loss of range or precision.\n\n7) Type-generic macro: If any argument has type `long double`, `nextafterl` is called. Otherwise, if any argument has integer type or has type `double`, `nextafter` is called. Otherwise, `nextafterf` is called.\n\n8) Type-generic macro: If the argument `from` has type `long double`, `nexttowardl` is called. Otherwise, if `from` has integer type or the type `double`, `nexttoward` is called. Otherwise, `nexttowardf` is called.\n\n### Parameters\n\n|          |     |                       |\n|----------|-----|-----------------------|\n| from, to | \\-  | floating point values |\n\n### Return value\n\nIf no errors occur, the next representable value of `from` in the direction of `to`. is returned. If `from` equals `to`, then `to` is returned, converted to the type of the function.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned (with the same sign as `from`).\n\nIf a range error occurs due to underflow, the correct result is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if `from` is finite, but the expected result is an infinity, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_OVERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- if `from` does not equal `to` and the result is subnormal or zero, raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") and [`FE_UNDERFLOW`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- in any case, the returned value is independent of the current rounding mode\n- if either `from` or `to` is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/nextafter.html) that the overflow and the underflow conditions are range errors ([`errno`](../../error/errno \"c/error/errno\") may be set).\n\nIEC 60559 recommends that `from` is returned whenever `from == to`. These functions return `to` instead, which makes the behavior around zero consistent: `nextafter(-0.0, +0.0)` returns `+0.0` and `nextafter(+0.0, -0.0)` returns `-0.0`.\n\n`nextafter` is typically implemented by manipulation of IEEE representation ([glibc](https://github.com/bminor/glibc/blob/master/math/s_nextafter.c) [musl](https://github.com/ifduyue/musl/blob/master/src/math/nextafter.c)).\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n#include <float.h>\n#include <fenv.h>\n \nint main(void)\n{\n    float from1 = 0, to1 = nextafterf(from1, 1);\n    printf(\"The next representable float after %.2f is %.20g (%a)\\n\", from1, to1, to1);\n \n    float from2 = 1, to2 = nextafterf(from2, 2);\n    printf(\"The next representable float after %.2f is %.20f (%a)\\n\", from2, to2, to2);\n \n    double from3 = nextafter(0.1, 0), to3 = 0.1;\n    printf(\"The number 0.1 lies between two valid doubles:\\n\"\n           \"    %.56f (%a)\\nand %.55f  (%a)\\n\", from3, from3, to3, to3);\n \n    // difference between nextafter and nexttoward:\n    long double dir = nextafterl(from1, 1); // first subnormal long double\n    float x = nextafterf(from1, dir); // first converts dir to float, giving 0\n    printf(\"Using nextafter, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n    x = nexttowardf(from1, dir);\n    printf(\"Using nexttoward, next float after %.2f (%a) is %.20g (%a)\\n\",\n           from1, from1, x, x);\n \n    // special values\n    {\n        #pragma STDC FENV_ACCESS ON\n        feclearexcept(FE_ALL_EXCEPT);\n        double from4 = DBL_MAX, to4 = nextafter(from4, INFINITY);\n        printf(\"The next representable double after %.2g (%a) is %.23f (%a)\\n\",\n               from4, from4, to4, to4);\n        if(fetestexcept(FE_OVERFLOW)) puts(\"   raised FE_OVERFLOW\");\n        if(fetestexcept(FE_INEXACT)) puts(\"   raised FE_INEXACT\");\n    } // end FENV_ACCESS block\n \n    float from5 = 0.0, to5 = nextafter(from5, -0.0);\n    printf(\"nextafter(+0.0, -0.0) gives %.2g (%a)\\n\", to5, to5);\n}\n```\n\nOutput:\n\n```\nThe next representable float after 0.00 is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable float after 1.00 is 1.00000011920928955078 (0x1.000002p+0)\nThe number 0.1 lies between two valid doubles:\n    0.09999999999999999167332731531132594682276248931884765625 (0x1.9999999999999p-4)\nand 0.1000000000000000055511151231257827021181583404541015625  (0x1.999999999999ap-4)\nUsing nextafter, next float after 0.00 (0x0p+0) is 0 (0x0p+0)\nUsing nexttoward, next float after 0.00 (0x0p+0) is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable double after 1.8e+308 (0x1.fffffffffffffp+1023) is inf (inf)\n   raised FE_OVERFLOW\n   raised FE_INEXACT\nnextafter(+0.0, -0.0) gives -0 (-0x0p+0)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.11.3 The nextafter functions (p: 187)\n  - 7.12.11.4 The nexttoward functions (p: 187)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.8.3 The nextafter functions (p: 386)\n  - F.10.8.4 The nexttoward functions (p: 386)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.11.3 The nextafter functions (p: 256)\n  - 7.12.11.4 The nexttoward functions (p: 257)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.8.3 The nextafter functions (p: 529)\n  - F.10.8.4 The nexttoward functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.11.3 The nextafter functions (p: 237)\n  - 7.12.11.4 The nexttoward functions (p: 238)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.8.3 The nextafter functions (p: 466)\n  - F.9.8.4 The nexttoward functions (p: 466)\n\n### See also\n\n|                                                                                                                            |     |\n|----------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/math/nextafter \"cpp/numeric/math/nextafter\") for `nextafter` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/nextafter](https://en.cppreference.com/w/c/numeric/math/nextafter)"
- name: 'NULL'
  summary: The macro NULL is an implementation-defined null pointer constant, which may be
  description: "# NULL\n\n[TABLE]\n\nThe macro `NULL` is an implementation-defined null pointer constant, which may be\n\n- an integer [constant expression](../language/constant_expression#Integer_constant_expression \"c/language/constant expression\") with the value `​0​`\n- an integer constant expression with the value `​0​` [cast to the type](../language/conversion#Pointer_conversions \"c/language/conversion\") `void*`\n\n[TABLE]\n\nA null pointer constant may be [converted](../language/conversion#Pointer_conversions \"c/language/conversion\") to any pointer type; such conversion results in the null pointer value of that type.\n\n### Possible implementation\n\n[TABLE]\n\n### Example\n\n```\n#include <inttypes.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    // any kind of pointer can be set to NULL\n    int* p = NULL;\n    struct S *s = NULL;\n    void(*f)(int, double) = NULL;\n    printf(\"%p %p %p\\n\", (void*)p, (void*)s, (void*)(long)f);\n \n    // many pointer-returning functions use null pointers to indicate error\n    char *ptr = malloc(0xFULL);\n    if (ptr == NULL)\n        printf(\"Out of memory\");\n    else\n        printf(\"ptr = %#\" PRIxPTR\"\\n\", (uintptr_t)ptr);\n    free(ptr);\n}\n```\n\nPossible output:\n\n```\n(nil) (nil) (nil)\nptr = 0xc001cafe\n```\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types/NULL](https://en.cppreference.com/w/c/types/NULL)"
- name: Null-terminated byte strings
  summary: A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character)
  description: "# Null-terminated byte strings\n\nA null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array `{'\\x63','\\x61','\\x74','\\0'}` is an NTBS holding the string `\"cat\"` in [ASCII](../language/ascii \"c/language/ascii\") encoding.\n\n### Functions\n\n[TABLE]\n\nNote: additional functions whose names begin with either `to` or `is`, followed by a lowercase letter, may be added to the header `ctype.h` in future and should not be defined by programs that include that header.\n\n[TABLE]\n\n[TABLE]\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4 Character handling \\<ctype.h\\> (p: 200-204)\n  - 7.8 Format conversion of integer types \\<inttypes.h\\> (p: 217-220)\n  - 7.22 General utilities \\<stdlib.h\\> (p: 340-360)\n  - 7.24 String handling \\<string.h\\> (p: 362-372)\n  - 7.31.2 Character handling \\<ctype.h\\> (p: 455)\n  - 7.31.5 Format conversion of integer types \\<inttypes.h\\> (p: 455)\n  - 7.31.12 General utilities \\<stdlib.h\\> (p: 456)\n  - 7.31.13 String handling \\<string.h\\> (p: 456)\n  - K.3.6 General utilities \\<stdlib.h\\> (p: 604-613)\n  - K.3.7 String handling \\<string.h\\> (p: 614-623)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4 Character handling \\<ctype.h\\> (p: 181-185)\n  - 7.8 Format conversion of integer types \\<inttypes.h\\> (p: 198-201)\n  - 7.20 General utilities \\<stdlib.h\\> (p: 306-324)\n  - 7.21 String handling \\<string.h\\> (p: 325-334)\n  - 7.26.2 Character handling \\<ctype.h\\> (p: 401)\n  - 7.26.4 Format conversion of integer types \\<inttypes.h\\> (p: 401)\n  - 7.26.10 General utilities \\<stdlib.h\\> (p: 402)\n  - 7.26.11 String handling \\<string.h\\> (p: 402)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3 CHARACTER HANDLING \\<ctype.h\\>\n  - 4.10 GENERAL UTILITIES \\<stdlib.h\\>\n  - 4.11 STRING HANDLING \\<string.h\\>\n  - 4.13.2 Character handling \\<ctype.h\\>\n  - 4.13.7 General utilities \\<stdlib.h\\>\n  - 4.13.8 String handling \\<string.h\\>\n\n### See also\n\n|                                                                                                                         |     |\n|-------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/string/byte \"cpp/string/byte\") for `Null`-terminated byte strings |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte](https://en.cppreference.com/w/c/string/byte)"
- name: Null-terminated multibyte strings
  summary: A null-terminated multibyte string (NTMBS), or "multibyte string", is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character)
  description: "# Null-terminated multibyte strings\n\nA null-terminated multibyte string (NTMBS), or \"multibyte string\", is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).\n\nEach character stored in the string may occupy more than one byte. The encoding used to represent characters in a multibyte character string is locale-specific: it may be UTF-8, GB18030, EUC-JP, Shift-JIS, etc. For example, the char array `{'\\xe4','\\xbd','\\xa0','\\xe5','\\xa5','\\xbd','\\0'`} is an NTMBS holding the string `\"你好\"` in UTF-8 multibyte encoding: the first three bytes encode the character 你, the next three bytes encode the character 好. The same string encoded in GB18030 is the char array `{'\\xc4', '\\xe3', '\\xba', '\\xc3', '\\0'`}, where each of the two characters is encoded as a two-byte sequence.\n\nIn some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as \"shift sequences\". Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are BOCU-1 and [SCSU](http://www.unicode.org/reports/tr6).\n\nA multibyte character string is layout-compatible with [null-terminated byte string](byte \"c/string/byte\") (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the following locale-dependent conversion functions:\n\n### Multibyte/wide character conversions\n\n[TABLE]\n\n### Types\n\n[TABLE]\n\n### Macros\n\n[TABLE]\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.10 Sizes of integer types \\<limits.h\\> (p: 222)\n  - 7.22 General utilities \\<stdlib.h\\> (p: 340-360)\n  - 7.28 Unicode utilities \\<uchar.h\\> (p: 398-401)\n  - 7.29 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 402-446)\n  - 7.31.12 General utilities \\<stdlib.h\\> (p: 456)\n  - 7.31.16 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 456)\n  - K.3.6 General utilities \\<stdlib.h\\> (p: 604-614)\n  - K.3.9 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 627-651)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.10 Sizes of integer types \\<limits.h\\> (p: 203)\n  - 7.20 General utilities \\<stdlib.h\\> (p: 306-324)\n  - 7.24 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 348-392)\n  - 7.26.10 General utilities \\<stdlib.h\\> (p: 402)\n  - 7.26.12 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 402)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.1.4 Limits \\<float.h\\> and \\<limits.h\\>\n  - 4.10 GENERAL UTILITIES \\<stdlib.h\\>\n  - 4.13.7 General utilities \\<stdlib.h\\>\n\n### See also\n\n|                                                                                                                                        |     |\n|----------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/string/multibyte \"cpp/string/multibyte\") for `Null-terminated multibyte strings` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte](https://en.cppreference.com/w/c/string/multibyte)"
- name: Null-terminated wide strings
  summary: A null-terminated wide string is a sequence of valid wide characters, ending with a null-character
  description: "# Null-terminated wide strings\n\nA null-terminated wide string is a sequence of valid wide characters, ending with a null-character.\n\n### Functions\n\n[TABLE]\n\n[TABLE]\n\n[TABLE]\n\n[TABLE]\n\n[TABLE]\n\n### Types\n\n[TABLE]\n\n### Macros\n\n[TABLE]\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.19 Common definitions \\<stddef.h\\> (p: 288)\n  - 7.29 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 402-446)\n  - 7.30 Wide character classification and mapping utilities \\<wctype.h\\> (p: 447-454)\n  - 7.31.16 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 456)\n  - 7.31.17 Wide character classification and mapping utilities \\<wctype.h\\> (p: 457)\n  - K.3.3 Common definitions \\<stddef.h\\> (p: 585)\n  - K.3.9 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 627-651)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.17 Common definitions \\<stddef.h\\> (p: 254)\n  - 7.24 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 348-392)\n  - 7.25 Wide character classification and mapping utilities \\<wctype.h\\> (p: 393-400)\n  - 7.26.12 Extended multibyte and wide character utilities \\<wchar.h\\> (p: 402)\n  - 7.26.13 Wide character classification and mapping utilities \\<wctype.h\\> (p: 402)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.1.5 Common definitions \\<stddef.h\\>\n\n### See also\n\n|                                                                                                                         |     |\n|-------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/string/wide \"cpp/string/wide\") for `Null`-terminated wide strings |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide](https://en.cppreference.com/w/c/string/wide)"
- name: nullptr
  summary: ''
  description: "# C keywords: nullptr (since C23)\n\n### Usage\n\n- [`nullptr` pointer constant](../language/nullptr \"c/language/nullptr\") (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/nullptr](https://en.cppreference.com/w/c/keyword/nullptr)"
- name: nullptr_t
  summary: nullptr_t is the type of the predefined null pointer constant, nullptr
  description: "# nullptr_t\n\n[TABLE]\n\n`nullptr_t` is the type of the predefined null pointer constant, [`nullptr`](../language/nullptr \"c/language/nullptr\"). It is a distinct type that is not itself a pointer type. It can be [implicitly converted](../language/conversion \"c/language/conversion\") to any pointer type or `bool`, and the result is the null pointer value of that type or `false` respectively. No type other than `nullptr_t` itself can be converted or explicitly cast to `nullptr_t`.\n\n`sizeof(nullptr_t)` and `alignof(nullptr_t)` are equal to `sizeof(void*)` and `alignof(void*)` respectively.\n\n`nullptr_t` has only one valid value, i.e., `nullptr`. The object representation of `nullptr` is same as that of `(void*)0`. If a program produces a `nullptr_t` value with a different object representation, the behavior is undefined.\n\n### Example\n\nDemonstrate that `nullptr_t` is a distinct type.\n\n```\n#include <stddef.h>\n#include <stdio.h>\n \n#define DETECT_NULL_POINTER_CONSTANT(e) \\\n    _Generic(e,                         \\\n        void* : puts(\"void*\"),          \\\n        nullptr_t : puts(\"nullptr_t\"),  \\\n        default : puts(\"other\")       \\\n    )\n \nint main()\n{\n    DETECT_NULL_POINTER_CONSTANT(((void*)0));\n    DETECT_NULL_POINTER_CONSTANT(0);\n    DETECT_NULL_POINTER_CONSTANT(nullptr);\n}\n```\n\nOutput:\n\n```\nvoid*\nother\nnullptr_t\n```\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types/nullptr_t](https://en.cppreference.com/w/c/types/nullptr_t)"
- name: Numeric limits
  summary: 'The types of these constants, other than CHAR_BIT and MB_LEN_MAX, are required to match the results of the integral promotions as applied to objects of the types they describe: CHAR_MAX may have type int or unsigned int, but never char'
  description: "# Numeric limits\n\n### Limits of integer types\n\n[TABLE]\n\n#### Notes\n\nThe types of these constants, other than `CHAR_BIT` and `MB_LEN_MAX`, are required to match the results of the [integral promotions](../language/conversion#Integer_promotions \"c/language/conversion\") as applied to objects of the types they describe: `CHAR_MAX` may have type int or unsigned int, but never char. Similarly `USHRT_MAX` may not be of an unsigned type: its type may be int.\n\nA freestanding implementation may lack [`sig_atomic_t`](../program/sig_atomic_t \"c/program/sig atomic t\") and/or wint_t typedef names, in which case the `SIG_ATOMIC_*` and/or `WINT_*` macros are correspondingly absent.\n\n#### Example\n\n```\n#include <limits.h>\n#include <stdint.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"CHAR_BIT       = %d\\n\", CHAR_BIT);\n    printf(\"MB_LEN_MAX     = %d\\n\\n\", MB_LEN_MAX);\n \n    printf(\"CHAR_MIN       = %+d\\n\", CHAR_MIN);\n    printf(\"CHAR_MAX       = %+d\\n\", CHAR_MAX);\n    printf(\"SCHAR_MIN      = %+d\\n\", SCHAR_MIN);\n    printf(\"SCHAR_MAX      = %+d\\n\", SCHAR_MAX);\n    printf(\"UCHAR_MAX      = %u\\n\\n\", UCHAR_MAX);\n \n    printf(\"SHRT_MIN       = %+d\\n\", SHRT_MIN);\n    printf(\"SHRT_MAX       = %+d\\n\", SHRT_MAX);\n    printf(\"USHRT_MAX      = %u\\n\\n\", USHRT_MAX);\n \n    printf(\"INT_MIN        = %+d\\n\", INT_MIN);\n    printf(\"INT_MAX        = %+d\\n\", INT_MAX);\n    printf(\"UINT_MAX       = %u\\n\\n\", UINT_MAX);\n \n    printf(\"LONG_MIN       = %+ld\\n\", LONG_MIN);\n    printf(\"LONG_MAX       = %+ld\\n\", LONG_MAX);\n    printf(\"ULONG_MAX      = %lu\\n\\n\", ULONG_MAX);\n \n    printf(\"LLONG_MIN      = %+lld\\n\", LLONG_MIN);\n    printf(\"LLONG_MAX      = %+lld\\n\", LLONG_MAX);\n    printf(\"ULLONG_MAX     = %llu\\n\\n\", ULLONG_MAX);\n \n    printf(\"PTRDIFF_MIN    = %td\\n\", PTRDIFF_MIN);\n    printf(\"PTRDIFF_MAX    = %+td\\n\", PTRDIFF_MAX);\n    printf(\"SIZE_MAX       = %zu\\n\", SIZE_MAX);\n    printf(\"SIG_ATOMIC_MIN = %+jd\\n\",(intmax_t)SIG_ATOMIC_MIN);\n    printf(\"SIG_ATOMIC_MAX = %+jd\\n\",(intmax_t)SIG_ATOMIC_MAX);\n    printf(\"WCHAR_MIN      = %+jd\\n\",(intmax_t)WCHAR_MIN);\n    printf(\"WCHAR_MAX      = %+jd\\n\",(intmax_t)WCHAR_MAX);\n    printf(\"WINT_MIN       = %jd\\n\", (intmax_t)WINT_MIN);\n    printf(\"WINT_MAX       = %jd\\n\", (intmax_t)WINT_MAX);\n}\n```\n\nPossible output:\n\n```\nCHAR_BIT       = 8\nMB_LEN_MAX     = 16\n \nCHAR_MIN       = -128\nCHAR_MAX       = +127\nSCHAR_MIN      = -128\nSCHAR_MAX      = +127\nUCHAR_MAX      = 255\n \nSHRT_MIN       = -32768\nSHRT_MAX       = +32767\nUSHRT_MAX      = 65535\n \nINT_MIN        = -2147483648\nINT_MAX        = +2147483647\nUINT_MAX       = 4294967295\n \nLONG_MIN       = -9223372036854775808\nLONG_MAX       = +9223372036854775807\nULONG_MAX      = 18446744073709551615\n \nLLONG_MIN      = -9223372036854775808\nLLONG_MAX      = +9223372036854775807\nULLONG_MAX     = 18446744073709551615\n \nPTRDIFF_MIN    = -9223372036854775808\nPTRDIFF_MAX    = +9223372036854775807\nSIZE_MAX       = 18446744073709551615\nSIG_ATOMIC_MIN = -2147483648\nSIG_ATOMIC_MAX = +2147483647\nWCHAR_MIN      = -2147483648\nWCHAR_MAX      = +2147483647\nWINT_MIN       = 0\nWINT_MAX       = 4294967295\n```\n\n### Limits of floating-point types\n\n[TABLE]\n\n[TABLE]\n\n#### Example\n\n```\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"DECIMAL_DIG     = %d\\n\", DECIMAL_DIG);\n    printf(\"FLT_DECIMAL_DIG = %d\\n\", FLT_DECIMAL_DIG);\n    printf(\"FLT_RADIX       = %d\\n\", FLT_RADIX);\n    printf(\"FLT_MIN         = %e\\n\", FLT_MIN);\n    printf(\"FLT_MAX         = %e\\n\", FLT_MAX);\n    printf(\"FLT_EPSILON     = %e\\n\", FLT_EPSILON);\n    printf(\"FLT_DIG         = %d\\n\", FLT_DIG);\n    printf(\"FLT_MANT_DIG    = %d\\n\", FLT_MANT_DIG);\n    printf(\"FLT_MIN_EXP     = %d\\n\", FLT_MIN_EXP);\n    printf(\"FLT_MIN_10_EXP  = %d\\n\", FLT_MIN_10_EXP);\n    printf(\"FLT_MAX_EXP     = %d\\n\", FLT_MAX_EXP);\n    printf(\"FLT_MAX_10_EXP  = %d\\n\", FLT_MAX_10_EXP);\n    printf(\"FLT_ROUNDS      = %d\\n\", FLT_ROUNDS);\n    printf(\"FLT_EVAL_METHOD = %d\\n\", FLT_EVAL_METHOD);\n    printf(\"FLT_HAS_SUBNORM = %d\\n\", FLT_HAS_SUBNORM);\n}\n```\n\nPossible output:\n\n```\nDECIMAL_DIG     = 37\nFLT_DECIMAL_DIG = 9\nFLT_RADIX       = 2\nFLT_MIN         = 1.175494e-38\nFLT_MAX         = 3.402823e+38\nFLT_EPSILON     = 1.192093e-07\nFLT_DIG         = 6\nFLT_MANT_DIG    = 24\nFLT_MIN_EXP     = -125\nFLT_MIN_10_EXP  = -37\nFLT_MAX_EXP     = 128\nFLT_MAX_10_EXP  = 38\nFLT_ROUNDS      = 1\nFLT_EVAL_METHOD = 1\nFLT_HAS_SUBNORM = 1\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 5.2.4.2 Numerical limits (p: TBD)\n  - 7.22.3 Limits of other integer types (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 5.2.4.2 Numerical limits (p: 20-27)\n  - 7.20.3 Limits of other integer types (p: 215-216)\n- C11 standard (ISO/IEC 9899:2011):\n  - 5.2.4.2 Numerical limits (p: 26-34)\n  - 7.20.3 Limits of other integer types (p: 293-294)\n- C99 standard (ISO/IEC 9899:1999):\n  - 5.2.4.2 Numerical limits (p: 21-28)\n  - 7.18.3 Limits of other integer types (p: 259-260)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 2.2.4.2 Numerical limits\n\n### See also\n\n|                                                                                                                         |     |\n|-------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/types/climits \"cpp/types/climits\") for C numeric limits interface |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types/limits](https://en.cppreference.com/w/c/types/limits)"
- name: Numerics
  summary: The C numerics library includes common mathematical functions and types, as well as support for random number generation
  description: "# Numerics\n\nThe C numerics library includes common mathematical functions and types, as well as support for random number generation.\n\n### [Common mathematical functions](numeric/math \"c/numeric/math\")\n\nThe header `math.h` provides [standard C library mathematical functions](numeric/math \"c/numeric/math\") such as [`fabs`](numeric/math/fabs \"c/numeric/math/fabs\"), [`sqrt`](numeric/math/sqrt \"c/numeric/math/sqrt\"), and [`sin`](numeric/math/sin \"c/numeric/math/sin\").\n\n### [Floating-point environment](numeric/fenv \"c/numeric/fenv\")\n\nThe header `fenv.h` defines [flags and functions related to exceptional floating-point state](numeric/fenv \"c/numeric/fenv\"), such as overflow and division by zero.\n\n### [Pseudo-random number generation](numeric/random \"c/numeric/random\")\n\nThe header `stdlib.h` also includes C-style random number generation via [`srand`](numeric/random/srand \"c/numeric/random/srand\") and [`rand`](numeric/random/rand \"c/numeric/random/rand\").\n\n### [Complex number arithmetic](numeric/complex \"c/numeric/complex\")\n\nThe header `complex.h` provides types and functions about [complex numbers](numeric/complex \"c/numeric/complex\").\n\n### [Type-generic math](numeric/tgmath \"c/numeric/tgmath\")\n\nThe header `tgmath.h` provides some macros for a function which names XXX:\n\n- real function:\n  - `float` variant `XXXf`\n  - `double` variant `XXX`\n  - `long double` variant `XXXl`\n- complex function:\n  - `float` variant `cXXXf`\n  - `double` variant `cXXX`\n  - `long double` variant `cXXXl`\n\n### See also\n\n|                                                                                                   |     |\n|---------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric \"cpp/numeric\") for Numerics library |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric](https://en.cppreference.com/w/c/numeric)"
- name: Objects and alignment
  summary: C programs create, destroy, access, and manipulate objects
  description: "# Objects and alignment\n\nC programs create, destroy, access, and manipulate objects.\n\nAn object in C is a region of [data storage](memory_model \"c/language/memory model\") in the execution environment, the contents of which can represent *values* (a value is the meaning of the contents of an object, when interpreted as having a specific [type](type \"c/language/type\")).\n\nEvery object has\n\n- size (can be determined with [`sizeof`](sizeof \"c/language/sizeof\"))\n- alignment requirement(can be determined by [`_Alignof`](_alignof \"c/language/ Alignof\"))(since C11)\n- [storage duration](storage_duration \"c/language/storage duration\") (automatic, static, allocated, thread-local)\n- [lifetime](lifetime \"c/language/lifetime\") (equal to storage duration or temporary)\n- effective type (see below)\n- value (which may be indeterminate)\n- optionally, an [identifier](identifier \"c/language/identifier\") that denotes this object.\n\nObjects are created by [declarations](declarations \"c/language/declarations\"), [allocation functions](../memory \"c/memory\"), [string literals](string_literal \"c/language/string literal\"), [compound literals](compound_literal \"c/language/compound literal\"), and by non-lvalue expressions that return [structures or unions with array members](lifetime \"c/language/lifetime\").\n\n### Object representation\n\nExcept for [bit-fields](bit_field \"c/language/bit field\"), objects are composed of contiguous sequences of one or more bytes, each consisting of [`CHAR_BIT`](../types/limits \"c/types/limits\") bits, and can be copied with [`memcpy`](../string/byte/memcpy \"c/string/byte/memcpy\") into an object of type `unsigned char[n]`, where `n` is the size of the object. The contents of the resulting array are known as *object representation*.\n\nIf two objects have the same object representation, they compare equal (except if they are floating-point NaNs). The reverse is not true: two objects that compare equal may have different object representations because not every bit of the object representation needs to participate in the value. Such bits may be used for padding to satisfy alignment requirement, for parity checks, to indicate trap representations, etc.\n\nIf an object representation does not represent any value of the object type, it is known as *trap representation*. Accessing a trap representation in any way other than reading it through an lvalue expression of character type is undefined behavior. The value of a structure or union is never a trap representation even if any particular member is one.\n\nFor the objects of type char, signed char, and unsigned char, every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).\n\nWhen objects of [integer types](arithmetic_types#Integer_types \"c/language/arithmetic types\") (short, int, long, long long) occupy multiple bytes, the use of those bytes is implementation-defined, but the two dominant implementations are *big-endian* (POWER, Sparc, Itanium) and *little-endian* (x86, x86_64): a big-endian platform stores the most significant byte at the lowest address of the region of storage occupied by the integer, a little-endian platform stores the least significant byte at the lowest address. See [Endianness](https://en.wikipedia.org/wiki/Endianness \"enwiki:Endianness\") for detail. See also example below.\n\nAlthough most implementations do not allow trap representations, padding bits, or multiple representations for integer types, there are exceptions; for example a value of an integer type on Itanium [may be a trap representation](https://web.archive.org/web/20170830125905/https://blogs.msdn.microsoft.com/oldnewthing/20040119-00/?p=41003).\n\n### Effective type\n\nEvery object has an *effective type*, which determines which [lvalue](value_category \"c/language/value category\") accesses are valid and which violate the strict aliasing rules.\n\nIf the object was created by a [declaration](declarations \"c/language/declarations\"), the declared type of that object is the object's *effective type*.\n\nIf the object was created by an [allocation function](../memory \"c/memory\") (including [`realloc`](../memory/realloc \"c/memory/realloc\")), it has no declared type. Such object acquires an effective type as follows:\n\n- The first write to that object through an lvalue that has a type other than character type, at which time the type of that lvalue becomes this object's *effective type* for that write and all subsequent reads.\n- [`memcpy`](../string/byte/memcpy \"c/string/byte/memcpy\") or [`memmove`](../string/byte/memmove \"c/string/byte/memmove\") copy another object into that object, or copy another object into that object as an array of character type, at which time the effective type of the source object (if it had one) becomes the effective type of this object for that write and all subsequent reads.\n- Any other access to the object with no declared type, the effective type is the type of the lvalue used for the access.\n\n### Strict aliasing\n\nGiven an object with *effective type* T1, using an lvalue expression (typically, dereferencing a pointer) of a different type T2 is undefined behavior, unless:\n\n- T2 and T1 are [compatible types](type#Compatible_types \"c/language/type\").\n- T2 is cvr-qualified version of a type that is [compatible](type#Compatible_types \"c/language/type\") with T1.\n- T2 is a signed or unsigned version of a type that is [compatible](type#Compatible_types \"c/language/type\") with T1.\n- T2 is an aggregate type or union type type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union).\n- T2 is a character type (char, signed char, or unsigned char).\n\n```\nint i = 7;\nchar* pc = (char*)(&i);\n \nif (pc[0] == '\\x7') // aliasing through char is OK\n    puts(\"This system is little-endian\");\nelse\n    puts(\"This system is big-endian\");\n \nfloat* pf = (float*)(&i);\nfloat d = *pf; // UB: float lvalue *p cannot be used to access int\n```\n\nThese rules control whether a function that receives two pointers must re-read one after writing through another:\n\n```\n// int* and double* cannot alias\nvoid f1(int* pi, double* pd, double d)\n{\n    // the read from *pi can be done only once, before the loop\n    for (int i = 0; i < *pi; i++)\n        *pd++ = d;\n}\n```\n\n```\nstruct S { int a, b; };\n \n// int* and struct S* may alias because S is an aggregate type with a member of type int\nvoid f2(int* pi, struct S* ps, struct S s)\n{\n    // read from *pi must take place after every write through *ps\n    for (int i = 0; i < *pi; i++)\n        *ps++ = s;\n}\n```\n\nNote that [restrict qualifier](restrict \"c/language/restrict\") can be used to indicate that two pointers do not alias even if the rules above permit them to be.\n\nNote that type-punning may also be performed through the inactive member of a [union](union \"c/language/union\").\n\n### Alignment\n\nEvery complete [object type](types#Type_groups \"c/language/types\") has a property called *alignment requirement*, which is an integer value of type [`size_t`](../types/size_t \"c/types/size t\") representing the number of bytes between successive addresses at which objects of this type can be allocated. The valid alignment values are non-negative integral powers of two.\n\n|                                                                                                       |             |\n|-------------------------------------------------------------------------------------------------------|-------------|\n| The alignment requirement of a type can be queried with [`_Alignof`](_alignof \"c/language/ Alignof\"). | (since C11) |\n\nIn order to satisfy alignment requirements of all members of a struct, padding may be inserted after some of its members.\n\n```\n#include <stdalign.h>\n#include <stdio.h>\n \n// objects of struct S can be allocated at any address\n// because both S.a and S.b can be allocated at any address\nstruct S\n{\n    char a; // size: 1, alignment: 1\n    char b; // size: 1, alignment: 1\n}; // size: 2, alignment: 1\n \n// objects of struct X must be allocated at 4-byte boundaries\n// because X.n must be allocated at 4-byte boundaries\n// because int's alignment requirement is (usually) 4\nstruct X\n{\n    int n;  // size: 4, alignment: 4\n    char c; // size: 1, alignment: 1\n    // three bytes padding\n}; // size: 8, alignment: 4\n \nint main(void)\n{\n    printf(\"sizeof(struct S) = %zu\\n\", sizeof(struct S));\n    printf(\"alignof(struct S) = %zu\\n\", alignof(struct S));\n    printf(\"sizeof(struct X) = %zu\\n\", sizeof(struct X));\n    printf(\"alignof(struct X) = %zu\\n\", alignof(struct X));\n}\n```\n\nPossible output:\n\n```\nsizeof(struct S) = 2\nalignof(struct S) = 1\nsizeof(struct X) = 8\nalignof(struct X) = 4\n```\n\nEach object type imposes its alignment requirement on every object of that type. The weakest (smallest) alignment is the alignment of the types char, signed char, and unsigned char, and equals 1. The strictest (largest) *fundamental alignment* of any type is implementation-definedand equal to the alignment of [`max_align_t`](../types/max_align_t \"c/types/max align t\")(since C11).\n\nFundamental alignments are supported for objects of all kinds of storage durations.\n\n[TABLE]\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                                           | Correct behavior                   |\n|-----------------------------------------------------------------------------|------------|-----------------------------------------------------------------|------------------------------------|\n| [DR 445](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_445) | C11        | a type might have extended alignment without \\_Alignas involved | it must have fundamental alignment |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 3.15 object (p: 5)\n  - 6.2.6 Representations of types (p: 33-35)\n  - 6.2.8 Alignment of objects (p: 36-37)\n  - 6.5/6-7 Expressions (p: 55-56)\n- C11 standard (ISO/IEC 9899:2011):\n  - 3.15 object (p: 6)\n  - 6.2.6 Representations of types (p: 44-46)\n  - 6.2.8 Alignment of objects (p: 48-49)\n  - 6.5/6-7 Expressions (p: 77)\n- C99 standard (ISO/IEC 9899:1999):\n  - 3.2 alignment (p: 3)\n  - 3.14 object (p: 5)\n  - 6.2.6 Representations of types (p: 37-39)\n  - 6.5/6-7 Expressions (p: 67-68)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 1.6 Definitions of terms\n\n### See also\n\n|                                                                                                         |     |\n|---------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/object \"cpp/language/object\") for Object |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/object](https://en.cppreference.com/w/c/language/object)"
- name: offsetof
  summary: The macro offsetof expands to an integer constant expression of type size_t, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified subobject, including padding if any
  description: "# offsetof\n\n[TABLE]\n\nThe macro `offsetof` expands to an [integer constant expression](../language/constant_expression#Integer_constant_expression \"c/language/constant expression\") of type [`size_t`](size_t \"c/types/size t\"), the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified subobject, including padding if any.\n\nGiven an object `o` of type `type` with static storage duration, `&(o.member)` shall be an address constant expression and point to a subobject of `o`. Otherwise, the behavior is undefined.\n\n|                                                                                                                    |             |\n|--------------------------------------------------------------------------------------------------------------------|-------------|\n| If the type name specified in `type` contains a comma not between matching parentheses, the behavior is undefined. | (since C23) |\n\n### Notes\n\nIf `offsetof` is applied to a bit-field member, the behavior is undefined, because the address of a bit-field cannot be taken.\n\n`member` is not restricted to a direct member. It can denote a subobject of a given member, such as an element of an array member.\n\nEven though it is specified in C23 that specifying a new type containg an unparenthesized comma in `offsetof` is undefined behavior, such usage is generally not supported even in earlier modes: `offsetof(struct Foo { int a, b; }, a)` generally fails to compile.\n\n|                                                                                                                                                                                                     |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| [`typeof`](../language/typeof \"c/language/typeof\") can be used to avoid the bad effect of commas in the definition of a new type, e.g. `offsetof(typeof(struct { int i, j; }), i)` is well-defined. | (since C23) |\n\n### Example\n\n```\n#include <stdio.h>\n#include <stddef.h>\n \nstruct S {\n    char c;\n    double d;\n};\n \nint main(void)\n{\n    printf(\"the first element is at offset %zu\\n\", offsetof(struct S, c));\n    printf(\"the double is at offset %zu\\n\", offsetof(struct S, d));\n}\n```\n\nPossible output:\n\n```\nthe first element is at offset 0\nthe double is at offset 8\n```\n\n### Defect reports\n\nThe following behavior-changing defect reports were applied retroactively to previously published C standards.\n\n| DR                                                                          | Applied to | Behavior as published                          | Correct behavior                               |\n|-----------------------------------------------------------------------------|------------|------------------------------------------------|------------------------------------------------|\n| [DR 496](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2396.htm#dr_496) | C89        | only structs and struct members were mentioned | unions and other subobjects are also supported |\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types/offsetof](https://en.cppreference.com/w/c/types/offsetof)"
- name: once_flag
  summary: (none)
  description: "# call_once, once_flag, ONCE_FLAG_INIT\n\n[TABLE]\n\n1) Calls function `func` exactly once, even if invoked from several threads. The completion of the function `func` synchronizes with all previous or subsequent calls to `call_once` with the same `flag` variable.\n\n2) Complete object type capable of holding a flag used by `call_once`.\n\n3) Expands to a value that can be used to initialize an object of type `once_flag`.\n\n### Parameters\n\n|      |     |                                                                                            |\n|------|-----|--------------------------------------------------------------------------------------------|\n| flag | \\-  | pointer to an object of type `call_once` that is used to ensure `func` is called only once |\n| func | \\-  | the function to execute only once                                                          |\n\n### Return value\n\n(none)\n\n### Notes\n\nThe POSIX equivalent of this function is [`pthread_once`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_once.html).\n\n### Example\n\n```\n#include <stdio.h>\n#include <threads.h>\n \nvoid do_once(void) {\n    puts(\"called once\");\n}\n \nstatic once_flag flag = ONCE_FLAG_INIT;\nint func(void* data)\n{\n    call_once(&flag, do_once);\n}\n \nint main(void)\n{\n    thrd_t t1, t2, t3, t4;\n    thrd_create(&t1, func, NULL);\n    thrd_create(&t2, func, NULL);\n    thrd_create(&t3, func, NULL);\n    thrd_create(&t4, func, NULL);\n \n    thrd_join(t1, NULL);\n    thrd_join(t2, NULL);\n    thrd_join(t3, NULL);\n    thrd_join(t4, NULL);\n}\n```\n\nOutput:\n\n```\ncalled once\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.2.1 The call_once function (p: 275)\n  - 7.26.1/3 ONCE_FLAG_INIT (p: 274)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.2.1 The call_once function (p: 378)\n  - 7.26.1/3 ONCE_FLAG_INIT (p: 376)\n\n### See also\n\n|                                                                                                                |     |\n|----------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/call_once \"cpp/thread/call once\") for `call_once` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/call_once](https://en.cppreference.com/w/c/thread/call_once)"
- name: ONCE_FLAG_INIT
  summary: (none)
  description: "# call_once, once_flag, ONCE_FLAG_INIT\n\n[TABLE]\n\n1) Calls function `func` exactly once, even if invoked from several threads. The completion of the function `func` synchronizes with all previous or subsequent calls to `call_once` with the same `flag` variable.\n\n2) Complete object type capable of holding a flag used by `call_once`.\n\n3) Expands to a value that can be used to initialize an object of type `once_flag`.\n\n### Parameters\n\n|      |     |                                                                                            |\n|------|-----|--------------------------------------------------------------------------------------------|\n| flag | \\-  | pointer to an object of type `call_once` that is used to ensure `func` is called only once |\n| func | \\-  | the function to execute only once                                                          |\n\n### Return value\n\n(none)\n\n### Notes\n\nThe POSIX equivalent of this function is [`pthread_once`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_once.html).\n\n### Example\n\n```\n#include <stdio.h>\n#include <threads.h>\n \nvoid do_once(void) {\n    puts(\"called once\");\n}\n \nstatic once_flag flag = ONCE_FLAG_INIT;\nint func(void* data)\n{\n    call_once(&flag, do_once);\n}\n \nint main(void)\n{\n    thrd_t t1, t2, t3, t4;\n    thrd_create(&t1, func, NULL);\n    thrd_create(&t2, func, NULL);\n    thrd_create(&t3, func, NULL);\n    thrd_create(&t4, func, NULL);\n \n    thrd_join(t1, NULL);\n    thrd_join(t2, NULL);\n    thrd_join(t3, NULL);\n    thrd_join(t4, NULL);\n}\n```\n\nOutput:\n\n```\ncalled once\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.2.1 The call_once function (p: 275)\n  - 7.26.1/3 ONCE_FLAG_INIT (p: 274)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.2.1 The call_once function (p: 378)\n  - 7.26.1/3 ONCE_FLAG_INIT (p: 376)\n\n### See also\n\n|                                                                                                                |     |\n|----------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/call_once \"cpp/thread/call once\") for `call_once` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/call_once](https://en.cppreference.com/w/c/thread/call_once)"
- name: Order of evaluation
  summary: Order of evaluation of the operands of any C operator, including the order of evaluation of function arguments in a function-call expression, and the order of evaluation of the subexpressions within any expression is unspecified (except where noted below)
  description: "# Order of evaluation\n\nOrder of evaluation of the operands of any C operator, including the order of evaluation of function arguments in a function-call expression, and the order of evaluation of the subexpressions within any expression is unspecified (except where noted below). The compiler will evaluate them in any order, and may choose another order when the same expression is evaluated again.\n\nThere is no concept of left-to-right or right-to-left evaluation in C, which is not to be confused with left-to-right and right-to-left associativity of operators: the expression `f1() + f2() + f3()` is parsed as `(f1() + f2()) + f3()` due to left-to-right associativity of operator+, but the function call to `f3` may be evaluated first, last, or between `f1()` or `f2()` at run time.\n\n### Definitions\n\n#### Evaluations\n\nThere are two kinds of evaluations performed by the compiler for each expression or subexpression (both of which are optional):\n\n- *value computation*: calculation of the value that is returned by the expression. This may involve determination of the identity of the object ([lvalue evaluation](value_category \"c/language/value category\")) or reading the value previously assigned to an object (rvalue evaluation)\n- *side effect*: access (read or write) to an object designated by a [volatile](volatile \"c/language/volatile\") lvalue, modification (writing) to an object, atomic synchronization(since C11), modifying a file, modifying the floating-point environment (if supported), or calling a function that does any of those operations.\n\nIf no side effects are produced by an expression and the compiler can determine that the value is not used, the expression [may not be evaluated](as_if \"c/language/as if\").\n\n#### Ordering\n\n\"sequenced-before\" is an asymmetric, transitive, pair-wise relationship between evaluations within the same thread (it may extend across threads if atomic types and memory barriers are involved).\n\n- If a [*sequence point*](https://en.wikipedia.org/wiki/Sequence_point \"enwiki:Sequence point\") is present between the subexpressions E1 and E2, then both value computation and side effects of E1 are *sequenced-before* every value computation and side effect of E2\n\n[TABLE]\n\n### Rules\n\n1) There is a sequence point after the evaluation of all function arguments and of the function designator, and before the actual function call.\n\n2) There is a sequence point after evaluation of the first (left) operand and before evaluation of the second (right) operand of the following binary operators: `&&` (logical AND), `||` (logical OR), and `,` (comma).\n\n3) There is a sequence point after evaluation of the first (left) operand and before evaluation of the second or third operand (whichever is evaluated) of the conditional operator `?:`\n\n4) There is a sequence point after the evaluation of a full expression (an expression that is not a subexpression: typically something that ends with a semicolon or a [controlling statement](statements \"c/language/statements\") of `if`/`switch`/`while`/`do`) and before the next full expression.\n\n|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| 5) There is a sequence point at the end of a full declarator. 6) There is a sequence point immediately before the return of a library function. 7) There is a sequence point after the action associated with each conversion specifier in formatted I/O (in particular, it is well-formed for [`scanf`](../io/fscanf \"c/io/fscanf\") to write different fields into the same variable and for [`printf`](../io/fprintf \"c/io/fprintf\") to read and modify or modify the same variable more than once using `%n`) 8) There are sequence points before and immediately after each call to a comparison function made by the library functions [`qsort`](../algorithm/qsort \"c/algorithm/qsort\") and [`bsearch`](../algorithm/bsearch \"c/algorithm/bsearch\"), as well as between any call to the comparison function and the movement of the associated objects made by [`qsort`](../algorithm/qsort \"c/algorithm/qsort\")                                                                                                                                                                                                                            | (since C99) |\n| 9) The value computations (but not the side-effects) of the operands to any operator are sequenced before the value computation of the result of the operator (but not its side-effects). 10) The side effect (modification of the left argument) of the direct assignment operator and of all compound assignment operators is sequenced after the value computation (but not the side effects) of both left and right arguments. 11) The value computation of the postincrement and postdecrement operators is sequenced before its side-effect. 12) A function call that is not sequenced before or sequenced after another function call is indeterminately sequenced (CPU instructions that constitute different function calls cannot be interleaved, even if the functions are inlined) 13) In [initialization](initialization \"c/language/initialization\") list expressions, all evaluations are indeterminately sequenced 14) With respect to an indeterminately-sequenced function call, the operation of compound assignment operators, and both prefix and postfix forms of increment and decrement operators are single evaluations. | (since C11) |\n\n### Undefined behavior\n\n1) If a side effect on a scalar object is unsequenced relative to another side effect on the same scalar object, the [behavior is undefined](behavior#UB_and_optimization \"c/language/behavior\").\n\n```\ni = ++i + i++; // undefined behavior\ni = i++ + 1; // undefined behavior\nf(++i, ++i); // undefined behavior\nf(i = -1, i = -1); // undefined behavior\n```\n\n2) If a side effect on a scalar object is unsequenced relative to a value computation using the value of the same scalar object, the behavior is undefined.\n\n```\nf(i, i++); // undefined behavior\na[i] = i++; // undefined bevahior\n```\n\n3) The above rules apply as long as at least one allowable ordering of subexpressions permits such an unsequenced side-effect.\n\n### See also\n\n[Operator precedence](operator_precedence \"c/language/operator precedence\") which defines how expressions are built from their source code representation.\n\n|                                                                                                                              |     |\n|------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/eval_order \"cpp/language/eval order\") for Order of evaluation |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/eval_order](https://en.cppreference.com/w/c/language/eval_order)"
- name: Other operators
  summary: A collection of operators that do not fit into any of the other major categories
  description: "# Other operators\n\nA collection of operators that do not fit into any of the other major categories.\n\n[TABLE]\n\n### Function call\n\nThe function call expression has the form\n\n|                                             |     |     |\n|---------------------------------------------|-----|-----|\n| expression `(` argument-list \uFEFF(optional) `)` |     |     |\n\nwhere\n\n|               |     |                                                                                                                                                                  |\n|---------------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| expression    | \\-  | any expression of pointer-to-function type (after [lvalue conversions](conversion#Lvalue_conversions \"c/language/conversion\"))                                   |\n| argument-list | \\-  | comma-separated list of expressions (which cannot be comma operators) of any complete object type. May be omitted when calling functions that take no arguments. |\n\nThe behavior of the function call expression depends on whether the prototype of the function being called is [in scope](scope \"c/language/scope\") at the point of call.\n\n#### Call to a function with a prototype\n\n1) The number of parameters must equal the number of arguments (unless the ellipsis parameter is used).\n\n2) The type of each parameter must be a type such that [implicit conversion as if by assignment](conversion \"c/language/conversion\") exists that converts the unqualified type of the corresponding argument to the type of the parameter.\n\n|                                                                                                                                                                                                                                                                                                    |             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| Additionally, for every parameter of [array type](array \"c/language/array\") that uses the keyword `static` between `[` and `]`, the argument expression must designate a pointer to the element of an array with at least that many elements as specified in the size expression of the parameter. | (since C99) |\n\n3) The arguments are evaluated [in unspecified order and without sequencing](eval_order \"c/language/eval order\").\n\n4) [Assignment](operator_assignment \"c/language/operator assignment\") is performed to copy the value of each argument to the corresponding function parameter, ignoring any type qualifiers on the parameter type and its possibly recursive elements or members, if any (note: the function can modify its parameters, and those changes do not affect the arguments; C function calls are only call-by-value).\n\n- if there is a [trailing ellipsis](variadic \"c/language/variadic\") parameter, [Default argument promotions](https://en.cppreference.com/mwiki/index.php?title=conversion&action=edit&redlink=1 \"conversion (page does not exist)\") are performed on the remaining arguments, which are made available to `va_list`.\n\n5) Function is executed, and the value it returns becomes the value of the function call expression (if the function returns void, the function call expression is a void expression)\n\n```\nvoid f(char* p, int x) {}\nint main(void)\n{\n    f(\"abc\", 3.14); // array to pointer and float to int conversions\n}\n```\n\n[TABLE]\n\n#### Notes\n\nThe evaluations of expression that designates the function to be called and all arguments are [unsequenced](eval_order \"c/language/eval order\") with respect to each other (but there is a sequence point before the body of the function begins executing)\n\n```\n(*pf[f1()]) (f2(), f3() + f4()); // f1, f2, f3, f4 may be called in any order\n```\n\nAlthough function call is only defined for pointers to functions, it works with function designators due to the [function-to-pointer implicit conversion](conversion#Function_to_pointer_conversion \"c/language/conversion\").\n\n```\nint f(void) { return 1; }\nint (*pf)(void) = f;\n \nint main(void)\n{\n    f();    // convert f to pointer, then call\n    (&f)(); // create a pointer to function, then call\n \n    pf();    // call the function\n    (*pf)(); // obtain the function designator, convert to pointer, then calls\n \n    (****f)(); // convert to pointer, obtain the function, repeat 4x, then call\n    (****pf)(); // also OK\n}\n```\n\nFunctions that ignore unused arguments, such as [`printf`](../io/fprintf \"c/io/fprintf\"), must be called with a prototype in scope (the prototype of such functions necessarily uses the [trailing ellipsis](variadic \"c/language/variadic\") parameter) to avoid invoking undefined behavior.\n\nThe current standard wording of the semantics of preparing function parameters is defective, because it specifies that parameters are assigned from arguments while calling, which incorrectly rejects const-qualified parameter or member types, and inappropriately applies the semantics of volatile which is unimplementable for function parameters on many platforms. A post-C11 defect report [DR427](https://open-std.org/JTC1/SC22/WG14/www/docs/n2396.htm#dr_427) proposed change of such semantics from assignment to initialization, but was closed as not-a-defect.\n\n[TABLE]\n\n### Comma operator\n\nThe comma operator expression has the form\n\n|             |     |     |\n|-------------|-----|-----|\n| lhs `,` rhs |     |     |\n\nwhere\n\n|     |     |                                                                                                                                                                            |\n|-----|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| lhs | \\-  | any expression                                                                                                                                                             |\n| rhs | \\-  | any expression other than another comma operator (in other words, comma operator's [associativity](operator_precedence \"c/language/operator precedence\") is left-to-right) |\n\nFirst, the left operand, lhs, is evaluated and its result value is discarded.\n\nThen, a [sequence point](eval_order \"c/language/eval order\") takes place, so that all side effects of lhs are complete.\n\nThen, the right operand, rhs, is evaluated and its result is returned by the comma operator as a [non-lvalue](value_category \"c/language/value category\").\n\n### Notes\n\nThe type of the lhs may be `void` (that is, it may be a call to a function that returns `void`, or it can be an expression [cast](cast \"c/language/cast\") to `void`)\n\nThe comma operator may be lvalue in C++, but never in C\n\nThe comma operator may return a struct (the only other expressions that return structs are compound literals, function calls, assignments, and the conditional operator)\n\nIn the following contexts, the comma operator cannot appear at the top level of an expression because the comma has a different meaning:\n\n- argument list in a function call\n- initializer expression or [initializer list](initialization \"c/language/initialization\")\n- [generic selection](generic \"c/language/generic\")\n\nIf the comma operator has to be used in such context, it must be parenthesized:\n\n```\n// int n = 2,3; // error, comma assumed to begin the next declarator\n// int a[2] = {1,2,3}; // error: more initializers than elements\nint n = (2,3), a[2] = {(1,2),3}; // OK\n \nf(a, (t=3, t+2), c); // OK, first, stores 3 in t, then calls f with three arguments\n```\n\nTop-level comma operator is also disallowed in array bounds\n\n```\n// int a[2,3]; // error\nint a[(2,3)]; // OK, VLA array of size 3 (VLA because (2,3) is not a constant expression)\n```\n\nComma operator is not allowed in [constant expressions](constant_expression \"c/language/constant expression\"), regardless of whether it's on the top level or not\n\n```\n// static int n = (1,2); // Error: constant expression cannot call the comma operator\n```\n\n### Cast operator\n\nSee [cast operator](cast \"c/language/cast\")\n\n### Conditional operator\n\nThe conditional operator expression has the form\n\n|                                                    |     |     |\n|----------------------------------------------------|-----|-----|\n| condition `?` expression-true `:` expression-false |     |     |\n\nwhere\n\n|                  |     |                                                                             |\n|------------------|-----|-----------------------------------------------------------------------------|\n| condition        | \\-  | an expression of scalar type                                                |\n| expression-true  | \\-  | the expression that will be evaluated if condition compares unequal to zero |\n| expression-false | \\-  | the expression that will be evaluated if condition compares equal to zero   |\n\nOnly the following expressions are allowed as expression-true and expression-false\n\n- two expressions of any [arithmetic type](arithmetic_types \"c/language/arithmetic types\")\n- two expressions of the same [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") type\n- two expressions of void type\n- two expressions of pointer type, pointing to types that are [compatible](type#Compatible_types \"c/language/type\"), ignoring cvr-qualifiers\n\n[TABLE]\n\n- one expression is a pointer and the other is the null pointer constant (such as [`NULL`](../types/null \"c/types/NULL\"))or a [`nullptr_t`](../types/nullptr_t \"c/types/nullptr t\") value(since C23)\n- one expression is a pointer to object and the other is a pointer to void (possibly qualified)\n\n1) First, evaluates condition. There is a [sequence point](eval_order \"c/language/eval order\") after this evaluation.\n\n2) If the result of condition compares unequal to zero, executes expression-true, otherwise executes expression-false\n\n3) Performs a [conversion](conversion \"c/language/conversion\") from the result of the evaluation to the *common type*, defined as follows:\n\n1) if the expressions have arithmetic type, the common type is the type after [usual arithmetic conversions](conversion#Usual_arithmetic_conversions \"c/language/conversion\")\n\n2) if the expressions have struct/union type, the common type is that struct/union type\n\n3) if the expressions are both void, the entire conditional operator expression is a void expression\n\n4) if one is a pointer and the other is a null pointer constantor a [`nullptr_t`](../types/nullptr_t \"c/types/nullptr t\") value(since C23), the type is the type of that pointer\n\n5) if both are pointers, the result is the pointer to the type that combines cvr-qualifiers of both pointed-to types (that is, if one is `const int*` and the other is `volatile int*`, the result is `const volatile int*`), and if the types were different, the pointed-to type is the [composite type](types#Composite_type \"c/language/types\").\n\n6) if one is a pointer to void, the result is a pointer to void with combined cvr-qualifiers\n\n|                                                                                                                                                           |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| 7) if both have [`nullptr_t`](../types/nullptr_t \"c/types/nullptr t\") type, the common type is also [`nullptr_t`](../types/nullptr_t \"c/types/nullptr t\") | (since C23) |\n\n```\n#define ICE(x) (sizeof(*(1 ? ((void*)((x) * 0l)) : (int*)1)))\n \n// if x is an Integer Constant Expression then macro expands to\n \nsizeof(*(1 ? NULL : (int *) 1))  // (void *)((x)*0l)) -> NULL\n \n// according to point (4) this further converts into\n \nsizeof(int)\n \n// if x is not an Integer Constant Expression then macro expands to\n// according to point (6)\n \n(sizeof(*(void *)(x))           // Error due incomplete type\n```\n\n#### Notes\n\nThe conditional operator is never an [lvalue expression](value_category \"c/language/value category\"), although it may return objects of struct/union type. The only other expressions that may return structs are [assignment](operator_assignment \"c/language/operator assignment\"), [comma](#Comma_operator), [function call](#Function_call), and [compound literal](compound_literal \"c/language/compound literal\").\n\nNote that in C++, it may be an lvalue expression.\n\nSee [operator precedence](operator_precedence \"c/language/operator precedence\") for the details on the relative precedence of this operator and assignment.\n\nConditional operator has right-to-left associativity, which allows chaining\n\n```\n#include <assert.h>\n \nenum vehicle { bus, airplane, train, car, horse, feet };\n \nenum vehicle choose(char arg)\n{\n    return arg == 'B' ? bus      :\n           arg == 'A' ? airplane :\n           arg == 'T' ? train    :\n           arg == 'C' ? car      :\n           arg == 'H' ? horse    :\n                        feet     ;\n}\n \nint main(void)\n{\n    assert(choose('H') == horse && choose('F') == feet);\n}\n```\n\n### `sizeof` operator\n\nSee [sizeof operator](sizeof \"c/language/sizeof\")\n\n### `_Alignof` operator\n\nSee [\\_Alignof operator](_alignof \"c/language/ Alignof\")\n\n### `typeof` operators\n\nSee [typeof operators](typeof \"c/language/typeof\")\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.5.2.2 Function calls (p: TBD)\n  - 6.5.3.4 The sizeof and \\_Alignof operators (p: TBD)\n  - 6.5.4 Cast operators (p: TBD)\n  - 6.5.15 Conditional operator (p: TBD)\n  - 6.5.17 Comma operator (p: TBD)\n  - 6.7.3.5 Typeof specifiers (p: 115-118)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.2.2 Function calls (p: 58-59)\n  - 6.5.3.4 The sizeof and \\_Alignof operators (p: 64-65)\n  - 6.5.4 Cast operators (p: 65-66)\n  - 6.5.15 Conditional operator (p: 71-72)\n  - 6.5.17 Comma operator (p: 75)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.2.2 Function calls (p: 81-82)\n  - 6.5.3.4 The sizeof and \\_Alignof operators (p: 90-91)\n  - 6.5.4 Cast operators (p: 91)\n  - 6.5.15 Conditional operator (p: 100)\n  - 6.5.17 Comma operator (p: 105)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5.2.2 Function calls (p: 71-72)\n  - 6.5.3.4 The sizeof operator (p: 80-81)\n  - 6.5.4 Cast operators (p: 81)\n  - 6.5.15 Conditional operator (p: 90-91)\n  - 6.5.17 Comma operator (p: 94)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.3.2.2 Function calls\n  - 3.3.3.4 The sizeof operator\n  - 3.3.4 Cast operators\n  - 3.3.15 Conditional operator\n  - 3.3.17 Comma operator\n\n### See also\n\n- [Operator precedence](operator_precedence \"c/language/operator precedence\")\n\n[TABLE]\n\n|                                                                                                                                  |     |\n|----------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/operator_other \"cpp/language/operator other\") for Other operators |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/operator_other](https://en.cppreference.com/w/c/language/operator_other)"
- name: perror
  summary: Prints a textual description of the error code currently stored in the system variable errno to stderr
  description: "# perror\n\n[TABLE]\n\nPrints a textual description of the error code currently stored in the system variable [`errno`](../error/errno \"c/error/errno\") to [`stderr`](std_streams \"c/io/std streams\").\n\nThe description is formed by concatenating the following components:\n\n- the contents of the null-terminated byte string pointed to by `s`, followed by `\": \"` (unless `s` is a null pointer or the character pointed to by `s` is the null character)\n- implementation-defined error message string describing the error code stored in `errno`, followed by `'\\n'`. The error message string is identical to the result of [`strerror`](http://en.cppreference.com/w/c/string/byte/strerror)`(``errno``)`.\n\n### Parameters\n\n|     |     |                                                              |\n|-----|-----|--------------------------------------------------------------|\n| s   | \\-  | pointer to a null-terminated string with explanatory message |\n\n### Return value\n\n(none)\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    FILE *f = fopen(\"non_existent\", \"r\");\n    if (f == NULL) {\n        perror(\"fopen() failed\");\n    } else {\n        fclose(f);\n    }\n}\n```\n\nPossible output:\n\n```\nfopen() failed: No such file or directory\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.10.4 The perror function (p: 339)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.10.4 The perror function (p: 305)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.10.4 The perror function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/perror](https://en.cppreference.com/w/c/io/perror)"
- name: Phases of translation
  summary: The C source file is processed by the compiler as if the following phases take place, in this exact order
  description: "# Phases of translation\n\nThe C source file is processed by the compiler *as if* the following phases take place, in this exact order. Actual implementation may combine these actions or process them differently as long as the behavior is the same.\n\n### Phase 1\n\n1) The individual bytes of the source code file (which is generally a text file in some multibyte encoding such as UTF-8) are mapped, in implementation defined manner, to the characters of the *source character set*. In particular, OS-dependent end-of-line indicators are replaced by newline characters. The *source character set* is a multibyte character set which includes the *basic source character set* as a single-byte subset, consisting of the following 96 characters:\n\na) 5 whitespace characters (space, horizontal tab, vertical tab, form feed, new-line)\n\nb) 10 digit characters from `'0'` to `'9'`\n\nc) 52 letters from `'a'` to `'z'` and from `'A'` to `'Z'`\n\nd) 29 punctuation characters: `_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \\ \" '`\n\n2) [Trigraph sequences](operator_alternative \"c/language/operator alternative\") are replaced by corresponding single-character representations.(until C23)\n\n### Phase 2\n\n1) Whenever backslash appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation: a line ending in two backslashes followed by an empty line does not combine three lines into one.\n\n```\n#include <stdio.h>\n \n#define PUTS p\\\nu\\\nt\\\ns\n/* Line splicing is in phase 2 while macros\n * are tokenized in phase 3 and expanded in phase 4,\n * so the above is equivalent to #define PUTS puts\n */\n \nint main(void)\n{\n /* Use line splicing to call puts */ PUT\\\nS\\\n(\"Output ends here\\\\\n0Not printed\" /* After line splicing, the remaining backslash\n               * escapes the 0, ending the string early.\n               */\n);\n}\n```\n\n2) If a non-empty source file does not end with a newline character after this step (whether it had no newline originally, or it ended with a backslash), the behavior is undefined.\n\n### Phase 3\n\n1) The source file is decomposed into [comment](../comment \"c/comment\"), sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and *preprocessing tokens*, which are the following\n\na) header names: `<stdio.h>` or `\"myfile.h\"`\n\nb) [identifiers](identifier \"c/language/identifier\")\n\nc) preprocessing numbers, which cover [integer constants](integer_constant \"c/language/integer constant\") and [floating constants](floating_constant \"c/language/floating constant\"), but also cover some invalid tokens such as `1..E+3.foo` or `0JBK`\n\nd) [character constants](character_constant \"c/language/character constant\") and [string literals](string_literal \"c/language/string literal\")\n\ne) operators and punctuators, such as `+`, `<<=`, `<%`, or `##`.\n\nf) individual non-whitespace characters that do not fit in any other category\n\n2) Each comment is replaced by one space character\n\n3) Newlines are kept, and it's implementation-defined whether non-newline whitespace sequences may be collapsed into single space characters.\n\nIf the input has been parsed into preprocessing tokens up to a given character, the next preprocessing token is generally taken to be the longest sequence of characters that could constitute a preprocessing token, even if that would cause subsequent analysis to fail. This is commonly known as *maximal munch*.\n\n```\nint foo = 1;\n// int bar = 0xE+foo; // error: invalid preprocessing number 0xE+foo\nint bar = 0xE/*Comment expands to a space*/+foo; // OK: 0xE + foo\nint baz = 0xE + foo; // OK: 0xE + foo\nint pub = bar+++baz; // OK: bar++ + baz\nint ham = bar++-++baz; // OK: bar++ - ++baz\n// int qux = bar+++++baz; // error: bar++ ++ +baz, not bar++ + ++baz\nint qux = bar+++/*Saving comment*/++baz; // OK: bar++ + ++baz\n```\n\nThe sole exception to the maximal munch rule is:\n\n- Header name preprocessing tokens are only formed within a [` #include`](../preprocessor/include \"c/preprocessor/include\") or [` #embed`](../preprocessor/embed \"c/preprocessor/embed\")(since C23) directive, in [`__has_include`](../preprocessor/include \"c/preprocessor/include\") and [`__has_embed`](../preprocessor/embed \"c/preprocessor/embed\") expressions(since C23) and in implementation-defined locations within a [` #pragma`](../preprocessor/impl \"c/preprocessor/impl\") directive.\n\n```\n#define MACRO_1 1\n#define MACRO_2 2\n#define MACRO_3 3\n#define MACRO_EXPR (MACRO_1 <MACRO_2> MACRO_3) // OK: <MACRO_2> is not a header-name\n```\n\n### Phase 4\n\n1) [Preprocessor](../preprocessor \"c/preprocessor\") is executed.\n\n2) Each file introduced with the [\\#include](../preprocessor/include \"c/preprocessor/include\") directive goes through phases 1 through 4, recursively.\n\n3) At the end of this phase, all preprocessor directives are removed from the source.\n\n### Phase 5\n\n1) All characters and [escape sequences](escape \"c/language/escape\") in [character constants](character_constant \"c/language/character constant\") and [string literals](string_literal \"c/language/string literal\") are converted from *source character set* to *execution character set* (which may be a multibyte character set such as UTF-8, as long as all 96 characters from the *basic source character set* listed in phase 1 have single-byte representations). If the character specified by an escape sequence isn't a member of the execution character set, the result is implementation-defined, but is guaranteed to not be a null (wide) character.\n\nNote: the conversion performed at this stage can be controlled by command line options in some implementations: gcc and clang use `-finput-charset` to specify the encoding of the source character set, `-fexec-charset` and `-fwide-exec-charset` to specify the encodings of the execution character set in the string literals and character constants that don't have an encoding prefix(since C11).\n\n### Phase 6\n\nAdjacent [string literals](string_literal \"c/language/string literal\") are concatenated.\n\n### Phase 7\n\nCompilation takes place: the tokens are syntactically and semantically analyzed and translated as a translation unit.\n\n### Phase 8\n\nLinking takes place: Translation units and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment (the OS).\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 5.1.1.2 Translation phases (p: TBD)\n  - 5.2.1 Character sets (p: TBD)\n  - 6.4 Lexical elements (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 5.1.1.2 Translation phases (p: 9-10)\n  - 5.2.1 Character sets (p: 17)\n  - 6.4 Lexical elements (p: 41-54)\n- C11 standard (ISO/IEC 9899:2011):\n  - 5.1.1.2 Translation phases (p: 10-11)\n  - 5.2.1 Character sets (p: 22-24)\n  - 6.4 Lexical elements (p: 57-75)\n- C99 standard (ISO/IEC 9899:1999):\n  - 5.1.1.2 Translation phases (p: 9-10)\n  - 5.2.1 Character sets (p: 17-19)\n  - 6.4 Lexical elements (p: 49-66)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 2.1.1.2 Translation phases\n  - 2.2.1 Character sets\n  - 3.1 Lexical elements\n\n### See also\n\n|                                                                                                                                                |     |\n|------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/translation_phases \"cpp/language/translation phases\") for Phases of translation |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/translation_phases](https://en.cppreference.com/w/c/language/translation_phases)"
- name: Pointer declaration
  summary: Pointer is a type of an object that refers to a function or an object of another type, possibly adding qualifiers
  description: "# Pointer declaration\n\nPointer is a type of an object that refers to a function or an object of another type, possibly adding qualifiers. Pointer may also refer to nothing, which is indicated by the special null pointer value.\n\n### Syntax\n\nIn the [declaration grammar](declarations \"c/language/declarations\") of a pointer declaration, the type-specifier sequence designates the pointed-to type (which may be function or object type and may be incomplete), and the declarator has the form:\n\n|                                                             |     |     |\n|-------------------------------------------------------------|-----|-----|\n| `*` attr-spec-seq(optional) qualifiers(optional) declarator |     |     |\n\nwhere declarator may be the identifier that names the pointer being declared, including another pointer declarator (which would indicate a pointer to a pointer):\n\n```\nfloat *p, **pp; // p is a pointer to float\n                // pp is a pointer to a pointer to float\nint (*fp)(int); // fp is a pointer to function with type int(int)\n```\n\nThe qualifiers that appear between `*` and the identifier (or other nested declarator) qualify the type of the pointer that is being declared:\n\n```\nint n;\nconst int * pc = &n; // pc is a non-const pointer to a const int\n// *pc = 2; // Error: n cannot be changed through pc without a cast\npc = NULL; // OK: pc itself can be changed\n \nint * const cp = &n; // cp is a const pointer to a non-const int\n*cp = 2; // OK to change n through cp\n// cp = NULL; // Error: cp itself cannot be changed\n \nint * const * pcp = &cp; // non-const pointer to const pointer to non-const int\n```\n\nThe attr-spec-seq(C23) is an optional list of [attributes](attributes \"c/language/attributes\"), applied to the declared pointer.\n\n### Explanation\n\nPointers are used for indirection, which is a ubiquitous programming technique; they can be used to implement pass-by-reference semantics, to access objects with dynamic [storage duration](storage_duration \"c/language/storage duration\"), to implement \"optional\" types (using the null pointer value), aggregation relationship between structs, callbacks (using pointers to functions), generic interfaces (using pointers to void), and much more.\n\n#### Pointers to objects\n\nA pointer to object can be initialized with the result of the [address-of operator](operator_member_access \"c/language/operator member access\") applied to an expression of object type (which may be incomplete):\n\n```\nint n;\nint *np = &n; // pointer to int\nint *const *npp = &np; // non-const pointer to const pointer to non-const int\n \nint a[2];\nint (*ap)[2] = &a; // pointer to array of int\n \nstruct S { int n; } s = {1}\nint* sp = &s.n; // pointer to the int that is a member of s\n```\n\nPointers may appear as operands to the [indirection operator](operator_member_access#Dereference \"c/language/operator member access\") (unary `*`), which returns [the lvalue](value_category \"c/language/value category\") identifying the pointed-to object:\n\n```\nint n;\nint* p = &n;     // pointer p is pointing to n\n*p = 7;         // stores 7 in n\nprintf(\"%d\\n\", *p); // lvalue-to-rvalue conversion reads the value from n\n```\n\nPointers to objects of [struct](struct \"c/language/struct\") and [union](union \"c/language/union\") type may also appear as the left-hand operands of the [member access through pointer](operator_member_access \"c/language/operator member access\") operator `->`.\n\nBecause of the [array-to-pointer](array \"c/language/array\") implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:\n\n```\nint a[2];\nint *p = a; // pointer to a[0]\n \nint b[3][3];\nint (*row)[3] = b; // pointer to b[0]\n```\n\nCertain [addition, subtraction](operator_arithmetic \"c/language/operator arithmetic\"), [compound assignment](operator_assignment \"c/language/operator assignment\"), [increment, and decrement](operator_incdec \"c/language/operator incdec\") operators are defined for pointers to elements of arrays.\n\n[Comparison operators](operator_comparison \"c/language/operator comparison\") are defined for pointers to objects in some situations: two pointers that represent the same address compare equal, two null pointer values compare equal, pointers to elements of the same array compare the same as the array indexes of those elements, and pointers to struct members compare in order of declaration of those members.\n\nMany implementations also provide [strict total ordering](https://en.wikipedia.org/wiki/Total_order#Strict_total_order \"enwiki:Total order\") of pointers of random origin, e.g. if they are implemented as addresses within continuous (\"flat\") virtual address space.\n\n#### Pointers to functions\n\nA pointer to function can be initialized with an address of a function. Because of the [function-to-pointer](conversion \"c/language/conversion\") conversion, the address-of operator is optional:\n\n```\nvoid f(int);\nvoid (*pf1)(int) = &f;\nvoid (*pf2)(int) = f; // same as &f\n```\n\nUnlike functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, passed to other functions as arguments, etc.\n\nA pointer to function can be used on the left-hand side of the [function call operator](operator_other#Function_call \"c/language/operator other\"); this invokes the pointed-to function:\n\n```\n#include <stdio.h>\nint f(int n)\n{\n    printf(\"%d\\n\", n);\n    return n*n;\n}\nint main(void)\n{\n    int (*p)(int) = f;\n    int x = p(7);\n}\n```\n\nDereferencing a function pointer yields the function designator for the pointed-to function:\n\n```\nint f();\nint (*p)() = f;    // pointer p is pointing to f\n(*p)(); // function f invoked through the function designator\np();    // function f invoked directly through the pointer\n```\n\n[Equality comparison operators](operator_comparison \"c/language/operator comparison\") are defined for pointers to functions (they compare equal if pointing to the same function).\n\nBecause [compatibility of function types](type#Compatible_types \"c/language/type\") ignores top-level qualifiers of the function parameters, pointers to functions whose parameters only differ in their top-level qualifiers are interchangeable:\n\n```\nint f(int), fc(const int);\nint (*pc)(const int) = f; // OK\nint (*p)(int) = fc;       // OK\npc = p;                   // OK\n```\n\n#### Pointers to void\n\nPointer to object of any type can be [implicitly converted](conversion \"c/language/conversion\") to pointer to `void` (optionally [const](const \"c/language/const\") or [volatile](volatile \"c/language/volatile\")-qualified), and vice versa:\n\n```\nint n=1, *p=&n;\nvoid* pv = p; // int* to void*\nint* p2 = pv; // void* to int*\nprintf(\"%d\\n\", *p2); // prints 1\n```\n\nPointers to void are used to pass objects of unknown type, which is common in generic interfaces: [`malloc`](../memory/malloc \"c/memory/malloc\") returns `void*`, [`qsort`](../algorithm/qsort \"c/algorithm/qsort\") expects a user-provided callback that accepts two `const void*` arguments. [pthread_create](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html) expects a user-provided callback that accepts and returns `void*`. In all cases, it is the caller's responsibility to convert the pointer to the correct type before use.\n\n### Null pointers\n\nPointers of every type have a special value known as *null pointer value* of that type. A pointer whose value is null does not point to an object or a function (dereferencing a null pointer is undefined behavior), and compares equal to all pointers of the same type whose value is also *null*.\n\nTo initialize a pointer to null or to assign the null value to an existing pointer, a null pointer constant ([`NULL`](../types/null \"c/types/NULL\"), or any other integer constant with the value zero) may be used. [static initialization](initialization \"c/language/initialization\") also initializes pointers to their null values.\n\nNull pointers can indicate the absence of an object or can be used to indicate other types of error conditions. In general, a function that receives a pointer argument almost always needs to check if the value is null and handle that case differently (for example, [`free`](../memory/free \"c/memory/free\") does nothing when a null pointer is passed).\n\n### Notes\n\nAlthough any pointer to object [can be cast](cast \"c/language/cast\") to pointer to object of a different type, dereferencing a pointer to the type different from the declared type of the object is almost always undefined behavior. See [strict aliasing](object#Strict_aliasing \"c/language/object\") for details.\n\n|                                                                                                                                                                               |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| It is possible to indicate to a function that accesses objects through pointers that those pointers do not alias. See [restrict](restrict \"c/language/restrict\") for details. | (since C99) |\n\nlvalue expressions of array type, when used in most contexts, undergo an [implicit conversion](conversion \"c/language/conversion\") to the pointer to the first element of the array. See [array](array#Array_to_pointer_conversion \"c/language/array\") for details.\n\n```\nchar *str = \"abc\"; // \"abc\" is a char[4] array, str is a pointer to 'a'\n```\n\nPointers to char are often [used to represent strings](../string/byte \"c/string/byte\"). To represent a valid byte string, a pointer must be pointing at a char that is an element of an array of char, and there must be a char with the value zero at some index greater or equal to the index of the element referenced by the pointer.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.6.1 Pointer declarators (p: 93-94)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.6.1 Pointer declarators (p: 130)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.5.1 Pointer declarators (p: 115-116)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.5.4.1 Pointer declarators\n\n### See also\n\n|                                                                                                                        |     |\n|------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/pointer \"cpp/language/pointer\") for Pointer declaration |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/pointer](https://en.cppreference.com/w/c/language/pointer)"
- name: pow
  summary: If no errors occur, base raised to the power of exponent (baseexponent) is returned
  description: "# pow, powf, powl\n\n[TABLE]\n\n1-3) Computes the value of `base` raised to the power `exponent`.\n\n4) Type-generic macro: If any argument has type `long double`, `powl` is called. Otherwise, if any argument has integer type or has type `double`, `pow` is called. Otherwise, `powf` is called. If at least one argument is complex or imaginary, then the macro invokes the corresponding complex function ([`cpowf`](http://en.cppreference.com/w/c/numeric/complex/cpow), [`cpow`](http://en.cppreference.com/w/c/numeric/complex/cpow), [`cpowl`](http://en.cppreference.com/w/c/numeric/complex/cpow)).\n\n### Parameters\n\n|          |     |                                  |\n|----------|-----|----------------------------------|\n| base     | \\-  | base as floating point value     |\n| exponent | \\-  | exponent as floating point value |\n\n### Return value\n\nIf no errors occur, `base` raised to the power of `exponent` (base^(exponent)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error or a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf `base` is finite and negative and `exponent` is finite and non-integer, a domain error occurs and a range error may occur.\n\nIf `base` is zero and `exponent` is zero, a domain error may occur.\n\nIf `base` is zero and `exponent` is negative, a domain error or a pole error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- `pow(+0, exponent)`, where `exponent` is a negative odd integer, returns `+∞` and raises [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- `pow(-0, exponent)`, where `exponent` is a negative odd integer, returns `-∞` and raises [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- `pow(±0, exponent)`, where `exponent` is negative, finite, and is an even integer or a non-integer, returns +∞ and raises [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- `pow(±0, -∞)` returns +∞ and may raise [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")(until C23)\n- `pow(+0, exponent)`, where `exponent` is a positive odd integer, returns +0\n- `pow(-0, exponent)`, where `exponent` is a positive odd integer, returns -0\n- `pow(±0, exponent)`, where `exponent` is positive non-integer or a positive even integer, returns +0\n- `pow(-1, ±∞)` returns `1`\n- `pow(+1, exponent)` returns `1` for any `exponent`, even when `exponent` is `NaN`\n- `pow(base, ±0)` returns `1` for any `base`, even when `base` is `NaN`\n- `pow(base, exponent)` returns `NaN` and raises [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") if `base` is finite and negative and `exponent` is finite and non-integer.\n- `pow(base, -∞)` returns +∞ for any `|base|<1`\n- `pow(base, -∞)` returns +0 for any `|base|>1`\n- `pow(base, +∞)` returns +0 for any `|base|<1`\n- `pow(base, +∞)` returns +∞ for any `|base|>1`\n- `pow(-∞, exponent)` returns -0 if `exponent` is a negative odd integer\n- `pow(-∞, exponent)` returns +0 if `exponent` is a negative non-integer or negative even integer\n- `pow(-∞, exponent)` returns -∞ if `exponent` is a positive odd integer\n- `pow(-∞, exponent)` returns +∞ if `exponent` is a positive non-integer or positive even integer\n- `pow(+∞, exponent)` returns +0 for any negative `exponent`\n- `pow(+∞, exponent)` returns +∞ for any positive `exponent`\n- except where specified above, if any argument is NaN, NaN is returned\n\n### Notes\n\nAlthough `pow` cannot be used to obtain a root of a negative number, [`cbrt`](cbrt \"c/numeric/math/cbrt\") is provided for the common case where `exponent` is 1/3.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    // typical usage\n    printf(\"pow(2, 10) = %f\\n\", pow(2,10));\n    printf(\"pow(2, 0.5) = %f\\n\", pow(2,0.5));\n    printf(\"pow(-2, -3) = %f\\n\", pow(-2,-3));\n    // special values\n    printf(\"pow(-1, NAN) = %f\\n\", pow(-1,NAN));\n    printf(\"pow(+1, NAN) = %f\\n\", pow(+1,NAN));\n    printf(\"pow(INFINITY, 2) = %f\\n\", pow(INFINITY, 2));\n    printf(\"pow(INFINITY, -1) = %f\\n\", pow(INFINITY, -1));\n    // error handling \n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"pow(-1, 1/3) = %f\\n\", pow(-1, 1.0/3));\n    if(errno == EDOM)         perror(\"    errno == EDOM\");\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"pow(-0, -3) = %f\\n\", pow(-0.0, -3));\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\npow(2, 10) = 1024.000000\npow(2, 0.5) = 1.414214\npow(-2, -3) = -0.125000\npow(-1, NAN) = nan\npow(+1, NAN) = 1.000000\npow(INFINITY, 2) = inf\npow(INFINITY, -1) = 0.000000\npow(-1, 1/3) = -nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\npow(-0, -3) = -inf\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.7.5 The pow functions\n  - 7.27 Type-generic math \\<tgmath.h\\>\n  - F.10.4.5 The pow functions (p: 524-525)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.4 The pow functions (p: 248-249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.4 The pow functions (p: 524-525)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.4 The pow functions (p: 248-249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.4 The pow functions (p: 524-525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.4 The pow functions (p: 229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.4 The pow functions (p: 461)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.5.1 The pow function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/pow](https://en.cppreference.com/w/c/numeric/math/pow)"
- name: powf
  summary: If no errors occur, base raised to the power of exponent (baseexponent) is returned
  description: "# pow, powf, powl\n\n[TABLE]\n\n1-3) Computes the value of `base` raised to the power `exponent`.\n\n4) Type-generic macro: If any argument has type `long double`, `powl` is called. Otherwise, if any argument has integer type or has type `double`, `pow` is called. Otherwise, `powf` is called. If at least one argument is complex or imaginary, then the macro invokes the corresponding complex function ([`cpowf`](http://en.cppreference.com/w/c/numeric/complex/cpow), [`cpow`](http://en.cppreference.com/w/c/numeric/complex/cpow), [`cpowl`](http://en.cppreference.com/w/c/numeric/complex/cpow)).\n\n### Parameters\n\n|          |     |                                  |\n|----------|-----|----------------------------------|\n| base     | \\-  | base as floating point value     |\n| exponent | \\-  | exponent as floating point value |\n\n### Return value\n\nIf no errors occur, `base` raised to the power of `exponent` (base^(exponent)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error or a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf `base` is finite and negative and `exponent` is finite and non-integer, a domain error occurs and a range error may occur.\n\nIf `base` is zero and `exponent` is zero, a domain error may occur.\n\nIf `base` is zero and `exponent` is negative, a domain error or a pole error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- `pow(+0, exponent)`, where `exponent` is a negative odd integer, returns `+∞` and raises [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- `pow(-0, exponent)`, where `exponent` is a negative odd integer, returns `-∞` and raises [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- `pow(±0, exponent)`, where `exponent` is negative, finite, and is an even integer or a non-integer, returns +∞ and raises [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- `pow(±0, -∞)` returns +∞ and may raise [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")(until C23)\n- `pow(+0, exponent)`, where `exponent` is a positive odd integer, returns +0\n- `pow(-0, exponent)`, where `exponent` is a positive odd integer, returns -0\n- `pow(±0, exponent)`, where `exponent` is positive non-integer or a positive even integer, returns +0\n- `pow(-1, ±∞)` returns `1`\n- `pow(+1, exponent)` returns `1` for any `exponent`, even when `exponent` is `NaN`\n- `pow(base, ±0)` returns `1` for any `base`, even when `base` is `NaN`\n- `pow(base, exponent)` returns `NaN` and raises [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") if `base` is finite and negative and `exponent` is finite and non-integer.\n- `pow(base, -∞)` returns +∞ for any `|base|<1`\n- `pow(base, -∞)` returns +0 for any `|base|>1`\n- `pow(base, +∞)` returns +0 for any `|base|<1`\n- `pow(base, +∞)` returns +∞ for any `|base|>1`\n- `pow(-∞, exponent)` returns -0 if `exponent` is a negative odd integer\n- `pow(-∞, exponent)` returns +0 if `exponent` is a negative non-integer or negative even integer\n- `pow(-∞, exponent)` returns -∞ if `exponent` is a positive odd integer\n- `pow(-∞, exponent)` returns +∞ if `exponent` is a positive non-integer or positive even integer\n- `pow(+∞, exponent)` returns +0 for any negative `exponent`\n- `pow(+∞, exponent)` returns +∞ for any positive `exponent`\n- except where specified above, if any argument is NaN, NaN is returned\n\n### Notes\n\nAlthough `pow` cannot be used to obtain a root of a negative number, [`cbrt`](cbrt \"c/numeric/math/cbrt\") is provided for the common case where `exponent` is 1/3.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    // typical usage\n    printf(\"pow(2, 10) = %f\\n\", pow(2,10));\n    printf(\"pow(2, 0.5) = %f\\n\", pow(2,0.5));\n    printf(\"pow(-2, -3) = %f\\n\", pow(-2,-3));\n    // special values\n    printf(\"pow(-1, NAN) = %f\\n\", pow(-1,NAN));\n    printf(\"pow(+1, NAN) = %f\\n\", pow(+1,NAN));\n    printf(\"pow(INFINITY, 2) = %f\\n\", pow(INFINITY, 2));\n    printf(\"pow(INFINITY, -1) = %f\\n\", pow(INFINITY, -1));\n    // error handling \n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"pow(-1, 1/3) = %f\\n\", pow(-1, 1.0/3));\n    if(errno == EDOM)         perror(\"    errno == EDOM\");\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"pow(-0, -3) = %f\\n\", pow(-0.0, -3));\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\npow(2, 10) = 1024.000000\npow(2, 0.5) = 1.414214\npow(-2, -3) = -0.125000\npow(-1, NAN) = nan\npow(+1, NAN) = 1.000000\npow(INFINITY, 2) = inf\npow(INFINITY, -1) = 0.000000\npow(-1, 1/3) = -nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\npow(-0, -3) = -inf\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.7.5 The pow functions\n  - 7.27 Type-generic math \\<tgmath.h\\>\n  - F.10.4.5 The pow functions (p: 524-525)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.4 The pow functions (p: 248-249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.4 The pow functions (p: 524-525)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.4 The pow functions (p: 248-249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.4 The pow functions (p: 524-525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.4 The pow functions (p: 229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.4 The pow functions (p: 461)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.5.1 The pow function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/pow](https://en.cppreference.com/w/c/numeric/math/pow)"
- name: powl
  summary: If no errors occur, base raised to the power of exponent (baseexponent) is returned
  description: "# pow, powf, powl\n\n[TABLE]\n\n1-3) Computes the value of `base` raised to the power `exponent`.\n\n4) Type-generic macro: If any argument has type `long double`, `powl` is called. Otherwise, if any argument has integer type or has type `double`, `pow` is called. Otherwise, `powf` is called. If at least one argument is complex or imaginary, then the macro invokes the corresponding complex function ([`cpowf`](http://en.cppreference.com/w/c/numeric/complex/cpow), [`cpow`](http://en.cppreference.com/w/c/numeric/complex/cpow), [`cpowl`](http://en.cppreference.com/w/c/numeric/complex/cpow)).\n\n### Parameters\n\n|          |     |                                  |\n|----------|-----|----------------------------------|\n| base     | \\-  | base as floating point value     |\n| exponent | \\-  | exponent as floating point value |\n\n### Return value\n\nIf no errors occur, `base` raised to the power of `exponent` (base^(exponent)) is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a pole error or a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf `base` is finite and negative and `exponent` is finite and non-integer, a domain error occurs and a range error may occur.\n\nIf `base` is zero and `exponent` is zero, a domain error may occur.\n\nIf `base` is zero and `exponent` is negative, a domain error or a pole error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- `pow(+0, exponent)`, where `exponent` is a negative odd integer, returns `+∞` and raises [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- `pow(-0, exponent)`, where `exponent` is a negative odd integer, returns `-∞` and raises [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- `pow(±0, exponent)`, where `exponent` is negative, finite, and is an even integer or a non-integer, returns +∞ and raises [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")\n- `pow(±0, -∞)` returns +∞ and may raise [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\")(until C23)\n- `pow(+0, exponent)`, where `exponent` is a positive odd integer, returns +0\n- `pow(-0, exponent)`, where `exponent` is a positive odd integer, returns -0\n- `pow(±0, exponent)`, where `exponent` is positive non-integer or a positive even integer, returns +0\n- `pow(-1, ±∞)` returns `1`\n- `pow(+1, exponent)` returns `1` for any `exponent`, even when `exponent` is `NaN`\n- `pow(base, ±0)` returns `1` for any `base`, even when `base` is `NaN`\n- `pow(base, exponent)` returns `NaN` and raises [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") if `base` is finite and negative and `exponent` is finite and non-integer.\n- `pow(base, -∞)` returns +∞ for any `|base|<1`\n- `pow(base, -∞)` returns +0 for any `|base|>1`\n- `pow(base, +∞)` returns +0 for any `|base|<1`\n- `pow(base, +∞)` returns +∞ for any `|base|>1`\n- `pow(-∞, exponent)` returns -0 if `exponent` is a negative odd integer\n- `pow(-∞, exponent)` returns +0 if `exponent` is a negative non-integer or negative even integer\n- `pow(-∞, exponent)` returns -∞ if `exponent` is a positive odd integer\n- `pow(-∞, exponent)` returns +∞ if `exponent` is a positive non-integer or positive even integer\n- `pow(+∞, exponent)` returns +0 for any negative `exponent`\n- `pow(+∞, exponent)` returns +∞ for any positive `exponent`\n- except where specified above, if any argument is NaN, NaN is returned\n\n### Notes\n\nAlthough `pow` cannot be used to obtain a root of a negative number, [`cbrt`](cbrt \"c/numeric/math/cbrt\") is provided for the common case where `exponent` is 1/3.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    // typical usage\n    printf(\"pow(2, 10) = %f\\n\", pow(2,10));\n    printf(\"pow(2, 0.5) = %f\\n\", pow(2,0.5));\n    printf(\"pow(-2, -3) = %f\\n\", pow(-2,-3));\n    // special values\n    printf(\"pow(-1, NAN) = %f\\n\", pow(-1,NAN));\n    printf(\"pow(+1, NAN) = %f\\n\", pow(+1,NAN));\n    printf(\"pow(INFINITY, 2) = %f\\n\", pow(INFINITY, 2));\n    printf(\"pow(INFINITY, -1) = %f\\n\", pow(INFINITY, -1));\n    // error handling \n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"pow(-1, 1/3) = %f\\n\", pow(-1, 1.0/3));\n    if(errno == EDOM)         perror(\"    errno == EDOM\");\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"pow(-0, -3) = %f\\n\", pow(-0.0, -3));\n    if(fetestexcept(FE_DIVBYZERO)) puts(\"    FE_DIVBYZERO raised\");\n}\n```\n\nPossible output:\n\n```\npow(2, 10) = 1024.000000\npow(2, 0.5) = 1.414214\npow(-2, -3) = -0.125000\npow(-1, NAN) = nan\npow(+1, NAN) = 1.000000\npow(INFINITY, 2) = inf\npow(INFINITY, -1) = 0.000000\npow(-1, 1/3) = -nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\npow(-0, -3) = -inf\n    FE_DIVBYZERO raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.7.5 The pow functions\n  - 7.27 Type-generic math \\<tgmath.h\\>\n  - F.10.4.5 The pow functions (p: 524-525)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.7.4 The pow functions (p: 248-249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.4 The pow functions (p: 524-525)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.4 The pow functions (p: 248-249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.4 The pow functions (p: 524-525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.4 The pow functions (p: 229)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.4 The pow functions (p: 461)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.5.1 The pow function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/pow](https://en.cppreference.com/w/c/numeric/math/pow)"
- name: Predefined Boolean constants
  summary: Keywords true and false represent predefined constants
  description: "# Predefined Boolean constants (since C23)\n\n### Syntax\n\n|         |       |             |\n|---------|-------|-------------|\n| `true`  | \\(1\\) | (since C23) |\n| `false` | \\(2\\) | (since C23) |\n\n### Explanation\n\nKeywords `true` and `false` represent predefined constants. They are [non-lvalues](value_category#Non-lvalue_object_expressions \"c/language/value category\") of type [`bool`](types \"c/language/types\").\n\n### Notes\n\nSee [integral conversions](conversion#Integer_conversions \"c/language/conversion\") for implicit conversions from `bool` to other types and [boolean conversions](conversion#Boolean_conversion \"c/language/conversion\") for the implicit conversions from other types to `bool`.\n\nUntil C23, `true` and `false` were implemented as macros provided in [`<stdbool.h>`](../types \"c/types\"). An implementation may also define `bool`, `true`, and `false` as predefined macros in C23 for compatibility.\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"%d\\n%d\\n\", true, false);\n}\n```\n\nOutput:\n\n```\n1\n0\n```\n\n### See also\n\n|                                                                                                                               |     |\n|-------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/bool_literal \"cpp/language/bool literal\") for Boolean literals |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/bool_constant](https://en.cppreference.com/w/c/language/bool_constant)"
- name: Predefined null pointer constant
  summary: The keyword nullptr denotes a predefined null pointer constant
  description: "# Predefined null pointer constant (since C23)\n\n### Syntax\n\n|           |     |             |\n|-----------|-----|-------------|\n| `nullptr` |     | (since C23) |\n\n### Explanation\n\nThe keyword `nullptr` denotes a predefined null pointer constant. It is a [non-lvalue](value_category#Non-lvalue_object_expressions \"c/language/value category\") of type [`nullptr_t`](../types/nullptr_t \"c/types/nullptr t\"). `nullptr` can be [converted](conversion \"c/language/conversion\") to a pointer types or `bool`, where the result is the null pointer value of that type or `false` respectively.\n\n### Keywords\n\n[`nullptr`](../keyword/nullptr \"c/keyword/nullptr\")\n\n### Example\n\nDemonstrates that a copy of `nullptr` can also be used as a null pointer constant.\n\n```\n#include <stddef.h>\n#include <stdio.h>\n \nvoid g(int*)\n{\n    puts(\"Function g called\");\n}\n \n#define DETECT_NULL_POINTER_CONSTANT(e) \\\n    _Generic(e,                         \\\n        void* : puts(\"void*\"),          \\\n        nullptr_t : puts(\"nullptr_t\"),  \\\n        default : puts(\"integer\")       \\\n    )\n \nint main()\n{\n    g(nullptr); // OK\n    g(NULL); // OK\n    g(0); // OK\n \n    auto cloned_nullptr = nullptr;\n    g(cloned_nullptr); // OK\n \n    [[maybe_unused]] auto cloned_NULL = NULL;\n//  g(cloned_NULL); // implementation-defined: maybe OK\n \n    [[maybe_unused]] auto cloned_zero = 0;\n//  g(cloned_zero); // Error\n \n    DETECT_NULL_POINTER_CONSTANT(((void*)0));\n    DETECT_NULL_POINTER_CONSTANT(0);\n    DETECT_NULL_POINTER_CONSTANT(nullptr);\n    DETECT_NULL_POINTER_CONSTANT(NULL); // implementation-defined\n}\n```\n\nPossible output:\n\n```\nFunction g called\nFunction g called\nFunction g called\nFunction g called\nvoid*\ninteger\nnullptr_t\nvoid*\n```\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/nullptr](https://en.cppreference.com/w/c/language/nullptr)"
- name: Preprocessor
  summary: The preprocessor is executed at translation phase 4, before the compilation
  description: "# Preprocessor\n\nThe preprocessor is executed at [translation phase 4](language/translation_phases \"c/language/translation phases\"), before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.\n\n### Directives\n\nThe preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:\n\n- `#` character\n- preprocessing instruction (one of `define`, `undef`, `include`, `if`, `ifdef`, `ifndef`, `else`, `elif`, `elifdef`, `elifndef`(since C23), `endif`, `line`, `embed`(since C23), `error`, `warning`(since C23), `pragma`) ^([\\[1\\]](#cite_note-1))\n- arguments (depends on the instruction)\n- line break\n\nThe null directive (`#` followed by a line break) is allowed and has no effect.\n\n### Capabilities\n\nThe preprocessor has the source file translation capabilities:\n\n- **[conditionally](preprocessor/conditional \"c/preprocessor/conditional\")** compile of parts of source file (controlled by directive `#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`, `#elifdef`, `#elifndef`(since C23) and `#endif`).\n- **[replace](preprocessor/replace \"c/preprocessor/replace\")** text macros while possibly concatenating or quoting identifiers (controlled by directives `#define` and `#undef`, and operators `#` and `##`)\n- **[include](preprocessor/include \"c/preprocessor/include\")** other files (controlled by directive `#include` and checked with `__has_include`(since C23))\n- cause an **[error](preprocessor/error \"c/preprocessor/error\")** or **[warning](preprocessor/error \"c/preprocessor/error\")**(since C23) (controlled by directive `#error` or `#warning` respectively(since C23))\n\nThe following aspects of the preprocessor can be controlled:\n\n- **[implementation defined](preprocessor/impl \"c/preprocessor/impl\")** behavior (controlled by directive `#pragma` and operator `_Pragma`(since C99))\n- **[file name and line information](preprocessor/line \"c/preprocessor/line\")** available to the preprocessor (controlled by directives `#line`)\n\n### Footnotes\n\n1.  These are the directives defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or make the program ill-formed. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive `#warning` which emits a user-defined message during compilation.(until C23)\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.10 Preprocessing directives (p: 117-129)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.10 Preprocessing directives (p: 160-178)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.10 Preprocessing directives (p: 145-162)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.8 PREPROCESSING DIRECTIVES\n\n### See also\n\n|                                                                                                                 |     |\n|-----------------------------------------------------------------------------------------------------------------|-----|\n| [C documentation](preprocessor/replace#Predefined_macros \"c/preprocessor/replace\") for Predefined Macro Symbols |     |\n| [C documentation](symbol_index/macro \"c/symbol index/macro\") for Macro Symbol Index                             |     |\n| [C++ documentation](https://en.cppreference.com/w/cpp/preprocessor \"cpp/preprocessor\") for Preprocessor         |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/preprocessor](https://en.cppreference.com/w/c/preprocessor)"
- name: printf
  summary: 'Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:'
  description: "# printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:\n\n1) Writes the results to the output stream [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to the output stream `stream`.\n\n3) Writes the results to a character string `buffer`. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz` - 1 characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `stream` or `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `sprintf_s` only), the string to be stored in `buffer` (including the trailing null) would exceed `bufsz`\n\nAs with all bounds-checked functions, `printf_s` , `fprintf_s`, `sprintf_s`, and `snprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a character string to write to                                                                                                                                                                                                                                                                                                                                                                                                |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                      |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) number of characters transmitted to the output stream or negative value if an output error or an encoding error (for string and character conversion specifiers) occurred\n\n3) number of characters written to `buffer` (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n4) number of characters (not including the terminating null character) which would have been written to `buffer` if `bufsz` was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nThe C standard and [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) specify that the behavior of `sprintf` and its variants is undefined when an argument overlaps with the destination buffer. Example:\n\n```\nsprintf(dst, \"%s and %s\", dst, t); // <- broken: undefined behavior\n```\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) that [`errno`](../error/errno \"c/error/errno\") is set on error. It also specifies additional conversion specifications, most notably support for argument reordering (`n$` immediately after `%` indicates `n`^(th) argument).\n\nCalling `snprintf` with zero `bufsz` and null pointer for `buffer` is useful to determine the necessary buffer size to contain the output:\n\n```\nconst char fmt[] = \"sqrt(2) = %f\";\nint sz = snprintf(NULL, 0, fmt, sqrt(2));\nchar buf[sz + 1]; // note +1 for terminating null byte\nsnprintf(buf, sizeof buf, fmt, sqrt(2));\n```\n\n`snprintf_s`, just like `snprintf`, but unlike `sprintf_s`, will truncate the output to fit in `bufsz-1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n \nint main(void)\n{\n    const char* s = \"Hello\";\n    printf(\"Strings:\\n\"); // same as puts(\"Strings\");\n    printf(\" padding:\\n\");\n    printf(\"\\t[%10s]\\n\", s);\n    printf(\"\\t[%-10s]\\n\", s);\n    printf(\"\\t[%*s]\\n\", 10, s);\n    printf(\" truncating:\\n\");\n    printf(\"\\t%.4s\\n\", s);\n    printf(\"\\t%.*s\\n\", 3, s);\n \n    printf(\"Characters:\\t%c %%\\n\", 'A');\n \n    printf(\"Integers:\\n\");\n    printf(\"\\tDecimal:\\t%i %d %.6i %i %.0i %+i %i\\n\",\n                         1, 2,   3, 0,   0,  4,-4);\n    printf(\"\\tHexadecimal:\\t%x %x %X %#x\\n\", 5, 10, 10, 6);\n    printf(\"\\tOctal:\\t\\t%o %#o %#o\\n\", 10, 10, 4);\n \n    printf(\"Floating point:\\n\");\n    printf(\"\\tRounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    printf(\"\\tPadding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    printf(\"\\tScientific:\\t%E %e\\n\", 1.5, 1.5);\n    printf(\"\\tHexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n    printf(\"\\tSpecial values:\\t0/0=%g 1/0=%g\\n\", 0.0/0.0, 1.0/0.0);\n \n    printf(\"Fixed-width types:\\n\");\n    printf(\"\\tLargest 32-bit value is %\" PRIu32 \" or %#\" PRIx32 \"\\n\",\n                                     UINT32_MAX,     UINT32_MAX );\n}\n```\n\nPossible output:\n\n```\nStrings:\n padding:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n truncating:\n        Hell\n        Hel\nCharacters:        A %\nIntegers:\n        Decimal:        1 2 000003 0  +4 -4\n        Hexadecimal:        5 a A 0x6\n        Octal:                12 012 04\nFloating point:\n        Rounding:        1.500000 2 1.30000000000000004440892098500626\n        Padding:        01.50 1.50  1.50\n        Scientific:        1.500000E+00 1.500000e+00\n        Hexadecimal:        0x1.8p+0 0X1.8P+0\n        Special values:        0/0=-nan 1/0=inf\nFixed-width types:\n        Largest 32-bit value is 4294967295 or 0xffffffff\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.1 The fprintf function (p: 225-230)\n  - 7.21.6.3 The printf function (p: 236)\n  - 7.21.6.5 The snprintf function (p: 237)\n  - 7.21.6.6 The sprintf function (p: 237)\n  - K.3.5.3.1 The fprintf_s function (p: 430)\n  - K.3.5.3.3 The printf_s function (p: 432)\n  - K.3.5.3.5 The snprintf_s function (p: 432-433)\n  - K.3.5.3.6 The sprintf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.1 The fprintf function (p: 309-316)\n  - 7.21.6.3 The printf function (p: 324)\n  - 7.21.6.5 The snprintf function (p: 325)\n  - 7.21.6.6 The sprintf function (p: 325-326)\n  - K.3.5.3.1 The fprintf_s function (p: 591)\n  - K.3.5.3.3 The printf_s function (p: 593-594)\n  - K.3.5.3.5 The snprintf_s function (p: 594-595)\n  - K.3.5.3.6 The sprintf_s function (p: 595-596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.1 The fprintf function (p: 274-282)\n  - 7.19.6.3 The printf function (p: 290)\n  - 7.19.6.5 The snprintf function (p: 290-291)\n  - 7.19.6.6 The sprintf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.1 The fprintf function\n  - 4.9.6.3 The printf function\n  - 4.9.6.5 The sprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fprintf](https://en.cppreference.com/w/c/io/fprintf)"
- name: printf_s
  summary: 'Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:'
  description: "# printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:\n\n1) Writes the results to the output stream [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to the output stream `stream`.\n\n3) Writes the results to a character string `buffer`. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz` - 1 characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `stream` or `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `sprintf_s` only), the string to be stored in `buffer` (including the trailing null) would exceed `bufsz`\n\nAs with all bounds-checked functions, `printf_s` , `fprintf_s`, `sprintf_s`, and `snprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a character string to write to                                                                                                                                                                                                                                                                                                                                                                                                |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                      |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) number of characters transmitted to the output stream or negative value if an output error or an encoding error (for string and character conversion specifiers) occurred\n\n3) number of characters written to `buffer` (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n4) number of characters (not including the terminating null character) which would have been written to `buffer` if `bufsz` was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nThe C standard and [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) specify that the behavior of `sprintf` and its variants is undefined when an argument overlaps with the destination buffer. Example:\n\n```\nsprintf(dst, \"%s and %s\", dst, t); // <- broken: undefined behavior\n```\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) that [`errno`](../error/errno \"c/error/errno\") is set on error. It also specifies additional conversion specifications, most notably support for argument reordering (`n$` immediately after `%` indicates `n`^(th) argument).\n\nCalling `snprintf` with zero `bufsz` and null pointer for `buffer` is useful to determine the necessary buffer size to contain the output:\n\n```\nconst char fmt[] = \"sqrt(2) = %f\";\nint sz = snprintf(NULL, 0, fmt, sqrt(2));\nchar buf[sz + 1]; // note +1 for terminating null byte\nsnprintf(buf, sizeof buf, fmt, sqrt(2));\n```\n\n`snprintf_s`, just like `snprintf`, but unlike `sprintf_s`, will truncate the output to fit in `bufsz-1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n \nint main(void)\n{\n    const char* s = \"Hello\";\n    printf(\"Strings:\\n\"); // same as puts(\"Strings\");\n    printf(\" padding:\\n\");\n    printf(\"\\t[%10s]\\n\", s);\n    printf(\"\\t[%-10s]\\n\", s);\n    printf(\"\\t[%*s]\\n\", 10, s);\n    printf(\" truncating:\\n\");\n    printf(\"\\t%.4s\\n\", s);\n    printf(\"\\t%.*s\\n\", 3, s);\n \n    printf(\"Characters:\\t%c %%\\n\", 'A');\n \n    printf(\"Integers:\\n\");\n    printf(\"\\tDecimal:\\t%i %d %.6i %i %.0i %+i %i\\n\",\n                         1, 2,   3, 0,   0,  4,-4);\n    printf(\"\\tHexadecimal:\\t%x %x %X %#x\\n\", 5, 10, 10, 6);\n    printf(\"\\tOctal:\\t\\t%o %#o %#o\\n\", 10, 10, 4);\n \n    printf(\"Floating point:\\n\");\n    printf(\"\\tRounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    printf(\"\\tPadding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    printf(\"\\tScientific:\\t%E %e\\n\", 1.5, 1.5);\n    printf(\"\\tHexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n    printf(\"\\tSpecial values:\\t0/0=%g 1/0=%g\\n\", 0.0/0.0, 1.0/0.0);\n \n    printf(\"Fixed-width types:\\n\");\n    printf(\"\\tLargest 32-bit value is %\" PRIu32 \" or %#\" PRIx32 \"\\n\",\n                                     UINT32_MAX,     UINT32_MAX );\n}\n```\n\nPossible output:\n\n```\nStrings:\n padding:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n truncating:\n        Hell\n        Hel\nCharacters:        A %\nIntegers:\n        Decimal:        1 2 000003 0  +4 -4\n        Hexadecimal:        5 a A 0x6\n        Octal:                12 012 04\nFloating point:\n        Rounding:        1.500000 2 1.30000000000000004440892098500626\n        Padding:        01.50 1.50  1.50\n        Scientific:        1.500000E+00 1.500000e+00\n        Hexadecimal:        0x1.8p+0 0X1.8P+0\n        Special values:        0/0=-nan 1/0=inf\nFixed-width types:\n        Largest 32-bit value is 4294967295 or 0xffffffff\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.1 The fprintf function (p: 225-230)\n  - 7.21.6.3 The printf function (p: 236)\n  - 7.21.6.5 The snprintf function (p: 237)\n  - 7.21.6.6 The sprintf function (p: 237)\n  - K.3.5.3.1 The fprintf_s function (p: 430)\n  - K.3.5.3.3 The printf_s function (p: 432)\n  - K.3.5.3.5 The snprintf_s function (p: 432-433)\n  - K.3.5.3.6 The sprintf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.1 The fprintf function (p: 309-316)\n  - 7.21.6.3 The printf function (p: 324)\n  - 7.21.6.5 The snprintf function (p: 325)\n  - 7.21.6.6 The sprintf function (p: 325-326)\n  - K.3.5.3.1 The fprintf_s function (p: 591)\n  - K.3.5.3.3 The printf_s function (p: 593-594)\n  - K.3.5.3.5 The snprintf_s function (p: 594-595)\n  - K.3.5.3.6 The sprintf_s function (p: 595-596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.1 The fprintf function (p: 274-282)\n  - 7.19.6.3 The printf function (p: 290)\n  - 7.19.6.5 The snprintf function (p: 290-291)\n  - 7.19.6.6 The sprintf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.1 The fprintf function\n  - 4.9.6.3 The printf function\n  - 4.9.6.5 The sprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fprintf](https://en.cppreference.com/w/c/io/fprintf)"
- name: Program support utilities
  summary: The following functions manage program termination and resources cleanup
  description: "# Program support utilities\n\n### Program termination\n\nThe following functions manage program termination and resources cleanup.\n\n[TABLE]\n\n### Unreachable control flow\n\n[TABLE]\n\n### Communicating with the environment\n\n[TABLE]\n\n### Signals\n\nSeveral functions and macro constants for signal management are provided.\n\n[TABLE]\n\n### Non-local jumps\n\n[TABLE]\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.13 Nonlocal jumps \\<setjmp.h\\> (p: 191-192)\n  - 7.14 Signal handling \\<signal.h\\> (p: 193-195)\n  - 7.22 General utilities \\<stdlib.h\\> (p: 248-262)\n  - 7.31.7 Signal handling \\<signal.h\\> (p: 332)\n  - 7.31.12 General utilities \\<stdlib.h\\> (p: 333)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.13 Nonlocal jumps \\<setjmp.h\\> (p: 262-264)\n  - 7.14 Signal handling \\<signal.h\\> (p: 265-267)\n  - 7.22 General utilities \\<stdlib.h\\> (p: 340-360)\n  - 7.31.7 Signal handling \\<signal.h\\> (p: 455)\n  - 7.31.12 General utilities \\<stdlib.h\\> (p: 456)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.13 Nonlocal jumps \\<setjmp.h\\> (p: 243-245)\n  - 7.14 Signal handling \\<signal.h\\> (p: 246-248)\n  - 7.20 General utilities \\<stdlib.h\\> (p: 306-324)\n  - 7.26.6 Signal handling \\<signal.h\\> (p: 401)\n  - 7.26.10 General utilities \\<stdlib.h\\> (p: 402)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.6 NON-LOCAL JUMPS \\<setjmp.h\\>\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n  - 4.10 GENERAL UTILITIES \\<stdlib.h\\>\n  - 4.13.5 Signal handling \\<signal.h\\>\n  - 7.13.7 General utilities \\<stdlib.h\\>\n\n### See also\n\n|                                                                                                                            |     |\n|----------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/utility/program \"cpp/utility/program\") for Program support utilities |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program](https://en.cppreference.com/w/c/program)"
- name: Pseudo-random number generation
  summary: ''
  description: "# Pseudo-random number generation\n\n[TABLE]\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.2 Pseudo-random sequence generation functions (p: 252-253)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.2 Pseudo-random sequence generation functions (p: 346-347)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.2 Pseudo-random sequence generation functions (p: 312-313)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.2 Pseudo-random sequence generation functions\n\n### See also\n\n|                                                                                                                                |     |\n|--------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/numeric/random \"cpp/numeric/random\") for Pseudo-random number generation |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/random](https://en.cppreference.com/w/c/numeric/random)"
- name: ptrdiff_t
  summary: ptrdiff_t is the signed integer type of the result of subtracting two pointers
  description: "# ptrdiff_t\n\n[TABLE]\n\n`ptrdiff_t` is the signed integer type of the result of [subtracting two pointers](../language/operator_arithmetic#Pointer_arithmetic \"c/language/operator arithmetic\").\n\n[TABLE]\n\n### Notes\n\n`ptrdiff_t` is used for pointer arithmetic and array indexing, if negative values are possible. Programs that use other types, such as `int`, may fail on, e.g. 64-bit systems when the index exceeds [`INT_MAX`](limits \"c/types/limits\") or if it relies on 32-bit modular arithmetic.\n\nOnly pointers to elements of the same array (including the pointer one past the end of the array) may be subtracted from each other.\n\nIf an array is so large (greater than [`PTRDIFF_MAX`](limits \"c/types/limits\") elements, but equal to or less than [`SIZE_MAX`](limits \"c/types/limits\") bytes), that the difference between two pointers may not be representable as `ptrdiff_t`, the result of subtracting two such pointers is undefined.\n\nFor char arrays shorter than [`PTRDIFF_MAX`](limits \"c/types/limits\"), `ptrdiff_t` acts as the signed counterpart of [`size_t`](size_t \"c/types/size t\"): it can store the size of the array of any type and is, on most platforms, synonymous with `intptr_t`).\n\n### Example\n\n```\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n \nint main(void)\n{\n    const size_t N = 100;\n    int numbers[N];\n \n    printf(\"PTRDIFF_MAX = %ld\\n\", PTRDIFF_MAX);\n    int *p1 = &numbers[18], *p2 = &numbers[23];\n    ptrdiff_t diff = p2 - p1;\n    printf(\"p2-p1 = %td\\n\", diff);\n}\n```\n\nPossible output:\n\n```\nPTRDIFF_MAX = 9223372036854775807\np2-p1 = 5\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.19 Common definitions \\<stddef.h\\> (p: 211)\n  - 7.20.3 Limits of other integer types (p: 215)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.19 Common definitions \\<stddef.h\\> (p: 288)\n  - 7.20.3 Limits of other integer types (p: 293)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.17 Common definitions \\<stddef.h\\> (p: 253)\n  - 7.18.3 Limits of other integer types (p: 258)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.1.6 Common definitions \\<stddef.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types/ptrdiff_t](https://en.cppreference.com/w/c/types/ptrdiff_t)"
- name: Punctuation
  summary: These are the punctuation symbols in C
  description: "# Punctuation\n\nThese are the punctuation symbols in C. The meaning of each symbol is detailed in the linked pages.\n\n### `{` `}`\n\n- In a [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") definition, delimit the struct-declaration-list.\n- In an [enum](enum \"c/language/enum\") definition, delimit the enumerator list.\n- Delimit a [compound statement](statements#Compound_statements \"c/language/statements\"). The compound statement may be part of a [function definition](function_definition \"c/language/function definition\").\n- In [initialization](initialization \"c/language/initialization\"), delimit the initializers.\n\n### `[` `]`\n\n- [Subscript operator](operator_member_access#Subscript \"c/language/operator member access\").\n- Part of [array declarator](declarations#Declarators \"c/language/declarations\") in a [declaration](declarations \"c/language/declarations\") or a [type-id](type#Type_names \"c/language/type\").\n- In [initialization](initialization \"c/language/initialization\"), introduce a designator for an array element. (since C99)\n- In an [attribute specifier](attributes \"c/language/attributes\"), delimit the attributes. (since C23)\n\n### `#`\n\n- Introduce a [preprocessing directive](../preprocessor \"c/preprocessor\").\n- The [preprocessing operator for stringification](../preprocessor/replace#.23_and_.23.23_operators \"c/preprocessor/replace\").\n\n### `##`\n\n- The [preprocessing operator for token pasting](../preprocessor/replace#.23_and_.23.23_operators \"c/preprocessor/replace\").\n\n### `(` `)`\n\n- In an expression, [indicate grouping](expressions#Primary_expressions \"c/language/expressions\").\n- [Function call operator](operator_other#Function_call \"c/language/operator other\").\n- In a [`sizeof`](sizeof \"c/language/sizeof\"), [`_Alignof`](_alignof \"c/language/ Alignof\")(since C11) , [`typeof`](typeof \"c/language/typeof\") or [`typeof_unqual`](https://en.cppreference.com/mwiki/index.php?title=c/language/typeof_unqual&action=edit&redlink=1 \"c/language/typeof unqual (page does not exist)\")(since C23) expression, delimit the operand.\n- In an [explicit cast](cast \"c/language/cast\"), delimit the type-id.\n- In a [compound literal](compound_literal \"c/language/compound literal\"), delimit the type-id. (since C99)\n- In a [declaration](declarations \"c/language/declarations\") or a [type-id](type#Type_names \"c/language/type\"), indicate grouping.\n- In a [function declarator](function_declaration \"c/language/function declaration\") (in a [declaration](declarations \"c/language/declarations\") or a [type-id](type#Type_names \"c/language/type\")), delimit the parameter list.\n- In an [`if`](if \"c/language/if\"), [`switch`](switch \"c/language/switch\"), [`while`](while \"c/language/while\"), [`do-while`](do \"c/language/do\"), or [`for`](for \"c/language/for\") statement, delimit the controlling clause.\n- In a [function-like macro definition](../preprocessor/replace#Function-like_macros \"c/preprocessor/replace\"), delimit the macro parameters.\n- In a [function-like macro invocation](../preprocessor/replace#Function-like_macros \"c/preprocessor/replace\"), delimit the macro arguments or prevent commas from being interpreted as argument separators.\n- Part of a `defined`, `__has_include`, `__has_embed` or `__has_c_attribute`(since C23) preprocessing operator.\n- Part of a [generic selection expression](generic \"c/language/generic\"). (since C11)\n- In an [`_Atomic`](atomic \"c/language/atomic\") type specifier, delimit the type-id. (since C11)\n- In a [static assertion declaration](_static_assert \"c/language/ Static assert\"), delimit the operands. (since C11)\n- In an [`_Alignas`](_alignas \"c/language/ Alignas\") specifier, delimit the operand. (since C11)\n- In an [attribute](attributes \"c/language/attributes\"), delimit the attribute arguments. (since C23)\n- In a bit-precise integer type name (\\_BitInt(N)), delimit the size. (since C23)\n- Part of [`__VA_OPT__`](../preprocessor/replace \"c/preprocessor/replace\") replacement in a variadic macro definition. (since C23)\n- In a preprocessor parameter used in [`#embed` directives](../preprocessor/embed \"c/preprocessor/embed\") and `__has_embed` preprocessing expressions, delimit the preprocessor parameter clause. (since C23)\n\n### `;`\n\n- Indicate the end of\n  - a [statement](statements \"c/language/statements\") (including the init-statement of a for statement)\n  - a [declaration](declarations \"c/language/declarations\") or struct-declaration-list\n- Separate the second and third clauses of a [for statement](for \"c/language/for\").\n\n### `:`\n\n- Part of [conditional operator](operator_other#Conditional_operator \"c/language/operator other\").\n- Part of [label declaration](statements#Labels \"c/language/statements\").\n- In a [bit-field member declaration](bit_field \"c/language/bit field\"), introduce the width.\n- Introduce an [enum base](enum \"c/language/enum\"), which specifies the underlying type of the enum. (since C23)\n- In a [generic association](generic \"c/language/generic\"), delimit the type-id or `default` and the selected expression. (since C11)\n\n### `...`\n\n- In the [parameter list](function_declaration#Parameter_list \"c/language/function declaration\") of a function declarator, signify a [variadic function](variadic \"c/language/variadic\").\n- In a [macro definition](../preprocessor/replace \"c/preprocessor/replace\"), signify a variadic macro. (since C99)\n\n### `?`\n\n- Part of [conditional operator](operator_other#Conditional_operator \"c/language/operator other\").\n\n### `::`\n\n- In an [attribute](attributes \"c/language/attributes\"), indicate attribute scope. (since C23)\n- In a preprocessor prefixed parameter (used by [`#embed`](../preprocessor/embed \"c/preprocessor/embed\") and `__has_embed`), indicate scope. (since C23)\n\n### `.`\n\n- [Member access operator](operator_member_access#Member_access \"c/language/operator member access\").\n- In [initialization](initialization \"c/language/initialization\"), introduce a designator for a struct/union member. (since C99)\n\n### `->`\n\n- [Member access operator](operator_member_access#Member_access_through_pointer \"c/language/operator member access\").\n\n### `~`\n\n- [Unary complement operator (a.k.a. bitwise not operator)](operator_arithmetic#Bitwise_logic \"c/language/operator arithmetic\").\n\n### `!`\n\n- [Logical not operator](operator_logical#Logical_NOT \"c/language/operator logical\").\n\n### `+`\n\n- [Unary plus operator](operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\").\n- [Binary plus operator](operator_arithmetic#Additive_operators \"c/language/operator arithmetic\").\n\n### `-`\n\n- [Unary minus operator](operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\").\n- [Binary minus operator](operator_arithmetic#Additive_operators \"c/language/operator arithmetic\").\n\n### `*`\n\n- [Indirection operator](operator_member_access#Dereference \"c/language/operator member access\").\n- [Multiplication operator](operator_arithmetic#Multiplicative_operators \"c/language/operator arithmetic\").\n- Pointer operator operator in a [declarator](declarations#Declarators \"c/language/declarations\") or in a [type-id](type#Type_names \"c/language/type\").\n- Placeholder for the length of a variable-length array declarator in a [function declaration](function_declaration \"c/language/function declaration\"). (since C99)\n\n### `/`\n\n- [Division operator](operator_arithmetic#Multiplicative_operators \"c/language/operator arithmetic\").\n\n### `%`\n\n- [Modulo operator](operator_arithmetic#Multiplicative_operators \"c/language/operator arithmetic\").\n\n### `^`\n\n- [Bitwise xor operator](operator_arithmetic#Bitwise_logic \"c/language/operator arithmetic\").\n\n### `&`\n\n- [Address-of operator](operator_member_access#Address_of \"c/language/operator member access\").\n- [Bitwise and operator](operator_arithmetic#Bitwise_logic \"c/language/operator arithmetic\").\n\n### `|`\n\n- [Bitwise or operator](operator_arithmetic#Bitwise_logic \"c/language/operator arithmetic\").\n\n### `=`\n\n- [Simple assignment operator](operator_assignment#Simple_assignment \"c/language/operator assignment\").\n- In [initialization](initialization \"c/language/initialization\"), delimit the object and the initializer list.\n- In an [enum definition](enum \"c/language/enum\"), introduce the value of enumeration constant.\n\n### `+=`\n\n- [Compound assignment operator](operator_assignment#Compound_assignment \"c/language/operator assignment\").\n\n### `-=`\n\n- [Compound assignment operator](operator_assignment#Compound_assignment \"c/language/operator assignment\").\n\n### `*=`\n\n- [Compound assignment operator](operator_assignment#Compound_assignment \"c/language/operator assignment\").\n\n### `/=`\n\n- [Compound assignment operator](operator_assignment#Compound_assignment \"c/language/operator assignment\").\n\n### `%=`\n\n- [Compound assignment operator](operator_assignment#Compound_assignment \"c/language/operator assignment\").\n\n### `^=`\n\n- [Compound assignment operator](operator_assignment#Compound_assignment \"c/language/operator assignment\").\n\n### `&=`\n\n- [Compound assignment operator](operator_assignment#Compound_assignment \"c/language/operator assignment\").\n\n### `|=`\n\n- [Compound assignment operator](operator_assignment#Compound_assignment \"c/language/operator assignment\").\n\n### `==`\n\n- [Equality operator](operator_comparison#Equality_operators \"c/language/operator comparison\").\n\n### `!=`\n\n- [Inequality operator](operator_comparison#Equality_operators \"c/language/operator comparison\").\n\n### `<`\n\n- [Less-than operator](operator_comparison#Relational_operators \"c/language/operator comparison\").\n- Introduce a header name in\n  - a [`#include` directive](../preprocessor/include \"c/preprocessor/include\")\n  - a [`__has_include` preprocessing expression](../preprocessor/include \"c/preprocessor/include\") (since C23)\n  - a [`#embed` directive](../preprocessor/embed \"c/preprocessor/embed\") (since C23)\n  - a [`__has_embed` preprocessing expression](../preprocessor/embed \"c/preprocessor/embed\") (since C23)\n  - implementation-defined locations within a [`#pragma` directive](../preprocessor/impl \"c/preprocessor/impl\")\n\n### `>`\n\n- [Greater-than operator](operator_comparison#Relational_operators \"c/language/operator comparison\").\n- Indicate the end of a header name in\n  - a [`#include` directive](../preprocessor/include \"c/preprocessor/include\")\n  - a [`__has_include` preprocessing expression](../preprocessor/include \"c/preprocessor/include\") (since C23)\n  - a [`#embed` directive](../preprocessor/embed \"c/preprocessor/embed\") (since C23)\n  - a [`__has_embed` preprocessing expression](../preprocessor/embed \"c/preprocessor/embed\") (since C23)\n  - implementation-defined locations within a [`#pragma` directive](../preprocessor/impl \"c/preprocessor/impl\")\n\n### `<=`\n\n- [Less-than-or-equal-to operator](operator_comparison#Relational_operators \"c/language/operator comparison\").\n\n### `>=`\n\n- [Greater-than-or-equal-to operator](operator_comparison#Relational_operators \"c/language/operator comparison\").\n\n### `&&`\n\n- [Logical and operator](operator_logical#Logical_AND \"c/language/operator logical\").\n\n### `||`\n\n- [Logical or operator](operator_logical#Logical_OR \"c/language/operator logical\").\n\n### `<<`\n\n- [Bitwise shift operator](operator_arithmetic#Shift_operators \"c/language/operator arithmetic\").\n\n### `>>`\n\n- [Bitwise shift operator](operator_arithmetic#Shift_operators \"c/language/operator arithmetic\").\n\n### `<<=`\n\n- [Compound assignment operator](operator_assignment#Compound_assignment \"c/language/operator assignment\").\n\n### `>>=`\n\n- [Compound assignment operator](operator_assignment#Compound_assignment \"c/language/operator assignment\").\n\n### `++`\n\n- [Increment operator](operator_incdec \"c/language/operator incdec\").\n\n### `--`\n\n- [Decrement operator](operator_incdec \"c/language/operator incdec\").\n\n### `,`\n\n- [Comma operator](operator_other#Comma_operator \"c/language/operator other\").\n- List separator in\n  - the declarator list in a [declaration](declarations \"c/language/declarations\")\n  - initializer list in [initialization](initialization \"c/language/initialization\"), including [compound literals](compound_literal \"c/language/compound literal\")(since C99)\n  - the argument list in a [function call expression](operator_other#Function_call \"c/language/operator other\")\n  - the enumerator list in an [enum](enum \"c/language/enum\") declaration\n  - a function parameter list\n  - the macro parameter list in a [function-like macro definition](../preprocessor/replace#Function-like_macros \"c/preprocessor/replace\")\n  - the macro argument list in a [function-like macro invocation](../preprocessor/replace#Function-like_macros \"c/preprocessor/replace\"), unless found between an inner set of parentheses\n  - the generic association list in a [generic selection expression](generic \"c/language/generic\") (since C11)\n  - an [attribute](attributes \"c/language/attributes\") list (since C23)\n- In a [static assertion declaration](_static_assert \"c/language/ Static assert\"), separate the arguments. (since C11)\n- In a [generic selection expression](generic \"c/language/generic\"), separate the controlling expression and the generic association list. (since C11)\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.4.6 Punctuators (p: 68-69)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.4.6 Punctuators (p: 52-53)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.4.6 Punctuators (p: 72-73)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.4.6 Punctuators (p: 63-64)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.6 Punctuators\n\n### See also\n\n|                                                                                                                        |                                             |\n|------------------------------------------------------------------------------------------------------------------------|---------------------------------------------|\n| [Alternative representations](operator_alternative \"c/language/operator alternative\") (C95)                            | alternative spellings for certain operators |\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/punctuators \"cpp/language/punctuators\") for Punctuation |                                             |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/punctuators](https://en.cppreference.com/w/c/language/punctuators)"
- name: putc
  summary: Writes a character ch to the given output stream stream
  description: "# fputc, putc\n\n[TABLE]\n\nWrites a character `ch` to the given output stream `stream`. `putc()` may be implemented as a macro and evaluate `stream` more than once, so the corresponding argument should never be an expression with side effects.\n\nInternally, the character is converted to `unsigned char` just before being written.\n\n### Parameters\n\n|        |     |                         |\n|--------|-----|-------------------------|\n| ch     | \\-  | character to be written |\n| stream | \\-  | output stream           |\n\n### Return value\n\nOn success, returns the written character.\n\nOn failure, returns [`EOF`](../io \"c/io\") and sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`.\n\n### Example\n\nShows `putc` with error checking\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int ret_code = 0;\n    for (char c = 'a'; (ret_code != EOF) && (c != 'z'); c++)\n        ret_code = putc(c, stdout);\n \n    // Test whether EOF was reached.\n    if (ret_code == EOF && ferror(stdout))\n    {\n        perror(\"putc()\");\n        fprintf(stderr, \"putc() failed in file %s at line # %d\\n\",\n                __FILE__, __LINE__ - 7);\n        exit(EXIT_FAILURE);\n    }\n    putc('\\n', stdout);\n \n    return EXIT_SUCCESS;\n}\n```\n\nOutput:\n\n```\nabcdefghijklmnopqrstuvwxy\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.7.3 The fputc function (p: TBD)\n  - 7.21.7.7 The putc function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.7.3 The fputc function (p: TBD)\n  - 7.21.7.7 The putc function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.7.3 The fputc function (p: 331)\n  - 7.21.7.7 The putc function (p: 333)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.3 The fputc function (p: 297)\n  - 7.19.7.8 The putc function (p: 299)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.3 The fputc function\n  - 4.9.7.8 The putc function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fputc](https://en.cppreference.com/w/c/io/fputc)"
- name: putchar
  summary: Writes a character ch to stdout
  description: "# putchar\n\n[TABLE]\n\nWrites a character `ch` to [`stdout`](std_streams \"c/io/std streams\"). Internally, the character is converted to `unsigned char` just before being written.\n\nEquivalent to [`putc`](http://en.cppreference.com/w/c/io/fputc)`(``ch, `[`stdout`](http://en.cppreference.com/w/c/io/std_streams)`)`.\n\n### Parameters\n\n|     |     |                         |\n|-----|-----|-------------------------|\n| ch  | \\-  | character to be written |\n\n### Return value\n\nOn success, returns the written character.\n\nOn failure, returns [`EOF`](../io \"c/io\") and sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on [`stdout`](std_streams \"c/io/std streams\").\n\n### Example\n\nShows `putchar` with error checking\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int ret_code = 0;\n    for (char c = 'a'; (ret_code != EOF) && (c != 'z'); c++)\n        ret_code = putchar(c);\n \n    // Test whether EOF was reached.\n    if (ret_code == EOF && ferror(stdout))\n    {\n        fprintf(stderr, \"putchar() failed in file %s at line # %d\\n\",\n                __FILE__, __LINE__ - 6);\n        perror(\"putchar()\");\n        exit(EXIT_FAILURE);\n    }\n    putchar('\\n');\n \n    // putchar return value is not equal to the argument\n    int r = 0x1070;\n    printf(\"\\n0x%x\\n\", r);\n    r = putchar(r);\n    printf(\"\\n0x%x\\n\", r);\n}\n```\n\nOutput:\n\n```\nabcdefghijklmnopqrstuvwxy\n \n0x1070\np\n0x70\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.7.8 The putchar function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.7.8 The putchar function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.7.8 The putchar function (p: 333)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.9 The putchar function (p: 299)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.9 The putchar function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/putchar](https://en.cppreference.com/w/c/io/putchar)"
- name: puts
  summary: Writes every character from the null-terminated string str and one additional newline character '\n' to the output stream stdout, as if by repeatedly executing fputc
  description: "# puts\n\n[TABLE]\n\nWrites every character from the null-terminated string `str` and one additional newline character '\\n' to the output stream [`stdout`](std_streams \"c/io/std streams\"), as if by repeatedly executing [`fputc`](fputc \"c/io/fputc\").\n\nThe terminating null character from `str` is not written.\n\n### Parameters\n\n|     |     |                                |\n|-----|-----|--------------------------------|\n| str | \\-  | character string to be written |\n\n### Return value\n\nOn success, returns a non-negative value.\n\nOn failure, returns [`EOF`](../io \"c/io\") and sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`.\n\n### Notes\n\nThe `puts` function appends the newline character to the output, while [`fputs`](fputs \"c/io/fputs\") function does not.\n\nDifferent implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or [`INT_MAX`](../types/limits \"c/types/limits\") if the string was longer than that), some simply return a non-negative constant.\n\nA typical cause of failure for `puts` is running out of space on the file system, when [`stdout`](std_streams \"c/io/std streams\") is redirected to a file.\n\n### Example\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    int rc = puts(\"Hello World\");\n \n    if (rc == EOF)\n        perror(\"puts()\"); // POSIX requires that errno is set\n}\n```\n\nOutput:\n\n```\nHello World\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.7.9 The puts function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.7.9 The puts function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.7.9 The puts function (p: 333)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.10 The puts function (p: 299)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 7.9.7.10 The puts function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/puts](https://en.cppreference.com/w/c/io/puts)"
- name: putwc
  summary: Writes a wide character ch to the given output stream stream
  description: "# fputwc, putwc\n\n[TABLE]\n\nWrites a wide character `ch` to the given output stream `stream`.\n\n2) May be implemented as a macro and may evaluate `stream` more than once.\n\n### Parameters\n\n|        |     |                              |\n|--------|-----|------------------------------|\n| ch     | \\-  | wide character to be written |\n| stream | \\-  | the output stream            |\n\n### Return value\n\nReturns a copy of `ch` on success.\n\nOn failure, returns `WEOF` and sets the *error* indicator (see [`ferror()`](ferror \"c/io/ferror\")) on `stream`.\n\nIf an encoding error occurred, additionally sets [`errno`](../error/errno \"c/error/errno\") to [`EILSEQ`](../error/errno_macros \"c/error/errno macros\").\n\n### Example\n\n```\n#include <errno.h>\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    errno = 0;\n    if (fputwc(L'🍌', stdout) == WEOF)\n    {\n        if (errno == EILSEQ)\n            puts(\"Encoding error in fputwc.\");\n        else\n            puts(\"I/O error in fputwc.\");\n        return EXIT_FAILURE;\n    }\n}\n```\n\nPossible output:\n\n```\n🍌\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.31.3.3 The fputwc function (p: 430)\n  - 7.31.3.8 The putwc function (p: 431-432)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.3.3 The fputwc function (p: 308)\n  - 7.29.3.8 The putwc function (p: 310)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.3.3 The fputwc function (p: 422-423)\n  - 7.29.3.8 The putwc function (p: 424)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.3.3 The fputwc function (p: 368)\n  - 7.24.3.8 The putwc function (p: 370)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fputwc](https://en.cppreference.com/w/c/io/fputwc)"
- name: putwchar
  summary: Writes a wide character ch to stdout
  description: "# putwchar\n\n[TABLE]\n\nWrites a wide character `ch` to `stdout`.\n\n### Parameters\n\n|     |     |                              |\n|-----|-----|------------------------------|\n| ch  | \\-  | wide character to be written |\n\n### Return value\n\n`ch` on success, `WEOF` on failure.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n \nint main()\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    const wchar_t data[] =\n    {\n        L'\\u2200', // Unicode name: \"FOR ALL\"\n        L'∀',\n        L'\\n',\n    };\n \n    for (size_t t = 0; t != (sizeof data / sizeof(wchar_t)); ++t)\n    {\n        if (putwchar(data[t]) == WEOF)\n        {\n            puts(\"I/O error in putwchar\");\n            return EXIT_FAILURE;\n        }\n    }\n \n    return EXIT_SUCCESS;\n}\n```\n\nPossible output:\n\n```\n∀∀\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.31.3.9 The putwchar function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.3.9 The putwchar function (p: 310)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.3.9 The putwchar function (p: 425)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.3.9 The putwchar function (p: 370)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/putwchar](https://en.cppreference.com/w/c/io/putwchar)"
- name: qsort
  summary: If comp indicates two elements as equivalent, their order in the resulting sorted array is unspecified
  description: "# qsort, qsort_s\n\n[TABLE]\n\n1) Sorts the given array pointed to by `ptr` in ascending order. The array contains `count` elements of `size` bytes. Function pointed to by `comp` is used for object comparison.\n\n2) Same as (1), except that the additional context parameter `context` is passed to `comp` and that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `count` or `size` is greater than `RSIZE_MAX`\n- `ptr` or `comp` is a null pointer (unless `count` is zero)\n\nAs with all bounds-checked functions, `qsort_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../program \"c/program\").\n\nIf `comp` indicates two elements as equivalent, their order in the resulting sorted array is unspecified.\n\n### Parameters\n\n[TABLE]\n\n### Return value\n\n1) (none)\n\n2) zero on success, non-zero if a runtime constraints violation was detected\n\n### Notes\n\nDespite the name, neither C nor POSIX standards require this function to be implemented using [quicksort](https://en.wikipedia.org/wiki/Quicksort \"enwiki:Quicksort\") or make any complexity or stability guarantees.\n\nUnlike other bounds-checked functions, `qsort_s` does not treat arrays of zero size as a runtime constraint violation and instead returns successfully without altering the array (the other function that accepts arrays of zero size is `bsearch_s`).\n\nUntil `qsort_s`, users of `qsort` often used global variables to pass additional context to the comparison function.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n \nint compare_ints(const void* a, const void* b)\n{\n    int arg1 = *(const int*)a;\n    int arg2 = *(const int*)b;\n \n    if (arg1 < arg2) return -1;\n    if (arg1 > arg2) return 1;\n    return 0;\n \n    // return (arg1 > arg2) - (arg1 < arg2); // possible shortcut\n    // return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)\n}\n \nint main(void)\n{\n    int ints[] = { -2, 99, 0, -743, 2, INT_MIN, 4 };\n    int size = sizeof ints / sizeof *ints;\n \n    qsort(ints, size, sizeof(int), compare_ints);\n \n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", ints[i]);\n    }\n \n    printf(\"\\n\");\n}\n```\n\nOutput:\n\n```\n-2147483648 -743 -2 0 2 4 99\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.5.2 The qsort function (p: 258-259)\n  - K.3.6.3.2 The qsort_s function (p: 442-443)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.5.2 The qsort function (p: 355-356)\n  - K.3.6.3.2 The qsort_s function (p: 609)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.5.2 The qsort function (p: 319)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.5.2 The qsort function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/algorithm/qsort](https://en.cppreference.com/w/c/algorithm/qsort)"
- name: qsort_s
  summary: If comp indicates two elements as equivalent, their order in the resulting sorted array is unspecified
  description: "# qsort, qsort_s\n\n[TABLE]\n\n1) Sorts the given array pointed to by `ptr` in ascending order. The array contains `count` elements of `size` bytes. Function pointed to by `comp` is used for object comparison.\n\n2) Same as (1), except that the additional context parameter `context` is passed to `comp` and that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `count` or `size` is greater than `RSIZE_MAX`\n- `ptr` or `comp` is a null pointer (unless `count` is zero)\n\nAs with all bounds-checked functions, `qsort_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../program \"c/program\").\n\nIf `comp` indicates two elements as equivalent, their order in the resulting sorted array is unspecified.\n\n### Parameters\n\n[TABLE]\n\n### Return value\n\n1) (none)\n\n2) zero on success, non-zero if a runtime constraints violation was detected\n\n### Notes\n\nDespite the name, neither C nor POSIX standards require this function to be implemented using [quicksort](https://en.wikipedia.org/wiki/Quicksort \"enwiki:Quicksort\") or make any complexity or stability guarantees.\n\nUnlike other bounds-checked functions, `qsort_s` does not treat arrays of zero size as a runtime constraint violation and instead returns successfully without altering the array (the other function that accepts arrays of zero size is `bsearch_s`).\n\nUntil `qsort_s`, users of `qsort` often used global variables to pass additional context to the comparison function.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n \nint compare_ints(const void* a, const void* b)\n{\n    int arg1 = *(const int*)a;\n    int arg2 = *(const int*)b;\n \n    if (arg1 < arg2) return -1;\n    if (arg1 > arg2) return 1;\n    return 0;\n \n    // return (arg1 > arg2) - (arg1 < arg2); // possible shortcut\n    // return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)\n}\n \nint main(void)\n{\n    int ints[] = { -2, 99, 0, -743, 2, INT_MIN, 4 };\n    int size = sizeof ints / sizeof *ints;\n \n    qsort(ints, size, sizeof(int), compare_ints);\n \n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", ints[i]);\n    }\n \n    printf(\"\\n\");\n}\n```\n\nOutput:\n\n```\n-2147483648 -743 -2 0 2 4 99\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.5.2 The qsort function (p: 258-259)\n  - K.3.6.3.2 The qsort_s function (p: 442-443)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.5.2 The qsort function (p: 355-356)\n  - K.3.6.3.2 The qsort_s function (p: 609)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.5.2 The qsort function (p: 319)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.5.2 The qsort function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/algorithm/qsort](https://en.cppreference.com/w/c/algorithm/qsort)"
- name: quick_exit
  summary: Causes normal program termination to occur without completely cleaning the resources
  description: "# quick_exit\n\n[TABLE]\n\nCauses normal program termination to occur without completely cleaning the resources.\n\nFunctions passed to [`at_quick_exit`](at_quick_exit \"c/program/at quick exit\") are called in reverse order of their registration. After calling the registered functions, calls [`_Exit`](http://en.cppreference.com/w/c/program/_Exit)`(``exit_code``)`.\n\nFunctions passed to [`atexit`](atexit \"c/program/atexit\") or signal handlers passed to [`signal`](signal \"c/program/signal\") are not called.\n\n### Parameters\n\n|           |     |                            |\n|-----------|-----|----------------------------|\n| exit_code | \\-  | exit status of the program |\n\n### Return value\n\n(none)\n\n### Example\n\n```\n#include <stdlib.h>\n#include <stdio.h>\n \nvoid f1(void)\n{\n    puts(\"pushed first\");\n    fflush(stdout);\n}\n \nvoid f2(void)\n{\n    puts(\"pushed second\");\n}\n \nvoid f3(void)\n{\n    puts(\"won't be called\");\n}\n \nint main(void)\n{\n    at_quick_exit(f1);\n    at_quick_exit(f2);\n    atexit(f3);\n    quick_exit(0);\n}\n```\n\nOutput:\n\n```\npushed second\npushed first\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.4.7 The quick_exit function (p: 257)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.4.7 The quick_exit function (p: 353)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/quick_exit](https://en.cppreference.com/w/c/program/quick_exit)"
- name: raise
  summary: Sends signal sig to the program
  description: "# raise\n\n[TABLE]\n\nSends signal sig to the program. The signal handler, specified using [`signal()`](signal \"c/program/signal\"), is invoked.\n\nIf the user-defined signal handling strategy is not set using [`signal()`](signal \"c/program/signal\") yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked.\n\n### Parameters\n\n[TABLE]\n\n### Return value\n\n`​0​` upon success, non-zero value on failure.\n\n### Example\n\n```\n#include <signal.h>\n#include <stdio.h>\n \nvoid signal_handler(int signal)\n{\n    printf(\"Received signal %d\\n\", signal);\n}\n \nint main(void)\n{\n    // Install a signal handler.\n    signal(SIGTERM, signal_handler);\n \n    printf(\"Sending signal %d\\n\", SIGTERM);\n    raise(SIGTERM);\n    printf(\"Exit main()\\n\");\n}\n```\n\nOutput:\n\n```\nSending signal 15\nReceived signal 15\nExit main()\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14.2.1 The raise function (p: 194-195)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14.2.1 The raise function (p: 267)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14.2.1 The raise function (p: 248)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7.2.1 The raise function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/raise](https://en.cppreference.com/w/c/program/raise)"
- name: rand
  summary: Returns a pseudo-random integer value between ​0​ and RAND_MAX (0 and RAND_MAX included)
  description: "# rand\n\n[TABLE]\n\nReturns a pseudo-random integer value between `​0​` and [`RAND_MAX`](rand_max \"c/numeric/random/RAND MAX\") (`0` and `RAND_MAX` included).\n\n[`srand()`](srand \"c/numeric/random/srand\") seeds the pseudo-random number generator used by `rand()`. If `rand()` is used before any calls to `srand()`, `rand()` behaves as if it was seeded with [`srand`](http://en.cppreference.com/w/c/numeric/random/srand)`(``1``)`. Each time `rand()` is seeded with `srand()`, it must produce the same sequence of values.\n\n`rand()` is not guaranteed to be thread-safe.\n\n### Parameters\n\n(none)\n\n### Return value\n\nPseudo-random integer value between `​0​` and [`RAND_MAX`](rand_max \"c/numeric/random/RAND MAX\"), inclusive.\n\n### Notes\n\nThere are no guarantees as to the quality of the random sequence produced. In the past, some implementations of `rand()` have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between `1` and `0` between calls). `rand()` is not recommended for serious random-number generation needs, like cryptography.\n\nPOSIX requires that the period of the pseudo-random number generator used by `rand` be at least 2³².\n\nPOSIX offered a thread-safe version of rand called `rand_r`, which is obsolete in favor of the [`drand48`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/drand48.html) family of functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n \nint main(void)\n{\n    srand(time(NULL)); // use current time as seed for random generator\n    int random_variable = rand();\n    printf(\"Random value on [0,%d]: %d\\n\", RAND_MAX, random_variable);\n \n    // roll a 6-sided die 20 times\n    for (int n=0; n != 20; ++n) {\n        int x = 7;\n        while(x > 6) \n            x = 1 + rand()/((RAND_MAX + 1u)/6); // Note: 1+rand()%6 is biased\n        printf(\"%d \",  x); \n    }\n}\n```\n\nPossible output:\n\n```\nRandom value on [0,2147483647]: 448749574\n3 1 3 1 4 2 2 1 3 6 4 4 3 1 6 2 3 2 6 1\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.2.1 The rand function (p: 252)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.2.1 The rand function (p: 346)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.2.1 The rand function (p: 312)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.2.1 The rand function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/random/rand](https://en.cppreference.com/w/c/numeric/random/rand)"
- name: RAND_MAX
  summary: Expands to an integer constant expression equal to the maximum value returned by the function rand()
  description: "# RAND_MAX\n\n[TABLE]\n\nExpands to an integer constant expression equal to the maximum value returned by the function [`rand()`](rand \"c/numeric/random/rand\"). This value is implementation dependent. It's guaranteed that this value is at least `32767`.\n\n### Example\n\n```\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n \nint main(void)\n{\n    srand(time(NULL)); // use current time as seed for random generator\n    printf(\"RAND_MAX: %i\\n\", RAND_MAX);\n    printf(\"INT_MAX: %i\\n\", INT_MAX);\n    printf(\"Random value on [0,1]: %f\\n\", (double)rand() / RAND_MAX);\n}\n```\n\nPossible output:\n\n```\nRAND_MAX: 2147483647\nINT_MAX: 2147483647\nRandom value on [0,1]: 0.362509\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22/3 General utilities \\<stdlib.h\\> (p: 248)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22/3 General utilities \\<stdlib.h\\> (p: 340)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20/3 General utilities \\<stdlib.h\\> (p: 306)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10 GENERAL UTILITIES \\<stdlib.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/random/RAND_MAX](https://en.cppreference.com/w/c/numeric/random/RAND_MAX)"
- name: realloc
  summary: Reallocates the given area of memory
  description: "# realloc\n\n[TABLE]\n\nReallocates the given area of memory. If `ptr` is not NULL, it must be previously allocated by [`malloc`](malloc \"c/memory/malloc\"), [`calloc`](calloc \"c/memory/calloc\") or `realloc` and not yet freed with a call to [`free`](free \"c/memory/free\") or `realloc`. Otherwise, the results are undefined.\n\nThe reallocation is done by either:\n\na) expanding or contracting the existing area pointed to by `ptr`, if possible. The contents of the area remain unchanged up to the lesser of the new and old sizes. If the area is expanded, the contents of the new part of the array are undefined.\n\nb) allocating a new memory block of size `new_size` bytes, copying memory area with size equal the lesser of the new and the old sizes, and freeing the old block.\n\nIf there is not enough memory, the old memory block is not freed and null pointer is returned.\n\nIf `ptr` is [`NULL`](../types/null \"c/types/NULL\"), the behavior is the same as calling [`malloc`](http://en.cppreference.com/w/c/memory/malloc)`(``new_size``)`.\n\nOtherwise,\n\n|                                                                                                                                                                                                                                                                                                                                                                  |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| if `new_size` is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-null pointer may be returned that may not be used to access storage). Such usage is deprecated (via [C DR 400](https://open-std.org/JTC1/SC22/WG14/www/docs/n2396.htm#dr_400)).(since C17) | (until C23) |\n| if `new_size` is zero, the behavior is undefined.                                                                                                                                                                                                                                                                                                                | (since C23) |\n\n[TABLE]\n\n### Parameters\n\n|          |     |                                              |\n|----------|-----|----------------------------------------------|\n| ptr      | \\-  | pointer to the memory area to be reallocated |\n| new_size | \\-  | new size of the array in bytes               |\n\n### Return value\n\nOn success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with [`free`](free \"c/memory/free\") or `realloc`. The original pointer `ptr` is invalidated and any access to it is undefined behavior (even if reallocation was in-place).\n\nOn failure, returns a null pointer. The original pointer `ptr` remains valid and may need to be deallocated with [`free`](free \"c/memory/free\") or `realloc`.\n\n### Notes\n\nOriginally (in C89), support for zero size was added to accommodate code such as\n\n```\nOBJ *p = calloc(0, sizeof(OBJ)); // \"zero-length\" placeholder\n/*...*/\nwhile (1)\n{\n    p = realloc(p, c * sizeof(OBJ)); // reallocations until size settles\n    /* code that may change c or break out of loop */\n}\n```\n\n### Example\n\n```\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nvoid print_storage_info(const int* next, const int* prev, int ints)\n{\n    if (next)\n        printf(\"%s location: %p. Size: %d ints (%ld bytes).\\n\",\n               (next != prev ? \"New\" : \"Old\"), (void*)next, ints, ints * sizeof(int));\n    else\n        printf(\"Allocation failed.\\n\");\n}\n \nint main(void)\n{\n    const int pattern[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    const int pattern_size = sizeof pattern / sizeof(int);\n    int *next = NULL, *prev = NULL;\n \n    if ((next = (int*)malloc(pattern_size * sizeof *next))) // allocates an array\n    {\n        memcpy(next, pattern, sizeof pattern); // fills the array\n        print_storage_info(next, prev, pattern_size);\n    }\n    else\n        return EXIT_FAILURE;\n \n    // Reallocate in cycle using the following values as a new storage size.\n    const int realloc_size[] = {10, 12, 512, 32768, 65536, 32768};\n \n    for (int i = 0; i != sizeof realloc_size / sizeof(int); ++i)\n    {\n        if ((next = (int*)realloc(prev = next, realloc_size[i] * sizeof(int))))\n        {\n            print_storage_info(next, prev, realloc_size[i]);\n            assert(!memcmp(next, pattern, sizeof pattern));  // is pattern held\n        }\n        else // if realloc failed, the original pointer needs to be freed\n        {\n            free(prev);\n            return EXIT_FAILURE;\n        }\n    }\n \n    free(next); // finally, frees the storage\n    return EXIT_SUCCESS;\n}\n```\n\nPossible output:\n\n```\nNew location: 0x144c010. Size: 8 ints (32 bytes).\nOld location: 0x144c010. Size: 10 ints (40 bytes).\nNew location: 0x144c450. Size: 12 ints (48 bytes).\nOld location: 0x144c450. Size: 512 ints (2048 bytes).\nOld location: 0x144c450. Size: 32768 ints (131072 bytes).\nNew location: 0x7f490c5bd010. Size: 65536 ints (262144 bytes).\nOld location: 0x7f490c5bd010. Size: 32768 ints (131072 bytes).\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.22.3.5 The realloc function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.3.5 The realloc function (p: 254)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.3.5 The realloc function (p: 349)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.3.4 The realloc function (p: 314)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.3.4 The realloc function\n\n### See also\n\n|                                                                                                              |     |\n|--------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/memory/c/realloc \"cpp/memory/c/realloc\") for `realloc` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/memory/realloc](https://en.cppreference.com/w/c/memory/realloc)"
- name: register
  summary: ''
  description: "# C keywords: register\n\n### Usage\n\n- [automatic duration storage-class specifier](../language/storage_duration \"c/language/storage duration\") with no linkage. Hints that the variable will be used heavily.\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/register](https://en.cppreference.com/w/c/keyword/register)"
- name: remainder
  summary: The IEEE floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where the value n is the integral value nearest the exact value x/y
  description: "# remainder, remainderf, remainderl\n\n[TABLE]\n\n1-3) Computes the IEEE remainder of the floating point division operation `x/y`.\n\n4) Type-generic macro: If any argument has type `long double`, `remainderl` is called. Otherwise, if any argument has integer type or has type `double`, `remainder` is called. Otherwise, `remainderf` is called.\n\nThe IEEE floating-point remainder of the division operation `x/y` calculated by this function is exactly the value `x - n*y`, where the value `n` is the integral value nearest the exact value `x/y`. When \\|n-x/y\\| = ½, the value `n` is chosen to be even.\n\nIn contrast to [`fmod()`](fmod \"c/numeric/math/fmod\"), the returned value is not guaranteed to have the same sign as `x`.\n\nIf the returned value is `0`, it will have the same sign as `x`.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the IEEE floating-point remainder of the division `x/y` as defined above.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result is returned.\n\nIf `y` is zero, but the domain error does not occur, zero is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `y` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised, the result is always exact.\n- If `x` is ±∞ and `y` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `y` is ±0 and `x` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If either argument is NaN, NaN is returned.\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/remainder.html) that a domain error occurs if `x` is infinite or `y` is zero.\n\n[`fmod`](fmod \"c/numeric/math/fmod\"), but not `remainder` is useful for doing silent wrapping of floating-point types to unsigned integer types: `(``0.0`` ``<=`` ``(``y ``=`` `[`fmod`](http://en.cppreference.com/w/c/numeric/math/fmod)`(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0``)``)`` ``?`` y ``:`` ``65536.0`` ``+`` y``)` is in the range `[-0.0 .. 65535.0]`, which corresponds to `unsigned short`, but `remainder``(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0``)` is in the range `[-32767.0, +32768.0]`, which is outside of the range of `signed short`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"remainder(+5.1, +3.0) = %.1f\\n\", remainder(5.1,3));\n    printf(\"remainder(-5.1, +3.0) = %.1f\\n\", remainder(-5.1,3));\n    printf(\"remainder(+5.1, -3.0) = %.1f\\n\", remainder(5.1,-3));\n    printf(\"remainder(-5.1, -3.0) = %.1f\\n\", remainder(-5.1,-3));\n \n    // special values\n    printf(\"remainder(-0.0, 1.0) = %.1f\\n\", remainder(-0.0, 1));\n    printf(\"remainder(+5.1, Inf) = %.1f\\n\", remainder(5.1, INFINITY));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"remainder(+5.1, 0) = %.1f\\n\", remainder(5.1, 0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nOutput:\n\n```\nremainder(+5.1, +3.0) = -0.9\nremainder(-5.1, +3.0) = 0.9\nremainder(+5.1, -3.0) = -0.9\nremainder(-5.1, -3.0) = 0.9\nremainder(+0.0, 1.0) = 0.0\nremainder(-0.0, 1.0) = -0.0\nremainder(+5.1, Inf) = 5.1\nremainder(+5.1, 0) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.10.2 The remainder functions (p: 185-186)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.7.2 The remainder functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.10.2 The remainder functions (p: 254-255)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.7.2 The remainder functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.10.2 The remainder functions (p: 235)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.7.2 The remainder functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/remainder](https://en.cppreference.com/w/c/numeric/math/remainder)"
- name: remainderf
  summary: The IEEE floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where the value n is the integral value nearest the exact value x/y
  description: "# remainder, remainderf, remainderl\n\n[TABLE]\n\n1-3) Computes the IEEE remainder of the floating point division operation `x/y`.\n\n4) Type-generic macro: If any argument has type `long double`, `remainderl` is called. Otherwise, if any argument has integer type or has type `double`, `remainder` is called. Otherwise, `remainderf` is called.\n\nThe IEEE floating-point remainder of the division operation `x/y` calculated by this function is exactly the value `x - n*y`, where the value `n` is the integral value nearest the exact value `x/y`. When \\|n-x/y\\| = ½, the value `n` is chosen to be even.\n\nIn contrast to [`fmod()`](fmod \"c/numeric/math/fmod\"), the returned value is not guaranteed to have the same sign as `x`.\n\nIf the returned value is `0`, it will have the same sign as `x`.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the IEEE floating-point remainder of the division `x/y` as defined above.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result is returned.\n\nIf `y` is zero, but the domain error does not occur, zero is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `y` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised, the result is always exact.\n- If `x` is ±∞ and `y` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `y` is ±0 and `x` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If either argument is NaN, NaN is returned.\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/remainder.html) that a domain error occurs if `x` is infinite or `y` is zero.\n\n[`fmod`](fmod \"c/numeric/math/fmod\"), but not `remainder` is useful for doing silent wrapping of floating-point types to unsigned integer types: `(``0.0`` ``<=`` ``(``y ``=`` `[`fmod`](http://en.cppreference.com/w/c/numeric/math/fmod)`(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0``)``)`` ``?`` y ``:`` ``65536.0`` ``+`` y``)` is in the range `[-0.0 .. 65535.0]`, which corresponds to `unsigned short`, but `remainder``(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0``)` is in the range `[-32767.0, +32768.0]`, which is outside of the range of `signed short`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"remainder(+5.1, +3.0) = %.1f\\n\", remainder(5.1,3));\n    printf(\"remainder(-5.1, +3.0) = %.1f\\n\", remainder(-5.1,3));\n    printf(\"remainder(+5.1, -3.0) = %.1f\\n\", remainder(5.1,-3));\n    printf(\"remainder(-5.1, -3.0) = %.1f\\n\", remainder(-5.1,-3));\n \n    // special values\n    printf(\"remainder(-0.0, 1.0) = %.1f\\n\", remainder(-0.0, 1));\n    printf(\"remainder(+5.1, Inf) = %.1f\\n\", remainder(5.1, INFINITY));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"remainder(+5.1, 0) = %.1f\\n\", remainder(5.1, 0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nOutput:\n\n```\nremainder(+5.1, +3.0) = -0.9\nremainder(-5.1, +3.0) = 0.9\nremainder(+5.1, -3.0) = -0.9\nremainder(-5.1, -3.0) = 0.9\nremainder(+0.0, 1.0) = 0.0\nremainder(-0.0, 1.0) = -0.0\nremainder(+5.1, Inf) = 5.1\nremainder(+5.1, 0) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.10.2 The remainder functions (p: 185-186)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.7.2 The remainder functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.10.2 The remainder functions (p: 254-255)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.7.2 The remainder functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.10.2 The remainder functions (p: 235)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.7.2 The remainder functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/remainder](https://en.cppreference.com/w/c/numeric/math/remainder)"
- name: remainderl
  summary: The IEEE floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where the value n is the integral value nearest the exact value x/y
  description: "# remainder, remainderf, remainderl\n\n[TABLE]\n\n1-3) Computes the IEEE remainder of the floating point division operation `x/y`.\n\n4) Type-generic macro: If any argument has type `long double`, `remainderl` is called. Otherwise, if any argument has integer type or has type `double`, `remainder` is called. Otherwise, `remainderf` is called.\n\nThe IEEE floating-point remainder of the division operation `x/y` calculated by this function is exactly the value `x - n*y`, where the value `n` is the integral value nearest the exact value `x/y`. When \\|n-x/y\\| = ½, the value `n` is chosen to be even.\n\nIn contrast to [`fmod()`](fmod \"c/numeric/math/fmod\"), the returned value is not guaranteed to have the same sign as `x`.\n\nIf the returned value is `0`, it will have the same sign as `x`.\n\n### Parameters\n\n|      |     |                       |\n|------|-----|-----------------------|\n| x, y | \\-  | floating point values |\n\n### Return value\n\nIf successful, returns the IEEE floating-point remainder of the division `x/y` as defined above.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result is returned.\n\nIf `y` is zero, but the domain error does not occur, zero is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `y` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised, the result is always exact.\n- If `x` is ±∞ and `y` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If `y` is ±0 and `x` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If either argument is NaN, NaN is returned.\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/remainder.html) that a domain error occurs if `x` is infinite or `y` is zero.\n\n[`fmod`](fmod \"c/numeric/math/fmod\"), but not `remainder` is useful for doing silent wrapping of floating-point types to unsigned integer types: `(``0.0`` ``<=`` ``(``y ``=`` `[`fmod`](http://en.cppreference.com/w/c/numeric/math/fmod)`(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0``)``)`` ``?`` y ``:`` ``65536.0`` ``+`` y``)` is in the range `[-0.0 .. 65535.0]`, which corresponds to `unsigned short`, but `remainder``(`[`rint`](http://en.cppreference.com/w/c/numeric/math/rint)`(``x``)``, ``65536.0``)` is in the range `[-32767.0, +32768.0]`, which is outside of the range of `signed short`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"remainder(+5.1, +3.0) = %.1f\\n\", remainder(5.1,3));\n    printf(\"remainder(-5.1, +3.0) = %.1f\\n\", remainder(-5.1,3));\n    printf(\"remainder(+5.1, -3.0) = %.1f\\n\", remainder(5.1,-3));\n    printf(\"remainder(-5.1, -3.0) = %.1f\\n\", remainder(-5.1,-3));\n \n    // special values\n    printf(\"remainder(-0.0, 1.0) = %.1f\\n\", remainder(-0.0, 1));\n    printf(\"remainder(+5.1, Inf) = %.1f\\n\", remainder(5.1, INFINITY));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"remainder(+5.1, 0) = %.1f\\n\", remainder(5.1, 0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nOutput:\n\n```\nremainder(+5.1, +3.0) = -0.9\nremainder(-5.1, +3.0) = 0.9\nremainder(+5.1, -3.0) = -0.9\nremainder(-5.1, -3.0) = 0.9\nremainder(+0.0, 1.0) = 0.0\nremainder(-0.0, 1.0) = -0.0\nremainder(+5.1, Inf) = 5.1\nremainder(+5.1, 0) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.10.2 The remainder functions (p: 185-186)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.7.2 The remainder functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.10.2 The remainder functions (p: 254-255)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.7.2 The remainder functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.10.2 The remainder functions (p: 235)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.7.2 The remainder functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/remainder](https://en.cppreference.com/w/c/numeric/math/remainder)"
- name: remove
  summary: Deletes the file identified by character string pointed to by fname
  description: "# remove\n\n[TABLE]\n\nDeletes the file identified by character string pointed to by `fname`.\n\nIf the file is currently open by this or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name although the file system space is not reclaimed until the last running process closes the file; Windows does not allow the file to be deleted).\n\n### Parameters\n\n|       |     |                                                                                        |\n|-------|-----|----------------------------------------------------------------------------------------|\n| fname | \\-  | pointer to a null-terminated string containing the path identifying the file to delete |\n\n### Return value\n\n`​0​` upon success or non-zero value on error.\n\n### Notes\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html) many additional details for the behavior of this function.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE* fp = fopen(\"file1.txt\", \"w\"); // create file\n    if (!fp)\n    {\n        perror(\"file1.txt\");\n        return EXIT_FAILURE;\n    }\n    puts(\"Created file1.txt\");\n    fclose(fp);\n \n    int rc = remove(\"file1.txt\");\n    if (rc)\n    {\n        perror(\"remove\");\n        return EXIT_FAILURE;\n    }\n    puts(\"Removed file1.txt\");\n \n    fp = fopen(\"file1.txt\", \"r\"); // Failure: file does not exist\n    if (!fp)\n        perror(\"Opening removed file failed\");\n \n    rc = remove(\"file1.txt\"); // Failure: file does not exist\n    if (rc)\n        perror(\"Double-remove failed\");\n \n    return EXIT_SUCCESS;\n}\n```\n\nPossible output:\n\n```\nCreated file1.txt\nRemoved file1.txt\nOpening removed file failed: No such file or directory\nDouble-remove failed: No such file or directory\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.4.1 The remove function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.4.1 The remove function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.4.1 The remove function (p: 302)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.4.1 The remove function (p: 268)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.4.1 The remove function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/remove](https://en.cppreference.com/w/c/io/remove)"
- name: remquo
  summary: If successful, returns the floating-point remainder of the division x/y as defined in remainder, and stores, in *quo, the sign and at least three of the least significant bits of x/y (formally, stores a value whose sign is the sign of x/y and whose magnitude is congruent modulo 2n to the magnitude of the integral quotient of x/y, where n is an implementation-defined integer greater than or equal to 3)
  description: "# remquo, remquof, remquol\n\n[TABLE]\n\n1-3) Computes the floating-point remainder of the division operation `x/y` as the [`remainder()`](remainder \"c/numeric/math/remainder\") function does. Additionally, the sign and at least the three of the last bits of `x/y` will be stored in `quo`, sufficient to determine the octant of the result within a period.\n\n4) Type-generic macro: If any non-pointer argument has type `long double`, `remquol` is called. Otherwise, if any non-pointer argument has integer type or has type `double`, `remquo` is called. Otherwise, `remquof` is called.\n\n### Parameters\n\n|      |     |                                                                      |\n|------|-----|----------------------------------------------------------------------|\n| x, y | \\-  | floating point values                                                |\n| quo  | \\-  | pointer to an integer value to store the sign and some bits of `x/y` |\n\n### Return value\n\nIf successful, returns the floating-point remainder of the division `x/y` as defined in [`remainder`](remainder \"c/numeric/math/remainder\"), and stores, in `*quo`, the sign and at least three of the least significant bits of `x/y` (formally, stores a value whose sign is the sign of `x/y` and whose magnitude is congruent modulo 2^(n) to the magnitude of the integral quotient of `x/y`, where n is an implementation-defined integer greater than or equal to 3).\n\nIf `y` is zero, the value stored in `*quo` is unspecified.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result is returned if subnormals are supported.\n\nIf `y` is zero, but the domain error does not occur, zero is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `y` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- If `x` is ±∞ and `y` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `y` is ±0 and `x` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If either `x` or `y` is NaN, NaN is returned\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/remquo.html) that a domain error occurs if `x` is infinite or `y` is zero.\n\nThis function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(πx) for a very large `x`, calling [`sin`](sin \"c/numeric/math/sin\") directly may result in a large error, but if the function argument is first reduced with `remquo`, the low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.\n\nOn some platforms this operation is supported by hardware (and, for example, on Intel CPU, `FPREM1` leaves exactly 3 bits of precision in the quotient)\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\ndouble cos_pi_x_naive(double x)\n{\n    const double pi = acos(-1);\n    return cos(pi * x);\n}\n// the period is 2, values are (0;0.5) positive, (0.5;1.5) negative, (1.5,2) positive\ndouble cos_pi_x_smart(double x)\n{\n    const double pi = acos(-1);\n    int extremum;\n    double rem = remquo(x, 1, &extremum);\n    extremum = (unsigned)extremum % 2; // keep 1 bit to determine nearest extremum\n    return extremum ? -cos(pi * rem) : cos(pi * rem);\n}\nint main(void)\n{\n    printf(\"cos(pi * 0.25) = %f\\n\", cos_pi_x_naive(0.25));\n    printf(\"cos(pi * 1.25) = %f\\n\", cos_pi_x_naive(1.25));\n    printf(\"cos(pi * 1000000000000.25) = %f\\n\", cos_pi_x_naive(1000000000000.25));\n    printf(\"cos(pi * 1000000000001.25) = %f\\n\", cos_pi_x_naive(1000000000001.25));\n    printf(\"cos(pi * 1000000000000.25) = %f\\n\", cos_pi_x_smart(1000000000000.25));\n    printf(\"cos(pi * 1000000000001.25) = %f\\n\", cos_pi_x_smart(1000000000001.25));\n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    int quo;\n    printf(\"remquo(+Inf, 1) = %.1f\\n\", remquo(INFINITY, 1, &quo));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncos(pi * 0.25) = 0.707107\ncos(pi * 1.25) = -0.707107\ncos(pi * 1000000000000.25) = 0.707123\ncos(pi * 1000000000001.25) = -0.707117\ncos(pi * 1000000000000.25) = 0.707107\ncos(pi * 1000000000001.25) = -0.707107 \nremquo(+Inf, 1) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.10.3 The remquo functions (p: 186)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.7.3 The remquo functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.10.3 The remquo functions (p: 255)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.7.3 The remquo functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.10.3 The remquo functions (p: 236)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.7.3 The remquo functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/remquo](https://en.cppreference.com/w/c/numeric/math/remquo)"
- name: remquof
  summary: If successful, returns the floating-point remainder of the division x/y as defined in remainder, and stores, in *quo, the sign and at least three of the least significant bits of x/y (formally, stores a value whose sign is the sign of x/y and whose magnitude is congruent modulo 2n to the magnitude of the integral quotient of x/y, where n is an implementation-defined integer greater than or equal to 3)
  description: "# remquo, remquof, remquol\n\n[TABLE]\n\n1-3) Computes the floating-point remainder of the division operation `x/y` as the [`remainder()`](remainder \"c/numeric/math/remainder\") function does. Additionally, the sign and at least the three of the last bits of `x/y` will be stored in `quo`, sufficient to determine the octant of the result within a period.\n\n4) Type-generic macro: If any non-pointer argument has type `long double`, `remquol` is called. Otherwise, if any non-pointer argument has integer type or has type `double`, `remquo` is called. Otherwise, `remquof` is called.\n\n### Parameters\n\n|      |     |                                                                      |\n|------|-----|----------------------------------------------------------------------|\n| x, y | \\-  | floating point values                                                |\n| quo  | \\-  | pointer to an integer value to store the sign and some bits of `x/y` |\n\n### Return value\n\nIf successful, returns the floating-point remainder of the division `x/y` as defined in [`remainder`](remainder \"c/numeric/math/remainder\"), and stores, in `*quo`, the sign and at least three of the least significant bits of `x/y` (formally, stores a value whose sign is the sign of `x/y` and whose magnitude is congruent modulo 2^(n) to the magnitude of the integral quotient of `x/y`, where n is an implementation-defined integer greater than or equal to 3).\n\nIf `y` is zero, the value stored in `*quo` is unspecified.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result is returned if subnormals are supported.\n\nIf `y` is zero, but the domain error does not occur, zero is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `y` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- If `x` is ±∞ and `y` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `y` is ±0 and `x` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If either `x` or `y` is NaN, NaN is returned\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/remquo.html) that a domain error occurs if `x` is infinite or `y` is zero.\n\nThis function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(πx) for a very large `x`, calling [`sin`](sin \"c/numeric/math/sin\") directly may result in a large error, but if the function argument is first reduced with `remquo`, the low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.\n\nOn some platforms this operation is supported by hardware (and, for example, on Intel CPU, `FPREM1` leaves exactly 3 bits of precision in the quotient)\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\ndouble cos_pi_x_naive(double x)\n{\n    const double pi = acos(-1);\n    return cos(pi * x);\n}\n// the period is 2, values are (0;0.5) positive, (0.5;1.5) negative, (1.5,2) positive\ndouble cos_pi_x_smart(double x)\n{\n    const double pi = acos(-1);\n    int extremum;\n    double rem = remquo(x, 1, &extremum);\n    extremum = (unsigned)extremum % 2; // keep 1 bit to determine nearest extremum\n    return extremum ? -cos(pi * rem) : cos(pi * rem);\n}\nint main(void)\n{\n    printf(\"cos(pi * 0.25) = %f\\n\", cos_pi_x_naive(0.25));\n    printf(\"cos(pi * 1.25) = %f\\n\", cos_pi_x_naive(1.25));\n    printf(\"cos(pi * 1000000000000.25) = %f\\n\", cos_pi_x_naive(1000000000000.25));\n    printf(\"cos(pi * 1000000000001.25) = %f\\n\", cos_pi_x_naive(1000000000001.25));\n    printf(\"cos(pi * 1000000000000.25) = %f\\n\", cos_pi_x_smart(1000000000000.25));\n    printf(\"cos(pi * 1000000000001.25) = %f\\n\", cos_pi_x_smart(1000000000001.25));\n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    int quo;\n    printf(\"remquo(+Inf, 1) = %.1f\\n\", remquo(INFINITY, 1, &quo));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncos(pi * 0.25) = 0.707107\ncos(pi * 1.25) = -0.707107\ncos(pi * 1000000000000.25) = 0.707123\ncos(pi * 1000000000001.25) = -0.707117\ncos(pi * 1000000000000.25) = 0.707107\ncos(pi * 1000000000001.25) = -0.707107 \nremquo(+Inf, 1) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.10.3 The remquo functions (p: 186)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.7.3 The remquo functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.10.3 The remquo functions (p: 255)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.7.3 The remquo functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.10.3 The remquo functions (p: 236)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.7.3 The remquo functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/remquo](https://en.cppreference.com/w/c/numeric/math/remquo)"
- name: remquol
  summary: If successful, returns the floating-point remainder of the division x/y as defined in remainder, and stores, in *quo, the sign and at least three of the least significant bits of x/y (formally, stores a value whose sign is the sign of x/y and whose magnitude is congruent modulo 2n to the magnitude of the integral quotient of x/y, where n is an implementation-defined integer greater than or equal to 3)
  description: "# remquo, remquof, remquol\n\n[TABLE]\n\n1-3) Computes the floating-point remainder of the division operation `x/y` as the [`remainder()`](remainder \"c/numeric/math/remainder\") function does. Additionally, the sign and at least the three of the last bits of `x/y` will be stored in `quo`, sufficient to determine the octant of the result within a period.\n\n4) Type-generic macro: If any non-pointer argument has type `long double`, `remquol` is called. Otherwise, if any non-pointer argument has integer type or has type `double`, `remquo` is called. Otherwise, `remquof` is called.\n\n### Parameters\n\n|      |     |                                                                      |\n|------|-----|----------------------------------------------------------------------|\n| x, y | \\-  | floating point values                                                |\n| quo  | \\-  | pointer to an integer value to store the sign and some bits of `x/y` |\n\n### Return value\n\nIf successful, returns the floating-point remainder of the division `x/y` as defined in [`remainder`](remainder \"c/numeric/math/remainder\"), and stores, in `*quo`, the sign and at least three of the least significant bits of `x/y` (formally, stores a value whose sign is the sign of `x/y` and whose magnitude is congruent modulo 2^(n) to the magnitude of the integral quotient of `x/y`, where n is an implementation-defined integer greater than or equal to 3).\n\nIf `y` is zero, the value stored in `*quo` is unspecified.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result is returned if subnormals are supported.\n\nIf `y` is zero, but the domain error does not occur, zero is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error may occur if `y` is zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- If `x` is ±∞ and `y` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If `y` is ±0 and `x` is not NaN, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised\n- If either `x` or `y` is NaN, NaN is returned\n\n### Notes\n\n[POSIX requires](http://pubs.opengroup.org/onlinepubs/9699919799/functions/remquo.html) that a domain error occurs if `x` is infinite or `y` is zero.\n\nThis function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(πx) for a very large `x`, calling [`sin`](sin \"c/numeric/math/sin\") directly may result in a large error, but if the function argument is first reduced with `remquo`, the low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.\n\nOn some platforms this operation is supported by hardware (and, for example, on Intel CPU, `FPREM1` leaves exactly 3 bits of precision in the quotient)\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\ndouble cos_pi_x_naive(double x)\n{\n    const double pi = acos(-1);\n    return cos(pi * x);\n}\n// the period is 2, values are (0;0.5) positive, (0.5;1.5) negative, (1.5,2) positive\ndouble cos_pi_x_smart(double x)\n{\n    const double pi = acos(-1);\n    int extremum;\n    double rem = remquo(x, 1, &extremum);\n    extremum = (unsigned)extremum % 2; // keep 1 bit to determine nearest extremum\n    return extremum ? -cos(pi * rem) : cos(pi * rem);\n}\nint main(void)\n{\n    printf(\"cos(pi * 0.25) = %f\\n\", cos_pi_x_naive(0.25));\n    printf(\"cos(pi * 1.25) = %f\\n\", cos_pi_x_naive(1.25));\n    printf(\"cos(pi * 1000000000000.25) = %f\\n\", cos_pi_x_naive(1000000000000.25));\n    printf(\"cos(pi * 1000000000001.25) = %f\\n\", cos_pi_x_naive(1000000000001.25));\n    printf(\"cos(pi * 1000000000000.25) = %f\\n\", cos_pi_x_smart(1000000000000.25));\n    printf(\"cos(pi * 1000000000001.25) = %f\\n\", cos_pi_x_smart(1000000000001.25));\n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    int quo;\n    printf(\"remquo(+Inf, 1) = %.1f\\n\", remquo(INFINITY, 1, &quo));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ncos(pi * 0.25) = 0.707107\ncos(pi * 1.25) = -0.707107\ncos(pi * 1000000000000.25) = 0.707123\ncos(pi * 1000000000001.25) = -0.707117\ncos(pi * 1000000000000.25) = 0.707107\ncos(pi * 1000000000001.25) = -0.707107 \nremquo(+Inf, 1) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.10.3 The remquo functions (p: 186)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.7.3 The remquo functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.10.3 The remquo functions (p: 255)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.7.3 The remquo functions (p: 529)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.10.3 The remquo functions (p: 236)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.7.3 The remquo functions (p: 465)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/remquo](https://en.cppreference.com/w/c/numeric/math/remquo)"
- name: rename
  summary: Changes the filename of a file
  description: "# rename\n\n[TABLE]\n\nChanges the filename of a file. The file is identified by character string pointed to by `old_filename`. The new filename is identified by character string pointed to by `new_filename`.\n\nIf `new_filename` exists, the behavior is implementation-defined.\n\n### Parameters\n\n|              |     |                                                                                        |\n|--------------|-----|----------------------------------------------------------------------------------------|\n| old_filename | \\-  | pointer to a null-terminated string containing the path identifying the file to rename |\n| new_filename | \\-  | pointer to a null-terminated string containing the new path of the file                |\n\n### Return value\n\n`​0​` upon success or non-zero value on error.\n\n### Notes\n\n[POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html) specifies many additional details on the semantics of this function.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    FILE* fp = fopen(\"from.txt\", \"w\"); // create file \"from.txt\"\n    if (!fp)\n    {\n        perror(\"from.txt\");\n        return EXIT_FAILURE;\n    }\n    fputc('a', fp); // write to \"from.txt\"\n    fclose(fp);\n \n    int rc = rename(\"from.txt\", \"to.txt\");\n    if (rc)\n    {\n        perror(\"rename\");\n        return EXIT_FAILURE;\n    }\n \n    fp = fopen(\"to.txt\", \"r\");\n    if(!fp)\n    {\n        perror(\"to.txt\");\n        return EXIT_FAILURE;\n    }\n    printf(\"%c\\n\", fgetc(fp)); // read from \"to.txt\"\n    fclose(fp);\n \n    return EXIT_SUCCESS;\n}\n```\n\nPossible output:\n\n```\na\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.4.2 The rename function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.4.2 The rename function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.4.2 The rename function (p: 302-303)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.4.2 The rename function (p: 268-269)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.4.2 The rename function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/rename](https://en.cppreference.com/w/c/io/rename)"
- name: reproducible (since C23)
  summary: Provides the compiler with information about the access of objects by a function such that certain properties of function calls can be deduced
  description: "# C attribute: unsequenced, reproducible (since C23)\n\nProvides the compiler with information about the access of objects by a function such that certain properties of function calls can be deduced.\n\n### Syntax\n\n[TABLE]\n\n1) Indicates that a function is effectless, idempotent, stateless, and independent\n\n2) Indicates that a function is effectless and idempotent\n\n### Explanation\n\nThese attributes apply to a function declarator or to a type specifier that has a function type. The corresponding attribute is a property of the function type.\n\n#### Effectless\n\nAn evaluation of a function call is effectless if any store operation that is sequenced during the call is the modification of an object that synchronizes with the call; if additionally the operation is observable, all access to the object must be based on a unique pointer parameter of the function.\n\n#### Idempotent\n\nAn evaluation E is idempotent if a second evaluation of E can be sequenced immediately after the original one without changing the resulting value, if any, or the observable state of the execution.\n\n#### Stateless\n\nA function F is stateless if any definition of an object of static or thread [storage duration](../storage_duration \"c/language/storage duration\") in F or in a function that is called by F is `const` but not `volatile` qualified.\n\n#### Independent\n\nA function F is independent if for any object X that is observed by a call to F through an lvalue that is not based on a parameter of the call, all accesses to X in all calls to F during the same program execution observe the same value; otherwise if the access is based on a pointer parameter, there shall be a unique such pointer parameter P such that any access to X shall be to an lvalue that is based on P.\n\nAn object X is observed by a function call if both synchronize, if X is not local to the call, if X has a lifetime that starts before the function call, and if an access of X is sequenced during the call; the last value of X, if any, that is stored before the call is said to be the value of X that is observed by the call.\n\n### Notes\n\nThese attributes exist for the purpose of compiler optimization.\n\nIf a function is reproducible, multiple subsequent calls can be treated as a single call.\n\nIf a function is unsequenced, multiple subsequent calls can be treated as a single call, and the calls can be parallelized and reordered arbitrarily.\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes/unsequenced](https://en.cppreference.com/w/c/language/attributes/unsequenced)"
- name: reproducible (since C23)
  summary: Provides the compiler with information about the access of objects by a function such that certain properties of function calls can be deduced
  description: "# C attribute: unsequenced, reproducible (since C23)\n\nProvides the compiler with information about the access of objects by a function such that certain properties of function calls can be deduced.\n\n### Syntax\n\n[TABLE]\n\n1) Indicates that a function is effectless, idempotent, stateless, and independent\n\n2) Indicates that a function is effectless and idempotent\n\n### Explanation\n\nThese attributes apply to a function declarator or to a type specifier that has a function type. The corresponding attribute is a property of the function type.\n\n#### Effectless\n\nAn evaluation of a function call is effectless if any store operation that is sequenced during the call is the modification of an object that synchronizes with the call; if additionally the operation is observable, all access to the object must be based on a unique pointer parameter of the function.\n\n#### Idempotent\n\nAn evaluation E is idempotent if a second evaluation of E can be sequenced immediately after the original one without changing the resulting value, if any, or the observable state of the execution.\n\n#### Stateless\n\nA function F is stateless if any definition of an object of static or thread [storage duration](../storage_duration \"c/language/storage duration\") in F or in a function that is called by F is `const` but not `volatile` qualified.\n\n#### Independent\n\nA function F is independent if for any object X that is observed by a call to F through an lvalue that is not based on a parameter of the call, all accesses to X in all calls to F during the same program execution observe the same value; otherwise if the access is based on a pointer parameter, there shall be a unique such pointer parameter P such that any access to X shall be to an lvalue that is based on P.\n\nAn object X is observed by a function call if both synchronize, if X is not local to the call, if X has a lifetime that starts before the function call, and if an access of X is sequenced during the call; the last value of X, if any, that is stored before the call is said to be the value of X that is observed by the call.\n\n### Notes\n\nThese attributes exist for the purpose of compiler optimization.\n\nIf a function is reproducible, multiple subsequent calls can be treated as a single call.\n\nIf a function is unsequenced, multiple subsequent calls can be treated as a single call, and the calls can be parallelized and reordered arbitrarily.\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/attributes/reproducible](https://en.cppreference.com/w/c/language/attributes/reproducible)"
- name: restrict
  summary: ''
  description: "# C keywords: restrict (since C99)\n\n### Usage\n\n- [`restrict` type qualifier](../language/restrict \"c/language/restrict\") (since C99)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/restrict](https://en.cppreference.com/w/c/keyword/restrict)"
- name: restrict type qualifier
  summary: Each individual type in the C type system has several qualified versions of that type, corresponding to one, two, or all three of the const, volatile, and, for pointers to object types, restrict qualifiers
  description: "# restrict type qualifier (since C99)\n\nEach individual type in the C [type system](type \"c/language/type\") has several *qualified* versions of that type, corresponding to one, two, or all three of the [`const`](const \"c/language/const\"), [`volatile`](volatile \"c/language/volatile\"), and, for pointers to object types, `restrict` qualifiers. This page describes the effects of the `restrict` qualifier.\n\nOnly a pointer to an [object type](type \"c/language/type\") or a (possibly multi-dimensional) array thereof(since C23) may be restrict-qualified; in particular, the following are *erroneous*:\n\n- `int restrict *p`\n- `float (* restrict f9)(void)`\n\nRestrict semantics apply to lvalue expressions only; for example, a cast to restrict-qualified pointer or a function call returning a restrict-qualified pointer are not lvalues and the qualifier has no effect.\n\nDuring each execution of a block in which a restricted pointer `P` is declared (typically each execution of a function body in which `P` is a function parameter), if some object that is accessible through `P` (directly or indirectly) is modified, by any means, then all accesses to that object (both reads and writes) in that block must occur through `P` (directly or indirectly), otherwise the behavior is undefined:\n\n```\nvoid f(int n, int * restrict p, int * restrict q)\n{\n    while (n-- > 0)\n        *p++ = *q++; // none of the objects modified through *p is the same\n                     // as any of the objects read through *q\n                     // compiler free to optimize, vectorize, page map, etc.\n}\n \nvoid g(void)\n{\n    extern int d[100];\n    f(50, d + 50, d); // OK\n    f(50, d + 1, d);  // Undefined behavior: d[1] is accessed through both p and q in f\n}\n```\n\nIf the object is never modified, it may be aliased and accessed through different restrict-qualified pointers (note that if the objects pointed to by aliased restrict-qualified pointers are, in turn, pointers, this aliasing can inhibit optimization).\n\nAssignment from one restricted pointer to another is undefined behavior, except when assigning from a pointer to an object in some outer block to a pointer in some inner block (including using a restricted pointer argument when calling a function with a restricted pointer parameter) or when returning from a function (and otherwise when the block of the from-pointer ended):\n\n```\nint* restrict p1 = &a;\nint* restrict p2 = &b;\np1 = p2; // undefined behavior\n```\n\nRestricted pointers can be assigned to unrestricted pointers freely, the optimization opportunities remain in place as long as the compiler is able to analyze the code:\n\n```\nvoid f(int n, float * restrict r, float * restrict s)\n{\n    float *p = r, *q = s; // OK\n    while (n-- > 0)\n        *p++ = *q++; // almost certainly optimized just like *r++ = *s++\n}\n```\n\n|                                                                                                                                                                                                |             |\n|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If an array type is declared with the restrict type qualifier (through the use of [typedef](typedef \"c/language/typedef\")), the array type is not restrict-qualified, but its element type is: | (until C23) |\n| An array type and its element type are always considered to be identically restrict-qualified:                                                                                                 | (since C23) |\n\n```\ntypedef int *array_t[10];\n \nrestrict array_t a; // the type of a is int *restrict[10]\n// Notes: clang and icc reject this on the grounds that array_t is not a pointer type\n \nvoid *unqual_ptr = &a; // OK until C23; error since C23\n// Notes: clang applies the rule in C++/C23 even in C89-C17 modes\n```\n\nIn a function declaration, the keyword `restrict` may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed:\n\n```\nvoid f(int m, int n, float a[restrict m][n], float b[restrict m][n]);\n \nvoid g12(int n, float (*p)[n])\n{\n   f(10, n, p, p+10); // OK\n   f(20, n, p, p+10); // possibly undefined behavior (depending on what f does)\n}\n```\n\n### Notes\n\nThe intended use of the restrict qualifier (like the register storage class) is to promote optimization, and deleting all instances of the qualifier from all preprocessing translation units composing a conforming program does not change its meaning (i.e., observable behavior).\n\nThe compiler is free to ignore any or all aliasing implications of uses of `restrict`.\n\nTo avoid undefined behavior, the programmer must ensure that the aliasing assertions made by the restrict-qualified pointers are not violated.\n\nMany compilers provide, as a language extension, the opposite of `restrict`: an attribute indicating that pointers may alias even if their types differ: [`may_alias`](https://gcc.gnu.org/onlinedocs/gcc/Common-Type-Attributes.html#index-g_t_0040code_007bmay_005falias_007d-type-attribute-3667) (gcc),\n\n### Usage patterns\n\nThere are several common usage patterns for restrict-qualified pointers:\n\n#### File scope\n\nA file-scope restrict-qualified pointer has to point into a single array object for the duration of the program. That array object may not be referenced both through the restricted pointer and through either its declared name (if it has one) or another restricted pointer.\n\nFile scope restricted pointers are useful in providing access to dynamically allocated global arrays; the restrict semantics make it possible to optimize references through this pointer as effectively as references to a static array through its declared name:\n\n```\nfloat *restrict a, *restrict b;\nfloat c[100];\n \nint init(int n)\n{\n   float * t = malloc(2*n*sizeof(float));\n   a = t;      // a refers to 1st half\n   b = t + n;  // b refers to 2nd half\n}\n// compiler can deduce from the restrict qualifiers that\n// there is no potential aliasing among the names a, b, and c\n```\n\n#### Function parameter\n\nThe most popular use case for restrict-qualified pointers is the use as function parameters.\n\nIn the following example, the compiler may infer that there is no aliasing of modified objects, and so optimize the loop aggressively. Upon entry to `f`, the restricted pointer a must provide exclusive access to its associated array. In particular, within `f` neither `b` nor `c` may point into the array associated with `a`, because neither is assigned a pointer value based on `a`. For `b`, this is evident from the const-qualifier in its declaration, but for `c`, an inspection of the body of `f` is required:\n\n```\nfloat x[100];\nfloat *c;\n \nvoid f(int n, float * restrict a, float * const b)\n{\n    int i;\n    for ( i=0; i<n; i++ )\n       a[i] = b[i] + c[i];\n}\n \nvoid g3(void)\n{\n    float d[100], e[100];\n    c = x; f(100,   d,    e); // OK\n           f( 50,   d, d+50); // OK\n           f( 99, d+1,    d); // undefined behavior\n    c = d; f( 99, d+1,    e); // undefined behavior\n           f( 99,   e,  d+1); // OK\n}\n```\n\nNote that it is permitted for c to point into the array associated with b. Note also that, for these purposes, the \"array\" associated with a particular pointer means only that portion of an array object which is actually referenced through that pointer.\n\nNote that in the example above, the compiler can infer that a and b do not alias because b's constness guarantees that it cannot become dependent on a in the body of the function. Equivalently, the programmer could write `void f(int n, float * a, float const * restrict b)`, in which case the compiler can reason that objects referenced through b cannot be modified, and so no modified object can be referenced using both b and a. If the programmer were to write `void f(int n, float * restrict a, float * b)`, the compiler would be unable to infer non-aliasing of a and b without examining the body of the function.\n\nIn general, it is best to explicitly annotate all non-aliasing pointers in a function's prototype with `restrict`.\n\n#### Block scope\n\nA block scope restrict-qualified pointer makes an aliasing assertion that is limited to its block. It allows local assertions that apply only to important blocks, such as tight loops. It also makes it possible to convert a function that takes restrict-qualified pointers into a macro:\n\n```\nfloat x[100];\nfloat *c;\n \n#define f3(N, A, B)                                    \\\ndo                                                     \\\n{   int n = (N);                                       \\\n    float * restrict a = (A);                          \\\n    float * const    b = (B);                          \\\n    int i;                                             \\\n    for ( i=0; i<n; i++ )                              \\\n        a[i] = b[i] + c[i];                            \\\n} while(0)\n```\n\n#### Struct members\n\nThe scope of the aliasing assertion made by a restrict-qualified pointer that is a member of a struct is the scope of the identifier used to access the struct.\n\nEven if the struct is declared at file scope, when the identifier used to access the struct has block scope, the aliasing assertions in the struct also have block scope; the aliasing assertions are only in effect within a block execution or a function call, depending on how the object of this struct type was created:\n\n```\nstruct t      // Restricted pointers assert that\n{\n   int n;     // members point to disjoint storage.\n   float * restrict p;\n   float * restrict q;\n};\n \nvoid ff(struct t r, struct t s)\n{\n   struct t u;\n   // r,s,u have block scope\n   // r.p, r.q, s.p, s.q, u.p, u.q should all point to\n   // disjoint storage during each execution of ff.\n   // ...\n}\n```\n\n### Keywords\n\n[`restrict`](../keyword/restrict \"c/keyword/restrict\")\n\n### Example\n\ncode generation example; compile with -S (gcc, clang, etc) or /FA (visual studio)\n\n```\nint foo(int *a, int *b)\n{\n    *a = 5;\n    *b = 6;\n    return *a + *b;\n}\n \nint rfoo(int *restrict a, int *restrict b)\n{\n    *a = 5;\n    *b = 6;\n    return *a + *b;\n}\n```\n\nPossible output:\n\n```\n; generated code on 64bit Intel platform:\nfoo:\n    movl    $5, (%rdi)    ; store 5 in *a\n    movl    $6, (%rsi)    ; store 6 in *b\n    movl    (%rdi), %eax  ; read back from *a in case previous store modified it\n    addl    $6, %eax      ; add 6 to the value read from *a\n    ret\n \nrfoo:\n    movl      $11, %eax   ; the result is 11, a compile-time constant\n    movl      $5, (%rdi)  ; store 5 in *a\n    movl      $6, (%rsi)  ; store 6 in *b\n    ret\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.3.1 Formal definition of restrict (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.3.1 Formal definition of restrict (p: 89-90)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.3.1 Formal definition of restrict (p: 123-125)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.3.1 Formal definition of restrict (p: 110-112)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/restrict](https://en.cppreference.com/w/c/language/restrict)"
- name: return
  summary: ''
  description: "# C keywords: return\n\n### Usage\n\n- [`return` statement](../language/return \"c/language/return\"): as the declaration of the statement\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/return](https://en.cppreference.com/w/c/keyword/return)"
- name: return statement
  summary: Terminates current function and returns specified value to the caller function
  description: "# return statement\n\nTerminates current function and returns specified value to the caller function.\n\n### Syntax\n\n|                                                 |       |     |\n|-------------------------------------------------|-------|-----|\n| attr-spec-seq(optional) `return` expression `;` | \\(1\\) |     |\n| attr-spec-seq(optional) `return` `;`            | \\(2\\) |     |\n\n|               |     |                                                                                                           |\n|---------------|-----|-----------------------------------------------------------------------------------------------------------|\n| expression    | \\-  | expression used for initializing the return value of the function                                         |\n| attr-spec-seq | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the `return` statement |\n\n### Explanation\n\n1) Evaluates the expression, terminates the current function and returns the result of the expression to the caller (the value returned becomes the value of the function call expression). Only valid if the function return type is not `void`.\n\n2) Terminates the current function. Only valid if the function return type is `void`.\n\nIf the type of the expression is different from the return type of the function, its value is [converted](conversion \"c/language/conversion\") as if by assignment to an object whose type is the return type of the function, except that overlap between object representations is permitted:\n\n```\nstruct s { double i; } f(void); // function returning struct s\nunion { struct { int f1; struct s f2; } u1;\n        struct { struct s f3; int f4; } u2; } g;\nstruct s f(void)\n{\n    return g.u1.f2;\n}\nint main(void)\n{\n// g.u2.f3 = g.u1.f2; // undefined behavior (overlap in assignment)\n   g.u2.f3 = f();     // well-defined\n}\n```\n\nIf the return type is a real floating type, the result may be represented in [greater range and precision](../types/limits/flt_eval_method \"c/types/limits/FLT EVAL METHOD\") than implied by the new type.\n\nReaching the end of a function returning `void` is equivalent to `return;`. Reaching the end of any other value-returning function is undefined behavior if the result of the function is used in an expression (it is allowed to discard such return value). For `main`, see [`main` function](main_function \"c/language/main function\").\n\n|                                                                                                                     |             |\n|---------------------------------------------------------------------------------------------------------------------|-------------|\n| Executing the `return` statement in a [no-return function](_noreturn \"c/language/ Noreturn\") is undefined behavior. | (since C11) |\n\n### Keywords\n\n[`return`](../keyword/return \"c/keyword/return\")\n\n### Example\n\n```\n#include <stdio.h>\n \nvoid fa(int i)\n{\n    if (i == 2)\n       return;\n    printf(\"fa():   %d\\n\", i);\n} // implied return;\n \nint fb(int i)\n{\n    if (i > 4)\n       return 4;\n    printf(\"fb():   %d\\n\", i);\n    return 2;\n}\n \nint main(void)\n{\n    fa(2);\n    fa(1);\n    int i = fb(5);   // the return value 4 used to initializes i\n    i = fb(i);       // the return value 2 used as rhs of assignment\n    printf(\"main(): %d\\n\", i);\n}\n```\n\nOutput:\n\n```\nfa():   1\nfb():   4\nmain(): 2\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.8.6.4 The return statement (p: 111-112)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.8.6.4 The return statement (p: 154)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.8.6.4 The return statement (p: 139)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.6.6.4 The return statement\n\n### See also\n\n|                                                                                                                     |     |\n|---------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/return \"cpp/language/return\") for `return` statement |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/return](https://en.cppreference.com/w/c/language/return)"
- name: rewind
  summary: Moves the file position indicator to the beginning of the given file stream
  description: "# rewind\n\n[TABLE]\n\nMoves the file position indicator to the beginning of the given file stream.\n\nThe function is equivalent to [`fseek`](http://en.cppreference.com/w/c/io/fseek)`(``stream, ``0``, `[`SEEK_SET`](http://en.cppreference.com/w/c/io)`)``;`, except that end-of-file and error indicators are cleared.\n\nThe function drops any effects from previous calls to [`ungetc`](ungetc \"c/io/ungetc\").\n\n### Parameters\n\n|        |     |                       |\n|--------|-----|-----------------------|\n| stream | \\-  | file stream to modify |\n\n### Return value\n\n(none)\n\n### Example\n\nThis example shows how to read a file twice\n\n```\n#include <stdio.h>\n \nchar str[20];\n \nint main(void)\n{\n    FILE *f;\n    char ch;\n \n    f = fopen(\"file.txt\", \"w\");\n    for (ch = '0'; ch <= '9'; ch++) {\n        fputc(ch, f);\n    }\n    fclose(f);\n \n    f = fopen(\"file.txt\", \"r\");\n    fread(str, 1, 10, f);\n    puts(str);\n \n    rewind(f);\n    fread(str, 1, 10, f);\n    puts(str);\n    fclose(f);\n \n    return 0;\n}\n```\n\nOutput:\n\n```\n0123456789\n0123456789\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.9.5 The rewind function (p: 338)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.9.5 The rewind function (p: 304)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.9.5 The rewind function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/rewind](https://en.cppreference.com/w/c/io/rewind)"
- name: rint
  summary: If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned
  description: "# rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the current rounding mode.\n\n5-7, 9-11) Rounds the floating-point argument `arg` to an integer value in integer format, using the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `rintl`, `lrintl`, `llrintl` is called. Otherwise, if `arg` has integer type or the type `double`, `rint`, `lrint`, `llrint` is called. Otherwise, `rintf`, `lrintf`, `llrintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lrint` or `llrint` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `rint` function:\n\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lrint` and `llrint` functions:\n\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lrint.html) that all cases where `lrint` or `llrint` raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nAs specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\"), [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be on non-IEEE floating-point platforms) raised by `rint` when rounding a non-integer finite value.\n\nThe only difference between `rint` and [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") is that [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `rint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is...\n\n- [`FE_DOWNWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`floor`](floor \"c/numeric/math/floor\").\n- [`FE_UPWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`ceil`](ceil \"c/numeric/math/ceil\").\n- [`FE_TOWARDZERO`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`trunc`](trunc \"c/numeric/math/trunc\")\n- [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` differs from [`round`](round \"c/numeric/math/round\") in that halfway cases are rounded to even rather than away from zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest (halfway cases to even):\\n\"\n           \"rint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nrint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n    printf(\"rounding down with lrint: \\nlrint(+2.3) = %ld  \", lrint(2.3));\n    printf(\"lrint(+2.5) = %ld  \", lrint(2.5));\n    printf(\"lrint(+3.5) = %ld\\n\", lrint(3.5));\n    printf(\"lrint(-2.3) = %ld  \", lrint(-2.3));\n    printf(\"lrint(-2.5) = %ld  \", lrint(-2.5));\n    printf(\"lrint(-3.5) = %ld\\n\", lrint(-3.5));\n \n    printf(\"lrint(-0.0) = %ld\\n\", lrint(-0.0));\n    printf(\"lrint(-Inf) = %ld\\n\", lrint(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"rint(1.1) = %.1f\\n\", rint(1.1));\n    if(fetestexcept(FE_INEXACT)) puts(\"    FE_INEXACT was raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lrint(LONG_MIN-2048.0) = %ld\\n\", lrint(LONG_MIN-2048.0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nrounding to nearest (halfway cases to even):\nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +4.0\nrint(-2.3) = -2.0  rint(-2.5) = -2.0  rint(-3.5) = -4.0\nrounding down: \nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +3.0\nrint(-2.3) = -3.0  rint(-2.5) = -3.0  rint(-3.5) = -4.0\nrounding down with lrint: \nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nrint(1.1) = 1.0\n    FE_INEXACT was raised\nlrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.4 The rint functions (p: 184)\n  - 7.12.9.5 The lrint and llrint functions (p: 184)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.4 The rint functions (p: 384)\n  - F.10.6.5 The lrint and llrint functions (p: 384)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.4 The rint functions (p: 252)\n  - 7.12.9.5 The lrint and llrint functions (p: 252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.4 The rint functions (p: 527)\n  - F.10.6.5 The lrint and llrint functions (p: 527)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.4 The rint functions (p: 232-233)\n  - 7.12.9.5 The lrint and llrint functions (p: 233)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.4 The rint functions (p: 463)\n  - F.9.6.5 The lrint and llrint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/rint](https://en.cppreference.com/w/c/numeric/math/rint)"
- name: rintf
  summary: If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned
  description: "# rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the current rounding mode.\n\n5-7, 9-11) Rounds the floating-point argument `arg` to an integer value in integer format, using the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `rintl`, `lrintl`, `llrintl` is called. Otherwise, if `arg` has integer type or the type `double`, `rint`, `lrint`, `llrint` is called. Otherwise, `rintf`, `lrintf`, `llrintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lrint` or `llrint` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `rint` function:\n\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lrint` and `llrint` functions:\n\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lrint.html) that all cases where `lrint` or `llrint` raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nAs specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\"), [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be on non-IEEE floating-point platforms) raised by `rint` when rounding a non-integer finite value.\n\nThe only difference between `rint` and [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") is that [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `rint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is...\n\n- [`FE_DOWNWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`floor`](floor \"c/numeric/math/floor\").\n- [`FE_UPWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`ceil`](ceil \"c/numeric/math/ceil\").\n- [`FE_TOWARDZERO`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`trunc`](trunc \"c/numeric/math/trunc\")\n- [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` differs from [`round`](round \"c/numeric/math/round\") in that halfway cases are rounded to even rather than away from zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest (halfway cases to even):\\n\"\n           \"rint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nrint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n    printf(\"rounding down with lrint: \\nlrint(+2.3) = %ld  \", lrint(2.3));\n    printf(\"lrint(+2.5) = %ld  \", lrint(2.5));\n    printf(\"lrint(+3.5) = %ld\\n\", lrint(3.5));\n    printf(\"lrint(-2.3) = %ld  \", lrint(-2.3));\n    printf(\"lrint(-2.5) = %ld  \", lrint(-2.5));\n    printf(\"lrint(-3.5) = %ld\\n\", lrint(-3.5));\n \n    printf(\"lrint(-0.0) = %ld\\n\", lrint(-0.0));\n    printf(\"lrint(-Inf) = %ld\\n\", lrint(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"rint(1.1) = %.1f\\n\", rint(1.1));\n    if(fetestexcept(FE_INEXACT)) puts(\"    FE_INEXACT was raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lrint(LONG_MIN-2048.0) = %ld\\n\", lrint(LONG_MIN-2048.0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nrounding to nearest (halfway cases to even):\nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +4.0\nrint(-2.3) = -2.0  rint(-2.5) = -2.0  rint(-3.5) = -4.0\nrounding down: \nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +3.0\nrint(-2.3) = -3.0  rint(-2.5) = -3.0  rint(-3.5) = -4.0\nrounding down with lrint: \nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nrint(1.1) = 1.0\n    FE_INEXACT was raised\nlrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.4 The rint functions (p: 184)\n  - 7.12.9.5 The lrint and llrint functions (p: 184)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.4 The rint functions (p: 384)\n  - F.10.6.5 The lrint and llrint functions (p: 384)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.4 The rint functions (p: 252)\n  - 7.12.9.5 The lrint and llrint functions (p: 252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.4 The rint functions (p: 527)\n  - F.10.6.5 The lrint and llrint functions (p: 527)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.4 The rint functions (p: 232-233)\n  - 7.12.9.5 The lrint and llrint functions (p: 233)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.4 The rint functions (p: 463)\n  - F.9.6.5 The lrint and llrint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/rint](https://en.cppreference.com/w/c/numeric/math/rint)"
- name: rintl
  summary: If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned
  description: "# rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl\n\n[TABLE]\n\n1-3) Rounds the floating-point argument `arg` to an integer value in floating-point format, using the current rounding mode.\n\n5-7, 9-11) Rounds the floating-point argument `arg` to an integer value in integer format, using the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `rintl`, `lrintl`, `llrintl` is called. Otherwise, if `arg` has integer type or the type `double`, `rint`, `lrint`, `llrint` is called. Otherwise, `rintf`, `lrintf`, `llrintf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, according to the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\"), is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lrint` or `llrint` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `rint` function:\n\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lrint` and `llrint` functions:\n\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lrint.html) that all cases where `lrint` or `llrint` raise [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nAs specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\"), [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be on non-IEEE floating-point platforms) raised by `rint` when rounding a non-integer finite value.\n\nThe only difference between `rint` and [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") is that [`nearbyint`](nearbyint \"c/numeric/math/nearbyint\") never raises [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\").\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `rint` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nIf the current rounding mode is...\n\n- [`FE_DOWNWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`floor`](floor \"c/numeric/math/floor\").\n- [`FE_UPWARD`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`ceil`](ceil \"c/numeric/math/ceil\").\n- [`FE_TOWARDZERO`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` is equivalent to [`trunc`](trunc \"c/numeric/math/trunc\")\n- [`FE_TONEAREST`](../fenv/fe_round \"c/numeric/fenv/FE round\"), then `rint` differs from [`round`](round \"c/numeric/math/round\") in that halfway cases are rounded to even rather than away from zero.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \nint main(void)\n{\n#pragma STDC FENV_ACCESS ON\n    fesetround(FE_TONEAREST);\n    printf(\"rounding to nearest (halfway cases to even):\\n\"\n           \"rint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n \n    fesetround(FE_DOWNWARD);\n    printf(\"rounding down: \\nrint(+2.3) = %+.1f  \", rint(2.3));\n    printf(\"rint(+2.5) = %+.1f  \", rint(2.5));\n    printf(\"rint(+3.5) = %+.1f\\n\", rint(3.5));\n    printf(\"rint(-2.3) = %+.1f  \", rint(-2.3));\n    printf(\"rint(-2.5) = %+.1f  \", rint(-2.5));\n    printf(\"rint(-3.5) = %+.1f\\n\", rint(-3.5));\n    printf(\"rounding down with lrint: \\nlrint(+2.3) = %ld  \", lrint(2.3));\n    printf(\"lrint(+2.5) = %ld  \", lrint(2.5));\n    printf(\"lrint(+3.5) = %ld\\n\", lrint(3.5));\n    printf(\"lrint(-2.3) = %ld  \", lrint(-2.3));\n    printf(\"lrint(-2.5) = %ld  \", lrint(-2.5));\n    printf(\"lrint(-3.5) = %ld\\n\", lrint(-3.5));\n \n    printf(\"lrint(-0.0) = %ld\\n\", lrint(-0.0));\n    printf(\"lrint(-Inf) = %ld\\n\", lrint(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"rint(1.1) = %.1f\\n\", rint(1.1));\n    if(fetestexcept(FE_INEXACT)) puts(\"    FE_INEXACT was raised\");\n \n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lrint(LONG_MIN-2048.0) = %ld\\n\", lrint(LONG_MIN-2048.0));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nrounding to nearest (halfway cases to even):\nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +4.0\nrint(-2.3) = -2.0  rint(-2.5) = -2.0  rint(-3.5) = -4.0\nrounding down: \nrint(+2.3) = +2.0  rint(+2.5) = +2.0  rint(+3.5) = +3.0\nrint(-2.3) = -3.0  rint(-2.5) = -3.0  rint(-3.5) = -4.0\nrounding down with lrint: \nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nrint(1.1) = 1.0\n    FE_INEXACT was raised\nlrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.4 The rint functions (p: 184)\n  - 7.12.9.5 The lrint and llrint functions (p: 184)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.4 The rint functions (p: 384)\n  - F.10.6.5 The lrint and llrint functions (p: 384)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.4 The rint functions (p: 252)\n  - 7.12.9.5 The lrint and llrint functions (p: 252)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.4 The rint functions (p: 527)\n  - F.10.6.5 The lrint and llrint functions (p: 527)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.4 The rint functions (p: 232-233)\n  - 7.12.9.5 The lrint and llrint functions (p: 233)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.4 The rint functions (p: 463)\n  - F.9.6.5 The lrint and llrint functions (p: 463)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/rint](https://en.cppreference.com/w/c/numeric/math/rint)"
- name: round
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned
  description: "# round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n5-7, 9-11) Computes the nearest integer value to `arg` (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `roundl`, `lroundl`, `llroundl` is called. Otherwise, if `arg` has integer type or the type `double`, `round`, `lround`, `llround` is called. Otherwise, `roundf`, `lroundf`, `llroundf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases away from zero, is returned.\n\nReturn value\n\nArgument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lround` or `llround` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `round`, `roundf`, and `roundl` function:\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lround` and `llround` families of functions:\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised by `round` when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `round` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lround.html) that all cases where `lround` or `llround` raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nThe `double` version of `round` behaves as if implemented as follows:\n\n```\n#include <math.h>\ndouble round(double x)\n{\n    return signbit(x) ? ceil(x - 0.5) : floor(x + 0.5);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // round\n    printf(\"round(+2.3) = %+.1f  \", round(2.3));\n    printf(\"round(+2.5) = %+.1f  \", round(2.5));\n    printf(\"round(+2.7) = %+.1f\\n\", round(2.7));\n    printf(\"round(-2.3) = %+.1f  \", round(-2.3));\n    printf(\"round(-2.5) = %+.1f  \", round(-2.5));\n    printf(\"round(-2.7) = %+.1f\\n\", round(-2.7));\n \n    printf(\"round(-0.0) = %+.1f\\n\", round(-0.0));\n    printf(\"round(-Inf) = %+f\\n\",   round(-INFINITY));\n \n    // lround\n    printf(\"lround(+2.3) = %ld  \", lround(2.3));\n    printf(\"lround(+2.5) = %ld  \", lround(2.5));\n    printf(\"lround(+2.7) = %ld\\n\", lround(2.7));\n    printf(\"lround(-2.3) = %ld  \", lround(-2.3));\n    printf(\"lround(-2.5) = %ld  \", lround(-2.5));\n    printf(\"lround(-2.7) = %ld\\n\", lround(-2.7));\n \n    printf(\"lround(-0.0) = %ld\\n\", lround(-0.0));\n    printf(\"lround(-Inf) = %ld\\n\", lround(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lround(LONG_MAX+1.5) = %ld\\n\", lround(LONG_MAX+1.5));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nround(+2.3) = +2.0  round(+2.5) = +3.0  round(+2.7) = +3.0\nround(-2.3) = -2.0  round(-2.5) = -3.0  round(-2.7) = -3.0\nround(-0.0) = -0.0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nlround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.6 The round functions (p: 184)\n  - 7.12.9.7 The lround and llround functions (p: 184-185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.6 The round functions (p: 384)\n  - F.10.6.7 The lround and llround functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.6 The round functions (p: 253)\n  - 7.12.9.7 The lround and llround functions (p: 253)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.6 The round functions (p: 527)\n  - F.10.6.7 The lround and llround functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.6 The round functions (p: 233)\n  - 7.12.9.7 The lround and llround functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.6 The round functions (p: 464)\n  - F.9.6.7 The lround and llround functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/round](https://en.cppreference.com/w/c/numeric/math/round)"
- name: roundeven
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases to nearest even integer, is returned
  description: "# roundeven, roundevenf, roundevenl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases to nearest even integer, regardless of the current rounding mode.\n\n4) Type-generic macro: If `arg` has type `long double`, `roundevenl` is called. Otherwise, if `arg` has integer type or the type `double`, `roundeven` is called. Otherwise, `roundevenf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases to nearest even integer, is returned.\n\n### Error handling\n\nThis function is not subject to any of the errors specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"roundeven(+2.4) = %+.1f\\n\", roundeven(2.4));\n    printf(\"roundeven(-2.4) = %+.1f\\n\", roundeven(-2.4));\n    printf(\"roundeven(+2.5) = %+.1f\\n\", roundeven(2.5));\n    printf(\"roundeven(-2.5) = %+.1f\\n\", roundeven(-2.5));\n    printf(\"roundeven(+2.6) = %+.1f\\n\", roundeven(2.6));\n    printf(\"roundeven(-2.6) = %+.1f\\n\", roundeven(-2.6));\n    printf(\"roundeven(+3.5) = %+.1f\\n\", roundeven(3.5));\n    printf(\"roundeven(-3.5) = %+.1f\\n\", roundeven(-3.5));\n    printf(\"roundeven(-0.0) = %+.1f\\n\", roundeven(-0.0));\n    printf(\"roundeven(-Inf) = %+f\\n\",   roundeven(-INFINITY));\n}\n```\n\nPossible output:\n\n```\nroundeven(+2.4) = +2.0\nroundeven(-2.4) = -2.0\nroundeven(+2.5) = +2.0\nroundeven(-2.5) = -2.0\nroundeven(+2.6) = +3.0\nroundeven(-2.6) = -3.0\nroundeven(+3.5) = +4.0\nroundeven(-3.5) = -4.0\nroundeven(-0.0) = -0.0\nroundeven(-Inf) = -inf\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.9.8 The roundeven functions (p: 265-266)\n  - 7.27 Type-generic math \\<tgmath.h\\> (p: 386-390)\n  - F.10.6.8 The roundeven functions (p: 532)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/roundeven](https://en.cppreference.com/w/c/numeric/math/roundeven)"
- name: roundevenf
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases to nearest even integer, is returned
  description: "# roundeven, roundevenf, roundevenl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases to nearest even integer, regardless of the current rounding mode.\n\n4) Type-generic macro: If `arg` has type `long double`, `roundevenl` is called. Otherwise, if `arg` has integer type or the type `double`, `roundeven` is called. Otherwise, `roundevenf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases to nearest even integer, is returned.\n\n### Error handling\n\nThis function is not subject to any of the errors specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"roundeven(+2.4) = %+.1f\\n\", roundeven(2.4));\n    printf(\"roundeven(-2.4) = %+.1f\\n\", roundeven(-2.4));\n    printf(\"roundeven(+2.5) = %+.1f\\n\", roundeven(2.5));\n    printf(\"roundeven(-2.5) = %+.1f\\n\", roundeven(-2.5));\n    printf(\"roundeven(+2.6) = %+.1f\\n\", roundeven(2.6));\n    printf(\"roundeven(-2.6) = %+.1f\\n\", roundeven(-2.6));\n    printf(\"roundeven(+3.5) = %+.1f\\n\", roundeven(3.5));\n    printf(\"roundeven(-3.5) = %+.1f\\n\", roundeven(-3.5));\n    printf(\"roundeven(-0.0) = %+.1f\\n\", roundeven(-0.0));\n    printf(\"roundeven(-Inf) = %+f\\n\",   roundeven(-INFINITY));\n}\n```\n\nPossible output:\n\n```\nroundeven(+2.4) = +2.0\nroundeven(-2.4) = -2.0\nroundeven(+2.5) = +2.0\nroundeven(-2.5) = -2.0\nroundeven(+2.6) = +3.0\nroundeven(-2.6) = -3.0\nroundeven(+3.5) = +4.0\nroundeven(-3.5) = -4.0\nroundeven(-0.0) = -0.0\nroundeven(-Inf) = -inf\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.9.8 The roundeven functions (p: 265-266)\n  - 7.27 Type-generic math \\<tgmath.h\\> (p: 386-390)\n  - F.10.6.8 The roundeven functions (p: 532)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/roundeven](https://en.cppreference.com/w/c/numeric/math/roundeven)"
- name: roundevenl
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases to nearest even integer, is returned
  description: "# roundeven, roundevenf, roundevenl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases to nearest even integer, regardless of the current rounding mode.\n\n4) Type-generic macro: If `arg` has type `long double`, `roundevenl` is called. Otherwise, if `arg` has integer type or the type `double`, `roundeven` is called. Otherwise, `roundevenf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases to nearest even integer, is returned.\n\n### Error handling\n\nThis function is not subject to any of the errors specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"roundeven(+2.4) = %+.1f\\n\", roundeven(2.4));\n    printf(\"roundeven(-2.4) = %+.1f\\n\", roundeven(-2.4));\n    printf(\"roundeven(+2.5) = %+.1f\\n\", roundeven(2.5));\n    printf(\"roundeven(-2.5) = %+.1f\\n\", roundeven(-2.5));\n    printf(\"roundeven(+2.6) = %+.1f\\n\", roundeven(2.6));\n    printf(\"roundeven(-2.6) = %+.1f\\n\", roundeven(-2.6));\n    printf(\"roundeven(+3.5) = %+.1f\\n\", roundeven(3.5));\n    printf(\"roundeven(-3.5) = %+.1f\\n\", roundeven(-3.5));\n    printf(\"roundeven(-0.0) = %+.1f\\n\", roundeven(-0.0));\n    printf(\"roundeven(-Inf) = %+f\\n\",   roundeven(-INFINITY));\n}\n```\n\nPossible output:\n\n```\nroundeven(+2.4) = +2.0\nroundeven(-2.4) = -2.0\nroundeven(+2.5) = +2.0\nroundeven(-2.5) = -2.0\nroundeven(+2.6) = +3.0\nroundeven(-2.6) = -3.0\nroundeven(+3.5) = +4.0\nroundeven(-3.5) = -4.0\nroundeven(-0.0) = -0.0\nroundeven(-Inf) = -inf\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.9.8 The roundeven functions (p: 265-266)\n  - 7.27 Type-generic math \\<tgmath.h\\> (p: 386-390)\n  - F.10.6.8 The roundeven functions (p: 532)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/roundeven](https://en.cppreference.com/w/c/numeric/math/roundeven)"
- name: roundf
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned
  description: "# round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n5-7, 9-11) Computes the nearest integer value to `arg` (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `roundl`, `lroundl`, `llroundl` is called. Otherwise, if `arg` has integer type or the type `double`, `round`, `lround`, `llround` is called. Otherwise, `roundf`, `lroundf`, `llroundf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases away from zero, is returned.\n\nReturn value\n\nArgument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lround` or `llround` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `round`, `roundf`, and `roundl` function:\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lround` and `llround` families of functions:\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised by `round` when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `round` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lround.html) that all cases where `lround` or `llround` raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nThe `double` version of `round` behaves as if implemented as follows:\n\n```\n#include <math.h>\ndouble round(double x)\n{\n    return signbit(x) ? ceil(x - 0.5) : floor(x + 0.5);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // round\n    printf(\"round(+2.3) = %+.1f  \", round(2.3));\n    printf(\"round(+2.5) = %+.1f  \", round(2.5));\n    printf(\"round(+2.7) = %+.1f\\n\", round(2.7));\n    printf(\"round(-2.3) = %+.1f  \", round(-2.3));\n    printf(\"round(-2.5) = %+.1f  \", round(-2.5));\n    printf(\"round(-2.7) = %+.1f\\n\", round(-2.7));\n \n    printf(\"round(-0.0) = %+.1f\\n\", round(-0.0));\n    printf(\"round(-Inf) = %+f\\n\",   round(-INFINITY));\n \n    // lround\n    printf(\"lround(+2.3) = %ld  \", lround(2.3));\n    printf(\"lround(+2.5) = %ld  \", lround(2.5));\n    printf(\"lround(+2.7) = %ld\\n\", lround(2.7));\n    printf(\"lround(-2.3) = %ld  \", lround(-2.3));\n    printf(\"lround(-2.5) = %ld  \", lround(-2.5));\n    printf(\"lround(-2.7) = %ld\\n\", lround(-2.7));\n \n    printf(\"lround(-0.0) = %ld\\n\", lround(-0.0));\n    printf(\"lround(-Inf) = %ld\\n\", lround(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lround(LONG_MAX+1.5) = %ld\\n\", lround(LONG_MAX+1.5));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nround(+2.3) = +2.0  round(+2.5) = +3.0  round(+2.7) = +3.0\nround(-2.3) = -2.0  round(-2.5) = -3.0  round(-2.7) = -3.0\nround(-0.0) = -0.0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nlround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.6 The round functions (p: 184)\n  - 7.12.9.7 The lround and llround functions (p: 184-185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.6 The round functions (p: 384)\n  - F.10.6.7 The lround and llround functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.6 The round functions (p: 253)\n  - 7.12.9.7 The lround and llround functions (p: 253)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.6 The round functions (p: 527)\n  - F.10.6.7 The lround and llround functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.6 The round functions (p: 233)\n  - 7.12.9.7 The lround and llround functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.6 The round functions (p: 464)\n  - F.9.6.7 The lround and llround functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/round](https://en.cppreference.com/w/c/numeric/math/round)"
- name: roundl
  summary: If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned
  description: "# round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl\n\n[TABLE]\n\n1-3) Computes the nearest integer value to `arg` (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n5-7, 9-11) Computes the nearest integer value to `arg` (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.\n\n4,8,12) Type-generic macros: If `arg` has type `long double`, `roundl`, `lroundl`, `llroundl` is called. Otherwise, if `arg` has integer type or the type `double`, `round`, `lround`, `llround` is called. Otherwise, `roundf`, `lroundf`, `llroundf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value to `arg`, rounding halfway cases away from zero, is returned.\n\nReturn value\n\nArgument\n\nIf a domain error occurs, an implementation-defined value is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the result of `lround` or `llround` is outside the range representable by the return type, a domain error or a range error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559), For the `round`, `roundf`, and `roundl` function:\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If `arg` is NaN, NaN is returned\n\nFor `lround` and `llround` families of functions:\n\n- [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If the result of the rounding is outside the range of the return type, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n- If `arg` is NaN, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and an implementation-defined value is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised by `round` when rounding a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so `round` never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lround.html) that all cases where `lround` or `llround` raise [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") are domain errors.\n\nThe `double` version of `round` behaves as if implemented as follows:\n\n```\n#include <math.h>\ndouble round(double x)\n{\n    return signbit(x) ? ceil(x - 0.5) : floor(x + 0.5);\n}\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <fenv.h>\n#include <limits.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // round\n    printf(\"round(+2.3) = %+.1f  \", round(2.3));\n    printf(\"round(+2.5) = %+.1f  \", round(2.5));\n    printf(\"round(+2.7) = %+.1f\\n\", round(2.7));\n    printf(\"round(-2.3) = %+.1f  \", round(-2.3));\n    printf(\"round(-2.5) = %+.1f  \", round(-2.5));\n    printf(\"round(-2.7) = %+.1f\\n\", round(-2.7));\n \n    printf(\"round(-0.0) = %+.1f\\n\", round(-0.0));\n    printf(\"round(-Inf) = %+f\\n\",   round(-INFINITY));\n \n    // lround\n    printf(\"lround(+2.3) = %ld  \", lround(2.3));\n    printf(\"lround(+2.5) = %ld  \", lround(2.5));\n    printf(\"lround(+2.7) = %ld\\n\", lround(2.7));\n    printf(\"lround(-2.3) = %ld  \", lround(-2.3));\n    printf(\"lround(-2.5) = %ld  \", lround(-2.5));\n    printf(\"lround(-2.7) = %ld\\n\", lround(-2.7));\n \n    printf(\"lround(-0.0) = %ld\\n\", lround(-0.0));\n    printf(\"lround(-Inf) = %ld\\n\", lround(-INFINITY)); // FE_INVALID raised\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"lround(LONG_MAX+1.5) = %ld\\n\", lround(LONG_MAX+1.5));\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nround(+2.3) = +2.0  round(+2.5) = +3.0  round(+2.7) = +3.0\nround(-2.3) = -2.0  round(-2.5) = -3.0  round(-2.7) = -3.0\nround(-0.0) = -0.0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nlround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.9.6 The round functions (p: 184)\n  - 7.12.9.7 The lround and llround functions (p: 184-185)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.6.6 The round functions (p: 384)\n  - F.10.6.7 The lround and llround functions (p: 385)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.6 The round functions (p: 253)\n  - 7.12.9.7 The lround and llround functions (p: 253)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.6 The round functions (p: 527)\n  - F.10.6.7 The lround and llround functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.6 The round functions (p: 233)\n  - 7.12.9.7 The lround and llround functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.6 The round functions (p: 464)\n  - F.9.6.7 The lround and llround functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/round](https://en.cppreference.com/w/c/numeric/math/round)"
- name: Scalar initialization
  summary: When initializing an object of scalar type, the initializer must be a single expression
  description: "# Scalar initialization\n\nWhen [initializing](initialization \"c/language/initialization\") an object of [scalar type](type#Type_groups \"c/language/type\"), the initializer must be a single expression\n\nThe initializer for a scalar (an object of integer type including booleans and enumerated types, floating type including complex and imaginary, and pointer type including pointer to function) must be a single expression, optionally enclosed in braces, or an empty initializer(since C23):\n\n|                        |       |             |\n|------------------------|-------|-------------|\n| `=` expression         | \\(1\\) |             |\n| `=` `{` expression `}` | \\(2\\) |             |\n| `=` `{` `}`            | \\(3\\) | (since C23) |\n\n1,2) The expression is evaluated, and its value, after [conversion as if by assignment](conversion \"c/language/conversion\") to the type of the object, becomes the initial value of the object being initialized.\n\n3) The object is [empty-initialized](initialization#Empty_initialization \"c/language/initialization\"), i.e. initialized to numeric zero for an object of an arithmetic or enumeration type, or null pointer value for an object of a pointer type.\n\n### Notes\n\nBecause of the rules that apply to conversions as if by assignment, [`const`](const \"c/language/const\") and [`volatile`](volatile \"c/language/volatile\") qualifiers on the declared type are ignored when determining which type to convert the expression to.\n\nSee [initialization](initialization \"c/language/initialization\") for the rules that apply when no initializer is used.\n\nAs with all other initializations, expression must be a [constant expression](constant_expression \"c/language/constant expression\") when initializing objects of static or thread-local [storage duration](storage_duration \"c/language/storage duration\").\n\nThe expression cannot be a [comma operator](operator_other#Comma_operator \"c/language/operator other\") (unless parenthesized) because the comma at the top level would be interpreted as the beginning of the next declarator.\n\nWhen initializing objects of floating-point type, all computations for the objects with automatic [storage duration](storage_duration \"c/language/storage duration\") are done as-if at execution time and are affected by the [current rounding](../numeric/fenv/fe_round \"c/numeric/fenv/FE round\"); floating-point errors are reported as specified in [`math_errhandling`](../numeric/math/math_errhandling \"c/numeric/math/math errhandling\"). For objects of static and thread-local storage duration, computations are done as-if at compile time, and no exceptions are raised:\n\n```\nvoid f(void)\n{\n#pragma STDC FENV_ACCESS ON\n    static float v = 1.1e75; // does not raise exceptions: static init\n \n    float u[] = { 1.1e75 }; // raises FE_INEXACT\n    float w = 1.1e75;       // raises FE_INEXACT\n \n    double x = 1.1e75; // may raise FE_INEXACT (depends on FLT_EVAL_METHOD)\n    float y = 1.1e75f; // may raise FE_INEXACT (depends on FLT_EVAL_METHOD)\n \n    long double z = 1.1e75; // does not raise exceptions (conversion is exact)\n}\n```\n\n### Example\n\n```\n#include <stdbool.h>\nint main(void)\n{\n    bool b = true;\n    const double d = 3.14;\n    int k = 3.15; // conversion from double to int\n    int n = {12}, // optional braces\n       *p = &n,   // non-constant expression OK for automatic variable\n       (*fp)(void) = main;\n    enum {RED, BLUE} e = RED; // enumerations are scalar types as well\n}\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.9/11 Initialization (p: 101)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.9/11 Initialization (p: 140)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.8/11 Initialization (p: 126)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 6.5.7 Initialization\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/scalar_initialization](https://en.cppreference.com/w/c/language/scalar_initialization)"
- name: scalbln
  summary: If no errors occur, arg multiplied by FLT_RADIX to the power of exp (arg×FLT_RADIXexp) is returned
  description: "# scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl\n\n[TABLE]\n\n1-3,5-7) Multiplies a floating point value `arg` by [`FLT_RADIX`](../../types/limits \"c/types/limits\") raised to power [`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n\n4,8) Type-generic macros: If `arg` has type `long double`, `scalbnl` or `scalblnl` is called. Otherwise, if `arg` has integer type or the type `double`, `scalbn` or `scalbln` is called. Otherwise, `scalbnf` or `scalblnf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n| exp | \\-  | integer value        |\n\n### Return value\n\nIf no errors occur, `arg` multiplied by [`FLT_RADIX`](../../types/limits \"c/types/limits\") to the power of [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) (arg×FLT_RADIX^(exp)) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- Unless a range error occurs, [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised (the result is exact).\n- Unless a range error occurs, the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored.\n- If `arg` is ±0, it is returned, unmodified.\n- If `arg` is ±∞, it is returned, unmodified.\n- If [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) is 0, then `arg` is returned, unmodified.\n- If `arg` is NaN, NaN is returned.\n\n### Notes\n\nOn binary systems (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `scalbn` is equivalent to [`ldexp`](ldexp \"c/numeric/math/ldexp\").\n\nAlthough `scalbn` and `scalbln` are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.\n\nThe `scalbln` function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than `32767`, the standard-guaranteed [`INT_MAX`](../../types/limits \"c/types/limits\"). In particular, for the 80-bit `long double`, the factor is `32828`.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"scalbn(7, -4) = %f\\n\", scalbn(7, -4));\n    printf(\"scalbn(1, -1074) = %g (minimum positive subnormal double)\\n\",\n            scalbn(1, -1074));\n    printf(\"scalbn(nextafter(1,0), 1024) = %g (largest finite double)\\n\",\n            scalbn(nextafter(1,0), 1024));\n \n    // special values\n    printf(\"scalbn(-0, 10) = %f\\n\", scalbn(-0.0, 10));\n    printf(\"scalbn(-Inf, -1) = %f\\n\", scalbn(-INFINITY, -1));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"scalbn(1, 1024) = %f\\n\", scalbn(1, 1024));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_OVERFLOW))\n        puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nscalbn(7, -4) = 0.437500\nscalbn(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nscalbn(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nscalbn(-0, 10) = -0.000000\nscalbn(-Inf, -1) = -inf\nscalbn(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.13 The scalbn functions (p: 247)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.13 The scalbn functions (p: 523)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.13 The scalbn functions (p: 228)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.13 The scalbn functions (p: 460)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/scalbn](https://en.cppreference.com/w/c/numeric/math/scalbn)"
- name: scalblnf
  summary: If no errors occur, arg multiplied by FLT_RADIX to the power of exp (arg×FLT_RADIXexp) is returned
  description: "# scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl\n\n[TABLE]\n\n1-3,5-7) Multiplies a floating point value `arg` by [`FLT_RADIX`](../../types/limits \"c/types/limits\") raised to power [`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n\n4,8) Type-generic macros: If `arg` has type `long double`, `scalbnl` or `scalblnl` is called. Otherwise, if `arg` has integer type or the type `double`, `scalbn` or `scalbln` is called. Otherwise, `scalbnf` or `scalblnf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n| exp | \\-  | integer value        |\n\n### Return value\n\nIf no errors occur, `arg` multiplied by [`FLT_RADIX`](../../types/limits \"c/types/limits\") to the power of [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) (arg×FLT_RADIX^(exp)) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- Unless a range error occurs, [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised (the result is exact).\n- Unless a range error occurs, the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored.\n- If `arg` is ±0, it is returned, unmodified.\n- If `arg` is ±∞, it is returned, unmodified.\n- If [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) is 0, then `arg` is returned, unmodified.\n- If `arg` is NaN, NaN is returned.\n\n### Notes\n\nOn binary systems (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `scalbn` is equivalent to [`ldexp`](ldexp \"c/numeric/math/ldexp\").\n\nAlthough `scalbn` and `scalbln` are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.\n\nThe `scalbln` function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than `32767`, the standard-guaranteed [`INT_MAX`](../../types/limits \"c/types/limits\"). In particular, for the 80-bit `long double`, the factor is `32828`.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"scalbn(7, -4) = %f\\n\", scalbn(7, -4));\n    printf(\"scalbn(1, -1074) = %g (minimum positive subnormal double)\\n\",\n            scalbn(1, -1074));\n    printf(\"scalbn(nextafter(1,0), 1024) = %g (largest finite double)\\n\",\n            scalbn(nextafter(1,0), 1024));\n \n    // special values\n    printf(\"scalbn(-0, 10) = %f\\n\", scalbn(-0.0, 10));\n    printf(\"scalbn(-Inf, -1) = %f\\n\", scalbn(-INFINITY, -1));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"scalbn(1, 1024) = %f\\n\", scalbn(1, 1024));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_OVERFLOW))\n        puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nscalbn(7, -4) = 0.437500\nscalbn(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nscalbn(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nscalbn(-0, 10) = -0.000000\nscalbn(-Inf, -1) = -inf\nscalbn(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.13 The scalbn functions (p: 247)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.13 The scalbn functions (p: 523)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.13 The scalbn functions (p: 228)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.13 The scalbn functions (p: 460)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/scalbn](https://en.cppreference.com/w/c/numeric/math/scalbn)"
- name: scalblnl
  summary: If no errors occur, arg multiplied by FLT_RADIX to the power of exp (arg×FLT_RADIXexp) is returned
  description: "# scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl\n\n[TABLE]\n\n1-3,5-7) Multiplies a floating point value `arg` by [`FLT_RADIX`](../../types/limits \"c/types/limits\") raised to power [`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n\n4,8) Type-generic macros: If `arg` has type `long double`, `scalbnl` or `scalblnl` is called. Otherwise, if `arg` has integer type or the type `double`, `scalbn` or `scalbln` is called. Otherwise, `scalbnf` or `scalblnf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n| exp | \\-  | integer value        |\n\n### Return value\n\nIf no errors occur, `arg` multiplied by [`FLT_RADIX`](../../types/limits \"c/types/limits\") to the power of [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) (arg×FLT_RADIX^(exp)) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- Unless a range error occurs, [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised (the result is exact).\n- Unless a range error occurs, the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored.\n- If `arg` is ±0, it is returned, unmodified.\n- If `arg` is ±∞, it is returned, unmodified.\n- If [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) is 0, then `arg` is returned, unmodified.\n- If `arg` is NaN, NaN is returned.\n\n### Notes\n\nOn binary systems (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `scalbn` is equivalent to [`ldexp`](ldexp \"c/numeric/math/ldexp\").\n\nAlthough `scalbn` and `scalbln` are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.\n\nThe `scalbln` function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than `32767`, the standard-guaranteed [`INT_MAX`](../../types/limits \"c/types/limits\"). In particular, for the 80-bit `long double`, the factor is `32828`.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"scalbn(7, -4) = %f\\n\", scalbn(7, -4));\n    printf(\"scalbn(1, -1074) = %g (minimum positive subnormal double)\\n\",\n            scalbn(1, -1074));\n    printf(\"scalbn(nextafter(1,0), 1024) = %g (largest finite double)\\n\",\n            scalbn(nextafter(1,0), 1024));\n \n    // special values\n    printf(\"scalbn(-0, 10) = %f\\n\", scalbn(-0.0, 10));\n    printf(\"scalbn(-Inf, -1) = %f\\n\", scalbn(-INFINITY, -1));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"scalbn(1, 1024) = %f\\n\", scalbn(1, 1024));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_OVERFLOW))\n        puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nscalbn(7, -4) = 0.437500\nscalbn(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nscalbn(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nscalbn(-0, 10) = -0.000000\nscalbn(-Inf, -1) = -inf\nscalbn(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.13 The scalbn functions (p: 247)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.13 The scalbn functions (p: 523)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.13 The scalbn functions (p: 228)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.13 The scalbn functions (p: 460)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/scalbn](https://en.cppreference.com/w/c/numeric/math/scalbn)"
- name: scalbn
  summary: If no errors occur, arg multiplied by FLT_RADIX to the power of exp (arg×FLT_RADIXexp) is returned
  description: "# scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl\n\n[TABLE]\n\n1-3,5-7) Multiplies a floating point value `arg` by [`FLT_RADIX`](../../types/limits \"c/types/limits\") raised to power [`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n\n4,8) Type-generic macros: If `arg` has type `long double`, `scalbnl` or `scalblnl` is called. Otherwise, if `arg` has integer type or the type `double`, `scalbn` or `scalbln` is called. Otherwise, `scalbnf` or `scalblnf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n| exp | \\-  | integer value        |\n\n### Return value\n\nIf no errors occur, `arg` multiplied by [`FLT_RADIX`](../../types/limits \"c/types/limits\") to the power of [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) (arg×FLT_RADIX^(exp)) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- Unless a range error occurs, [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised (the result is exact).\n- Unless a range error occurs, the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored.\n- If `arg` is ±0, it is returned, unmodified.\n- If `arg` is ±∞, it is returned, unmodified.\n- If [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) is 0, then `arg` is returned, unmodified.\n- If `arg` is NaN, NaN is returned.\n\n### Notes\n\nOn binary systems (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `scalbn` is equivalent to [`ldexp`](ldexp \"c/numeric/math/ldexp\").\n\nAlthough `scalbn` and `scalbln` are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.\n\nThe `scalbln` function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than `32767`, the standard-guaranteed [`INT_MAX`](../../types/limits \"c/types/limits\"). In particular, for the 80-bit `long double`, the factor is `32828`.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"scalbn(7, -4) = %f\\n\", scalbn(7, -4));\n    printf(\"scalbn(1, -1074) = %g (minimum positive subnormal double)\\n\",\n            scalbn(1, -1074));\n    printf(\"scalbn(nextafter(1,0), 1024) = %g (largest finite double)\\n\",\n            scalbn(nextafter(1,0), 1024));\n \n    // special values\n    printf(\"scalbn(-0, 10) = %f\\n\", scalbn(-0.0, 10));\n    printf(\"scalbn(-Inf, -1) = %f\\n\", scalbn(-INFINITY, -1));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"scalbn(1, 1024) = %f\\n\", scalbn(1, 1024));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_OVERFLOW))\n        puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nscalbn(7, -4) = 0.437500\nscalbn(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nscalbn(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nscalbn(-0, 10) = -0.000000\nscalbn(-Inf, -1) = -inf\nscalbn(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.13 The scalbn functions (p: 247)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.13 The scalbn functions (p: 523)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.13 The scalbn functions (p: 228)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.13 The scalbn functions (p: 460)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/scalbn](https://en.cppreference.com/w/c/numeric/math/scalbn)"
- name: scalbnf
  summary: If no errors occur, arg multiplied by FLT_RADIX to the power of exp (arg×FLT_RADIXexp) is returned
  description: "# scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl\n\n[TABLE]\n\n1-3,5-7) Multiplies a floating point value `arg` by [`FLT_RADIX`](../../types/limits \"c/types/limits\") raised to power [`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n\n4,8) Type-generic macros: If `arg` has type `long double`, `scalbnl` or `scalblnl` is called. Otherwise, if `arg` has integer type or the type `double`, `scalbn` or `scalbln` is called. Otherwise, `scalbnf` or `scalblnf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n| exp | \\-  | integer value        |\n\n### Return value\n\nIf no errors occur, `arg` multiplied by [`FLT_RADIX`](../../types/limits \"c/types/limits\") to the power of [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) (arg×FLT_RADIX^(exp)) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- Unless a range error occurs, [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised (the result is exact).\n- Unless a range error occurs, the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored.\n- If `arg` is ±0, it is returned, unmodified.\n- If `arg` is ±∞, it is returned, unmodified.\n- If [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) is 0, then `arg` is returned, unmodified.\n- If `arg` is NaN, NaN is returned.\n\n### Notes\n\nOn binary systems (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `scalbn` is equivalent to [`ldexp`](ldexp \"c/numeric/math/ldexp\").\n\nAlthough `scalbn` and `scalbln` are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.\n\nThe `scalbln` function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than `32767`, the standard-guaranteed [`INT_MAX`](../../types/limits \"c/types/limits\"). In particular, for the 80-bit `long double`, the factor is `32828`.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"scalbn(7, -4) = %f\\n\", scalbn(7, -4));\n    printf(\"scalbn(1, -1074) = %g (minimum positive subnormal double)\\n\",\n            scalbn(1, -1074));\n    printf(\"scalbn(nextafter(1,0), 1024) = %g (largest finite double)\\n\",\n            scalbn(nextafter(1,0), 1024));\n \n    // special values\n    printf(\"scalbn(-0, 10) = %f\\n\", scalbn(-0.0, 10));\n    printf(\"scalbn(-Inf, -1) = %f\\n\", scalbn(-INFINITY, -1));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"scalbn(1, 1024) = %f\\n\", scalbn(1, 1024));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_OVERFLOW))\n        puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nscalbn(7, -4) = 0.437500\nscalbn(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nscalbn(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nscalbn(-0, 10) = -0.000000\nscalbn(-Inf, -1) = -inf\nscalbn(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.13 The scalbn functions (p: 247)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.13 The scalbn functions (p: 523)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.13 The scalbn functions (p: 228)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.13 The scalbn functions (p: 460)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/scalbn](https://en.cppreference.com/w/c/numeric/math/scalbn)"
- name: scalbnl
  summary: If no errors occur, arg multiplied by FLT_RADIX to the power of exp (arg×FLT_RADIXexp) is returned
  description: "# scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl\n\n[TABLE]\n\n1-3,5-7) Multiplies a floating point value `arg` by [`FLT_RADIX`](../../types/limits \"c/types/limits\") raised to power [`exp`](http://en.cppreference.com/w/c/numeric/math/exp).\n\n4,8) Type-generic macros: If `arg` has type `long double`, `scalbnl` or `scalblnl` is called. Otherwise, if `arg` has integer type or the type `double`, `scalbn` or `scalbln` is called. Otherwise, `scalbnf` or `scalblnf` is called, respectively.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n| exp | \\-  | integer value        |\n\n### Return value\n\nIf no errors occur, `arg` multiplied by [`FLT_RADIX`](../../types/limits \"c/types/limits\") to the power of [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) (arg×FLT_RADIX^(exp)) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- Unless a range error occurs, [`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is never raised (the result is exact).\n- Unless a range error occurs, the [current rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") is ignored.\n- If `arg` is ±0, it is returned, unmodified.\n- If `arg` is ±∞, it is returned, unmodified.\n- If [`exp`](http://en.cppreference.com/w/c/numeric/math/exp) is 0, then `arg` is returned, unmodified.\n- If `arg` is NaN, NaN is returned.\n\n### Notes\n\nOn binary systems (where [`FLT_RADIX`](../../types/limits \"c/types/limits\") is `2`), `scalbn` is equivalent to [`ldexp`](ldexp \"c/numeric/math/ldexp\").\n\nAlthough `scalbn` and `scalbln` are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.\n\nThe `scalbln` function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than `32767`, the standard-guaranteed [`INT_MAX`](../../types/limits \"c/types/limits\"). In particular, for the 80-bit `long double`, the factor is `32828`.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"scalbn(7, -4) = %f\\n\", scalbn(7, -4));\n    printf(\"scalbn(1, -1074) = %g (minimum positive subnormal double)\\n\",\n            scalbn(1, -1074));\n    printf(\"scalbn(nextafter(1,0), 1024) = %g (largest finite double)\\n\",\n            scalbn(nextafter(1,0), 1024));\n \n    // special values\n    printf(\"scalbn(-0, 10) = %f\\n\", scalbn(-0.0, 10));\n    printf(\"scalbn(-Inf, -1) = %f\\n\", scalbn(-INFINITY, -1));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"scalbn(1, 1024) = %f\\n\", scalbn(1, 1024));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    if (fetestexcept(FE_OVERFLOW))\n        puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nscalbn(7, -4) = 0.437500\nscalbn(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nscalbn(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nscalbn(-0, 10) = -0.000000\nscalbn(-Inf, -1) = -inf\nscalbn(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.6.13 The scalbn functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.3.13 The scalbn functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.6.13 The scalbn functions (p: 247)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.3.13 The scalbn functions (p: 523)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.6.13 The scalbn functions (p: 228)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.3.13 The scalbn functions (p: 460)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/scalbn](https://en.cppreference.com/w/c/numeric/math/scalbn)"
- name: scanf
  summary: Reads data from a variety of sources, interprets it according to format and stores the results into given locations
  description: "# scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s\n\n[TABLE]\n\nReads data from a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) reads the data from file stream `stream`\n\n3) reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%c` into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `scanf_s` , `fscanf_s`, and `sscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                           |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or [`EOF`](../io \"c/io\") if input failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Complexity\n\nNot guaranteed. Notably, some implementations of `sscanf` are O(N), where `N ``=`` `[`strlen`](http://en.cppreference.com/w/c/string/byte/strlen)`(``buffer``)` [\\[1\\]](https://sourceware.org/bugzilla/show_bug.cgi?id=17577).\n\n### Notes\n\nBecause most conversion specifiers first consume all consecutive whitespace, code such as\n\n```\nscanf(\"%d\", &a);\nscanf(\"%d\", &b);\n```\n\nwill read two integers that are entered on different lines (second `%d` will consume the newline left over by the first) or on the same line, separated by spaces or tabs (second `%d` will consume the spaces or tabs). The conversion specifiers that do not consume leading whitespace, such as `%c`, can be made to do so by using a whitespace character in the format string:\n\n```\nscanf(\"%d\", &a);\nscanf(\" %c\", &c); // consume all consecutive whitespace after %d, then read a char\n```\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stddef.h>\n#include <locale.h>\n \nint main(void)\n{\n    int i, j;\n    float x, y;\n    char str1[10], str2[4];\n    wchar_t warr[2];\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    char input[] = \"25 54.32E-1 Thompson 56789 0123 56ß水\";\n    /* parse as follows:\n       %d: an integer\n       %f: a floating-point value\n       %9s: a string of at most 9 non-whitespace characters\n       %2d: two-digit integer (digits 5 and 6)\n       %f:  a floating-point value (digits 7, 8, 9)\n       %*d: an integer which isn't stored anywhere\n       ' ': all consecutive whitespace\n       %3[0-9]: a string of at most 3 decimal digits (digits 5 and 6)\n       %2lc: two wide characters, using multibyte to wide conversion  */\n    int ret = sscanf(input, \"%d%f%9s%2d%f%*d %3[0-9]%2lc\",\n                     &i, &x, str1, &j, &y, str2, warr);\n \n    printf(\"Converted %d fields:\\n\"\n           \"i = %d\\n\"\n           \"x = %f\\n\"\n           \"str1 = %s\\n\"\n           \"j = %d\\n\"\n           \"y = %f\\n\"\n           \"str2 = %s\\n\"\n           \"warr[0] = U+%x\\n\"\n           \"warr[1] = U+%x\\n\",\n           ret, i, x, str1, j, y, str2, warr[0], warr[1]);\n \n#ifdef __STDC_LIB_EXT1__\n    int n = sscanf_s(input, \"%d%f%s\", &i, &x, str1, (rsize_t)sizeof str1);\n    // writes 25 to i, 5.432 to x, the 9 bytes \"Thompson\\0\" to str1, and 3 to n.\n#endif\n}\n```\n\nPossible output:\n\n```\nConverted 7 fields:\ni = 25\nx = 5.432000\nstr1 = Thompson\nj = 56\ny = 789.000000\nstr2 = 56\nwarr[0] = U+df\nwarr[1] = U+6c34\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.2 The fscanf function (p: 231-236)\n  - 7.21.6.4 The scanf function (p: 236-237)\n  - 7.21.6.7 The sscanf function (p: 238-239)\n  - K.3.5.3.2 The fscanf_s function (p: 430-431)\n  - K.3.5.3.4 The scanf_s function (p: 432)\n  - K.3.5.3.7 The sscanf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.2 The fscanf function (p: 317-324)\n  - 7.21.6.4 The scanf function (p: 325)\n  - 7.21.6.7 The sscanf function (p: 326)\n  - K.3.5.3.2 The fscanf_s function (p: 592-593)\n  - K.3.5.3.4 The scanf_s function (p: 594)\n  - K.3.5.3.7 The sscanf_s function (p: 596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.2 The fscanf function (p: 282-289)\n  - 7.19.6.4 The scanf function (p: 290)\n  - 7.19.6.7 The sscanf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.2 The fscanf function\n  - 4.9.6.4 The scanf function\n  - 4.9.6.6 The sscanf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fscanf](https://en.cppreference.com/w/c/io/fscanf)"
- name: scanf_s
  summary: Reads data from a variety of sources, interprets it according to format and stores the results into given locations
  description: "# scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s\n\n[TABLE]\n\nReads data from a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) reads the data from file stream `stream`\n\n3) reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%c` into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `scanf_s` , `fscanf_s`, and `sscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                           |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or [`EOF`](../io \"c/io\") if input failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Complexity\n\nNot guaranteed. Notably, some implementations of `sscanf` are O(N), where `N ``=`` `[`strlen`](http://en.cppreference.com/w/c/string/byte/strlen)`(``buffer``)` [\\[1\\]](https://sourceware.org/bugzilla/show_bug.cgi?id=17577).\n\n### Notes\n\nBecause most conversion specifiers first consume all consecutive whitespace, code such as\n\n```\nscanf(\"%d\", &a);\nscanf(\"%d\", &b);\n```\n\nwill read two integers that are entered on different lines (second `%d` will consume the newline left over by the first) or on the same line, separated by spaces or tabs (second `%d` will consume the spaces or tabs). The conversion specifiers that do not consume leading whitespace, such as `%c`, can be made to do so by using a whitespace character in the format string:\n\n```\nscanf(\"%d\", &a);\nscanf(\" %c\", &c); // consume all consecutive whitespace after %d, then read a char\n```\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stddef.h>\n#include <locale.h>\n \nint main(void)\n{\n    int i, j;\n    float x, y;\n    char str1[10], str2[4];\n    wchar_t warr[2];\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    char input[] = \"25 54.32E-1 Thompson 56789 0123 56ß水\";\n    /* parse as follows:\n       %d: an integer\n       %f: a floating-point value\n       %9s: a string of at most 9 non-whitespace characters\n       %2d: two-digit integer (digits 5 and 6)\n       %f:  a floating-point value (digits 7, 8, 9)\n       %*d: an integer which isn't stored anywhere\n       ' ': all consecutive whitespace\n       %3[0-9]: a string of at most 3 decimal digits (digits 5 and 6)\n       %2lc: two wide characters, using multibyte to wide conversion  */\n    int ret = sscanf(input, \"%d%f%9s%2d%f%*d %3[0-9]%2lc\",\n                     &i, &x, str1, &j, &y, str2, warr);\n \n    printf(\"Converted %d fields:\\n\"\n           \"i = %d\\n\"\n           \"x = %f\\n\"\n           \"str1 = %s\\n\"\n           \"j = %d\\n\"\n           \"y = %f\\n\"\n           \"str2 = %s\\n\"\n           \"warr[0] = U+%x\\n\"\n           \"warr[1] = U+%x\\n\",\n           ret, i, x, str1, j, y, str2, warr[0], warr[1]);\n \n#ifdef __STDC_LIB_EXT1__\n    int n = sscanf_s(input, \"%d%f%s\", &i, &x, str1, (rsize_t)sizeof str1);\n    // writes 25 to i, 5.432 to x, the 9 bytes \"Thompson\\0\" to str1, and 3 to n.\n#endif\n}\n```\n\nPossible output:\n\n```\nConverted 7 fields:\ni = 25\nx = 5.432000\nstr1 = Thompson\nj = 56\ny = 789.000000\nstr2 = 56\nwarr[0] = U+df\nwarr[1] = U+6c34\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.2 The fscanf function (p: 231-236)\n  - 7.21.6.4 The scanf function (p: 236-237)\n  - 7.21.6.7 The sscanf function (p: 238-239)\n  - K.3.5.3.2 The fscanf_s function (p: 430-431)\n  - K.3.5.3.4 The scanf_s function (p: 432)\n  - K.3.5.3.7 The sscanf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.2 The fscanf function (p: 317-324)\n  - 7.21.6.4 The scanf function (p: 325)\n  - 7.21.6.7 The sscanf function (p: 326)\n  - K.3.5.3.2 The fscanf_s function (p: 592-593)\n  - K.3.5.3.4 The scanf_s function (p: 594)\n  - K.3.5.3.7 The sscanf_s function (p: 596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.2 The fscanf function (p: 282-289)\n  - 7.19.6.4 The scanf function (p: 290)\n  - 7.19.6.7 The sscanf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.2 The fscanf function\n  - 4.9.6.4 The scanf function\n  - 4.9.6.6 The sscanf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fscanf](https://en.cppreference.com/w/c/io/fscanf)"
- name: Scope
  summary: Each identifier that appears in a C program is visible (that is, may be used) only in some possibly discontiguous portion of the source code called its scope
  description: "# Scope\n\nEach [identifier](identifier \"c/language/identifier\") that appears in a C program is *visible* (that is, may be used) only in some possibly discontiguous portion of the source code called its *scope*.\n\nWithin a scope, an identifier may designate more than one entity only if the entities are in different [name spaces](name_space \"c/language/name space\").\n\nC has four kinds of scopes:\n\n- block scope\n- file scope\n- function scope\n- function prototype scope\n\n### Nested scopes\n\nIf two different entities named by the same identifier are in scope at the same time, and they belong to the same [name space](name_space \"c/language/name space\"), the scopes are nested (no other form of scope overlap is allowed), and the declaration that appears in the inner scope hides the declaration that appears in the outer scope:\n\n```\n// The name space here is ordinary identifiers.\n \nint a;   // file scope of name a begins here\n \nvoid f(void)\n{\n    int a = 1; // the block scope of the name a begins here; hides file-scope a\n    {\n      int a = 2;         // the scope of the inner a begins here, outer a is hidden\n      printf(\"%d\\n\", a); // inner a is in scope, prints 2\n    }                    // the block scope of the inner a ends here\n    printf(\"%d\\n\", a);   // the outer a is in scope, prints 1\n}                        // the scope of the outer a ends here\n \nvoid g(int a);   // name a has function prototype scope; hides file-scope a\n```\n\n### Block scope\n\nThe scope of any identifier declared inside a [compound statement](statements#Compound_statements \"c/language/statements\"), including function bodies, or in any expression, declaration, or statement appearing in [if](if \"c/language/if\"), [switch](switch \"c/language/switch\"), [for](for \"c/language/for\"), [while](while \"c/language/while\"), or [do-while](do \"c/language/do\") statement(since C99), or within the parameter list of a [function definition](function_definition \"c/language/function definition\") begins at the point of declaration and ends at the end of the block or statement in which it was declared.\n\n```\nvoid f(int n)  // scope of the function parameter 'n' begins\n{         // the body of the function begins\n   ++n;   // 'n' is in scope and refers to the function parameter\n// int n = 2; // error: cannot redeclare identifier in the same scope\n   for(int n = 0; n<10; ++n) { // scope of loop-local 'n' begins\n       printf(\"%d\\n\", n); // prints 0 1 2 3 4 5 6 7 8 9\n   } // scope of the loop-local 'n' ends\n     // the function parameter 'n' is back in scope\n   printf(\"%d\\n\", n); // prints the value of the parameter\n} // scope of function parameter 'n' ends\nint a = n; // Error: name 'n' is not in scope\n```\n\n[TABLE]\n\nBlock-scope variables have [no linkage](storage_duration \"c/language/storage duration\") and [automatic storage duration](storage_duration \"c/language/storage duration\") by default. Note that storage duration for non-VLA local variables begins when the block is entered, but until the declaration is seen, the variable is not in scope and cannot be accessed.\n\n### File scope\n\nThe scope of any identifier declared outside of any block or parameter list begins at the point of declaration and ends at the end of the translation unit.\n\n```\nint i; // scope of i begins\nstatic int g(int a) { return a; } // scope of g begins (note, \"a\" has block scope)\nint main(void)\n{\n    i = g(2); // i and g are in scope\n}\n```\n\nFile-scope identifiers have [external linkage](storage_duration \"c/language/storage duration\") and [static storage duration](storage_duration \"c/language/storage duration\") by default.\n\n### Function scope\n\nA [label (and only a label)](statements#Labels \"c/language/statements\") declared inside a function is in scope everywhere in that function, in all nested blocks, before and after its own declaration. Note: a label is declared implicitly, by using an otherwise unused identifier before the colon character before any statement.\n\n```\nvoid f()\n{\n   {   \n       goto label; // label in scope even though declared later\nlabel:;\n   }\n   goto label; // label ignores block scope\n}\n \nvoid g()\n{\n    goto label; // error: label not in scope in g()\n}\n```\n\n### Function prototype scope\n\nThe scope of a name introduced in the parameter list of a [function declaration](function_declaration \"c/language/function declaration\") that is not a definition ends at the end of the function [declarator](declarations \"c/language/declarations\").\n\n```\nint f(int n,\n      int a[n]); // n is in scope and refers to the first parameter\n```\n\nNote that if there are multiple or nested declarators in the declaration, the scope ends at the end of the nearest enclosing function declarator:\n\n```\nvoid f ( // function name 'f' is at file scope\n long double f,            // the identifier 'f' is now in scope, file-scope 'f' is hidden\n char (**a)[10 * sizeof f] // 'f' refers to the first parameter, which is in scope\n);\n \nenum{ n = 3 };\nint (*(*g)(int n))[n]; // the scope of the function parameter 'n'\n                       // ends at the end of its function declarator\n                       // in the array declarator, global n is in scope\n// (this declares a pointer to function returning a pointer to an array of 3 int)\n```\n\n### Point of declaration\n\nThe scope of structure, union, and enumeration tags begins immediately after the appearance of the tag in a type specifier that declares the tag.\n\n```\nstruct Node {\n   struct Node* next; // Node is in scope and refers to this struct\n};\n```\n\nThe scope of enumeration constant begins immediately after the appearance of its defining enumerator in an enumerator list.\n\n```\nenum { x = 12 };\n{\n    enum { x = x + 1, // new x is not in scope until the comma, x is initialized to 13\n           y = x + 1  // the new enumerator x is now in scope, y is initialized to 14\n         };\n}\n```\n\nThe scope of any other identifier begins just after the end of its declarator and before the initializer, if any:\n\n```\nint x = 2; // scope of the first 'x' begins\n{\n    int x[x]; // scope of the newly declared x begins after the declarator (x[x]).\n              // Within the declarator, the outer 'x' is still in scope.\n              // This declares a VLA array of 2 int.\n}\n```\n\n```\nunsigned char x = 32; // scope of the outer 'x' begins\n{\n    unsigned char x = x;\n            // scope of the inner 'x' begins before the initializer (= x)\n            // this does not initialize the inner 'x' with the value 32, \n            // this initializes the inner 'x' with its own, indeterminate, value\n}\n \nunsigned long factorial(unsigned long n)\n// declarator ends, 'factorial' is in scope from this point\n{\n   return n<2 ? 1 : n*factorial(n-1); // recursive call\n}\n```\n\nAs a special case, the scope of a [type name](type \"c/language/type\") that is not a declaration of an identifier is considered to begin just after the place within the type name where the identifier would appear were it not omitted.\n\n### Notes\n\nPrior to C89, identifiers with external linkage had file scope even when introduced within a block, and because of that, a C89 compiler is not required to diagnose the use of an extern identifier that has gone out of scope (such use is undefined behavior).\n\nLocal variables within a loop body can hide variables declared in the init clause of a [for](for \"c/language/for\") loop in C (their scope is nested), but cannot do that in C++.\n\nUnlike C++, C has no struct scope: names declared within a struct/union/enum declaration are in the same scope as the struct declaration (except that data members are in their own [member name space](name_space \"c/language/name space\")):\n\n```\nstruct foo {\n    struct baz {};\n    enum color {RED, BLUE};\n};\nstruct baz b; // baz is in scope\nenum color x = RED; // color and RED are in scope\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.2.1 Scopes of identifiers (p: 28-29)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.2.1 Scopes of identifiers (p: 35-36)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.2.1 Scopes of identifiers (p: 29-30)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.2.1 Scopes of identifiers\n\n### See also\n\n|                                                                                                      |     |\n|------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/scope \"cpp/language/scope\") for Scope |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/scope](https://en.cppreference.com/w/c/language/scope)"
- name: set_constraint_handler_s
  summary: Configures the handler to be called by all bounds-checked functions on a runtime constraint violation or restores the default handler (if handler is a null pointer)
  description: "# set_constraint_handler_s, constraint_handler_t\n\n[TABLE]\n\nConfigures the handler to be called by all [bounds-checked functions](../error#Bounds_checking \"c/error\") on a runtime constraint violation or restores the default handler (if `handler` is a null pointer)\n\nThe handler must be a pointer to function of type `constraint_handler_t`, which is defined as\n\n[TABLE]\n\nOn a runtime constraint violation, it is called with the following arguments:\n\n1) pointer to character string that describes the error\n\n2) pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected\n\n3) the error about to be returned by the calling function, if it happens to be one of the functions that return `errno_t`\n\nIf `set_constraint_handler_s` is never called, the default handler is implementation-defined: it may be `abort_handler_s`, `ignore_handler_s`, or some other implementation-defined handler. As with all bounds-checked functions, `set_constraint_handler_s` and `constraint_handler_t` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including `<stdlib.h>`.\n\n### Parameters\n\n|         |     |                                                                      |\n|---------|-----|----------------------------------------------------------------------|\n| handler | \\-  | pointer to function of type `constraint_handler_t` or a null pointer |\n\n### Return value\n\nA pointer to the previously-installed runtime constraints handler. (note: this pointer is never a null pointer because calling `set_constraint_handler_s``(`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`)` sets up the system default handler)\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n#ifdef __STDC_LIB_EXT1__\n    char dst[2];\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcpy_s(dst, sizeof dst, \"Too long!\");\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n    set_constraint_handler_s(abort_handler_s);\n    r = strcpy_s(dst, sizeof dst, \"Too long!\");\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n#endif\n}\n```\n\nPossible output:\n\n```\ndst = \"\", r = 22\nabort_handler_s was called in response to a runtime-constraint violation.\n \nThe runtime-constraint violation was caused by the following expression in strcpy_s:\n(s1max <= (s2_len=strnlen_s(s2, s1max)) ) (in string_s.c:62)\n \nNote to end users: This program was terminated as a result\nof a bug present in the software. Please reach out to your\nsoftware's vendor to get more help.\nAborted\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - K.3.6/2 constraint_handler_t (p: 604)\n  - K.3.6.1.1 The set_constraint_handler_s function (p: 604-605)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/error/set_constraint_handler_s](https://en.cppreference.com/w/c/error/set_constraint_handler_s)"
- name: setbuf
  summary: Sets the internal buffer to use for stream operations
  description: "# setbuf\n\n[TABLE]\n\nSets the internal buffer to use for stream operations. It should be at least `BUFSIZ` characters long.\n\nIf `buffer` is not null, equivalent to [`setvbuf`](http://en.cppreference.com/w/c/io/setvbuf)`(``stream, buffer, `[`_IOFBF`](http://en.cppreference.com/w/c/io)`, `[`BUFSIZ`](http://en.cppreference.com/w/c/io)`)`.\n\nIf `buffer` is null, equivalent to [`setvbuf`](http://en.cppreference.com/w/c/io/setvbuf)`(``stream, `[`NULL`](http://en.cppreference.com/w/c/types/NULL)`, `[`_IONBF`](http://en.cppreference.com/w/c/io)`, ``0``)`, which turns off buffering.\n\n### Parameters\n\n|        |     |                                                                                                       |\n|--------|-----|-------------------------------------------------------------------------------------------------------|\n| stream | \\-  | the file stream to set the buffer to                                                                  |\n| buffer | \\-  | pointer to a buffer for the stream to use. If a null pointer is supplied, the buffering is turned off |\n\n### Return value\n\nNone.\n\n### Notes\n\nIf [`BUFSIZ`](../io \"c/io\") is not the appropriate buffer size, [`setvbuf`](setvbuf \"c/io/setvbuf\") can be used to change it.\n\n[`setvbuf`](setvbuf \"c/io/setvbuf\") should also be used to detect errors, since `setbuf` does not indicate success or failure.\n\nThis function may only be used after `stream` has been associated with an open file, but before any other operation (other than a failed call to `setbuf`/`setvbuf`).\n\nA common error is setting the buffer of stdin or stdout to an array whose lifetime ends before the program terminates:\n\n```\nint main(void) {\n    char buf[BUFSIZ];\n    setbuf(stdin, buf);\n} // lifetime of buf ends, undefined behavior\n```\n\n### Example\n\n`setbuf` may be used to disable buffering on streams that require immediate output.\n\n```\n#include <stdio.h>\n#include <threads.h>\n \nint main(void)\n{\n    setbuf(stdout, NULL); // unbuffered stdout\n    putchar('a'); // 'a' appears immediately if stdout is unbuffered\n    thrd_sleep(&(struct timespec){.tv_sec=1}, NULL); // sleep 1 sec\n    putchar('b'); \n}\n```\n\nOutput:\n\n```\nab\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.5.5 The setbuf function (p: 225)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.5.5 The setbuf function (p: 307-308)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.5.5 The setbuf function (p: 273)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.5.5 The setbuf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/setbuf](https://en.cppreference.com/w/c/io/setbuf)"
- name: setjmp
  summary: Saves the current execution context into a variable env of type jmp_buf
  description: "# setjmp\n\n[TABLE]\n\nSaves the current execution context into a variable `env` of type [`jmp_buf`](jmp_buf \"c/program/jmp buf\"). This variable can later be used to restore the current execution context by [`longjmp`](longjmp \"c/program/longjmp\") function. That is, when a call to [`longjmp`](longjmp \"c/program/longjmp\") function is made, the execution continues at the particular call site that constructed the [`jmp_buf`](jmp_buf \"c/program/jmp buf\") variable passed to [`longjmp`](longjmp \"c/program/longjmp\"). In that case `setjmp` returns the value passed to [`longjmp`](longjmp \"c/program/longjmp\").\n\nThe invocation of `setjmp` must appear only in one of the following contexts:\n\n1.  The entire controlling expression of [`if`](../language/if \"c/language/if\"), [`switch`](../language/switch \"c/language/switch\"), [`while`](../language/while \"c/language/while\"), [`do-while`](../language/do \"c/language/do\"), [`for`](../language/for \"c/language/for\").\n    ```\n    switch(setjmp(env)) { // ...\n    ```\n2.  One operand of a relational or equality operator with the other operand an integer constant expression, with the resulting expression being the entire controlling expression of [`if`](../language/if \"c/language/if\"), [`switch`](../language/switch \"c/language/switch\"), [`while`](../language/while \"c/language/while\"), [`do-while`](../language/do \"c/language/do\"), [`for`](../language/for \"c/language/for\").\n    ```\n    if(setjmp(env) > 10) { // ...\n    ```\n3.  The operand of a unary ! operator with the resulting expression being the entire controlling expression of [`if`](../language/if \"c/language/if\"), [`switch`](../language/switch \"c/language/switch\"), [`while`](../language/while \"c/language/while\"), [`do-while`](../language/do \"c/language/do\"), [`for`](../language/for \"c/language/for\").\n    ```\n    while(!setjmp(env)) { // ...\n    ```\n4.  The entire expression of an [expression statement](../language/statements#Expression_statements \"c/language/statements\") (possibly cast to `void`).\n    ```\n    setjmp(env);\n    ```\n\nIf `setjmp` appears in any other context, the behavior is undefined.\n\nUpon return to the scope of `setjmp`:\n\n- all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when [`longjmp`](longjmp \"c/program/longjmp\") was executed,\n- except for the non-[`volatile`](../language/volatile \"c/language/volatile\") local variables in the function containing the invocation of `setjmp`, whose values are indeterminate if they have been changed since the `setjmp` invocation.\n\n### Parameters\n\n|     |     |                                                         |\n|-----|-----|---------------------------------------------------------|\n| env | \\-  | variable to save the execution state of the program to. |\n\n### Return value\n\n`​0​` if the macro was called by the original code and the execution context was saved to `env`.\n\nNon-zero value if a non-local jump was just performed. The return value is the same as passed to [`longjmp`](longjmp \"c/program/longjmp\").\n\n### Notes\n\nAbove requirements forbid using return value of `setjmp` in data flow (e.g. to initialize or assign an object with it). The return value can only be either used in control flow or discarded.\n\n### Example\n\n```\n#include <stdio.h>\n#include <setjmp.h>\n#include <stdnoreturn.h>\n \njmp_buf my_jump_buffer;\n \nnoreturn void foo(int status) \n{\n    printf(\"foo(%d) called\\n\", status);\n    longjmp(my_jump_buffer, status + 1); // will return status+1 out of setjmp\n}\n \nint main(void)\n{\n    volatile int count = 0; // modified local vars in setjmp scope must be volatile\n    if (setjmp(my_jump_buffer) != 5) // compare against constant in an if\n        foo(++count);\n}\n```\n\nOutput:\n\n```\nfoo(1) called\nfoo(2) called\nfoo(3) called\nfoo(4) called\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.13.1.1 The setjmp macro (p: 191)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.13.1.1 The setjmp macro (p: 262-263)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.13.1.1 The setjmp macro (p: 243-244)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.6.1 The setjmp macro\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/setjmp](https://en.cppreference.com/w/c/program/setjmp)"
- name: setlocale
  summary: The setlocale function installs the specified system locale or its portion as the new C locale
  description: "# setlocale\n\n[TABLE]\n\nThe `setlocale` function installs the specified system locale or its portion as the new C locale. The modifications remain in effect and influences the execution of all locale-sensitive C library functions until the next call to `setlocale`. If `locale` is a null pointer, `setlocale` queries the current C locale without modifying it.\n\n### Parameters\n\n|          |     |                                                                                                              |\n|----------|-----|--------------------------------------------------------------------------------------------------------------|\n| category | \\-  | locale category identifier, one of the [LC_xxx](lc_categories \"c/locale/LC categories\") macros. May be null. |\n| locale   | \\-  | system-specific locale identifier. Can be `\"\"` for the user-preferred locale or `\"C\"` for the minimal locale |\n\n### Return value\n\npointer to a narrow null-terminated string identifying the C locale after applying the changes, if any, or null pointer on failure.\n\nA copy of the returned string along with the category used in this call to `setlocale` may be used later in the program to restore the locale back to the state at the end of this call.\n\n### Notes\n\nDuring program startup, the equivalent of `setlocale``(`[`LC_ALL`](http://en.cppreference.com/w/c/locale/LC_categories)`, ``\"C\"``)``;` is executed before any user code is run.\n\nAlthough the return type is `char*`, modifying the pointed-to characters is undefined behavior.\n\nBecause `setlocale` modifies global state which affects execution of locale-dependent functions, it is undefined behavior to call it from one thread, while another thread is executing any of the following functions: [`fprintf`](../io/fprintf \"c/io/fprintf\"), [`isprint`](../string/byte/isprint \"c/string/byte/isprint\"), [`iswdigit`](../string/wide/iswdigit \"c/string/wide/iswdigit\"), [`localeconv`](localeconv \"c/locale/localeconv\"), [`tolower`](../string/byte/tolower \"c/string/byte/tolower\"), [`fscanf`](../io/fscanf \"c/io/fscanf\"), [`ispunct`](../string/byte/ispunct \"c/string/byte/ispunct\"), [`iswgraph`](../string/wide/iswgraph \"c/string/wide/iswgraph\"), [`mblen`](../string/multibyte/mblen \"c/string/multibyte/mblen\"), [`toupper`](../string/byte/toupper \"c/string/byte/toupper\"), [`isalnum`](../string/byte/isalnum \"c/string/byte/isalnum\"), [`isspace`](../string/byte/isspace \"c/string/byte/isspace\"), [`iswlower`](../string/wide/iswlower \"c/string/wide/iswlower\"), [`mbstowcs`](../string/multibyte/mbstowcs \"c/string/multibyte/mbstowcs\"), [`towlower`](../string/wide/towlower \"c/string/wide/towlower\"), [`isalpha`](../string/byte/isalpha \"c/string/byte/isalpha\"), [`isupper`](../string/byte/isupper \"c/string/byte/isupper\"), [`iswprint`](../string/wide/iswprint \"c/string/wide/iswprint\"), [`mbtowc`](../string/multibyte/mbtowc \"c/string/multibyte/mbtowc\"), [`towupper`](../string/wide/towupper \"c/string/wide/towupper\"), [`isblank`](../string/byte/isblank \"c/string/byte/isblank\"), [`iswalnum`](../string/wide/iswalnum \"c/string/wide/iswalnum\"), [`iswpunct`](../string/wide/iswpunct \"c/string/wide/iswpunct\"), `setlocale`, [`wcscoll`](../string/wide/wcscoll \"c/string/wide/wcscoll\"), [`iscntrl`](../string/byte/iscntrl \"c/string/byte/iscntrl\"), [`iswalpha`](../string/wide/iswalpha \"c/string/wide/iswalpha\"), [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\"), [`strcoll`](../string/byte/strcoll \"c/string/byte/strcoll\"), [`wcstod`](../string/wide/wcstof \"c/string/wide/wcstof\"), [`isdigit`](../string/byte/isdigit \"c/string/byte/isdigit\"), [`iswblank`](../string/wide/iswblank \"c/string/wide/iswblank\"), [`iswupper`](../string/wide/iswupper \"c/string/wide/iswupper\"), [`strerror`](../string/byte/strerror \"c/string/byte/strerror\"), [`wcstombs`](../string/multibyte/wcstombs \"c/string/multibyte/wcstombs\"), [`isgraph`](../string/byte/isgraph \"c/string/byte/isgraph\"), [`iswcntrl`](../string/wide/iswcntrl \"c/string/wide/iswcntrl\"), [`iswxdigit`](../string/wide/iswxdigit \"c/string/wide/iswxdigit\"), [`strtod`](../string/byte/strtof \"c/string/byte/strtof\"), [`wcsxfrm`](../string/wide/wcsxfrm \"c/string/wide/wcsxfrm\"), [`islower`](../string/byte/islower \"c/string/byte/islower\"), [`iswctype`](../string/wide/iswctype \"c/string/wide/iswctype\"), [`isxdigit`](../string/byte/isxdigit \"c/string/byte/isxdigit\").\n\nPOSIX also defines a locale named \"POSIX\", which is always accessible and is exactly equivalent to the default minimal \"C\" locale.\n\nPOSIX also specifies that the returned pointer, not just the contents of the pointed-to string, may be invalidated by subsequent calls to `setlocale`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <time.h>\n#include <wchar.h>\n \nint main(void)\n{\n    // the C locale will be UTF-8 enabled English;\n    // decimal dot will be German\n    // date and time formatting will be Japanese\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n    setlocale(LC_NUMERIC, \"de_DE.utf8\");\n    setlocale(LC_TIME, \"ja_JP.utf8\");\n \n    wchar_t str[100];\n    time_t t = time(NULL);\n    wcsftime(str, 100, L\"%A %c\", localtime(&t));\n    wprintf(L\"Number: %.2f\\nDate: %ls\\n\", 3.14, str);\n}\n```\n\nPossible output:\n\n```\nNumber: 3,14\nDate: 月曜日 2017年09月25日 13時00分15秒\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.11.1.1 The setlocale function (p: 163-164)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.11.1.1 The setlocale function (p: 224-225)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.11.1.1 The setlocale function (p: 205-206)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.4.1.1 The setlocale function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/locale/setlocale](https://en.cppreference.com/w/c/locale/setlocale)"
- name: setvbuf
  summary: Changes the buffering mode of the given file stream stream as indicated by the argument mode
  description: "# setvbuf\n\n[TABLE]\n\nChanges the buffering mode of the given file stream `stream` as indicated by the argument `mode`. In addition,\n\n- If `buffer` is a null pointer, resizes the internal buffer to `size`.\n- If `buffer` is not a null pointer, instructs the stream to use the user-provided buffer of size `size` beginning at `buffer`. The stream must be closed (with [`fclose`](fclose \"c/io/fclose\")) before the [lifetime](../language/lifetime \"c/language/lifetime\") of the array pointed to by `buffer` ends. The contents of the array after a successful call to `setvbuf` are indeterminate and any attempt to use it is undefined behavior.\n\n### Parameters\n\n[TABLE]\n\n### Return value\n\n`​0​` on success or nonzero on failure.\n\n### Notes\n\nThis function may only be used after `stream` has been associated with an open file, but before any other operation (other than a failed call to [`setbuf`](setbuf \"c/io/setbuf\")/`setvbuf`).\n\nNot all `size` bytes will necessarily be used for buffering: the actual buffer size is usually rounded down to a multiple of 2, a multiple of page size, etc.\n\nOn many implementations, line buffering is only available for terminal input streams.\n\nA common error is setting the buffer of stdin or stdout to an array whose lifetime ends before the program terminates:\n\n```\nint main(void) {\n    char buf[BUFSIZ];\n    setbuf(stdin, buf);\n} // lifetime of buf ends, undefined behavior\n```\n\nThe default buffer size [`BUFSIZ`](../io \"c/io\") is expected to be the most efficient buffer size for file I/O on the implementation, but POSIX [fstat](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html) often provides a better estimate.\n\n### Example\n\nOne use case for changing buffer size is when a better size is known. (This example uses some POSIX function, e.g. [`fileno`](https://pubs.opengroup.org/onlinepubs/7908799/xsh/fileno.html). See also SO: [\\#1](https://stackoverflow.com/questions/15749184/fileno-not-available) and [\\#2](https://stackoverflow.com/questions/44622827/why-am-i-getting-error-implicit-declaration-of-function-fileno-when-i-try-t)).\n\n```\n// Make some POSIX functions, such as `int fileno(FILE*)`, visible:\n#define _POSIX_SOURCE\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n \nint main(void)\n{\n    FILE* fp = fopen(\"/tmp/test.txt\", \"w+\");\n    if (fp == NULL)\n    {\n        perror(\"fopen\");\n        return EXIT_FAILURE;\n    }\n \n    struct stat stats;\n    if (fstat(fileno(fp), &stats) == -1) // POSIX only\n    {\n        perror(\"fstat\");\n        return EXIT_FAILURE;\n    }\n \n    printf(\"BUFSIZ is %d, but optimal block size is %ld\\n\", BUFSIZ, stats.st_blksize);\n    if (setvbuf(fp, NULL, _IOFBF, stats.st_blksize) != 0)\n    {\n        perror(\"setvbuf failed\"); // POSIX version sets errno\n        return EXIT_FAILURE;\n    }\n \n    int ch;\n    while((ch=fgetc(fp)) != EOF); // read entire file: use truss/strace to\n                                  // observe the read(2) syscalls used\n \n    fclose(fp);\n    return EXIT_SUCCESS;\n}\n```\n\nPossible output:\n\n```\nBUFSIZ is 8192, but optimal block size is 65536\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.5.6 The setvbuf function (p: 225)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.5.6 The setvbuf function (p: 308)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.5.6 The setvbuf function (p: 273-274)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.5.6 The setvbuf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/setvbuf](https://en.cppreference.com/w/c/io/setvbuf)"
- name: short
  summary: ''
  description: "# C keywords: short\n\n### Usage\n\n- [`short` type modifier](../language/types \"c/language/types\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/short](https://en.cppreference.com/w/c/keyword/short)"
- name: sig_atomic_t
  summary: An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals
  description: "# sig_atomic_t\n\n[TABLE]\n\nAn integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.\n\n### Example\n\n```\n#include <signal.h>\n#include <stdio.h>\n \nvolatile sig_atomic_t gSignalStatus = 0;\n \nvoid signal_handler(int status)\n{\n    gSignalStatus = status;\n}\n \nint main(void)\n{\n    /* Install a signal handler. */\n    signal(SIGINT, signal_handler);\n \n    printf(\"SignalValue:    %d\\n\", gSignalStatus);\n    printf(\"Sending signal: %d\\n\", SIGINT);\n    raise(SIGINT);\n    printf(\"SignalValue:    %d\\n\", gSignalStatus);\n}\n```\n\nPossible output:\n\n```\nSignalValue:    0\nSending signal: 2\nSignalValue:    2\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14/2 Signal handling \\<signal.h\\> (p: 194-195)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14/2 Signal handling \\<signal.h\\> (p: 265)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14/2 Signal handling \\<signal.h\\> (p: 246)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/sig_atomic_t](https://en.cppreference.com/w/c/program/sig_atomic_t)"
- name: SIG_DFL
  summary: The SIG_DFL and SIG_IGN macros expand into integral expressions that are not equal to an address of any function
  description: "# SIG_DFL, SIG_IGN\n\n[TABLE]\n\nThe `SIG_DFL` and `SIG_IGN` macros expand into integral expressions that are not equal to an address of any function. The macros define signal handling strategies for [`signal`](http://en.cppreference.com/w/c/program/signal)`(``)` function.\n\n| Constant  | Explanation             |\n|-----------|-------------------------|\n| `SIG_DFL` | default signal handling |\n| `SIG_IGN` | signal is ignored       |\n\n### Example\n\n```\n#include <signal.h>\n#include <stdio.h>\n \nint main(void)\n{\n    /* using the default signal handler */\n    raise(SIGTERM);\n    printf(\"Exit main()\\n\");   /* never reached */\n}\n```\n\nOutput:\n\n```\n(none)\n```\n\n### Example\n\n```\n#include <signal.h>\n#include <stdio.h>\n \nint main(void)\n{\n    /* ignoring the signal */\n    signal(SIGTERM, SIG_IGN);\n    raise(SIGTERM);\n    printf(\"Exit main()\\n\");\n}\n```\n\nOutput:\n\n```\nExit main()\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 193)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 265)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 246)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n\n### See also\n\n|                                                                                                                                                   |     |\n|---------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/utility/program/SIG_strategies \"cpp/utility/program/SIG strategies\") for `SIG_DFL, SIG_IGN` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/SIG_strategies](https://en.cppreference.com/w/c/program/SIG_strategies)"
- name: SIG_ERR
  summary: A value of type void (*)(int)
  description: "# SIG_ERR\n\n[TABLE]\n\nA value of type `void (*)(int)`. When returned by [`signal`](signal \"c/program/signal\"), indicates that an error has occurred.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n \nvoid signal_handler(int sig)\n{\n    printf(\"Received signal: %d\\n\", sig);\n}\n \nint main(void)\n{\n    /* Install a signal handler. */\n    if (signal(SIGTERM, signal_handler) == SIG_ERR)\n    {\n        printf(\"Error while installing a signal handler.\\n\");\n        exit(EXIT_FAILURE);\n    }\n \n    printf(\"Sending signal: %d\\n\", SIGTERM);\n    if (raise(SIGTERM) != 0)\n    {\n        printf(\"Error while raising the SIGTERM signal.\\n\");\n        exit(EXIT_FAILURE);\n    }\n \n    printf(\"Exit main()\\n\");\n    return EXIT_SUCCESS;\n}\n```\n\nOutput:\n\n```\nSending signal: 15\nReceived signal: 15\nExit main()\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 194)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 265)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 246)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/SIG_ERR](https://en.cppreference.com/w/c/program/SIG_ERR)"
- name: SIG_IGN
  summary: The SIG_DFL and SIG_IGN macros expand into integral expressions that are not equal to an address of any function
  description: "# SIG_DFL, SIG_IGN\n\n[TABLE]\n\nThe `SIG_DFL` and `SIG_IGN` macros expand into integral expressions that are not equal to an address of any function. The macros define signal handling strategies for [`signal`](http://en.cppreference.com/w/c/program/signal)`(``)` function.\n\n| Constant  | Explanation             |\n|-----------|-------------------------|\n| `SIG_DFL` | default signal handling |\n| `SIG_IGN` | signal is ignored       |\n\n### Example\n\n```\n#include <signal.h>\n#include <stdio.h>\n \nint main(void)\n{\n    /* using the default signal handler */\n    raise(SIGTERM);\n    printf(\"Exit main()\\n\");   /* never reached */\n}\n```\n\nOutput:\n\n```\n(none)\n```\n\n### Example\n\n```\n#include <signal.h>\n#include <stdio.h>\n \nint main(void)\n{\n    /* ignoring the signal */\n    signal(SIGTERM, SIG_IGN);\n    raise(SIGTERM);\n    printf(\"Exit main()\\n\");\n}\n```\n\nOutput:\n\n```\nExit main()\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 193)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 265)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 246)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n\n### See also\n\n|                                                                                                                                                   |     |\n|---------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/utility/program/SIG_strategies \"cpp/utility/program/SIG strategies\") for `SIG_DFL, SIG_IGN` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/SIG_strategies](https://en.cppreference.com/w/c/program/SIG_strategies)"
- name: SIGABRT
  summary: Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program
  description: "# SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE\n\n[TABLE]\n\nEach of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.\n\n| Constant  | Explanation                                                                                  |\n|-----------|----------------------------------------------------------------------------------------------|\n| `SIGTERM` | termination request, sent to the program                                                     |\n| `SIGSEGV` | invalid memory access (segmentation fault)                                                   |\n| `SIGINT`  | external interrupt, usually initiated by the user                                            |\n| `SIGILL`  | invalid program image, such as invalid instruction                                           |\n| `SIGABRT` | abnormal termination condition, as is e.g. initiated by [`abort()`](abort \"c/program/abort\") |\n| `SIGFPE`  | erroneous arithmetic operation such as divide by zero                                        |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 193)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 265)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 246)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/SIG_types](https://en.cppreference.com/w/c/program/SIG_types)"
- name: SIGFPE
  summary: Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program
  description: "# SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE\n\n[TABLE]\n\nEach of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.\n\n| Constant  | Explanation                                                                                  |\n|-----------|----------------------------------------------------------------------------------------------|\n| `SIGTERM` | termination request, sent to the program                                                     |\n| `SIGSEGV` | invalid memory access (segmentation fault)                                                   |\n| `SIGINT`  | external interrupt, usually initiated by the user                                            |\n| `SIGILL`  | invalid program image, such as invalid instruction                                           |\n| `SIGABRT` | abnormal termination condition, as is e.g. initiated by [`abort()`](abort \"c/program/abort\") |\n| `SIGFPE`  | erroneous arithmetic operation such as divide by zero                                        |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 193)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 265)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 246)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/SIG_types](https://en.cppreference.com/w/c/program/SIG_types)"
- name: SIGILL
  summary: Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program
  description: "# SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE\n\n[TABLE]\n\nEach of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.\n\n| Constant  | Explanation                                                                                  |\n|-----------|----------------------------------------------------------------------------------------------|\n| `SIGTERM` | termination request, sent to the program                                                     |\n| `SIGSEGV` | invalid memory access (segmentation fault)                                                   |\n| `SIGINT`  | external interrupt, usually initiated by the user                                            |\n| `SIGILL`  | invalid program image, such as invalid instruction                                           |\n| `SIGABRT` | abnormal termination condition, as is e.g. initiated by [`abort()`](abort \"c/program/abort\") |\n| `SIGFPE`  | erroneous arithmetic operation such as divide by zero                                        |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 193)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 265)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 246)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/SIG_types](https://en.cppreference.com/w/c/program/SIG_types)"
- name: SIGINT
  summary: Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program
  description: "# SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE\n\n[TABLE]\n\nEach of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.\n\n| Constant  | Explanation                                                                                  |\n|-----------|----------------------------------------------------------------------------------------------|\n| `SIGTERM` | termination request, sent to the program                                                     |\n| `SIGSEGV` | invalid memory access (segmentation fault)                                                   |\n| `SIGINT`  | external interrupt, usually initiated by the user                                            |\n| `SIGILL`  | invalid program image, such as invalid instruction                                           |\n| `SIGABRT` | abnormal termination condition, as is e.g. initiated by [`abort()`](abort \"c/program/abort\") |\n| `SIGFPE`  | erroneous arithmetic operation such as divide by zero                                        |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 193)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 265)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 246)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/SIG_types](https://en.cppreference.com/w/c/program/SIG_types)"
- name: signal
  summary: Sets the error handler for signal sig
  description: "# signal\n\n[TABLE]\n\nSets the error handler for signal `sig`. The signal handler can be set so that default handling will occur, signal is ignored, or a user-defined function is called.\n\nWhen signal handler is set to a function and a signal occurs, it is implementation defined whether `signal``(``sig, `[`SIG_DFL`](http://en.cppreference.com/w/c/program/SIG_strategies)`)` will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.\n\n### Parameters\n\n[TABLE]\n\n### Return value\n\nPrevious signal handler on success or [`SIG_ERR`](sig_err \"c/program/SIG ERR\") on failure (setting a signal handler can be disabled on some implementations).\n\n### Signal handler\n\nThe following limitations are imposed on the user-defined function that is installed as a signal handler.\n\nIf the user defined function returns when handling [`SIGFPE`](sig_types \"c/program/SIG types\"), [`SIGILL`](sig_types \"c/program/SIG types\") or [`SIGSEGV`](sig_types \"c/program/SIG types\"), the behavior is undefined.\n\nIf the signal handler is called as a result of [`abort`](abort \"c/program/abort\") or [`raise`](raise \"c/program/raise\"), the behavior is undefined if the signal handler calls [`raise`](raise \"c/program/raise\").\n\nIf the signal handler is called NOT as a result of [`abort`](abort \"c/program/abort\") or [`raise`](raise \"c/program/raise\") (in other words, the signal handler is *asynchronous*), the behavior is undefined if\n\n- the signal handler calls any function within the standard library, except\n  - [`abort`](abort \"c/program/abort\")\n  - [`_Exit`](_exit \"c/program/ Exit\")\n  - [`quick_exit`](quick_exit \"c/program/quick exit\")\n  - `signal` with the first argument being the number of the signal currently handled (async handler can re-register itself, but not other signals).\n  - atomic functions from [`<stdatomic.h>`](../thread#Atomic_operations \"c/thread\") if the atomic arguments are lock-free\n  - [`atomic_is_lock_free`](../atomic/atomic_is_lock_free \"c/atomic/atomic is lock free\") (with any kind of atomic arguments)\n- the signal handler refers to any object with static or thread-local(since C11) [storage duration](../language/storage_duration \"c/language/storage duration\") that is not a lock-free [atomic](../language/atomic \"c/language/atomic\")(since C11) other than by assigning to a static `volatile`` `[`sig_atomic_t`](http://en.cppreference.com/w/c/program/sig_atomic_t).\n\nOn entry to the signal handler, the state of the floating-point environment and the values of all objects is unspecified, except for\n\n- objects of type `volatile`` `[`sig_atomic_t`](http://en.cppreference.com/w/c/program/sig_atomic_t)\n- objects of lock-free atomic types (since C11)\n- side effects made visible through [`atomic_signal_fence`](../atomic/atomic_signal_fence \"c/atomic/atomic signal fence\") (since C11)\n\nOn return from a signal handler, the value of any object modified by the signal handler that is not `volatile`` `[`sig_atomic_t`](http://en.cppreference.com/w/c/program/sig_atomic_t) or lock-free atomic(since C11) is undefined.\n\nThe behavior is undefined if `signal` is used in a multithreaded program. It is not required to be thread-safe.\n\n### Notes\n\nPOSIX requires that `signal` is thread-safe, and [specifies a list of async-signal-safe library functions](http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04) that may be called from any signal handler.\n\nBesides `abort` and `raise`, POSIX specifies that `kill`, `pthread_kill`, and `sigqueue` generate synchronous signals.\n\nPOSIX recommends [`sigaction`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaction.html) instead of `signal`, due to its underspecified behavior and significant implementation variations, regarding signal delivery while a signal handler is executed.\n\n### Example\n\n```\n#include <signal.h>\n#include <stdio.h>\n \nvolatile sig_atomic_t gSignalStatus;\n \nvoid signal_handler(int signal)\n{\n  gSignalStatus = signal;\n}\n \nint main(void)\n{\n  signal(SIGINT, signal_handler);\n \n  printf(\"SignalValue: %d\\n\", gSignalStatus);\n  printf(\"Sending signal: %d\\n\", SIGINT);\n  raise(SIGINT);\n  printf(\"SignalValue: %d\\n\", gSignalStatus);\n}\n```\n\nOutput:\n\n```\nSignalValue: 0\nSending signal: 2\nSignalValue: 2\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14.1.1 The signal function (p: 193-194)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14.1.1 The signal function (p: 266-267)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14.1.1 The signal function (p: 247-248)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7.1.1 The signal function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/signal](https://en.cppreference.com/w/c/program/signal)"
- name: signbit
  summary: Determines if the given floating point number arg is negative
  description: "# signbit\n\n[TABLE]\n\nDetermines if the given floating point number `arg` is negative. The macro returns an integral value.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nNonzero integral value if `arg` is negative, `​0​` otherwise.\n\n### Notes\n\nThis macro detects the sign bit of zeroes, infinities, and NaNs. Along with [`copysign`](copysign \"c/numeric/math/copysign\"), this macro is one of the only two portable ways to examine the sign of a NaN.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"signbit(+0.0) = %d\\n\", signbit(+0.0));\n    printf(\"signbit(-0.0) = %d\\n\", signbit(-0.0));\n}\n```\n\nPossible output:\n\n```\nsignbit(+0.0) = 0\nsignbit(-0.0) = 128\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.3.6 The signbit macro (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.3.6 The signbit macro (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.3.6 The signbit macro (p: 237)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.3.6 The signbit macro (p: 218)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/signbit](https://en.cppreference.com/w/c/numeric/math/signbit)"
- name: signed
  summary: ''
  description: "# C keywords: signed\n\n### Usage\n\n- [`signed` type modifier](../language/types \"c/language/types\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/signed](https://en.cppreference.com/w/c/keyword/signed)"
- name: SIGSEGV
  summary: Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program
  description: "# SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE\n\n[TABLE]\n\nEach of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.\n\n| Constant  | Explanation                                                                                  |\n|-----------|----------------------------------------------------------------------------------------------|\n| `SIGTERM` | termination request, sent to the program                                                     |\n| `SIGSEGV` | invalid memory access (segmentation fault)                                                   |\n| `SIGINT`  | external interrupt, usually initiated by the user                                            |\n| `SIGILL`  | invalid program image, such as invalid instruction                                           |\n| `SIGABRT` | abnormal termination condition, as is e.g. initiated by [`abort()`](abort \"c/program/abort\") |\n| `SIGFPE`  | erroneous arithmetic operation such as divide by zero                                        |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 193)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 265)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 246)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/SIG_types](https://en.cppreference.com/w/c/program/SIG_types)"
- name: SIGTERM
  summary: Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program
  description: "# SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE\n\n[TABLE]\n\nEach of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.\n\n| Constant  | Explanation                                                                                  |\n|-----------|----------------------------------------------------------------------------------------------|\n| `SIGTERM` | termination request, sent to the program                                                     |\n| `SIGSEGV` | invalid memory access (segmentation fault)                                                   |\n| `SIGINT`  | external interrupt, usually initiated by the user                                            |\n| `SIGILL`  | invalid program image, such as invalid instruction                                           |\n| `SIGABRT` | abnormal termination condition, as is e.g. initiated by [`abort()`](abort \"c/program/abort\") |\n| `SIGFPE`  | erroneous arithmetic operation such as divide by zero                                        |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 193)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 265)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.14/3 Signal handling \\<signal.h\\> (p: 246)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.7 SIGNAL HANDLING \\<signal.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/SIG_types](https://en.cppreference.com/w/c/program/SIG_types)"
- name: sin
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# sin, sinf, sinl\n\n[TABLE]\n\n1-3) Computes the sine of `arg` (measured in radians).\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`sinl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`sin`) is called. Otherwise, (1) (`sinf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`csinl`](../complex/csin \"c/numeric/complex/csin\"), [`csin`](../complex/csin \"c/numeric/complex/csin\"), [`csinf`](../complex/csin \"c/numeric/complex/csin\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                       |\n|-----|-----|-------------------------------------------------------|\n| arg | \\-  | floating-point value representing an angle in radians |\n\n### Return value\n\nIf no errors occur, the sine of `arg` (sin(arg)) in the range \\[-1 ; +1\\], is returned.\n\n|                                                                                   |             |\n|-----------------------------------------------------------------------------------|-------------|\n| The result may have little or no significance if the magnitude of `arg` is large. | (until C99) |\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nThe case where the argument is infinite is not specified to be a domain error in C, but it is defined as a [domain error in POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sin.html).\n\nPOSIX also specifies that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"sin(pi/6) = %f\\n\", sin(pi / 6));\n    printf(\"sin(pi/2) = %f\\n\", sin(pi / 2));\n    printf(\"sin(-3*pi/4) = %f\\n\", sin(-3 * pi / 4));\n \n    // special values\n    printf(\"sin(+0) = %f\\n\", sin(0.0));\n    printf(\"sin(-0) = %f\\n\", sin(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sin(INFINITY) = %f\\n\", sin(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nsin(pi/6) = 0.500000\nsin(pi/2) = 1.000000\nsin(-3*pi/4) = -0.707107\nsin(+0) = 0.000000\nsin(-0) = -0.000000\nsin(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.6 The sin functions (p: TBD)\n  - 7.27 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.6 The sin functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.6 The sin functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.6 The sin functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.6 The sin functions (p: 239-240)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.6 The sin functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.6 The sin functions (p: 220)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.6 The sin functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.6 The sin function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sin](https://en.cppreference.com/w/c/numeric/math/sin)"
- name: sinf
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# sin, sinf, sinl\n\n[TABLE]\n\n1-3) Computes the sine of `arg` (measured in radians).\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`sinl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`sin`) is called. Otherwise, (1) (`sinf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`csinl`](../complex/csin \"c/numeric/complex/csin\"), [`csin`](../complex/csin \"c/numeric/complex/csin\"), [`csinf`](../complex/csin \"c/numeric/complex/csin\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                       |\n|-----|-----|-------------------------------------------------------|\n| arg | \\-  | floating-point value representing an angle in radians |\n\n### Return value\n\nIf no errors occur, the sine of `arg` (sin(arg)) in the range \\[-1 ; +1\\], is returned.\n\n|                                                                                   |             |\n|-----------------------------------------------------------------------------------|-------------|\n| The result may have little or no significance if the magnitude of `arg` is large. | (until C99) |\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nThe case where the argument is infinite is not specified to be a domain error in C, but it is defined as a [domain error in POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sin.html).\n\nPOSIX also specifies that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"sin(pi/6) = %f\\n\", sin(pi / 6));\n    printf(\"sin(pi/2) = %f\\n\", sin(pi / 2));\n    printf(\"sin(-3*pi/4) = %f\\n\", sin(-3 * pi / 4));\n \n    // special values\n    printf(\"sin(+0) = %f\\n\", sin(0.0));\n    printf(\"sin(-0) = %f\\n\", sin(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sin(INFINITY) = %f\\n\", sin(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nsin(pi/6) = 0.500000\nsin(pi/2) = 1.000000\nsin(-3*pi/4) = -0.707107\nsin(+0) = 0.000000\nsin(-0) = -0.000000\nsin(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.6 The sin functions (p: TBD)\n  - 7.27 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.6 The sin functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.6 The sin functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.6 The sin functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.6 The sin functions (p: 239-240)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.6 The sin functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.6 The sin functions (p: 220)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.6 The sin functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.6 The sin function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sin](https://en.cppreference.com/w/c/numeric/math/sin)"
- name: sinh
  summary: If a range error due to overflow occurs, ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL is returned
  description: "# sinh, sinhf, sinhl\n\n[TABLE]\n\n1-3) Computes hyperbolic sine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `sinhl` is called. Otherwise, if the argument has integer type or the type `double`, `sinh` is called. Otherwise, `sinhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`csinhf`](http://en.cppreference.com/w/c/numeric/complex/csinh), [`csinh`](http://en.cppreference.com/w/c/numeric/complex/csinh), [`csinhl`](http://en.cppreference.com/w/c/numeric/complex/csinh)).\n\n### Parameters\n\n|     |     |                                                      |\n|-----|-----|------------------------------------------------------|\n| arg | \\-  | floating point value representing a hyperbolic angle |\n\n### Return value\n\nIf no errors occur, the hyperbolic sine of `arg` (sinh(arg), or earg-e-arg/2) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0 or ±∞, it is returned unmodified\n- if the argument is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sinh.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"sinh(1) = %f\\nsinh(-1)=%f\\n\", sinh(1), sinh(-1));\n    printf(\"log(sinh(1) + cosh(1))=%f\\n\", log(sinh(1)+cosh(1)));\n    // special values\n    printf(\"sinh(+0) = %f\\nsinh(-0)=%f\\n\", sinh(0.0), sinh(-0.0));\n    // error handling \n    errno=0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sinh(710.5) = %f\\n\", sinh(710.5));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nsinh(1) = 1.175201\nsinh(-1)=-1.175201\nlog(sinh(1) + cosh(1))=1.000000\nsinh(+0) = 0.000000\nsinh(-0)=-0.000000\nsinh(710.5) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.5 The sinh functions (p: 176)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.2.5 The sinh functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.5 The sinh functions (p: 241-242)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.5 The sinh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.5 The sinh functions (p: 222)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.5 The sinh functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.3.2 The sinh function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sinh](https://en.cppreference.com/w/c/numeric/math/sinh)"
- name: sinhf
  summary: If a range error due to overflow occurs, ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL is returned
  description: "# sinh, sinhf, sinhl\n\n[TABLE]\n\n1-3) Computes hyperbolic sine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `sinhl` is called. Otherwise, if the argument has integer type or the type `double`, `sinh` is called. Otherwise, `sinhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`csinhf`](http://en.cppreference.com/w/c/numeric/complex/csinh), [`csinh`](http://en.cppreference.com/w/c/numeric/complex/csinh), [`csinhl`](http://en.cppreference.com/w/c/numeric/complex/csinh)).\n\n### Parameters\n\n|     |     |                                                      |\n|-----|-----|------------------------------------------------------|\n| arg | \\-  | floating point value representing a hyperbolic angle |\n\n### Return value\n\nIf no errors occur, the hyperbolic sine of `arg` (sinh(arg), or earg-e-arg/2) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0 or ±∞, it is returned unmodified\n- if the argument is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sinh.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"sinh(1) = %f\\nsinh(-1)=%f\\n\", sinh(1), sinh(-1));\n    printf(\"log(sinh(1) + cosh(1))=%f\\n\", log(sinh(1)+cosh(1)));\n    // special values\n    printf(\"sinh(+0) = %f\\nsinh(-0)=%f\\n\", sinh(0.0), sinh(-0.0));\n    // error handling \n    errno=0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sinh(710.5) = %f\\n\", sinh(710.5));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nsinh(1) = 1.175201\nsinh(-1)=-1.175201\nlog(sinh(1) + cosh(1))=1.000000\nsinh(+0) = 0.000000\nsinh(-0)=-0.000000\nsinh(710.5) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.5 The sinh functions (p: 176)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.2.5 The sinh functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.5 The sinh functions (p: 241-242)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.5 The sinh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.5 The sinh functions (p: 222)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.5 The sinh functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.3.2 The sinh function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sinh](https://en.cppreference.com/w/c/numeric/math/sinh)"
- name: sinhl
  summary: If a range error due to overflow occurs, ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL is returned
  description: "# sinh, sinhf, sinhl\n\n[TABLE]\n\n1-3) Computes hyperbolic sine of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `sinhl` is called. Otherwise, if the argument has integer type or the type `double`, `sinh` is called. Otherwise, `sinhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`csinhf`](http://en.cppreference.com/w/c/numeric/complex/csinh), [`csinh`](http://en.cppreference.com/w/c/numeric/complex/csinh), [`csinhl`](http://en.cppreference.com/w/c/numeric/complex/csinh)).\n\n### Parameters\n\n|     |     |                                                      |\n|-----|-----|------------------------------------------------------|\n| arg | \\-  | floating point value representing a hyperbolic angle |\n\n### Return value\n\nIf no errors occur, the hyperbolic sine of `arg` (sinh(arg), or earg-e-arg/2) is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0 or ±∞, it is returned unmodified\n- if the argument is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sinh.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n// #pragma STDC FENV_ACCESS ON\nint main(void)\n{\n    printf(\"sinh(1) = %f\\nsinh(-1)=%f\\n\", sinh(1), sinh(-1));\n    printf(\"log(sinh(1) + cosh(1))=%f\\n\", log(sinh(1)+cosh(1)));\n    // special values\n    printf(\"sinh(+0) = %f\\nsinh(-0)=%f\\n\", sinh(0.0), sinh(-0.0));\n    // error handling \n    errno=0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sinh(710.5) = %f\\n\", sinh(710.5));\n    if(errno == ERANGE) perror(\"    errno == ERANGE\");\n    if(fetestexcept(FE_OVERFLOW)) puts(\"    FE_OVERFLOW raised\");\n}\n```\n\nPossible output:\n\n```\nsinh(1) = 1.175201\nsinh(-1)=-1.175201\nlog(sinh(1) + cosh(1))=1.000000\nsinh(+0) = 0.000000\nsinh(-0)=-0.000000\nsinh(710.5) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.5.5 The sinh functions (p: 176)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.2.5 The sinh functions (p: 379)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.5 The sinh functions (p: 241-242)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.5 The sinh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.5 The sinh functions (p: 222)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.5 The sinh functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.3.2 The sinh function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sinh](https://en.cppreference.com/w/c/numeric/math/sinh)"
- name: sinl
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# sin, sinf, sinl\n\n[TABLE]\n\n1-3) Computes the sine of `arg` (measured in radians).\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`sinl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`sin`) is called. Otherwise, (1) (`sinf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`csinl`](../complex/csin \"c/numeric/complex/csin\"), [`csin`](../complex/csin \"c/numeric/complex/csin\"), [`csinf`](../complex/csin \"c/numeric/complex/csin\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                       |\n|-----|-----|-------------------------------------------------------|\n| arg | \\-  | floating-point value representing an angle in radians |\n\n### Return value\n\nIf no errors occur, the sine of `arg` (sin(arg)) in the range \\[-1 ; +1\\], is returned.\n\n|                                                                                   |             |\n|-----------------------------------------------------------------------------------|-------------|\n| The result may have little or no significance if the magnitude of `arg` is large. | (until C99) |\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nThe case where the argument is infinite is not specified to be a domain error in C, but it is defined as a [domain error in POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sin.html).\n\nPOSIX also specifies that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than [`DBL_MIN`](../../types/limits \"c/types/limits\"), [`FLT_MIN`](../../types/limits \"c/types/limits\"), and [`LDBL_MIN`](../../types/limits \"c/types/limits\") is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"sin(pi/6) = %f\\n\", sin(pi / 6));\n    printf(\"sin(pi/2) = %f\\n\", sin(pi / 2));\n    printf(\"sin(-3*pi/4) = %f\\n\", sin(-3 * pi / 4));\n \n    // special values\n    printf(\"sin(+0) = %f\\n\", sin(0.0));\n    printf(\"sin(-0) = %f\\n\", sin(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sin(INFINITY) = %f\\n\", sin(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nsin(pi/6) = 0.500000\nsin(pi/2) = 1.000000\nsin(-3*pi/4) = -0.707107\nsin(+0) = 0.000000\nsin(-0) = -0.000000\nsin(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.6 The sin functions (p: TBD)\n  - 7.27 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.6 The sin functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.6 The sin functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.6 The sin functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.6 The sin functions (p: 239-240)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.6 The sin functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.6 The sin functions (p: 220)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.6 The sin functions (p: 456)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.6 The sin function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sin](https://en.cppreference.com/w/c/numeric/math/sin)"
- name: sinpi
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# sinpi, sinpif, sinpil, sinpid32, sinpid64, sinpid128\n\n[TABLE]\n\n1-6) Computes the sine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the sine of `π·arg` (sin(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of sinpi family\ndouble sinpi(double arg)\n{\n    return sin(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"sinpi(1) = %f, sin(pi) = %f\\n\", sinpi(1), sin(pi));\n    printf(\"sinpi(0.5) = %f, sin(pi/2) = %f\\n\", sinpi(0.5), sin(pi / 2));\n    printf(\"sinpi(-0.75) = %f, sin(-3*pi/4) = %f\\n\", sinpi(-0.75), sin(-3 * pi / 4));\n \n    // special values\n    printf(\"sinpi(+0) = %f\\n\", sinpi(0.0));\n    printf(\"sinpi(-0) = %f\\n\", sinpi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sinpi(INFINITY) = %f\\n\", sinpi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nsinpi(1) = 0.000000, sin(pi) = 0.000000\nsinpi(0.5) = 1.000000, sin(pi/2) = 1.000000\nsinpi(-0.75) = -0.707107, sin(-3*pi/4) = -0.707107\nsinpi(+0) = 0.000000\nsinpi(-0) = -0.000000\nsinpi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.13 The sinpi functions (p: 247-248)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sinpi](https://en.cppreference.com/w/c/numeric/math/sinpi)"
- name: sinpid128
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# sinpi, sinpif, sinpil, sinpid32, sinpid64, sinpid128\n\n[TABLE]\n\n1-6) Computes the sine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the sine of `π·arg` (sin(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of sinpi family\ndouble sinpi(double arg)\n{\n    return sin(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"sinpi(1) = %f, sin(pi) = %f\\n\", sinpi(1), sin(pi));\n    printf(\"sinpi(0.5) = %f, sin(pi/2) = %f\\n\", sinpi(0.5), sin(pi / 2));\n    printf(\"sinpi(-0.75) = %f, sin(-3*pi/4) = %f\\n\", sinpi(-0.75), sin(-3 * pi / 4));\n \n    // special values\n    printf(\"sinpi(+0) = %f\\n\", sinpi(0.0));\n    printf(\"sinpi(-0) = %f\\n\", sinpi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sinpi(INFINITY) = %f\\n\", sinpi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nsinpi(1) = 0.000000, sin(pi) = 0.000000\nsinpi(0.5) = 1.000000, sin(pi/2) = 1.000000\nsinpi(-0.75) = -0.707107, sin(-3*pi/4) = -0.707107\nsinpi(+0) = 0.000000\nsinpi(-0) = -0.000000\nsinpi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.13 The sinpi functions (p: 247-248)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sinpi](https://en.cppreference.com/w/c/numeric/math/sinpi)"
- name: sinpid32
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# sinpi, sinpif, sinpil, sinpid32, sinpid64, sinpid128\n\n[TABLE]\n\n1-6) Computes the sine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the sine of `π·arg` (sin(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of sinpi family\ndouble sinpi(double arg)\n{\n    return sin(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"sinpi(1) = %f, sin(pi) = %f\\n\", sinpi(1), sin(pi));\n    printf(\"sinpi(0.5) = %f, sin(pi/2) = %f\\n\", sinpi(0.5), sin(pi / 2));\n    printf(\"sinpi(-0.75) = %f, sin(-3*pi/4) = %f\\n\", sinpi(-0.75), sin(-3 * pi / 4));\n \n    // special values\n    printf(\"sinpi(+0) = %f\\n\", sinpi(0.0));\n    printf(\"sinpi(-0) = %f\\n\", sinpi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sinpi(INFINITY) = %f\\n\", sinpi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nsinpi(1) = 0.000000, sin(pi) = 0.000000\nsinpi(0.5) = 1.000000, sin(pi/2) = 1.000000\nsinpi(-0.75) = -0.707107, sin(-3*pi/4) = -0.707107\nsinpi(+0) = 0.000000\nsinpi(-0) = -0.000000\nsinpi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.13 The sinpi functions (p: 247-248)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sinpi](https://en.cppreference.com/w/c/numeric/math/sinpi)"
- name: sinpid64
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# sinpi, sinpif, sinpil, sinpid32, sinpid64, sinpid128\n\n[TABLE]\n\n1-6) Computes the sine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the sine of `π·arg` (sin(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of sinpi family\ndouble sinpi(double arg)\n{\n    return sin(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"sinpi(1) = %f, sin(pi) = %f\\n\", sinpi(1), sin(pi));\n    printf(\"sinpi(0.5) = %f, sin(pi/2) = %f\\n\", sinpi(0.5), sin(pi / 2));\n    printf(\"sinpi(-0.75) = %f, sin(-3*pi/4) = %f\\n\", sinpi(-0.75), sin(-3 * pi / 4));\n \n    // special values\n    printf(\"sinpi(+0) = %f\\n\", sinpi(0.0));\n    printf(\"sinpi(-0) = %f\\n\", sinpi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sinpi(INFINITY) = %f\\n\", sinpi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nsinpi(1) = 0.000000, sin(pi) = 0.000000\nsinpi(0.5) = 1.000000, sin(pi/2) = 1.000000\nsinpi(-0.75) = -0.707107, sin(-3*pi/4) = -0.707107\nsinpi(+0) = 0.000000\nsinpi(-0) = -0.000000\nsinpi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.13 The sinpi functions (p: 247-248)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sinpi](https://en.cppreference.com/w/c/numeric/math/sinpi)"
- name: sinpif
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# sinpi, sinpif, sinpil, sinpid32, sinpid64, sinpid128\n\n[TABLE]\n\n1-6) Computes the sine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the sine of `π·arg` (sin(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of sinpi family\ndouble sinpi(double arg)\n{\n    return sin(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"sinpi(1) = %f, sin(pi) = %f\\n\", sinpi(1), sin(pi));\n    printf(\"sinpi(0.5) = %f, sin(pi/2) = %f\\n\", sinpi(0.5), sin(pi / 2));\n    printf(\"sinpi(-0.75) = %f, sin(-3*pi/4) = %f\\n\", sinpi(-0.75), sin(-3 * pi / 4));\n \n    // special values\n    printf(\"sinpi(+0) = %f\\n\", sinpi(0.0));\n    printf(\"sinpi(-0) = %f\\n\", sinpi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sinpi(INFINITY) = %f\\n\", sinpi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nsinpi(1) = 0.000000, sin(pi) = 0.000000\nsinpi(0.5) = 1.000000, sin(pi/2) = 1.000000\nsinpi(-0.75) = -0.707107, sin(-3*pi/4) = -0.707107\nsinpi(+0) = 0.000000\nsinpi(-0) = -0.000000\nsinpi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.13 The sinpi functions (p: 247-248)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sinpi](https://en.cppreference.com/w/c/numeric/math/sinpi)"
- name: sinpil
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# sinpi, sinpif, sinpil, sinpid32, sinpid64, sinpid128\n\n[TABLE]\n\n1-6) Computes the sine of `π·arg` measured in radians, thus regarding `arg` as a measurement in half-revolutions.\n\n7) Type-generic macro: calls the correct function based on the type of `arg`. If the argument has integer type, (2) is called.\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                                            |\n|-----|-----|----------------------------------------------------------------------------|\n| arg | \\-  | floating-point value whose product with `π` represents an angle in radians |\n\n### Return value\n\nIf no errors occur, the sine of `π·arg` (sin(π×arg)) in the range \\[-1, +1\\], is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \n#if __STDC_VERSION__ < 202311L\n// A naive implementation of a subset of sinpi family\ndouble sinpi(double arg)\n{\n    return sin(arg * (double)3.1415926535897932384626433);\n}\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"sinpi(1) = %f, sin(pi) = %f\\n\", sinpi(1), sin(pi));\n    printf(\"sinpi(0.5) = %f, sin(pi/2) = %f\\n\", sinpi(0.5), sin(pi / 2));\n    printf(\"sinpi(-0.75) = %f, sin(-3*pi/4) = %f\\n\", sinpi(-0.75), sin(-3 * pi / 4));\n \n    // special values\n    printf(\"sinpi(+0) = %f\\n\", sinpi(0.0));\n    printf(\"sinpi(-0) = %f\\n\", sinpi(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sinpi(INFINITY) = %f\\n\", sinpi(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\nsinpi(1) = 0.000000, sin(pi) = 0.000000\nsinpi(0.5) = 1.000000, sin(pi/2) = 1.000000\nsinpi(-0.75) = -0.707107, sin(-3*pi/4) = -0.707107\nsinpi(+0) = 0.000000\nsinpi(-0) = -0.000000\nsinpi(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.13 The sinpi functions (p: 247-248)\n  - 7.27 Type generic math \\<tgmath.h\\> (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sinpi](https://en.cppreference.com/w/c/numeric/math/sinpi)"
- name: size_t
  summary: size_t is the unsigned integer type of the result of sizeof , _Alignof(since C11) and offsetof, depending on the data model
  description: "# size_t\n\n[TABLE]\n\n`size_t` is the unsigned integer type of the result of [`sizeof`](../language/sizeof \"c/language/sizeof\") , [`_Alignof`](../language/_alignof \"c/language/ Alignof\")(since C11) and [`offsetof`](offsetof \"c/types/offsetof\"), depending on the [data model](../language/arithmetic_types#Data_models \"c/language/arithmetic types\").\n\n|                                                |             |\n|------------------------------------------------|-------------|\n| The bit width of `size_t` is not less than 16. | (since C99) |\n\n### Notes\n\n`size_t` can store the maximum size of a theoretically possible object of any type (including array).\n\n`size_t` is commonly used for array indexing and loop counting. Programs that use other types, such as `unsigned int`, for array indexing may fail on, e.g. 64-bit systems when the index exceeds [`UINT_MAX`](limits \"c/types/limits\") or if it relies on 32-bit modular arithmetic.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stddef.h>\n#include <stdint.h>\n \nint main(void)\n{\n    const size_t N = 100;\n    int numbers[N];\n    for (size_t ndx = 0; ndx < N; ++ndx)\n        numbers[ndx] = ndx;\n    printf(\"SIZE_MAX = %zu\\n\", SIZE_MAX);\n    size_t size = sizeof numbers;\n    printf(\"size = %zu\\n\", size);\n}\n```\n\nPossible output:\n\n```\nSIZE_MAX = 18446744073709551615\nsize = 400\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.19 Common definitions \\<stddef.h\\> (p: 211)\n  - 7.20.3 Limits of other integer types (p: 215)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.19 Common definitions \\<stddef.h\\> (p: 288)\n  - 7.20.3 Limits of other integer types (p: 293)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.17 Common definitions \\<stddef.h\\> (p: 253)\n  - 7.18.3 Limits of other integer types (p: 258)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.1.6 Common definitions \\<stddef.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types/size_t](https://en.cppreference.com/w/c/types/size_t)"
- name: sizeof
  summary: ''
  description: "# C keywords: sizeof\n\n### Usage\n\n- [`sizeof` operator](../language/sizeof \"c/language/sizeof\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/sizeof](https://en.cppreference.com/w/c/keyword/sizeof)"
- name: sizeof operator
  summary: Queries size of the object or type
  description: "# sizeof operator\n\nQueries size of the object or type.\n\nUsed when actual size of the object must be known.\n\n### Syntax\n\n|                     |       |     |\n|---------------------|-------|-----|\n| `sizeof(` type `)`  | \\(1\\) |     |\n| `sizeof` expression | \\(2\\) |     |\n\nBoth versions return a value of type [`size_t`](../types/size_t \"c/types/size t\").\n\n### Explanation\n\n1) Returns the size, in bytes, of the [object representation](object#Object_representation \"c/language/object\") of type\n\n2) Returns the size, in bytes, of the object representation of the type of expression. No implicit conversions are applied to expression.\n\n### Notes\n\nDepending on the computer architecture, a [byte](https://en.wikipedia.org/wiki/byte \"enwiki:byte\") may consist of 8 or more bits, the exact number provided as [`CHAR_BIT`](../types/limits \"c/types/limits\").\n\n`sizeof(char)`, `sizeof(signed char)`, and `sizeof(unsigned char)` always return `1`.\n\nsizeof cannot be used with function types, incomplete types (including `void`), or [bit-field](bit_field \"c/language/bit field\") lvalues.\n\nWhen applied to an operand that has [structure](struct \"c/language/struct\") or [union](union \"c/language/union\") type, the result is the total number of bytes in such an object, including internal and trailing padding. The trailing padding is such that if the object were an element of an array, the alignment requirement of the next element of this array would be satisfied, in other words, `sizeof(T)` returns the size of an element of a `T[]` array.\n\n|                                                                                                                                                                                                             |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If type is a [VLA](array \"c/language/array\") type and changing the value of its size expression would not affect the result of `sizeof`, it is unspecified whether or not the size expression is evaluated. | (since C99) |\n\nExcept if the type of expression is a [VLA](array \"c/language/array\"),(since C99)expression is not evaluated and the `sizeof` operator may be used in an integer [constant expression](constant_expression \"c/language/constant expression\").\n\n|                                                                                                                                                                                     |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If the type of expression is a [variable-length array](array \"c/language/array\") type, expression is evaluated and the size of the array it evaluates to is calculated at run time. | (since C99) |\n\nNumber of elements in any [array](array \"c/language/array\") `a` including VLA(since C99) may be determined with the expression `sizeof a / sizeof a[0]`. Note that if `a` has pointer type (such as after array-to-pointer conversion of function parameter type adjustment), this expression would simply divide the number of bytes in a pointer type by the number of bytes in the pointed type.\n\n### Keywords\n\n[`sizeof`](../keyword/sizeof \"c/keyword/sizeof\")\n\n### Example\n\nSample output corresponds to a platform with 64-bit pointers and 32-bit int\n\n```\n#include <stdio.h>\n \nint main(void)\n{\n    short x;\n    // type argument:\n    printf(\"sizeof(float)          = %zu\\n\", sizeof(float));\n    printf(\"sizeof(void(*)(void))  = %zu\\n\", sizeof(void(*)(void)));\n    printf(\"sizeof(char[10])       = %zu\\n\", sizeof(char[10]));\n//  printf(\"sizeof(void(void))     = %zu\\n\", sizeof(void(void))); // Error: function type\n//  printf(\"sizeof(char[])         = %zu\\n\", sizeof(char[])); // Error: incomplete type\n \n    // expression argument:\n    printf(\"sizeof 'a'             = %zu\\n\", sizeof 'a'); // type of 'a' is int\n//  printf(\"sizeof main            = %zu\\n\", sizeof main); // Error: Function type\n    printf(\"sizeof &main           = %zu\\n\", sizeof &main);\n    printf(\"sizeof \\\"hello\\\"         = %zu\\n\", sizeof \"hello\"); // type is char[6]\n    printf(\"sizeof x               = %zu\\n\", sizeof x); // type of x is short\n    printf(\"sizeof (x+1)           = %zu\\n\", sizeof(x + 1)); // type of x+1 is int\n}\n```\n\nPossible output:\n\n```\nsizeof(float)          = 4\nsizeof(void(*)(void))  = 8\nsizeof(char[10])       = 10\nsizeof 'a'             = 4\nsizeof &main           = 8\nsizeof \"hello\"         = 6\nsizeof x               = 2\nsizeof (x+1)           = 4\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.5.3.4 The sizeof and alignof operators (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.5.3.4 The sizeof and \\_Alignof operators (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.5.3.4 The sizeof and \\_Alignof operators (p: 90-91)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.5.3.4 The sizeof operator (p: 80-81)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.3.3.4 The sizeof operator\n\n### See also\n\n|                                                                                                                    |     |\n|--------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/sizeof \"cpp/language/sizeof\") for `sizeof` operator |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/sizeof](https://en.cppreference.com/w/c/language/sizeof)"
- name: snprintf
  summary: 'Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:'
  description: "# printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:\n\n1) Writes the results to the output stream [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to the output stream `stream`.\n\n3) Writes the results to a character string `buffer`. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz` - 1 characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `stream` or `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `sprintf_s` only), the string to be stored in `buffer` (including the trailing null) would exceed `bufsz`\n\nAs with all bounds-checked functions, `printf_s` , `fprintf_s`, `sprintf_s`, and `snprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a character string to write to                                                                                                                                                                                                                                                                                                                                                                                                |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                      |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) number of characters transmitted to the output stream or negative value if an output error or an encoding error (for string and character conversion specifiers) occurred\n\n3) number of characters written to `buffer` (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n4) number of characters (not including the terminating null character) which would have been written to `buffer` if `bufsz` was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nThe C standard and [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) specify that the behavior of `sprintf` and its variants is undefined when an argument overlaps with the destination buffer. Example:\n\n```\nsprintf(dst, \"%s and %s\", dst, t); // <- broken: undefined behavior\n```\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) that [`errno`](../error/errno \"c/error/errno\") is set on error. It also specifies additional conversion specifications, most notably support for argument reordering (`n$` immediately after `%` indicates `n`^(th) argument).\n\nCalling `snprintf` with zero `bufsz` and null pointer for `buffer` is useful to determine the necessary buffer size to contain the output:\n\n```\nconst char fmt[] = \"sqrt(2) = %f\";\nint sz = snprintf(NULL, 0, fmt, sqrt(2));\nchar buf[sz + 1]; // note +1 for terminating null byte\nsnprintf(buf, sizeof buf, fmt, sqrt(2));\n```\n\n`snprintf_s`, just like `snprintf`, but unlike `sprintf_s`, will truncate the output to fit in `bufsz-1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n \nint main(void)\n{\n    const char* s = \"Hello\";\n    printf(\"Strings:\\n\"); // same as puts(\"Strings\");\n    printf(\" padding:\\n\");\n    printf(\"\\t[%10s]\\n\", s);\n    printf(\"\\t[%-10s]\\n\", s);\n    printf(\"\\t[%*s]\\n\", 10, s);\n    printf(\" truncating:\\n\");\n    printf(\"\\t%.4s\\n\", s);\n    printf(\"\\t%.*s\\n\", 3, s);\n \n    printf(\"Characters:\\t%c %%\\n\", 'A');\n \n    printf(\"Integers:\\n\");\n    printf(\"\\tDecimal:\\t%i %d %.6i %i %.0i %+i %i\\n\",\n                         1, 2,   3, 0,   0,  4,-4);\n    printf(\"\\tHexadecimal:\\t%x %x %X %#x\\n\", 5, 10, 10, 6);\n    printf(\"\\tOctal:\\t\\t%o %#o %#o\\n\", 10, 10, 4);\n \n    printf(\"Floating point:\\n\");\n    printf(\"\\tRounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    printf(\"\\tPadding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    printf(\"\\tScientific:\\t%E %e\\n\", 1.5, 1.5);\n    printf(\"\\tHexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n    printf(\"\\tSpecial values:\\t0/0=%g 1/0=%g\\n\", 0.0/0.0, 1.0/0.0);\n \n    printf(\"Fixed-width types:\\n\");\n    printf(\"\\tLargest 32-bit value is %\" PRIu32 \" or %#\" PRIx32 \"\\n\",\n                                     UINT32_MAX,     UINT32_MAX );\n}\n```\n\nPossible output:\n\n```\nStrings:\n padding:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n truncating:\n        Hell\n        Hel\nCharacters:        A %\nIntegers:\n        Decimal:        1 2 000003 0  +4 -4\n        Hexadecimal:        5 a A 0x6\n        Octal:                12 012 04\nFloating point:\n        Rounding:        1.500000 2 1.30000000000000004440892098500626\n        Padding:        01.50 1.50  1.50\n        Scientific:        1.500000E+00 1.500000e+00\n        Hexadecimal:        0x1.8p+0 0X1.8P+0\n        Special values:        0/0=-nan 1/0=inf\nFixed-width types:\n        Largest 32-bit value is 4294967295 or 0xffffffff\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.1 The fprintf function (p: 225-230)\n  - 7.21.6.3 The printf function (p: 236)\n  - 7.21.6.5 The snprintf function (p: 237)\n  - 7.21.6.6 The sprintf function (p: 237)\n  - K.3.5.3.1 The fprintf_s function (p: 430)\n  - K.3.5.3.3 The printf_s function (p: 432)\n  - K.3.5.3.5 The snprintf_s function (p: 432-433)\n  - K.3.5.3.6 The sprintf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.1 The fprintf function (p: 309-316)\n  - 7.21.6.3 The printf function (p: 324)\n  - 7.21.6.5 The snprintf function (p: 325)\n  - 7.21.6.6 The sprintf function (p: 325-326)\n  - K.3.5.3.1 The fprintf_s function (p: 591)\n  - K.3.5.3.3 The printf_s function (p: 593-594)\n  - K.3.5.3.5 The snprintf_s function (p: 594-595)\n  - K.3.5.3.6 The sprintf_s function (p: 595-596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.1 The fprintf function (p: 274-282)\n  - 7.19.6.3 The printf function (p: 290)\n  - 7.19.6.5 The snprintf function (p: 290-291)\n  - 7.19.6.6 The sprintf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.1 The fprintf function\n  - 4.9.6.3 The printf function\n  - 4.9.6.5 The sprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fprintf](https://en.cppreference.com/w/c/io/fprintf)"
- name: snprintf_s
  summary: 'Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:'
  description: "# printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:\n\n1) Writes the results to the output stream [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to the output stream `stream`.\n\n3) Writes the results to a character string `buffer`. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz` - 1 characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `stream` or `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `sprintf_s` only), the string to be stored in `buffer` (including the trailing null) would exceed `bufsz`\n\nAs with all bounds-checked functions, `printf_s` , `fprintf_s`, `sprintf_s`, and `snprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a character string to write to                                                                                                                                                                                                                                                                                                                                                                                                |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                      |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) number of characters transmitted to the output stream or negative value if an output error or an encoding error (for string and character conversion specifiers) occurred\n\n3) number of characters written to `buffer` (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n4) number of characters (not including the terminating null character) which would have been written to `buffer` if `bufsz` was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nThe C standard and [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) specify that the behavior of `sprintf` and its variants is undefined when an argument overlaps with the destination buffer. Example:\n\n```\nsprintf(dst, \"%s and %s\", dst, t); // <- broken: undefined behavior\n```\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) that [`errno`](../error/errno \"c/error/errno\") is set on error. It also specifies additional conversion specifications, most notably support for argument reordering (`n$` immediately after `%` indicates `n`^(th) argument).\n\nCalling `snprintf` with zero `bufsz` and null pointer for `buffer` is useful to determine the necessary buffer size to contain the output:\n\n```\nconst char fmt[] = \"sqrt(2) = %f\";\nint sz = snprintf(NULL, 0, fmt, sqrt(2));\nchar buf[sz + 1]; // note +1 for terminating null byte\nsnprintf(buf, sizeof buf, fmt, sqrt(2));\n```\n\n`snprintf_s`, just like `snprintf`, but unlike `sprintf_s`, will truncate the output to fit in `bufsz-1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n \nint main(void)\n{\n    const char* s = \"Hello\";\n    printf(\"Strings:\\n\"); // same as puts(\"Strings\");\n    printf(\" padding:\\n\");\n    printf(\"\\t[%10s]\\n\", s);\n    printf(\"\\t[%-10s]\\n\", s);\n    printf(\"\\t[%*s]\\n\", 10, s);\n    printf(\" truncating:\\n\");\n    printf(\"\\t%.4s\\n\", s);\n    printf(\"\\t%.*s\\n\", 3, s);\n \n    printf(\"Characters:\\t%c %%\\n\", 'A');\n \n    printf(\"Integers:\\n\");\n    printf(\"\\tDecimal:\\t%i %d %.6i %i %.0i %+i %i\\n\",\n                         1, 2,   3, 0,   0,  4,-4);\n    printf(\"\\tHexadecimal:\\t%x %x %X %#x\\n\", 5, 10, 10, 6);\n    printf(\"\\tOctal:\\t\\t%o %#o %#o\\n\", 10, 10, 4);\n \n    printf(\"Floating point:\\n\");\n    printf(\"\\tRounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    printf(\"\\tPadding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    printf(\"\\tScientific:\\t%E %e\\n\", 1.5, 1.5);\n    printf(\"\\tHexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n    printf(\"\\tSpecial values:\\t0/0=%g 1/0=%g\\n\", 0.0/0.0, 1.0/0.0);\n \n    printf(\"Fixed-width types:\\n\");\n    printf(\"\\tLargest 32-bit value is %\" PRIu32 \" or %#\" PRIx32 \"\\n\",\n                                     UINT32_MAX,     UINT32_MAX );\n}\n```\n\nPossible output:\n\n```\nStrings:\n padding:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n truncating:\n        Hell\n        Hel\nCharacters:        A %\nIntegers:\n        Decimal:        1 2 000003 0  +4 -4\n        Hexadecimal:        5 a A 0x6\n        Octal:                12 012 04\nFloating point:\n        Rounding:        1.500000 2 1.30000000000000004440892098500626\n        Padding:        01.50 1.50  1.50\n        Scientific:        1.500000E+00 1.500000e+00\n        Hexadecimal:        0x1.8p+0 0X1.8P+0\n        Special values:        0/0=-nan 1/0=inf\nFixed-width types:\n        Largest 32-bit value is 4294967295 or 0xffffffff\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.1 The fprintf function (p: 225-230)\n  - 7.21.6.3 The printf function (p: 236)\n  - 7.21.6.5 The snprintf function (p: 237)\n  - 7.21.6.6 The sprintf function (p: 237)\n  - K.3.5.3.1 The fprintf_s function (p: 430)\n  - K.3.5.3.3 The printf_s function (p: 432)\n  - K.3.5.3.5 The snprintf_s function (p: 432-433)\n  - K.3.5.3.6 The sprintf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.1 The fprintf function (p: 309-316)\n  - 7.21.6.3 The printf function (p: 324)\n  - 7.21.6.5 The snprintf function (p: 325)\n  - 7.21.6.6 The sprintf function (p: 325-326)\n  - K.3.5.3.1 The fprintf_s function (p: 591)\n  - K.3.5.3.3 The printf_s function (p: 593-594)\n  - K.3.5.3.5 The snprintf_s function (p: 594-595)\n  - K.3.5.3.6 The sprintf_s function (p: 595-596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.1 The fprintf function (p: 274-282)\n  - 7.19.6.3 The printf function (p: 290)\n  - 7.19.6.5 The snprintf function (p: 290-291)\n  - 7.19.6.6 The sprintf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.1 The fprintf function\n  - 4.9.6.3 The printf function\n  - 4.9.6.5 The sprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fprintf](https://en.cppreference.com/w/c/io/fprintf)"
- name: snwprintf_s
  summary: Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# wprintf, fwprintf, swprintf, wprintf_s, fwprintf_s, swprintf_s, snwprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) If `bufsz` is greater than zero, writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. If `bufsz` is zero, nothing is written (and `buffer` may be a null pointer).\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (only for `swprintf_s`) the number of wide characters to be written, including the null, would exceed `bufsz`.\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by s. As with all bounds-checked functions, `wprintf_s` , `fwprintf_s`, `swprintf_s`, and `snwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a wide character string to write to                                                                                                                                                                                                                                                                                                                                                                                           |\n| bufsz  | \\-  | up to `bufsz-1` wide characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                 |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) Number of wide characters written if successful or negative value if an error occurred.\n\n3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than `size` (including when `size` is zero).\n\n4,5) Number of wide characters written if successful or negative value if an error occurred.\n\n6) Number of wide characters (not counting the terminating null) that were written to `buffer`. Returns a negative value on encoding errors and on overflow. Returns zero on all other errors.\n\n7) Number of wide characters (not counting the terminating null) that would have been written to `buffer` had `bufsz` been sufficiently large, or a negative value if an error occurs. (meaning, write was successful and complete only if the return is nonnegative and less than `bufsz`)\n\n### Notes\n\nWhile narrow strings provide [`snprintf`](fprintf \"c/io/fprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until `snwprintf_s`)(since C11), and in order to determine the buffer size, the program may need to call `swprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`snwprintf_s`, unlike `swprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    char narrow_str[] = \"z\\u00df\\u6c34\\U0001f34c\";\n                    // or \"zß水🍌\"\n                    // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator\n    setlocale(LC_ALL, \"en_US.utf8\");\n    swprintf(warr, sizeof warr/sizeof *warr,\n              L\"Converted from UTF-8: '%s'\", narrow_str);\n    wprintf(L\"%ls\\n\", warr);\n}\n```\n\nOutput:\n\n```\nConverted from UTF-8: 'zß水🍌'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.1 The fwprintf function (p: 403-410)\n  - 7.29.2.3 The swprintf function (p: 416)\n  - 7.29.2.11 The wprintf function (p: 421)\n  - K.3.9.1.1 The fwprintf_s function (p: 628)\n  - K.3.9.1.4 The swprintf_s function (p: 630-631)\n  - K.3.9.1.13 The wprintf_s function (p: 637-638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.1 The fwprintf function (p: 349-356)\n  - 7.24.2.3 The swprintf function (p: 362)\n  - 7.24.2.11 The wprintf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwprintf](https://en.cppreference.com/w/c/io/fwprintf)"
- name: sprintf
  summary: 'Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:'
  description: "# printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:\n\n1) Writes the results to the output stream [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to the output stream `stream`.\n\n3) Writes the results to a character string `buffer`. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz` - 1 characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `stream` or `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `sprintf_s` only), the string to be stored in `buffer` (including the trailing null) would exceed `bufsz`\n\nAs with all bounds-checked functions, `printf_s` , `fprintf_s`, `sprintf_s`, and `snprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a character string to write to                                                                                                                                                                                                                                                                                                                                                                                                |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                      |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) number of characters transmitted to the output stream or negative value if an output error or an encoding error (for string and character conversion specifiers) occurred\n\n3) number of characters written to `buffer` (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n4) number of characters (not including the terminating null character) which would have been written to `buffer` if `bufsz` was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nThe C standard and [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) specify that the behavior of `sprintf` and its variants is undefined when an argument overlaps with the destination buffer. Example:\n\n```\nsprintf(dst, \"%s and %s\", dst, t); // <- broken: undefined behavior\n```\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) that [`errno`](../error/errno \"c/error/errno\") is set on error. It also specifies additional conversion specifications, most notably support for argument reordering (`n$` immediately after `%` indicates `n`^(th) argument).\n\nCalling `snprintf` with zero `bufsz` and null pointer for `buffer` is useful to determine the necessary buffer size to contain the output:\n\n```\nconst char fmt[] = \"sqrt(2) = %f\";\nint sz = snprintf(NULL, 0, fmt, sqrt(2));\nchar buf[sz + 1]; // note +1 for terminating null byte\nsnprintf(buf, sizeof buf, fmt, sqrt(2));\n```\n\n`snprintf_s`, just like `snprintf`, but unlike `sprintf_s`, will truncate the output to fit in `bufsz-1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n \nint main(void)\n{\n    const char* s = \"Hello\";\n    printf(\"Strings:\\n\"); // same as puts(\"Strings\");\n    printf(\" padding:\\n\");\n    printf(\"\\t[%10s]\\n\", s);\n    printf(\"\\t[%-10s]\\n\", s);\n    printf(\"\\t[%*s]\\n\", 10, s);\n    printf(\" truncating:\\n\");\n    printf(\"\\t%.4s\\n\", s);\n    printf(\"\\t%.*s\\n\", 3, s);\n \n    printf(\"Characters:\\t%c %%\\n\", 'A');\n \n    printf(\"Integers:\\n\");\n    printf(\"\\tDecimal:\\t%i %d %.6i %i %.0i %+i %i\\n\",\n                         1, 2,   3, 0,   0,  4,-4);\n    printf(\"\\tHexadecimal:\\t%x %x %X %#x\\n\", 5, 10, 10, 6);\n    printf(\"\\tOctal:\\t\\t%o %#o %#o\\n\", 10, 10, 4);\n \n    printf(\"Floating point:\\n\");\n    printf(\"\\tRounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    printf(\"\\tPadding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    printf(\"\\tScientific:\\t%E %e\\n\", 1.5, 1.5);\n    printf(\"\\tHexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n    printf(\"\\tSpecial values:\\t0/0=%g 1/0=%g\\n\", 0.0/0.0, 1.0/0.0);\n \n    printf(\"Fixed-width types:\\n\");\n    printf(\"\\tLargest 32-bit value is %\" PRIu32 \" or %#\" PRIx32 \"\\n\",\n                                     UINT32_MAX,     UINT32_MAX );\n}\n```\n\nPossible output:\n\n```\nStrings:\n padding:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n truncating:\n        Hell\n        Hel\nCharacters:        A %\nIntegers:\n        Decimal:        1 2 000003 0  +4 -4\n        Hexadecimal:        5 a A 0x6\n        Octal:                12 012 04\nFloating point:\n        Rounding:        1.500000 2 1.30000000000000004440892098500626\n        Padding:        01.50 1.50  1.50\n        Scientific:        1.500000E+00 1.500000e+00\n        Hexadecimal:        0x1.8p+0 0X1.8P+0\n        Special values:        0/0=-nan 1/0=inf\nFixed-width types:\n        Largest 32-bit value is 4294967295 or 0xffffffff\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.1 The fprintf function (p: 225-230)\n  - 7.21.6.3 The printf function (p: 236)\n  - 7.21.6.5 The snprintf function (p: 237)\n  - 7.21.6.6 The sprintf function (p: 237)\n  - K.3.5.3.1 The fprintf_s function (p: 430)\n  - K.3.5.3.3 The printf_s function (p: 432)\n  - K.3.5.3.5 The snprintf_s function (p: 432-433)\n  - K.3.5.3.6 The sprintf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.1 The fprintf function (p: 309-316)\n  - 7.21.6.3 The printf function (p: 324)\n  - 7.21.6.5 The snprintf function (p: 325)\n  - 7.21.6.6 The sprintf function (p: 325-326)\n  - K.3.5.3.1 The fprintf_s function (p: 591)\n  - K.3.5.3.3 The printf_s function (p: 593-594)\n  - K.3.5.3.5 The snprintf_s function (p: 594-595)\n  - K.3.5.3.6 The sprintf_s function (p: 595-596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.1 The fprintf function (p: 274-282)\n  - 7.19.6.3 The printf function (p: 290)\n  - 7.19.6.5 The snprintf function (p: 290-291)\n  - 7.19.6.6 The sprintf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.1 The fprintf function\n  - 4.9.6.3 The printf function\n  - 4.9.6.5 The sprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fprintf](https://en.cppreference.com/w/c/io/fprintf)"
- name: sprintf_s
  summary: 'Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:'
  description: "# printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks/streams:\n\n1) Writes the results to the output stream [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to the output stream `stream`.\n\n3) Writes the results to a character string `buffer`. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz` - 1 characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `stream` or `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `sprintf_s` only), the string to be stored in `buffer` (including the trailing null) would exceed `bufsz`\n\nAs with all bounds-checked functions, `printf_s` , `fprintf_s`, `sprintf_s`, and `snprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a character string to write to                                                                                                                                                                                                                                                                                                                                                                                                |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                      |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) number of characters transmitted to the output stream or negative value if an output error or an encoding error (for string and character conversion specifiers) occurred\n\n3) number of characters written to `buffer` (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n4) number of characters (not including the terminating null character) which would have been written to `buffer` if `bufsz` was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nThe C standard and [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) specify that the behavior of `sprintf` and its variants is undefined when an argument overlaps with the destination buffer. Example:\n\n```\nsprintf(dst, \"%s and %s\", dst, t); // <- broken: undefined behavior\n```\n\n[POSIX specifies](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html) that [`errno`](../error/errno \"c/error/errno\") is set on error. It also specifies additional conversion specifications, most notably support for argument reordering (`n$` immediately after `%` indicates `n`^(th) argument).\n\nCalling `snprintf` with zero `bufsz` and null pointer for `buffer` is useful to determine the necessary buffer size to contain the output:\n\n```\nconst char fmt[] = \"sqrt(2) = %f\";\nint sz = snprintf(NULL, 0, fmt, sqrt(2));\nchar buf[sz + 1]; // note +1 for terminating null byte\nsnprintf(buf, sizeof buf, fmt, sqrt(2));\n```\n\n`snprintf_s`, just like `snprintf`, but unlike `sprintf_s`, will truncate the output to fit in `bufsz-1`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n \nint main(void)\n{\n    const char* s = \"Hello\";\n    printf(\"Strings:\\n\"); // same as puts(\"Strings\");\n    printf(\" padding:\\n\");\n    printf(\"\\t[%10s]\\n\", s);\n    printf(\"\\t[%-10s]\\n\", s);\n    printf(\"\\t[%*s]\\n\", 10, s);\n    printf(\" truncating:\\n\");\n    printf(\"\\t%.4s\\n\", s);\n    printf(\"\\t%.*s\\n\", 3, s);\n \n    printf(\"Characters:\\t%c %%\\n\", 'A');\n \n    printf(\"Integers:\\n\");\n    printf(\"\\tDecimal:\\t%i %d %.6i %i %.0i %+i %i\\n\",\n                         1, 2,   3, 0,   0,  4,-4);\n    printf(\"\\tHexadecimal:\\t%x %x %X %#x\\n\", 5, 10, 10, 6);\n    printf(\"\\tOctal:\\t\\t%o %#o %#o\\n\", 10, 10, 4);\n \n    printf(\"Floating point:\\n\");\n    printf(\"\\tRounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    printf(\"\\tPadding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    printf(\"\\tScientific:\\t%E %e\\n\", 1.5, 1.5);\n    printf(\"\\tHexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n    printf(\"\\tSpecial values:\\t0/0=%g 1/0=%g\\n\", 0.0/0.0, 1.0/0.0);\n \n    printf(\"Fixed-width types:\\n\");\n    printf(\"\\tLargest 32-bit value is %\" PRIu32 \" or %#\" PRIx32 \"\\n\",\n                                     UINT32_MAX,     UINT32_MAX );\n}\n```\n\nPossible output:\n\n```\nStrings:\n padding:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n truncating:\n        Hell\n        Hel\nCharacters:        A %\nIntegers:\n        Decimal:        1 2 000003 0  +4 -4\n        Hexadecimal:        5 a A 0x6\n        Octal:                12 012 04\nFloating point:\n        Rounding:        1.500000 2 1.30000000000000004440892098500626\n        Padding:        01.50 1.50  1.50\n        Scientific:        1.500000E+00 1.500000e+00\n        Hexadecimal:        0x1.8p+0 0X1.8P+0\n        Special values:        0/0=-nan 1/0=inf\nFixed-width types:\n        Largest 32-bit value is 4294967295 or 0xffffffff\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.1 The fprintf function (p: 225-230)\n  - 7.21.6.3 The printf function (p: 236)\n  - 7.21.6.5 The snprintf function (p: 237)\n  - 7.21.6.6 The sprintf function (p: 237)\n  - K.3.5.3.1 The fprintf_s function (p: 430)\n  - K.3.5.3.3 The printf_s function (p: 432)\n  - K.3.5.3.5 The snprintf_s function (p: 432-433)\n  - K.3.5.3.6 The sprintf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.1 The fprintf function (p: 309-316)\n  - 7.21.6.3 The printf function (p: 324)\n  - 7.21.6.5 The snprintf function (p: 325)\n  - 7.21.6.6 The sprintf function (p: 325-326)\n  - K.3.5.3.1 The fprintf_s function (p: 591)\n  - K.3.5.3.3 The printf_s function (p: 593-594)\n  - K.3.5.3.5 The snprintf_s function (p: 594-595)\n  - K.3.5.3.6 The sprintf_s function (p: 595-596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.1 The fprintf function (p: 274-282)\n  - 7.19.6.3 The printf function (p: 290)\n  - 7.19.6.5 The snprintf function (p: 290-291)\n  - 7.19.6.6 The sprintf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.1 The fprintf function\n  - 4.9.6.3 The printf function\n  - 4.9.6.5 The sprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fprintf](https://en.cppreference.com/w/c/io/fprintf)"
- name: sqrt
  summary: If no errors occur, square root of arg (\({\small \sqrt{arg} }\)√arg), is returned
  description: "# sqrt, sqrtf, sqrtl\n\n[TABLE]\n\n1-3) Computes square root of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `sqrtl` is called. Otherwise, if `arg` has integer type or the type `double`, `sqrt` is called. Otherwise, `sqrtf` is called. If `arg` is complex or imaginary, then the macro invokes the corresponding complex function ([`csqrtf`](http://en.cppreference.com/w/c/numeric/complex/csqrt), [`csqrt`](http://en.cppreference.com/w/c/numeric/complex/csqrt), [`csqrtl`](http://en.cppreference.com/w/c/numeric/complex/csqrt)).\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, square root of `arg` (\\\\{\\small \\sqrt{arg} }\\\\√arg), is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is less than -0, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and NaN is returned.\n- If the argument is +∞ or ±0, it is returned, unmodified.\n- If the argument is NaN, NaN is returned\n\n### Notes\n\n`sqrt` is required by the IEEE standard to be correctly rounded from the infinitely precise result. In particular, the exact result is produced if it can be represented in the floating-point type. The only other operations which require this are the [arithmetic operators](../../language/operator_arithmetic \"c/language/operator arithmetic\") and the function [`fma`](fma \"c/numeric/math/fma\"). Other functions, including [`pow`](pow \"c/numeric/math/pow\"), are not so constrained.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // normal use\n    printf(\"sqrt(100) = %f\\n\", sqrt(100));\n    printf(\"sqrt(2) = %f\\n\", sqrt(2));\n    printf(\"golden ratio = %f\\n\", (1+sqrt(5))/2);\n    // special values\n    printf(\"sqrt(-0) = %f\\n\", sqrt(-0.0));\n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sqrt(-1.0) = %f\\n\", sqrt(-1));\n    if(errno == EDOM) perror(\"    errno == EDOM\");\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nsqrt(100) = 10.000000\nsqrt(2) = 1.414214\ngolden ratio = 1.618034\nsqrt(-0) = -0.000000\nsqrt(-1.0) = -nan\n    errno = EDOM: Numerical argument out of domain\n    FE_INVALID was raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.5 The sqrt functions (p: 249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.5 The sqrt functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.5 The sqrt functions (p: 229-230)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.5 The sqrt functions (p: 462)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.5.2 The sqrt function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sqrt](https://en.cppreference.com/w/c/numeric/math/sqrt)"
- name: sqrtf
  summary: If no errors occur, square root of arg (\({\small \sqrt{arg} }\)√arg), is returned
  description: "# sqrt, sqrtf, sqrtl\n\n[TABLE]\n\n1-3) Computes square root of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `sqrtl` is called. Otherwise, if `arg` has integer type or the type `double`, `sqrt` is called. Otherwise, `sqrtf` is called. If `arg` is complex or imaginary, then the macro invokes the corresponding complex function ([`csqrtf`](http://en.cppreference.com/w/c/numeric/complex/csqrt), [`csqrt`](http://en.cppreference.com/w/c/numeric/complex/csqrt), [`csqrtl`](http://en.cppreference.com/w/c/numeric/complex/csqrt)).\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, square root of `arg` (\\\\{\\small \\sqrt{arg} }\\\\√arg), is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is less than -0, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and NaN is returned.\n- If the argument is +∞ or ±0, it is returned, unmodified.\n- If the argument is NaN, NaN is returned\n\n### Notes\n\n`sqrt` is required by the IEEE standard to be correctly rounded from the infinitely precise result. In particular, the exact result is produced if it can be represented in the floating-point type. The only other operations which require this are the [arithmetic operators](../../language/operator_arithmetic \"c/language/operator arithmetic\") and the function [`fma`](fma \"c/numeric/math/fma\"). Other functions, including [`pow`](pow \"c/numeric/math/pow\"), are not so constrained.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // normal use\n    printf(\"sqrt(100) = %f\\n\", sqrt(100));\n    printf(\"sqrt(2) = %f\\n\", sqrt(2));\n    printf(\"golden ratio = %f\\n\", (1+sqrt(5))/2);\n    // special values\n    printf(\"sqrt(-0) = %f\\n\", sqrt(-0.0));\n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sqrt(-1.0) = %f\\n\", sqrt(-1));\n    if(errno == EDOM) perror(\"    errno == EDOM\");\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nsqrt(100) = 10.000000\nsqrt(2) = 1.414214\ngolden ratio = 1.618034\nsqrt(-0) = -0.000000\nsqrt(-1.0) = -nan\n    errno = EDOM: Numerical argument out of domain\n    FE_INVALID was raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.5 The sqrt functions (p: 249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.5 The sqrt functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.5 The sqrt functions (p: 229-230)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.5 The sqrt functions (p: 462)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.5.2 The sqrt function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sqrt](https://en.cppreference.com/w/c/numeric/math/sqrt)"
- name: sqrtl
  summary: If no errors occur, square root of arg (\({\small \sqrt{arg} }\)√arg), is returned
  description: "# sqrt, sqrtf, sqrtl\n\n[TABLE]\n\n1-3) Computes square root of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `sqrtl` is called. Otherwise, if `arg` has integer type or the type `double`, `sqrt` is called. Otherwise, `sqrtf` is called. If `arg` is complex or imaginary, then the macro invokes the corresponding complex function ([`csqrtf`](http://en.cppreference.com/w/c/numeric/complex/csqrt), [`csqrt`](http://en.cppreference.com/w/c/numeric/complex/csqrt), [`csqrtl`](http://en.cppreference.com/w/c/numeric/complex/csqrt)).\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, square root of `arg` (\\\\{\\small \\sqrt{arg} }\\\\√arg), is returned.\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nDomain error occurs if `arg` is less than zero.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- If the argument is less than -0, [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised and NaN is returned.\n- If the argument is +∞ or ±0, it is returned, unmodified.\n- If the argument is NaN, NaN is returned\n\n### Notes\n\n`sqrt` is required by the IEEE standard to be correctly rounded from the infinitely precise result. In particular, the exact result is produced if it can be represented in the floating-point type. The only other operations which require this are the [arithmetic operators](../../language/operator_arithmetic \"c/language/operator arithmetic\") and the function [`fma`](fma \"c/numeric/math/fma\"). Other functions, including [`pow`](pow \"c/numeric/math/pow\"), are not so constrained.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <fenv.h>\n \n#pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    // normal use\n    printf(\"sqrt(100) = %f\\n\", sqrt(100));\n    printf(\"sqrt(2) = %f\\n\", sqrt(2));\n    printf(\"golden ratio = %f\\n\", (1+sqrt(5))/2);\n    // special values\n    printf(\"sqrt(-0) = %f\\n\", sqrt(-0.0));\n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"sqrt(-1.0) = %f\\n\", sqrt(-1));\n    if(errno == EDOM) perror(\"    errno == EDOM\");\n    if(fetestexcept(FE_INVALID)) puts(\"    FE_INVALID was raised\");\n}\n```\n\nPossible output:\n\n```\nsqrt(100) = 10.000000\nsqrt(2) = 1.414214\ngolden ratio = 1.618034\nsqrt(-0) = -0.000000\nsqrt(-1.0) = -nan\n    errno = EDOM: Numerical argument out of domain\n    FE_INVALID was raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.7.5 The sqrt functions (p: 249)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.4.5 The sqrt functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.7.5 The sqrt functions (p: 229-230)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.4.5 The sqrt functions (p: 462)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.5.2 The sqrt function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/sqrt](https://en.cppreference.com/w/c/numeric/math/sqrt)"
- name: srand
  summary: Seeds the pseudo-random number generator used by rand() with the value seed
  description: "# srand\n\n[TABLE]\n\nSeeds the pseudo-random number generator used by [`rand()`](rand \"c/numeric/random/rand\") with the value `seed`.\n\nIf `rand()` is used before any calls to `srand()`, `rand()` behaves as if it was seeded with `srand(1)`.\n\nEach time `rand()` is seeded with the same `seed`, it must produce the same sequence of values.\n\n`srand()` is not guaranteed to be thread-safe.\n\n### Parameters\n\n|      |     |                |\n|------|-----|----------------|\n| seed | \\-  | the seed value |\n\n### Return value\n\n(none)\n\n### Notes\n\nGenerally speaking, the pseudo-random number generator should only be seeded once, before any calls to `rand()`, and the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.\n\nStandard practice is to use the result of a call to [`time`](http://en.cppreference.com/w/c/chrono/time)`(``0``)` as the seed. However, `time()` returns a [`time_t`](../../chrono/time_t \"c/chrono/time t\") value, and `time_t` is not guaranteed to be an integral type. In practice, though, every major implementation defines `time_t` to be an integral type, and this is also what POSIX requires.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n \nint main(void)\n{\n    srand(time(NULL)); //use current time as seed for random generator\n    int random_variable = rand();\n    printf(\"Random value on [0,%d]: %d\\n\", RAND_MAX, random_variable);\n}\n```\n\nPossible output:\n\n```\nRandom value on [0 2147483647]: 1373858591\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.2.2 The srand function (p: 252-253)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.2.2 The srand function (p: 346-347)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.2.2 The srand function (p: 312-313)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.2.2 The srand function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/random/srand](https://en.cppreference.com/w/c/numeric/random/srand)"
- name: sscanf
  summary: Reads data from a variety of sources, interprets it according to format and stores the results into given locations
  description: "# scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s\n\n[TABLE]\n\nReads data from a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) reads the data from file stream `stream`\n\n3) reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%c` into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `scanf_s` , `fscanf_s`, and `sscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                           |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or [`EOF`](../io \"c/io\") if input failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Complexity\n\nNot guaranteed. Notably, some implementations of `sscanf` are O(N), where `N ``=`` `[`strlen`](http://en.cppreference.com/w/c/string/byte/strlen)`(``buffer``)` [\\[1\\]](https://sourceware.org/bugzilla/show_bug.cgi?id=17577).\n\n### Notes\n\nBecause most conversion specifiers first consume all consecutive whitespace, code such as\n\n```\nscanf(\"%d\", &a);\nscanf(\"%d\", &b);\n```\n\nwill read two integers that are entered on different lines (second `%d` will consume the newline left over by the first) or on the same line, separated by spaces or tabs (second `%d` will consume the spaces or tabs). The conversion specifiers that do not consume leading whitespace, such as `%c`, can be made to do so by using a whitespace character in the format string:\n\n```\nscanf(\"%d\", &a);\nscanf(\" %c\", &c); // consume all consecutive whitespace after %d, then read a char\n```\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stddef.h>\n#include <locale.h>\n \nint main(void)\n{\n    int i, j;\n    float x, y;\n    char str1[10], str2[4];\n    wchar_t warr[2];\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    char input[] = \"25 54.32E-1 Thompson 56789 0123 56ß水\";\n    /* parse as follows:\n       %d: an integer\n       %f: a floating-point value\n       %9s: a string of at most 9 non-whitespace characters\n       %2d: two-digit integer (digits 5 and 6)\n       %f:  a floating-point value (digits 7, 8, 9)\n       %*d: an integer which isn't stored anywhere\n       ' ': all consecutive whitespace\n       %3[0-9]: a string of at most 3 decimal digits (digits 5 and 6)\n       %2lc: two wide characters, using multibyte to wide conversion  */\n    int ret = sscanf(input, \"%d%f%9s%2d%f%*d %3[0-9]%2lc\",\n                     &i, &x, str1, &j, &y, str2, warr);\n \n    printf(\"Converted %d fields:\\n\"\n           \"i = %d\\n\"\n           \"x = %f\\n\"\n           \"str1 = %s\\n\"\n           \"j = %d\\n\"\n           \"y = %f\\n\"\n           \"str2 = %s\\n\"\n           \"warr[0] = U+%x\\n\"\n           \"warr[1] = U+%x\\n\",\n           ret, i, x, str1, j, y, str2, warr[0], warr[1]);\n \n#ifdef __STDC_LIB_EXT1__\n    int n = sscanf_s(input, \"%d%f%s\", &i, &x, str1, (rsize_t)sizeof str1);\n    // writes 25 to i, 5.432 to x, the 9 bytes \"Thompson\\0\" to str1, and 3 to n.\n#endif\n}\n```\n\nPossible output:\n\n```\nConverted 7 fields:\ni = 25\nx = 5.432000\nstr1 = Thompson\nj = 56\ny = 789.000000\nstr2 = 56\nwarr[0] = U+df\nwarr[1] = U+6c34\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.2 The fscanf function (p: 231-236)\n  - 7.21.6.4 The scanf function (p: 236-237)\n  - 7.21.6.7 The sscanf function (p: 238-239)\n  - K.3.5.3.2 The fscanf_s function (p: 430-431)\n  - K.3.5.3.4 The scanf_s function (p: 432)\n  - K.3.5.3.7 The sscanf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.2 The fscanf function (p: 317-324)\n  - 7.21.6.4 The scanf function (p: 325)\n  - 7.21.6.7 The sscanf function (p: 326)\n  - K.3.5.3.2 The fscanf_s function (p: 592-593)\n  - K.3.5.3.4 The scanf_s function (p: 594)\n  - K.3.5.3.7 The sscanf_s function (p: 596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.2 The fscanf function (p: 282-289)\n  - 7.19.6.4 The scanf function (p: 290)\n  - 7.19.6.7 The sscanf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.2 The fscanf function\n  - 4.9.6.4 The scanf function\n  - 4.9.6.6 The sscanf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fscanf](https://en.cppreference.com/w/c/io/fscanf)"
- name: sscanf_s
  summary: Reads data from a variety of sources, interprets it according to format and stores the results into given locations
  description: "# scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s\n\n[TABLE]\n\nReads data from a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) reads the data from file stream `stream`\n\n3) reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%c` into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `scanf_s` , `fscanf_s`, and `sscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                           |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or [`EOF`](../io \"c/io\") if input failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Complexity\n\nNot guaranteed. Notably, some implementations of `sscanf` are O(N), where `N ``=`` `[`strlen`](http://en.cppreference.com/w/c/string/byte/strlen)`(``buffer``)` [\\[1\\]](https://sourceware.org/bugzilla/show_bug.cgi?id=17577).\n\n### Notes\n\nBecause most conversion specifiers first consume all consecutive whitespace, code such as\n\n```\nscanf(\"%d\", &a);\nscanf(\"%d\", &b);\n```\n\nwill read two integers that are entered on different lines (second `%d` will consume the newline left over by the first) or on the same line, separated by spaces or tabs (second `%d` will consume the spaces or tabs). The conversion specifiers that do not consume leading whitespace, such as `%c`, can be made to do so by using a whitespace character in the format string:\n\n```\nscanf(\"%d\", &a);\nscanf(\" %c\", &c); // consume all consecutive whitespace after %d, then read a char\n```\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stddef.h>\n#include <locale.h>\n \nint main(void)\n{\n    int i, j;\n    float x, y;\n    char str1[10], str2[4];\n    wchar_t warr[2];\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    char input[] = \"25 54.32E-1 Thompson 56789 0123 56ß水\";\n    /* parse as follows:\n       %d: an integer\n       %f: a floating-point value\n       %9s: a string of at most 9 non-whitespace characters\n       %2d: two-digit integer (digits 5 and 6)\n       %f:  a floating-point value (digits 7, 8, 9)\n       %*d: an integer which isn't stored anywhere\n       ' ': all consecutive whitespace\n       %3[0-9]: a string of at most 3 decimal digits (digits 5 and 6)\n       %2lc: two wide characters, using multibyte to wide conversion  */\n    int ret = sscanf(input, \"%d%f%9s%2d%f%*d %3[0-9]%2lc\",\n                     &i, &x, str1, &j, &y, str2, warr);\n \n    printf(\"Converted %d fields:\\n\"\n           \"i = %d\\n\"\n           \"x = %f\\n\"\n           \"str1 = %s\\n\"\n           \"j = %d\\n\"\n           \"y = %f\\n\"\n           \"str2 = %s\\n\"\n           \"warr[0] = U+%x\\n\"\n           \"warr[1] = U+%x\\n\",\n           ret, i, x, str1, j, y, str2, warr[0], warr[1]);\n \n#ifdef __STDC_LIB_EXT1__\n    int n = sscanf_s(input, \"%d%f%s\", &i, &x, str1, (rsize_t)sizeof str1);\n    // writes 25 to i, 5.432 to x, the 9 bytes \"Thompson\\0\" to str1, and 3 to n.\n#endif\n}\n```\n\nPossible output:\n\n```\nConverted 7 fields:\ni = 25\nx = 5.432000\nstr1 = Thompson\nj = 56\ny = 789.000000\nstr2 = 56\nwarr[0] = U+df\nwarr[1] = U+6c34\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.2 The fscanf function (p: 231-236)\n  - 7.21.6.4 The scanf function (p: 236-237)\n  - 7.21.6.7 The sscanf function (p: 238-239)\n  - K.3.5.3.2 The fscanf_s function (p: 430-431)\n  - K.3.5.3.4 The scanf_s function (p: 432)\n  - K.3.5.3.7 The sscanf_s function (p: 433)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.2 The fscanf function (p: 317-324)\n  - 7.21.6.4 The scanf function (p: 325)\n  - 7.21.6.7 The sscanf function (p: 326)\n  - K.3.5.3.2 The fscanf_s function (p: 592-593)\n  - K.3.5.3.4 The scanf_s function (p: 594)\n  - K.3.5.3.7 The sscanf_s function (p: 596)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.2 The fscanf function (p: 282-289)\n  - 7.19.6.4 The scanf function (p: 290)\n  - 7.19.6.7 The sscanf function (p: 291)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.2 The fscanf function\n  - 4.9.6.4 The scanf function\n  - 4.9.6.6 The sscanf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fscanf](https://en.cppreference.com/w/c/io/fscanf)"
- name: Statements
  summary: Statements are fragments of the C program that are executed in sequence
  description: "# Statements\n\nStatements are fragments of the C program that are executed in sequence. The body of any function is a compound statement, which, in turn is a sequence of statements and declarations:\n\n```\nint main(void)\n{ // start of a compound statement\n    int n = 1; // declaration (not a statement)\n    n = n+1; // expression statement\n    printf(\"n = %d\\n\", n); // expression statement\n    return 0; // return statement\n} // end of compound statement, end of function body\n```\n\n  \nThere are five types of statements:\n\n1) [compound statements](#Compound_statements)\n\n2) [expression statements](#Expression_statements)\n\n3) [selection statements](#Selection_statements)\n\n4) [iteration statements](#Iteration_statements)\n\n5) [jump statements](#Jump_statements)\n\n|                                                                                                                                                                                                                                            |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| An [attribute specifier sequence](attributes \"c/language/attributes\") (attr-spec-seq) can be applied to an unlabeled statement, in which case (except for an expression statement) the attributes are applied to the respective statement. | (since C23) |\n\n### Labels\n\nAny statement can be *labeled*, by providing a name followed by a colon before the statement itself.\n\n|                                                                   |       |     |\n|-------------------------------------------------------------------|-------|-----|\n| attr-spec-seq(optional)(since C23) identifier `:`                 | \\(1\\) |     |\n| attr-spec-seq(optional)(since C23) `case` constant-expression `:` | \\(2\\) |     |\n| attr-spec-seq(optional)(since C23) `default` `:`                  | \\(3\\) |     |\n\n1) Target for [goto](goto \"c/language/goto\").\n\n2) Case label in a [switch](switch \"c/language/switch\") statement.\n\n3) Default label in a [switch](switch \"c/language/switch\") statement.\n\nAny statement (but not a declaration) may be preceded by any number of *labels*, each of which declares identifier to be a label name, which must be unique within the enclosing function (in other words, label names have [function scope](scope \"c/language/scope\")).\n\nLabel declaration has no effect on its own, does not alter the flow of control, or modify the behavior of the statement that follows in any way.\n\n[TABLE]\n\n### Compound statements\n\nA compound statement, or *block*, is a brace-enclosed sequence of statements and declarations.\n\n|                                                                                             |     |             |\n|---------------------------------------------------------------------------------------------|-----|-------------|\n| `{` statement `|` declaration...(optional) `} `                                             |     | (until C23) |\n| attr-spec-seq(optional) `{` unlabeled-statement `|` label `|` declaration...(optional) `} ` |     | (since C23) |\n\nThe compound statement allows a set of declarations and statements to be grouped into one unit that can be used anywhere a single statement is expected (for example, in an [if](if \"c/language/if\") statement or an iteration statement):\n\n```\nif (expr) // start of if-statement\n{ // start of block\n  int n = 1; // declaration\n  printf(\"%d\\n\", n); // expression statement\n} // end of block, end of if-statement\n```\n\nEach compound statement introduces its own [block scope](scope \"c/language/scope\").\n\nThe initializers of the variables with automatic [storage duration](storage_duration \"c/language/storage duration\") declared inside a block and the VLA declarators are executed when flow of control passes over these declarations in order, as if they were statements:\n\n```\nint main(void)\n{ // start of block\n  { // start of block\n       puts(\"hello\"); // expression statement\n       int n = printf(\"abc\\n\"); // declaration, prints \"abc\", stores 4 in n\n       int a[n*printf(\"1\\n\")]; // declaration, prints \"1\", allocates 8*sizeof(int)\n       printf(\"%zu\\n\", sizeof(a)); // expression statement\n  } // end of block, scope of n and a ends\n  int n = 7; // n can be reused\n}\n```\n\n### Expression statements\n\nAn expression followed by a semicolon is a statement.\n\n|                              |       |             |\n|------------------------------|-------|-------------|\n| expression(optional) `;`     | \\(1\\) |             |\n| attr-spec-seq expression `;` | \\(2\\) | (since C23) |\n\nMost statements in a typical C program are expression statements, such as assignments or function calls.\n\nAn expression statement without an expression is called a *null statement*. It is often used to provide an empty body to a [for](for \"c/language/for\") or [while](while \"c/language/while\") loop. It can also be used to carry a label in the end of a compound statement or before a declaration:\n\n```\nputs(\"hello\"); // expression statement\nchar *s;\nwhile (*s++ != '\\0')\n    ; // null statement\n```\n\n[TABLE]\n\n### Selection statements\n\nThe selection statements choose between one of several statements depending on the value of an expression.\n\n|                                                                                       |       |     |\n|---------------------------------------------------------------------------------------|-------|-----|\n| attr-spec-seq(optional)(since C23) `if` `(` expression `)` statement                  | \\(1\\) |     |\n| attr-spec-seq(optional)(since C23) `if` `(` expression `)` statement `else` statement | \\(2\\) |     |\n| attr-spec-seq(optional)(since C23) `switch` `(` expression `)` statement              | \\(3\\) |     |\n\n1) [if](if \"c/language/if\") statement\n\n2) [if](if \"c/language/if\") statement with an else clause\n\n3) [switch](switch \"c/language/switch\") statement\n\n### Iteration statements\n\nThe iteration statements repeatedly execute a statement.\n\n|                                                                                                                          |       |     |\n|--------------------------------------------------------------------------------------------------------------------------|-------|-----|\n| attr-spec-seq(optional)(since C23) `while` `(` expression `)` statement                                                  | \\(1\\) |     |\n| attr-spec-seq(optional)(since C23) `do` statement `while` `(` expression `)` `;`                                         | \\(2\\) |     |\n| attr-spec-seq(optional)(since C23) `for` `(` init-clause `;` expression(optional) `;` expression(optional) `)` statement | \\(3\\) |     |\n\n1) [while](while \"c/language/while\") loop\n\n2) [do-while](do \"c/language/do\") loop\n\n3) [for](for \"c/language/for\") loop\n\n### Jump statements\n\nThe jump statements unconditionally transfer flow control.\n\n|                                                                      |       |     |\n|----------------------------------------------------------------------|-------|-----|\n| attr-spec-seq(optional)(since C23) `break` `;`                       | \\(1\\) |     |\n| attr-spec-seq(optional)(since C23) `continue` `;`                    | \\(2\\) |     |\n| attr-spec-seq(optional)(since C23) `return` expression(optional) `;` | \\(3\\) |     |\n| attr-spec-seq(optional)(since C23) `goto` identifier `;`             | \\(4\\) |     |\n\n1) [break](break \"c/language/break\") statement\n\n2) [continue](continue \"c/language/continue\") statement\n\n3) [return](return \"c/language/return\") statement with an optional expression\n\n4) [goto](goto \"c/language/goto\") statement\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.8 Statements and blocks (p: 106-112)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.8 Statements and blocks (p: 146-154)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.8 Statements and blocks (p: 131-139)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.6 STATEMENTS\n\n### See also\n\n|                                                                                                                     |     |\n|---------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/statements \"cpp/language/statements\") for Statements |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/statements](https://en.cppreference.com/w/c/language/statements)"
- name: static
  summary: ''
  description: "# C keywords: static\n\n### Usage\n\n- [declarations of file scope with static storage duration and internal linkage](../language/storage_duration \"c/language/storage duration\")\n- [definitions of block scope variables with static storage duration and initialized once](../language/storage_duration#Static_local_variables \"c/language/storage duration\")\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/static](https://en.cppreference.com/w/c/keyword/static)"
- name: Static assertion
  summary: This keyword is also available as convenience macro static_assert, available in the header <assert.h>
  description: "# Static assertion (since C11)\n\n### Syntax\n\n|                                                 |     |                                |\n|-------------------------------------------------|-----|--------------------------------|\n| `_Static_assert` `(` expression `,` message `)` |     | (since C11)(deprecated in C23) |\n| `static_assert` `(` expression `,` message `)`  |     | (since C23)                    |\n| `_Static_assert` `(` expression `)`             |     | (since C23)(deprecated in C23) |\n| `static_assert` `(` expression `)`              |     | (since C23)                    |\n\n|            |     |                                                                                         |\n|------------|-----|-----------------------------------------------------------------------------------------|\n| expression | \\-  | any [integer constant expression](constant_expression \"c/language/constant expression\") |\n| message    | \\-  | any [string literal](string_literal \"c/language/string literal\")                        |\n\n[TABLE]\n\n### Explanation\n\nThe constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display message as part of the error message (except that characters not in [basic character set](charset \"c/language/charset\") are not required to be displayed)(until C23)should display message (if provided) as part of the error message(since C23).\n\nOtherwise, if expression does not equal zero, nothing happens; no code is emitted.\n\n### Keywords\n\n[`_Static_assert`](../keyword/_static_assert \"c/keyword/ Static assert\"), [`static_assert`](../keyword/static_assert \"c/keyword/static assert\")\n\n### Example\n\n```\n#include <assert.h> // no longer needed since C23\n \nint main(void)\n{\n    // Test if math works, C23:\n    static_assert((2 + 2) % 3 == 1, \"Whoa dude, you knew!\");\n    // Pre-C23 alternative:\n    _Static_assert(2 + 2 * 2 == 6, \"Lucky guess!?\");\n \n    // This will produce an error at compile time.\n    // static_assert(sizeof(int) < sizeof(char), \"Unmet condition!\");\n \n    constexpr int _42 = 2 * 3 * 2 * 3 + 2 * 3;\n    static_assert(_42 == 42); // the message string can be omitted.\n \n    // const int _13 = 13;\n    // Compile time error - not an integer constant expression:\n    // static_assert(_13 == 13);\n}\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.11 Static assertions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.10 Static assertions (p: 105)\n  - 7.2 Diagnostics \\<assert.h\\> (p: 135)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.10 Static assertions (p: 145)\n  - 7.2 Diagnostics \\<assert.h\\> (p: 186-187)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/\\_Static_assert](https://en.cppreference.com/w/c/language/_Static_assert)"
- name: Static assertion
  summary: This keyword is also available as convenience macro static_assert, available in the header <assert.h>
  description: "# Static assertion (since C11)\n\n### Syntax\n\n|                                                 |     |                                |\n|-------------------------------------------------|-----|--------------------------------|\n| `_Static_assert` `(` expression `,` message `)` |     | (since C11)(deprecated in C23) |\n| `static_assert` `(` expression `,` message `)`  |     | (since C23)                    |\n| `_Static_assert` `(` expression `)`             |     | (since C23)(deprecated in C23) |\n| `static_assert` `(` expression `)`              |     | (since C23)                    |\n\n|            |     |                                                                                         |\n|------------|-----|-----------------------------------------------------------------------------------------|\n| expression | \\-  | any [integer constant expression](constant_expression \"c/language/constant expression\") |\n| message    | \\-  | any [string literal](string_literal \"c/language/string literal\")                        |\n\n[TABLE]\n\n### Explanation\n\nThe constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display message as part of the error message (except that characters not in [basic character set](charset \"c/language/charset\") are not required to be displayed)(until C23)should display message (if provided) as part of the error message(since C23).\n\nOtherwise, if expression does not equal zero, nothing happens; no code is emitted.\n\n### Keywords\n\n[`_Static_assert`](../keyword/_static_assert \"c/keyword/ Static assert\"), [`static_assert`](../keyword/static_assert \"c/keyword/static assert\")\n\n### Example\n\n```\n#include <assert.h> // no longer needed since C23\n \nint main(void)\n{\n    // Test if math works, C23:\n    static_assert((2 + 2) % 3 == 1, \"Whoa dude, you knew!\");\n    // Pre-C23 alternative:\n    _Static_assert(2 + 2 * 2 == 6, \"Lucky guess!?\");\n \n    // This will produce an error at compile time.\n    // static_assert(sizeof(int) < sizeof(char), \"Unmet condition!\");\n \n    constexpr int _42 = 2 * 3 * 2 * 3 + 2 * 3;\n    static_assert(_42 == 42); // the message string can be omitted.\n \n    // const int _13 = 13;\n    // Compile time error - not an integer constant expression:\n    // static_assert(_13 == 13);\n}\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.11 Static assertions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.10 Static assertions (p: 105)\n  - 7.2 Diagnostics \\<assert.h\\> (p: 135)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.10 Static assertions (p: 145)\n  - 7.2 Diagnostics \\<assert.h\\> (p: 186-187)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/static_assert](https://en.cppreference.com/w/c/language/static_assert)"
- name: Static storage duration
  summary: An object whose identifier is declared without the storage-class specifier _Thread_local, and either with external or internal linkage or with the storage-class specifier static, has static storage duration
  description: "# Static storage duration\n\nAn object whose identifier is declared without the storage-class specifier `_Thread_local`, and either with external or internal [linkage](storage_duration#Linkage \"c/language/storage duration\") or with the storage-class specifier `static`, has static storage duration. Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup.\n\n### Notes\n\nSince its stored value is initialized only once, an object with static storage duration can profile the invocations of a function.\n\nThe other use of the keyword `static` is [file scope](file_scope \"c/language/file scope\").\n\n### Example\n\n```\n#include <stdio.h>\n \nvoid f (void)\n{\n    static int count = 0;   // static variable   \n    int i = 0;              // automatic variable\n    printf(\"%d %d\\n\", i++, count++);\n}\n \nint main(void)\n{\n    for (int ndx=0; ndx<10; ++ndx)\n        f();\n}\n```\n\nOutput:\n\n```\n0 0\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n0 7\n0 8\n0 9\n```\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/static_storage_duration](https://en.cppreference.com/w/c/language/static_storage_duration)"
- name: static_assert
  summary: ''
  description: "# C keywords: static_assert (since C23)\n\n### Usage\n\n- [static assert declaration](../language/_static_assert \"c/language/ Static assert\") (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/static_assert](https://en.cppreference.com/w/c/keyword/static_assert)"
- name: static_assert
  summary: This convenience macro expands to the keyword _Static_assert
  description: "# static_assert\n\n[TABLE]\n\nThis convenience macro expands to the keyword [`_Static_assert`](../keyword/_static_assert \"c/keyword/ Static assert\").\n\n### Example\n\n```\n#include <assert.h>\n \nint main(void)\n{\n    static_assert(2 + 2 == 4, \"2+2 isn't 4\");   // well-formed\n \n    static_assert(sizeof(int) < sizeof(char),   // compile-time error\n                  \"this program requires that int is less than char\");\n}\n```\n\n### Notes\n\nSince C23, [`static_assert`](../language/_static_assert \"c/language/ Static assert\") is itself a keyword, which may also be a predefined macro, so [`<assert.h>`](../error \"c/error\") no longer provides it.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.2/3 Diagnostics \\<assert.h\\> (p: 135)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.2/3 Diagnostics \\<assert.h\\> (p: 186)\n\n### See also\n\n|                                                                                                                                   |     |\n|-----------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/static_assert \"cpp/language/static assert\") for `Static Assertion` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/error/static_assert](https://en.cppreference.com/w/c/error/static_assert)"
- name: stderr
  summary: Three text streams are predefined
  description: "# stdin, stdout, stderr\n\n[TABLE]\n\nThree text streams are predefined. These streams are implicitly opened and unoriented at program startup.\n\n1) Associated with the *standard input* stream, used for reading conventional input. At program startup, the stream is fully buffered if and only if the stream can be determined to not refer to an interactive device.\n\n2) Associated with the *standard output* stream, used for writing conventional output. At program startup, the stream is fully buffered if and only if the stream can be determined to not refer to an interactive device.\n\n3) Associated with the *standard error* stream, used for writing diagnostic output. At program startup, the stream is not fully buffered.\n\nWhat constitutes an interactive device is implementation-defined.\n\nThese macros are expanded to expressions of type [`FILE`](http://en.cppreference.com/w/c/io/FILE)`*`.\n\n### Notes\n\nAlthough not mandated by POSIX, the UNIX convention is that `stdin` and `stdout` are line-buffered if associated with a terminal and `stderr` is unbuffered.\n\nThese macros may be expanded to modifiable lvalues. If any of these [`FILE`](http://en.cppreference.com/w/c/io/FILE)`*` lvalue is modified, subsequent operations on the corresponding stream result in unspecified or undefined behavior.\n\n### Example\n\nThis example shows a function equivalent to [`printf`](fprintf \"c/io/fprintf\").\n\n```\n#include <stdarg.h>\n#include <stdio.h>\n \nint my_printf(const char * restrict fmt, ...)\n{\n    va_list vl;\n    va_start(vl, fmt);\n    int ret = vfprintf(stdout, fmt, vl);\n    va_end(vl);\n    return ret;\n}\n \nint main(void)\n{\n    my_printf(\"Rounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    my_printf(\"Padding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    my_printf(\"Scientific:\\t%E %e\\n\", 1.5, 1.5);\n    my_printf(\"Hexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n}\n```\n\nPossible output:\n\n```\nRounding:       1.500000 2 1.30000000000000004440892098500626\nPadding:        01.50 1.50  1.50\nScientific:     1.500000E+00 1.500000e+00\nHexadecimal:    0x1.8p+0 0X1.8P+0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.1 Introduction (p: 217-218)\n  - 7.21.2 Streams (p: 217-219)\n  - 7.21.2 Files (p: 219-221)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.1 Introduction (p: 296-298)\n  - 7.21.2 Streams (p: 298-299)\n  - 7.21.2 Files (p: 300-302)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.1 Introduction (p: 262-264)\n  - 7.19.2 Streams (p: 264-265)\n  - 7.19.2 Files (p: 266-268)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 7.9.1 Introduction\n  - 7.9.2 Streams\n  - 7.9.3 Files\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/std_streams](https://en.cppreference.com/w/c/io/std_streams)"
- name: stdin
  summary: Three text streams are predefined
  description: "# stdin, stdout, stderr\n\n[TABLE]\n\nThree text streams are predefined. These streams are implicitly opened and unoriented at program startup.\n\n1) Associated with the *standard input* stream, used for reading conventional input. At program startup, the stream is fully buffered if and only if the stream can be determined to not refer to an interactive device.\n\n2) Associated with the *standard output* stream, used for writing conventional output. At program startup, the stream is fully buffered if and only if the stream can be determined to not refer to an interactive device.\n\n3) Associated with the *standard error* stream, used for writing diagnostic output. At program startup, the stream is not fully buffered.\n\nWhat constitutes an interactive device is implementation-defined.\n\nThese macros are expanded to expressions of type [`FILE`](http://en.cppreference.com/w/c/io/FILE)`*`.\n\n### Notes\n\nAlthough not mandated by POSIX, the UNIX convention is that `stdin` and `stdout` are line-buffered if associated with a terminal and `stderr` is unbuffered.\n\nThese macros may be expanded to modifiable lvalues. If any of these [`FILE`](http://en.cppreference.com/w/c/io/FILE)`*` lvalue is modified, subsequent operations on the corresponding stream result in unspecified or undefined behavior.\n\n### Example\n\nThis example shows a function equivalent to [`printf`](fprintf \"c/io/fprintf\").\n\n```\n#include <stdarg.h>\n#include <stdio.h>\n \nint my_printf(const char * restrict fmt, ...)\n{\n    va_list vl;\n    va_start(vl, fmt);\n    int ret = vfprintf(stdout, fmt, vl);\n    va_end(vl);\n    return ret;\n}\n \nint main(void)\n{\n    my_printf(\"Rounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    my_printf(\"Padding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    my_printf(\"Scientific:\\t%E %e\\n\", 1.5, 1.5);\n    my_printf(\"Hexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n}\n```\n\nPossible output:\n\n```\nRounding:       1.500000 2 1.30000000000000004440892098500626\nPadding:        01.50 1.50  1.50\nScientific:     1.500000E+00 1.500000e+00\nHexadecimal:    0x1.8p+0 0X1.8P+0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.1 Introduction (p: 217-218)\n  - 7.21.2 Streams (p: 217-219)\n  - 7.21.2 Files (p: 219-221)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.1 Introduction (p: 296-298)\n  - 7.21.2 Streams (p: 298-299)\n  - 7.21.2 Files (p: 300-302)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.1 Introduction (p: 262-264)\n  - 7.19.2 Streams (p: 264-265)\n  - 7.19.2 Files (p: 266-268)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 7.9.1 Introduction\n  - 7.9.2 Streams\n  - 7.9.3 Files\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/std_streams](https://en.cppreference.com/w/c/io/std_streams)"
- name: stdout
  summary: Three text streams are predefined
  description: "# stdin, stdout, stderr\n\n[TABLE]\n\nThree text streams are predefined. These streams are implicitly opened and unoriented at program startup.\n\n1) Associated with the *standard input* stream, used for reading conventional input. At program startup, the stream is fully buffered if and only if the stream can be determined to not refer to an interactive device.\n\n2) Associated with the *standard output* stream, used for writing conventional output. At program startup, the stream is fully buffered if and only if the stream can be determined to not refer to an interactive device.\n\n3) Associated with the *standard error* stream, used for writing diagnostic output. At program startup, the stream is not fully buffered.\n\nWhat constitutes an interactive device is implementation-defined.\n\nThese macros are expanded to expressions of type [`FILE`](http://en.cppreference.com/w/c/io/FILE)`*`.\n\n### Notes\n\nAlthough not mandated by POSIX, the UNIX convention is that `stdin` and `stdout` are line-buffered if associated with a terminal and `stderr` is unbuffered.\n\nThese macros may be expanded to modifiable lvalues. If any of these [`FILE`](http://en.cppreference.com/w/c/io/FILE)`*` lvalue is modified, subsequent operations on the corresponding stream result in unspecified or undefined behavior.\n\n### Example\n\nThis example shows a function equivalent to [`printf`](fprintf \"c/io/fprintf\").\n\n```\n#include <stdarg.h>\n#include <stdio.h>\n \nint my_printf(const char * restrict fmt, ...)\n{\n    va_list vl;\n    va_start(vl, fmt);\n    int ret = vfprintf(stdout, fmt, vl);\n    va_end(vl);\n    return ret;\n}\n \nint main(void)\n{\n    my_printf(\"Rounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    my_printf(\"Padding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    my_printf(\"Scientific:\\t%E %e\\n\", 1.5, 1.5);\n    my_printf(\"Hexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n}\n```\n\nPossible output:\n\n```\nRounding:       1.500000 2 1.30000000000000004440892098500626\nPadding:        01.50 1.50  1.50\nScientific:     1.500000E+00 1.500000e+00\nHexadecimal:    0x1.8p+0 0X1.8P+0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.1 Introduction (p: 217-218)\n  - 7.21.2 Streams (p: 217-219)\n  - 7.21.2 Files (p: 219-221)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.1 Introduction (p: 296-298)\n  - 7.21.2 Streams (p: 298-299)\n  - 7.21.2 Files (p: 300-302)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.1 Introduction (p: 262-264)\n  - 7.19.2 Streams (p: 264-265)\n  - 7.19.2 Files (p: 266-268)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 7.9.1 Introduction\n  - 7.9.2 Streams\n  - 7.9.3 Files\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/std_streams](https://en.cppreference.com/w/c/io/std_streams)"
- name: Storage-class specifiers
  summary: 'Specify storage duration and linkage of objects and functions:'
  description: "# Storage-class specifiers\n\nSpecify *storage duration* and *linkage* of objects and functions:\n\n- `auto` - automatic duration and no linkage\n- `register` - automatic duration and no linkage; address of this variable cannot be taken\n- `static` - static duration and internal linkage (unless at block scope)\n- `extern` - static duration and external linkage (unless already declared internal)\n\n[TABLE]\n\n### Explanation\n\nStorage-class specifiers appear in [declarations](declarations \"c/language/declarations\") and [compound literal](compound_literal \"c/language/compound literal\") expressions(since C23). At most one specifier may be used, except that \\_Thread_local(until C23)[thread_local](http://en.cppreference.com/w/c/thread/thread_local)(since C23) may be combined with static or extern to adjust linkage(since C11). The storage-class specifiers determine two independent properties of the names they declare: *storage duration* and *linkage*.\n\n1) The auto specifier is only allowed for objects declared at block scope (except function parameter lists). It indicates automatic storage duration and no linkage, which are the defaults for these kinds of declarations.\n\n2) The register specifier is only allowed for objects declared at block scope, including function parameter lists. It indicates automatic storage duration and no linkage (which is the default for these kinds of declarations), but additionally hints the optimizer to store the value of this variable in a CPU register if possible. Regardless of whether this optimization takes place or not, variables declared register cannot be used as arguments to the [address-of operator](operator_member_access \"c/language/operator member access\"), cannot use [alignas](_alignas \"c/language/ Alignas\")(since C11), and register arrays are not convertible to pointers.\n\n3) The static specifier specifies both static storage duration (unless combined with \\_Thread_local)(since C11) and internal linkage (unless used at block scope). It can be used with functions at file scope and with variables at both file and block scope, but not in function parameter lists.\n\n4) The extern specifier specifies static storage duration (unless combined with \\_Thread_local(until C23)[thread_local](http://en.cppreference.com/w/c/thread/thread_local)(since C23))(since C11) and external linkage. It can be used with function and object declarations in both file and block scope (excluding function parameter lists). If extern appears on a redeclaration of an identifier that was already declared with internal linkage, the linkage remains internal. Otherwise (if the prior declaration was external, no-linkage, or is not in scope), the linkage is external.\n\n|                                                                                                                                                                                                                                                                                                                                                                                                                       |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| 5) \\_Thread_local(until C23)[thread_local](http://en.cppreference.com/w/c/thread/thread_local)(since C23) indicates *thread storage duration*. It cannot be used with function declarations. If it is used on a declaration of an object, it must be present on every declaration of the same object. If it is used on a block-scope declaration, it must be combined with either static or extern to decide linkage. | (since C11) |\n\nIf no storage-class specifier is provided, the defaults are:\n\nextern for all functions\n\nextern for objects at file scope\n\nauto for objects at block scope\n\nFor any struct or union declared with a storage-class specifier, the storage duration (but not linkage) applies to their members, recursively.\n\nFunction declarations at block scope can use extern or none at all. Function declarations at file scope can use extern or static.\n\nFunction parameters cannot use any storage-class specifiers other than register. Note that static has special meaning in function parameters of array type.\n\n### Storage duration\n\nEvery [object](object \"c/language/object\") has a property called *storage duration*, which limits the object [lifetime](lifetime \"c/language/lifetime\"). There are four kinds of storage duration in C:\n\n- ***automatic*** storage duration. The storage is allocated when the [block](statements#Compound_statements \"c/language/statements\") in which the object was declared is entered and deallocated when it is exited by any means ([goto](goto \"c/language/goto\"), [return](return \"c/language/return\"), reaching the end). One exception is the [VLAs](array#Variable-length_arrays \"c/language/array\"); their storage is allocated when the declaration is executed, not on block entry, and deallocated when the declaration goes out of scope, not when the block is exited(since C99). If the block is entered recursively, a new allocation is performed for every recursion level. All function parameters and non-static block-scope objects have this storage duration, as well as [compound literals](compound_literal \"c/language/compound literal\") used at block scope(until C23)\n- ***static*** storage duration. The storage duration is the entire execution of the program, and the value stored in the object is initialized only once, prior to [main function](main_function \"c/language/main function\"). All objects declared static and all objects with either internal or external linkage that aren't declared \\_Thread_local(until C23)[thread_local](http://en.cppreference.com/w/c/thread/thread_local)(since C23)(since C11) have this storage duration.\n\n[TABLE]\n\n- ***allocated*** storage duration. The storage is allocated and deallocated on request, using [dynamic memory allocation](../memory \"c/memory\") functions.\n\n#### Linkage\n\nLinkage refers to the ability of an identifier (variable or function) to be referred to in other scopes. If a variable or function with the same identifier is declared in several scopes, but cannot be referred to from all of them, then several instances of the variable are generated. The following linkages are recognized:\n\n- ***no linkage***. The identifier can be referred to only from the scope it is in. All function parameters and all non-extern block-scope variables (including the ones declared static) have this linkage.\n  - ***internal linkage***. The identifier can be referred to from all scopes in the current translation unit. All static file-scope identifiers (both functions and variables) have this linkage.\n  - ***external linkage***. The identifier can be referred to from any other translation units in the entire program. All non-static functions, all extern variables (unless earlier declared static), and all file-scope non-static variables have this linkage.\n\nIf the same identifier appears with both internal and external linkage in the same translation unit, the behavior is undefined. This is possible when [tentative definitions](extern \"c/language/extern\") are used.\n\n#### Linkage and libraries\n\nDeclarations with external linkage are commonly made available in header files so that all translation units that [\\#include](../preprocessor/include \"c/preprocessor/include\") the file may refer to the same identifier that are defined elsewhere.\n\nAny declaration with internal linkage that appears in a header file results in a separate and distinct object in each translation unit that includes that file.\n\n[TABLE]\n\n### Keywords\n\n[`auto`](../keyword/auto \"c/keyword/auto\"), [`register`](../keyword/register \"c/keyword/register\"), [`static`](../keyword/static \"c/keyword/static\"), [`extern`](../keyword/extern \"c/keyword/extern\"), [`_Thread_local`](../keyword/_thread_local \"c/keyword/ Thread local\") [`thread_local`](../keyword/thread_local \"c/keyword/thread local\")\n\n### Notes\n\n|                                                                                                                                                                                                         |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The keyword \\_Thread_local is usually used through the convenience macro [`thread_local`](../thread/thread_local \"c/thread/thread local\"), defined in the header [`<threads.h>`](../thread \"c/thread\"). | (until C23) |\n\nThe [`typedef`](typedef \"c/language/typedef\") and [`constexpr`](constexpr \"c/language/constexpr\")(since C23) specifiers are formally listed as storage-class specifiers in the C language grammar, but do not specify storage.\n\n|                                                     |             |\n|-----------------------------------------------------|-------------|\n| The auto specifier is also used for type inference. | (since C23) |\n\nNames at file scope that are const and not extern have external linkage in C (as the default for all file-scope declarations), but internal linkage in C++.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \n// static storage duration\nint A;\n \nint main(void)\n{\n    printf(\"&A = %p\\n\", (void*)&A);\n \n    // automatic storage duration\n    int A = 1;   // hides global A\n    printf(\"&A = %p\\n\", (void*)&A);\n \n    // allocated storage duration\n    int* ptr_1 = malloc(sizeof(int));   // start allocated storage duration\n    printf(\"address of int in allocated memory = %p\\n\", (void*)ptr_1);\n    free(ptr_1);                        // stop allocated storage duration\n}\n```\n\nPossible output:\n\n```\n&A = 0x600ae4\n&A = 0x7ffefb064f5c\naddress of int in allocated memory = 0x1f28c30\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.2.2 Linkages of identifiers (p: 35-36)\n  - 6.2.4 Storage durations of objects (p: 36-37)\n  - 6.7.1 Storage-class specifiers (p: 97-100)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.2.2 Linkages of identifiers (p: 29-30)\n  - 6.2.4 Storage durations of objects (p: 30)\n  - 6.7.1 Storage-class specifiers (p: 79)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.2.2 Linkages of identifiers (p: 36-37)\n  - 6.2.4 Storage durations of objects (p: 38-39)\n  - 6.7.1 Storage-class specifiers (p: 109-110)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.2.2 Linkages of identifiers (p: 30-31)\n  - 6.2.4 Storage durations of objects (p: 32)\n  - 6.7.1 Storage-class specifiers (p: 98-99)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.2.2 Linkages of identifiers\n  - 3.1.2.4 Storage durations of objects\n  - 3.5.1 Storage-class specifiers\n\n### See also\n\n|                                                                                                                                               |     |\n|-----------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/storage_duration \"cpp/language/storage duration\") for Storage class specifiers |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/storage_duration](https://en.cppreference.com/w/c/language/storage_duration)"
- name: strcat
  summary: Because strcat needs to seek to the end of dest on each call, it is inefficient to concatenate many strings into one using strcat
  description: "# strcat, strcat_s\n\n[TABLE]\n\n1) Appends a copy of the null-terminated byte string pointed to by `src` to the end of the null-terminated byte string pointed to by `dest`. The character `src[0]` replaces the null terminator at the end of `dest`. The resulting byte string is null-terminated.\n\nThe behavior is undefined if the destination array is not large enough for the contents of both `src` and `dest` and the terminating null character. The behavior is undefined if the strings overlap. The behavior is undefined if either `dest` or `src` is not a pointer to a null-terminated byte string.\n\n2) Same as (1), except that it may clobber the rest of the destination array (from the last character written to `destsz`) with unspecified values and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` is zero or greater than `RSIZE_MAX`\n- there is no null terminator in the first `destsz` bytes of `dest`\n- truncation would occur (the available space at the end of `dest` would not fit every character, including the null terminator, of `src`)\n- overlap would occur between the source and the destination strings\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< [`strlen`](http://en.cppreference.com/w/c/string/byte/strlen)`(``dest``)``+`[`strlen`](http://en.cppreference.com/w/c/string/byte/strlen)`(``src``)``+``1` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `strcat_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                                                     |\n|--------|-----|-------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the null-terminated byte string to append to                             |\n| src    | \\-  | pointer to the null-terminated byte string to copy from                             |\n| destsz | \\-  | maximum number of characters to write, typically the size of the destination buffer |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes zero to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX`).\n\n### Notes\n\nBecause `strcat` needs to seek to the end of `dest` on each call, it is inefficient to concatenate many strings into one using `strcat`.\n\n`strcat_s` is allowed to clobber the destination array from the last character written up to `destsz` in order to improve efficiency: it may copy in multibyte blocks and then check for null bytes.\n\nThe function `strcat_s` is similar to the [BSD function `strlcat`](https://www.freebsd.org/cgi/man.cgi?query=strlcat&sektion=3), except that\n\n- `strlcat` truncates the source string to fit in the destination\n- `strlcat` does not perform all the runtime checks that `strcat_s` does\n- `strlcat` does not make failures obvious by setting the destination to a null string or calling a handler if the call fails.\n\nAlthough `strcat_s` prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked [`strncat_s`](strncat \"c/string/byte/strncat\") instead.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h> \n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void) \n{\n    char str[50] = \"Hello \";\n    char str2[50] = \"World!\";\n    strcat(str, str2);\n    strcat(str, \" ...\");\n    strcat(str, \" Goodbye World!\");\n    puts(str);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcat_s(str, sizeof str, \" ... \");\n    printf(\"str = \\\"%s\\\", r = %d\\n\", str, r);\n    r = strcat_s(str, sizeof str, \" and this is too much\");\n    printf(\"str = \\\"%s\\\", r = %d\\n\", str, r);\n#endif\n}\n```\n\nPossible output:\n\n```\nHello World! ... Goodbye World!\nstr = \"Hello World! ... Goodbye World! ... \", r = 0\nstr = \"\", r = 22\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.3.1 The strcat function (p: 364)\n  - K.3.7.2.1 The strcat_s function (p: 617-618)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.3.1 The strcat function (p: 327)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.3.1 The strcat function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strcat](https://en.cppreference.com/w/c/string/byte/strcat)"
- name: strcat_s
  summary: Because strcat needs to seek to the end of dest on each call, it is inefficient to concatenate many strings into one using strcat
  description: "# strcat, strcat_s\n\n[TABLE]\n\n1) Appends a copy of the null-terminated byte string pointed to by `src` to the end of the null-terminated byte string pointed to by `dest`. The character `src[0]` replaces the null terminator at the end of `dest`. The resulting byte string is null-terminated.\n\nThe behavior is undefined if the destination array is not large enough for the contents of both `src` and `dest` and the terminating null character. The behavior is undefined if the strings overlap. The behavior is undefined if either `dest` or `src` is not a pointer to a null-terminated byte string.\n\n2) Same as (1), except that it may clobber the rest of the destination array (from the last character written to `destsz`) with unspecified values and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` is zero or greater than `RSIZE_MAX`\n- there is no null terminator in the first `destsz` bytes of `dest`\n- truncation would occur (the available space at the end of `dest` would not fit every character, including the null terminator, of `src`)\n- overlap would occur between the source and the destination strings\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< [`strlen`](http://en.cppreference.com/w/c/string/byte/strlen)`(``dest``)``+`[`strlen`](http://en.cppreference.com/w/c/string/byte/strlen)`(``src``)``+``1` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `strcat_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                                                     |\n|--------|-----|-------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the null-terminated byte string to append to                             |\n| src    | \\-  | pointer to the null-terminated byte string to copy from                             |\n| destsz | \\-  | maximum number of characters to write, typically the size of the destination buffer |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes zero to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX`).\n\n### Notes\n\nBecause `strcat` needs to seek to the end of `dest` on each call, it is inefficient to concatenate many strings into one using `strcat`.\n\n`strcat_s` is allowed to clobber the destination array from the last character written up to `destsz` in order to improve efficiency: it may copy in multibyte blocks and then check for null bytes.\n\nThe function `strcat_s` is similar to the [BSD function `strlcat`](https://www.freebsd.org/cgi/man.cgi?query=strlcat&sektion=3), except that\n\n- `strlcat` truncates the source string to fit in the destination\n- `strlcat` does not perform all the runtime checks that `strcat_s` does\n- `strlcat` does not make failures obvious by setting the destination to a null string or calling a handler if the call fails.\n\nAlthough `strcat_s` prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked [`strncat_s`](strncat \"c/string/byte/strncat\") instead.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h> \n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void) \n{\n    char str[50] = \"Hello \";\n    char str2[50] = \"World!\";\n    strcat(str, str2);\n    strcat(str, \" ...\");\n    strcat(str, \" Goodbye World!\");\n    puts(str);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcat_s(str, sizeof str, \" ... \");\n    printf(\"str = \\\"%s\\\", r = %d\\n\", str, r);\n    r = strcat_s(str, sizeof str, \" and this is too much\");\n    printf(\"str = \\\"%s\\\", r = %d\\n\", str, r);\n#endif\n}\n```\n\nPossible output:\n\n```\nHello World! ... Goodbye World!\nstr = \"Hello World! ... Goodbye World! ... \", r = 0\nstr = \"\", r = 22\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.3.1 The strcat function (p: 364)\n  - K.3.7.2.1 The strcat_s function (p: 617-618)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.3.1 The strcat function (p: 327)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.3.1 The strcat function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strcat](https://en.cppreference.com/w/c/string/byte/strcat)"
- name: strchr
  summary: The behavior is undefined if str is not a pointer to a null-terminated byte string
  description: "# strchr\n\n[TABLE]\n\n1) Finds the first occurrence of `ch` (after conversion to `char` as if by `(char)ch`) in the null-terminated byte string pointed to by `str` (each character interpreted as `unsigned char`). The terminating null character is considered to be a part of the string and can be found when searching for `'\\0'`.\n\n2) Type-generic function equivalent to (1). Let `T` be an unqualified character object type.\n\n- If `str` is of type `const T*`, the return type is `const char*`.\n- Otherwise, if `str` is of type `T*`, the return type is `char*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(strchr)` or a function pointer is used), the actual function declaration (1) becomes visible.\n\nThe behavior is undefined if `str` is not a pointer to a null-terminated byte string.\n\n### Parameters\n\n|     |     |                                                           |\n|-----|-----|-----------------------------------------------------------|\n| str | \\-  | pointer to the null-terminated byte string to be analyzed |\n| ch  | \\-  | character to search for                                   |\n\n### Return value\n\nPointer to the found character in `str`, or null pointer if no such character is found.\n\n### Example\n\n```\n#include <stdio.h>\n#include <string.h>\n \nint main(void)\n{\n  const char *str = \"Try not. Do, or do not. There is no try.\";\n  char target = 'T';\n  const char *result = str;\n \n  while((result = strchr(result, target)) != NULL) {\n    printf(\"Found '%c' starting at '%s'\\n\", target, result);\n    ++result; // Increment result, otherwise we'll find target at the same location\n  }\n}\n```\n\nOutput:\n\n```\nFound 'T' starting at 'Try not. Do, or do not. There is no try.'\nFound 'T' starting at 'There is no try.'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.5.2 The strchr function (p: 367-368)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.5.2 The strchr function (p: 330)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.5.2 The strchr function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strchr](https://en.cppreference.com/w/c/string/byte/strchr)"
- name: strcmp
  summary: Compares two null-terminated byte strings lexicographically
  description: "# strcmp\n\n[TABLE]\n\nCompares two null-terminated byte strings lexicographically.\n\nThe sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as `unsigned char`) that differ in the strings being compared.\n\nThe behavior is undefined if `lhs` or `rhs` are not pointers to null-terminated byte strings.\n\n### Parameters\n\n|          |     |                                                         |\n|----------|-----|---------------------------------------------------------|\n| lhs, rhs | \\-  | pointers to the null-terminated byte strings to compare |\n\n### Return value\n\nNegative value if `lhs` appears before `rhs` in lexicographical order.\n\nZero if `lhs` and `rhs` compare equal.\n\nPositive value if `lhs` appears after `rhs` in lexicographical order.\n\n### Notes\n\nThis function is not locale-sensitive, unlike [`strcoll`](strcoll \"c/string/byte/strcoll\") and [`strxfrm`](strxfrm \"c/string/byte/strxfrm\").\n\n### Example\n\n```\n#include <string.h>\n#include <stdio.h>\n \nvoid demo(const char* lhs, const char* rhs)\n{\n    int rc = strcmp(lhs, rhs);\n    const char *rel = rc < 0 ? \"precedes\" : rc > 0 ? \"follows\" : \"equals\";\n    printf(\"[%s] %s [%s]\\n\", lhs, rel, rhs);\n}\n \nint main(void)\n{\n    const char* string = \"Hello World!\";\n    demo(string, \"Hello!\");\n    demo(string, \"Hello\");\n    demo(string, \"Hello there\");\n    demo(\"Hello, everybody!\" + 12, \"Hello, somebody!\" + 11);\n}\n```\n\nOutput:\n\n```\n[Hello World!] precedes [Hello!]\n[Hello World!] follows [Hello]\n[Hello World!] precedes [Hello there]\n[body!] equals [body!]\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.4.2 The strcmp function (p: 365-366)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.4.2 The strcmp function (p: 328-329)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.4.2 The strcmp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strcmp](https://en.cppreference.com/w/c/string/byte/strcmp)"
- name: strcoll
  summary: Compares two null-terminated byte strings according to the current locale as defined by the LC_COLLATE category
  description: "# strcoll\n\n[TABLE]\n\nCompares two null-terminated byte strings according to the current locale as defined by the [`LC_COLLATE`](../../locale/lc_categories \"c/locale/LC categories\") category.\n\n### Parameters\n\n|          |     |                                                         |\n|----------|-----|---------------------------------------------------------|\n| lhs, rhs | \\-  | pointers to the null-terminated byte strings to compare |\n\n### Return value\n\n- Negative value if `lhs` is *less than* (precedes) `rhs`.\n- `​0​` if `lhs` is *equal to* `rhs`.\n- Positive value if `lhs` is *greater than* (follows) `rhs`.\n\n### Notes\n\nCollation order is the dictionary order: the position of the letter in the national alphabet (its *equivalence class*) has higher priority than its case or variant. Within an equivalence class, lowercase characters collate before their uppercase equivalents and locale-specific order may apply to the characters with diacritics. In some locales, groups of characters compare as single *collation units*. For example, `\"ch\"` in Czech follows `\"h\"` and precedes `\"i\"`, and `\"dzs\"` in Hungarian follows `\"dz\"` and precedes `\"g\"`.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <string.h>\n \nint main(void)\n{\n    setlocale(LC_COLLATE, \"cs_CZ.utf8\");\n    // Alternatively, ISO-8859-2 (a.k.a. Latin-2)\n    // may also work on some OS:\n    // setlocale(LC_COLLATE, \"cs_CZ.iso88592\");\n \n    const char* s1 = \"hrnec\";\n    const char* s2 = \"chrt\";\n \n    printf(\"In the Czech locale: \");\n    if (strcoll(s1, s2) < 0)\n        printf(\"%s before %s\\n\", s1, s2);\n    else\n        printf(\"%s before %s\\n\", s2, s1);\n \n    printf(\"In lexicographical comparison: \");\n    if (strcmp(s1, s2) < 0)\n        printf(\"%s before %s\\n\", s1, s2);\n    else\n        printf(\"%s before %s\\n\", s2, s1);\n}\n```\n\nOutput:\n\n```\nIn the Czech locale: hrnec before chrt\nIn lexicographical comparison: chrt before hrnec\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.24.4.3 The strcoll function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.4.3 The strcoll function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.4.3 The strcoll function (p: 366)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.4.3 The strcoll function (p: 329)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.4.3 The strcoll function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strcoll](https://en.cppreference.com/w/c/string/byte/strcoll)"
- name: strcpy
  summary: 'strcpy_s is allowed to clobber the destination array from the last character written up to destsz in order to improve efficiency: it may copy in multibyte blocks and then check for null bytes'
  description: "# strcpy, strcpy_s\n\n[TABLE]\n\n1) Copies the null-terminated byte string pointed to by `src`, including the null terminator, to the character array whose first element is pointed to by `dest`.\n\nThe behavior is undefined if the `dest` array is not large enough. The behavior is undefined if the strings overlap. The behavior is undefined if either `dest` is not a pointer to a character array or `src` is not a pointer to a null-terminated byte string.\n\n2) Same as (1), except that it may clobber the rest of the destination array with unspecified values and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` is zero or greater than `RSIZE_MAX`\n- `destsz` is less or equal `strnlen_s(src, destsz)`; in other words, truncation would occur\n- overlap would occur between the source and the destination strings\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\<= `strnlen_s(src, destsz)` \\< `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `strcpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                                                     |\n|--------|-----|-------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the character array to write to                                          |\n| src    | \\-  | pointer to the null-terminated byte string to copy from                             |\n| destsz | \\-  | maximum number of characters to write, typically the size of the destination buffer |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes zero to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX`).\n\n### Notes\n\n`strcpy_s` is allowed to clobber the destination array from the last character written up to `destsz` in order to improve efficiency: it may copy in multibyte blocks and then check for null bytes.\n\nThe function `strcpy_s` is similar to the BSD function `strlcpy`, except that\n\n- `strlcpy` truncates the source string to fit in the destination (which is a security risk)\n- `strlcpy` does not perform all the runtime checks that `strcpy_s` does\n- `strlcpy` does not make failures obvious by setting the destination to a null string or calling a handler if the call fails.\n\nAlthough `strcpy_s` prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked [`strncpy_s`](strncpy \"c/string/byte/strncpy\") instead.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char *src = \"Take the test.\";\n//  src[0] = 'M' ; // this would be undefined behavior\n    char dst[strlen(src) + 1]; // +1 to accommodate for the null terminator\n    strcpy(dst, src);\n    dst[0] = 'M'; // OK\n    printf(\"src = %s\\ndst = %s\\n\", src, dst);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcpy_s(dst, sizeof dst, src);\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n    r = strcpy_s(dst, sizeof dst, \"Take even more tests.\");\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n#endif\n}\n```\n\nPossible output:\n\n```\nsrc = Take the test.\ndst = Make the test.\ndst = \"Take the test.\", r = 0\ndst = \"\", r = 22\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.2.3 The strcpy function (p: 264-265)\n  - K.3.7.1.3 The strcpy_s function (p: 447)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.2.3 The strcpy function (p: 363)\n  - K.3.7.1.3 The strcpy_s function (p: 615-616)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.2.3 The strcpy function (p: 326)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.2.3 The strcpy function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strcpy](https://en.cppreference.com/w/c/string/byte/strcpy)"
- name: strcpy_s
  summary: 'strcpy_s is allowed to clobber the destination array from the last character written up to destsz in order to improve efficiency: it may copy in multibyte blocks and then check for null bytes'
  description: "# strcpy, strcpy_s\n\n[TABLE]\n\n1) Copies the null-terminated byte string pointed to by `src`, including the null terminator, to the character array whose first element is pointed to by `dest`.\n\nThe behavior is undefined if the `dest` array is not large enough. The behavior is undefined if the strings overlap. The behavior is undefined if either `dest` is not a pointer to a character array or `src` is not a pointer to a null-terminated byte string.\n\n2) Same as (1), except that it may clobber the rest of the destination array with unspecified values and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` is zero or greater than `RSIZE_MAX`\n- `destsz` is less or equal `strnlen_s(src, destsz)`; in other words, truncation would occur\n- overlap would occur between the source and the destination strings\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\<= `strnlen_s(src, destsz)` \\< `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `strcpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                                                     |\n|--------|-----|-------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the character array to write to                                          |\n| src    | \\-  | pointer to the null-terminated byte string to copy from                             |\n| destsz | \\-  | maximum number of characters to write, typically the size of the destination buffer |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes zero to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX`).\n\n### Notes\n\n`strcpy_s` is allowed to clobber the destination array from the last character written up to `destsz` in order to improve efficiency: it may copy in multibyte blocks and then check for null bytes.\n\nThe function `strcpy_s` is similar to the BSD function `strlcpy`, except that\n\n- `strlcpy` truncates the source string to fit in the destination (which is a security risk)\n- `strlcpy` does not perform all the runtime checks that `strcpy_s` does\n- `strlcpy` does not make failures obvious by setting the destination to a null string or calling a handler if the call fails.\n\nAlthough `strcpy_s` prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked [`strncpy_s`](strncpy \"c/string/byte/strncpy\") instead.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char *src = \"Take the test.\";\n//  src[0] = 'M' ; // this would be undefined behavior\n    char dst[strlen(src) + 1]; // +1 to accommodate for the null terminator\n    strcpy(dst, src);\n    dst[0] = 'M'; // OK\n    printf(\"src = %s\\ndst = %s\\n\", src, dst);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    int r = strcpy_s(dst, sizeof dst, src);\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n    r = strcpy_s(dst, sizeof dst, \"Take even more tests.\");\n    printf(\"dst = \\\"%s\\\", r = %d\\n\", dst, r);\n#endif\n}\n```\n\nPossible output:\n\n```\nsrc = Take the test.\ndst = Make the test.\ndst = \"Take the test.\", r = 0\ndst = \"\", r = 22\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.2.3 The strcpy function (p: 264-265)\n  - K.3.7.1.3 The strcpy_s function (p: 447)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.2.3 The strcpy function (p: 363)\n  - K.3.7.1.3 The strcpy_s function (p: 615-616)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.2.3 The strcpy function (p: 326)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.2.3 The strcpy function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strcpy](https://en.cppreference.com/w/c/string/byte/strcpy)"
- name: strcspn
  summary: Returns the length of the maximum initial segment of the null-terminated byte string pointed to by dest, that consists of only the characters not found in the null-terminated byte string pointed to by src
  description: "# strcspn\n\n[TABLE]\n\nReturns the length of the maximum initial segment of the null-terminated byte string pointed to by `dest`, that consists of only the characters *not* found in the null-terminated byte string pointed to by `src`.\n\nThe behavior is undefined if either `dest` or `src` is not a pointer to a null-terminated byte string.\n\n### Parameters\n\n|      |     |                                                                                       |\n|------|-----|---------------------------------------------------------------------------------------|\n| dest | \\-  | pointer to the null-terminated byte string to be analyzed                             |\n| src  | \\-  | pointer to the null-terminated byte string that contains the characters to search for |\n\n### Return value\n\nThe length of the maximum initial segment that contains only characters not found in the null-terminated byte string pointed to by `src`\n\n### Notes\n\nThe function name stands for \"complementary span\" because the function searches for characters not found in `src`, that is the complement of `src`.\n\n### Example\n\n```\n#include <string.h>\n#include <stdio.h>\n \nint main(void)\n{\n    const char *string = \"abcde312$#@\";\n    const char *invalid = \"*$#\";\n \n    size_t valid_len = strcspn(string, invalid);\n    if(valid_len != strlen(string))\n       printf(\"'%s' contains invalid chars starting at position %zu\\n\",\n               string, valid_len);\n}\n```\n\nOutput:\n\n```\n'abcde312$#@' contains invalid chars starting at position 8\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.5.3 The strcspn function (p: 368)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.5.3 The strcspn function (p: 331)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.5.3 The strcspn function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strcspn](https://en.cppreference.com/w/c/string/byte/strcspn)"
- name: strdup
  summary: Returns a pointer to a null-terminated byte string, which is a duplicate of the string pointed to by src
  description: "# strdup\n\n[TABLE]\n\nReturns a pointer to a null-terminated byte string, which is a duplicate of the string pointed to by `src`. The space for the new string is obtained as if the [`malloc`](../../memory/malloc \"c/memory/malloc\") was invoked. The returned pointer must be passed to [`free`](../../memory/free \"c/memory/free\") to avoid a memory leak.\n\nIf an error occurs, a null pointer is returned and [`errno`](../../error/errno \"c/error/errno\") might be set.\n\n### Parameters\n\n|     |     |                                                         |\n|-----|-----|---------------------------------------------------------|\n| src | \\-  | pointer to the null-terminated byte string to duplicate |\n\n### Return value\n\nA pointer to the newly allocated string, or a null pointer if an error occurred.\n\n### Notes\n\nThe function is identical to the [POSIX strdup](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strdup.html).\n\n### Example\n\n```\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char *s1 = \"Duplicate me!\";\n    char *s2 = strdup(s1);\n    printf(\"s2 = \\\"%s\\\"\\n\", s2);\n    free(s2);\n}\n```\n\nOutput:\n\n```\ns2 = \"Duplicate me!\"\n```\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strdup](https://en.cppreference.com/w/c/string/byte/strdup)"
- name: strerror
  summary: POSIX allows subsequent calls to strerror to invalidate the pointer value returned by an earlier call
  description: "# strerror, strerror_s, strerrorlen_s\n\n[TABLE]\n\n1) Returns a pointer to the textual description of the system error code `errnum`, identical to the description that would be printed by [`perror()`](../../io/perror \"c/io/perror\").\n\n`errnum` is usually acquired from the `errno` variable, however the function accepts any value of type `int`. The contents of the string are locale-specific.\n\nThe returned string must not be modified by the program, but may be overwritten by a subsequent call to the `strerror` function. `strerror` is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.\n\n2) Same as (1), except that the message is copied into user-provided storage `buf`. No more than `bufsz-1` bytes are written, the buffer is always null-terminated. If the message had to be truncated to fit the buffer and `bufsz` is greater than 3, then only `bufsz-4` bytes are written, and the characters `\"...\"` are appended before the null terminator. In addition, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `buf` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n\nThe behavior is undefined if writing to `buf` occurs past the end of the array, which can happen when the size of the buffer pointed to by `buf` is less than the number of characters in the error message which in turn is less than `bufsz`.\n\n3) Computes the length of the untruncated locale-specific error message that `strerror_s` would write if it were called with `errnum`. The length does not include the null terminator. As with all bounds-checked functions, `strerror_s` and `strerrorlen_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                           |\n|--------|-----|-------------------------------------------|\n| errnum | \\-  | integral value referring to an error code |\n| buf    | \\-  | pointer to a user-provided buffer         |\n| bufsz  | \\-  | size of the user-provided buffer          |\n\n### Return value\n\n1) Pointer to a null-terminated byte string corresponding to the [`errno`](../../error/errno \"c/error/errno\") error code `errnum`.\n\n2) Zero if the entire message was successfully stored in `buf`, non-zero otherwise.\n\n3) Length (not including the null terminator) of the message that `strerror_s` would return\n\n### Notes\n\n[POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strerror.html) allows subsequent calls to `strerror` to invalidate the pointer value returned by an earlier call. It also specifies that it is the [`LC_MESSAGES`](../../locale/lc_categories \"c/locale/LC categories\") locale facet that controls the contents of these messages.\n\n`strerror_s` is the only bounds-checked function that allows truncation, because providing as much information as possible about a failure was deemed to be more desirable. POSIX also defines [`strerror_r`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strerror.html) for similar purposes.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <locale.h>\n \nint main(void)\n{\n    FILE *fp = fopen(tmpnam((char[L_tmpnam]){0}), \"r\");\n    if(fp==NULL) {\n        printf(\"File opening error: %s\\n\", strerror(errno));\n        setlocale(LC_MESSAGES, \"de_DE.utf8\");\n        printf(\"Now in German: %s\\n\", strerror(errno));\n#ifdef __STDC_LIB_EXT1__\n        setlocale(LC_ALL, \"ja_JP.utf8\"); // printf needs CTYPE for multibyte output\n        size_t errmsglen = strerrorlen_s(errno) + 1;\n        char errmsg[errmsglen]; \n        strerror_s(errmsg, errmsglen, errno);\n        printf(\"Now in Japanese: %s\\n\", errmsg);\n#endif\n    }\n}\n```\n\nPossible output:\n\n```\nFile opening error: No such file or directory\nNow in German: Datei oder Verzeichnis nicht gefunden\nNow in Japanese: そのようなファイル、又はディレクトリはありません\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.6.2 The strerror function (p: 371)\n  - K.3.7.4.2 The strerror_s function (p: 622)\n  - K.3.7.4.3 The strerrorlen_s function (p: 623)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.6.2 The strerror function (p: 334)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.6.2 The strerror function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strerror](https://en.cppreference.com/w/c/string/byte/strerror)"
- name: strerror_s
  summary: POSIX allows subsequent calls to strerror to invalidate the pointer value returned by an earlier call
  description: "# strerror, strerror_s, strerrorlen_s\n\n[TABLE]\n\n1) Returns a pointer to the textual description of the system error code `errnum`, identical to the description that would be printed by [`perror()`](../../io/perror \"c/io/perror\").\n\n`errnum` is usually acquired from the `errno` variable, however the function accepts any value of type `int`. The contents of the string are locale-specific.\n\nThe returned string must not be modified by the program, but may be overwritten by a subsequent call to the `strerror` function. `strerror` is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.\n\n2) Same as (1), except that the message is copied into user-provided storage `buf`. No more than `bufsz-1` bytes are written, the buffer is always null-terminated. If the message had to be truncated to fit the buffer and `bufsz` is greater than 3, then only `bufsz-4` bytes are written, and the characters `\"...\"` are appended before the null terminator. In addition, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `buf` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n\nThe behavior is undefined if writing to `buf` occurs past the end of the array, which can happen when the size of the buffer pointed to by `buf` is less than the number of characters in the error message which in turn is less than `bufsz`.\n\n3) Computes the length of the untruncated locale-specific error message that `strerror_s` would write if it were called with `errnum`. The length does not include the null terminator. As with all bounds-checked functions, `strerror_s` and `strerrorlen_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                           |\n|--------|-----|-------------------------------------------|\n| errnum | \\-  | integral value referring to an error code |\n| buf    | \\-  | pointer to a user-provided buffer         |\n| bufsz  | \\-  | size of the user-provided buffer          |\n\n### Return value\n\n1) Pointer to a null-terminated byte string corresponding to the [`errno`](../../error/errno \"c/error/errno\") error code `errnum`.\n\n2) Zero if the entire message was successfully stored in `buf`, non-zero otherwise.\n\n3) Length (not including the null terminator) of the message that `strerror_s` would return\n\n### Notes\n\n[POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strerror.html) allows subsequent calls to `strerror` to invalidate the pointer value returned by an earlier call. It also specifies that it is the [`LC_MESSAGES`](../../locale/lc_categories \"c/locale/LC categories\") locale facet that controls the contents of these messages.\n\n`strerror_s` is the only bounds-checked function that allows truncation, because providing as much information as possible about a failure was deemed to be more desirable. POSIX also defines [`strerror_r`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strerror.html) for similar purposes.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <locale.h>\n \nint main(void)\n{\n    FILE *fp = fopen(tmpnam((char[L_tmpnam]){0}), \"r\");\n    if(fp==NULL) {\n        printf(\"File opening error: %s\\n\", strerror(errno));\n        setlocale(LC_MESSAGES, \"de_DE.utf8\");\n        printf(\"Now in German: %s\\n\", strerror(errno));\n#ifdef __STDC_LIB_EXT1__\n        setlocale(LC_ALL, \"ja_JP.utf8\"); // printf needs CTYPE for multibyte output\n        size_t errmsglen = strerrorlen_s(errno) + 1;\n        char errmsg[errmsglen]; \n        strerror_s(errmsg, errmsglen, errno);\n        printf(\"Now in Japanese: %s\\n\", errmsg);\n#endif\n    }\n}\n```\n\nPossible output:\n\n```\nFile opening error: No such file or directory\nNow in German: Datei oder Verzeichnis nicht gefunden\nNow in Japanese: そのようなファイル、又はディレクトリはありません\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.6.2 The strerror function (p: 371)\n  - K.3.7.4.2 The strerror_s function (p: 622)\n  - K.3.7.4.3 The strerrorlen_s function (p: 623)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.6.2 The strerror function (p: 334)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.6.2 The strerror function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strerror](https://en.cppreference.com/w/c/string/byte/strerror)"
- name: strerrorlen_s
  summary: POSIX allows subsequent calls to strerror to invalidate the pointer value returned by an earlier call
  description: "# strerror, strerror_s, strerrorlen_s\n\n[TABLE]\n\n1) Returns a pointer to the textual description of the system error code `errnum`, identical to the description that would be printed by [`perror()`](../../io/perror \"c/io/perror\").\n\n`errnum` is usually acquired from the `errno` variable, however the function accepts any value of type `int`. The contents of the string are locale-specific.\n\nThe returned string must not be modified by the program, but may be overwritten by a subsequent call to the `strerror` function. `strerror` is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.\n\n2) Same as (1), except that the message is copied into user-provided storage `buf`. No more than `bufsz-1` bytes are written, the buffer is always null-terminated. If the message had to be truncated to fit the buffer and `bufsz` is greater than 3, then only `bufsz-4` bytes are written, and the characters `\"...\"` are appended before the null terminator. In addition, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `buf` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n\nThe behavior is undefined if writing to `buf` occurs past the end of the array, which can happen when the size of the buffer pointed to by `buf` is less than the number of characters in the error message which in turn is less than `bufsz`.\n\n3) Computes the length of the untruncated locale-specific error message that `strerror_s` would write if it were called with `errnum`. The length does not include the null terminator. As with all bounds-checked functions, `strerror_s` and `strerrorlen_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                           |\n|--------|-----|-------------------------------------------|\n| errnum | \\-  | integral value referring to an error code |\n| buf    | \\-  | pointer to a user-provided buffer         |\n| bufsz  | \\-  | size of the user-provided buffer          |\n\n### Return value\n\n1) Pointer to a null-terminated byte string corresponding to the [`errno`](../../error/errno \"c/error/errno\") error code `errnum`.\n\n2) Zero if the entire message was successfully stored in `buf`, non-zero otherwise.\n\n3) Length (not including the null terminator) of the message that `strerror_s` would return\n\n### Notes\n\n[POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strerror.html) allows subsequent calls to `strerror` to invalidate the pointer value returned by an earlier call. It also specifies that it is the [`LC_MESSAGES`](../../locale/lc_categories \"c/locale/LC categories\") locale facet that controls the contents of these messages.\n\n`strerror_s` is the only bounds-checked function that allows truncation, because providing as much information as possible about a failure was deemed to be more desirable. POSIX also defines [`strerror_r`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strerror.html) for similar purposes.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <locale.h>\n \nint main(void)\n{\n    FILE *fp = fopen(tmpnam((char[L_tmpnam]){0}), \"r\");\n    if(fp==NULL) {\n        printf(\"File opening error: %s\\n\", strerror(errno));\n        setlocale(LC_MESSAGES, \"de_DE.utf8\");\n        printf(\"Now in German: %s\\n\", strerror(errno));\n#ifdef __STDC_LIB_EXT1__\n        setlocale(LC_ALL, \"ja_JP.utf8\"); // printf needs CTYPE for multibyte output\n        size_t errmsglen = strerrorlen_s(errno) + 1;\n        char errmsg[errmsglen]; \n        strerror_s(errmsg, errmsglen, errno);\n        printf(\"Now in Japanese: %s\\n\", errmsg);\n#endif\n    }\n}\n```\n\nPossible output:\n\n```\nFile opening error: No such file or directory\nNow in German: Datei oder Verzeichnis nicht gefunden\nNow in Japanese: そのようなファイル、又はディレクトリはありません\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.6.2 The strerror function (p: 371)\n  - K.3.7.4.2 The strerror_s function (p: 622)\n  - K.3.7.4.3 The strerrorlen_s function (p: 623)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.6.2 The strerror function (p: 334)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.6.2 The strerror function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strerror](https://en.cppreference.com/w/c/string/byte/strerror)"
- name: strfromd
  summary: Converts a floating-point value to a byte string
  description: "# strfromf, strfromd, strfromld\n\n[TABLE]\n\nConverts a floating-point value to a byte string.\n\nThe functions are equivalent to [`snprintf`](http://en.cppreference.com/w/c/io/fprintf)`(``s, n, format, fp``)`, except that the format string shall only contain the character %, an optional precision that does not contain an asterisk \\*, and one of the conversion specifiers `a`, `A`, `e`, `E`, `f`, `F`, `g`, or `G`, which applies to the type `double`, `float`, or `long double`) indicated by the function suffix (rather than by a length modifier). Use of these functions with any other format string results in undefined behavior.\n\n### Parameters\n\n|        |     |                                                                               |\n|--------|-----|-------------------------------------------------------------------------------|\n| s      | \\-  | pointer to a character string to write to                                     |\n| n      | \\-  | up to n - 1 characters may be written, plus the null terminator               |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data |\n| fp     | \\-  | floating-point value to convert                                               |\n\n### Return value\n\nThe number of characters that would have been written had `n` been sufficiently large, not counting the terminating null character. Thus, the null-terminated output has been completely written if and only if the returned value is both nonnegative and less than `n`.\n\n### Example\n\n### Reference\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.24.1.3 The strfromd, strfromf, and strfroml functions\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strfromf](https://en.cppreference.com/w/c/string/byte/strfromf)"
- name: strfromf
  summary: Converts a floating-point value to a byte string
  description: "# strfromf, strfromd, strfromld\n\n[TABLE]\n\nConverts a floating-point value to a byte string.\n\nThe functions are equivalent to [`snprintf`](http://en.cppreference.com/w/c/io/fprintf)`(``s, n, format, fp``)`, except that the format string shall only contain the character %, an optional precision that does not contain an asterisk \\*, and one of the conversion specifiers `a`, `A`, `e`, `E`, `f`, `F`, `g`, or `G`, which applies to the type `double`, `float`, or `long double`) indicated by the function suffix (rather than by a length modifier). Use of these functions with any other format string results in undefined behavior.\n\n### Parameters\n\n|        |     |                                                                               |\n|--------|-----|-------------------------------------------------------------------------------|\n| s      | \\-  | pointer to a character string to write to                                     |\n| n      | \\-  | up to n - 1 characters may be written, plus the null terminator               |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data |\n| fp     | \\-  | floating-point value to convert                                               |\n\n### Return value\n\nThe number of characters that would have been written had `n` been sufficiently large, not counting the terminating null character. Thus, the null-terminated output has been completely written if and only if the returned value is both nonnegative and less than `n`.\n\n### Example\n\n### Reference\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.24.1.3 The strfromd, strfromf, and strfroml functions\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strfromf](https://en.cppreference.com/w/c/string/byte/strfromf)"
- name: strfromld
  summary: Converts a floating-point value to a byte string
  description: "# strfromf, strfromd, strfromld\n\n[TABLE]\n\nConverts a floating-point value to a byte string.\n\nThe functions are equivalent to [`snprintf`](http://en.cppreference.com/w/c/io/fprintf)`(``s, n, format, fp``)`, except that the format string shall only contain the character %, an optional precision that does not contain an asterisk \\*, and one of the conversion specifiers `a`, `A`, `e`, `E`, `f`, `F`, `g`, or `G`, which applies to the type `double`, `float`, or `long double`) indicated by the function suffix (rather than by a length modifier). Use of these functions with any other format string results in undefined behavior.\n\n### Parameters\n\n|        |     |                                                                               |\n|--------|-----|-------------------------------------------------------------------------------|\n| s      | \\-  | pointer to a character string to write to                                     |\n| n      | \\-  | up to n - 1 characters may be written, plus the null terminator               |\n| format | \\-  | pointer to a null-terminated byte string specifying how to interpret the data |\n| fp     | \\-  | floating-point value to convert                                               |\n\n### Return value\n\nThe number of characters that would have been written had `n` been sufficiently large, not counting the terminating null character. Thus, the null-terminated output has been completely written if and only if the returned value is both nonnegative and less than `n`.\n\n### Example\n\n### Reference\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.24.1.3 The strfromd, strfromf, and strfroml functions\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strfromf](https://en.cppreference.com/w/c/string/byte/strfromf)"
- name: strftime
  summary: Converts the date and time information from a given calendar time tp to a null-terminated multibyte character string str according to format string format
  description: "# strftime\n\n[TABLE]\n\nConverts the date and time information from a given calendar time `tp` to a null-terminated multibyte character string `str` according to [format string](#Format_string) `format`. Up to `count` bytes are written.\n\n### Parameters\n\n|        |     |                                                                                                               |\n|--------|-----|---------------------------------------------------------------------------------------------------------------|\n| str    | \\-  | pointer to the first element of the char array for output                                                     |\n| count  | \\-  | maximum number of bytes to write                                                                              |\n| format | \\-  | pointer to a null-terminated multibyte character string specifying the [format of conversion](#Format_string) |\n| tp     | \\-  | pointer to a `struct`` `[`tm`](http://en.cppreference.com/w/c/chrono/tm) object specifying the time to format |\n\n### Format string\n\nThe format string consists of zero or more conversion specifiers and ordinary characters (except `%`). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with `%` character, optionally followed by `E` or `O` modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:\n\n[TABLE]\n\n### Return value\n\nThe number of bytes written into the character array pointed to by `str` not including the terminating `'\\0'` on success. If `count` was reached before the entire string could be stored, `​0​` is returned and the contents are indeterminate.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    char buff[70];\n    struct tm my_time = { .tm_year=112, // = year 2012\n                          .tm_mon=9,    // = 10th month\n                          .tm_mday=9,   // = 9th day\n                          .tm_hour=8,   // = 8 hours\n                          .tm_min=10,   // = 10 minutes\n                          .tm_sec=20    // = 20 secs\n    };\n \n    if (strftime(buff, sizeof buff, \"%A %c\", &my_time))\n        puts(buff);\n    else\n        puts(\"strftime failed\");\n \n    setlocale(LC_TIME, \"el_GR.utf8\");\n \n    if (strftime(buff, sizeof buff, \"%A %c\", &my_time))\n        puts(buff);\n    else\n        puts(\"strftime failed\");\n}\n```\n\nPossible output:\n\n```\nSunday Sun Oct  9 08:10:20 2012\nΚυριακή Κυρ 09 Οκτ 2012 08:10:20 πμ EST\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.27.3.5 The strftime function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.3.5 The strftime function (p: 288-291)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.3.5 The strftime function (p: 394-397)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.3.5 The strftime function (p: 343-347)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.3.5 The strftime function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/strftime](https://en.cppreference.com/w/c/chrono/strftime)"
- name: String literals
  summary: Constructs an unnamed object of specified character array type in-place, used when a character string needs to be embedded in source code
  description: "# String literals\n\nConstructs an unnamed object of specified character array type in-place, used when a character string needs to be embedded in source code.\n\n### Syntax\n\n|                           |       |             |\n|---------------------------|-------|-------------|\n| `\"` s-char-sequence `\"`   | \\(1\\) |             |\n| `u8\"` s-char-sequence `\"` | \\(2\\) | (since C11) |\n| `u\"` s-char-sequence `\"`  | \\(3\\) | (since C11) |\n| `U\"` s-char-sequence `\"`  | \\(4\\) | (since C11) |\n| `L\"` s-char-sequence `\"`  | \\(5\\) |             |\n\nwhere\n\n|                 |     |                                                                                                                                                                                                                                                                                               |\n|-----------------|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| s-char-sequence | \\-  | zero or more characters, each of which is either a multibyte character from the source character set (excluding (`\"`), `\\`, and newline), or character escape, hex escape, octal escape, or universal character name(since C99) as defined in [escape sequences](escape \"c/language/escape\"). |\n\n1) *character string literal*: The type of the literal is `char[N]`, where `N` is the size of the string in code units of the execution narrow encoding, including the null terminator. Each `char` element in the array is initialized from the next character in s-char-sequence using the execution character set.\n\n2) *UTF-8 string literal*: The type of the literal is `char[N]`(until C23)`char8_t[N]`(since C23), where `N` is the size of the string in UTF-8 code units including the null terminator. Each `char`(until C23)`char8_t`(since C23) element in the array is initialized from the next multibyte character in s-char-sequence using UTF-8 encoding.\n\n|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| 3) 16-bit wide string literal: The type of the literal is `char16_t[N]`, where `N` is the size of the string in code units of implementation-defined 16-bit encoding (typically UTF-16), including the null terminator. Each `char16_t` element in the array is initialized as if by executing [`mbrtoc16`](../string/multibyte/mbrtoc16 \"c/string/multibyte/mbrtoc16\") in implementation-defined locale. 4) 32-bit wide string literal: The type of the literal is `char32_t[N]`, where `N` is the size of the string in code units of implementation-defined 32-bit encoding (typically UTF-32), including the null terminator. Each `char32_t` element in the array is initialized as if by executing [`mbrtoc32`](../string/multibyte/mbrtoc32 \"c/string/multibyte/mbrtoc32\") in implementation-defined locale. | (until C23) |\n| 3) *UTF-16 string literal*: The type of the literal is `char16_t[N]`, where `N` is the size of the string in UTF-16 code units including the null terminator. Each `char16_t` element in the array is initialized from the next multibyte character in s-char-sequence using UTF-16 encoding. 4) *UTF-32 string literal*: The type of the literal is `char32_t[N]`, where `N` is the size of the string in UTF-32 code units including the null terminator. Each `char32_t` element in the array is initialized from the next multibyte character in s-char-sequence using UTF-32 encoding.                                                                                                                                                                                                                         | (since C23) |\n\n5) wide string literal: The type of the literal is `wchar_t[N]`, where `N` is the size of the string in code units of the execution wide encoding, including the null terminator. Each `wchar_t` element in the array is initialized as if by executing [`mbstowcs`](../string/multibyte/mbstowcs \"c/string/multibyte/mbstowcs\") in implementation-defined locale.\n\n### Explanation\n\nFirst, at [translation phase 6](translation_phases \"c/language/translation phases\") (after macro expansion), the adjacent string literals (that is, string literals separated by whitespace only) are concatenated.\n\n[TABLE]\n\n[TABLE]\n\nSecondly, at [translation phase 7](translation_phases \"c/language/translation phases\"), a terminating null character is added to each string literal, and then each literal initializes an unnamed array with static [storage duration](storage_duration \"c/language/storage duration\") and length just enough to contain the contents of the string literal plus one for the null terminator.\n\n```\nchar* p = \"\\x12\" \"3\"; // creates a static char[3] array holding {'\\x12', '3', '\\0'}\n                      // sets p to point to the first element of the array\n```\n\nString literals are **not modifiable** (and in fact may be placed in read-only memory such as `.rodata`). If a program attempts to modify the static array formed by a string literal, the behavior is undefined.\n\n```\nchar* p = \"Hello\";\np[1] = 'M'; // Undefined behavior\nchar a[] = \"Hello\";\na[1] = 'M'; // OK: a is not a string literal\n```\n\nIt is neither required nor forbidden for identical string literals to refer to the same location in memory. Moreover, overlapping string literals or string literals that are substrings of other string literals may be combined.\n\n```\n\"def\" == 3+\"abcdef\"; // may be 1 or 0, implementation-defined\n```\n\n### Notes\n\nA string literal is not necessarily a string; if a string literal has embedded null characters, it represents an array which contains more than one string:\n\n```\nchar* p = \"abc\\0def\"; // strlen(p) == 3, but the array has size 8\n```\n\nIf a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence, but string concatenation can be used as a workaround:\n\n```\n//char* p = \"\\xfff\"; // error: hex escape sequence out of range\nchar* p = \"\\xff\"\"f\"; // okay, the literal is char[3] holding {'\\xff', 'f', '\\0'}\n```\n\nString literals can be used to [initialize arrays](array_initialization \"c/language/array initialization\"), and if the size of the array is one less the size of the string literal, the null terminator is ignored:\n\n```\nchar a1[] = \"abc\"; // a1 is char[4] holding {'a', 'b', 'c', '\\0'}\nchar a2[4] = \"abc\"; // a2 is char[4] holding {'a', 'b', 'c', '\\0'}\nchar a3[3] = \"abc\"; // a3 is char[3] holding {'a', 'b', 'c'}\n```\n\nThe encoding of character string literals (1) and wide string literals (5) is implementation-defined. For example, gcc selects them with the [commandline options](https://gcc.gnu.org/onlinedocs/cpp/Invocation.html) `-fexec-charset` and `-fwide-exec-charset`.\n\nAlthough mixed wide string literal concatenation is allowed in C11, almost all compilers reject such concatenation (the only known exception is [SDCC](http://sdcc.sourceforge.net/)), and its usage experience is unknown. As a result, allowance of mixed wide string literal concatenation is removed in C23.\n\n### Example\n\n```\n#include <inttypes.h>\n#include <locale.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <uchar.h>\n \nint main(void)\n{\n    char s1[] = \"a猫🍌\"; // or \"a\\u732B\\U0001F34C\"\n#if __STDC_VERSION__ >= 202311L\n    char8_t\n#else\n    char\n#endif\n    s2[] = u8\"a猫🍌\";\n    char16_t s3[] = u\"a猫🍌\";\n    char32_t s4[] = U\"a猫🍌\";\n    wchar_t s5[] = L\"a猫🍌\";\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"  \\\"%s\\\" is a char[%zu] holding     { \", s1, sizeof s1 / sizeof *s1);\n    for(size_t n = 0; n < sizeof s1 / sizeof *s1; ++n)\n        printf(\"0x%02X \", +(unsigned char)s1[n]);\n    puts(\"}\");\n    printf(\n#if __STDC_VERSION__ >= 202311L\n    \"u8\\\"%s\\\" is a char8_t[%zu] holding  { \"\n#else\n    \"u8\\\"%s\\\" is a char[%zu] holding     { \"\n#endif\n, s2, sizeof s2 / sizeof *s2);\n    for(size_t n = 0; n < sizeof s2 / sizeof *s2; ++n)\n#if __STDC_VERSION__ >= 202311L\n       printf(\"0x%02X \", s2[n]);\n#else\n       printf(\"0x%02X \", +(unsigned char)s2[n]);\n#endif\n    puts(\"}\");\n    printf(\" u\\\"a猫🍌\\\" is a char16_t[%zu] holding { \", sizeof s3 / sizeof *s3);\n    for(size_t n = 0; n < sizeof s3 / sizeof *s3; ++n)\n       printf(\"0x%04\" PRIXLEAST16\" \", s3[n]);\n    puts(\"}\");\n    printf(\" U\\\"a猫🍌\\\" is a char32_t[%zu] holding { \", sizeof s4 / sizeof *s4);\n    for(size_t n = 0; n < sizeof s4 / sizeof *s4; ++n)\n       printf(\"0x%08\" PRIXLEAST32\" \", s4[n]);\n    puts(\"}\");\n    printf(\" L\\\"%ls\\\" is a wchar_t[%zu] holding  { \", s5, sizeof s5 / sizeof *s5);\n    for(size_t n = 0; n < sizeof s5 / sizeof *s5; ++n)\n       printf(\"0x%08X \", (unsigned)s5[n]);\n    puts(\"}\");\n}\n```\n\nPossible output:\n\n```\n  \"a猫🍌\" is a char[9] holding     { 0x61 0xE7 0x8C 0xAB 0xF0 0x9F 0x8D 0x8C 0x00 }\nu8\"a猫🍌\" is a char[9] holding     { 0x61 0xE7 0x8C 0xAB 0xF0 0x9F 0x8D 0x8C 0x00 }\n u\"a猫🍌\" is a char16_t[5] holding { 0x0061 0x732B 0xD83C 0xDF4C 0x0000 }\n U\"a猫🍌\" is a char32_t[4] holding { 0x00000061 0x0000732B 0x0001F34C 0x00000000 }\n L\"a猫🍌\" is a wchar_t[4] holding  { 0x00000061 0x0000732B 0x0001F34C 0x00000000 }\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.4.5 String literals (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.4.5 String literals (p: 50-52)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.4.5 String literals (p: 70-72)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.4.5 String literals (p: 62-63)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.4 String literals\n\n### See also\n\n|                                                                                                                                 |     |\n|---------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/string_literal \"cpp/language/string literal\") for string literal |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/string_literal](https://en.cppreference.com/w/c/language/string_literal)"
- name: Strings library
  summary: ''
  description: "# Strings library\n\n### [Null-terminated byte string management](string/byte \"c/string/byte\")\n\n### [Null-terminated multibyte string management](string/multibyte \"c/string/multibyte\")\n\n### [Null-terminated wide string management](string/wide \"c/string/wide\")\n\n### See also\n\n|                                                                                                |     |\n|------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/string \"cpp/string\") for Strings library |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string](https://en.cppreference.com/w/c/string)"
- name: strlen
  summary: strnlen_s and wcsnlen_s are the only bounds-checked functions that do not invoke the runtime constraints handler
  description: "# strlen, strnlen_s\n\n[TABLE]\n\n1) Returns the length of the given null-terminated byte string, that is, the number of characters in a character array whose first element is pointed to by `str` up to and not including the first null character.\n\nThe behavior is undefined if `str` is not a pointer to a null-terminated byte string.\n\n2) Same as (1), except that the function returns zero if `str` is a null pointer and returns `strsz` if the null character was not found in the first `strsz` bytes of `str`.\n\nThe behavior is undefined if both `str` points to a character array which lacks the null character and the size of that character array \\< `strsz`; in other words, an erroneous value of `strsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `strnlen_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|       |     |                                                           |\n|-------|-----|-----------------------------------------------------------|\n| str   | \\-  | pointer to the null-terminated byte string to be examined |\n| strsz | \\-  | maximum number of characters to examine                   |\n\n### Return value\n\n1) The length of the null-terminated byte string `str`.\n\n2) The length of the null-terminated byte string `str` on success, zero if `str` is a null pointer, `strsz` if the null character was not found.\n\n### Notes\n\n`strnlen_s` and `wcsnlen_s` are the only [bounds-checked functions](../../error \"c/error\") that do not invoke the runtime constraints handler. They are pure utility functions used to provide limited support for non-null terminated strings.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n \nint main(void)\n{\n    const char str[] = \"How many characters does this string contain?\";\n \n    printf(\"without null character: %zu\\n\", strlen(str));\n    printf(\"with null character:    %zu\\n\", sizeof str);\n \n#ifdef __STDC_LIB_EXT1__\n    printf(\"without null character: %zu\\n\", strnlen_s(str, sizeof str));\n#endif\n}\n```\n\nPossible output:\n\n```\nwithout null character: 45\nwith null character:    46\nwithout null character: 45\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.6.3 The strlen function (p: 372)\n  - K.3.7.4.4 The strnlen_s function (p: 623)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.6.3 The strlen function (p: 334)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.6.3 The strlen function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strlen](https://en.cppreference.com/w/c/string/byte/strlen)"
- name: strncat
  summary: Because strncat needs to seek to the end of dest on each call, it is inefficient to concatenate many strings into one using strncat
  description: "# strncat, strncat_s\n\n[TABLE]\n\n1) Appends at most `count` characters from the character array pointed to by `src`, stopping if the null character is found, to the end of the null-terminated byte string pointed to by `dest`. The character `src[0]` replaces the null terminator at the end of `dest`. The terminating null character is always appended in the end (so the maximum number of bytes the function may write is `count+1`).\n\nThe behavior is undefined if the destination array does not have enough space for the contents of both `dest` and the first `count` characters of `src`, plus the terminating null character. The behavior is undefined if the source and destination objects overlap. The behavior is undefined if either `dest` is not a pointer to a null-terminated byte string or `src` is not a pointer to a character array,\n\n2) Same as (1), except that this function may clobber the remainder of the destination array (from the last byte written to `destsz`) and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` or `count` is zero or greater than `RSIZE_MAX`\n- there is no null character in the first `destsz` bytes of `dest`\n- truncation would occur: `count` or the length of `src`, whichever is less, exceeds the space available between the null terminator of `dest` and `destsz`.\n- overlap would occur between the source and the destination strings\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `strnlen(dest,destsz)+strnlen(src,count)+1` \\< `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by `src` \\< `strnlen(src,count)` \\< `destsz`; in other words, an erroneous value of `count` does not expose the impending buffer overflow. As with all bounds-checked functions, `strncat_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                         |\n|--------|-----|---------------------------------------------------------|\n| dest   | \\-  | pointer to the null-terminated byte string to append to |\n| src    | \\-  | pointer to the character array to copy from             |\n| count  | \\-  | maximum number of characters to copy                    |\n| destsz | \\-  | the size of the destination buffer                      |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes zero to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX`).\n\n### Notes\n\nBecause `strncat` needs to seek to the end of `dest` on each call, it is inefficient to concatenate many strings into one using `strncat`.\n\nAlthough truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for `strncat_s`, it is possible to get the truncating behavior by specifying `count` equal to the size of the destination array minus one: it will copy the first `count` bytes and append the null terminator as always: `strncat_s(dst, sizeof dst, src, (sizeof dst)-strnlen_s(dst, sizeof dst)-1);`\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    char str[50] = \"Hello \";\n    char str2[50] = \"World!\";\n    strcat(str, str2);\n    strncat(str, \" Goodbye World!\", 3);\n    puts(str);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    char s1[100] = \"good\";\n    char s5[1000] = \"bye\";\n    int r1 = strncat_s(s1, 100, s5, 1000); // r1 is 0, s1 holds \"goodbye\\0\"\n    printf(\"s1 = %s, r1 = %d\\n\", s1, r1);\n    char s2[6] = \"hello\";\n    int r2 = strncat_s(s2, 6, \"\", 1); // r2 is 0, s2 holds \"hello\\0\"\n    printf(\"s2 = %s, r2 = %d\\n\", s2, r2);\n    char s3[6] = \"hello\";\n    int r3 = strncat_s(s3, 6, \"X\", 2); // r3 is non-zero, s3 holds \"\\0\"\n    printf(\"s3 = %s, r3 = %d\\n\", s3, r3);\n    // the strncat_s truncation idiom:\n    char s4[7] = \"abc\";\n    int r4 = strncat_s(s4, 7, \"defghijklmn\", 3); // r4 is 0, s4 holds \"abcdef\\0\"\n    printf(\"s4 = %s, r4 = %d\\n\", s4, r4);\n#endif\n}\n```\n\nPossible output:\n\n```\nHello World! Go\ns1 = goodbye, r1 = 0\ns2 = hello, r2 = 0\ns3 = , r3 = 22\ns4 = abcdef, r4 = 0\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.26.3.2 The strncat function (p: 379)\n  - K.3.7.2.2 The strncat_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.3.2 The strncat function (p: 265-266)\n  - K.3.7.2.2 The strncat_s function (p: 449-450)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.3.2 The strncat function (p: 364-365)\n  - K.3.7.2.2 The strncat_s function (p: 618-620)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.3.2 The strncat function (p: 327-328)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.3.2 The strncat function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strncat](https://en.cppreference.com/w/c/string/byte/strncat)"
- name: strncat_s
  summary: Because strncat needs to seek to the end of dest on each call, it is inefficient to concatenate many strings into one using strncat
  description: "# strncat, strncat_s\n\n[TABLE]\n\n1) Appends at most `count` characters from the character array pointed to by `src`, stopping if the null character is found, to the end of the null-terminated byte string pointed to by `dest`. The character `src[0]` replaces the null terminator at the end of `dest`. The terminating null character is always appended in the end (so the maximum number of bytes the function may write is `count+1`).\n\nThe behavior is undefined if the destination array does not have enough space for the contents of both `dest` and the first `count` characters of `src`, plus the terminating null character. The behavior is undefined if the source and destination objects overlap. The behavior is undefined if either `dest` is not a pointer to a null-terminated byte string or `src` is not a pointer to a character array,\n\n2) Same as (1), except that this function may clobber the remainder of the destination array (from the last byte written to `destsz`) and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` or `count` is zero or greater than `RSIZE_MAX`\n- there is no null character in the first `destsz` bytes of `dest`\n- truncation would occur: `count` or the length of `src`, whichever is less, exceeds the space available between the null terminator of `dest` and `destsz`.\n- overlap would occur between the source and the destination strings\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `strnlen(dest,destsz)+strnlen(src,count)+1` \\< `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by `src` \\< `strnlen(src,count)` \\< `destsz`; in other words, an erroneous value of `count` does not expose the impending buffer overflow. As with all bounds-checked functions, `strncat_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                         |\n|--------|-----|---------------------------------------------------------|\n| dest   | \\-  | pointer to the null-terminated byte string to append to |\n| src    | \\-  | pointer to the character array to copy from             |\n| count  | \\-  | maximum number of characters to copy                    |\n| destsz | \\-  | the size of the destination buffer                      |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes zero to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX`).\n\n### Notes\n\nBecause `strncat` needs to seek to the end of `dest` on each call, it is inefficient to concatenate many strings into one using `strncat`.\n\nAlthough truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for `strncat_s`, it is possible to get the truncating behavior by specifying `count` equal to the size of the destination array minus one: it will copy the first `count` bytes and append the null terminator as always: `strncat_s(dst, sizeof dst, src, (sizeof dst)-strnlen_s(dst, sizeof dst)-1);`\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    char str[50] = \"Hello \";\n    char str2[50] = \"World!\";\n    strcat(str, str2);\n    strncat(str, \" Goodbye World!\", 3);\n    puts(str);\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    char s1[100] = \"good\";\n    char s5[1000] = \"bye\";\n    int r1 = strncat_s(s1, 100, s5, 1000); // r1 is 0, s1 holds \"goodbye\\0\"\n    printf(\"s1 = %s, r1 = %d\\n\", s1, r1);\n    char s2[6] = \"hello\";\n    int r2 = strncat_s(s2, 6, \"\", 1); // r2 is 0, s2 holds \"hello\\0\"\n    printf(\"s2 = %s, r2 = %d\\n\", s2, r2);\n    char s3[6] = \"hello\";\n    int r3 = strncat_s(s3, 6, \"X\", 2); // r3 is non-zero, s3 holds \"\\0\"\n    printf(\"s3 = %s, r3 = %d\\n\", s3, r3);\n    // the strncat_s truncation idiom:\n    char s4[7] = \"abc\";\n    int r4 = strncat_s(s4, 7, \"defghijklmn\", 3); // r4 is 0, s4 holds \"abcdef\\0\"\n    printf(\"s4 = %s, r4 = %d\\n\", s4, r4);\n#endif\n}\n```\n\nPossible output:\n\n```\nHello World! Go\ns1 = goodbye, r1 = 0\ns2 = hello, r2 = 0\ns3 = , r3 = 22\ns4 = abcdef, r4 = 0\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.26.3.2 The strncat function (p: 379)\n  - K.3.7.2.2 The strncat_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.3.2 The strncat function (p: 265-266)\n  - K.3.7.2.2 The strncat_s function (p: 449-450)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.3.2 The strncat function (p: 364-365)\n  - K.3.7.2.2 The strncat_s function (p: 618-620)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.3.2 The strncat function (p: 327-328)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.3.2 The strncat function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strncat](https://en.cppreference.com/w/c/string/byte/strncat)"
- name: strncmp
  summary: Compares at most count characters of two possibly null-terminated arrays
  description: "# strncmp\n\n[TABLE]\n\nCompares at most `count` characters of two possibly null-terminated arrays. The comparison is done lexicographically. Characters following the null character are not compared.\n\nThe sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as `unsigned char`) that differ in the arrays being compared.\n\nThe behavior is undefined when access occurs past the end of either array `lhs` or `rhs`. The behavior is undefined when either `lhs` or `rhs` is the null pointer.\n\n### Parameters\n\n|          |     |                                                            |\n|----------|-----|------------------------------------------------------------|\n| lhs, rhs | \\-  | pointers to the possibly null-terminated arrays to compare |\n| count    | \\-  | maximum number of characters to compare                    |\n\n### Return value\n\nNegative value if `lhs` appears before `rhs` in lexicographical order.\n\nZero if `lhs` and `rhs` compare equal, or if count is zero.\n\nPositive value if `lhs` appears after `rhs` in lexicographical order.\n\n### Notes\n\nThis function is not locale-sensitive, unlike [`strcoll`](strcoll \"c/string/byte/strcoll\") and [`strxfrm`](strxfrm \"c/string/byte/strxfrm\").\n\n### Example\n\n```\n#include <stdio.h>\n#include <string.h>\n \nvoid demo(const char* lhs, const char* rhs, int sz)\n{\n    const int rc = strncmp(lhs, rhs, sz);\n    if (rc < 0)\n        printf(\"First %d chars of [%s] precede [%s]\\n\", sz, lhs, rhs);\n    else if (rc > 0)\n        printf(\"First %d chars of [%s] follow [%s]\\n\", sz, lhs, rhs);\n    else\n        printf(\"First %d chars of [%s] equal [%s]\\n\", sz, lhs, rhs);\n}\nint main(void)\n{\n    const char* string = \"Hello World!\";\n    demo(string, \"Hello!\", 5);\n    demo(string, \"Hello\", 10);\n    demo(string, \"Hello there\", 10);\n    demo(\"Hello, everybody!\" + 12, \"Hello, somebody!\" + 11, 5);\n}\n```\n\nOutput:\n\n```\nFirst 5 chars of [Hello World!] equal [Hello!]\nFirst 10 chars of [Hello World!] follow [Hello]\nFirst 10 chars of [Hello World!] precede [Hello there]\nFirst 5 chars of [body!] equal [body!]\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.24.4.4 The strncmp function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.4.4 The strncmp function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.4.4 The strncmp function (p: 366)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.4.4 The strncmp function (p: 329)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.4.4 The strncmp function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strncmp](https://en.cppreference.com/w/c/string/byte/strncmp)"
- name: strncpy
  summary: As corrected by the post-C11 DR 468, strncpy_s, unlike strcpy_s, is only allowed to clobber the remainder of the destination array if an error occurs
  description: "# strncpy, strncpy_s\n\n[TABLE]\n\n1) Copies at most `count` characters of the character array pointed to by `src` (including the terminating null character, but not any of the characters that follow the null character) to character array pointed to by `dest`.\n\nIf `count` is reached before the entire array `src` was copied, the resulting character array is not null-terminated.\n\nIf, after copying the terminating null character from `src`, `count` is not reached, additional null characters are written to `dest` until the total of `count` characters have been written.\n\nThe behavior is undefined if the character arrays overlap, if either `dest` or `src` is not a pointer to a character array (including if `dest` or `src` is a null pointer), if the size of the array pointed to by `dest` is less than `count`, or if the size of the array pointed to by `src` is less than `count` and it does not contain a null character.\n\n2) Same as (1), except that the function does not continue writing zeroes into the destination array to pad up to `count`, it stops after writing the terminating null character (if there was no null in the source, it writes one at `dest[count]` and then stops). Also, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` is zero or greater than `RSIZE_MAX`\n- `count` is greater than `RSIZE_MAX`\n- `count` is greater or equal `destsz`, but `destsz` is less or equal `strnlen_s(src, count)`, in other words, truncation would occur\n- overlap would occur between the source and the destination strings\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `strnlen_s(src, destsz)` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by `src` \\< `strnlen_s(src, count)` \\< `destsz`; in other words, an erroneous value of `count` does not expose the impending buffer overflow. As with all bounds-checked functions, `strncpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                             |\n|--------|-----|---------------------------------------------|\n| dest   | \\-  | pointer to the character array to copy to   |\n| src    | \\-  | pointer to the character array to copy from |\n| count  | \\-  | maximum number of characters to copy        |\n| destsz | \\-  | the size of the destination buffer          |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes zero to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX`) and may clobber the rest of the destination array with unspecified values.\n\n### Notes\n\nAs corrected by the post-C11 DR 468, `strncpy_s`, unlike [`strcpy_s`](strcpy \"c/string/byte/strcpy\"), is only allowed to clobber the remainder of the destination array if an error occurs.\n\nUnlike `strncpy`, `strncpy_s` does not pad the destination array with zeroes, This is a common source of errors when converting existing code to the bounds-checked version.\n\nAlthough truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for `strncpy_s`, it is possible to get the truncating behavior by specifying `count` equal to the size of the destination array minus one: it will copy the first `count` bytes and append the null terminator as always: `strncpy_s(dst, sizeof dst, src, (sizeof dst)-1);`\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n \nint main(void)\n{\n    char src[] = \"hi\";\n    char dest[6] = \"abcdef\"; // no null terminator\n    strncpy(dest, src, 5); // writes five characters 'h', 'i', '\\0', '\\0', '\\0' to dest\n    printf(\"strncpy(dest, src, 5) to a 6-byte dest gives : \");\n    for (size_t n = 0; n < sizeof dest; ++n) {\n        char c = dest[n];\n        c ? printf(\"'%c' \", c) : printf(\"'\\\\0' \");\n    }\n \n    printf(\"\\nstrncpy(dest2, src, 2) to a 2-byte dst gives : \");\n    char dest2[2];\n    strncpy(dest2, src, 2); // truncation: writes two characters 'h', 'i', to dest2\n    for (size_t n = 0; n < sizeof dest2; ++n) {\n        char c = dest2[n];\n        c ? printf(\"'%c' \", c) : printf(\"'\\\\0' \");\n    }\n    printf(\"\\n\");\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    char dst1[6], src1[100] = \"hello\";\n    errno_t r1 = strncpy_s(dst1, 6, src1, 100);  // writes 0 to r1, 6 characters to dst1\n    printf(\"dst1 = \\\"%s\\\", r1 = %d\\n\", dst1,r1); // 'h','e','l','l','o','\\0' to dst1\n \n    char dst2[5], src2[7] = {'g','o','o','d','b','y','e'};\n    errno_t r2 = strncpy_s(dst2, 5, src2, 7);    // copy overflows the destination array\n    printf(\"dst2 = \\\"%s\\\", r2 = %d\\n\", dst2,r2); // writes nonzero to r2,'\\0' to dst2[0]\n \n    char dst3[5];\n    errno_t r3 = strncpy_s(dst3, 5, src2, 4);    // writes 0 to r3, 5 characters to dst3\n    printf(\"dst3 = \\\"%s\\\", r3 = %d\\n\", dst3,r3); // 'g', 'o', 'o', 'd', '\\0' to dst3\n#endif\n}\n```\n\nPossible output:\n\n```\nstrncpy(dest, src, 5) to a 6-byte dst gives : 'h' 'i' '\\0' '\\0' '\\0' 'f'\nstrncpy(dest2, src, 2) to a 2-byte dst gives : 'h' 'i'\ndst1 = \"hello\", r1 = 0\ndst2 = \"\", r2 = 22\ndst3 = \"good\", r3 = 0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.2.4 The strncpy function (p: 265)\n  - K.3.7.1.4 The strncpy_s function (p: 447-448)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.2.4 The strncpy function (p: 363-364)\n  - K.3.7.1.4 The strncpy_s function (p: 616-617)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.2.4 The strncpy function (p: 326-327)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.2.4 The strncpy function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strncpy](https://en.cppreference.com/w/c/string/byte/strncpy)"
- name: strncpy_s
  summary: As corrected by the post-C11 DR 468, strncpy_s, unlike strcpy_s, is only allowed to clobber the remainder of the destination array if an error occurs
  description: "# strncpy, strncpy_s\n\n[TABLE]\n\n1) Copies at most `count` characters of the character array pointed to by `src` (including the terminating null character, but not any of the characters that follow the null character) to character array pointed to by `dest`.\n\nIf `count` is reached before the entire array `src` was copied, the resulting character array is not null-terminated.\n\nIf, after copying the terminating null character from `src`, `count` is not reached, additional null characters are written to `dest` until the total of `count` characters have been written.\n\nThe behavior is undefined if the character arrays overlap, if either `dest` or `src` is not a pointer to a character array (including if `dest` or `src` is a null pointer), if the size of the array pointed to by `dest` is less than `count`, or if the size of the array pointed to by `src` is less than `count` and it does not contain a null character.\n\n2) Same as (1), except that the function does not continue writing zeroes into the destination array to pad up to `count`, it stops after writing the terminating null character (if there was no null in the source, it writes one at `dest[count]` and then stops). Also, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` is zero or greater than `RSIZE_MAX`\n- `count` is greater than `RSIZE_MAX`\n- `count` is greater or equal `destsz`, but `destsz` is less or equal `strnlen_s(src, count)`, in other words, truncation would occur\n- overlap would occur between the source and the destination strings\n\nThe behavior is undefined if the size of the character array pointed to by `dest` \\< `strnlen_s(src, destsz)` \\<= `destsz`; in other words, an erroneous value of `destsz` does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by `src` \\< `strnlen_s(src, count)` \\< `destsz`; in other words, an erroneous value of `count` does not expose the impending buffer overflow. As with all bounds-checked functions, `strncpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                             |\n|--------|-----|---------------------------------------------|\n| dest   | \\-  | pointer to the character array to copy to   |\n| src    | \\-  | pointer to the character array to copy from |\n| count  | \\-  | maximum number of characters to copy        |\n| destsz | \\-  | the size of the destination buffer          |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes zero to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX`) and may clobber the rest of the destination array with unspecified values.\n\n### Notes\n\nAs corrected by the post-C11 DR 468, `strncpy_s`, unlike [`strcpy_s`](strcpy \"c/string/byte/strcpy\"), is only allowed to clobber the remainder of the destination array if an error occurs.\n\nUnlike `strncpy`, `strncpy_s` does not pad the destination array with zeroes, This is a common source of errors when converting existing code to the bounds-checked version.\n\nAlthough truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for `strncpy_s`, it is possible to get the truncating behavior by specifying `count` equal to the size of the destination array minus one: it will copy the first `count` bytes and append the null terminator as always: `strncpy_s(dst, sizeof dst, src, (sizeof dst)-1);`\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n \nint main(void)\n{\n    char src[] = \"hi\";\n    char dest[6] = \"abcdef\"; // no null terminator\n    strncpy(dest, src, 5); // writes five characters 'h', 'i', '\\0', '\\0', '\\0' to dest\n    printf(\"strncpy(dest, src, 5) to a 6-byte dest gives : \");\n    for (size_t n = 0; n < sizeof dest; ++n) {\n        char c = dest[n];\n        c ? printf(\"'%c' \", c) : printf(\"'\\\\0' \");\n    }\n \n    printf(\"\\nstrncpy(dest2, src, 2) to a 2-byte dst gives : \");\n    char dest2[2];\n    strncpy(dest2, src, 2); // truncation: writes two characters 'h', 'i', to dest2\n    for (size_t n = 0; n < sizeof dest2; ++n) {\n        char c = dest2[n];\n        c ? printf(\"'%c' \", c) : printf(\"'\\\\0' \");\n    }\n    printf(\"\\n\");\n \n#ifdef __STDC_LIB_EXT1__\n    set_constraint_handler_s(ignore_handler_s);\n    char dst1[6], src1[100] = \"hello\";\n    errno_t r1 = strncpy_s(dst1, 6, src1, 100);  // writes 0 to r1, 6 characters to dst1\n    printf(\"dst1 = \\\"%s\\\", r1 = %d\\n\", dst1,r1); // 'h','e','l','l','o','\\0' to dst1\n \n    char dst2[5], src2[7] = {'g','o','o','d','b','y','e'};\n    errno_t r2 = strncpy_s(dst2, 5, src2, 7);    // copy overflows the destination array\n    printf(\"dst2 = \\\"%s\\\", r2 = %d\\n\", dst2,r2); // writes nonzero to r2,'\\0' to dst2[0]\n \n    char dst3[5];\n    errno_t r3 = strncpy_s(dst3, 5, src2, 4);    // writes 0 to r3, 5 characters to dst3\n    printf(\"dst3 = \\\"%s\\\", r3 = %d\\n\", dst3,r3); // 'g', 'o', 'o', 'd', '\\0' to dst3\n#endif\n}\n```\n\nPossible output:\n\n```\nstrncpy(dest, src, 5) to a 6-byte dst gives : 'h' 'i' '\\0' '\\0' '\\0' 'f'\nstrncpy(dest2, src, 2) to a 2-byte dst gives : 'h' 'i'\ndst1 = \"hello\", r1 = 0\ndst2 = \"\", r2 = 22\ndst3 = \"good\", r3 = 0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.2.4 The strncpy function (p: 265)\n  - K.3.7.1.4 The strncpy_s function (p: 447-448)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.2.4 The strncpy function (p: 363-364)\n  - K.3.7.1.4 The strncpy_s function (p: 616-617)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.2.4 The strncpy function (p: 326-327)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.2.4 The strncpy function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strncpy](https://en.cppreference.com/w/c/string/byte/strncpy)"
- name: strndup
  summary: Returns a pointer to a null-terminated byte string, which contains copies of at most size bytes from the string pointed to by src
  description: "# strndup\n\n[TABLE]\n\nReturns a pointer to a null-terminated byte string, which contains copies of at most `size` bytes from the string pointed to by `src`. The space for the new string is obtained as if [`malloc`](../../memory/malloc \"c/memory/malloc\") was called. If the null terminator is not encountered in the first `size` bytes, it is appended to the duplicated string.\n\nThe returned pointer must be passed to [`free`](../../memory/free \"c/memory/free\") to avoid a memory leak.\n\nIf an error occurs, a null pointer is returned and [`errno`](../../error/errno \"c/error/errno\") might be set.\n\n### Parameters\n\n|      |     |                                                         |\n|------|-----|---------------------------------------------------------|\n| src  | \\-  | pointer to the null-terminated byte string to duplicate |\n| size | \\-  | max number of bytes to copy from `src`                  |\n\n### Return value\n\nA pointer to the newly allocated string, or a null pointer if an error occurred.\n\n### Notes\n\nThe function is identical to the [POSIX strndup](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strdup.html) except that it is allowed, but not required to set [`errno`](../../error/errno \"c/error/errno\") on error.\n\n### Example\n\n```\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const size_t n = 3;\n \n    const char *src = \"Replica\";\n    char *dup = strndup(src, n);\n    printf(\"strndup(\\\"%s\\\", %lu) == \\\"%s\\\"\\n\", src, n, dup);\n    free(dup);\n \n    src = \"Hi\";\n    dup = strndup(src, n);\n    printf(\"strndup(\\\"%s\\\", %lu) == \\\"%s\\\"\\n\", src, n, dup);\n    free(dup);\n \n    const char arr[] = {'A','B','C','D'}; // NB: no trailing '\\0'\n    dup = strndup(arr, n);\n    printf(\"strndup({'A','B','C','D'}, %lu) == \\\"%s\\\"\\n\", n, dup);\n    free(dup);\n}\n```\n\nOutput:\n\n```\nstrndup(\"Replica\", 3) == \"Rep\"\nstrndup(\"Hi\", 3) == \"Hi\"\nstrndup({'A','B','C','D'}, 3) == \"ABC\"\n```\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strndup](https://en.cppreference.com/w/c/string/byte/strndup)"
- name: strnlen_s
  summary: strnlen_s and wcsnlen_s are the only bounds-checked functions that do not invoke the runtime constraints handler
  description: "# strlen, strnlen_s\n\n[TABLE]\n\n1) Returns the length of the given null-terminated byte string, that is, the number of characters in a character array whose first element is pointed to by `str` up to and not including the first null character.\n\nThe behavior is undefined if `str` is not a pointer to a null-terminated byte string.\n\n2) Same as (1), except that the function returns zero if `str` is a null pointer and returns `strsz` if the null character was not found in the first `strsz` bytes of `str`.\n\nThe behavior is undefined if both `str` points to a character array which lacks the null character and the size of that character array \\< `strsz`; in other words, an erroneous value of `strsz` does not expose the impending buffer overflow. As with all bounds-checked functions, `strnlen_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|       |     |                                                           |\n|-------|-----|-----------------------------------------------------------|\n| str   | \\-  | pointer to the null-terminated byte string to be examined |\n| strsz | \\-  | maximum number of characters to examine                   |\n\n### Return value\n\n1) The length of the null-terminated byte string `str`.\n\n2) The length of the null-terminated byte string `str` on success, zero if `str` is a null pointer, `strsz` if the null character was not found.\n\n### Notes\n\n`strnlen_s` and `wcsnlen_s` are the only [bounds-checked functions](../../error \"c/error\") that do not invoke the runtime constraints handler. They are pure utility functions used to provide limited support for non-null terminated strings.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n \nint main(void)\n{\n    const char str[] = \"How many characters does this string contain?\";\n \n    printf(\"without null character: %zu\\n\", strlen(str));\n    printf(\"with null character:    %zu\\n\", sizeof str);\n \n#ifdef __STDC_LIB_EXT1__\n    printf(\"without null character: %zu\\n\", strnlen_s(str, sizeof str));\n#endif\n}\n```\n\nPossible output:\n\n```\nwithout null character: 45\nwith null character:    46\nwithout null character: 45\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.6.3 The strlen function (p: 372)\n  - K.3.7.4.4 The strnlen_s function (p: 623)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.6.3 The strlen function (p: 334)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.6.3 The strlen function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strlen](https://en.cppreference.com/w/c/string/byte/strlen)"
- name: strpbrk
  summary: The behavior is undefined if either dest or breakset is not a pointer to a null-terminated byte string
  description: "# strpbrk\n\n[TABLE]\n\n1 ) Scans the null-terminated byte string pointed to by `dest` for any character from the null-terminated byte string pointed to by `breakset`, and returns a pointer to that character.\n\n2) Type-generic function equivalent to (1). Let `T` be an unqualified character object type.\n\n- If `dest` is of type `const T*`, the return type is `const char*`.\n- Otherwise, if `dest` is of type `T*`, the return type is `char*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(strpbrk)` or a function pointer is used), the actual function declaration (1) becomes visible.\n\nThe behavior is undefined if either `dest` or `breakset` is not a pointer to a null-terminated byte string.\n\n### Parameters\n\n|          |     |                                                                                       |\n|----------|-----|---------------------------------------------------------------------------------------|\n| dest     | \\-  | pointer to the null-terminated byte string to be analyzed                             |\n| breakset | \\-  | pointer to the null-terminated byte string that contains the characters to search for |\n\n### Return value\n\nPointer to the first character in `dest`, that is also in `breakset`, or null pointer if no such character exists.\n\n### Notes\n\nThe name stands for \"string pointer break\", because it returns a pointer to the first of the separator (\"break\") characters.\n\n### Example\n\n```\n#include <stdio.h>\n#include <string.h>\n \nint main(void)\n{\n    const char* str = \"hello world, friend of mine!\";\n    const char* sep = \" ,!\";\n \n    unsigned int cnt = 0;\n    do {\n       str = strpbrk(str, sep); // find separator\n       if(str) str += strspn(str, sep); // skip separator\n       ++cnt; // increment word count\n    } while(str && *str);\n \n    printf(\"There are %u words\\n\", cnt);\n}\n```\n\nOutput:\n\n```\nThere are 5 words\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.5.4 The strpbrk function (p: 368)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.5.4 The strpbrk function (p: 331)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.5.4 The strpbrk function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strpbrk](https://en.cppreference.com/w/c/string/byte/strpbrk)"
- name: strrchr
  summary: The behavior is undefined if str is not a pointer to a null-terminated byte string
  description: "# strrchr\n\n[TABLE]\n\n1) Finds the last occurrence of `ch` (after conversion to `char` as if by `(char)ch`) in the null-terminated byte string pointed to by `str` (each character interpreted as `unsigned char`). The terminating null character is considered to be a part of the string and can be found if searching for `'\\0'`.\n\n2) Type-generic function equivalent to (1). Let `T` be an unqualified character object type.\n\n- If `str` is of type `const T*`, the return type is `const char*`.\n- Otherwise, if `str` is of type `T*`, the return type is `char*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(strrchr)` or a function pointer is used), the actual function declaration (1) becomes visible.\n\nThe behavior is undefined if `str` is not a pointer to a null-terminated byte string.\n\n### Parameters\n\n|     |     |                                                           |\n|-----|-----|-----------------------------------------------------------|\n| str | \\-  | pointer to the null-terminated byte string to be analyzed |\n| ch  | \\-  | character to search for                                   |\n\n### Return value\n\nPointer to the found character in `str`, or null pointer if no such character is found.\n\n### Example\n\n```\n#include <string.h>\n#include <stdio.h>\n \nint main(void)\n{\n    char szSomeFileName[] = \"foo/bar/foobar.txt\";\n    char *pLastSlash = strrchr(szSomeFileName, '/');\n    char *pszBaseName = pLastSlash ? pLastSlash + 1 : szSomeFileName;\n    printf(\"Base Name: %s\", pszBaseName);\n}\n```\n\nOutput:\n\n```\nBase Name: foobar.txt\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.5.5 The strrchr function (p: 368-369)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.5.5 The strrchr function (p: 331)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.5.5 The strrchr function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strrchr](https://en.cppreference.com/w/c/string/byte/strrchr)"
- name: strspn
  summary: Returns the length of the maximum initial segment (span) of the null-terminated byte string pointed to by dest, that consists of only the characters found in the null-terminated byte string pointed to by src
  description: "# strspn\n\n[TABLE]\n\nReturns the length of the maximum initial segment (span) of the null-terminated byte string pointed to by `dest`, that consists of only the characters found in the null-terminated byte string pointed to by `src`.\n\nThe behavior is undefined if either `dest` or `src` is not a pointer to a null-terminated byte string.\n\n### Parameters\n\n|      |     |                                                                                       |\n|------|-----|---------------------------------------------------------------------------------------|\n| dest | \\-  | pointer to the null-terminated byte string to be analyzed                             |\n| src  | \\-  | pointer to the null-terminated byte string that contains the characters to search for |\n\n### Return value\n\nThe length of the maximum initial segment that contains only characters from the null-terminated byte string pointed to by `src`\n\n### Example\n\n```\n#include <string.h>\n#include <stdio.h>\n \nint main(void)\n{\n    const char *string = \"abcde312$#@\";\n    const char *low_alpha = \"qwertyuiopasdfghjklzxcvbnm\";\n \n    size_t spnsz = strspn(string, low_alpha);\n    printf(\"After skipping initial lowercase letters from '%s'\\n\"\n           \"The remainder is '%s'\\n\", string, string+spnsz);\n}\n```\n\nOutput:\n\n```\nAfter skipping initial lowercase letters from 'abcde312$#@'\nThe remainder is '312$#@'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.5.6 The strspn function (p: 369)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.5.6 The strspn function (p: 332)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.5.6 The strspn function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strspn](https://en.cppreference.com/w/c/string/byte/strspn)"
- name: strstr
  summary: The behavior is undefined if either str or substr is not a pointer to a null-terminated byte string
  description: "# strstr\n\n[TABLE]\n\n1) Finds the first occurrence of the null-terminated byte string pointed to by `substr` in the null-terminated byte string pointed to by `str`. The terminating null characters are not compared.\n\n2) Type-generic function equivalent to (1). Let `T` be an unqualified character object type.\n\n- If `str` is of type `const T*`, the return type is `const char*`.\n- Otherwise, if `str` is of type `T*`, the return type is `char*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(strstr)` or a function pointer is used), the actual function declaration (1) becomes visible.\n\nThe behavior is undefined if either `str` or `substr` is not a pointer to a null-terminated byte string.\n\n### Parameters\n\n|        |     |                                                          |\n|--------|-----|----------------------------------------------------------|\n| str    | \\-  | pointer to the null-terminated byte string to examine    |\n| substr | \\-  | pointer to the null-terminated byte string to search for |\n\n### Return value\n\nPointer to the first character of the found substring in `str`, or a null pointer if such substring is not found. If `substr` points to an empty string, `str` is returned.\n\n### Example\n\n```\n#include <string.h>\n#include <stdio.h>\n \nvoid find_str(char const *str, char const *substr)\n{\n    char *pos = strstr(str, substr);\n    pos ? printf(\"found the string '%s' in '%s' at position %td\\n\",\n                 substr, str, pos - str)\n        : printf(\"the string '%s' was not found in '%s'\\n\",\n                 substr, str);\n}\n \nint main(void)\n{\n    char *str = \"one two three\";\n    find_str(str, \"two\");\n    find_str(str, \"\");\n    find_str(str, \"nine\");\n    find_str(str, \"n\");\n \n    return 0;\n}\n```\n\nOutput:\n\n```\nfound the string 'two' in 'one two three' at position 4\nfound the string '' in 'one two three' at position 0\nthe string 'nine' was not found in 'one two three'\nfound the string 'n' in 'one two three' at position 1\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.5.7 The strstr function (p: 269)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.5.7 The strstr function (p: 369)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.5.7 The strstr function (p: 332)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.5.7 The strstr function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strstr](https://en.cppreference.com/w/c/string/byte/strstr)"
- name: strtod
  summary: Interprets a floating-point value in a byte string pointed to by str
  description: "# strtof, strtod, strtold\n\n[TABLE]\n\nInterprets a floating-point value in a byte string pointed to by `str`.\n\nFunction discards any whitespace characters (as determined by [`isspace`](isspace \"c/string/byte/isspace\")) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:\n\n- decimal floating-point expression. It consists of the following parts:\n  - (optional) plus or minus sign\n  - nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C [locale](../../locale/setlocale \"c/locale/setlocale\")) (defines significand)\n  - (optional) `e` or `E` followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent to base 10)\n\n[TABLE]\n\n- any other expression that may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\")\n\nThe functions sets the pointer pointed to by `str_end` to point to the character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated byte string to be interpreted |\n| str_end | \\-  | pointer to a pointer to character.                           |\n\n### Return value\n\nFloating-point value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs ([`errno`](../../error/errno \"c/error/errno\") is set to [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")) and [`HUGE_VAL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\"), [`HUGE_VALF`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") or [`HUGE_VALL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    // parsing with error handling\n    const char *p = \"111.11 -2.22 Nan nan(2) inF 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\";\n    printf(\"Parsing '%s':\\n\", p);\n    char *end;\n    for (double f = strtod(p, &end); p != end; f = strtod(p, &end))\n    {\n        printf(\"'%.*s' -> \", (int)(end-p), p);\n        p = end;\n        if (errno == ERANGE){\n            printf(\"range error, got \");\n            errno = 0;\n        }\n        printf(\"%f\\n\", f);\n    }\n \n    // parsing without error handling\n    printf(\"\\\"  -0.0000000123junk\\\"  -->  %g\\n\", strtod(\"  -0.0000000123junk\", NULL));\n    printf(\"\\\"junk\\\"                 -->  %g\\n\", strtod(\"junk\", NULL));\n}\n```\n\nPossible output:\n\n```\nParsing '111.11 -2.22 Nan nan(2) inF 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz':\n'111.11' -> 111.110000\n' -2.22' -> -2.220000\n' Nan' -> nan\n' nan(2)' -> nan\n' inF' -> inf\n' 0X1.BC70A3D70A3D7P+6' -> 111.110000\n'  1.18973e+4932' -> range error, got inf\n\"  -0.0000000123junk\"  -->  -1.23e-08\n\"junk\"                 -->  0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.1.3 The strtod, strtof, and strtold functions (p: 249-251)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.3 The strtod, strtof, and strtold functions (p: 342-344)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.3 The strtod, strtof, and strtold functions (p: 308-310)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.4 The strtod function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtof](https://en.cppreference.com/w/c/string/byte/strtof)"
- name: strtof
  summary: Interprets a floating-point value in a byte string pointed to by str
  description: "# strtof, strtod, strtold\n\n[TABLE]\n\nInterprets a floating-point value in a byte string pointed to by `str`.\n\nFunction discards any whitespace characters (as determined by [`isspace`](isspace \"c/string/byte/isspace\")) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:\n\n- decimal floating-point expression. It consists of the following parts:\n  - (optional) plus or minus sign\n  - nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C [locale](../../locale/setlocale \"c/locale/setlocale\")) (defines significand)\n  - (optional) `e` or `E` followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent to base 10)\n\n[TABLE]\n\n- any other expression that may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\")\n\nThe functions sets the pointer pointed to by `str_end` to point to the character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated byte string to be interpreted |\n| str_end | \\-  | pointer to a pointer to character.                           |\n\n### Return value\n\nFloating-point value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs ([`errno`](../../error/errno \"c/error/errno\") is set to [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")) and [`HUGE_VAL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\"), [`HUGE_VALF`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") or [`HUGE_VALL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    // parsing with error handling\n    const char *p = \"111.11 -2.22 Nan nan(2) inF 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\";\n    printf(\"Parsing '%s':\\n\", p);\n    char *end;\n    for (double f = strtod(p, &end); p != end; f = strtod(p, &end))\n    {\n        printf(\"'%.*s' -> \", (int)(end-p), p);\n        p = end;\n        if (errno == ERANGE){\n            printf(\"range error, got \");\n            errno = 0;\n        }\n        printf(\"%f\\n\", f);\n    }\n \n    // parsing without error handling\n    printf(\"\\\"  -0.0000000123junk\\\"  -->  %g\\n\", strtod(\"  -0.0000000123junk\", NULL));\n    printf(\"\\\"junk\\\"                 -->  %g\\n\", strtod(\"junk\", NULL));\n}\n```\n\nPossible output:\n\n```\nParsing '111.11 -2.22 Nan nan(2) inF 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz':\n'111.11' -> 111.110000\n' -2.22' -> -2.220000\n' Nan' -> nan\n' nan(2)' -> nan\n' inF' -> inf\n' 0X1.BC70A3D70A3D7P+6' -> 111.110000\n'  1.18973e+4932' -> range error, got inf\n\"  -0.0000000123junk\"  -->  -1.23e-08\n\"junk\"                 -->  0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.1.3 The strtod, strtof, and strtold functions (p: 249-251)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.3 The strtod, strtof, and strtold functions (p: 342-344)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.3 The strtod, strtof, and strtold functions (p: 308-310)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.4 The strtod function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtof](https://en.cppreference.com/w/c/string/byte/strtof)"
- name: strtoimax
  summary: Interprets an integer value in a byte string pointed to by nptr
  description: "# strtoimax, strtoumax\n\n[TABLE]\n\nInterprets an integer value in a byte string pointed to by `nptr`.\n\nDiscards any whitespace characters (as identified by calling [`isspace`](isspace \"c/string/byte/isspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type.\n\nThe functions sets the pointer pointed to by `endptr` to point to the character past the last character interpreted. If `endptr` is a null pointer, it is ignored.\n\nIf the `nptr` is empty or does not have the expected form, no conversion is performed, and (if `endptr` is not a null pointer) the value of `nptr` is stored in the object pointed to by `endptr`.\n\n### Parameters\n\n|        |     |                                                              |\n|--------|-----|--------------------------------------------------------------|\n| nptr   | \\-  | pointer to the null-terminated byte string to be interpreted |\n| endptr | \\-  | pointer to a pointer to character.                           |\n| base   | \\-  | *base* of the interpreted integer value                      |\n\n### Return value\n\n- If successful, an integer value corresponding to the contents of `str` is returned.\n- If the converted value falls out of range of corresponding return type, a range error occurs (setting [`errno`](../../error/errno \"c/error/errno\") to [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")) and [`INTMAX_MAX`](../../types/integer \"c/types/integer\"), [`INTMAX_MIN`](../../types/integer \"c/types/integer\"), [`UINTMAX_MAX`](../../types/integer \"c/types/integer\") or `​0​` is returned, as appropriate.\n- If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <string.h>\n \nint main(void)\n{\n    char* endptr;\n \n    printf(\"%ld\\n\", strtoimax(\" -123junk\",&endptr,10)); /* base 10                    */\n    printf(\"%ld\\n\", strtoimax(\"11111111\",&endptr,2));   /* base 2                     */\n    printf(\"%ld\\n\", strtoimax(\"XyZ\",&endptr,36));       /* base 36                    */\n    printf(\"%ld\\n\", strtoimax(\"010\",&endptr,0));        /* octal auto-detection       */\n    printf(\"%ld\\n\", strtoimax(\"10\",&endptr,0));         /* decimal auto-detection     */\n    printf(\"%ld\\n\", strtoimax(\"0x10\",&endptr,0));       /* hexadecimal auto-detection */\n \n    /* range error             */\n    /* LONG_MAX+1 --> LONG_MAX */\n    errno = 0;\n    printf(\"%ld\\n\", strtoimax(\"9223372036854775808\",&endptr,10));\n    printf(\"%s\\n\", strerror(errno));\n \n    return 0;\n}\n```\n\nOutput:\n\n```\n-123\n255\n44027\n8\n10\n16\n9223372036854775807\nNumerical result out of range\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.8.2.3 The strtoimax and strtoumax functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.2.3 The strtoimax and strtoumax functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.3 The strtoimax and strtoumax functions (p: 219)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.3 The strtoimax and strtoumax functions (p: 200)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtoimax](https://en.cppreference.com/w/c/string/byte/strtoimax)"
- name: strtok
  summary: Returns pointer to the beginning of the next token or a null pointer if there are no more tokens
  description: "# strtok, strtok_s\n\n[TABLE]\n\n1) Finds the next token in a null-terminated byte string pointed to by `str`. The separator characters are identified by null-terminated byte string pointed to by `delim`.\n\nThis function is designed to be called multiple times to obtain successive tokens from the same string.\n\n- If `str` is not a null pointer, the call is treated as the first call to `strtok` for this particular string. The function searches for the first character which is *not* contained in `delim`.\n- If no such character was found, there are no tokens in `str` at all, and the function returns a null pointer.\n- If such character was found, it is the *beginning of the token*. The function then searches from that point on for the first character that *is* contained in `delim`.\n  - If no such character was found, `str` has only one token, and future calls to `strtok` will return a null pointer\n  - If such character was found, it is *replaced* by the null character `'\\0'` and the pointer to the following character is stored in a static location for subsequent invocations.\n- The function then returns the pointer to the beginning of the token\n- If `str` is a null pointer, the call is treated as a subsequent call to `strtok`: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as `str`.\n\nThe behavior is undefined if either `str` or `delim` is not a pointer to a null-terminated byte string.\n\n2) Same as (1), except that on every step, writes the number of characters left to see in `str` into `*strmax` and writes the tokenizer's internal state to `*ptr`. Repeat calls (with null `str`) must pass `strmax` and `ptr` with the values stored by the previous call. Also, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function, without storing anything in the object pointed to by `ptr`\n\n- `strmax`, `delim`, or `ptr` is a null pointer\n- on a non-initial call (with null `str`), `*ptr` is a null pointer\n- on the first call, `*strmax` is zero or greater than `RSIZE_MAX`\n- search for the end of a token reaches the end of the source string (as measured by the initial value of `*strmax`) without encountering the null terminator\n\nThe behavior is undefined if both `str` points to a character array which lacks the null character and `strmax` points to a value which is greater than the size of that character array. As with all bounds-checked functions, `strtok_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                                                                                                   |\n|--------|-----|-----------------------------------------------------------------------------------------------------------------------------------|\n| str    | \\-  | pointer to the null-terminated byte string to tokenize                                                                            |\n| delim  | \\-  | pointer to the null-terminated byte string identifying delimiters                                                                 |\n| strmax | \\-  | pointer to an object which initially holds the size of `str`: strtok_s stores the number of characters that remain to be examined |\n| ptr    | \\-  | pointer to an object of type `char*`, which is used by strtok_s to store its internal state                                       |\n\n### Return value\n\nReturns pointer to the beginning of the next token or a null pointer if there are no more tokens.\n\n### Note\n\nThis function is destructive: it writes the `'\\0'` characters in the elements of the string `str`. In particular, a string literal cannot be used as the first argument of `strtok`.\n\nEach call to `strtok` modifies a static variable: is not thread safe.\n\nUnlike most other tokenizers, the delimiters in `strtok` can be different for each subsequent token, and can even depend on the contents of the previous tokens.\n\nThe `strtok_s` function differs from the POSIX [`strtok_r`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok.html) function by guarding against storing outside of the string being tokenized, and by checking runtime constraints. The Microsoft CRT `strtok_s` signature matches this POSIX `strtok_r` definition, not the C11 `strtok_s`.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n \nint main(void)\n{\n    char input[] = \"A bird came down the walk\";\n    printf(\"Parsing the input string '%s'\\n\", input);\n    char *token = strtok(input, \" \");\n    while(token) {\n        puts(token);\n        token = strtok(NULL, \" \");\n    }\n \n    printf(\"Contents of the input string now: '\");\n    for(size_t n = 0; n < sizeof input; ++n)\n        input[n] ? putchar(input[n]) : fputs(\"\\\\0\", stdout);\n    puts(\"'\");\n \n#ifdef __STDC_LIB_EXT1__\n    char str[] = \"A bird came down the walk\";\n    rsize_t strmax = sizeof str;\n    const char *delim = \" \";\n    char *next_token;\n    printf(\"Parsing the input string '%s'\\n\", str);\n    token = strtok_s(str, &strmax, delim, &next_token);\n    while(token) {\n        puts(token);\n        token = strtok_s(NULL, &strmax, delim, &next_token);\n    }\n \n    printf(\"Contents of the input string now: '\");\n    for(size_t n = 0; n < sizeof str; ++n)\n        str[n] ? putchar(str[n]) : fputs(\"\\\\0\", stdout);\n    puts(\"'\");\n#endif\n}\n```\n\nPossible output:\n\n```\nParsing the input string 'A bird came down the walk'\nA\nbird\ncame\ndown\nthe\nwalk\nContents of the input string now: 'A\\0bird\\0came\\0down\\0the\\0walk\\0'\nParsing the input string 'A bird came down the walk'\nA\nbird\ncame\ndown\nthe\nwalk\nContents of the input string now: 'A\\0bird\\0came\\0down\\0the\\0walk\\0'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.5.8 The strtok function (p: 369-370)\n  - K.3.7.3.1 The strtok_s function (p: 620-621)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.5.8 The strtok function (p: 332-333)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.5.8 The strtok function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtok](https://en.cppreference.com/w/c/string/byte/strtok)"
- name: strtok_s
  summary: Returns pointer to the beginning of the next token or a null pointer if there are no more tokens
  description: "# strtok, strtok_s\n\n[TABLE]\n\n1) Finds the next token in a null-terminated byte string pointed to by `str`. The separator characters are identified by null-terminated byte string pointed to by `delim`.\n\nThis function is designed to be called multiple times to obtain successive tokens from the same string.\n\n- If `str` is not a null pointer, the call is treated as the first call to `strtok` for this particular string. The function searches for the first character which is *not* contained in `delim`.\n- If no such character was found, there are no tokens in `str` at all, and the function returns a null pointer.\n- If such character was found, it is the *beginning of the token*. The function then searches from that point on for the first character that *is* contained in `delim`.\n  - If no such character was found, `str` has only one token, and future calls to `strtok` will return a null pointer\n  - If such character was found, it is *replaced* by the null character `'\\0'` and the pointer to the following character is stored in a static location for subsequent invocations.\n- The function then returns the pointer to the beginning of the token\n- If `str` is a null pointer, the call is treated as a subsequent call to `strtok`: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as `str`.\n\nThe behavior is undefined if either `str` or `delim` is not a pointer to a null-terminated byte string.\n\n2) Same as (1), except that on every step, writes the number of characters left to see in `str` into `*strmax` and writes the tokenizer's internal state to `*ptr`. Repeat calls (with null `str`) must pass `strmax` and `ptr` with the values stored by the previous call. Also, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function, without storing anything in the object pointed to by `ptr`\n\n- `strmax`, `delim`, or `ptr` is a null pointer\n- on a non-initial call (with null `str`), `*ptr` is a null pointer\n- on the first call, `*strmax` is zero or greater than `RSIZE_MAX`\n- search for the end of a token reaches the end of the source string (as measured by the initial value of `*strmax`) without encountering the null terminator\n\nThe behavior is undefined if both `str` points to a character array which lacks the null character and `strmax` points to a value which is greater than the size of that character array. As with all bounds-checked functions, `strtok_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<string.h>`](../byte \"c/string/byte\").\n\n### Parameters\n\n|        |     |                                                                                                                                   |\n|--------|-----|-----------------------------------------------------------------------------------------------------------------------------------|\n| str    | \\-  | pointer to the null-terminated byte string to tokenize                                                                            |\n| delim  | \\-  | pointer to the null-terminated byte string identifying delimiters                                                                 |\n| strmax | \\-  | pointer to an object which initially holds the size of `str`: strtok_s stores the number of characters that remain to be examined |\n| ptr    | \\-  | pointer to an object of type `char*`, which is used by strtok_s to store its internal state                                       |\n\n### Return value\n\nReturns pointer to the beginning of the next token or a null pointer if there are no more tokens.\n\n### Note\n\nThis function is destructive: it writes the `'\\0'` characters in the elements of the string `str`. In particular, a string literal cannot be used as the first argument of `strtok`.\n\nEach call to `strtok` modifies a static variable: is not thread safe.\n\nUnlike most other tokenizers, the delimiters in `strtok` can be different for each subsequent token, and can even depend on the contents of the previous tokens.\n\nThe `strtok_s` function differs from the POSIX [`strtok_r`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok.html) function by guarding against storing outside of the string being tokenized, and by checking runtime constraints. The Microsoft CRT `strtok_s` signature matches this POSIX `strtok_r` definition, not the C11 `strtok_s`.\n\n### Example\n\n```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n#include <stdio.h>\n \nint main(void)\n{\n    char input[] = \"A bird came down the walk\";\n    printf(\"Parsing the input string '%s'\\n\", input);\n    char *token = strtok(input, \" \");\n    while(token) {\n        puts(token);\n        token = strtok(NULL, \" \");\n    }\n \n    printf(\"Contents of the input string now: '\");\n    for(size_t n = 0; n < sizeof input; ++n)\n        input[n] ? putchar(input[n]) : fputs(\"\\\\0\", stdout);\n    puts(\"'\");\n \n#ifdef __STDC_LIB_EXT1__\n    char str[] = \"A bird came down the walk\";\n    rsize_t strmax = sizeof str;\n    const char *delim = \" \";\n    char *next_token;\n    printf(\"Parsing the input string '%s'\\n\", str);\n    token = strtok_s(str, &strmax, delim, &next_token);\n    while(token) {\n        puts(token);\n        token = strtok_s(NULL, &strmax, delim, &next_token);\n    }\n \n    printf(\"Contents of the input string now: '\");\n    for(size_t n = 0; n < sizeof str; ++n)\n        str[n] ? putchar(str[n]) : fputs(\"\\\\0\", stdout);\n    puts(\"'\");\n#endif\n}\n```\n\nPossible output:\n\n```\nParsing the input string 'A bird came down the walk'\nA\nbird\ncame\ndown\nthe\nwalk\nContents of the input string now: 'A\\0bird\\0came\\0down\\0the\\0walk\\0'\nParsing the input string 'A bird came down the walk'\nA\nbird\ncame\ndown\nthe\nwalk\nContents of the input string now: 'A\\0bird\\0came\\0down\\0the\\0walk\\0'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.5.8 The strtok function (p: 369-370)\n  - K.3.7.3.1 The strtok_s function (p: 620-621)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.5.8 The strtok function (p: 332-333)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.5.8 The strtok function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtok](https://en.cppreference.com/w/c/string/byte/strtok)"
- name: strtol
  summary: Interprets an integer value in a byte string pointed to by str
  description: "# strtol, strtoll\n\n[TABLE]\n\nInterprets an integer value in a byte string pointed to by `str`.\n\nDiscards any whitespace characters (as identified by calling [`isspace`](isspace \"c/string/byte/isspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type.\n\nThe functions set the pointer pointed to by `str_end` to point to the character past the last numeric character interpreted. If `str_end` is a null pointer, it is ignored.\n\nIf the `str` is empty or does not have the expected form, no conversion is performed, and (if `str_end` is not a null pointer) the value of `str` is stored in the object pointed to by `str_end`.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated byte string to be interpreted |\n| str_end | \\-  | pointer to a pointer to character.                           |\n| base    | \\-  | *base* of the interpreted integer value                      |\n\n### Return value\n\n- If successful, an integer value corresponding to the contents of `str` is returned.\n- If the converted value falls out of range of corresponding return type, a range error occurs (setting [`errno`](../../error/errno \"c/error/errno\") to [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")) and [`LONG_MAX`](../../types/limits \"c/types/limits\"), [`LONG_MIN`](../../types/limits \"c/types/limits\"), [`LLONG_MAX`](../../types/limits \"c/types/limits\") or [`LLONG_MIN`](../../types/limits \"c/types/limits\") is returned.\n- If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    // parsing with error handling\n    const char *p = \"10 200000000000000000000000000000 30 -40 junk\";\n    printf(\"Parsing '%s':\\n\", p);\n \n    for (;;)\n    {\n        // errno can be set to any non-zero value by a library function call\n        // regardless of whether there was an error, so it needs to be cleared\n        // in order to check the error set by strtol\n        errno = 0;\n        char *end;\n        const long i = strtol(p, &end, 10);\n        if (p == end)\n            break;\n \n        const bool range_error = errno == ERANGE;\n        printf(\"Extracted '%.*s', strtol returned %ld.\", (int)(end-p), p, i);\n        p = end;\n \n        if (range_error)\n            printf(\"\\n --> Range error occurred.\");\n \n        putchar('\\n');\n    }\n \n    printf(\"Unextracted leftover: '%s'\\n\\n\", p);\n \n    // parsing without error handling\n    printf(\"\\\"1010\\\" in binary  --> %ld\\n\", strtol(\"1010\", NULL, 2));\n    printf(\"\\\"12\\\"   in octal   --> %ld\\n\", strtol(\"12\",   NULL, 8));\n    printf(\"\\\"A\\\"    in hex     --> %ld\\n\", strtol(\"A\",    NULL, 16));\n    printf(\"\\\"junk\\\" in base-36 --> %ld\\n\", strtol(\"junk\", NULL, 36));\n    printf(\"\\\"012\\\"  in auto-detected base --> %ld\\n\", strtol(\"012\",  NULL, 0));\n    printf(\"\\\"0xA\\\"  in auto-detected base --> %ld\\n\", strtol(\"0xA\",  NULL, 0));\n    printf(\"\\\"junk\\\" in auto-detected base --> %ld\\n\", strtol(\"junk\", NULL, 0));\n}\n```\n\nPossible output:\n\n```\nParsing '10 200000000000000000000000000000 30 -40 junk':\nExtracted '10', strtol returned 10.\nExtracted ' 200000000000000000000000000000', strtol returned 9223372036854775807.\n --> Range error occurred.\nExtracted ' 30', strtol returned 30.\nExtracted ' -40', strtol returned -40.\nUnextracted leftover: ' junk'\n \n\"1010\" in binary  --> 10\n\"12\"   in octal   --> 10\n\"A\"    in hex     --> 10\n\"junk\" in base-36 --> 926192\n\"012\"  in auto-detected base --> 10\n\"0xA\"  in auto-detected base --> 10\n\"junk\" in auto-detected base --> 0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 251-252)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 344-345)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 310-311)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.5 The strtol function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtol](https://en.cppreference.com/w/c/string/byte/strtol)"
- name: strtold
  summary: Interprets a floating-point value in a byte string pointed to by str
  description: "# strtof, strtod, strtold\n\n[TABLE]\n\nInterprets a floating-point value in a byte string pointed to by `str`.\n\nFunction discards any whitespace characters (as determined by [`isspace`](isspace \"c/string/byte/isspace\")) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:\n\n- decimal floating-point expression. It consists of the following parts:\n  - (optional) plus or minus sign\n  - nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C [locale](../../locale/setlocale \"c/locale/setlocale\")) (defines significand)\n  - (optional) `e` or `E` followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent to base 10)\n\n[TABLE]\n\n- any other expression that may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\")\n\nThe functions sets the pointer pointed to by `str_end` to point to the character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated byte string to be interpreted |\n| str_end | \\-  | pointer to a pointer to character.                           |\n\n### Return value\n\nFloating-point value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs ([`errno`](../../error/errno \"c/error/errno\") is set to [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")) and [`HUGE_VAL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\"), [`HUGE_VALF`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") or [`HUGE_VALL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    // parsing with error handling\n    const char *p = \"111.11 -2.22 Nan nan(2) inF 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\";\n    printf(\"Parsing '%s':\\n\", p);\n    char *end;\n    for (double f = strtod(p, &end); p != end; f = strtod(p, &end))\n    {\n        printf(\"'%.*s' -> \", (int)(end-p), p);\n        p = end;\n        if (errno == ERANGE){\n            printf(\"range error, got \");\n            errno = 0;\n        }\n        printf(\"%f\\n\", f);\n    }\n \n    // parsing without error handling\n    printf(\"\\\"  -0.0000000123junk\\\"  -->  %g\\n\", strtod(\"  -0.0000000123junk\", NULL));\n    printf(\"\\\"junk\\\"                 -->  %g\\n\", strtod(\"junk\", NULL));\n}\n```\n\nPossible output:\n\n```\nParsing '111.11 -2.22 Nan nan(2) inF 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz':\n'111.11' -> 111.110000\n' -2.22' -> -2.220000\n' Nan' -> nan\n' nan(2)' -> nan\n' inF' -> inf\n' 0X1.BC70A3D70A3D7P+6' -> 111.110000\n'  1.18973e+4932' -> range error, got inf\n\"  -0.0000000123junk\"  -->  -1.23e-08\n\"junk\"                 -->  0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.1.3 The strtod, strtof, and strtold functions (p: 249-251)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.3 The strtod, strtof, and strtold functions (p: 342-344)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.3 The strtod, strtof, and strtold functions (p: 308-310)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.4 The strtod function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtof](https://en.cppreference.com/w/c/string/byte/strtof)"
- name: strtoll
  summary: Interprets an integer value in a byte string pointed to by str
  description: "# strtol, strtoll\n\n[TABLE]\n\nInterprets an integer value in a byte string pointed to by `str`.\n\nDiscards any whitespace characters (as identified by calling [`isspace`](isspace \"c/string/byte/isspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type.\n\nThe functions set the pointer pointed to by `str_end` to point to the character past the last numeric character interpreted. If `str_end` is a null pointer, it is ignored.\n\nIf the `str` is empty or does not have the expected form, no conversion is performed, and (if `str_end` is not a null pointer) the value of `str` is stored in the object pointed to by `str_end`.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated byte string to be interpreted |\n| str_end | \\-  | pointer to a pointer to character.                           |\n| base    | \\-  | *base* of the interpreted integer value                      |\n\n### Return value\n\n- If successful, an integer value corresponding to the contents of `str` is returned.\n- If the converted value falls out of range of corresponding return type, a range error occurs (setting [`errno`](../../error/errno \"c/error/errno\") to [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")) and [`LONG_MAX`](../../types/limits \"c/types/limits\"), [`LONG_MIN`](../../types/limits \"c/types/limits\"), [`LLONG_MAX`](../../types/limits \"c/types/limits\") or [`LLONG_MIN`](../../types/limits \"c/types/limits\") is returned.\n- If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    // parsing with error handling\n    const char *p = \"10 200000000000000000000000000000 30 -40 junk\";\n    printf(\"Parsing '%s':\\n\", p);\n \n    for (;;)\n    {\n        // errno can be set to any non-zero value by a library function call\n        // regardless of whether there was an error, so it needs to be cleared\n        // in order to check the error set by strtol\n        errno = 0;\n        char *end;\n        const long i = strtol(p, &end, 10);\n        if (p == end)\n            break;\n \n        const bool range_error = errno == ERANGE;\n        printf(\"Extracted '%.*s', strtol returned %ld.\", (int)(end-p), p, i);\n        p = end;\n \n        if (range_error)\n            printf(\"\\n --> Range error occurred.\");\n \n        putchar('\\n');\n    }\n \n    printf(\"Unextracted leftover: '%s'\\n\\n\", p);\n \n    // parsing without error handling\n    printf(\"\\\"1010\\\" in binary  --> %ld\\n\", strtol(\"1010\", NULL, 2));\n    printf(\"\\\"12\\\"   in octal   --> %ld\\n\", strtol(\"12\",   NULL, 8));\n    printf(\"\\\"A\\\"    in hex     --> %ld\\n\", strtol(\"A\",    NULL, 16));\n    printf(\"\\\"junk\\\" in base-36 --> %ld\\n\", strtol(\"junk\", NULL, 36));\n    printf(\"\\\"012\\\"  in auto-detected base --> %ld\\n\", strtol(\"012\",  NULL, 0));\n    printf(\"\\\"0xA\\\"  in auto-detected base --> %ld\\n\", strtol(\"0xA\",  NULL, 0));\n    printf(\"\\\"junk\\\" in auto-detected base --> %ld\\n\", strtol(\"junk\", NULL, 0));\n}\n```\n\nPossible output:\n\n```\nParsing '10 200000000000000000000000000000 30 -40 junk':\nExtracted '10', strtol returned 10.\nExtracted ' 200000000000000000000000000000', strtol returned 9223372036854775807.\n --> Range error occurred.\nExtracted ' 30', strtol returned 30.\nExtracted ' -40', strtol returned -40.\nUnextracted leftover: ' junk'\n \n\"1010\" in binary  --> 10\n\"12\"   in octal   --> 10\n\"A\"    in hex     --> 10\n\"junk\" in base-36 --> 926192\n\"012\"  in auto-detected base --> 10\n\"0xA\"  in auto-detected base --> 10\n\"junk\" in auto-detected base --> 0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 251-252)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 344-345)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 310-311)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.5 The strtol function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtol](https://en.cppreference.com/w/c/string/byte/strtol)"
- name: strtoul
  summary: Interprets an unsigned integer value in a byte string pointed to by str
  description: "# strtoul, strtoull\n\n[TABLE]\n\nInterprets an unsigned integer value in a byte string pointed to by `str`.\n\nDiscards any whitespace characters (as identified by calling [`isspace`](isspace \"c/string/byte/isspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type, which applies unsigned integer wraparound rules.\n\nThe functions sets the pointer pointed to by `str_end` to point to the character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                                                                   |\n|---------|-----|---------------------------------------------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated byte string to be interpreted                                      |\n| str_end | \\-  | pointer to a pointer to character, might be set to a position past the last character interpreted |\n| base    | \\-  | *base* of the interpreted integer value                                                           |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs ([`errno`](../../error/errno \"c/error/errno\") is set to `ERANGE`) and [`ULONG_MAX`](../../types/limits \"c/types/limits\") or [`ULLONG_MAX`](../../types/limits \"c/types/limits\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char *p = \"10 200000000000000000000000000000 30 -40 - 42\";\n    printf(\"Parsing '%s':\\n\", p);\n    char *end = NULL;\n    for (unsigned long i = strtoul(p, &end, 10);\n         p != end;\n         i = strtoul(p, &end, 10))\n    {\n        printf(\"'%.*s' -> \", (int)(end - p), p);\n        p = end;\n        if (errno == ERANGE)\n        {\n            errno = 0;\n            printf(\"range error, got \");\n        }\n        printf(\"%lu\\n\", i);\n    }\n    printf(\"After the loop p points to '%s'\\n\", p);\n}\n```\n\nOutput:\n\n```\nParsing '10 200000000000000000000000000000 30 -40 - 42':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' -40' -> 18446744073709551576\nAfter the loop p points to ' - 42'\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.24.1.7 The strtol, strtoll, strtoul, and strtoull functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 251-252)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 344-345)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 310-311)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.6 The strtoul function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtoul](https://en.cppreference.com/w/c/string/byte/strtoul)"
- name: strtoull
  summary: Interprets an unsigned integer value in a byte string pointed to by str
  description: "# strtoul, strtoull\n\n[TABLE]\n\nInterprets an unsigned integer value in a byte string pointed to by `str`.\n\nDiscards any whitespace characters (as identified by calling [`isspace`](isspace \"c/string/byte/isspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type, which applies unsigned integer wraparound rules.\n\nThe functions sets the pointer pointed to by `str_end` to point to the character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                                                                   |\n|---------|-----|---------------------------------------------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated byte string to be interpreted                                      |\n| str_end | \\-  | pointer to a pointer to character, might be set to a position past the last character interpreted |\n| base    | \\-  | *base* of the interpreted integer value                                                           |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs ([`errno`](../../error/errno \"c/error/errno\") is set to `ERANGE`) and [`ULONG_MAX`](../../types/limits \"c/types/limits\") or [`ULLONG_MAX`](../../types/limits \"c/types/limits\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    const char *p = \"10 200000000000000000000000000000 30 -40 - 42\";\n    printf(\"Parsing '%s':\\n\", p);\n    char *end = NULL;\n    for (unsigned long i = strtoul(p, &end, 10);\n         p != end;\n         i = strtoul(p, &end, 10))\n    {\n        printf(\"'%.*s' -> \", (int)(end - p), p);\n        p = end;\n        if (errno == ERANGE)\n        {\n            errno = 0;\n            printf(\"range error, got \");\n        }\n        printf(\"%lu\\n\", i);\n    }\n    printf(\"After the loop p points to '%s'\\n\", p);\n}\n```\n\nOutput:\n\n```\nParsing '10 200000000000000000000000000000 30 -40 - 42':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' -40' -> 18446744073709551576\nAfter the loop p points to ' - 42'\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.24.1.7 The strtol, strtoll, strtoul, and strtoull functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 251-252)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 344-345)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.1.4 The strtol, strtoll, strtoul, and strtoull functions (p: 310-311)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.1.6 The strtoul function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtoul](https://en.cppreference.com/w/c/string/byte/strtoul)"
- name: strtoumax
  summary: Interprets an integer value in a byte string pointed to by nptr
  description: "# strtoimax, strtoumax\n\n[TABLE]\n\nInterprets an integer value in a byte string pointed to by `nptr`.\n\nDiscards any whitespace characters (as identified by calling [`isspace`](isspace \"c/string/byte/isspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type.\n\nThe functions sets the pointer pointed to by `endptr` to point to the character past the last character interpreted. If `endptr` is a null pointer, it is ignored.\n\nIf the `nptr` is empty or does not have the expected form, no conversion is performed, and (if `endptr` is not a null pointer) the value of `nptr` is stored in the object pointed to by `endptr`.\n\n### Parameters\n\n|        |     |                                                              |\n|--------|-----|--------------------------------------------------------------|\n| nptr   | \\-  | pointer to the null-terminated byte string to be interpreted |\n| endptr | \\-  | pointer to a pointer to character.                           |\n| base   | \\-  | *base* of the interpreted integer value                      |\n\n### Return value\n\n- If successful, an integer value corresponding to the contents of `str` is returned.\n- If the converted value falls out of range of corresponding return type, a range error occurs (setting [`errno`](../../error/errno \"c/error/errno\") to [`ERANGE`](../../error/errno_macros \"c/error/errno macros\")) and [`INTMAX_MAX`](../../types/integer \"c/types/integer\"), [`INTMAX_MIN`](../../types/integer \"c/types/integer\"), [`UINTMAX_MAX`](../../types/integer \"c/types/integer\") or `​0​` is returned, as appropriate.\n- If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <string.h>\n \nint main(void)\n{\n    char* endptr;\n \n    printf(\"%ld\\n\", strtoimax(\" -123junk\",&endptr,10)); /* base 10                    */\n    printf(\"%ld\\n\", strtoimax(\"11111111\",&endptr,2));   /* base 2                     */\n    printf(\"%ld\\n\", strtoimax(\"XyZ\",&endptr,36));       /* base 36                    */\n    printf(\"%ld\\n\", strtoimax(\"010\",&endptr,0));        /* octal auto-detection       */\n    printf(\"%ld\\n\", strtoimax(\"10\",&endptr,0));         /* decimal auto-detection     */\n    printf(\"%ld\\n\", strtoimax(\"0x10\",&endptr,0));       /* hexadecimal auto-detection */\n \n    /* range error             */\n    /* LONG_MAX+1 --> LONG_MAX */\n    errno = 0;\n    printf(\"%ld\\n\", strtoimax(\"9223372036854775808\",&endptr,10));\n    printf(\"%s\\n\", strerror(errno));\n \n    return 0;\n}\n```\n\nOutput:\n\n```\n-123\n255\n44027\n8\n10\n16\n9223372036854775807\nNumerical result out of range\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.8.2.3 The strtoimax and strtoumax functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.8.2.3 The strtoimax and strtoumax functions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.3 The strtoimax and strtoumax functions (p: 219)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.3 The strtoimax and strtoumax functions (p: 200)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strtoimax](https://en.cppreference.com/w/c/string/byte/strtoimax)"
- name: struct
  summary: ''
  description: "# C keywords: struct\n\n### Usage\n\n- [declaration of a compound type](../language/struct \"c/language/struct\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/struct](https://en.cppreference.com/w/c/keyword/struct)"
- name: Struct and union initialization
  summary: 'When initializing an object of struct or union type, the initializer must be a non-empty,(until C23) brace-enclosed, comma-separated list of initializers for the members:'
  description: "# Struct and union initialization\n\nWhen [initializing](initialization \"c/language/initialization\") an object of [struct](struct \"c/language/struct\") or [union](union \"c/language/union\") type, the initializer must be a non-empty,(until C23) brace-enclosed, comma-separated list of initializers for the members:\n\n|                                                       |       |             |\n|-------------------------------------------------------|-------|-------------|\n| `=` `{` expression `,` `...` `}`                      | \\(1\\) | (until C99) |\n| `=` `{` designator(optional) expression `,` `...` `}` | \\(2\\) | (since C99) |\n| `=` `{` `}`                                           | \\(3\\) | (since C23) |\n\nwhere the designator is a sequence (whitespace-separated or adjacent) of individual member designators of the form `.` member and [array designators](array_initialization \"c/language/array initialization\") of the form `[` index `]`.\n\nAll members that are not initialized explicitly are [empty-initialized](initialization#Empty_initialization \"c/language/initialization\").\n\n### Explanation\n\nWhen initializing a [union](union \"c/language/union\"), the initializer list must have only one member, which initializes the first member of the union unless a designated initializer is used(since C99).\n\n```\nunion { int x; char c[4]; }\n  u = {1},           // makes u.x active with value 1\n u2 = { .c={'\\1'} }; // makes u2.c active with value {'\\1','\\0','\\0','\\0'}\n```\n\nWhen initializing a [struct](struct \"c/language/struct\"), the first initializer in the list initializes the first declared member (unless a designator is specified)(since C99), and all subsequent initializers without designators (since C99)initialize the struct members declared after the one initialized by the previous expression.\n\n```\nstruct point {double x,y,z;} p = {1.2, 1.3}; // p.x=1.2, p.y=1.3, p.z=0.0\ndiv_t answer = {.quot = 2, .rem = -1 };      // order of elements in div_t may vary\n```\n\n[TABLE]\n\nIt's an error to provide more initializers than members.\n\n### Nested initialization\n\nIf the members of the struct or union are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:\n\nIf the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding member object. Each left opening brace establishes a new *current object*. The members of the current object are initialized in their natural order, unless designators are used(since C99): array elements in subscript order, struct members in declaration order, only the first declared member of any union. The subobjects within the current object that are not explicitly initialized by the closing brace are [empty-initialized](initialization#Empty_initialization \"c/language/initialization\").\n\n```\nstruct example {\n    struct addr_t {\n       uint32_t port;\n    } addr;\n    union {\n       uint8_t a8[4];\n       uint16_t a16[2];\n    } in_u;\n};\nstruct example ex = { // start of initializer list for struct example\n                     { // start of initializer list for ex.addr\n                        80 // initialized struct's only member\n                     }, // end of initializer list for ex.addr\n                     { // start of initializer-list for ex.in_u\n                        {127,0,0,1} // initializes first element of the union\n                     } };\n```\n\nIf the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the member array, struct or union; any remaining initializers are left to initialize the next struct member:\n\n```\nstruct example ex = {80, 127, 0, 0, 1}; // 80 initializes ex.addr.port\n                                        // 127 initializes ex.in_u.a8[0]\n                                        // 0 initializes ex.in_u.a8[1]\n                                        // 0 initializes ex.in_u.a8[2]\n                                        // 1 initializes ex.in_u.a8[3]\n```\n\n[TABLE]\n\n### Notes\n\nThe initializer list may have a trailing comma, which is ignored.\n\n```\nstruct {double x,y;} p = {1.0,\n                          2.0, // trailing comma OK\n                          };\n```\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| In C, the braced list of initializers cannot be empty (note that C++ allows empty lists, and also note that a [struct](struct \"c/language/struct\") in C cannot be empty): | (until C23) |\n| The initializer list can be empty in C as in C++:                                                                                                                         | (since C23) |\n\n```\nstruct {int n;} s = {0}; // OK\nstruct {int n;} s = {}; // Error until C23: initializer-list cannot be empty\n                        // OK since C23: s.n is initialized to 0\nstruct {} s = {}; // Error: struct cannot be empty\n```\n\n[TABLE]\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    char buff[70];\n    // designated initializers simplify the use of structs whose\n    // order of members is unspecified\n    struct tm my_time = { .tm_year=2012-1900, .tm_mon=9, .tm_mday=9,\n                          .tm_hour=8, .tm_min=10, .tm_sec=20 };\n    strftime(buff, sizeof buff, \"%A %c\", &my_time);\n    puts(buff);\n}\n```\n\nPossible output:\n\n```\nSunday Sun Oct  9 08:10:20 2012\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.9/12-39 Initialization (p: 101-105)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.9/12-38 Initialization (p: 140-144)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.8/12-38 Initialization (p: 126-130)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 6.5.7 Initialization\n\n### See also\n\n|                                                                                                                                                               |     |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/aggregate_initialization \"cpp/language/aggregate initialization\") for Aggregate initialization |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/struct_initialization](https://en.cppreference.com/w/c/language/struct_initialization)"
- name: Struct declaration
  summary: A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps)
  description: "# Struct declaration\n\nA struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps).\n\nThe [type specifier](declarations \"c/language/declarations\") for a struct is identical to the [`union`](union \"c/language/union\") type specifier except for the keyword used:\n\n### Syntax\n\n|                                                                                   |       |     |\n|-----------------------------------------------------------------------------------|-------|-----|\n| `struct` attr-spec-seq \uFEFF(optional) name \uFEFF(optional) `{` struct-declaration-list `}` | \\(1\\) |     |\n| `struct` attr-spec-seq \uFEFF(optional) name                                            | \\(2\\) |     |\n\n1) Struct definition: introduces the new type struct name and defines its meaning\n\n2) If used on a line of its own, as in `struct` name `;`, *declares* but doesn't define the struct `name` (see forward declaration below). In other contexts, names the previously-declared struct, and attr-spec-seq is not allowed.\n\n|                         |     |                                                                                                                                                                                                                                                                                                             |\n|-------------------------|-----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| name                    | \\-  | the name of the struct that's being defined                                                                                                                                                                                                                                                                 |\n| struct-declaration-list | \\-  | any number of variable declarations, [bit-field](bit_field \"c/language/bit field\") declarations, and [static assert](static_assert \"c/language/static assert\") declarations. Members of incomplete type and members of function type are not allowed (except for the flexible array member described below) |\n| attr-spec-seq           | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the struct type                                                                                                                                                                                                          |\n\n### Explanation\n\nWithin a struct object, addresses of its elements (and the addresses of the bit-field allocation units) increase in order in which the members were defined. A pointer to a struct can be cast to a pointer to its first member (or, if the member is a bit-field, to its allocation unit). Likewise, a pointer to the first member of a struct can be cast to a pointer to the enclosing struct. There may be unnamed padding between any two members of a struct or after the last member, but not before the first member. The size of a struct is at least as large as the sum of the sizes of its members.\n\n[TABLE]\n\n[TABLE]\n\n### Forward declaration\n\nA declaration of the following form\n\n|                                            |     |     |\n|--------------------------------------------|-----|-----|\n| `struct` attr-spec-seq \uFEFF(optional) name `;` |     |     |\n\nhides any previously declared meaning for the name name in the tag name space and declares name as a new struct name in current scope, which will be defined later. Until the definition appears, this struct name has [incomplete type](type#Incomplete_types \"c/language/type\").\n\nThis allows structs that refer to each other:\n\n```\nstruct y;\nstruct x { struct y *p; /* ... */ };\nstruct y { struct x *q; /* ... */ };\n```\n\nNote that a new struct name may also be introduced just by using a struct tag within another declaration, but if a previously declared struct with the same name exists in the tag [name space](name_space \"c/language/name space\"), the tag would refer to that name\n\n```\nstruct s* p = NULL; // tag naming an unknown struct declares it\nstruct s { int a; }; // definition for the struct pointed to by p\nvoid g(void)\n{\n    struct s; // forward declaration of a new, local struct s\n              // this hides global struct s until the end of this block\n    struct s *p;  // pointer to local struct s\n                  // without the forward declaration above,\n                  // this would point at the file-scope s\n    struct s { char* p; }; // definitions of the local struct s\n}\n```\n\n### Keywords\n\n[`struct`](../keyword/struct \"c/keyword/struct\")\n\n### Notes\n\nSee [struct initialization](struct_initialization \"c/language/struct initialization\") for the rules regarding the initializers for structs.\n\nBecause members of incomplete type are not allowed, and a struct type is not complete until the end of the definition, a struct cannot have a member of its own type. A pointer to its own type is allowed, and is commonly used to implement nodes in linked lists or trees.\n\nBecause a struct declaration does not establish [scope](scope \"c/language/scope\"), nested types, enumerations and enumerators introduced by declarations within struct-declaration-list are visible in the surrounding scope where the struct is defined.\n\n### Example\n\n```\n#include <stddef.h>\n#include <stdio.h>\n \nint main(void)\n{\n    // Declare the struct type.\n    struct car\n    {\n        char* make;\n        int year;\n    };\n    // Declare and initialize an object of a previously-declared struct type.\n    struct car c = {.year = 1923, .make = \"Nash\"};\n    printf(\"1) Car: %d %s\\n\", c.year, c.make);\n \n    // Declare a struct type, an object of that type, and a pointer to it.\n    struct spaceship\n    {\n        char* model;\n        int max_speed;\n    } ship = {\"T-65 X-wing starfighter\", 1050},\n    *pship = &ship;\n    printf(\"2) Spaceship: %s. Max speed: %d km/h\\n\\n\", ship.model, ship.max_speed);\n \n    // Address increase in order of definition. Padding may be inserted.\n    struct A { char a; double b; char c; };\n    printf(\n        \"3) Offset of char a = %zu\\n\"\n        \"4) Offset of double b = %zu\\n\"\n        \"5) Offset of char c = %zu\\n\"\n        \"6) Size of struct A = %zu\\n\\n\",\n        offsetof(struct A, a),\n        offsetof(struct A, b),\n        offsetof(struct A, c),\n        sizeof(struct A)\n    );\n    struct B { char a; char b; double c; };\n    printf(\n        \"7) Offset of char a = %zu\\n\"\n        \"8) Offset of char b = %zu\\n\"\n        \"9) Offset of double c = %zu\\n\"\n        \"A) Size of struct B = %zu\\n\\n\",\n        offsetof(struct B, a),\n        offsetof(struct B, b),\n        offsetof(struct B, c),\n        sizeof(struct B)\n    );\n \n    // A pointer to a struct can be cast to a pointer\n    // to its first member and vice versa.\n    char** pmodel = (char **)pship;\n    printf(\"B) %s\\n\", *pmodel);\n    pship = (struct spaceship *)pmodel;\n}\n```\n\nPossible output:\n\n```\n1) Car: 1923 Nash\n2) Spaceship: T-65 X-wing starfighter. Max speed: 1050 km/h\n \n3) Offset of char a = 0\n4) Offset of double b = 8\n5) Offset of char c = 16\n6) Size of struct A = 24\n \n7) Offset of char a = 0\n8) Offset of char b = 1\n9) Offset of double c = 8\nA) Size of struct B = 16\n \nB) T-65 X-wing starfighter\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.2.1 Structure and union specifiers (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.2.1 Structure and union specifiers (p: 81-84)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.2.1 Structure and union specifiers (p: 112-117)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.2.1 Structure and union specifiers (p: 101-104)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.5.2.1 Structure and union specifiers\n\n### See also\n\n- [struct and union member access](operator_member_access \"c/language/operator member access\")\n- [bit-field](bit_field \"c/language/bit field\")\n- [struct initialization](struct_initialization \"c/language/struct initialization\")\n\n|                                                                                                                  |     |\n|------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/class \"cpp/language/class\") for Class declaration |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/struct](https://en.cppreference.com/w/c/language/struct)"
- name: strxfrm
  summary: Transforms the null-terminated byte string pointed to by src into the implementation-defined form such that comparing two transformed strings with strcmp gives the same result as comparing the original strings with strcoll, in the current C locale
  description: "# strxfrm\n\n[TABLE]\n\nTransforms the null-terminated byte string pointed to by `src` into the implementation-defined form such that comparing two transformed strings with [`strcmp`](strcmp \"c/string/byte/strcmp\") gives the same result as comparing the original strings with [`strcoll`](strcoll \"c/string/byte/strcoll\"), in the current C locale.\n\nThe first `count` characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.\n\nThe behavior is undefined if the `dest` array is not large enough. The behavior is undefined if `dest` and `src` overlap.\n\nIf `count` is `​0​`, then `dest` is allowed to be a null pointer.\n\n### Notes\n\nThe correct length of the buffer that can receive the entire transformed string is `1``+``strxfrm``(`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`, src, ``0``)`\n\nThis function is used when making multiple locale-dependent comparisons using the same string or set of strings, because it is more efficient to use `strxfrm` to transform all the strings just once, and subsequently compare the transformed strings with [`strcmp`](strcmp \"c/string/byte/strcmp\").\n\n### Parameters\n\n|       |     |                                                                                        |\n|-------|-----|----------------------------------------------------------------------------------------|\n| dest  | \\-  | pointer to the first element of the array where the transformed string will be written |\n| src   | \\-  | pointer to the first character of a null-terminated byte string to transform           |\n| count | \\-  | maximum number of characters to be written                                             |\n\n### Return value\n\nThe length of the transformed string, not including the terminating null-character.\n\n### Example\n\n```\n#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n \nint main(void)\n{\n    setlocale(LC_COLLATE, \"cs_CZ.iso88592\");\n \n    const char *in1 = \"hrnec\";\n    char out1[1+strxfrm(NULL, in1, 0)];\n    strxfrm(out1, in1, sizeof out1);\n \n    const char *in2 = \"chrt\";\n    char out2[1+strxfrm(NULL, in2, 0)];\n    strxfrm(out2, in2, sizeof out2);\n \n    printf(\"In the Czech locale: \");\n    if(strcmp(out1, out2) < 0)\n         printf(\"%s before %s\\n\",in1, in2);\n    else\n         printf(\"%s before %s\\n\",in2, in1);\n \n    printf(\"In lexicographical comparison: \");\n    if(strcmp(in1, in2)<0)\n         printf(\"%s before %s\\n\",in1, in2);\n    else\n         printf(\"%s before %s\\n\",in2, in1);\n \n}\n```\n\nPossible output:\n\n```\nIn the Czech locale: hrnec before chrt\nIn lexicographical comparison: chrt before hrnec\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.24.4.5 The strxfrm function (p: 267)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.24.4.5 The strxfrm function (p: 366-367)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.21.4.5 The strxfrm function (p: 329-330)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.11.4.5 The strxfrm function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/strxfrm](https://en.cppreference.com/w/c/string/byte/strxfrm)"
- name: switch
  summary: ''
  description: "# C keywords: switch\n\n### Usage\n\n- [`switch` statement](../language/switch \"c/language/switch\"): as the declaration of the statement\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/switch](https://en.cppreference.com/w/c/keyword/switch)"
- name: switch statement
  summary: Executes code according to the value of an integral argument
  description: "# switch statement\n\nExecutes code according to the value of an integral argument.\n\nUsed where one or several out of many branches of code need to be executed according to an integral value.\n\n### Syntax\n\n|                                                             |     |     |\n|-------------------------------------------------------------|-----|-----|\n| attr-spec-seq(optional) `switch (` expression `)` statement |     |     |\n\n|               |     |                                                                                                                                                                                             |\n|---------------|-----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| attr-spec-seq | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the `switch` statement                                                                                   |\n| expression    | \\-  | any [expression](expressions \"c/language/expressions\") of [integer type](type#Type_groups \"c/language/type\") (char, signed or unsigned integer, or enumeration)                             |\n| statement     | \\-  | any [statement](statements \"c/language/statements\") (typically a compound statement). `case:` and `default:` labels are permitted in statement, and `break;` statement has special meaning. |\n\n|                                                                            |       |             |\n|----------------------------------------------------------------------------|-------|-------------|\n| `case` constant-expression `:` statement                                   | \\(1\\) | (until C23) |\n| attr-spec-seq(optional) `case` constant-expression `:` statement(optional) | \\(1\\) | (since C23) |\n| `default` `:` statement                                                    | \\(2\\) | (until C23) |\n| attr-spec-seq(optional) `default` `:` statement(optional)                  | \\(2\\) | (since C23) |\n\n|                     |     |                                                                                              |\n|---------------------|-----|----------------------------------------------------------------------------------------------|\n| constant-expression | \\-  | any integer [constant expression](constant_expression \"c/language/constant expression\")      |\n| attr-spec-seq       | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the label |\n\n### Explanation\n\nThe body of a switch statement may have an arbitrary number of `case:` labels, as long as the values of all constant-expressions are unique (after [conversion](conversion \"c/language/conversion\") to the [promoted type](conversion#Integer_promotions \"c/language/conversion\") of expression). At most one `default:` label may be present (although nested switch statements may use their own `default:` labels or have `case:` labels whose constants are identical to the ones used in the enclosing switch).\n\nIf expression evaluates to the value that is equal to the value of one of constant-expressions after conversion to the promoted type of expression, then control is transferred to the statement that is labeled with that constant-expression.\n\nIf expression evaluates to a value that doesn't match any of the `case:` labels, and the `default:` label is present, control is transferred to the statement labeled with the `default:` label.\n\nIf expression evaluates to a value that doesn't match any of the `case:` labels, and the `default:` label is not present, none of the switch body is executed.\n\nThe [break](break \"c/language/break\") statement, when encountered anywhere in statement, exits the switch statement:\n\n```\nswitch(1) {\n    case 1 : puts(\"1\"); // prints \"1\",\n    case 2 : puts(\"2\"); // then prints \"2\" (\"fall-through\")\n}\n```\n\n```\nswitch(1) {\n    case 1 : puts(\"1\"); // prints \"1\"\n             break;     // and exits the switch\n    case 2 : puts(\"2\");\n             break;\n}\n```\n\n[TABLE]\n\n### Keywords\n\n[`switch`](../keyword/switch \"c/keyword/switch\"), [`case`](../keyword/case \"c/keyword/case\"), [`default`](../keyword/default \"c/keyword/default\")\n\n### Example\n\n```\n#include <stdio.h>\n \nvoid func(int x)\n{\n   printf(\"func(%d): \", x);\n   switch(x)\n   {\n      case 1: printf(\"case 1, \");\n      case 2: printf(\"case 2, \");\n      case 3: printf(\"case 3.\\n\"); break;\n      case 4: printf(\"case 4, \");\n      case 5:\n      case 6: printf(\"case 5 or case 6, \");\n      default: printf(\"default.\\n\");\n   }\n}\n \nint main(void)\n{\n   for(int i = 1; i < 9; ++i) func(i);\n}\n```\n\nOutput:\n\n```\nfunc(1): case 1, case 2, case 3.\nfunc(2): case 2, case 3.\nfunc(3): case 3.\nfunc(4): case 4, case 5 or case 6, default.\nfunc(5): case 5 or case 6, default.\nfunc(6): case 5 or case 6, default.\nfunc(7): default.\nfunc(8): default.\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.8.4.2 The switch statement (p: 108-109)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.8.4.2 The switch statement (p: 149-150)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.8.4.2 The switch statement (p: 134-135)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.6.4.2 The switch statement\n\n### See also\n\n|                                                                                                                     |     |\n|---------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/switch \"cpp/language/switch\") for `switch` statement |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/switch](https://en.cppreference.com/w/c/language/switch)"
- name: swprintf
  summary: Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# wprintf, fwprintf, swprintf, wprintf_s, fwprintf_s, swprintf_s, snwprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) If `bufsz` is greater than zero, writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. If `bufsz` is zero, nothing is written (and `buffer` may be a null pointer).\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (only for `swprintf_s`) the number of wide characters to be written, including the null, would exceed `bufsz`.\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by s. As with all bounds-checked functions, `wprintf_s` , `fwprintf_s`, `swprintf_s`, and `snwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a wide character string to write to                                                                                                                                                                                                                                                                                                                                                                                           |\n| bufsz  | \\-  | up to `bufsz-1` wide characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                 |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) Number of wide characters written if successful or negative value if an error occurred.\n\n3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than `size` (including when `size` is zero).\n\n4,5) Number of wide characters written if successful or negative value if an error occurred.\n\n6) Number of wide characters (not counting the terminating null) that were written to `buffer`. Returns a negative value on encoding errors and on overflow. Returns zero on all other errors.\n\n7) Number of wide characters (not counting the terminating null) that would have been written to `buffer` had `bufsz` been sufficiently large, or a negative value if an error occurs. (meaning, write was successful and complete only if the return is nonnegative and less than `bufsz`)\n\n### Notes\n\nWhile narrow strings provide [`snprintf`](fprintf \"c/io/fprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until `snwprintf_s`)(since C11), and in order to determine the buffer size, the program may need to call `swprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`snwprintf_s`, unlike `swprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    char narrow_str[] = \"z\\u00df\\u6c34\\U0001f34c\";\n                    // or \"zß水🍌\"\n                    // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator\n    setlocale(LC_ALL, \"en_US.utf8\");\n    swprintf(warr, sizeof warr/sizeof *warr,\n              L\"Converted from UTF-8: '%s'\", narrow_str);\n    wprintf(L\"%ls\\n\", warr);\n}\n```\n\nOutput:\n\n```\nConverted from UTF-8: 'zß水🍌'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.1 The fwprintf function (p: 403-410)\n  - 7.29.2.3 The swprintf function (p: 416)\n  - 7.29.2.11 The wprintf function (p: 421)\n  - K.3.9.1.1 The fwprintf_s function (p: 628)\n  - K.3.9.1.4 The swprintf_s function (p: 630-631)\n  - K.3.9.1.13 The wprintf_s function (p: 637-638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.1 The fwprintf function (p: 349-356)\n  - 7.24.2.3 The swprintf function (p: 362)\n  - 7.24.2.11 The wprintf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwprintf](https://en.cppreference.com/w/c/io/fwprintf)"
- name: swprintf_s
  summary: Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# wprintf, fwprintf, swprintf, wprintf_s, fwprintf_s, swprintf_s, snwprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) If `bufsz` is greater than zero, writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. If `bufsz` is zero, nothing is written (and `buffer` may be a null pointer).\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (only for `swprintf_s`) the number of wide characters to be written, including the null, would exceed `bufsz`.\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by s. As with all bounds-checked functions, `wprintf_s` , `fwprintf_s`, `swprintf_s`, and `snwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a wide character string to write to                                                                                                                                                                                                                                                                                                                                                                                           |\n| bufsz  | \\-  | up to `bufsz-1` wide characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                 |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) Number of wide characters written if successful or negative value if an error occurred.\n\n3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than `size` (including when `size` is zero).\n\n4,5) Number of wide characters written if successful or negative value if an error occurred.\n\n6) Number of wide characters (not counting the terminating null) that were written to `buffer`. Returns a negative value on encoding errors and on overflow. Returns zero on all other errors.\n\n7) Number of wide characters (not counting the terminating null) that would have been written to `buffer` had `bufsz` been sufficiently large, or a negative value if an error occurs. (meaning, write was successful and complete only if the return is nonnegative and less than `bufsz`)\n\n### Notes\n\nWhile narrow strings provide [`snprintf`](fprintf \"c/io/fprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until `snwprintf_s`)(since C11), and in order to determine the buffer size, the program may need to call `swprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`snwprintf_s`, unlike `swprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    char narrow_str[] = \"z\\u00df\\u6c34\\U0001f34c\";\n                    // or \"zß水🍌\"\n                    // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator\n    setlocale(LC_ALL, \"en_US.utf8\");\n    swprintf(warr, sizeof warr/sizeof *warr,\n              L\"Converted from UTF-8: '%s'\", narrow_str);\n    wprintf(L\"%ls\\n\", warr);\n}\n```\n\nOutput:\n\n```\nConverted from UTF-8: 'zß水🍌'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.1 The fwprintf function (p: 403-410)\n  - 7.29.2.3 The swprintf function (p: 416)\n  - 7.29.2.11 The wprintf function (p: 421)\n  - K.3.9.1.1 The fwprintf_s function (p: 628)\n  - K.3.9.1.4 The swprintf_s function (p: 630-631)\n  - K.3.9.1.13 The wprintf_s function (p: 637-638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.1 The fwprintf function (p: 349-356)\n  - 7.24.2.3 The swprintf function (p: 362)\n  - 7.24.2.11 The wprintf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwprintf](https://en.cppreference.com/w/c/io/fwprintf)"
- name: swscanf
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into given locations
  description: "# wscanf, fwscanf, swscanf, wscanf_s, fwscanf_s, swscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%lc` into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs all bounds-checked functions, `wscanf_s`, `fwscanf_s`, and `swscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../string/wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                      |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <string.h>\n \n#define NUM_VARS   3\n#define ERR_READ   2\n#define ERR_WRITE  3\n \nint main(void) {\n    wchar_t state[64];\n    wchar_t capital[64];\n    unsigned int population = 0;\n    int elevation = 0;\n    int age = 0;\n    float pi = 0;\n \n#if INTERACTIVE_MODE\n    wprintf(L\"Enter state, age, and pi value: \");\n    if (wscanf(L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#else\n    wchar_t* input = L\"California 170 3.141592\";\n    if (swscanf(input, L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#endif\n    wprintf(L\"State: %ls\\nAge  : %d years\\nPi   : %.5f\\n\\n\", state, age, pi);\n \n    FILE* fp = tmpfile();\n    if (fp) {\n        // write some data to temp file\n        if (!fwprintf(fp, L\"Mississippi Jackson 420000 807\")) {\n            fprintf(stderr, \"Error writing to file.\\n\");\n            fclose(fp);\n            return ERR_WRITE;\n        }\n        // rewind file pointer\n        rewind(fp);\n \n        // read data into variables\n        fwscanf(fp, L\"%ls%ls%u%d\", state, capital, &population, &elevation);\n        wprintf(L\"State  : %ls\\nCapital: %ls\\nJackson population (in 2020): %u\\n\"\n                L\"Highest elevation: %dft\\n\",\n                state, capital, population, elevation);\n        fclose(fp);\n    }\n}\n```\n\nPossible output:\n\n```\nState: California\nAge  : 170 years\nPi   : 3.14159\n \nState  : Mississippi\nCapital: Jackson\nJackson population (in 2020): 420000\nHighest elevation: 807ft\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.2 The fwscanf function (p: 410-416)\n  - 7.29.2.4 The swscanf function (p: 417)\n  - 7.29.2.12 The wscanf function (p: 421)\n  - K.3.9.1.2 The fwscanf_s function (p: 628-629)\n  - K.3.9.1.5 The swscanf_s function (p: 631)\n  - K.3.9.1.14 The wscanf_s function (p: 638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.2 The fwscanf function (p: 356-362)\n  - 7.24.2.4 The swscanf function (p: 362)\n  - 7.24.2.12 The wscanf function (p: 366-367)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwscanf](https://en.cppreference.com/w/c/io/fwscanf)"
- name: swscanf_s
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into given locations
  description: "# wscanf, fwscanf, swscanf, wscanf_s, fwscanf_s, swscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%lc` into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs all bounds-checked functions, `wscanf_s`, `fwscanf_s`, and `swscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../string/wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                      |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <string.h>\n \n#define NUM_VARS   3\n#define ERR_READ   2\n#define ERR_WRITE  3\n \nint main(void) {\n    wchar_t state[64];\n    wchar_t capital[64];\n    unsigned int population = 0;\n    int elevation = 0;\n    int age = 0;\n    float pi = 0;\n \n#if INTERACTIVE_MODE\n    wprintf(L\"Enter state, age, and pi value: \");\n    if (wscanf(L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#else\n    wchar_t* input = L\"California 170 3.141592\";\n    if (swscanf(input, L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#endif\n    wprintf(L\"State: %ls\\nAge  : %d years\\nPi   : %.5f\\n\\n\", state, age, pi);\n \n    FILE* fp = tmpfile();\n    if (fp) {\n        // write some data to temp file\n        if (!fwprintf(fp, L\"Mississippi Jackson 420000 807\")) {\n            fprintf(stderr, \"Error writing to file.\\n\");\n            fclose(fp);\n            return ERR_WRITE;\n        }\n        // rewind file pointer\n        rewind(fp);\n \n        // read data into variables\n        fwscanf(fp, L\"%ls%ls%u%d\", state, capital, &population, &elevation);\n        wprintf(L\"State  : %ls\\nCapital: %ls\\nJackson population (in 2020): %u\\n\"\n                L\"Highest elevation: %dft\\n\",\n                state, capital, population, elevation);\n        fclose(fp);\n    }\n}\n```\n\nPossible output:\n\n```\nState: California\nAge  : 170 years\nPi   : 3.14159\n \nState  : Mississippi\nCapital: Jackson\nJackson population (in 2020): 420000\nHighest elevation: 807ft\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.2 The fwscanf function (p: 410-416)\n  - 7.29.2.4 The swscanf function (p: 417)\n  - 7.29.2.12 The wscanf function (p: 421)\n  - K.3.9.1.2 The fwscanf_s function (p: 628-629)\n  - K.3.9.1.5 The swscanf_s function (p: 631)\n  - K.3.9.1.14 The wscanf_s function (p: 638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.2 The fwscanf function (p: 356-362)\n  - 7.24.2.4 The swscanf function (p: 362)\n  - 7.24.2.12 The wscanf function (p: 366-367)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwscanf](https://en.cppreference.com/w/c/io/fwscanf)"
- name: system
  summary: Calls the host environment's command processor with the parameter command
  description: "# system\n\n[TABLE]\n\nCalls the host environment's command processor with the parameter `command`. Returns an implementation-defined value (usually the value that the invoked program returns).\n\nIf command is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.\n\n### Parameters\n\n|         |     |                                                                                                                                                     |\n|---------|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------|\n| command | \\-  | character string identifying the command to be run in the command processor. If a null pointer is given, command processor is checked for existence |\n\n### Return value\n\nImplementation-defined value. If `command` is a null pointer, returns a nonzero value if and only if the command processor exists.\n\n### Notes\n\nOn POSIX systems, the return value can be decomposed using [`WEXITSTATUS` and `WSTOPSIG`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html).\n\nThe related POSIX function [popen](http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html) makes the output generated by `command` available to the caller.\n\n### Example\n\nIn this example there is a system call of the unix command **date +%A** and a system call to (possibly installed) **gcc** compiler with command-line argument (*--version*):\n\n```\n#include <stdlib.h>\n \nint main(void) {\n    system(\"date +%A\");\n    system(\"gcc --version\");\n}\n```\n\nPossible output:\n\n```\nWednesday\ngcc (GCC) 11.2.0\n...\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.4.8 The system function (p: 257)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.4.8 The system function (p: 353-354)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.4.6 The system function (p: 317)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.4.5 The system function\n\n### See also\n\n|                                                                                                                         |     |\n|-------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/utility/program/system \"cpp/utility/program/system\") for `system` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/system](https://en.cppreference.com/w/c/program/system)"
- name: tan
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# tan, tanf, tanl\n\n[TABLE]\n\n1-6) Computes the tangent of `arg` (measured in radians).\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`tanl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`tan`) is called. Otherwise, (1) (`tanf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ctanf`](../complex/ctan \"c/numeric/complex/ctan\"), [`ctan`](../complex/ctan \"c/numeric/complex/ctan\"), [`ctanl`](../complex/ctan \"c/numeric/complex/ctan\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                    |\n|-----|-----|----------------------------------------------------|\n| arg | \\-  | floating-point value representing angle in radians |\n\n### Return value\n\nIf no errors occur, the tangent of `arg` (tan(arg)) is returned.\n\n|                                                                                   |             |\n|-----------------------------------------------------------------------------------|-------------|\n| The result may have little or no significance if the magnitude of `arg` is large. | (until C99) |\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nThe case where the argument is infinite is not specified to be a domain error in C, but it is defined as a [domain error in POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html).\n\nThe function has mathematical poles at π(1/2 + n); however no common floating-point representation is able to represent `π/2` exactly, thus there is no value of the argument for which a pole error occurs.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"tan(pi*1/4) = %+f\\n\", tan(pi * 1 / 4)); //   45 deg\n    printf(\"tan(pi*3/4) = %+f\\n\", tan(pi * 3 / 4)); //  135 deg\n    printf(\"tan(pi*5/4) = %+f\\n\", tan(pi * 5 / 4)); // -135 deg\n    printf(\"tan(pi*7/4) = %+f\\n\", tan(pi * 7 / 4)); //  -45 deg\n \n    // special values\n    printf(\"tan(+0) = %f\\n\", tan(0.0));\n    printf(\"tan(-0) = %f\\n\", tan(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"tan(INFINITY) = %f\\n\", tan(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ntan(pi*1/4) = +1.000000\ntan(pi*3/4) = -1.000000\ntan(pi*5/4) = +1.000000\ntan(pi*7/4) = -1.000000\ntan(+0) = 0.000000\ntan(-0) = -0.000000\ntan(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.7 The tan functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.7 The tan functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.7 The tan functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.7 The tan functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.7 The tan functions (p: 240)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.7 The tan functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.7 The tan functions (p: 220)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.7 The tan functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.7 The tan function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/tan](https://en.cppreference.com/w/c/numeric/math/tan)"
- name: tanf
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# tan, tanf, tanl\n\n[TABLE]\n\n1-6) Computes the tangent of `arg` (measured in radians).\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`tanl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`tan`) is called. Otherwise, (1) (`tanf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ctanf`](../complex/ctan \"c/numeric/complex/ctan\"), [`ctan`](../complex/ctan \"c/numeric/complex/ctan\"), [`ctanl`](../complex/ctan \"c/numeric/complex/ctan\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                    |\n|-----|-----|----------------------------------------------------|\n| arg | \\-  | floating-point value representing angle in radians |\n\n### Return value\n\nIf no errors occur, the tangent of `arg` (tan(arg)) is returned.\n\n|                                                                                   |             |\n|-----------------------------------------------------------------------------------|-------------|\n| The result may have little or no significance if the magnitude of `arg` is large. | (until C99) |\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nThe case where the argument is infinite is not specified to be a domain error in C, but it is defined as a [domain error in POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html).\n\nThe function has mathematical poles at π(1/2 + n); however no common floating-point representation is able to represent `π/2` exactly, thus there is no value of the argument for which a pole error occurs.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"tan(pi*1/4) = %+f\\n\", tan(pi * 1 / 4)); //   45 deg\n    printf(\"tan(pi*3/4) = %+f\\n\", tan(pi * 3 / 4)); //  135 deg\n    printf(\"tan(pi*5/4) = %+f\\n\", tan(pi * 5 / 4)); // -135 deg\n    printf(\"tan(pi*7/4) = %+f\\n\", tan(pi * 7 / 4)); //  -45 deg\n \n    // special values\n    printf(\"tan(+0) = %f\\n\", tan(0.0));\n    printf(\"tan(-0) = %f\\n\", tan(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"tan(INFINITY) = %f\\n\", tan(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ntan(pi*1/4) = +1.000000\ntan(pi*3/4) = -1.000000\ntan(pi*5/4) = +1.000000\ntan(pi*7/4) = -1.000000\ntan(+0) = 0.000000\ntan(-0) = -0.000000\ntan(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.7 The tan functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.7 The tan functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.7 The tan functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.7 The tan functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.7 The tan functions (p: 240)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.7 The tan functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.7 The tan functions (p: 220)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.7 The tan functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.7 The tan function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/tan](https://en.cppreference.com/w/c/numeric/math/tan)"
- name: tanh
  summary: If a range error occurs due to underflow, the correct result (after rounding) is returned
  description: "# tanh, tanhf, tanhl\n\n[TABLE]\n\n1-3) Computes the hyperbolic tangent of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `tanhl` is called. Otherwise, if the argument has integer type or the type `double`, `tanh` is called. Otherwise, `tanhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ctanhf`](http://en.cppreference.com/w/c/numeric/complex/ctanh), [`ctanh`](http://en.cppreference.com/w/c/numeric/complex/ctanh), [`ctanhl`](http://en.cppreference.com/w/c/numeric/complex/ctanh)).\n\n### Parameters\n\n|     |     |                                                      |\n|-----|-----|------------------------------------------------------|\n| arg | \\-  | floating point value representing a hyperbolic angle |\n\n### Return value\n\nIf no errors occur, the hyperbolic tangent of `arg` (tanh(arg), or earg-e-arg/earg+e-arg) is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0, ±0 is returned\n- If the argument is ±∞, ±1 is returned\n- if the argument is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tanh.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"tanh(1) = %f\\ntanh(-1) = %f\\n\", tanh(1), tanh(-1));\n    printf(\"tanh(0.1)*sinh(0.2)-cosh(0.2) = %f\\n\", tanh(0.1) * sinh(0.2) - cosh(0.2));\n    // special values\n    printf(\"tanh(+0) = %f\\ntanh(-0) = %f\\n\", tanh(0.0), tanh(-0.0));\n}\n```\n\nOutput:\n\n```\ntanh(1) = 0.761594\ntanh(-1) = -0.761594\ntanh(0.1)*sinh(0.2)-cosh(0.2) = -1.000000\ntanh(+0) = 0.000000\ntanh(-0) = -0.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.6 The tanh functions (p: 242)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.6 The tanh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.6 The tanh functions (p: 222-223)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.6 The tanh functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.3.3 The tanh function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/tanh](https://en.cppreference.com/w/c/numeric/math/tanh)"
- name: tanhf
  summary: If a range error occurs due to underflow, the correct result (after rounding) is returned
  description: "# tanh, tanhf, tanhl\n\n[TABLE]\n\n1-3) Computes the hyperbolic tangent of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `tanhl` is called. Otherwise, if the argument has integer type or the type `double`, `tanh` is called. Otherwise, `tanhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ctanhf`](http://en.cppreference.com/w/c/numeric/complex/ctanh), [`ctanh`](http://en.cppreference.com/w/c/numeric/complex/ctanh), [`ctanhl`](http://en.cppreference.com/w/c/numeric/complex/ctanh)).\n\n### Parameters\n\n|     |     |                                                      |\n|-----|-----|------------------------------------------------------|\n| arg | \\-  | floating point value representing a hyperbolic angle |\n\n### Return value\n\nIf no errors occur, the hyperbolic tangent of `arg` (tanh(arg), or earg-e-arg/earg+e-arg) is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0, ±0 is returned\n- If the argument is ±∞, ±1 is returned\n- if the argument is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tanh.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"tanh(1) = %f\\ntanh(-1) = %f\\n\", tanh(1), tanh(-1));\n    printf(\"tanh(0.1)*sinh(0.2)-cosh(0.2) = %f\\n\", tanh(0.1) * sinh(0.2) - cosh(0.2));\n    // special values\n    printf(\"tanh(+0) = %f\\ntanh(-0) = %f\\n\", tanh(0.0), tanh(-0.0));\n}\n```\n\nOutput:\n\n```\ntanh(1) = 0.761594\ntanh(-1) = -0.761594\ntanh(0.1)*sinh(0.2)-cosh(0.2) = -1.000000\ntanh(+0) = 0.000000\ntanh(-0) = -0.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.6 The tanh functions (p: 242)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.6 The tanh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.6 The tanh functions (p: 222-223)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.6 The tanh functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.3.3 The tanh function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/tanh](https://en.cppreference.com/w/c/numeric/math/tanh)"
- name: tanhl
  summary: If a range error occurs due to underflow, the correct result (after rounding) is returned
  description: "# tanh, tanhf, tanhl\n\n[TABLE]\n\n1-3) Computes the hyperbolic tangent of `arg`.\n\n4) Type-generic macro: If the argument has type `long double`, `tanhl` is called. Otherwise, if the argument has integer type or the type `double`, `tanh` is called. Otherwise, `tanhf` is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ctanhf`](http://en.cppreference.com/w/c/numeric/complex/ctanh), [`ctanh`](http://en.cppreference.com/w/c/numeric/complex/ctanh), [`ctanhl`](http://en.cppreference.com/w/c/numeric/complex/ctanh)).\n\n### Parameters\n\n|     |     |                                                      |\n|-----|-----|------------------------------------------------------|\n| arg | \\-  | floating point value representing a hyperbolic angle |\n\n### Return value\n\nIf no errors occur, the hyperbolic tangent of `arg` (tanh(arg), or earg-e-arg/earg+e-arg) is returned.\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- if the argument is ±0, ±0 is returned\n- If the argument is ±∞, ±1 is returned\n- if the argument is NaN, NaN is returned\n\n### Notes\n\n[POSIX specifies](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tanh.html) that in case of underflow, `arg` is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n \nint main(void)\n{\n    printf(\"tanh(1) = %f\\ntanh(-1) = %f\\n\", tanh(1), tanh(-1));\n    printf(\"tanh(0.1)*sinh(0.2)-cosh(0.2) = %f\\n\", tanh(0.1) * sinh(0.2) - cosh(0.2));\n    // special values\n    printf(\"tanh(+0) = %f\\ntanh(-0) = %f\\n\", tanh(0.0), tanh(-0.0));\n}\n```\n\nOutput:\n\n```\ntanh(1) = 0.761594\ntanh(-1) = -0.761594\ntanh(0.1)*sinh(0.2)-cosh(0.2) = -1.000000\ntanh(+0) = 0.000000\ntanh(-0) = -0.000000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.5.6 The tanh functions (p: 242)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.2.6 The tanh functions (p: 520)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.5.6 The tanh functions (p: 222-223)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.2.6 The tanh functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.3.3 The tanh function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/tanh](https://en.cppreference.com/w/c/numeric/math/tanh)"
- name: tanl
  summary: The functions (4-6) are declared if and only if the implementation predefines __STDC_IEC_60559_DFP__ (i.e
  description: "# tan, tanf, tanl\n\n[TABLE]\n\n1-6) Computes the tangent of `arg` (measured in radians).\n\n7) Type-generic macro: If the argument has type `long double`, (3) (`tanl`) is called. Otherwise, if the argument has integer type or the type `double`, (2) (`tan`) is called. Otherwise, (1) (`tanf`) is called. If the argument is complex, then the macro invokes the corresponding complex function ([`ctanf`](../complex/ctan \"c/numeric/complex/ctan\"), [`ctan`](../complex/ctan \"c/numeric/complex/ctan\"), [`ctanl`](../complex/ctan \"c/numeric/complex/ctan\")).\n\n|                                                                                                                                                                           |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| The functions (4-6) are declared if and only if the implementation predefines `__STDC_IEC_60559_DFP__` (i.e. the implementation supports decimal floating-point numbers). | (since C23) |\n\n### Parameters\n\n|     |     |                                                    |\n|-----|-----|----------------------------------------------------|\n| arg | \\-  | floating-point value representing angle in radians |\n\n### Return value\n\nIf no errors occur, the tangent of `arg` (tan(arg)) is returned.\n\n|                                                                                   |             |\n|-----------------------------------------------------------------------------------|-------------|\n| The result may have little or no significance if the magnitude of `arg` is large. | (until C99) |\n\nIf a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nIf a range error occurs due to underflow, the correct result (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- if the argument is ±0, it is returned unmodified;\n- if the argument is ±∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised;\n- if the argument is NaN, NaN is returned.\n\n### Notes\n\nThe case where the argument is infinite is not specified to be a domain error in C, but it is defined as a [domain error in POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html).\n\nThe function has mathematical poles at π(1/2 + n); however no common floating-point representation is able to represent `π/2` exactly, thus there is no value of the argument for which a pole error occurs.\n\n### Example\n\n```\n#include <errno.h>\n#include <fenv.h>\n#include <math.h>\n#include <stdio.h>\n \n#ifndef __GNUC__\n#pragma STDC FENV_ACCESS ON\n#endif\n \nint main(void)\n{\n    const double pi = acos(-1);\n \n    // typical usage\n    printf(\"tan(pi*1/4) = %+f\\n\", tan(pi * 1 / 4)); //   45 deg\n    printf(\"tan(pi*3/4) = %+f\\n\", tan(pi * 3 / 4)); //  135 deg\n    printf(\"tan(pi*5/4) = %+f\\n\", tan(pi * 5 / 4)); // -135 deg\n    printf(\"tan(pi*7/4) = %+f\\n\", tan(pi * 7 / 4)); //  -45 deg\n \n    // special values\n    printf(\"tan(+0) = %f\\n\", tan(0.0));\n    printf(\"tan(-0) = %f\\n\", tan(-0.0));\n \n    // error handling\n    feclearexcept(FE_ALL_EXCEPT);\n    printf(\"tan(INFINITY) = %f\\n\", tan(INFINITY));\n    if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ntan(pi*1/4) = +1.000000\ntan(pi*3/4) = -1.000000\ntan(pi*5/4) = +1.000000\ntan(pi*7/4) = -1.000000\ntan(+0) = 0.000000\ntan(-0) = -0.000000\ntan(INFINITY) = -nan\n    FE_INVALID raised\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.12.4.7 The tan functions (p: TBD)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: TBD)\n  - F.10.1.7 The tan functions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.12.4.7 The tan functions (p: 175)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n  - F.10.1.7 The tan functions (p: 378)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.4.7 The tan functions (p: 240)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.1.7 The tan functions (p: 519)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.4.7 The tan functions (p: 220)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.1.7 The tan functions (p: 457)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.5.2.7 The tan function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/tan](https://en.cppreference.com/w/c/numeric/math/tan)"
- name: tgamma
  summary: If no errors occur, the value of the gamma function of arg, that is \(\Gamma(\mathtt{arg}) = \displaystyle\int_0^\infty\!\! t^{\mathtt{arg}-1} e^{-t}\, dt\)∫∞0targ-1 e-t dt, is returned
  description: "# tgamma, tgammaf, tgammal\n\n[TABLE]\n\n1-3) Computes the [gamma function](https://en.wikipedia.org/wiki/Gamma_function \"enwiki:Gamma function\") of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `tgammal` is called. Otherwise, if `arg` has integer type or the type `double`, `tgamma` is called. Otherwise, `tgammaf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the value of the gamma function of `arg`, that is \\\\\\Gamma(\\mathtt{arg}) = \\displaystyle\\int_0^\\infty\\\\\\\\ t^{\\mathtt{arg}-1} e^{-t}\\\\ dt\\\\∫_(∞0)*t*^(arg-1) *e*^(-t) d*t*, is returned.\n\nIf a domain error occurs, an implementation-defined value (NaN where supported) is returned.\n\nIf a pole error occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct value (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf `arg` is zero or is an integer less than zero, a pole error or a domain error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- If the argument is ±0, ±∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is a negative integer, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is -∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned.\n- If the argument is NaN, NaN is returned.\n\n### Notes\n\nIf `arg` is a natural number, `tgamma(arg)` is the factorial of `arg - 1`. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.\n\nFor IEEE-compatible type `double`, overflow happens if `0`` ``<`` x ``<`` ``1``/`[`DBL_MAX`](http://en.cppreference.com/w/c/types/limits) or if `x > 171.7`.\n\n[POSIX requires](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tgamma.html) that a pole error occurs if the argument is zero, but a domain error occurs when the argument is a negative integer. It also specifies that in future, domain errors may be replaced by pole errors for negative integer arguments (in which case the return value in those cases would change from NaN to ±∞).\n\nThere is a non-standard function named `gamma` in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of `gamma` executes `lgamma`, but 4.4BSD version of `gamma` executes `tgamma`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"tgamma(10) = %f, 9!=%f\\n\", tgamma(10), 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);\n    printf(\"tgamma(0.5) = %f, sqrt(pi) = %f\\n\", tgamma(0.5), sqrt(acos(-1)));\n \n    // special values\n    printf(\"tgamma(+Inf) = %f\\n\", tgamma(INFINITY));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"tgamma(-1) = %f\\n\", tgamma(-1));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    else\n        if (errno == EDOM)   perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_DIVBYZERO))\n        puts(\"    FE_DIVBYZERO raised\");\n    else if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ntgamma(10) = 362880.000000, 9!=362880.000000\ntgamma(0.5) = 1.772454, sqrt(pi) = 1.772454\ntgamma(+Inf) = inf\ntgamma(-1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.4 The tgamma functions (p: 250)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.4 The tgamma functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.4 The tgamma functions (p: 231)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.4 The tgamma functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                   |\n|-----------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Gamma Function.\"](https://mathworld.wolfram.com/GammaFunction.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/tgamma](https://en.cppreference.com/w/c/numeric/math/tgamma)"
- name: tgammaf
  summary: If no errors occur, the value of the gamma function of arg, that is \(\Gamma(\mathtt{arg}) = \displaystyle\int_0^\infty\!\! t^{\mathtt{arg}-1} e^{-t}\, dt\)∫∞0targ-1 e-t dt, is returned
  description: "# tgamma, tgammaf, tgammal\n\n[TABLE]\n\n1-3) Computes the [gamma function](https://en.wikipedia.org/wiki/Gamma_function \"enwiki:Gamma function\") of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `tgammal` is called. Otherwise, if `arg` has integer type or the type `double`, `tgamma` is called. Otherwise, `tgammaf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the value of the gamma function of `arg`, that is \\\\\\Gamma(\\mathtt{arg}) = \\displaystyle\\int_0^\\infty\\\\\\\\ t^{\\mathtt{arg}-1} e^{-t}\\\\ dt\\\\∫_(∞0)*t*^(arg-1) *e*^(-t) d*t*, is returned.\n\nIf a domain error occurs, an implementation-defined value (NaN where supported) is returned.\n\nIf a pole error occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct value (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf `arg` is zero or is an integer less than zero, a pole error or a domain error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- If the argument is ±0, ±∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is a negative integer, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is -∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned.\n- If the argument is NaN, NaN is returned.\n\n### Notes\n\nIf `arg` is a natural number, `tgamma(arg)` is the factorial of `arg - 1`. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.\n\nFor IEEE-compatible type `double`, overflow happens if `0`` ``<`` x ``<`` ``1``/`[`DBL_MAX`](http://en.cppreference.com/w/c/types/limits) or if `x > 171.7`.\n\n[POSIX requires](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tgamma.html) that a pole error occurs if the argument is zero, but a domain error occurs when the argument is a negative integer. It also specifies that in future, domain errors may be replaced by pole errors for negative integer arguments (in which case the return value in those cases would change from NaN to ±∞).\n\nThere is a non-standard function named `gamma` in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of `gamma` executes `lgamma`, but 4.4BSD version of `gamma` executes `tgamma`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"tgamma(10) = %f, 9!=%f\\n\", tgamma(10), 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);\n    printf(\"tgamma(0.5) = %f, sqrt(pi) = %f\\n\", tgamma(0.5), sqrt(acos(-1)));\n \n    // special values\n    printf(\"tgamma(+Inf) = %f\\n\", tgamma(INFINITY));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"tgamma(-1) = %f\\n\", tgamma(-1));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    else\n        if (errno == EDOM)   perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_DIVBYZERO))\n        puts(\"    FE_DIVBYZERO raised\");\n    else if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ntgamma(10) = 362880.000000, 9!=362880.000000\ntgamma(0.5) = 1.772454, sqrt(pi) = 1.772454\ntgamma(+Inf) = inf\ntgamma(-1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.4 The tgamma functions (p: 250)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.4 The tgamma functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.4 The tgamma functions (p: 231)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.4 The tgamma functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                   |\n|-----------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Gamma Function.\"](https://mathworld.wolfram.com/GammaFunction.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/tgamma](https://en.cppreference.com/w/c/numeric/math/tgamma)"
- name: tgammal
  summary: If no errors occur, the value of the gamma function of arg, that is \(\Gamma(\mathtt{arg}) = \displaystyle\int_0^\infty\!\! t^{\mathtt{arg}-1} e^{-t}\, dt\)∫∞0targ-1 e-t dt, is returned
  description: "# tgamma, tgammaf, tgammal\n\n[TABLE]\n\n1-3) Computes the [gamma function](https://en.wikipedia.org/wiki/Gamma_function \"enwiki:Gamma function\") of `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `tgammal` is called. Otherwise, if `arg` has integer type or the type `double`, `tgamma` is called. Otherwise, `tgammaf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the value of the gamma function of `arg`, that is \\\\\\Gamma(\\mathtt{arg}) = \\displaystyle\\int_0^\\infty\\\\\\\\ t^{\\mathtt{arg}-1} e^{-t}\\\\ dt\\\\∫_(∞0)*t*^(arg-1) *e*^(-t) d*t*, is returned.\n\nIf a domain error occurs, an implementation-defined value (NaN where supported) is returned.\n\nIf a pole error occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to overflow occurs, [`±HUGE_VAL`](huge_val \"c/numeric/math/HUGE VAL\"), `±HUGE_VALF`, or `±HUGE_VALL` is returned.\n\nIf a range error due to underflow occurs, the correct value (after rounding) is returned.\n\n### Error handling\n\nErrors are reported as specified in [`math_errhandling`](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf `arg` is zero or is an integer less than zero, a pole error or a domain error may occur.\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559):\n\n- If the argument is ±0, ±∞ is returned and [`FE_DIVBYZERO`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is a negative integer, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is -∞, NaN is returned and [`FE_INVALID`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") is raised.\n- If the argument is +∞, +∞ is returned.\n- If the argument is NaN, NaN is returned.\n\n### Notes\n\nIf `arg` is a natural number, `tgamma(arg)` is the factorial of `arg - 1`. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.\n\nFor IEEE-compatible type `double`, overflow happens if `0`` ``<`` x ``<`` ``1``/`[`DBL_MAX`](http://en.cppreference.com/w/c/types/limits) or if `x > 171.7`.\n\n[POSIX requires](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tgamma.html) that a pole error occurs if the argument is zero, but a domain error occurs when the argument is a negative integer. It also specifies that in future, domain errors may be replaced by pole errors for negative integer arguments (in which case the return value in those cases would change from NaN to ±∞).\n\nThere is a non-standard function named `gamma` in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of `gamma` executes `lgamma`, but 4.4BSD version of `gamma` executes `tgamma`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <errno.h>\n#include <fenv.h>\n// #pragma STDC FENV_ACCESS ON\n \nint main(void)\n{\n    printf(\"tgamma(10) = %f, 9!=%f\\n\", tgamma(10), 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);\n    printf(\"tgamma(0.5) = %f, sqrt(pi) = %f\\n\", tgamma(0.5), sqrt(acos(-1)));\n \n    // special values\n    printf(\"tgamma(+Inf) = %f\\n\", tgamma(INFINITY));\n \n    // error handling\n    errno = 0; feclearexcept(FE_ALL_EXCEPT);\n    printf(\"tgamma(-1) = %f\\n\", tgamma(-1));\n    if (errno == ERANGE)\n        perror(\"    errno == ERANGE\");\n    else\n        if (errno == EDOM)   perror(\"    errno == EDOM\");\n    if (fetestexcept(FE_DIVBYZERO))\n        puts(\"    FE_DIVBYZERO raised\");\n    else if (fetestexcept(FE_INVALID))\n        puts(\"    FE_INVALID raised\");\n}\n```\n\nPossible output:\n\n```\ntgamma(10) = 362880.000000, 9!=362880.000000\ntgamma(0.5) = 1.772454, sqrt(pi) = 1.772454\ntgamma(+Inf) = inf\ntgamma(-1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.8.4 The tgamma functions (p: 250)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.5.4 The tgamma functions (p: 525)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.8.4 The tgamma functions (p: 231)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.5.4 The tgamma functions (p: 462)\n\n### See also\n\n[TABLE]\n\n### External links\n\n|                                                                                                                                   |\n|-----------------------------------------------------------------------------------------------------------------------------------|\n| [Weisstein, Eric W. \"Gamma Function.\"](https://mathworld.wolfram.com/GammaFunction.html) From MathWorld — A Wolfram Web Resource. |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/tgamma](https://en.cppreference.com/w/c/numeric/math/tgamma)"
- name: thrd_busy
  summary: Identifiers for thread states and errors
  description: "# thrd_success, thrd_timedout, thrd_busy, thrd_nomem, thrd_error\n\n[TABLE]\n\nIdentifiers for thread states and errors.\n\n| Constant        | Explanation                                                               |\n|-----------------|---------------------------------------------------------------------------|\n| `thrd_success`  | indicates successful return value                                         |\n| `thrd_nomem`    | indicates unsuccessful return value due to out of memory condition        |\n| `thrd_timedout` | indicates timed out return value                                          |\n| `thrd_busy`     | indicates unsuccessful return value due to resource temporary unavailable |\n| `thrd_error`    | indicates unsuccessful return value                                       |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.1/5 thrd_success, thrd_timedout, ... (p: 275)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.1/5 thrd_success, thrd_timedout, ... (p: 377)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_errors](https://en.cppreference.com/w/c/thread/thrd_errors)"
- name: thrd_create
  summary: Creates a new thread executing the function func
  description: "# thrd_create\n\n[TABLE]\n\nCreates a new thread executing the function `func`. The function is invoked as `func(arg)`.\n\nIf successful, the object pointed to by `thr` is set to the identifier of the new thread.\n\nThe completion of this function *synchronizes-with* the beginning of the thread.\n\n### Parameters\n\n|      |     |                                                                    |\n|------|-----|--------------------------------------------------------------------|\n| thr  | \\-  | pointer to memory location to put the identifier of the new thread |\n| func | \\-  | function to execute                                                |\n| arg  | \\-  | argument to pass to the function                                   |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if the creation of the new thread was successful. Otherwise returns [`thrd_nomem`](thrd_errors \"c/thread/thrd errors\") if there was insufficient amount of memory or [`thrd_error`](thrd_errors \"c/thread/thrd errors\") if another error occurred.\n\n### Notes\n\nThe thread identifiers may be reused for new threads once the thread has finished and joined or detached.\n\nThe type [`thrd_start_t`](../thread \"c/thread\") is a typedef of `int(*)(void*)`, which differs from the POSIX equivalent `void*(*)(void*)`\n\nAll thread-specific storage values (see [`tss_create`](tss_create \"c/thread/tss create\")) are initialized to [`NULL`](../types/null \"c/types/NULL\").\n\nReturn from the function `func` is equivalent to calling [`thrd_exit`](thrd_exit \"c/thread/thrd exit\") with the argument equal to the return value of `func`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.5.1 The thrd_create function (p: 279)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.5.1 The thrd_create function (p: 383)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_create](https://en.cppreference.com/w/c/thread/thrd_create)"
- name: thrd_current
  summary: Returns the identifier of the calling thread
  description: "# thrd_current\n\n[TABLE]\n\nReturns the identifier of the calling thread.\n\n### Parameters\n\n(none)\n\n### Return value\n\nThe identifier of the calling thread.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.5.2 The thrd_current function (p: 279)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.5.2 The thrd_current function (p: 383)\n\n### See also\n\n|                                                                                                       |     |\n|-------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/get_id \"cpp/thread/get id\") for `get_id` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_current](https://en.cppreference.com/w/c/thread/thrd_current)"
- name: thrd_detach
  summary: Detaches the thread identified by thr from the current environment
  description: "# thrd_detach\n\n[TABLE]\n\nDetaches the thread identified by `thr` from the current environment. The resources held by the thread will be freed automatically once the thread exits.\n\n### Parameters\n\n|     |     |                                    |\n|-----|-----|------------------------------------|\n| thr | \\-  | identifier of the thread to detach |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") otherwise.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.5.3 The thrd_detach function (p: 280)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.5.3 The thrd_detach function (p: 383-384)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_detach](https://en.cppreference.com/w/c/thread/thrd_detach)"
- name: thrd_equal
  summary: Checks whether lhs and rhs refer to the same thread
  description: "# thrd_equal\n\n[TABLE]\n\nChecks whether `lhs` and `rhs` refer to the same thread.\n\n### Parameters\n\n|          |     |                    |\n|----------|-----|--------------------|\n| lhs, rhs | \\-  | threads to compare |\n\n### Return value\n\nNon-zero value if `lhs` and `rhs` refer to the same value, `​0​` otherwise.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.5.4 The thrd_equal function (p: 280)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.5.4 The thrd_equal function (p: 384)\n\n### See also\n\n|                                                                                                                                             |     |\n|---------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/thread/thread/id/operator_cmp \"cpp/thread/thread/id/operator cmp\") for `operator_cmp` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_equal](https://en.cppreference.com/w/c/thread/thrd_equal)"
- name: thrd_error
  summary: Identifiers for thread states and errors
  description: "# thrd_success, thrd_timedout, thrd_busy, thrd_nomem, thrd_error\n\n[TABLE]\n\nIdentifiers for thread states and errors.\n\n| Constant        | Explanation                                                               |\n|-----------------|---------------------------------------------------------------------------|\n| `thrd_success`  | indicates successful return value                                         |\n| `thrd_nomem`    | indicates unsuccessful return value due to out of memory condition        |\n| `thrd_timedout` | indicates timed out return value                                          |\n| `thrd_busy`     | indicates unsuccessful return value due to resource temporary unavailable |\n| `thrd_error`    | indicates unsuccessful return value                                       |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.1/5 thrd_success, thrd_timedout, ... (p: 275)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.1/5 thrd_success, thrd_timedout, ... (p: 377)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_errors](https://en.cppreference.com/w/c/thread/thrd_errors)"
- name: thrd_exit
  summary: First, for every thread-specific storage key which was created with a non-null destructor and for which the associated value is non-null (see tss_create), thrd_exit sets the value associated with the key to NULL and then invokes the destructor with the previous value of the key
  description: "# thrd_exit\n\n[TABLE]\n\nFirst, for every thread-specific storage key which was created with a non-null destructor and for which the associated value is non-null (see [`tss_create`](tss_create \"c/thread/tss create\")), `thrd_exit` sets the value associated with the key to [`NULL`](http://en.cppreference.com/w/c/types/NULL) and then invokes the destructor with the previous value of the key. The order in which the destructors are invoked is unspecified.\n\nIf, after this, there remain keys with both non-null destructors and values (e.g. if a destructor executed [`tss_set`](tss_set \"c/thread/tss set\")), the process is repeated up to [`TSS_DTOR_ITERATIONS`](tss_dtor_iterations \"c/thread/TSS DTOR ITERATIONS\") times.\n\nFinally, the `thrd_exit` function terminates execution of the calling thread and sets its result code to `res`.\n\nIf the last thread in the program is terminated with `thrd_exit`, the entire program terminates as if by calling [`exit`](../program/exit \"c/program/exit\") with [`EXIT_SUCCESS`](../program/exit_status \"c/program/EXIT status\") as the argument (so the functions registered by [`atexit`](../program/atexit \"c/program/atexit\") are executed in the context of that last thread)\n\n### Parameters\n\n|     |     |                            |\n|-----|-----|----------------------------|\n| res | \\-  | the result value to return |\n\n### Return value\n\n(none)\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.5.5 The thrd_exit function (p: 280)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.5.5 The thrd_exit function (p: 384)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_exit](https://en.cppreference.com/w/c/thread/thrd_exit)"
- name: thrd_join
  summary: Blocks the current thread until the thread identified by thr finishes execution
  description: "# thrd_join\n\n[TABLE]\n\nBlocks the current thread until the thread identified by `thr` finishes execution.\n\nIf `res` is not a null pointer, the result code of the thread is put to the location pointed to by `res`.\n\nThe termination of the thread *synchronizes-with* the completion of this function.\n\nThe behavior is undefined if the thread was previously detached or joined by another thread.\n\n### Parameters\n\n|     |     |                                    |\n|-----|-----|------------------------------------|\n| thr | \\-  | identifier of the thread to join   |\n| res | \\-  | location to put the result code to |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") otherwise.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.5.6 The thrd_join function (p: 280-281)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.5.6 The thrd_join function (p: 384-385)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_join](https://en.cppreference.com/w/c/thread/thrd_join)"
- name: thrd_nomem
  summary: Identifiers for thread states and errors
  description: "# thrd_success, thrd_timedout, thrd_busy, thrd_nomem, thrd_error\n\n[TABLE]\n\nIdentifiers for thread states and errors.\n\n| Constant        | Explanation                                                               |\n|-----------------|---------------------------------------------------------------------------|\n| `thrd_success`  | indicates successful return value                                         |\n| `thrd_nomem`    | indicates unsuccessful return value due to out of memory condition        |\n| `thrd_timedout` | indicates timed out return value                                          |\n| `thrd_busy`     | indicates unsuccessful return value due to resource temporary unavailable |\n| `thrd_error`    | indicates unsuccessful return value                                       |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.1/5 thrd_success, thrd_timedout, ... (p: 275)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.1/5 thrd_success, thrd_timedout, ... (p: 377)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_errors](https://en.cppreference.com/w/c/thread/thrd_errors)"
- name: thrd_sleep
  summary: Blocks the execution of the current thread for at least until the TIME_UTC based duration pointed to by duration has elapsed
  description: "# thrd_sleep\n\n[TABLE]\n\nBlocks the execution of the current thread for *at least* until the `TIME_UTC` based duration pointed to by `duration` has elapsed.\n\nThe sleep may resume earlier if a [`signal`](../program/signal \"c/program/signal\") that is not ignored is received. In such case, if `remaining` is not [`NULL`](../types/null \"c/types/NULL\"), the remaining time duration is stored into the object pointed to by `remaining`.\n\n### Parameters\n\n|           |     |                                                                                                                                             |\n|-----------|-----|---------------------------------------------------------------------------------------------------------------------------------------------|\n| duration  | \\-  | pointer to the duration to sleep for                                                                                                        |\n| remaining | \\-  | pointer to the object to put the remaining time on interruption. May be [`NULL`](../types/null \"c/types/NULL\"), in which case it is ignored |\n\n### Return value\n\n`​0​` on successful sleep, `-1` if a signal occurred, other negative value if an error occurred.\n\n### Notes\n\n`duration` and `remaining` may point at the same object, which simplifies re-running the function after a signal.\n\nThe actual sleep time may be longer than requested because it is rounded up to the timer granularity and because of scheduling and context switching overhead.\n\nThe POSIX equivalent of this function is [`nanosleep`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/nanosleep.html).\n\n### Example\n\n```\n#include <threads.h>\n#include <time.h>\n#include <stdio.h>\n \nint main(void)\n{\n    printf(\"Time: %s\", ctime(&(time_t){time(NULL)}));\n    thrd_sleep(&(struct timespec){.tv_sec=1}, NULL); // sleep 1 sec\n    printf(\"Time: %s\", ctime(&(time_t){time(NULL)}));\n}\n```\n\nOutput:\n\n```\nTime: Mon Feb  2 16:18:41 2015\nTime: Mon Feb  2 16:18:42 2015\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.5.7 The thrd_sleep function (p: 281)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.5.7 The thrd_sleep function (p: 385)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_sleep](https://en.cppreference.com/w/c/thread/thrd_sleep)"
- name: thrd_success
  summary: Identifiers for thread states and errors
  description: "# thrd_success, thrd_timedout, thrd_busy, thrd_nomem, thrd_error\n\n[TABLE]\n\nIdentifiers for thread states and errors.\n\n| Constant        | Explanation                                                               |\n|-----------------|---------------------------------------------------------------------------|\n| `thrd_success`  | indicates successful return value                                         |\n| `thrd_nomem`    | indicates unsuccessful return value due to out of memory condition        |\n| `thrd_timedout` | indicates timed out return value                                          |\n| `thrd_busy`     | indicates unsuccessful return value due to resource temporary unavailable |\n| `thrd_error`    | indicates unsuccessful return value                                       |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.1/5 thrd_success, thrd_timedout, ... (p: 275)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.1/5 thrd_success, thrd_timedout, ... (p: 377)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_errors](https://en.cppreference.com/w/c/thread/thrd_errors)"
- name: thrd_timedout
  summary: Identifiers for thread states and errors
  description: "# thrd_success, thrd_timedout, thrd_busy, thrd_nomem, thrd_error\n\n[TABLE]\n\nIdentifiers for thread states and errors.\n\n| Constant        | Explanation                                                               |\n|-----------------|---------------------------------------------------------------------------|\n| `thrd_success`  | indicates successful return value                                         |\n| `thrd_nomem`    | indicates unsuccessful return value due to out of memory condition        |\n| `thrd_timedout` | indicates timed out return value                                          |\n| `thrd_busy`     | indicates unsuccessful return value due to resource temporary unavailable |\n| `thrd_error`    | indicates unsuccessful return value                                       |\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.1/5 thrd_success, thrd_timedout, ... (p: 275)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.1/5 thrd_success, thrd_timedout, ... (p: 377)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_errors](https://en.cppreference.com/w/c/thread/thrd_errors)"
- name: thrd_yield
  summary: Provides a hint to the implementation to reschedule the execution of threads, allowing other threads to run
  description: "# thrd_yield\n\n[TABLE]\n\nProvides a hint to the implementation to reschedule the execution of threads, allowing other threads to run.\n\n### Parameters\n\n(none)\n\n### Return value\n\n(none)\n\n### Notes\n\nThe exact behavior of this function depends on the implementation, in particular on the mechanics of the OS scheduler in use and the state of the system. For example, a first-in-first-out realtime scheduler (`SCHED_FIFO` in Linux) would suspend the current thread and put it on the back of the queue of the same-priority threads that are ready to run (and if there are no other threads at the same priority, `yield` has no effect).\n\nThe POSIX equivalent of this function is [`sched_yield`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_yield.html).\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <threads.h>\n \n// utility function: difference between timespecs in microseconds\ndouble usdiff(struct timespec s, struct timespec e)\n{\n    double sdiff = difftime(e.tv_sec, s.tv_sec);\n    long nsdiff = e.tv_nsec - s.tv_nsec;\n    if(nsdiff < 0) return 1000000*(sdiff-1) + (1000000000L+nsdiff)/1000.0;\n    else return 1000000*(sdiff) + nsdiff/1000.0;\n}\n \n// busy wait while yielding\nvoid sleep_100us()\n{\n    struct timespec start, end;\n    timespec_get(&start, TIME_UTC);\n    do {\n        thrd_yield();\n        timespec_get(&end, TIME_UTC);\n    } while(usdiff(start, end) < 100.0);\n}\n \nint main()\n{\n    struct timespec start, end;\n    timespec_get(&start, TIME_UTC);\n    sleep_100us();\n    timespec_get(&end, TIME_UTC);\n    printf(\"Waited for %.3f us\\n\", usdiff(start, end));\n}\n```\n\nPossible output:\n\n```\nWaited for 100.344 us\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.5.8 The thrd_yield function (p: 281)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.5.8 The thrd_yield function (p: 385)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thrd_yield](https://en.cppreference.com/w/c/thread/thrd_yield)"
- name: Thread storage duration
  summary: An object whose identifier is declared with the storage-class specifier _Thread_local (since C11) has thread storage duration
  description: "# Thread storage duration\n\nAn object whose identifier is declared with the storage-class specifier `_Thread_local` (since C11) has thread storage duration. Its lifetime is the entire execution of the thread for which it is created, and its stored value is initialized when the thread is started. There is a distinct object per thread, and use of the declared name in an expression refers to the object associated with the thread evaluating the expression. The result of attempting to indirectly access an object with thread storage duration from a thread other than the one with which the object is associated is implementation-defined.\n\n### Example\n\n```\nconst double PI = 3.14159;         /* const variable is global to all threads  */\n_Thread_local unsigned int seed;   /* seed is a thread-specific variable       */\n \nint main(void)\n{\n    return 0;\n}\n```\n\nPossible output:\n\n```\n(none)\n```\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/thread_storage_duration](https://en.cppreference.com/w/c/language/thread_storage_duration)"
- name: thread_local
  summary: ''
  description: "# C keywords: thread_local (since C23)\n\n### Usage\n\n- [thread storage-class specifier](../language/storage_duration \"c/language/storage duration\") (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/thread_local](https://en.cppreference.com/w/c/keyword/thread_local)"
- name: thread_local
  summary: Convenience macro which can be used to specify that an object has thread-local storage duration
  description: "# thread_local\n\n[TABLE]\n\nConvenience macro which can be used to specify that an object has [thread-local storage duration](../language/storage_duration \"c/language/storage duration\").\n\n### Notes\n\nSince C23, `thread_local` is itself a keyword, which may also be a predefined macro, so `<threads.h>` no longer provides it.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.1/3 thread_local (p: 274)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.1/3 thread_local (p: 376)\n\n### See also\n\n|                                                                                                                           |     |\n|---------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/keyword/thread_local \"cpp/keyword/thread local\") for `thread_local` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/thread_local](https://en.cppreference.com/w/c/thread/thread_local)"
- name: time
  summary: Returns the current calendar time encoded as a time_t object, and also stores it in the time_t object pointed to by arg (unless arg is a null pointer)
  description: "# time\n\n[TABLE]\n\nReturns the current calendar time encoded as a [`time_t`](time_t \"c/chrono/time t\") object, and also stores it in the [`time_t`](time_t \"c/chrono/time t\") object pointed to by `arg` (unless `arg` is a null pointer)\n\n### Parameters\n\n|     |     |                                                                                                           |\n|-----|-----|-----------------------------------------------------------------------------------------------------------|\n| arg | \\-  | pointer to a [`time_t`](time_t \"c/chrono/time t\") object where the time will be stored, or a null pointer |\n\n### Return value\n\nCurrent calendar time encoded as [`time_t`](time_t \"c/chrono/time t\") object on success, `(`[`time_t`](http://en.cppreference.com/w/c/chrono/time_t)`)``(``-``1``)` on error. If `arg` is not a null pointer, the return value is also stored in the object pointed to by `arg`.\n\n### Notes\n\nThe encoding of calendar time in [`time_t`](time_t \"c/chrono/time t\") is unspecified, but most systems conform to [POSIX specification](http://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html) and return a value of integral type holding the number of seconds since [the Epoch](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15). Implementations in which [`time_t`](time_t \"c/chrono/time t\") is a 32-bit signed integer (many historical implementations) fail in the year [2038](http://en.wikipedia.org/wiki/Year_2038_problem).\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <stdint.h>\n \nint main(void)\n{\n    time_t result = time(NULL);\n    if(result != (time_t)(-1))\n        printf(\"The current time is %s(%jd seconds since the Epoch)\\n\",\n               asctime(gmtime(&result)), (intmax_t)result);\n}\n```\n\nPossible output:\n\n```\nThe current time is Fri Apr 24 15:05:25 2015\n(1429887925 seconds since the Epoch)\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.2.4 The time function (p: 286)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.2.4 The time function (p: 391)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.2.4 The time function (p: 341)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.2.4 The time function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/time](https://en.cppreference.com/w/c/chrono/time)"
- name: time_t
  summary: Real arithmetic type capable of representing times
  description: "# time_t\n\n[TABLE]\n\nReal arithmetic type capable of representing times.\n\nAlthough not defined by the C standard, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to [POSIX time](https://en.wikipedia.org/wiki/Unix_time \"enwiki:Unix time\").\n\n### Notes\n\nThe standard uses the term *calendar time* when referring to a value of type `time_t`.\n\n### Example\n\nShow the start of the epoch.\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <stdint.h>\n \nint main(void)\n{\n    time_t epoch = 0;\n    printf(\"%jd seconds since the epoch began\\n\", (intmax_t)epoch);\n    printf(\"%s\", asctime(gmtime(&epoch)));\n}\n```\n\nPossible output:\n\n```\n0 seconds since the epoch began\nThu Jan  1 00:00:00 1970\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.1/3 Components of time (p: 284)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.1/3 Components of time (p: 388)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.1/3 Components of time (p: 338)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.1 Components of time\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/time_t](https://en.cppreference.com/w/c/chrono/time_t)"
- name: timespec
  summary: Structure holding an interval broken down into seconds and nanoseconds
  description: "# timespec\n\n[TABLE]\n\nStructure holding an interval broken down into seconds and nanoseconds.\n\n### Member objects\n\n|                                               |                                                 |\n|-----------------------------------------------|-------------------------------------------------|\n| [`time_t`](time_t \"c/chrono/time t\") `tv_sec` | whole seconds (valid values are \\>= 0)          |\n| `/* see below */` `tv_nsec`                   | nanoseconds (valid values are \\[0, 999999999\\]) |\n\n|                                                                                                                         |             |\n|-------------------------------------------------------------------------------------------------------------------------|-------------|\n| The type of `tv_nsec` is `long`.                                                                                        | (until C23) |\n| The type of `tv_nsec` is an implementation-defined signed integer type that can represent integers in \\[0, 999999999\\]. | (since C23) |\n\nThe declaration order of `tv_sec` and `tv_nsec` is unspecified. Implementation may add other members to `struct timespec`.\n\n### Notes\n\nThe type of `tv_nsec` is `long long` on some platforms, which is conforming only since C23.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <stdint.h>\n \nint main(void)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char buff[100];\n    strftime(buff, sizeof buff, \"%D %T\", gmtime(&ts.tv_sec));\n    printf(\"Current time: %s.%09ld UTC\\n\", buff, ts.tv_nsec);\n    printf(\"Raw timespec.time_t: %jd\\n\", (intmax_t)ts.tv_sec);\n    printf(\"Raw timespec.tv_nsec: %09ld\\n\", ts.tv_nsec);\n}\n```\n\nPossible output:\n\n```\nCurrent time: 11/24/21 03:10:50.408191283 UTC\nRaw timespec.time_t: 1637723450\nRaw timespec.tv_nsec: 408191283\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.1/3 Components of time (p: 284)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.1/3 Components of time (p: 388)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/timespec](https://en.cppreference.com/w/c/chrono/timespec)"
- name: timespec_get
  summary: Other macro constants beginning with TIME_ may be provided by the implementation to indicate additional time bases
  description: "# timespec_get\n\n[TABLE]\n\n1) Modifies the `timespec` object pointed to by `ts` to hold the current calendar time in the time base `base`.\n\n2) Expands to a value suitable for use as the `base` argument of `timespec_get`\n\nOther macro constants beginning with `TIME_` may be provided by the implementation to indicate additional time bases\n\nIf `base` is `TIME_UTC`, then\n\n- `ts->tv_sec` is set to the number of seconds since an implementation defined epoch, truncated to a whole value\n- `ts->tv_nsec` member is set to the integral number of nanoseconds, rounded to the resolution of the system clock\n\n### Parameters\n\n|      |     |                                                                      |\n|------|-----|----------------------------------------------------------------------|\n| ts   | \\-  | pointer to an object of type `struct timespec`                       |\n| base | \\-  | `TIME_UTC` or another nonzero integer value indicating the time base |\n\n### Return value\n\nThe value of `base` if successful, zero otherwise.\n\n### Notes\n\nThe POSIX function [`clock_gettime(CLOCK_REALTIME, ts)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html) may also be used to populate a `timespec` with the time since the Epoch.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char buff[100];\n    strftime(buff, sizeof buff, \"%D %T\", gmtime(&ts.tv_sec));\n    printf(\"Current time: %s.%09ld UTC\\n\", buff, ts.tv_nsec);\n}\n```\n\nPossible output:\n\n```\nCurrent time: 02/18/15 14:34:03.048508855 UTC\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.2.5 The timespec_get function (p: 286)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.2.5 The timespec_get function (p: 390)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/timespec_get](https://en.cppreference.com/w/c/chrono/timespec_get)"
- name: timespec_getres
  summary: If ts is non-null and base is supported by timespec_get, modifies *ts to hold the resolution of time provided by timespec_get for base
  description: "# timespec_getres\n\n[TABLE]\n\nIf `ts` is non-null and `base` is supported by `timespec_get`, modifies `*ts` to hold the resolution of time provided by `timespec_get` for `base`. For each supported `base`, multiple calls to `timespec_getres` during the same program execution have identical results.\n\n### Parameters\n\n|      |     |                                                                      |\n|------|-----|----------------------------------------------------------------------|\n| ts   | \\-  | pointer to an object of type `struct timespec`                       |\n| base | \\-  | `TIME_UTC` or another nonzero integer value indicating the time base |\n\n### Return value\n\nThe value of `base` if `base` is supported, zero otherwise.\n\n### Notes\n\nThe POSIX function [`clock_getres(clock_id, ts)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html) may also be used to populate a `timespec` with the resolution of time identified by `clock_id`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    char buff[128];\n    struct timespec ts;\n    const int res = timespec_getres(&ts, TIME_UTC);\n    if (res == TIME_UTC) {\n        struct tm timer;\n        strftime(buff, sizeof buff, \"%D %T\", gmtime_r(&ts.tv_sec, &timer));\n        printf(\"Time resolution info: %s.%09ld UTC\\n\", buff, ts.tv_nsec);\n    } else {\n        printf(\"TIME_UTC base is not supported.\");\n    }\n}\n```\n\nPossible output:\n\n```\nTime resolution info: 01/01/70 00:00:00.000000001 UTC\n```\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/timespec_getres](https://en.cppreference.com/w/c/chrono/timespec_getres)"
- name: tm
  summary: Structure holding a calendar date and time broken down into its components
  description: "# tm\n\n[TABLE]\n\nStructure holding a calendar date and time broken down into its components.\n\n### Member objects\n\n[TABLE]\n\n###### Notes\n\nThe Standard mandates only the presence of the aforementioned members in either order. The implementations usually add more data-members to this structure.\n\n1.  Range allows for a positive leap second. Two leap seconds in the same minute are not allowed (the C89 range 0..61 was a defect)\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    struct tm start = {.tm_year=2022-1900, .tm_mday=1};\n    mktime(&start);\n    printf(\"%s\", asctime(&start));\n}\n```\n\nOutput:\n\n```\nSat Jan  1 00:00:00 2022\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.27.1/3 Components of time (p: 284)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.27.1/3 Components of time (p: 388)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.23.1/3 Components of time (p: 338)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.12.1 Components of time\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/tm](https://en.cppreference.com/w/c/chrono/tm)"
- name: tmpfile
  summary: The temporary file created by this function is closed and deleted when the program exits normally
  description: "# tmpfile, tmpfile_s\n\n[TABLE]\n\n1) Creates and opens a temporary file. The file is opened as binary file for update (as if by [`fopen`](fopen \"c/io/fopen\") with \"wb+\" mode). The filename of the file is guaranteed to be unique within the filesystem. At least [`TMP_MAX`](../io \"c/io\") files may be opened during the lifetime of a program (this limit may be shared with [`tmpnam`](tmpnam \"c/io/tmpnam\") and may be further limited by [`FOPEN_MAX`](../io \"c/io\")).\n\n2) Same as (1), except that at least `TMP_MAX_S` files may be opened (the limit may be shared with `tmpnam_s`), and if `streamptr` is a null pointer, the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function is called. As with all bounds-checked functions, `tmpfile_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\nThe temporary file created by this function is closed and deleted when the program exits normally. Whether it's deleted on abnormal termination is implementation-defined.\n\n### Parameters\n\n1) (none)\n\n2) pointer to a pointer that will be updated by this function call\n\n### Return value\n\n1) Pointer to the file stream associated with the file or null pointer if an error has occurred.\n\n2) Zero if the file was created and open successfully, non-zero if the file was not created or open or if `streamptr` was a null pointer. In addition, pointer to the associated file stream is stored in `*streamptr` on success, and a null pointer value is stored in `*streamptr` on error.\n\n### Notes\n\nOn some implementations (e.g. older Linux), this function actually creates, opens, and immediately deletes the file from the file system: as long as an open file descriptor to a deleted file is held by a program, the file exists, but since it was deleted, its name does not appear in any directory, so that no other process can open it. Once the file descriptor is closed, or once the program terminates (normally or abnormally), the space occupied by the file is reclaimed by the filesystem. Newer Linux (since 3.11 or later, depending on filesystem) creates such invisible temporary files in one step, via special flag in the [`open()`](https://man7.org/linux/man-pages/man2/open.2.html) syscall.\n\nOn some implementations (e.g. Windows), elevated privileges are required as the function may create the temporary file in a system directory.\n\n### Example\n\n```\n#define _POSIX_C_SOURCE 200112L\n#include <stdio.h>\n#include <unistd.h>\n \nint main(void)\n{\n    printf(\"TMP_MAX = %d, FOPEN_MAX = %d\\n\", TMP_MAX, FOPEN_MAX);\n    FILE* tmpf = tmpfile();\n    fputs(\"Hello, world\", tmpf);\n    rewind(tmpf);\n    char buf[6];\n    fgets(buf, sizeof buf, tmpf);\n    printf(\"got back from the file: '%s'\\n\", buf);\n \n    // Linux-specific method to display the tmpfile name\n    char fname[FILENAME_MAX], link[FILENAME_MAX] = {0};\n    sprintf(fname, \"/proc/self/fd/%d\", fileno(tmpf));\n    if (readlink(fname, link, sizeof link - 1) > 0)\n        printf(\"File name: %s\\n\", link);\n}\n```\n\nPossible output:\n\n```\nTMP_MAX = 238328, FOPEN_MAX = 16\ngot back from the file: 'Hello'\nFile name: /tmp/tmpfjptPe5 (deleted)\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.4.3 The tmpfile function (p: TBD)\n  - K.3.5.1.1 The tmpfile_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.4.3 The tmpfile function (p: 222)\n  - K.3.5.1.1 The tmpfile_s function (p: 427)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.4.3 The tmpfile function (p: 303)\n  - K.3.5.1.1 The tmpfile_s function (p: 586-587)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.4.3 The tmpfile function (p: 269)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.4.3 The tmpfile function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/tmpfile](https://en.cppreference.com/w/c/io/tmpfile)"
- name: tmpfile_s
  summary: The temporary file created by this function is closed and deleted when the program exits normally
  description: "# tmpfile, tmpfile_s\n\n[TABLE]\n\n1) Creates and opens a temporary file. The file is opened as binary file for update (as if by [`fopen`](fopen \"c/io/fopen\") with \"wb+\" mode). The filename of the file is guaranteed to be unique within the filesystem. At least [`TMP_MAX`](../io \"c/io\") files may be opened during the lifetime of a program (this limit may be shared with [`tmpnam`](tmpnam \"c/io/tmpnam\") and may be further limited by [`FOPEN_MAX`](../io \"c/io\")).\n\n2) Same as (1), except that at least `TMP_MAX_S` files may be opened (the limit may be shared with `tmpnam_s`), and if `streamptr` is a null pointer, the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function is called. As with all bounds-checked functions, `tmpfile_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\nThe temporary file created by this function is closed and deleted when the program exits normally. Whether it's deleted on abnormal termination is implementation-defined.\n\n### Parameters\n\n1) (none)\n\n2) pointer to a pointer that will be updated by this function call\n\n### Return value\n\n1) Pointer to the file stream associated with the file or null pointer if an error has occurred.\n\n2) Zero if the file was created and open successfully, non-zero if the file was not created or open or if `streamptr` was a null pointer. In addition, pointer to the associated file stream is stored in `*streamptr` on success, and a null pointer value is stored in `*streamptr` on error.\n\n### Notes\n\nOn some implementations (e.g. older Linux), this function actually creates, opens, and immediately deletes the file from the file system: as long as an open file descriptor to a deleted file is held by a program, the file exists, but since it was deleted, its name does not appear in any directory, so that no other process can open it. Once the file descriptor is closed, or once the program terminates (normally or abnormally), the space occupied by the file is reclaimed by the filesystem. Newer Linux (since 3.11 or later, depending on filesystem) creates such invisible temporary files in one step, via special flag in the [`open()`](https://man7.org/linux/man-pages/man2/open.2.html) syscall.\n\nOn some implementations (e.g. Windows), elevated privileges are required as the function may create the temporary file in a system directory.\n\n### Example\n\n```\n#define _POSIX_C_SOURCE 200112L\n#include <stdio.h>\n#include <unistd.h>\n \nint main(void)\n{\n    printf(\"TMP_MAX = %d, FOPEN_MAX = %d\\n\", TMP_MAX, FOPEN_MAX);\n    FILE* tmpf = tmpfile();\n    fputs(\"Hello, world\", tmpf);\n    rewind(tmpf);\n    char buf[6];\n    fgets(buf, sizeof buf, tmpf);\n    printf(\"got back from the file: '%s'\\n\", buf);\n \n    // Linux-specific method to display the tmpfile name\n    char fname[FILENAME_MAX], link[FILENAME_MAX] = {0};\n    sprintf(fname, \"/proc/self/fd/%d\", fileno(tmpf));\n    if (readlink(fname, link, sizeof link - 1) > 0)\n        printf(\"File name: %s\\n\", link);\n}\n```\n\nPossible output:\n\n```\nTMP_MAX = 238328, FOPEN_MAX = 16\ngot back from the file: 'Hello'\nFile name: /tmp/tmpfjptPe5 (deleted)\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.4.3 The tmpfile function (p: TBD)\n  - K.3.5.1.1 The tmpfile_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.4.3 The tmpfile function (p: 222)\n  - K.3.5.1.1 The tmpfile_s function (p: 427)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.4.3 The tmpfile function (p: 303)\n  - K.3.5.1.1 The tmpfile_s function (p: 586-587)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.4.3 The tmpfile function (p: 269)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.4.3 The tmpfile function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/tmpfile](https://en.cppreference.com/w/c/io/tmpfile)"
- name: tmpnam
  summary: tmpnam and tmpnam_s modify static state (which may be shared between these functions) and are not required to be thread-safe
  description: "# tmpnam, tmpnam_s\n\n[TABLE]\n\n1) Creates a unique valid file name (no longer than [`L_tmpnam`](../io \"c/io\") in length) and stores it in character string pointed to by `filename`. The function is capable of generating up to [`TMP_MAX`](../io \"c/io\") of unique filenames, but some or all of them may be in use in the filesystem and thus not suitable return values.\n\n2) Same as (1), except that up to `TMP_MAX_S` names may be generated, no longer than `L_tmpnam_s` in length, and the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `filename_s` is a null pointer\n- `maxsize` is greater than `RSIZE_MAX`\n- `maxsize` is less than the generated file name string\n\nAs with all bounds-checked functions, `tmpnam_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n`tmpnam` and `tmpnam_s` modify static state (which may be shared between these functions) and are not required to be thread-safe.\n\n### Parameters\n\n|            |     |                                                                                                                                                                                                            |\n|------------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| filename   | \\-  | pointer to the character array capable of holding at least [`L_tmpnam`](../io \"c/io\") bytes, to be used as a result buffer. If null pointer is passed, a pointer to an internal static buffer is returned. |\n| filename_s | \\-  | pointer to the character array capable of holding at least `L_tmpnam_s` bytes, to be used as a result buffer.                                                                                              |\n| maxsize    | \\-  | maximum number of characters the function is allowed to write (typically the size of the `filename_s` array).                                                                                              |\n\n### Return value\n\n1) `filename` if `filename` was not a null pointer. Otherwise a pointer to an internal static buffer is returned. If no suitable filename can be generated, null pointer is returned.\n\n2) Returns zero and writes the file name to `filename_s` on success. On error, returns non-zero and writes the null character to `filename_s[0]` (only if `filename_s` is not null and `maxsize` is not zero and is not greater than `RSIZE_MAX`).\n\n### Notes\n\nAlthough the names generated by `tmpnam` are difficult to guess, it is possible that a file with that name is created by another process between the moment `tmpnam` returns and the moment this program attempts to use the returned name to create a file. The standard function [`tmpfile`](tmpfile \"c/io/tmpfile\") and the POSIX function [`mkstemp`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html) do not have this problem (creating a unique directory using only the standard C library still requires the use of `tmpnam`).\n\nPOSIX systems additionally define the similarly named function [`tempnam`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tempnam.html), which offers the choice of a directory (which defaults to the optionally defined macro [`P_tmpdir`](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html)).\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nint main(void)\n{\n    // Note, the compiler/linker may issue a security warning, e.g. GCC:\n    // \"warning: the use of `tmpnam' is dangerous, better use `mkstemp'\"\n    char* name1 = tmpnam(NULL);\n    printf(\"temporary file name: %s\\n\", name1);\n \n    char name2[L_tmpnam];\n    if (tmpnam(name2))\n        printf(\"temporary file name: %s\\n\", name2);\n \n    // POSIX offers mkstemp. The following declaration might be\n    // necessary as mkstemp is absent in the standard C <stdlib.h>.\n    int mkstemp(char*);\n \n    char name3[] = \"/tmp/fileXXXXXX\"; // at least six 'X' required ^_^\n    int file_descriptor = mkstemp(name3);\n    if (file_descriptor != -1)\n        printf(\"temporary file name: %s\\n\", name3);\n    else\n        perror(\"mkstemp\");\n}\n```\n\nPossible output:\n\n```\ntemporary file name: /tmp/file90dLlR\ntemporary file name: /tmp/fileY9LWAg\ntemporary file name: /tmp/filexgv8PF\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.4.4 The tmpnam function (p: TBD)\n  - K.3.5.1.2 The tmpnam_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.4.4 The tmpnam function (p: 222)\n  - K.3.5.1.2 The tmpnam_s function (p: 427-428)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.4.4 The tmpnam function (p: 303-304)\n  - K.3.5.1.2 The tmpnam_s function (p: 587-588)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.4.4 The tmpnam function (p: 269-270)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.4.4 The tmpnam function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/tmpnam](https://en.cppreference.com/w/c/io/tmpnam)"
- name: tmpnam_s
  summary: tmpnam and tmpnam_s modify static state (which may be shared between these functions) and are not required to be thread-safe
  description: "# tmpnam, tmpnam_s\n\n[TABLE]\n\n1) Creates a unique valid file name (no longer than [`L_tmpnam`](../io \"c/io\") in length) and stores it in character string pointed to by `filename`. The function is capable of generating up to [`TMP_MAX`](../io \"c/io\") of unique filenames, but some or all of them may be in use in the filesystem and thus not suitable return values.\n\n2) Same as (1), except that up to `TMP_MAX_S` names may be generated, no longer than `L_tmpnam_s` in length, and the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `filename_s` is a null pointer\n- `maxsize` is greater than `RSIZE_MAX`\n- `maxsize` is less than the generated file name string\n\nAs with all bounds-checked functions, `tmpnam_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n`tmpnam` and `tmpnam_s` modify static state (which may be shared between these functions) and are not required to be thread-safe.\n\n### Parameters\n\n|            |     |                                                                                                                                                                                                            |\n|------------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| filename   | \\-  | pointer to the character array capable of holding at least [`L_tmpnam`](../io \"c/io\") bytes, to be used as a result buffer. If null pointer is passed, a pointer to an internal static buffer is returned. |\n| filename_s | \\-  | pointer to the character array capable of holding at least `L_tmpnam_s` bytes, to be used as a result buffer.                                                                                              |\n| maxsize    | \\-  | maximum number of characters the function is allowed to write (typically the size of the `filename_s` array).                                                                                              |\n\n### Return value\n\n1) `filename` if `filename` was not a null pointer. Otherwise a pointer to an internal static buffer is returned. If no suitable filename can be generated, null pointer is returned.\n\n2) Returns zero and writes the file name to `filename_s` on success. On error, returns non-zero and writes the null character to `filename_s[0]` (only if `filename_s` is not null and `maxsize` is not zero and is not greater than `RSIZE_MAX`).\n\n### Notes\n\nAlthough the names generated by `tmpnam` are difficult to guess, it is possible that a file with that name is created by another process between the moment `tmpnam` returns and the moment this program attempts to use the returned name to create a file. The standard function [`tmpfile`](tmpfile \"c/io/tmpfile\") and the POSIX function [`mkstemp`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html) do not have this problem (creating a unique directory using only the standard C library still requires the use of `tmpnam`).\n\nPOSIX systems additionally define the similarly named function [`tempnam`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tempnam.html), which offers the choice of a directory (which defaults to the optionally defined macro [`P_tmpdir`](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html)).\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nint main(void)\n{\n    // Note, the compiler/linker may issue a security warning, e.g. GCC:\n    // \"warning: the use of `tmpnam' is dangerous, better use `mkstemp'\"\n    char* name1 = tmpnam(NULL);\n    printf(\"temporary file name: %s\\n\", name1);\n \n    char name2[L_tmpnam];\n    if (tmpnam(name2))\n        printf(\"temporary file name: %s\\n\", name2);\n \n    // POSIX offers mkstemp. The following declaration might be\n    // necessary as mkstemp is absent in the standard C <stdlib.h>.\n    int mkstemp(char*);\n \n    char name3[] = \"/tmp/fileXXXXXX\"; // at least six 'X' required ^_^\n    int file_descriptor = mkstemp(name3);\n    if (file_descriptor != -1)\n        printf(\"temporary file name: %s\\n\", name3);\n    else\n        perror(\"mkstemp\");\n}\n```\n\nPossible output:\n\n```\ntemporary file name: /tmp/file90dLlR\ntemporary file name: /tmp/fileY9LWAg\ntemporary file name: /tmp/filexgv8PF\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.21.4.4 The tmpnam function (p: TBD)\n  - K.3.5.1.2 The tmpnam_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.4.4 The tmpnam function (p: 222)\n  - K.3.5.1.2 The tmpnam_s function (p: 427-428)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.4.4 The tmpnam function (p: 303-304)\n  - K.3.5.1.2 The tmpnam_s function (p: 587-588)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.4.4 The tmpnam function (p: 269-270)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.4.4 The tmpnam function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/tmpnam](https://en.cppreference.com/w/c/io/tmpnam)"
- name: tolower
  summary: Converts the given character to lowercase according to the character conversion rules defined by the currently installed C locale
  description: "# tolower\n\n[TABLE]\n\nConverts the given character to lowercase according to the character conversion rules defined by the currently installed C locale.\n\nIn the default \"C\" locale, the following uppercase letters `ABCDEFGHIJKLMNOPQRSTUVWXYZ` are replaced with respective lowercase letters `abcdefghijklmnopqrstuvwxyz`.\n\n### Parameters\n\n|     |     |                                                                                                                                                                                   |\n|-----|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| ch  | \\-  | character to be converted. If the value of `ch` is not representable as `unsigned char` and does not equal [`EOF`](http://en.cppreference.com/w/c/io), the behavior is undefined. |\n\n### Return value\n\nLowercase version of `ch` or unmodified `ch` if no lowercase version is listed in the current C locale.\n\n### Example\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <locale.h>\n#include <limits.h>\n \nint main(void)\n{\n    /* In the default locale: */\n    for (unsigned char u = 0; u < UCHAR_MAX; u++) {\n        unsigned char l = tolower(u);\n        if (l != u) printf(\"%c%c \", u, l);\n    }\n    printf(\"\\n\\n\");\n \n    unsigned char c = '\\xb4'; // the character Ž in ISO-8859-15\n                              // but ´ (acute accent) in ISO-8859-1\n    setlocale(LC_ALL, \"en_US.iso88591\");\n    printf(\"in iso8859-1, tolower('0x%x') gives 0x%x\\n\", c, tolower(c));\n    setlocale(LC_ALL, \"en_US.iso885915\");\n    printf(\"in iso8859-15, tolower('0x%x') gives 0x%x\\n\", c, tolower(c));\n}\n```\n\nPossible output:\n\n```\nAa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz\n \nin iso8859-1, tolower('0xb4') gives 0xb4\nin iso8859-15, tolower('0xb4') gives 0xb8\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.2.1 The tolower function (p: 147)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.2.1 The tolower function (p: 203)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.2.1 The tolower function (p: 184)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.2.1 The tolower function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/tolower](https://en.cppreference.com/w/c/string/byte/tolower)"
- name: toupper
  summary: Converts the given character to uppercase according to the character conversion rules defined by the currently installed C locale
  description: "# toupper\n\n[TABLE]\n\nConverts the given character to uppercase according to the character conversion rules defined by the currently installed C locale.\n\nIn the default \"C\" locale, the following lowercase letters `abcdefghijklmnopqrstuvwxyz` are replaced with respective uppercase letters `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n\n### Parameters\n\n|     |     |                                                                                                                                                                                   |\n|-----|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| ch  | \\-  | character to be converted. If the value of `ch` is not representable as `unsigned char` and does not equal [`EOF`](http://en.cppreference.com/w/c/io), the behavior is undefined. |\n\n### Return value\n\nUppercase version of `ch` or unmodified `ch` if no uppercase version is listed in the current C locale.\n\n### Example\n\n```\n#include <stdio.h>\n#include <ctype.h>\n#include <locale.h>\n#include <limits.h>\n \nint main(void)\n{\n    /* In the default locale: */\n    for (unsigned char l = 0; l < UCHAR_MAX; l++) {\n        unsigned char u = toupper(l);\n        if (u != l) printf(\"%c%c \", l, u);\n    }\n    printf(\"\\n\\n\");\n \n    unsigned char c = '\\xb8'; // the character Ž in ISO-8859-15\n                              // but ´ (acute accent) in ISO-8859-1 \n    setlocale(LC_ALL, \"en_US.iso88591\");\n    printf(\"in iso8859-1, toupper('0x%x') gives 0x%x\\n\", c, toupper(c));\n    setlocale(LC_ALL, \"en_US.iso885915\");\n    printf(\"in iso8859-15, toupper('0x%x') gives 0x%x\\n\", c, toupper(c));\n}\n```\n\nPossible output:\n\n```\naA bB cC dD eE fF gG hH iI jJ kK lL mM nN oO pP qQ rR sS tT uU vV wW xX yY zZ \n \nin iso8859-1, toupper('0xb8') gives 0xb8\nin iso8859-15, toupper('0xb8') gives 0xb4\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.4.2.2 The toupper function (p: 147-148)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.4.2.2 The toupper function (p: 204)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.4.2.2 The toupper function (p: 185)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.3.2.2 The toupper function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/byte/toupper](https://en.cppreference.com/w/c/string/byte/toupper)"
- name: towctrans
  summary: Maps the wide character wc using the current C locale's LC_CTYPE mapping category identified by desc
  description: "# towctrans\n\n[TABLE]\n\nMaps the wide character `wc` using the current C locale's [`LC_CTYPE`](../../locale/lc_categories \"c/locale/LC categories\") mapping category identified by `desc`.\n\n### Parameters\n\n|      |     |                                                                                                                                                     |\n|------|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------|\n| wc   | \\-  | the wide character to map                                                                                                                           |\n| desc | \\-  | the [`LC_CTYPE`](../../locale/lc_categories \"c/locale/LC categories\") mapping, obtained from a call to [`wctrans`](wctrans \"c/string/wide/wctrans\") |\n\n### Return value\n\nThe mapped value of `wc` using the mapping identified by `desc` in [`LC_CTYPE`](../../locale/lc_categories \"c/locale/LC categories\") facet of the current C locale.\n\n### Example\n\n```\n#include <locale.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <stdio.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"ja_JP.UTF-8\");\n    const wchar_t kana[] = L\"ヒラガナ\";\n    size_t sz = sizeof kana / sizeof *kana;\n    wchar_t hira[sz];\n    for (size_t n = 0; n < sz; ++n)\n        hira[n] = towctrans(kana[n], wctrans(\"tojhira\"));\n    printf(\"katakana characters %ls are %ls in hiragana\\n\", kana, hira);\n}\n```\n\nOutput:\n\n```\nkatakana characters ヒラガナ are ひらがな in hiragana\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.3.2.1 The towctrans function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.3.2.1 The towctrans function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.3.2.1 The towctrans function (p: 454)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.3.2,1 The towctrans function (p: 400)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/towctrans](https://en.cppreference.com/w/c/string/wide/towctrans)"
- name: towlower
  summary: Converts the given wide character to lowercase, if possible
  description: "# towlower\n\n[TABLE]\n\nConverts the given wide character to lowercase, if possible.\n\n### Parameters\n\n|     |     |                                |\n|-----|-----|--------------------------------|\n| wc  | \\-  | wide character to be converted |\n\n### Return value\n\nLowercase version of `wc` or unmodified `wc` if no lowercase version is listed in the current C locale.\n\n### Notes\n\nOnly 1:1 character mapping can be performed by this function, e.g. the Greek uppercase letter 'Σ' has two lowercase forms, depending on the position in a word: 'σ' and 'ς'. A call to `towlower` cannot be used to obtain the correct lowercase form in this case.\n\n[ISO 30112](http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) specifies which pairs of Unicode characters are included in this mapping.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n \nint main(void)\n{\n    wchar_t wc = L'\\u0190'; // Latin capital open E ('Ɛ')\n    printf(\"in the default locale, towlower(%#x) = %#x\\n\", wc, towlower(wc));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"in Unicode locale, towlower(%#x) = %#x\\n\", wc, towlower(wc));\n}\n```\n\nOutput:\n\n```\nin the default locale, towlower(0x190) = 0x190\nin Unicode locale, towlower(0x190) = 0x25b\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.3.1.1 The towlower function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.3.1.1 The towlower function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.3.1.1 The towlower function (p: 453)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.3.1.1 The towlower function (p: 399)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/towlower](https://en.cppreference.com/w/c/string/wide/towlower)"
- name: towupper
  summary: Converts the given wide character to uppercase, if possible
  description: "# towupper\n\n[TABLE]\n\nConverts the given wide character to uppercase, if possible.\n\n### Parameters\n\n|     |     |                                |\n|-----|-----|--------------------------------|\n| wc  | \\-  | wide character to be converted |\n\n### Return value\n\nUppercase version of `wc` or unmodified `wc` if no uppercase version is listed in the current C locale.\n\n### Notes\n\nOnly 1:1 character mapping can be performed by this function, e.g. the uppercase form of 'ß' is (with some exceptions) the two-character string \"SS\", which cannot be obtained by `towupper`.\n\n[ISO 30112](http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf) specifies which pairs of Unicode characters are included in this mapping.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n \nint main(void)\n{\n    wchar_t wc =  L'\\u017f'; // Latin small letter Long S ('ſ')\n    printf(\"in the default locale, towupper(%#x) = %#x\\n\", wc, towupper(wc));\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"in Unicode locale, towupper(%#x) = %#x\\n\", wc, towupper(wc));\n}\n```\n\nOutput:\n\n```\nin the default locale, towupper(0x17f) = 0x17f\nin Unicode locale, towupper(0x17f) = 0x53\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.3.1.2 The towupper function (p: 453)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.3.1.2 The towupper function (p: 399)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/towupper](https://en.cppreference.com/w/c/string/wide/towupper)"
- name: 'true'
  summary: ''
  description: "# C keywords: true (since C23)\n\n### Usage\n\n- [predefined boolean constant](../language/bool_constant \"c/language/bool constant\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/true](https://en.cppreference.com/w/c/keyword/true)"
- name: trunc
  summary: If no errors occur, the nearest integer value not greater in magnitude than arg (in other words, arg rounded towards zero), is returned
  description: "# trunc, truncf, truncl\n\n[TABLE]\n\n1-3) Computes the nearest integer not greater in magnitude than `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `truncl` is called. Otherwise, if `arg` has integer type or the type `double`, `trunc` is called. Otherwise, `truncf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value not greater in magnitude than `arg` (in other words, `arg` rounded towards zero), is returned.\n\nReturn value\n\nArgument\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If arg is NaN, NaN is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised when truncating a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nThe implicit conversion from floating-point to integral types also rounds towards zero, but is limited to the values that can be represented by the target type.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"trunc(+2.7) = %+.1f\\n\", trunc(2.7));\n    printf(\"trunc(-2.7) = %+.1f\\n\", trunc(-2.7));\n    printf(\"trunc(-0.0) = %+.1f\\n\", trunc(-0.0));\n    printf(\"trunc(-Inf) = %+f\\n\",   trunc(-INFINITY));\n}\n```\n\nPossible output:\n\n```\ntrunc(+2.7) = +2.0\ntrunc(-2.7) = -2.0\ntrunc(-0.0) = -0.0\ntrunc(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.8 The trunc functions (p: 253-254)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.8 The trunc functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.8 The trunc functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.8 The trunc functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/trunc](https://en.cppreference.com/w/c/numeric/math/trunc)"
- name: truncf
  summary: If no errors occur, the nearest integer value not greater in magnitude than arg (in other words, arg rounded towards zero), is returned
  description: "# trunc, truncf, truncl\n\n[TABLE]\n\n1-3) Computes the nearest integer not greater in magnitude than `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `truncl` is called. Otherwise, if `arg` has integer type or the type `double`, `trunc` is called. Otherwise, `truncf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value not greater in magnitude than `arg` (in other words, `arg` rounded towards zero), is returned.\n\nReturn value\n\nArgument\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If arg is NaN, NaN is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised when truncating a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nThe implicit conversion from floating-point to integral types also rounds towards zero, but is limited to the values that can be represented by the target type.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"trunc(+2.7) = %+.1f\\n\", trunc(2.7));\n    printf(\"trunc(-2.7) = %+.1f\\n\", trunc(-2.7));\n    printf(\"trunc(-0.0) = %+.1f\\n\", trunc(-0.0));\n    printf(\"trunc(-Inf) = %+f\\n\",   trunc(-INFINITY));\n}\n```\n\nPossible output:\n\n```\ntrunc(+2.7) = +2.0\ntrunc(-2.7) = -2.0\ntrunc(-0.0) = -0.0\ntrunc(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.8 The trunc functions (p: 253-254)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.8 The trunc functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.8 The trunc functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.8 The trunc functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/trunc](https://en.cppreference.com/w/c/numeric/math/trunc)"
- name: truncl
  summary: If no errors occur, the nearest integer value not greater in magnitude than arg (in other words, arg rounded towards zero), is returned
  description: "# trunc, truncf, truncl\n\n[TABLE]\n\n1-3) Computes the nearest integer not greater in magnitude than `arg`.\n\n4) Type-generic macro: If `arg` has type `long double`, `truncl` is called. Otherwise, if `arg` has integer type or the type `double`, `trunc` is called. Otherwise, `truncf` is called.\n\n### Parameters\n\n|     |     |                      |\n|-----|-----|----------------------|\n| arg | \\-  | floating point value |\n\n### Return value\n\nIf no errors occur, the nearest integer value not greater in magnitude than `arg` (in other words, `arg` rounded towards zero), is returned.\n\nReturn value\n\nArgument\n\n### Error handling\n\nErrors are reported as specified in [math_errhandling](math_errhandling \"c/numeric/math/math errhandling\").\n\nIf the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\n- The current [rounding mode](../fenv/fe_round \"c/numeric/fenv/FE round\") has no effect.\n- If `arg` is ±∞, it is returned, unmodified\n- If `arg` is ±0, it is returned, unmodified\n- If arg is NaN, NaN is returned\n\n### Notes\n\n[`FE_INEXACT`](../fenv/fe_exceptions \"c/numeric/fenv/FE exceptions\") may be (but isn't required to be) raised when truncating a non-integer finite value.\n\nThe largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including [`intmax_t`](../../types/integer \"c/types/integer\")), when stored in an integer variable.\n\nThe implicit conversion from floating-point to integral types also rounds towards zero, but is limited to the values that can be represented by the target type.\n\n### Example\n\n```\n#include <math.h>\n#include <stdio.h>\nint main(void)\n{\n    printf(\"trunc(+2.7) = %+.1f\\n\", trunc(2.7));\n    printf(\"trunc(-2.7) = %+.1f\\n\", trunc(-2.7));\n    printf(\"trunc(-0.0) = %+.1f\\n\", trunc(-0.0));\n    printf(\"trunc(-Inf) = %+f\\n\",   trunc(-INFINITY));\n}\n```\n\nPossible output:\n\n```\ntrunc(+2.7) = +2.0\ntrunc(-2.7) = -2.0\ntrunc(-0.0) = -0.0\ntrunc(-Inf) = -inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.12.9.8 The trunc functions (p: 253-254)\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n  - F.10.6.8 The trunc functions (p: 528)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.12.9.8 The trunc functions (p: 234)\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n  - F.9.6.8 The trunc functions (p: 464)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/math/trunc](https://en.cppreference.com/w/c/numeric/math/trunc)"
- name: tss_create
  summary: Creates new thread-specific storage key and stores it in the object pointed to by tss_key
  description: "# tss_create\n\n[TABLE]\n\nCreates new thread-specific storage key and stores it in the object pointed to by `tss_key`. Although the same key value may be used by different threads, the values bound to the key by [`tss_set`](tss_set \"c/thread/tss set\") are maintained on a per-thread basis and persist for the life of the calling thread.\n\nThe value [`NULL`](../types/null \"c/types/NULL\") is associated with the newly created key in all existing threads, and upon thread creation, the values associated with all TSS keys is initialized to [`NULL`](../types/null \"c/types/NULL\").\n\nIf `destructor` is not a null pointer, then also associates the destructor which is called when the storage is released by [`thrd_exit`](thrd_exit \"c/thread/thrd exit\") (but not by [`tss_delete`](tss_delete \"c/thread/tss delete\") and not at program termination by [`exit`](../program/exit \"c/program/exit\")).\n\nA call to `tss_create` from within a thread-specific storage destructor results in undefined behavior.\n\n### Parameters\n\n|            |     |                                                                         |\n|------------|-----|-------------------------------------------------------------------------|\n| tss_key    | \\-  | pointer to memory location to store the new thread-specific storage key |\n| destructor | \\-  | pointer to a function to call at thread exit                            |\n\n### Notes\n\nThe POSIX equivalent of this function is [`pthread_key_create`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_create.html).\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") otherwise.\n\n### Example\n\n```\nint thread_func(void *arg) {\n    tss_t key;\n    if (thrd_success == tss_create(&key, free)) {\n        tss_set(key, malloc(4)); // stores a pointer on TSS\n        // ...\n    }\n} // calls free() for the pointer stored on TSS\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.6.1 The tss_create function (p: 281-282)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.6.1 The tss_create function (p: 386)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/tss_create](https://en.cppreference.com/w/c/thread/tss_create)"
- name: tss_delete
  summary: Destroys the thread-specific storage identified by tss_id
  description: "# tss_delete\n\n[TABLE]\n\nDestroys the thread-specific storage identified by `tss_id`.\n\nThe destructor, if one was registered by [`tss_create`](tss_create \"c/thread/tss create\"), is not called (they are only called at thread exit, either by [`thrd_exit`](thrd_exit \"c/thread/thrd exit\") or by returning from the thread function), it is the responsibility of the programmer to ensure that every thread that is aware of `tss_id` performed all necessary cleanup, before the call to `tss_delete` is made.\n\nIf `tss_delete` is called while another thread is executing destructors for `tss_id`, it's unspecified whether this changes the number of invocations to the associated destructor.\n\nIf `tss_delete` is called while the calling thread is executing destructors, then the destructor associated with `tss_id` will not be executed again on this thread.\n\n### Parameters\n\n|        |     |                                                                                                                                         |\n|--------|-----|-----------------------------------------------------------------------------------------------------------------------------------------|\n| tss_id | \\-  | thread-specific storage key previously returned by [`tss_create`](tss_create \"c/thread/tss create\") and not yet deleted by `tss_delete` |\n\n### Return value\n\n(none)\n\n### Notes\n\nThe POSIX equivalent of this function is [`pthread_key_delete`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_delete.html).\n\nThe reason `tss_delete` never calls destructors is that the destructors (called at thread exit) are normally intended to be executed by the same thread that originally set the value (via [`tss_set`](tss_set \"c/thread/tss set\")) that the destructor will be dealing with, and may even rely on the values of that or other thread-specific data as seen by that thread. The thread executing `tss_delete` has no access to other threads' TSS. Even if it were possible to call the destructor for each thread's own value associated with `tss_id`, `tss_delete` would have to synchronize with every thread if only to examine whether the value of this TSS in that thread is null (destructors are only called against non-null values).\n\n### Example\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.6.2 The tss_delete function (p: 282)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.6.2 The tss_delete function (p: 386)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/tss_delete](https://en.cppreference.com/w/c/thread/tss_delete)"
- name: TSS_DTOR_ITERATIONS
  summary: Expands to a positive integral constant expression defining the maximum number of times a destructor for thread-local storage pointer will be called by thrd_exit
  description: "# TSS_DTOR_ITERATIONS\n\n[TABLE]\n\nExpands to a positive integral [constant expression](../language/constant_expression \"c/language/constant expression\") defining the maximum number of times a destructor for thread-local storage pointer will be called by [`thrd_exit`](thrd_exit \"c/thread/thrd exit\").\n\nThis constant is equivalent to the POSIX `PTHREAD_DESTRUCTOR_ITERATIONS`.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.1/3 TSS_DTOR_ITERATIONS (p: 274)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.1/3 TSS_DTOR_ITERATIONS (p: 376)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/TSS_DTOR_ITERATIONS](https://en.cppreference.com/w/c/thread/TSS_DTOR_ITERATIONS)"
- name: tss_get
  summary: Returns the value held in thread-specific storage for the current thread identified by tss_key
  description: "# tss_get\n\n[TABLE]\n\nReturns the value held in thread-specific storage for the current thread identified by `tss_key`. Different threads may get different values identified by the same key.\n\nOn thread startup (see [`thrd_create`](thrd_create \"c/thread/thrd create\")), the values associated with all TSS keys are NULL. Different value may be placed in the thread-specific storage with [`tss_set`](tss_set \"c/thread/tss set\").\n\n### Parameters\n\n|         |     |                                                                                                                                                                 |\n|---------|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| tss_key | \\-  | thread-specific storage key, obtained from [`tss_create`](tss_create \"c/thread/tss create\") and not deleted by [`tss_delete`](tss_delete \"c/thread/tss delete\") |\n\n### Return value\n\nThe value on success, [`NULL`](../types/null \"c/types/NULL\") on failure.\n\n### Notes\n\nThe POSIX equivalent for this function is [`pthread_getspecific`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_getspecific.html).\n\n### Example\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.6.3 The tss_get function (p: 282)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.6.3 The tss_get function (p: 386)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/tss_get](https://en.cppreference.com/w/c/thread/tss_get)"
- name: tss_set
  summary: Sets the value of the thread-specific storage identified by tss_id for the current thread to val
  description: "# tss_set\n\n[TABLE]\n\nSets the value of the thread-specific storage identified by `tss_id` for the current thread to `val`. Different threads may set different values to the same key.\n\nThe destructor, if available, is not invoked.\n\n### Parameters\n\n|        |     |                                                                                                                                                                 |\n|--------|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| tss_id | \\-  | thread-specific storage key, obtained from [`tss_create`](tss_create \"c/thread/tss create\") and not deleted by [`tss_delete`](tss_delete \"c/thread/tss delete\") |\n| val    | \\-  | value to set thread-specific storage to                                                                                                                         |\n\n### Return value\n\n[`thrd_success`](thrd_errors \"c/thread/thrd errors\") if successful, [`thrd_error`](thrd_errors \"c/thread/thrd errors\") otherwise.\n\n### Notes\n\nThe POSIX equivalent of this function is [`pthread_setspecific`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_setspecific.html).\n\nTypically TSS is used to store pointers to blocks of dynamically allocated memory that have been reserved for use by the calling thread.\n\n`tss_set` may be called in the TSS destructor. If the destructor exits with non-NULL value in the TSS storage, it will be retried by [`thrd_exit`](thrd_exit \"c/thread/thrd exit\") up to [`TSS_DTOR_ITERATIONS`](tss_dtor_iterations \"c/thread/TSS DTOR ITERATIONS\") times, after which the storage will be lost.\n\n### Example\n\n```\nint thread_func(void *arg) {\n    tss_t key;\n    if (thrd_success == tss_create(&key, free)) {\n        tss_set(key, malloc(4)); // stores a pointer on TSS\n        // ...\n    }\n} // calls free() for the pointer stored on TSS\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.26.6.4 The tss_set function (p: 282-283)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.26.6.4 The tss_set function (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/thread/tss_set](https://en.cppreference.com/w/c/thread/tss_set)"
- name: Type
  summary: (See also arithmetic types for the details on most built-in types and the list of type-related utilities that are provided by the C library.)
  description: "# Type\n\n(See also [arithmetic types](arithmetic_types \"c/language/arithmetic types\") for the details on most built-in types and [the list of type-related utilities](../types \"c/types\") that are provided by the C library.)\n\n[Objects](object \"c/language/object\"), [functions](functions \"c/language/functions\"), and [expressions](expressions \"c/language/expressions\") have a property called *type*, which determines the interpretation of the binary value stored in an object or evaluated by the expression.\n\n### Type classification\n\nThe C type system consists of the following types:\n\n- the type `void`\n- basic types\n- the type `char`\n- signed integer types\n  - standard: `signed char`, `short`, `int`, `long`, `long long`(since C99)\n\n[TABLE]\n\n- unsigned integer types\n  - standard: `_Bool`,(since C99) `unsigned char`, `unsigned short`, `unsigned int`, `unsigned long`, `unsigned long long`(since C99)\n\n[TABLE]\n\n- floating-point types\n  - real floating-point types: `float`, `double`, `long double`\n\n[TABLE]\n\n- [enumerated types](enum \"c/language/enum\")\n- derived types\n  - [array types](array \"c/language/array\")\n  - [structure types](struct \"c/language/struct\")\n  - [union types](union \"c/language/union\")\n  - [function types](functions \"c/language/functions\")\n  - [pointer types](pointer \"c/language/pointer\")\n\n[TABLE]\n\nFor every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the [`const`](const \"c/language/const\"), [`volatile`](volatile \"c/language/volatile\"), and [`restrict`](restrict \"c/language/restrict\") qualifiers (where allowed by the qualifier's semantics).\n\n#### Type groups\n\n- *object types*: all types that aren't function types\n- *character types*: `char`, `signed char`, `unsigned char`\n- *integer types*: `char`, signed integer types, unsigned integer types, enumerated types\n- *real types*: integer types and real floating types\n- [arithmetic types](arithmetic_types \"c/language/arithmetic types\"): integer types and floating types\n- *scalar types*: arithmetic types, pointer types, and [`nullptr_t`](../types/nullptr_t \"c/types/nullptr t\")(since C23)\n- *aggregate types*: array types and structure types\n- *derived declarator types*: array types, function types, and pointer types\n\nConstructing a complete object type such that the number of bytes in its object representation is not representable in the type [`size_t`](../types/size_t \"c/types/size t\") (i.e. the result type of [`sizeof`](sizeof \"c/language/sizeof\") operator), including forming such a VLA type at runtime,(since C99) is undefined behavior.\n\n### Compatible types\n\nIn a C program, the declarations referring to the same object or function in *different translation units* do not have to use the same type. They only have to use sufficiently similar types, formally known as *compatible types*. Same applies to function calls and lvalue accesses; argument types must be *compatible* with parameter types and lvalue expression type must be *compatible* with the object type that is accessed.\n\nThe types `T` and `U` are compatible, if\n\n- they are the same type (same name or aliases introduced by a [`typedef`](typedef \"c/language/typedef\"))\n- they are identically cvr-qualified versions of compatible unqualified types\n- they are pointer types and are pointing to compatible types\n- they are array types, and\n  - their element types are compatible, and\n  - if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. VLA is compatible with any array of compatible element type.(since C99)\n- they are both structure/union/enumeration types, and\n- (C99)if one is declared with a tag, the other must also be declared with the same tag.\n- if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names.\n- additionally, if they are enumerations, corresponding members must also have the same values.\n- additionally, if they are structures or unions,\n  - Corresponding members must be declared in the same order (structures only)\n  - Corresponding [bit-fields](bit_field \"c/language/bit field\") must have the same widths.\n- one is an enumerated type and the other is that enumeration's underlying type\n- they are function types, and\n  - their return types are compatible\n  - they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, and the corresponding parameter, after applying array-to-pointer and function-to-pointer type adjustments and after stripping top-level qualifiers, have compatible types\n\n[TABLE]\n\nThe type `char` is not compatible with `signed char` and not compatible with `unsigned char`.\n\nIf two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.\n\n```\n// Translation Unit 1\nstruct S { int a; };\nextern struct S *x; // compatible with TU2's x, but not with TU3's x\n \n// Translation Unit 2\nstruct S;\nextern struct S *x; // compatible with both x's\n \n// Translation Unit 3\nstruct S { float a; };\nextern struct S *x; // compatible with TU2's x, but not with TU1's x\n \n// the behavior is undefined\n```\n\n```\n// Translation Unit 1\n#include <stdio.h>\n \nstruct s { int i; }; // compatible with TU3's s, but not TU2's\nextern struct s x = {0}; // compatible with TU3's x\nextern void f(void); // compatible with TU2's f\n \nint main()\n{\n    f();\n    return x.i;\n}\n \n// Translation Unit 2\nstruct s { float f; }; // compatible with TU4's s, but not TU1's s\nextern struct s y = {3.14}; // compatible with TU4's y\nvoid f() // compatible with TU1's f\n{\n    return;\n}\n \n// Translation Unit 3\nstruct s { int i; }; // compatible with TU1's s, but not TU2's s\nextern struct s x; // compatible with TU1's x\n \n// Translation Unit 4\nstruct s { float f; }; // compatible with TU2's s, but not TU1's s\nextern struct s y; // compatible with TU2's y\n \n// the behavior is well-defined: only multiple declarations\n// of objects and functions must have compatible types, not the types themselves\n```\n\nNote: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.\n\n### Composite types\n\nA composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:\n\n- If both types are array types, the following rules are applied:\n  - If one type is an array of known constant size, the composite type is an array of that size.\n\n[TABLE]\n\n- Otherwise, both types are arrays of unknown size and the composite type is an array of unknown size.\n\nThe element type of the composite type is the composite type of the two element types.\n\n[TABLE]\n\n- If both types are function types with parameter type lists, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters.\n\nThese rules apply recursively to the types from which the two types are derived.\n\n```\n// Given the following two file scope declarations:\nint f(int (*)(), double (*)[3]);\nint f(int (*)(char *), double (*)[]); // C23: Error: conflicting types for 'f'\n// The resulting composite type for the function is:\nint f(int (*)(char *), double (*)[3]);\n```\n\nFor an identifier with internal or external [linkage](storage_duration \"c/language/storage duration\") declared in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.\n\n### Incomplete types\n\nAn incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.\n\nThe following types are incomplete:\n\n- the type `void`. This type cannot be completed.\n- array type of unknown size. It can be completed by a later declaration that specifies the size.\n\n```\nextern char a[]; // the type of a is incomplete (this typically appears in a header)\nchar a[10];      // the type of a is now complete (this typically appears in a source file)\n```\n\n- structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope.\n\n```\nstruct node\n{\n    struct node *next; // struct node is incomplete at this point\n}; // struct node is complete at this point\n```\n\n### Type names\n\nA type may have to be named in context other than the [declaration](declarations \"c/language/declarations\"). In these situations, *type name* is used, which is, grammatically, exactly the same as a list of *type-specifiers* and *type-qualifiers*, followed by the *declarator* (see [declarations](declarations \"c/language/declarations\")) as would be used to declare a single object or function of this type, except that the identifier is omitted:\n\n```\nint n; // declaration of an int\nsizeof(int); // use of type name\n \nint *a[3]; // declaration of an array of 3 pointers to int\nsizeof(int *[3]); // use of type name\n \nint (*p)[3]; // declaration of a pointer to array of 3 int\nsizeof(int (*)[3]); // use of type name\n \nint (*a)[*] // declaration of pointer to VLA (in a function parameter)\nsizeof(int (*)[*]) // use of type name (in a function parameter)\n \nint *f(void); // declaration of function\nsizeof(int *(void)); // use of type name\n \nint (*p)(void); // declaration of pointer to function\nsizeof(int (*)(void)); // use of type name\n \nint (*const a[])(unsigned int, ...) = {0}; // array of pointers to functions\nsizeof(int (*const [])(unsigned int, ...)); // use of type name\n```\n\nExcept the redundant parentheses around the identifier are meaningful in a type-name and represent \"function with no parameter specification\":\n\n```\nint (n); // declares n of type int\nsizeof(int ()); // uses type \"function returning int\"\n```\n\nType names are used in the following situations:\n\n- [cast](cast \"c/language/cast\")\n- [sizeof](sizeof \"c/language/sizeof\")\n\n[TABLE]\n\n  \nA type name may introduce a new type:\n\n```\nvoid* p = (void*)(struct X { int i; } *)0;\n// type name \"struct X {int i;}*\" used in the cast expression\n// introduces the new type \"struct X\"\nstruct X x = {1}; // struct X is now in scope\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.2.5 Types (p: TBD)\n  - 6.2.6 Representations of types (p: TBD)\n  - 6.2.7 Compatible type and composite type (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.2.5 Types (p: 31-33)\n  - 6.2.6 Representations of types (p: 31-35)\n  - 6.2.7 Compatible type and composite type (p: 35-36)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.2.5 Types (p: 39-43)\n  - 6.2.6 Representations of types (p: 44-46)\n  - 6.2.7 Compatible type and composite type (p: 47-48)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.2.5 Types (p: 33-37)\n  - 6.2.6 Representations of types (p: 37-40)\n  - 6.2.7 Compatible type and composite type (p: 40-41)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.2.5 Types\n  - 3.1.2.6 Compatible type and composite type\n\n### See also\n\n|                                                                                                   |     |\n|---------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/type \"cpp/language/type\") for Type |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/compatible_type](https://en.cppreference.com/w/c/language/compatible_type)"
- name: Type
  summary: (See also arithmetic types for the details on most built-in types and the list of type-related utilities that are provided by the C library.)
  description: "# Type\n\n(See also [arithmetic types](arithmetic_types \"c/language/arithmetic types\") for the details on most built-in types and [the list of type-related utilities](../types \"c/types\") that are provided by the C library.)\n\n[Objects](object \"c/language/object\"), [functions](functions \"c/language/functions\"), and [expressions](expressions \"c/language/expressions\") have a property called *type*, which determines the interpretation of the binary value stored in an object or evaluated by the expression.\n\n### Type classification\n\nThe C type system consists of the following types:\n\n- the type `void`\n- basic types\n- the type `char`\n- signed integer types\n  - standard: `signed char`, `short`, `int`, `long`, `long long`(since C99)\n\n[TABLE]\n\n- unsigned integer types\n  - standard: `_Bool`,(since C99) `unsigned char`, `unsigned short`, `unsigned int`, `unsigned long`, `unsigned long long`(since C99)\n\n[TABLE]\n\n- floating-point types\n  - real floating-point types: `float`, `double`, `long double`\n\n[TABLE]\n\n- [enumerated types](enum \"c/language/enum\")\n- derived types\n  - [array types](array \"c/language/array\")\n  - [structure types](struct \"c/language/struct\")\n  - [union types](union \"c/language/union\")\n  - [function types](functions \"c/language/functions\")\n  - [pointer types](pointer \"c/language/pointer\")\n\n[TABLE]\n\nFor every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the [`const`](const \"c/language/const\"), [`volatile`](volatile \"c/language/volatile\"), and [`restrict`](restrict \"c/language/restrict\") qualifiers (where allowed by the qualifier's semantics).\n\n#### Type groups\n\n- *object types*: all types that aren't function types\n- *character types*: `char`, `signed char`, `unsigned char`\n- *integer types*: `char`, signed integer types, unsigned integer types, enumerated types\n- *real types*: integer types and real floating types\n- [arithmetic types](arithmetic_types \"c/language/arithmetic types\"): integer types and floating types\n- *scalar types*: arithmetic types, pointer types, and [`nullptr_t`](../types/nullptr_t \"c/types/nullptr t\")(since C23)\n- *aggregate types*: array types and structure types\n- *derived declarator types*: array types, function types, and pointer types\n\nConstructing a complete object type such that the number of bytes in its object representation is not representable in the type [`size_t`](../types/size_t \"c/types/size t\") (i.e. the result type of [`sizeof`](sizeof \"c/language/sizeof\") operator), including forming such a VLA type at runtime,(since C99) is undefined behavior.\n\n### Compatible types\n\nIn a C program, the declarations referring to the same object or function in *different translation units* do not have to use the same type. They only have to use sufficiently similar types, formally known as *compatible types*. Same applies to function calls and lvalue accesses; argument types must be *compatible* with parameter types and lvalue expression type must be *compatible* with the object type that is accessed.\n\nThe types `T` and `U` are compatible, if\n\n- they are the same type (same name or aliases introduced by a [`typedef`](typedef \"c/language/typedef\"))\n- they are identically cvr-qualified versions of compatible unqualified types\n- they are pointer types and are pointing to compatible types\n- they are array types, and\n  - their element types are compatible, and\n  - if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. VLA is compatible with any array of compatible element type.(since C99)\n- they are both structure/union/enumeration types, and\n- (C99)if one is declared with a tag, the other must also be declared with the same tag.\n- if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names.\n- additionally, if they are enumerations, corresponding members must also have the same values.\n- additionally, if they are structures or unions,\n  - Corresponding members must be declared in the same order (structures only)\n  - Corresponding [bit-fields](bit_field \"c/language/bit field\") must have the same widths.\n- one is an enumerated type and the other is that enumeration's underlying type\n- they are function types, and\n  - their return types are compatible\n  - they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, and the corresponding parameter, after applying array-to-pointer and function-to-pointer type adjustments and after stripping top-level qualifiers, have compatible types\n\n[TABLE]\n\nThe type `char` is not compatible with `signed char` and not compatible with `unsigned char`.\n\nIf two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.\n\n```\n// Translation Unit 1\nstruct S { int a; };\nextern struct S *x; // compatible with TU2's x, but not with TU3's x\n \n// Translation Unit 2\nstruct S;\nextern struct S *x; // compatible with both x's\n \n// Translation Unit 3\nstruct S { float a; };\nextern struct S *x; // compatible with TU2's x, but not with TU1's x\n \n// the behavior is undefined\n```\n\n```\n// Translation Unit 1\n#include <stdio.h>\n \nstruct s { int i; }; // compatible with TU3's s, but not TU2's\nextern struct s x = {0}; // compatible with TU3's x\nextern void f(void); // compatible with TU2's f\n \nint main()\n{\n    f();\n    return x.i;\n}\n \n// Translation Unit 2\nstruct s { float f; }; // compatible with TU4's s, but not TU1's s\nextern struct s y = {3.14}; // compatible with TU4's y\nvoid f() // compatible with TU1's f\n{\n    return;\n}\n \n// Translation Unit 3\nstruct s { int i; }; // compatible with TU1's s, but not TU2's s\nextern struct s x; // compatible with TU1's x\n \n// Translation Unit 4\nstruct s { float f; }; // compatible with TU2's s, but not TU1's s\nextern struct s y; // compatible with TU2's y\n \n// the behavior is well-defined: only multiple declarations\n// of objects and functions must have compatible types, not the types themselves\n```\n\nNote: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.\n\n### Composite types\n\nA composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:\n\n- If both types are array types, the following rules are applied:\n  - If one type is an array of known constant size, the composite type is an array of that size.\n\n[TABLE]\n\n- Otherwise, both types are arrays of unknown size and the composite type is an array of unknown size.\n\nThe element type of the composite type is the composite type of the two element types.\n\n[TABLE]\n\n- If both types are function types with parameter type lists, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters.\n\nThese rules apply recursively to the types from which the two types are derived.\n\n```\n// Given the following two file scope declarations:\nint f(int (*)(), double (*)[3]);\nint f(int (*)(char *), double (*)[]); // C23: Error: conflicting types for 'f'\n// The resulting composite type for the function is:\nint f(int (*)(char *), double (*)[3]);\n```\n\nFor an identifier with internal or external [linkage](storage_duration \"c/language/storage duration\") declared in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.\n\n### Incomplete types\n\nAn incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.\n\nThe following types are incomplete:\n\n- the type `void`. This type cannot be completed.\n- array type of unknown size. It can be completed by a later declaration that specifies the size.\n\n```\nextern char a[]; // the type of a is incomplete (this typically appears in a header)\nchar a[10];      // the type of a is now complete (this typically appears in a source file)\n```\n\n- structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope.\n\n```\nstruct node\n{\n    struct node *next; // struct node is incomplete at this point\n}; // struct node is complete at this point\n```\n\n### Type names\n\nA type may have to be named in context other than the [declaration](declarations \"c/language/declarations\"). In these situations, *type name* is used, which is, grammatically, exactly the same as a list of *type-specifiers* and *type-qualifiers*, followed by the *declarator* (see [declarations](declarations \"c/language/declarations\")) as would be used to declare a single object or function of this type, except that the identifier is omitted:\n\n```\nint n; // declaration of an int\nsizeof(int); // use of type name\n \nint *a[3]; // declaration of an array of 3 pointers to int\nsizeof(int *[3]); // use of type name\n \nint (*p)[3]; // declaration of a pointer to array of 3 int\nsizeof(int (*)[3]); // use of type name\n \nint (*a)[*] // declaration of pointer to VLA (in a function parameter)\nsizeof(int (*)[*]) // use of type name (in a function parameter)\n \nint *f(void); // declaration of function\nsizeof(int *(void)); // use of type name\n \nint (*p)(void); // declaration of pointer to function\nsizeof(int (*)(void)); // use of type name\n \nint (*const a[])(unsigned int, ...) = {0}; // array of pointers to functions\nsizeof(int (*const [])(unsigned int, ...)); // use of type name\n```\n\nExcept the redundant parentheses around the identifier are meaningful in a type-name and represent \"function with no parameter specification\":\n\n```\nint (n); // declares n of type int\nsizeof(int ()); // uses type \"function returning int\"\n```\n\nType names are used in the following situations:\n\n- [cast](cast \"c/language/cast\")\n- [sizeof](sizeof \"c/language/sizeof\")\n\n[TABLE]\n\n  \nA type name may introduce a new type:\n\n```\nvoid* p = (void*)(struct X { int i; } *)0;\n// type name \"struct X {int i;}*\" used in the cast expression\n// introduces the new type \"struct X\"\nstruct X x = {1}; // struct X is now in scope\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.2.5 Types (p: TBD)\n  - 6.2.6 Representations of types (p: TBD)\n  - 6.2.7 Compatible type and composite type (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.2.5 Types (p: 31-33)\n  - 6.2.6 Representations of types (p: 31-35)\n  - 6.2.7 Compatible type and composite type (p: 35-36)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.2.5 Types (p: 39-43)\n  - 6.2.6 Representations of types (p: 44-46)\n  - 6.2.7 Compatible type and composite type (p: 47-48)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.2.5 Types (p: 33-37)\n  - 6.2.6 Representations of types (p: 37-40)\n  - 6.2.7 Compatible type and composite type (p: 40-41)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.2.5 Types\n  - 3.1.2.6 Compatible type and composite type\n\n### See also\n\n|                                                                                                   |     |\n|---------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/type \"cpp/language/type\") for Type |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/types](https://en.cppreference.com/w/c/language/types)"
- name: Type
  summary: (See also arithmetic types for the details on most built-in types and the list of type-related utilities that are provided by the C library.)
  description: "# Type\n\n(See also [arithmetic types](arithmetic_types \"c/language/arithmetic types\") for the details on most built-in types and [the list of type-related utilities](../types \"c/types\") that are provided by the C library.)\n\n[Objects](object \"c/language/object\"), [functions](functions \"c/language/functions\"), and [expressions](expressions \"c/language/expressions\") have a property called *type*, which determines the interpretation of the binary value stored in an object or evaluated by the expression.\n\n### Type classification\n\nThe C type system consists of the following types:\n\n- the type `void`\n- basic types\n- the type `char`\n- signed integer types\n  - standard: `signed char`, `short`, `int`, `long`, `long long`(since C99)\n\n[TABLE]\n\n- unsigned integer types\n  - standard: `_Bool`,(since C99) `unsigned char`, `unsigned short`, `unsigned int`, `unsigned long`, `unsigned long long`(since C99)\n\n[TABLE]\n\n- floating-point types\n  - real floating-point types: `float`, `double`, `long double`\n\n[TABLE]\n\n- [enumerated types](enum \"c/language/enum\")\n- derived types\n  - [array types](array \"c/language/array\")\n  - [structure types](struct \"c/language/struct\")\n  - [union types](union \"c/language/union\")\n  - [function types](functions \"c/language/functions\")\n  - [pointer types](pointer \"c/language/pointer\")\n\n[TABLE]\n\nFor every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the [`const`](const \"c/language/const\"), [`volatile`](volatile \"c/language/volatile\"), and [`restrict`](restrict \"c/language/restrict\") qualifiers (where allowed by the qualifier's semantics).\n\n#### Type groups\n\n- *object types*: all types that aren't function types\n- *character types*: `char`, `signed char`, `unsigned char`\n- *integer types*: `char`, signed integer types, unsigned integer types, enumerated types\n- *real types*: integer types and real floating types\n- [arithmetic types](arithmetic_types \"c/language/arithmetic types\"): integer types and floating types\n- *scalar types*: arithmetic types, pointer types, and [`nullptr_t`](../types/nullptr_t \"c/types/nullptr t\")(since C23)\n- *aggregate types*: array types and structure types\n- *derived declarator types*: array types, function types, and pointer types\n\nConstructing a complete object type such that the number of bytes in its object representation is not representable in the type [`size_t`](../types/size_t \"c/types/size t\") (i.e. the result type of [`sizeof`](sizeof \"c/language/sizeof\") operator), including forming such a VLA type at runtime,(since C99) is undefined behavior.\n\n### Compatible types\n\nIn a C program, the declarations referring to the same object or function in *different translation units* do not have to use the same type. They only have to use sufficiently similar types, formally known as *compatible types*. Same applies to function calls and lvalue accesses; argument types must be *compatible* with parameter types and lvalue expression type must be *compatible* with the object type that is accessed.\n\nThe types `T` and `U` are compatible, if\n\n- they are the same type (same name or aliases introduced by a [`typedef`](typedef \"c/language/typedef\"))\n- they are identically cvr-qualified versions of compatible unqualified types\n- they are pointer types and are pointing to compatible types\n- they are array types, and\n  - their element types are compatible, and\n  - if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. VLA is compatible with any array of compatible element type.(since C99)\n- they are both structure/union/enumeration types, and\n- (C99)if one is declared with a tag, the other must also be declared with the same tag.\n- if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names.\n- additionally, if they are enumerations, corresponding members must also have the same values.\n- additionally, if they are structures or unions,\n  - Corresponding members must be declared in the same order (structures only)\n  - Corresponding [bit-fields](bit_field \"c/language/bit field\") must have the same widths.\n- one is an enumerated type and the other is that enumeration's underlying type\n- they are function types, and\n  - their return types are compatible\n  - they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, and the corresponding parameter, after applying array-to-pointer and function-to-pointer type adjustments and after stripping top-level qualifiers, have compatible types\n\n[TABLE]\n\nThe type `char` is not compatible with `signed char` and not compatible with `unsigned char`.\n\nIf two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.\n\n```\n// Translation Unit 1\nstruct S { int a; };\nextern struct S *x; // compatible with TU2's x, but not with TU3's x\n \n// Translation Unit 2\nstruct S;\nextern struct S *x; // compatible with both x's\n \n// Translation Unit 3\nstruct S { float a; };\nextern struct S *x; // compatible with TU2's x, but not with TU1's x\n \n// the behavior is undefined\n```\n\n```\n// Translation Unit 1\n#include <stdio.h>\n \nstruct s { int i; }; // compatible with TU3's s, but not TU2's\nextern struct s x = {0}; // compatible with TU3's x\nextern void f(void); // compatible with TU2's f\n \nint main()\n{\n    f();\n    return x.i;\n}\n \n// Translation Unit 2\nstruct s { float f; }; // compatible with TU4's s, but not TU1's s\nextern struct s y = {3.14}; // compatible with TU4's y\nvoid f() // compatible with TU1's f\n{\n    return;\n}\n \n// Translation Unit 3\nstruct s { int i; }; // compatible with TU1's s, but not TU2's s\nextern struct s x; // compatible with TU1's x\n \n// Translation Unit 4\nstruct s { float f; }; // compatible with TU2's s, but not TU1's s\nextern struct s y; // compatible with TU2's y\n \n// the behavior is well-defined: only multiple declarations\n// of objects and functions must have compatible types, not the types themselves\n```\n\nNote: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.\n\n### Composite types\n\nA composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:\n\n- If both types are array types, the following rules are applied:\n  - If one type is an array of known constant size, the composite type is an array of that size.\n\n[TABLE]\n\n- Otherwise, both types are arrays of unknown size and the composite type is an array of unknown size.\n\nThe element type of the composite type is the composite type of the two element types.\n\n[TABLE]\n\n- If both types are function types with parameter type lists, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters.\n\nThese rules apply recursively to the types from which the two types are derived.\n\n```\n// Given the following two file scope declarations:\nint f(int (*)(), double (*)[3]);\nint f(int (*)(char *), double (*)[]); // C23: Error: conflicting types for 'f'\n// The resulting composite type for the function is:\nint f(int (*)(char *), double (*)[3]);\n```\n\nFor an identifier with internal or external [linkage](storage_duration \"c/language/storage duration\") declared in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.\n\n### Incomplete types\n\nAn incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.\n\nThe following types are incomplete:\n\n- the type `void`. This type cannot be completed.\n- array type of unknown size. It can be completed by a later declaration that specifies the size.\n\n```\nextern char a[]; // the type of a is incomplete (this typically appears in a header)\nchar a[10];      // the type of a is now complete (this typically appears in a source file)\n```\n\n- structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope.\n\n```\nstruct node\n{\n    struct node *next; // struct node is incomplete at this point\n}; // struct node is complete at this point\n```\n\n### Type names\n\nA type may have to be named in context other than the [declaration](declarations \"c/language/declarations\"). In these situations, *type name* is used, which is, grammatically, exactly the same as a list of *type-specifiers* and *type-qualifiers*, followed by the *declarator* (see [declarations](declarations \"c/language/declarations\")) as would be used to declare a single object or function of this type, except that the identifier is omitted:\n\n```\nint n; // declaration of an int\nsizeof(int); // use of type name\n \nint *a[3]; // declaration of an array of 3 pointers to int\nsizeof(int *[3]); // use of type name\n \nint (*p)[3]; // declaration of a pointer to array of 3 int\nsizeof(int (*)[3]); // use of type name\n \nint (*a)[*] // declaration of pointer to VLA (in a function parameter)\nsizeof(int (*)[*]) // use of type name (in a function parameter)\n \nint *f(void); // declaration of function\nsizeof(int *(void)); // use of type name\n \nint (*p)(void); // declaration of pointer to function\nsizeof(int (*)(void)); // use of type name\n \nint (*const a[])(unsigned int, ...) = {0}; // array of pointers to functions\nsizeof(int (*const [])(unsigned int, ...)); // use of type name\n```\n\nExcept the redundant parentheses around the identifier are meaningful in a type-name and represent \"function with no parameter specification\":\n\n```\nint (n); // declares n of type int\nsizeof(int ()); // uses type \"function returning int\"\n```\n\nType names are used in the following situations:\n\n- [cast](cast \"c/language/cast\")\n- [sizeof](sizeof \"c/language/sizeof\")\n\n[TABLE]\n\n  \nA type name may introduce a new type:\n\n```\nvoid* p = (void*)(struct X { int i; } *)0;\n// type name \"struct X {int i;}*\" used in the cast expression\n// introduces the new type \"struct X\"\nstruct X x = {1}; // struct X is now in scope\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.2.5 Types (p: TBD)\n  - 6.2.6 Representations of types (p: TBD)\n  - 6.2.7 Compatible type and composite type (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.2.5 Types (p: 31-33)\n  - 6.2.6 Representations of types (p: 31-35)\n  - 6.2.7 Compatible type and composite type (p: 35-36)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.2.5 Types (p: 39-43)\n  - 6.2.6 Representations of types (p: 44-46)\n  - 6.2.7 Compatible type and composite type (p: 47-48)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.2.5 Types (p: 33-37)\n  - 6.2.6 Representations of types (p: 37-40)\n  - 6.2.7 Compatible type and composite type (p: 40-41)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.1.2.5 Types\n  - 3.1.2.6 Compatible type and composite type\n\n### See also\n\n|                                                                                                   |     |\n|---------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/type \"cpp/language/type\") for Type |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/type](https://en.cppreference.com/w/c/language/type)"
- name: Type support
  summary: See also  type system overview and  arithmetic types defined by the language
  description: "# Type support\n\nSee also [type system overview](language/types \"c/language/types\") and [arithmetic types defined by the language](language/arithmetic_types \"c/language/arithmetic types\").\n\n### Basic types\n\n#### Additional basic types and convenience macros\n\n[TABLE]\n\n#### [Fixed width integer types](types/integer \"c/types/integer\") (since C99)\n\n#### [Numeric limits](types/limits \"c/types/limits\")\n\n### Notes\n\n[TABLE]\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdalign.h>\n \nint main(void)\n{\n    printf(\"%d %d %d\\n\", true && false, true || false, !false);\n    printf(\"%d %d\\n\", true ^ true, true + true);\n    printf(\"%zu\\n\", alignof(short));\n}\n```\n\nPossible output:\n\n```\n0 1 1\n0 2\n2\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.15 Alignment \\<stdalign.h\\> (p: 196)\n  - 7.18 Boolean type and values \\<stdbool.h\\> (p: 210)\n  - 7.19 Common definitions \\<stddef.h\\> (p: 211)\n  - 7.23 \\_Noreturn \\<stdnoreturn.h\\> (p: 263)\n  - 7.31.9 Boolean type and values \\<stdbool.h\\> (p: 332)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.15 Alignment \\<stdalign.h\\> (p: 268)\n  - 7.18 Boolean type and values \\<stdbool.h\\> (p: 287)\n  - 7.19 Common definitions \\<stddef.h\\> (p: 288)\n  - 7.23 \\_Noreturn \\<stdnoreturn.h\\> (p: 361)\n  - 7.31.9 Boolean type and values \\<stdbool.h\\> (p: 456)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.18 Boolean type and values \\<stdbool.h\\> (p: 253)\n  - 7.19 Common definitions \\<stddef.h\\> (p: 254)\n  - 7.26.7 Boolean type and values \\<stdbool.h\\> (p: 401)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.1.5 Common definitions \\<stddef.h\\>\n\n### See also\n\n|                                                                                                   |     |\n|---------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/types \"cpp/types\") for Type support library |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/types](https://en.cppreference.com/w/c/types)"
- name: Type-generic math
  summary: The header <tgmath.h> includes the headers <math.h> and <complex.h> and defines several type-generic macros that determine which real or, when applicable, complex function to call based on the types of the arguments
  description: "# Type-generic math\n\nThe header `<tgmath.h>` includes the headers `<math.h>` and `<complex.h>` and defines several type-generic macros that determine which real or, when applicable, complex function to call based on the types of the arguments.\n\nFor each macro, the parameters whose corresponding real type in the unsuffixed math.h function is `double` are known as *generic parameters* (for example, both parameters of [`pow`](math/pow \"c/numeric/math/pow\") are generic parameters, but only the first parameter of [`scalbn`](math/scalbn \"c/numeric/math/scalbn\") is a generic parameter).\n\nWhen a `<tgmath.h>` macro is used the types of the arguments passed to the generic parameters determine which function is selected by the macro as described below. If the types of the arguments are not [compatible](../language/type#Compatible_types \"c/language/type\") with the parameter types of the selected function, the behavior is undefined (e.g. if a complex argument is passed into a real-only `<tgmath.h>`'s macro: `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex)` fc``;`` `[`ceil`](http://en.cppreference.com/w/c/numeric/math/ceil)`(``fc``)``;` or `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex)` dc``;`` ``double`` d``;`` `[`fmax`](http://en.cppreference.com/w/c/numeric/math/fmax)`(``dc, d``)``;` are examples of undefined behavior).\n\nNote: type-generic macros were implemented in implementation-defined manner in C99, but C11 keyword [`_Generic`](../keyword/_generic \"c/keyword/ Generic\") makes it possible to implement these macros in portable manner.\n\n### Complex/real type-generic macros\n\nFor all functions that have both real and complex counterparts, a type-generic macro `XXX` exists, which calls either of:\n\n- real function:\n  - `float` variant `XXXf`\n  - `double` variant `XXX`\n  - `long double` variant `XXXl`\n- complex function:\n  - `float` variant `cXXXf`\n  - `double` variant `cXXX`\n  - `long double` variant `cXXXl`\n\nAn exception to the above rule is the `fabs` macro (see the table below).\n\nThe function to call is determined as follows:\n\n- If any of the arguments for the generic parameters is imaginary, the behavior is specified on each function reference page individually (in particular, `sin`, `cos`, `tag`, `cosh`, `sinh`, `tanh`, `asin`, `atan`, `asinh`, and `atanh` call *real* functions, the return types of `sin`, `tan`, `sinh`, `tanh`, `asin`, `atan`, `asinh`, and `atanh` are imaginary, and the return types of `cos` and `cosh` are real).\n- If any of the arguments for the generic parameters is complex, then the complex function is called, otherwise the real function is called.\n- If any of the arguments for the generic parameters is `long double`, then the `long double` variant is called. Otherwise, if any of the parameters is `double` or integer, then the `double` variant is called. Otherwise, `float` variant is called.\n\nThe type-generic macros are as follows:\n\n[TABLE]\n\n### Real-only functions\n\nFor all functions that do not have complex counterparts, with the exception of `modf`, a type-generic macro `XXX` exists, which calls either of the variants of a real function:\n\n- `float` variant `XXXf`\n- `double` variant `XXX`\n- `long double` variant `XXXl`\n\nThe function to call is determined as follows:\n\n- If any of the arguments for the generic parameters is `long double`, then the `long double` variant is called. Otherwise, if any of the arguments for the generic parameters is `double`, then the `double` variant is called. Otherwise, `float` variant is called.\n\n[TABLE]\n\n### Complex-only functions\n\nFor all complex number functions that do not have real counterparts, a type-generic macro `cXXX` exists, which calls either of the variants of a complex function:\n\n- `float`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) variant `cXXXf`\n- `double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) variant `cXXX`\n- `long`` ``double`` `[`complex`](http://en.cppreference.com/w/c/numeric/complex/complex) variant `cXXXl`\n\nThe function to call is determined as follows:\n\n- If any of the arguments for the generic parameters is real, complex, or imaginary, then the appropriate complex function is called.\n\n[TABLE]\n\n### Example\n\n```\n#include <stdio.h>\n#include <tgmath.h>\n \nint main(void)\n{\n    int i = 2;\n    printf(\"sqrt(2) = %f\\n\", sqrt(i)); // argument type is int, calls sqrt\n \n    float f = 0.5;\n    printf(\"sin(0.5f) = %f\\n\", sin(f));   // argument type is float, calls sinf\n \n    float complex dc = 1 + 0.5*I;\n    float complex z = sqrt(dc);      // argument type is float complex, calls csqrtf\n    printf(\"sqrt(1 + 0.5i) = %f+%fi\\n\",\n           creal(z),  // argument type is float complex, calls crealf\n           cimag(z)); // argument type is float complex, calls cimagf\n}\n```\n\nOutput:\n\n```\nsqrt(2) = 1.414214\nsin(0.5f) = 0.479426\nsqrt(1 + 0.5i) = 1.029086+0.242934i\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 272-273)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.25 Type-generic math \\<tgmath.h\\> (p: 373-375)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.22 Type-generic math \\<tgmath.h\\> (p: 335-337)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/numeric/tgmath](https://en.cppreference.com/w/c/numeric/tgmath)"
- name: typedef
  summary: ''
  description: "# C keywords: typedef\n\n### Usage\n\n- [`typedef` declaration](../language/typedef \"c/language/typedef\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/typedef](https://en.cppreference.com/w/c/keyword/typedef)"
- name: Typedef declaration
  summary: The typedef declaration provides a way to declare an identifier as a type alias, to be used to replace a possibly complex type name
  description: "# Typedef declaration\n\nThe *typedef declaration* provides a way to declare an identifier as a type alias, to be used to replace a possibly complex [type name](type#Type_names \"c/language/type\")\n\nThe keyword `typedef` is used in a [declaration](declarations \"c/language/declarations\"), in the grammatical position of a [storage-class specifier](storage_duration \"c/language/storage duration\"), except that it does not affect storage or linkage:\n\n```\ntypedef int int_t; // declares int_t to be an alias for the type int\ntypedef char char_t, *char_p, (*fp)(void); // declares char_t to be an alias for char\n                                           // char_p to be an alias for char*\n                                           // fp to be an alias for char(*)(void)\n```\n\n### Explanation\n\nIf a [declaration](declarations \"c/language/declarations\") uses `typedef` as storage-class specifier, every declarator in it defines an identifier as an alias to the type specified. Since only one storage-class specifier is permitted in a declaration, typedef declaration cannot be [static or extern](storage_duration \"c/language/storage duration\").\n\ntypedef declaration does not introduce a distinct type, it only establishes a synonym for an existing type, thus typedef names are [compatible](type#Compatible_types \"c/language/type\") with the types they alias. Typedef names share the [name space](name_space \"c/language/name space\") with ordinary identifiers such as enumerators, variables and function.\n\n[TABLE]\n\n### Notes\n\ntypedef name may be an [incomplete type](type#Incomplete_types \"c/language/type\"), which may be completed as usual:\n\n```\ntypedef int A[]; // A is int[]\nA a = {1, 2}, b = {3,4,5}; // type of a is int[2], type of b is int[3]\n```\n\ntypedef declarations are often used to inject names from the tag [name space](name_space \"c/language/name space\") into the ordinary name space:\n\n```\ntypedef struct tnode tnode; // tnode in ordinary name space\n                            // is an alias to tnode in tag name space\nstruct tnode {\n    int count;\n    tnode *left, *right; // same as struct tnode *left, *right;\n}; // now tnode is also a complete type\ntnode s, *sp; // same as struct tnode s, *sp;\n```\n\nThey can even avoid using the tag name space at all:\n\n```\ntypedef struct { double hi, lo; } range;\nrange z, *zp;\n```\n\nTypedef names are also commonly used to simplify the syntax of complex declarations:\n\n```\n// array of 5 pointers to functions returning pointers to arrays of 3 ints\nint (*(*callbacks[5])(void))[3]\n \n// same with typedefs\ntypedef int arr_t[3]; // arr_t is array of 3 int\ntypedef arr_t* (*fp)(void); // pointer to function returning arr_t*\nfp callbacks[5];\n```\n\nLibraries often expose system-dependent or configuration-dependent types as typedef names, to present a consistent interface to the users or to other library components:\n\n```\n#if defined(_LP64)\ntypedef int     wchar_t;\n#else\ntypedef long    wchar_t;\n#endif\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.8 Type definitions (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.8 Type definitions (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.8 Type definitions (p: 137-138)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.7 Type definitions (p: 123-124)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.5.6 Type definitions\n\n### Keywords\n\n[`typedef`](../keyword/typedef \"c/keyword/typedef\")\n\n### See also\n\n|                                                                                                                          |     |\n|--------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/typedef \"cpp/language/typedef\") for `typedef` declaration |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/typedef](https://en.cppreference.com/w/c/language/typedef)"
- name: typeof
  summary: ''
  description: "# C keywords: typeof (since C23)\n\n### Usage\n\n- [`typeof` operator](../language/typeof \"c/language/typeof\") (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/typeof](https://en.cppreference.com/w/c/keyword/typeof)"
- name: typeof operators
  summary: Determines the type of an object
  description: "# typeof operators (since C23)\n\nDetermines the type of an object.\n\n### Syntax\n\n|                                 |       |     |\n|---------------------------------|-------|-----|\n| `typeof(` type `)`              | \\(1\\) |     |\n| `typeof(` expression `)`        | \\(2\\) |     |\n| `typeof_unqual(` type `)`       | \\(3\\) |     |\n| `typeof_unqual(` expression `)` | \\(4\\) |     |\n\n### Explanation\n\n1) produces the type-name with any nested typeof-specifier evaluated\n\n2) yields the type-name representing the type of its operand. No implicit conversions are applied to expression.\n\n3,4) the same as (1) and (2) respectively but remove qualifiers\n\n### Notes\n\n`typeof` and `typeof_unqual` are collectively called the *typeof operators*. The `typeof` operators cannot be applied to bit-field members. If the type of the operand is a variably modified type, the operand is evaluated; otherwise, the operand is not evaluated. The result of the `typeof_unqual` operator is the non-atomic unqualified type that would result from the `typeof` operator. The `typeof` operator preserves all qualifiers.\n\n### Example\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.2.5 The typeof specifiers (p: 115-118)\n\n### See also\n\n|                                                                                                                 |     |\n|-----------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/decltype \"cpp/language/decltype\") for `decltype` |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/typeof](https://en.cppreference.com/w/c/language/typeof)"
- name: typeof_unqual
  summary: ''
  description: "# C keywords: typeof_unqual (since C23)\n\n### Usage\n\n- [`typeof` operator](../language/typeof \"c/language/typeof\") that removes qualifiers (since C23)\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/typeof_unqual](https://en.cppreference.com/w/c/keyword/typeof_unqual)"
- name: Undefined behavior
  summary: 'The C language standard precisely specifies the observable behavior of C language programs, except for the ones in the following categories:'
  description: "# Undefined behavior\n\nThe C language standard precisely specifies the [observable behavior](as_if \"c/language/as if\") of C language programs, except for the ones in the following categories:\n\n- *undefined behavior* - there are no restrictions on the behavior of the program. Examples of undefined behavior are memory accesses outside of array bounds, signed integer overflow, null pointer dereference, modification of the same scalar [more than once](eval_order \"c/language/eval order\") in an expression without sequence points, access to an object through a pointer of a different type, etc. Compilers are not required to diagnose undefined behavior (although many simple situations are diagnosed), and the compiled program is not required to do anything meaningful.\n- *unspecified behavior* - two or more behaviors are permitted and the implementation is not required to document the effects of each behavior. For example, [order of evaluation](eval_order \"c/language/eval order\"), whether identical [string literals](string_literal \"c/language/string literal\") are distinct, etc. Each unspecified behavior results in one of a set of valid results and may produce a different result when repeated in the same program.\n- *implementation-defined behavior* - unspecified behavior where each implementation documents how the choice is made. For example, number of bits in a byte, or whether signed integer right shift is arithmetic or logical.\n- *locale-specific behavior* - implementation-defined behavior that depends on the [currently chosen locale](../locale/setlocale \"c/locale/setlocale\"). For example, whether [`islower`](../string/byte/islower \"c/string/byte/islower\") returns true for any character other than the 26 lowercase Latin letters.\n\n(Note: [Strictly conforming](conformance \"c/language/conformance\") programs do not depend on any unspecified, undefined, or implementation-defined behavior)\n\nThe compilers are required to issue diagnostic messages (either errors or warnings) for any programs that violates any C syntax rule or semantic constraint, even if its behavior is specified as undefined or implementation-defined or if the compiler provides a language extension that allows it to accept such program. Diagnostics for undefined behavior are not otherwise required.\n\n### UB and optimization\n\nBecause correct C programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:\n\nFor example,\n\n#### Signed overflow\n\n```\nint foo(int x)\n{\n    return x + 1 > x; // either true or UB due to signed overflow\n}\n```\n\nmay be compiled as ([demo](https://godbolt.org/z/9dh7b71TK))\n\n```\nfoo:\n        mov     eax, 1\n        ret\n```\n\n#### Access out of bounds\n\n```\nint table[4] = {0};\nint exists_in_table(int v)\n{\n    // return 1 in one of the first 4 iterations or UB due to out-of-bounds access\n    for (int i = 0; i <= 4; i++)\n        if (table[i] == v)\n            return 1;\n    return 0;\n}\n```\n\nMay be compiled as ([demo](https://godbolt.org/z/48bn19Tsb))\n\n```\nexists_in_table:\n        mov     eax, 1\n        ret\n```\n\n#### Uninitialized scalar\n\n```\n_Bool p; // uninitialized local variable\nif (p) // UB access to uninitialized scalar\n    puts(\"p is true\");\nif (!p) // UB access to uninitialized scalar\n    puts(\"p is false\");\n```\n\nMay produce the following output (observed with an older version of gcc):\n\n```\np is true\np is false\n```\n\n```\nsize_t f(int x)\n{\n    size_t a;\n    if (x) // either x nonzero or UB\n        a = 42;\n    return a;\n}\n```\n\nMay be compiled as ([demo](https://godbolt.org/z/9nz6EMPTG))\n\n```\nf:\n        mov     eax, 42\n        ret\n```\n\n#### Invalid scalar\n\n```\nint f(void)\n{\n    _Bool b = 0;\n    unsigned char* p = (unsigned char*)&b;\n    *p = 10;\n    // reading from b is now UB\n    return b == 0;\n}\n```\n\nMay be compiled as ([demo](https://godbolt.org/z/rjx77bjoh))\n\n```\nf:\n        mov     eax, 11\n        ret\n```\n\n#### Null pointer dereference\n\n```\nint foo(int* p)\n{\n    int x = *p;\n    if (!p)\n        return x; // Either UB above or this branch is never taken\n    else\n        return 0;\n}\n \nint bar()\n{\n    int* p = NULL;\n    return *p;    // Unconditional UB\n}\n```\n\nmay be compiled as ([demo](https://godbolt.org/z/8jnjMjcPz))\n\n```\nfoo:\n        xor     eax, eax\n        ret\nbar:\n        ret\n```\n\n#### Access to pointer passed to [`realloc`](../memory/realloc \"c/memory/realloc\")\n\nChoose clang to observe the output shown\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    int *p = (int*)malloc(sizeof(int));\n    int *q = (int*)realloc(p, sizeof(int));\n    *p = 1; // UB access to a pointer that was passed to realloc\n    *q = 2;\n    if (p == q) // UB access to a pointer that was passed to realloc\n        printf(\"%d%d\\n\", *p, *q);\n}\n```\n\nPossible output:\n\n```\n12\n```\n\n#### Infinite loop without side-effects\n\nChoose clang to observe the output shown\n\n```\n#include <stdio.h>\n \nint fermat()\n{\n    const int MAX = 1000;\n    // Endless loop with no side effects is UB\n    for (int a = 1, b = 1, c = 1; 1;)\n    {\n        if (((a * a * a) == ((b * b * b) + (c * c * c))))\n            return 1;\n        ++a;\n        if (a > MAX)\n        {\n            a = 1;\n            ++b;\n        }\n        if (b > MAX)\n        {\n            b = 1;\n            ++c;\n        }\n        if (c > MAX)\n            c = 1;\n    }\n    return 0;\n}\n \nint main(void)\n{\n    if (fermat())\n        puts(\"Fermat's Last Theorem has been disproved.\");\n    else\n        puts(\"Fermat's Last Theorem has not been disproved.\");\n}\n```\n\nPossible output:\n\n```\nFermat's Last Theorem has been disproved.\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 3.4 Behavior (p: TBD)\n  - 4 Conformance (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 3.4 Behavior (p: 3-4)\n  - 4 Conformance (p: 8)\n- C11 standard (ISO/IEC 9899:2011):\n  - 3.4 Behavior (p: 3-4)\n  - 4/2 Undefined behavior (p: 8)\n- C99 standard (ISO/IEC 9899:1999):\n  - 3.4 Behavior (p: 3-4)\n  - 4/2 Undefined behavior (p: 7)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 1.6 DEFINITIONS OF TERMS\n\n### External links\n\n|     |                                                                                                                                                                             |\n|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 1\\. | [What Every C Programmer Should Know About Undefined Behavior \\#1/3](https://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html)                                |\n| 2\\. | [What Every C Programmer Should Know About Undefined Behavior \\#2/3](https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html)                             |\n| 3\\. | [What Every C Programmer Should Know About Undefined Behavior \\#3/3](https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html)                             |\n| 4\\. | [Undefined behavior can result in time travel (among other things, but time travel is the funkiest)](https://blogs.msdn.com/b/oldnewthing/archive/2014/06/27/10537746.aspx) |\n| 5\\. | [Understanding Integer Overflow in C/C++](https://www.cs.utah.edu/~regehr/papers/overflow12.pdf)                                                                            |\n| 6\\. | [Undefined Behavior and Fermat’s Last Theorem](https://web.archive.org/web/20201108094235/https://kukuruku.co/post/undefined-behavior-and-fermats-last-theorem/)            |\n| 7\\. | [Fun with NULL pointers, part 1](https://lwn.net/Articles/342330/) (local exploit in Linux 2.6.30 caused by UB due to null pointer dereference)                             |\n\n### See also\n\n|                                                                                                             |     |\n|-------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/ub \"cpp/language/ub\") for Undefined behavior |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/behavior](https://en.cppreference.com/w/c/language/behavior)"
- name: ungetc
  summary: If ch does not equal EOF, pushes the character ch (reinterpreted as unsigned char) into the input buffer associated with the stream stream in such a manner that subsequent read operation from stream will retrieve that character
  description: "# ungetc\n\n[TABLE]\n\nIf `ch` does not equal [`EOF`](../io \"c/io\"), pushes the character `ch` (reinterpreted as `unsigned char`) into the input buffer associated with the stream `stream` in such a manner that subsequent read operation from `stream` will retrieve that character. The external device associated with the stream is not modified.\n\nStream repositioning operations [`fseek`](fseek \"c/io/fseek\"), [`fsetpos`](fsetpos \"c/io/fsetpos\"), and [`rewind`](rewind \"c/io/rewind\") discard the effects of `ungetc`.\n\nIf `ungetc` is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful `ungetc` were performed, read operations retrieve the pushed-back characters in reverse order of `ungetc`.\n\nIf `ch` equals [`EOF`](../io \"c/io\"), the operation fails and the stream is not affected.\n\nA successful call to `ungetc` clears the end of file status flag [`feof`](feof \"c/io/feof\").\n\nA successful call to `ungetc` on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).\n\nA successful call to `ungetc` on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before `ungetc`.\n\n### Parameters\n\n|        |     |                                                     |\n|--------|-----|-----------------------------------------------------|\n| ch     | \\-  | character to be pushed into the input stream buffer |\n| stream | \\-  | file stream to put the character back to            |\n\n### Return value\n\nOn success `ch` is returned.\n\nOn failure [`EOF`](../io \"c/io\") is returned and the given stream remains unchanged.\n\n### Notes\n\nThe size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).\n\nThe apparent size of the pushback buffer may be larger if the character that is pushed back equals the character existing at that location in the external character sequence (the implementation may simply decrement the read file position indicator and avoid maintaining a pushback buffer).\n\n### Example\n\ndemonstrates the original purpose of `ungetc`: implementation of [`scanf`](fscanf \"c/io/fscanf\")\n\n```\n#include <ctype.h>\n#include <stdio.h>\n \nvoid demo_scanf(const char* fmt, FILE* s)\n{\n    while (*fmt != '\\0') {\n        if (*fmt == '%') {\n            int c;\n            switch (*++fmt) {\n                case 'u':\n                    while (isspace(c=getc(s))) {}\n                    unsigned int num = 0;\n                    while (isdigit(c)) {\n                        num = num*10 + c-'0';\n                        c = getc(s);\n                    }\n                    printf(\"%%u scanned %u\\n\", num);\n                    ungetc(c, s);\n                    break;\n                case 'c':\n                    c = getc(s);\n                    printf(\"%%c scanned '%c'\\n\", c);\n                    break;\n            }\n        } else {\n            ++fmt;\n        }\n    }\n}\n \nint main(void)\n{\n    FILE* f = fopen(\"input.txt\", \"w+\");\n    if (f != NULL) {\n        fputs(\"123x\", f);\n        rewind(f); \n        demo_scanf(\"%u%c\", f);\n        fclose(f);\n    }\n    return 0;\n}\n```\n\nOutput:\n\n```\n%u scanned 123\n%c scanned 'x'\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.7.10 The ungetc function (p: 243)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.7.10 The ungetc function (p: 334)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.7.11 The ungetc function (p: 300)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.7.11 The ungetc function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/ungetc](https://en.cppreference.com/w/c/io/ungetc)"
- name: ungetwc
  summary: If ch does not equal WEOF, pushes the wide character ch into the input buffer associated with the stream stream in such a manner that subsequent read operation from stream will retrieve that wide character
  description: "# ungetwc\n\n[TABLE]\n\nIf `ch` does not equal `WEOF`, pushes the wide character `ch` into the input buffer associated with the stream `stream` in such a manner that subsequent read operation from `stream` will retrieve that wide character. The external device associated with the stream is not modified.\n\nStream repositioning operations [`fseek`](fseek \"c/io/fseek\"), [`fsetpos`](fsetpos \"c/io/fsetpos\"), and [`rewind`](rewind \"c/io/rewind\") discard the effects of `ungetwc`.\n\nIf `ungetwc` is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful `ungetwc` were performed, read operations retrieve the pushed-back wide characters in reverse order of `ungetwc`\n\nIf `ch` equals `WEOF`, the operation fails and the stream is not affected.\n\nA successful call to `ungetwc` clears the end of file status flag [`feof`](feof \"c/io/feof\").\n\nA successful call to `ungetwc` on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before `ungetwc`.\n\n### Parameters\n\n|        |     |                                               |\n|--------|-----|-----------------------------------------------|\n| ch     | \\-  | wide character to be put back                 |\n| stream | \\-  | file stream to put the wide character back to |\n\n### Return value\n\nOn success `ch` is returned.\n\nOn failure `WEOF` is returned and the given stream remains unchanged.\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.3.10 The ungetwc function (p: 425-426)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.3.10 The ungetwc function (p: 370-371)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/ungetwc](https://en.cppreference.com/w/c/io/ungetwc)"
- name: union
  summary: ''
  description: "# C keywords: union\n\n### Usage\n\n- [declaration of a union type](../language/union \"c/language/union\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/union](https://en.cppreference.com/w/c/keyword/union)"
- name: Union declaration
  summary: A union is a type consisting of a sequence of members whose storage overlaps (as opposed to struct, which is a type consisting of a sequence of members whose storage is allocated in an ordered sequence)
  description: "# Union declaration\n\nA union is a type consisting of a sequence of members whose storage overlaps (as opposed to struct, which is a type consisting of a sequence of members whose storage is allocated in an ordered sequence). The value of at most one of the members can be stored in a union at any one time.\n\nThe [type specifier](declarations \"c/language/declarations\") for a union is identical to the [`struct`](struct \"c/language/struct\") type specifier except for the keyword used:\n\n### Syntax\n\n|                                                                                  |       |     |\n|----------------------------------------------------------------------------------|-------|-----|\n| `union` attr-spec-seq \uFEFF(optional) name \uFEFF(optional) `{` struct-declaration-list `}` | \\(1\\) |     |\n| `union` attr-spec-seq \uFEFF(optional) name                                            | \\(2\\) |     |\n\n|                         |     |                                                                                                                                                                                                           |\n|-------------------------|-----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| name                    | \\-  | the name of the union that's being defined                                                                                                                                                                |\n| struct-declaration-list | \\-  | any number of variable declarations, [bit-field](bit_field \"c/language/bit field\") declarations, and static assert declarations. Members of incomplete type and members of function type are not allowed. |\n| attr-spec-seq           | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the union type, not allowed for (2) if such form is not followed by a `;` (i.e. not a forward declaration).            |\n\n### Explanation\n\nThe union is only as big as necessary to hold its largest member (additional unnamed trailing padding may also be added). The other members are allocated in the same bytes as part of that largest member.\n\nA pointer to a union can be cast to a pointer to each of its members (if a union has bit-field members, the pointer to a union can be cast to the pointer to the bit-field's underlying type). Likewise, a pointer to any member of a union can be cast to a pointer to the enclosing union.\n\n|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |             |\n|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If the member used to access the contents of a union is not the same as the member last used to store a value, the object representation of the value that was stored is reinterpreted as an object representation of the new type (this is known as *type punning*). If the size of the new type is larger than the size of the last-written type, the contents of the excess bytes are unspecified (and may be a trap representation). Before C99 TC3 (DR 283) this behaviour was undefined, but commonly implemented this way. | (since C99) |\n\n[TABLE]\n\n### Keywords\n\n[`union`](../keyword/union \"c/keyword/union\")\n\n### Notes\n\nSee [struct initialization](struct_initialization \"c/language/struct initialization\") for the rules about initialization of structs and unions.\n\n### Example\n\n```\n#include <assert.h>\n#include <stdint.h>\n#include <stdio.h>\n \nint main(void)\n{\n    union S\n    {\n        uint32_t u32;\n        uint16_t u16[2];\n        uint8_t  u8;\n    } s = {0x12345678}; // s.u32 is now the active member\n    printf(\"Union S has size %zu and holds %x\\n\", sizeof s, s.u32);\n    s.u16[0] = 0x0011;  // s.u16 is now the active member\n    // reading from s.u32 or from s.u8 reinterprets the object representation\n//  printf(\"s.u8 is now %x\\n\", s.u8); // unspecified, typically 11 or 00\n//  printf(\"s.u32 is now %x\\n\", s.u32); // unspecified, typically 12340011 or 00115678\n \n    // pointers to all members of a union compare equal to themselves and the union\n    assert((uint8_t*)&s == &s.u8);\n \n    // this union has 3 bytes of trailing padding\n    union pad\n    {\n       char  c[5];   // occupies 5 bytes\n       float f;      // occupies 4 bytes, imposes alignment 4\n    } p = {.f = 1.23}; // the size is 8 to satisfy float's alignment\n    printf(\"size of union of char[5] and float is %zu\\n\", sizeof p);\n}\n```\n\nPossible output:\n\n```\nUnion S has size 4 and holds 12345678\nsize of union of char[5] and float is 8\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 6.7.2.1 Structure and union specifiers (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.2.1 Structure and union specifiers (p: 81-84)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.2.1 Structure and union specifiers (p: 112-117)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.2.1 Structure and union specifiers (p: 101-104)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.5.2.1 Structure and union specifiers\n\n### See also\n\n|                                                                                                                  |     |\n|------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/union \"cpp/language/union\") for Union declaration |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/union](https://en.cppreference.com/w/c/language/union)"
- name: unreachable
  summary: The function-like macro unreachable expands to a void expression
  description: "# unreachable\n\n[TABLE]\n\nThe function-like macro `unreachable` expands to a `void` expression. Executing `unreachable()` results in [undefined behavior](../language/behavior \"c/language/behavior\").\n\nAn implementation may use this to optimize impossible code branches away (typically, in optimized builds) or to trap them to prevent further execution (typically, in debug builds).\n\n### Possible implementation\n\n[TABLE]\n\n### Example\n\n```\n#include <assert.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n \nstruct Color { uint8_t r, g, b, a; };\nstruct ColorSpan { struct Color* data; size_t size; };\n \n// Assume that only restricted set of texture caps is supported.\nstruct ColorSpan allocate_texture(size_t xy)\n{\n    switch (xy)\n    {\n    case 128: [[fallthrough]];\n    case 256: [[fallthrough]];\n    case 512:\n    {\n        /* ... */\n        struct ColorSpan result = {\n            .data = malloc(xy * xy * sizeof(struct Color)),\n            .size = xy * xy\n        };\n        if (!result.data)\n            result.size = 0;\n        return result;\n    }\n    default:\n        unreachable();\n    }\n}\n \nint main(void)\n{\n    struct ColorSpan tex = allocate_texture(128); // OK\n    assert(tex.size == 128 * 128);\n \n    struct ColorSpan badtex = allocate_texture(32);  // Undefined behavior\n \n    free(badtex.data);\n    free(tex.data);\n}\n```\n\nPossible output:\n\n```\nSegmentation fault\n```\n\n### See also\n\n|                                                                                                                        |     |\n|------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/utility/unreachable \"cpp/utility/unreachable\") for `unreachable` |     |\n\n### External Links\n\n|     |                                                                                                                                     |\n|-----|-------------------------------------------------------------------------------------------------------------------------------------|\n| 1\\. | [GCC docs: `__builtin_unreachable`](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-_005f_005fbuiltin_005funreachable) |\n| 2\\. | [Clang docs: `__builtin_unreachable`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-unreachable)                      |\n| 3\\. | [MSVC docs: `__assume`](https://docs.microsoft.com/en-us/cpp/intrinsics/assume)                                                     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/program/unreachable](https://en.cppreference.com/w/c/program/unreachable)"
- name: unsigned
  summary: ''
  description: "# C keywords: unsigned\n\n### Usage\n\n- [`unsigned` type modifier](../language/types \"c/language/types\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/unsigned](https://en.cppreference.com/w/c/keyword/unsigned)"
- name: va_arg
  summary: The va_arg macro expands to an expression of type T that corresponds to the next parameter from the va_list ap
  description: "# va_arg\n\n[TABLE]\n\nThe `va_arg` macro expands to an expression of type `T` that corresponds to the next parameter from the `va_list` `ap`.\n\nPrior to calling `va_arg`, `ap` must be initialized by a call to either `va_start` or `va_copy`, with no intervening call to `va_end`. Each invocation of the `va_arg` macro modifies `ap` to point to the next variable argument.\n\nIf the type of the next argument in `ap` (after promotions) is not compatible with `T`, the behavior is undefined, unless:\n\n- one type is a signed integer type, the other type is the corresponding unsigned integer type, and the value is representable in both types; or\n- one type is pointer to `void` and the other is a pointer to a character type.\n\nIf `va_arg` is called when there are no more arguments in `ap`, the behavior is undefined.\n\n### Parameters\n\n|     |     |                                        |\n|-----|-----|----------------------------------------|\n| ap  | \\-  | an instance of the `va_list` type      |\n| T   | \\-  | the type of the next parameter in `ap` |\n\n### Expanded value\n\nthe next variable parameter in `ap`\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n#include <math.h>\n \ndouble stddev(int count, ...) \n{\n    double sum = 0;\n    double sum_sq = 0;\n    va_list args;\n    va_start(args, count);\n    for (int i = 0; i < count; ++i) {\n        double num = va_arg(args, double);\n        sum += num;\n        sum_sq += num*num;\n    }\n    va_end(args);\n    return sqrt(sum_sq/count - (sum/count)*(sum/count));\n}\n \nint main(void) \n{\n    printf(\"%f\\n\", stddev(4, 25.0, 27.3, 26.9, 25.7));\n}\n```\n\nOutput:\n\n```\n0.920258\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.16.1.1 The va_arg macro (p: 269-270)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.15.1.1 The va_arg macro (p: 249-250)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.8.1.2 The va_arg macro\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/variadic/va_arg](https://en.cppreference.com/w/c/variadic/va_arg)"
- name: va_copy
  summary: The va_copy macro copies src to dest
  description: "# va_copy\n\n[TABLE]\n\nThe `va_copy` macro copies `src` to `dest`.\n\n`va_end` should be called on `dest` before the function returns or any subsequent re-initialization of `dest` (via calls to `va_start` or `va_copy`).\n\n### Parameters\n\n|      |     |                                                             |\n|------|-----|-------------------------------------------------------------|\n| dest | \\-  | an instance of the `va_list` type to initialize             |\n| src  | \\-  | the source `va_list` that will be used to initialize `dest` |\n\n### Expanded value\n\n(none)\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n#include <math.h>\n \ndouble sample_stddev(int count, ...) \n{\n    /* Compute the mean with args1. */\n    double sum = 0;\n    va_list args1;\n    va_start(args1, count);\n    va_list args2;\n    va_copy(args2, args1);   /* copy va_list object */\n    for (int i = 0; i < count; ++i) {\n        double num = va_arg(args1, double);\n        sum += num;\n    }\n    va_end(args1);\n    double mean = sum / count;\n \n    /* Compute standard deviation with args2 and mean. */\n    double sum_sq_diff = 0;\n    for (int i = 0; i < count; ++i) {\n        double num = va_arg(args2, double);\n        sum_sq_diff += (num-mean) * (num-mean);\n    }\n    va_end(args2);\n    return sqrt(sum_sq_diff / count);\n}\n \nint main(void) \n{\n    printf(\"%f\\n\", sample_stddev(4, 25.0, 27.3, 26.9, 25.7));\n}\n```\n\nPossible output:\n\n```\n0.920258\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.16.1.2 The va_copy macro (p: 270)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.15.1.2 The va_copy macro (p: 250)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/variadic/va_copy](https://en.cppreference.com/w/c/variadic/va_copy)"
- name: va_end
  summary: The va_end macro performs cleanup for an ap object initialized by a call to va_start or va_copy
  description: "# va_end\n\n[TABLE]\n\nThe `va_end` macro performs cleanup for an `ap` object initialized by a call to `va_start` or `va_copy`. `va_end` may modify `ap` so that it is no longer usable.\n\nIf there is no corresponding call to `va_start` or `va_copy`, or if `va_end` is not called before a function that calls `va_start` or `va_copy` returns, the behavior is undefined.\n\n### Parameters\n\n|     |     |                                               |\n|-----|-----|-----------------------------------------------|\n| ap  | \\-  | an instance of the `va_list` type to clean up |\n\n### Expanded value\n\n(none)\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.16.1.3 The va_end macro (p: 270-271)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.15.1.3 The va_end macro (p: 250-251)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.8.1.3 The va_end macro\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/variadic/va_end](https://en.cppreference.com/w/c/variadic/va_end)"
- name: va_list
  summary: va_list is a complete object type suitable for holding the information needed by the macros va_start, va_copy, va_arg, and va_end
  description: "# va_list\n\n[TABLE]\n\n`va_list` is a complete object type suitable for holding the information needed by the macros `va_start`, `va_copy`, `va_arg`, and `va_end`.\n\nIf a `va_list` instance is created, passed to another function, and used via `va_arg` in that function, then any subsequent use in the calling function should be preceded by a call to `va_end`.\n\nIt is legal to pass a pointer to a `va_list` object to another function and then use that object after the function returns.\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.16/3 Variable arguments \\<stdarg.h\\> (p: 269)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.15/3 Variable arguments \\<stdarg.h\\> (p: 249)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.8 VARIABLE ARGUMENTS \\<stdarg.h\\>\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/variadic/va_list](https://en.cppreference.com/w/c/variadic/va_list)"
- name: va_start
  summary: The va_start macro enables access to the variable arguments following the named argument parmN(until C23)
  description: "# va_start\n\n[TABLE]\n\nThe `va_start` macro enables access to the variable arguments following the named argument `parmN`(until C23).\n\n`va_start` shall be invoked with an instance to a valid `va_list` object `ap` before any calls to `va_arg`.\n\n|                                                                                                                                                                                                                                 |             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If `parmN` is declared with `register` storage class specifier, with an array type, with a function type, or with a type not compatible with the type that results from default argument promotions, the behavior is undefined. | (until C23) |\n| Only the first argument passed to `va_start` is evaluated. Any additional arguments are neither expanded nor used in any way.                                                                                                   | (since C23) |\n\n### Parameters\n\n|       |     |                                                            |\n|-------|-----|------------------------------------------------------------|\n| ap    | \\-  | an instance of the `va_list` type                          |\n| parmN | \\-  | the named parameter preceding the first variable parameter |\n\n### Expanded value\n\n(none)\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n \nint add_nums_C99(int count, ...)\n{\n    int result = 0;\n    va_list args;\n    va_start(args, count); // count can be omitted since C23\n \n    for (int i = 0; i < count; ++i) {\n        result += va_arg(args, int);\n    }\n \n    va_end(args);\n    return result;\n}\n \n#if __STDC_VERSION__ > 201710L\n// Same as above, valid since C23\nint add_nums_C23(...)\n{\n    int result = 0;\n    va_list args;\n    va_start(args);\n \n    int count = va_arg(args, int);\n    for (int i = 0; i < count; ++i) {\n        result += va_arg(args, int);\n    }\n \n    va_end(args);\n    return result;\n}\n#endif\n \nint main(void)\n{\n    printf(\"%d\\n\", add_nums_C99(4, 25, 25, 50, 50));\n#if __STDC_VERSION__ > 201710L\n    printf(\"%d\\n\", add_nums_C23(4, 25, 25, 50, 50));\n#endif\n}\n```\n\nPossible output:\n\n```\n150\n150\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.16.1.4 The va_start macro (p: 198-199)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.16.1.4 The va_start macro (p: 271-272)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.15.1.4 The va_start macro (p: 251-252)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.8.1.1 The va_start macro\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/variadic/va_start](https://en.cppreference.com/w/c/variadic/va_start)"
- name: Value categories
  summary: 'Each expression in C (an operator with its arguments, a function call, a constant, a variable name, etc) is characterized by two independent properties: a type and a value category'
  description: "# Value categories\n\nEach [expression](expressions \"c/language/expressions\") in C (an operator with its arguments, a function call, a constant, a variable name, etc) is characterized by two independent properties: a [type](type#Type \"c/language/type\") and a [value category](expressions#General \"c/language/expressions\").\n\nEvery expression belongs to one of three value categories: lvalue, non-lvalue object (rvalue), and function designator.\n\n### Lvalue expressions\n\nLvalue expression is any expression with [object type](type#Type_groups \"c/language/type\") other than the type `void`, which potentially designates an [object](object \"c/language/object\") (the behavior is undefined if an lvalue does not actually designate an object when it is evaluated). In other words, lvalue expression evaluates to the *object identity*. The name of this value category (\"left value\") is historic and reflects the use of lvalue expressions as the left-hand operand of the assignment operator in the CPL programming language.\n\nLvalue expressions can be used in the following *lvalue contexts*:\n\n- as the operand of the [address-of operator](operator_member_access \"c/language/operator member access\") (except if the lvalue designates a [bit-field](bit_field \"c/language/bit field\") or was declared [register](storage_duration \"c/language/storage duration\")).\n- as the operand of the pre/post [increment and decrement operators](operator_incdec \"c/language/operator incdec\").\n- as the left-hand operand of the [member access](operator_member_access \"c/language/operator member access\") (dot) operator.\n- as the left-hand operand of the [assignment and compound assignment](operator_assignment \"c/language/operator assignment\") operators.\n\nIf an lvalue expression is used in any context other than [`sizeof`](sizeof \"c/language/sizeof\"), [`_Alignof`](_alignof \"c/language/ Alignof\"), or the operators listed above, non-array lvalues of any complete type undergo [lvalue conversion](conversion \"c/language/conversion\"), which models the memory load of the value of the object from its location. Similarly, array lvalues undergo [array-to-pointer conversion](conversion \"c/language/conversion\") when used in any context other than `sizeof`, `_Alignof`, address-of operator, or array initialization from a string literal.\n\nThe semantics of [`const`](const \"c/language/const\")/[`volatile`](volatile \"c/language/volatile\")/[`restrict`](restrict \"c/language/restrict\")-qualifiers and [atomic](atomic \"c/language/atomic\") types apply to lvalues only (lvalue conversion strips the qualifiers and removes atomicity).\n\nThe following expressions are lvalues:\n\n- identifiers, including function named parameters, provided they were declared as designating objects (not functions or enumeration constants)\n- [string literals](string_literal \"c/language/string literal\")\n- (C99) [compound literals](compound_literal \"c/language/compound literal\")\n- parenthesized expression if the unparenthesized expression is an lvalue\n- the result of a member access (dot) operator if its left-hand argument is lvalue\n- the result of a member access through pointer `->` operator\n- the result of the indirection (unary `*`) operator applied to a pointer to object\n- the result of the subscription operator (`[]`)\n\n#### Modifiable lvalue expressions\n\nA *modifiable lvalue* is any lvalue expression of complete, non-array type which is not [const](const \"c/language/const\")-qualified, and, if it's a struct/union, has no members that are [const](const \"c/language/const\")-qualified, recursively.\n\nOnly modifiable lvalue expressions may be used as arguments to increment/decrement, and as left-hand arguments of assignment and compound assignment operators.\n\n### Non-lvalue object expressions\n\nKnown as *rvalues*, non-lvalue object expressions are the expressions of object types that do not designate objects, but rather values that have no object identity or storage location. The address of a non-lvalue object expression cannot be taken.\n\nThe following expressions are non-lvalue object expressions:\n\n- integer, character, and floating constants\n- all operators not specified to return lvalues, including\n  - any function call expression\n  - any cast expression (note that compound literals, which look similar, are lvalues)\n  - member access operator (dot) applied to a non-lvalue structure/union, `f().x`, `(x,s1).a`, `(s1=s2).m`\n  - results of all arithmetic, relational, logical, and bitwise operators\n  - results of increment and decrement operators (note: pre-forms are lvalues in C++)\n  - results of assignment operators (note: also lvalues in C++)\n  - the conditional operator (note: is lvalue in C++ if both the second and third operands are lvalues of the same type)\n  - the comma operator (note: is lvalue in C++ if the second operand is)\n  - the address-of operator, even if neutralized by application to the result of unary `*` operator\n\nAs a special case, expressions of type `void` are assumed to be non-lvalue object expressions that yield a value which has no representation and requires no storage.\n\nNote that a struct/union rvalue that has a member (possibly nested) of array type does in fact designate an object with [temporary lifetime](lifetime \"c/language/lifetime\"). This object can be accessed through lvalue expressions that form by indexing the array member or by indirection through the pointer obtained by array-to-pointer conversion of the array member.\n\n### Function designator expression\n\nA function designator (the identifier introduced by a [function declaration](function_declaration \"c/language/function declaration\")) is an expression of function type. When used in any context other than the address-of operator, [`sizeof`](sizeof \"c/language/sizeof\"), and [`_Alignof`](_alignof \"c/language/ Alignof\") (the last two generate compile errors when applied to functions), the function designator is always converted to a non-lvalue pointer to function. Note that the function-call operator is defined for pointers to functions and not for function designators themselves.\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.3.2.1 Lvalues, arrays, and function designators (p: 40)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.3.2.1 Lvalues, arrays, and function designators (p: 54-55)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.3.2.1 Lvalues, arrays, and function designators (p: 46)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.2.2.1 Lvalues and function designators\n\n### See also\n\n|                                                                                                                                   |     |\n|-----------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/value_category \"cpp/language/value category\") for Value categories |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/value_category](https://en.cppreference.com/w/c/language/value_category)"
- name: Variadic arguments
  summary: Variadic functions are functions that may be called with different number of arguments
  description: "# Variadic arguments\n\nVariadic functions are functions that may be called with different number of arguments.\n\nOnly prototyped [function declarations](function_declaration \"c/language/function declaration\") may be variadic. This is indicated by the parameter of the form `...` which must appear last in the parameter list and must follow at least one named parameter(until C23). The ellipsis parameter and the proceeding parameter must be delimited by `,`.\n\n```\n// Prototyped declaration\nint printx(const char* fmt, ...); // function declared this way\nprintx(\"hello world\");     // may be called with one\nprintx(\"a=%d b=%d\", a, b); // or more arguments\n \nint printz(...); // OK since C23 and in C++\n// Error until C23: ... must follow at least one named parameter\n \n// int printy(..., const char* fmt); // Error: ... must be the last\n// int printa(const char* fmt...);   // Error in C: ',' is required; OK in C++\n```\n\nAt the [function call](operator_other#Function_call \"c/language/operator other\"), each argument that is a part of the variable argument list undergoes special implicit conversions known as [default argument promotions](conversion#Default_argument_promotions \"c/language/conversion\").\n\nWithin the body of a function that uses variadic arguments, the values of these arguments may be accessed using the [`<stdarg.h>` library facilities](../variadic \"c/variadic\"):\n\n[TABLE]\n\n### Notes\n\nAlthough old-style (prototype-less) [function declarations](function_declaration \"c/language/function declaration\") allow the subsequent function calls to use any number of arguments, they are not allowed to be variadic (as of C89). The definition of such function must specify a fixed number of parameters and cannot use the `stdarg.h` macros.\n\n```\n// old-style declaration, removed in C23\nint printx(); // function declared this way\nprintx(\"hello world\");     // may be called with one\nprintx(\"a=%d b=%d\", a, b); // or more arguments\n// the behavior of at least one of these calls is undefined, depending on\n// the number of parameters the function is defined to take\n```\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <stdarg.h>\n \nvoid tlog(const char* fmt,...)\n{\n    char msg[50];\n    strftime(msg, sizeof msg, \"%T\", localtime(&(time_t){time(NULL)}));\n    printf(\"[%s] \", msg);\n    va_list args;\n    va_start(args, fmt);\n    vprintf(fmt, args);\n    va_end(args);\n}\n \nint main(void)\n{\n   tlog(\"logging %d %d %d...\\n\", 1, 2, 3);\n}\n```\n\nOutput:\n\n```\n[10:21:38] logging 1 2 3...\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.6.3/9 Function declarators (including prototypes) (p: 96)\n  - 7.16 Variable arguments \\<stdarg.h\\> (p: 197-199)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.6.3/9 Function declarators (including prototypes) (p: 133)\n  - 7.16 Variable arguments \\<stdarg.h\\> (p: 269-272)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.5.3/9 Function declarators (including prototypes) (p: 119)\n  - 7.15 Variable arguments \\<stdarg.h\\> (p: 249-252)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.5.4.3/5 Function declarators (including prototypes)\n  - 4.8 VARIABLE ARGUMENTS \\<stdarg.h\\>\n\n### See also\n\n|                                                                                                                                             |     |\n|---------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/variadic_arguments \"cpp/language/variadic arguments\") for Variadic arguments |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/variadic](https://en.cppreference.com/w/c/language/variadic)"
- name: Variadic functions
  summary: Variadic functions are functions (e.g
  description: "# Variadic functions\n\nVariadic functions are functions (e.g. [`printf`](io/fprintf \"c/io/fprintf\")) which take a variable number of arguments.\n\nThe declaration of a variadic function uses an ellipsis as the last parameter, e.g. `int`` `[`printf`](http://en.cppreference.com/w/c/io/fprintf)`(``const`` ``char``*`` format, ...``)``;`. See [variadic arguments](language/variadic \"c/language/variadic\") for additional detail on the syntax and automatic argument conversions.\n\nAccessing the variadic arguments from the function body uses the following library facilities:\n\n[TABLE]\n\n### Example\n\nPrint values of different types.\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n \nvoid simple_printf(const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n \n    while (*fmt != '\\0') {\n        if (*fmt == 'd') {\n            int i = va_arg(args, int);\n            printf(\"%d\\n\", i);\n        } else if (*fmt == 'c') {\n            // A 'char' variable will be promoted to 'int'\n            // A character literal in C is already 'int' by itself\n            int c = va_arg(args, int);\n            printf(\"%c\\n\", c);\n        } else if (*fmt == 'f') {\n            double d = va_arg(args, double);\n            printf(\"%f\\n\", d);\n        }\n        ++fmt;\n    }\n \n    va_end(args);\n}\n \nint main(void)\n{\n    simple_printf(\"dcff\", 3, 'a', 1.999, 42.5); \n}\n```\n\nOutput:\n\n```\n3\na\n1.999000\n42.50000\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.16 Variable arguments \\<stdarg.h\\> (p: 269-272)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.15 Variable arguments \\<stdarg.h\\> (p: 249-252)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.8 VARIABLE ARGUMENTS \\<stdarg.h\\>\n\n### See also\n\n|                                                                                                                       |     |\n|-----------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/utility/variadic \"cpp/utility/variadic\") for Variadic functions |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/variadic](https://en.cppreference.com/w/c/variadic)"
- name: vfprintf
  summary: Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks
  description: "# vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s, vsprintf_s, vsnprintf_s\n\n[TABLE]\n\nLoads the data from the locations, defined by `vlist`, converts them to character string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a character string `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz - 1` characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vsprintf_s` only), the string to be stored in `buffer` (including the trailing null)) would be exceed `bufsz`\n\nAs with all bounds-checked functions, `vprintf_s` , `vfprintf_s`, `vsprintf_s`, and `vsnprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                    |\n|--------|-----|------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                     |\n| buffer | \\-  | pointer to a character string to write to                                          |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                |\n| format | \\-  | pointer to a null-terminated character string specifying how to interpret the data |\n| vlist  | \\-  | variable argument list containing the data to print.                               |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) The number of characters written if successful or negative value if an error occurred.\n\n4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `buf_size` limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions do not invoke `va_end`, and it must be done by the caller.\n\n`vsnprintf_s`, unlike `vsprintf_s`, will truncate the result to fit within the array pointed to by `buffer`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n \nvoid debug_log(const char *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    char buf[1+vsnprintf(NULL, 0, fmt, args1)];\n    va_end(args1);\n    vsnprintf(buf, sizeof buf, fmt, args2);\n    va_end(args2);\n \n    printf(\"%s [debug]: %s\\n\", time_buf, buf);\n}\n \nint main(void)\n{\n    debug_log(\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 21:58:09.072683 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.8 The vfprintf function (p: 238)\n  - 7.21.6.10 The vprintf function (p: 239)\n  - 7.21.6.12 The vsnprintf function (p: 239-240)\n  - 7.21.6.13 The vsprintf function (p: 240)\n  - K.3.5.3.8 The vfprintf_s function (p: 434)\n  - K.3.5.3.10 The vprintf_s function (p: 435)\n  - K.3.5.3.12 The vsnprintf_s function (p: 436-437)\n  - K.3.5.3.13 The vsprintf_s function (p: 437)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.8 The vfprintf function (p: 326-327)\n  - 7.21.6.10 The vprintf function (p: 328)\n  - 7.21.6.12 The vsnprintf function (p: 329)\n  - 7.21.6.13 The vsprintf function (p: 329)\n  - K.3.5.3.8 The vfprintf_s function (p: 597)\n  - K.3.5.3.10 The vprintf_s function (p: 598-599)\n  - K.3.5.3.12 The vsnprintf_s function (p: 600)\n  - K.3.5.3.13 The vsprintf_s function (p: 601)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.8 The vfprintf function (p: 292)\n  - 7.19.6.10 The vprintf function (p: 293)\n  - 7.19.6.12 The vsnprintf function (p: 294)\n  - 7.19.6.13 The vsprintf function (p: 295)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.7 The vfprintf function\n  - 4.9.6.8 The vprintf function\n  - 4.9.6.9 The vsprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfprintf](https://en.cppreference.com/w/c/io/vfprintf)"
- name: vfprintf_s
  summary: Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks
  description: "# vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s, vsprintf_s, vsnprintf_s\n\n[TABLE]\n\nLoads the data from the locations, defined by `vlist`, converts them to character string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a character string `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz - 1` characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vsprintf_s` only), the string to be stored in `buffer` (including the trailing null)) would be exceed `bufsz`\n\nAs with all bounds-checked functions, `vprintf_s` , `vfprintf_s`, `vsprintf_s`, and `vsnprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                    |\n|--------|-----|------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                     |\n| buffer | \\-  | pointer to a character string to write to                                          |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                |\n| format | \\-  | pointer to a null-terminated character string specifying how to interpret the data |\n| vlist  | \\-  | variable argument list containing the data to print.                               |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) The number of characters written if successful or negative value if an error occurred.\n\n4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `buf_size` limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions do not invoke `va_end`, and it must be done by the caller.\n\n`vsnprintf_s`, unlike `vsprintf_s`, will truncate the result to fit within the array pointed to by `buffer`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n \nvoid debug_log(const char *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    char buf[1+vsnprintf(NULL, 0, fmt, args1)];\n    va_end(args1);\n    vsnprintf(buf, sizeof buf, fmt, args2);\n    va_end(args2);\n \n    printf(\"%s [debug]: %s\\n\", time_buf, buf);\n}\n \nint main(void)\n{\n    debug_log(\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 21:58:09.072683 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.8 The vfprintf function (p: 238)\n  - 7.21.6.10 The vprintf function (p: 239)\n  - 7.21.6.12 The vsnprintf function (p: 239-240)\n  - 7.21.6.13 The vsprintf function (p: 240)\n  - K.3.5.3.8 The vfprintf_s function (p: 434)\n  - K.3.5.3.10 The vprintf_s function (p: 435)\n  - K.3.5.3.12 The vsnprintf_s function (p: 436-437)\n  - K.3.5.3.13 The vsprintf_s function (p: 437)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.8 The vfprintf function (p: 326-327)\n  - 7.21.6.10 The vprintf function (p: 328)\n  - 7.21.6.12 The vsnprintf function (p: 329)\n  - 7.21.6.13 The vsprintf function (p: 329)\n  - K.3.5.3.8 The vfprintf_s function (p: 597)\n  - K.3.5.3.10 The vprintf_s function (p: 598-599)\n  - K.3.5.3.12 The vsnprintf_s function (p: 600)\n  - K.3.5.3.13 The vsprintf_s function (p: 601)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.8 The vfprintf function (p: 292)\n  - 7.19.6.10 The vprintf function (p: 293)\n  - 7.19.6.12 The vsnprintf function (p: 294)\n  - 7.19.6.13 The vsprintf function (p: 295)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.7 The vfprintf function\n  - 4.9.6.8 The vprintf function\n  - 4.9.6.9 The vsprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfprintf](https://en.cppreference.com/w/c/io/vfprintf)"
- name: vfscanf
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) Reads the data from file stream `stream`\n\n3) Reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %c into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vscanf_s` , `vfscanf_s`, and `vsscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                     |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdarg.h>\n \nbool checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    int rc = vsscanf(buf, fmt, ap);\n    va_end(ap);\n    return rc == count;\n}\n \nint main(void)\n{\n    int n, m;\n \n    printf(\"Parsing '1 2'...\");\n    if(checked_sscanf(2, \"1 2\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n \n    printf(\"Parsing '1 a'...\");\n    if(checked_sscanf(2, \"1 a\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n}\n```\n\nOutput:\n\n```\nParsing '1 2'...success\nParsing '1 a'...failure\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.9 The vfscanf function (p: 327)\n  - 7.21.6.11 The vscanf function (p: 328)\n  - 7.21.6.14 The vsscanf function (p: 330)\n  - K.3.5.3.9 The vfscanf_s function (p: 597-598)\n  - K.3.5.3.11 The vscanf_s function (p: 599)\n  - K.3.5.3.14 The vsscanf_s function (p: 602)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.9 The vfscanf function (p: 293)\n  - 7.19.6.11 The vscanf function (p: 294)\n  - 7.19.6.14 The vsscanf function (p: 295)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfscanf](https://en.cppreference.com/w/c/io/vfscanf)"
- name: vfscanf_s
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) Reads the data from file stream `stream`\n\n3) Reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %c into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vscanf_s` , `vfscanf_s`, and `vsscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                     |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdarg.h>\n \nbool checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    int rc = vsscanf(buf, fmt, ap);\n    va_end(ap);\n    return rc == count;\n}\n \nint main(void)\n{\n    int n, m;\n \n    printf(\"Parsing '1 2'...\");\n    if(checked_sscanf(2, \"1 2\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n \n    printf(\"Parsing '1 a'...\");\n    if(checked_sscanf(2, \"1 a\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n}\n```\n\nOutput:\n\n```\nParsing '1 2'...success\nParsing '1 a'...failure\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.9 The vfscanf function (p: 327)\n  - 7.21.6.11 The vscanf function (p: 328)\n  - 7.21.6.14 The vsscanf function (p: 330)\n  - K.3.5.3.9 The vfscanf_s function (p: 597-598)\n  - K.3.5.3.11 The vscanf_s function (p: 599)\n  - K.3.5.3.14 The vsscanf_s function (p: 602)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.9 The vfscanf function (p: 293)\n  - 7.19.6.11 The vscanf function (p: 294)\n  - 7.19.6.14 The vsscanf function (p: 295)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfscanf](https://en.cppreference.com/w/c/io/vfscanf)"
- name: vfwprintf
  summary: Loads the data from locations, defined by vlist, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# vwprintf, vfwprintf, vswprintf, vwprintf_s, vfwprintf_s, vswprintf_s, vsnwprintf_s\n\n[TABLE]\n\nLoads the data from locations, defined by `vlist`, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. The resulting wide character string will be terminated with a null wide character, unless `bufsz` is zero.\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vswprintf_s` only), the string to be stored in `buffer` (including the trailing wide null) would be exceed `bufsz`\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by `buffer`. As with all bounds-checked functions, `vwprintf_s` , `vfwprintf_s`, `vswprintf_s`, and `vsnwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                    |\n|--------|-----|----------------------------------------------------------------------------------------------------|\n| stream | \\-  | output wide stream to write to                                                                     |\n| buffer | \\-  | pointer to a wide string to write to                                                               |\n| bufsz  | \\-  | maximum number of wide characters to write                                                         |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                      |\n| vlist  | \\-  | [variable argument list](../language/variadic \"c/language/variadic\") containing the data to print. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,4) The number of wide characters written if successful or negative value if an error occurred.\n\n3) The number of wide characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `bufsz` limit, function returns the total number of characters (not including the terminating null wide character) which would have been written, if the limit were not imposed.\n\n2,5) number of wide characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n6) number of wide characters written to `buffer`, not counting the null wide character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), or zero on runtime constraint violations, and negative value on encoding errors.\n\n7) number of wide characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\nWhile narrow strings provide [`vsnprintf`](vfprintf \"c/io/vfprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call `vswprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`vsnwprintf_s`, unlike `vswprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <wchar.h>\n \nvoid debug_wlog(const wchar_t *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args;\n    va_start(args, fmt);\n    wchar_t buf[1024];\n    int rc2 = vswprintf(buf, sizeof buf / sizeof *buf, fmt, args);\n    va_end(args);\n \n    if(rc2 > 0)\n       wprintf(L\"%s [debug]: %ls\\n\", time_buf, buf);\n    else\n       wprintf(L\"%s [debug]: (string too long)\\n\", time_buf);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"\");\n    debug_wlog(L\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 22:12:38.476575 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.5 The vfwprintf function (p: 417-418)\n  - 7.29.2.7 The vswprintf function (p: 419)\n  - 7.29.2.9 The vwprintf function (p: 420)\n  - K.3.9.1.6 The vfwprintf_s function (p: 632)\n  - K.3.9.1.8 The vsnwprintf_s function (p: 633-634)\n  - K.3.9.1.9 The vswprintf_s function (p: 634-635)\n  - K.3.9.1.11 The vwprintf_s function (p: 636)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.5 The vfwprintf function (p: 363)\n  - 7.24.2.7 The vswprintf function (p: 364)\n  - 7.24.2.9 The vwprintf function (p: 365)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwprintf](https://en.cppreference.com/w/c/io/vfwprintf)"
- name: vfwprintf_s
  summary: Loads the data from locations, defined by vlist, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# vwprintf, vfwprintf, vswprintf, vwprintf_s, vfwprintf_s, vswprintf_s, vsnwprintf_s\n\n[TABLE]\n\nLoads the data from locations, defined by `vlist`, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. The resulting wide character string will be terminated with a null wide character, unless `bufsz` is zero.\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vswprintf_s` only), the string to be stored in `buffer` (including the trailing wide null) would be exceed `bufsz`\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by `buffer`. As with all bounds-checked functions, `vwprintf_s` , `vfwprintf_s`, `vswprintf_s`, and `vsnwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                    |\n|--------|-----|----------------------------------------------------------------------------------------------------|\n| stream | \\-  | output wide stream to write to                                                                     |\n| buffer | \\-  | pointer to a wide string to write to                                                               |\n| bufsz  | \\-  | maximum number of wide characters to write                                                         |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                      |\n| vlist  | \\-  | [variable argument list](../language/variadic \"c/language/variadic\") containing the data to print. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,4) The number of wide characters written if successful or negative value if an error occurred.\n\n3) The number of wide characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `bufsz` limit, function returns the total number of characters (not including the terminating null wide character) which would have been written, if the limit were not imposed.\n\n2,5) number of wide characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n6) number of wide characters written to `buffer`, not counting the null wide character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), or zero on runtime constraint violations, and negative value on encoding errors.\n\n7) number of wide characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\nWhile narrow strings provide [`vsnprintf`](vfprintf \"c/io/vfprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call `vswprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`vsnwprintf_s`, unlike `vswprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <wchar.h>\n \nvoid debug_wlog(const wchar_t *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args;\n    va_start(args, fmt);\n    wchar_t buf[1024];\n    int rc2 = vswprintf(buf, sizeof buf / sizeof *buf, fmt, args);\n    va_end(args);\n \n    if(rc2 > 0)\n       wprintf(L\"%s [debug]: %ls\\n\", time_buf, buf);\n    else\n       wprintf(L\"%s [debug]: (string too long)\\n\", time_buf);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"\");\n    debug_wlog(L\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 22:12:38.476575 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.5 The vfwprintf function (p: 417-418)\n  - 7.29.2.7 The vswprintf function (p: 419)\n  - 7.29.2.9 The vwprintf function (p: 420)\n  - K.3.9.1.6 The vfwprintf_s function (p: 632)\n  - K.3.9.1.8 The vsnwprintf_s function (p: 633-634)\n  - K.3.9.1.9 The vswprintf_s function (p: 634-635)\n  - K.3.9.1.11 The vwprintf_s function (p: 636)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.5 The vfwprintf function (p: 363)\n  - 7.24.2.7 The vswprintf function (p: 364)\n  - 7.24.2.9 The vwprintf function (p: 365)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwprintf](https://en.cppreference.com/w/c/io/vfwprintf)"
- name: vfwscanf
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vwscanf, vfwscanf, vswscanf, vwscanf_s, vfwscanf_s, vswscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vwscanf_s` , `vfwscanf_s`, and `vswscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions may invoke `va_arg`, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.6 The vfwscanf function (p: 418)\n  - 7.29.2.8 The vswscanf function (p: 419)\n  - 7.29.2.10 The vwscanf function (p: 420)\n  - K.3.9.1.7 The vfwscanf_s function (p: 632-633)\n  - K.3.9.1.10 The vswscanf_s function (p: 635-636)\n  - K.3.9.1.12 The vwscanf_s function (p: 637)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.6 The vfwscanf function (p: 364)\n  - 7.24.2.8 The vswscanf function (p: 365)\n  - 7.24.2.10 The vwscanf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwscanf](https://en.cppreference.com/w/c/io/vfwscanf)"
- name: vfwscanf_s
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vwscanf, vfwscanf, vswscanf, vwscanf_s, vfwscanf_s, vswscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vwscanf_s` , `vfwscanf_s`, and `vswscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions may invoke `va_arg`, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.6 The vfwscanf function (p: 418)\n  - 7.29.2.8 The vswscanf function (p: 419)\n  - 7.29.2.10 The vwscanf function (p: 420)\n  - K.3.9.1.7 The vfwscanf_s function (p: 632-633)\n  - K.3.9.1.10 The vswscanf_s function (p: 635-636)\n  - K.3.9.1.12 The vwscanf_s function (p: 637)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.6 The vfwscanf function (p: 364)\n  - 7.24.2.8 The vswscanf function (p: 365)\n  - 7.24.2.10 The vwscanf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwscanf](https://en.cppreference.com/w/c/io/vfwscanf)"
- name: void
  summary: ''
  description: "# C keywords: void\n\n### Usage\n\n- [`void` type](../language/types \"c/language/types\"): as the declaration of the incomplete type\n- [`void`](../language/function_declaration \"c/language/function declaration\"): in a function with no parameter or no return value\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/void](https://en.cppreference.com/w/c/keyword/void)"
- name: volatile
  summary: ''
  description: "# C keywords: volatile\n\n### Usage\n\n- [`volatile` type qualifier](../language/volatile \"c/language/volatile\")\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/volatile](https://en.cppreference.com/w/c/keyword/volatile)"
- name: volatile type qualifier
  summary: Each individual type in the C type system has several qualified versions of that type, corresponding to one, two, or all three of the const, volatile, and, for pointers to object types, restrict qualifiers
  description: "# volatile type qualifier\n\nEach individual type in the C [type system](type \"c/language/type\") has several *qualified* versions of that type, corresponding to one, two, or all three of the [`const`](const \"c/language/const\"), `volatile`, and, for pointers to object types, [`restrict`](restrict \"c/language/restrict\") qualifiers. This page describes the effects of the `volatile` qualifier.\n\nEvery access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a [sequence point](eval_order \"c/language/eval order\") from the volatile access.\n\nA cast of a non-volatile value to a volatile type has no effect. To access a non-volatile object using volatile semantics, its address must be cast to a pointer-to-volatile and then the access must be made through that pointer.\n\nAny attempt to read or write to an object whose type is volatile-qualified through a non-volatile lvalue results in undefined behavior:\n\n```\nvolatile int n = 1; // object of volatile-qualified type\nint* p = (int*)&n;\nint val = *p; // undefined behavior\n```\n\nA member of a volatile-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the `.` operator or the `->` operator):\n\n```\nstruct s { int i; const int ci; } s;\n// the type of s.i is int, the type of s.ci is const int\nvolatile struct s vs;\n// the types of vs.i and vs.ci are volatile int and const volatile int\n```\n\n|                                                                                                                                                                                                  |             |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| If an array type is declared with the volatile type qualifier (through the use of [`typedef`](typedef \"c/language/typedef\")), the array type is not volatile-qualified, but its element type is. | (until C23) |\n| An array type and its element type are always considered to be identically volatile-qualified.                                                                                                   | (since C23) |\n\n```\ntypedef int A[2][3];\nvolatile A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of volatile int\nint* pi = a[0]; // Error: a[0] has type volatile int*\nvoid *unqual_ptr = a; // OK until C23; error since C23\n// Notes: clang applies the rule in C++/C23 even in C89-C17 modes\n```\n\nIf a function type is declared with the volatile type qualified (through the use of [`typedef`](typedef \"c/language/typedef\")), the behavior is undefined.\n\n[TABLE]\n\nA pointer to a non-volatile type can be implicitly converted to a pointer to the volatile-qualified version of the same or [compatible](compatible_type \"c/language/compatible type\") type. The reverse conversion requires a cast expression.\n\n```\nint* p = 0;\nvolatile int* vp = p; // OK: adds qualifiers (int to volatile int)\np = vp; // Error: discards qualifiers (volatile int to int)\np = (int*)vp; // OK: cast\n```\n\nNote that pointer to pointer to `T` is not convertible to pointer to pointer to `volatile T`; for two types to be compatible, their qualifications must be identical:\n\n```\nchar *p = 0;\nvolatile char **vpp = &p; // Error: char* and volatile char* are not compatible types\nchar * volatile *pvp = &p; // OK, adds qualifiers (char* to char*volatile)\n```\n\n### Uses of volatile\n\n1) [`static`](static_storage_duration \"c/language/static storage duration\") `volatile` objects model memory-mapped I/O ports, and `static` `const` `volatile` objects model memory-mapped input ports, such as a real-time clock:\n\n```\nvolatile short *ttyport = (volatile short*)TTYPORT_ADDR;\nfor(int i = 0; i < N; ++i)\n    *ttyport = a[i]; // *ttyport is an lvalue of type volatile short\n```\n\n2) `static` `volatile` objects of type [`sig_atomic_t`](../program/sig_atomic_t \"c/program/sig atomic t\") are used for communication with [`signal`](../program/signal \"c/program/signal\") handlers.\n\n3) `volatile` variables that are local to a function that contains an invocation of the [`setjmp`](../program/setjmp \"c/program/setjmp\") macro are the only local variables guaranteed to retain their values after [`longjmp`](../program/longjmp \"c/program/longjmp\") returns.\n\n4) In addition, volatile variables can be used to disable certain forms of optimization, e.g. to disable dead store elimination or constant folding for micro-benchmarks.\n\nNote that volatile variables are not suitable for communication between threads; they do not offer atomicity, synchronization, or memory ordering. A read from a volatile variable that is modified by another thread without synchronization or concurrent modification from two unsynchronized threads is undefined behavior due to a data race.\n\n### Keywords\n\n[`volatile`](https://en.cppreference.com/w/cpp/keyword/volatile \"cpp/keyword/volatile\")\n\n### Example\n\ndemonstrates the use of volatile to disable optimizations\n\n```\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    clock_t t = clock();\n    double d = 0.0;\n    for (int n = 0; n < 10000; ++n)\n        for (int m = 0; m < 10000; ++m)\n            d += d * n * m; // reads from and writes to a non-volatile \n    printf(\"Modified a non-volatile variable 100m times. \"\n           \"Time used: %.2f seconds\\n\",\n           (double)(clock() - t)/CLOCKS_PER_SEC);\n \n    t = clock();\n    volatile double vd = 0.0;\n    for (int n = 0; n < 10000; ++n)\n        for (int m = 0; m < 10000; ++m) {\n            double prod = vd * n * m; // reads from a volatile\n            vd += prod; // reads from and writes to a volatile\n        } \n    printf(\"Modified a volatile variable 100m times. \"\n           \"Time used: %.2f seconds\\n\",\n           (double)(clock() - t)/CLOCKS_PER_SEC);\n}\n```\n\nPossible output:\n\n```\nModified a non-volatile variable 100m times. Time used: 0.00 seconds\nModified a volatile variable 100m times. Time used: 0.79 seconds\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.7.3 Type qualifiers (p: 87-90)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.7.3 Type qualifiers (p: 121-123)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.7.3 Type qualifiers (p: 108-110)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 6.5.3 Type qualifiers\n\n### See also\n\n|                                                                                                                                      |     |\n|--------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/cv \"cpp/language/cv\") for cv (`const` and `volatile`) type qualifiers |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/volatile](https://en.cppreference.com/w/c/language/volatile)"
- name: vprintf
  summary: Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks
  description: "# vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s, vsprintf_s, vsnprintf_s\n\n[TABLE]\n\nLoads the data from the locations, defined by `vlist`, converts them to character string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a character string `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz - 1` characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vsprintf_s` only), the string to be stored in `buffer` (including the trailing null)) would be exceed `bufsz`\n\nAs with all bounds-checked functions, `vprintf_s` , `vfprintf_s`, `vsprintf_s`, and `vsnprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                    |\n|--------|-----|------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                     |\n| buffer | \\-  | pointer to a character string to write to                                          |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                |\n| format | \\-  | pointer to a null-terminated character string specifying how to interpret the data |\n| vlist  | \\-  | variable argument list containing the data to print.                               |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) The number of characters written if successful or negative value if an error occurred.\n\n4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `buf_size` limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions do not invoke `va_end`, and it must be done by the caller.\n\n`vsnprintf_s`, unlike `vsprintf_s`, will truncate the result to fit within the array pointed to by `buffer`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n \nvoid debug_log(const char *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    char buf[1+vsnprintf(NULL, 0, fmt, args1)];\n    va_end(args1);\n    vsnprintf(buf, sizeof buf, fmt, args2);\n    va_end(args2);\n \n    printf(\"%s [debug]: %s\\n\", time_buf, buf);\n}\n \nint main(void)\n{\n    debug_log(\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 21:58:09.072683 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.8 The vfprintf function (p: 238)\n  - 7.21.6.10 The vprintf function (p: 239)\n  - 7.21.6.12 The vsnprintf function (p: 239-240)\n  - 7.21.6.13 The vsprintf function (p: 240)\n  - K.3.5.3.8 The vfprintf_s function (p: 434)\n  - K.3.5.3.10 The vprintf_s function (p: 435)\n  - K.3.5.3.12 The vsnprintf_s function (p: 436-437)\n  - K.3.5.3.13 The vsprintf_s function (p: 437)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.8 The vfprintf function (p: 326-327)\n  - 7.21.6.10 The vprintf function (p: 328)\n  - 7.21.6.12 The vsnprintf function (p: 329)\n  - 7.21.6.13 The vsprintf function (p: 329)\n  - K.3.5.3.8 The vfprintf_s function (p: 597)\n  - K.3.5.3.10 The vprintf_s function (p: 598-599)\n  - K.3.5.3.12 The vsnprintf_s function (p: 600)\n  - K.3.5.3.13 The vsprintf_s function (p: 601)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.8 The vfprintf function (p: 292)\n  - 7.19.6.10 The vprintf function (p: 293)\n  - 7.19.6.12 The vsnprintf function (p: 294)\n  - 7.19.6.13 The vsprintf function (p: 295)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.7 The vfprintf function\n  - 4.9.6.8 The vprintf function\n  - 4.9.6.9 The vsprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfprintf](https://en.cppreference.com/w/c/io/vfprintf)"
- name: vprintf_s
  summary: Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks
  description: "# vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s, vsprintf_s, vsnprintf_s\n\n[TABLE]\n\nLoads the data from the locations, defined by `vlist`, converts them to character string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a character string `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz - 1` characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vsprintf_s` only), the string to be stored in `buffer` (including the trailing null)) would be exceed `bufsz`\n\nAs with all bounds-checked functions, `vprintf_s` , `vfprintf_s`, `vsprintf_s`, and `vsnprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                    |\n|--------|-----|------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                     |\n| buffer | \\-  | pointer to a character string to write to                                          |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                |\n| format | \\-  | pointer to a null-terminated character string specifying how to interpret the data |\n| vlist  | \\-  | variable argument list containing the data to print.                               |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) The number of characters written if successful or negative value if an error occurred.\n\n4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `buf_size` limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions do not invoke `va_end`, and it must be done by the caller.\n\n`vsnprintf_s`, unlike `vsprintf_s`, will truncate the result to fit within the array pointed to by `buffer`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n \nvoid debug_log(const char *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    char buf[1+vsnprintf(NULL, 0, fmt, args1)];\n    va_end(args1);\n    vsnprintf(buf, sizeof buf, fmt, args2);\n    va_end(args2);\n \n    printf(\"%s [debug]: %s\\n\", time_buf, buf);\n}\n \nint main(void)\n{\n    debug_log(\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 21:58:09.072683 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.8 The vfprintf function (p: 238)\n  - 7.21.6.10 The vprintf function (p: 239)\n  - 7.21.6.12 The vsnprintf function (p: 239-240)\n  - 7.21.6.13 The vsprintf function (p: 240)\n  - K.3.5.3.8 The vfprintf_s function (p: 434)\n  - K.3.5.3.10 The vprintf_s function (p: 435)\n  - K.3.5.3.12 The vsnprintf_s function (p: 436-437)\n  - K.3.5.3.13 The vsprintf_s function (p: 437)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.8 The vfprintf function (p: 326-327)\n  - 7.21.6.10 The vprintf function (p: 328)\n  - 7.21.6.12 The vsnprintf function (p: 329)\n  - 7.21.6.13 The vsprintf function (p: 329)\n  - K.3.5.3.8 The vfprintf_s function (p: 597)\n  - K.3.5.3.10 The vprintf_s function (p: 598-599)\n  - K.3.5.3.12 The vsnprintf_s function (p: 600)\n  - K.3.5.3.13 The vsprintf_s function (p: 601)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.8 The vfprintf function (p: 292)\n  - 7.19.6.10 The vprintf function (p: 293)\n  - 7.19.6.12 The vsnprintf function (p: 294)\n  - 7.19.6.13 The vsprintf function (p: 295)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.7 The vfprintf function\n  - 4.9.6.8 The vprintf function\n  - 4.9.6.9 The vsprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfprintf](https://en.cppreference.com/w/c/io/vfprintf)"
- name: vscanf
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) Reads the data from file stream `stream`\n\n3) Reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %c into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vscanf_s` , `vfscanf_s`, and `vsscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                     |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdarg.h>\n \nbool checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    int rc = vsscanf(buf, fmt, ap);\n    va_end(ap);\n    return rc == count;\n}\n \nint main(void)\n{\n    int n, m;\n \n    printf(\"Parsing '1 2'...\");\n    if(checked_sscanf(2, \"1 2\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n \n    printf(\"Parsing '1 a'...\");\n    if(checked_sscanf(2, \"1 a\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n}\n```\n\nOutput:\n\n```\nParsing '1 2'...success\nParsing '1 a'...failure\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.9 The vfscanf function (p: 327)\n  - 7.21.6.11 The vscanf function (p: 328)\n  - 7.21.6.14 The vsscanf function (p: 330)\n  - K.3.5.3.9 The vfscanf_s function (p: 597-598)\n  - K.3.5.3.11 The vscanf_s function (p: 599)\n  - K.3.5.3.14 The vsscanf_s function (p: 602)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.9 The vfscanf function (p: 293)\n  - 7.19.6.11 The vscanf function (p: 294)\n  - 7.19.6.14 The vsscanf function (p: 295)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfscanf](https://en.cppreference.com/w/c/io/vfscanf)"
- name: vscanf_s
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) Reads the data from file stream `stream`\n\n3) Reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %c into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vscanf_s` , `vfscanf_s`, and `vsscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                     |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdarg.h>\n \nbool checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    int rc = vsscanf(buf, fmt, ap);\n    va_end(ap);\n    return rc == count;\n}\n \nint main(void)\n{\n    int n, m;\n \n    printf(\"Parsing '1 2'...\");\n    if(checked_sscanf(2, \"1 2\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n \n    printf(\"Parsing '1 a'...\");\n    if(checked_sscanf(2, \"1 a\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n}\n```\n\nOutput:\n\n```\nParsing '1 2'...success\nParsing '1 a'...failure\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.9 The vfscanf function (p: 327)\n  - 7.21.6.11 The vscanf function (p: 328)\n  - 7.21.6.14 The vsscanf function (p: 330)\n  - K.3.5.3.9 The vfscanf_s function (p: 597-598)\n  - K.3.5.3.11 The vscanf_s function (p: 599)\n  - K.3.5.3.14 The vsscanf_s function (p: 602)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.9 The vfscanf function (p: 293)\n  - 7.19.6.11 The vscanf function (p: 294)\n  - 7.19.6.14 The vsscanf function (p: 295)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfscanf](https://en.cppreference.com/w/c/io/vfscanf)"
- name: vsnprintf
  summary: Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks
  description: "# vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s, vsprintf_s, vsnprintf_s\n\n[TABLE]\n\nLoads the data from the locations, defined by `vlist`, converts them to character string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a character string `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz - 1` characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vsprintf_s` only), the string to be stored in `buffer` (including the trailing null)) would be exceed `bufsz`\n\nAs with all bounds-checked functions, `vprintf_s` , `vfprintf_s`, `vsprintf_s`, and `vsnprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                    |\n|--------|-----|------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                     |\n| buffer | \\-  | pointer to a character string to write to                                          |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                |\n| format | \\-  | pointer to a null-terminated character string specifying how to interpret the data |\n| vlist  | \\-  | variable argument list containing the data to print.                               |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) The number of characters written if successful or negative value if an error occurred.\n\n4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `buf_size` limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions do not invoke `va_end`, and it must be done by the caller.\n\n`vsnprintf_s`, unlike `vsprintf_s`, will truncate the result to fit within the array pointed to by `buffer`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n \nvoid debug_log(const char *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    char buf[1+vsnprintf(NULL, 0, fmt, args1)];\n    va_end(args1);\n    vsnprintf(buf, sizeof buf, fmt, args2);\n    va_end(args2);\n \n    printf(\"%s [debug]: %s\\n\", time_buf, buf);\n}\n \nint main(void)\n{\n    debug_log(\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 21:58:09.072683 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.8 The vfprintf function (p: 238)\n  - 7.21.6.10 The vprintf function (p: 239)\n  - 7.21.6.12 The vsnprintf function (p: 239-240)\n  - 7.21.6.13 The vsprintf function (p: 240)\n  - K.3.5.3.8 The vfprintf_s function (p: 434)\n  - K.3.5.3.10 The vprintf_s function (p: 435)\n  - K.3.5.3.12 The vsnprintf_s function (p: 436-437)\n  - K.3.5.3.13 The vsprintf_s function (p: 437)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.8 The vfprintf function (p: 326-327)\n  - 7.21.6.10 The vprintf function (p: 328)\n  - 7.21.6.12 The vsnprintf function (p: 329)\n  - 7.21.6.13 The vsprintf function (p: 329)\n  - K.3.5.3.8 The vfprintf_s function (p: 597)\n  - K.3.5.3.10 The vprintf_s function (p: 598-599)\n  - K.3.5.3.12 The vsnprintf_s function (p: 600)\n  - K.3.5.3.13 The vsprintf_s function (p: 601)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.8 The vfprintf function (p: 292)\n  - 7.19.6.10 The vprintf function (p: 293)\n  - 7.19.6.12 The vsnprintf function (p: 294)\n  - 7.19.6.13 The vsprintf function (p: 295)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.7 The vfprintf function\n  - 4.9.6.8 The vprintf function\n  - 4.9.6.9 The vsprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfprintf](https://en.cppreference.com/w/c/io/vfprintf)"
- name: vsnprintf_s
  summary: Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks
  description: "# vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s, vsprintf_s, vsnprintf_s\n\n[TABLE]\n\nLoads the data from the locations, defined by `vlist`, converts them to character string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a character string `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz - 1` characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vsprintf_s` only), the string to be stored in `buffer` (including the trailing null)) would be exceed `bufsz`\n\nAs with all bounds-checked functions, `vprintf_s` , `vfprintf_s`, `vsprintf_s`, and `vsnprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                    |\n|--------|-----|------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                     |\n| buffer | \\-  | pointer to a character string to write to                                          |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                |\n| format | \\-  | pointer to a null-terminated character string specifying how to interpret the data |\n| vlist  | \\-  | variable argument list containing the data to print.                               |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) The number of characters written if successful or negative value if an error occurred.\n\n4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `buf_size` limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions do not invoke `va_end`, and it must be done by the caller.\n\n`vsnprintf_s`, unlike `vsprintf_s`, will truncate the result to fit within the array pointed to by `buffer`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n \nvoid debug_log(const char *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    char buf[1+vsnprintf(NULL, 0, fmt, args1)];\n    va_end(args1);\n    vsnprintf(buf, sizeof buf, fmt, args2);\n    va_end(args2);\n \n    printf(\"%s [debug]: %s\\n\", time_buf, buf);\n}\n \nint main(void)\n{\n    debug_log(\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 21:58:09.072683 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.8 The vfprintf function (p: 238)\n  - 7.21.6.10 The vprintf function (p: 239)\n  - 7.21.6.12 The vsnprintf function (p: 239-240)\n  - 7.21.6.13 The vsprintf function (p: 240)\n  - K.3.5.3.8 The vfprintf_s function (p: 434)\n  - K.3.5.3.10 The vprintf_s function (p: 435)\n  - K.3.5.3.12 The vsnprintf_s function (p: 436-437)\n  - K.3.5.3.13 The vsprintf_s function (p: 437)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.8 The vfprintf function (p: 326-327)\n  - 7.21.6.10 The vprintf function (p: 328)\n  - 7.21.6.12 The vsnprintf function (p: 329)\n  - 7.21.6.13 The vsprintf function (p: 329)\n  - K.3.5.3.8 The vfprintf_s function (p: 597)\n  - K.3.5.3.10 The vprintf_s function (p: 598-599)\n  - K.3.5.3.12 The vsnprintf_s function (p: 600)\n  - K.3.5.3.13 The vsprintf_s function (p: 601)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.8 The vfprintf function (p: 292)\n  - 7.19.6.10 The vprintf function (p: 293)\n  - 7.19.6.12 The vsnprintf function (p: 294)\n  - 7.19.6.13 The vsprintf function (p: 295)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.7 The vfprintf function\n  - 4.9.6.8 The vprintf function\n  - 4.9.6.9 The vsprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfprintf](https://en.cppreference.com/w/c/io/vfprintf)"
- name: vsnwprintf_s
  summary: Loads the data from locations, defined by vlist, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# vwprintf, vfwprintf, vswprintf, vwprintf_s, vfwprintf_s, vswprintf_s, vsnwprintf_s\n\n[TABLE]\n\nLoads the data from locations, defined by `vlist`, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. The resulting wide character string will be terminated with a null wide character, unless `bufsz` is zero.\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vswprintf_s` only), the string to be stored in `buffer` (including the trailing wide null) would be exceed `bufsz`\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by `buffer`. As with all bounds-checked functions, `vwprintf_s` , `vfwprintf_s`, `vswprintf_s`, and `vsnwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                    |\n|--------|-----|----------------------------------------------------------------------------------------------------|\n| stream | \\-  | output wide stream to write to                                                                     |\n| buffer | \\-  | pointer to a wide string to write to                                                               |\n| bufsz  | \\-  | maximum number of wide characters to write                                                         |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                      |\n| vlist  | \\-  | [variable argument list](../language/variadic \"c/language/variadic\") containing the data to print. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,4) The number of wide characters written if successful or negative value if an error occurred.\n\n3) The number of wide characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `bufsz` limit, function returns the total number of characters (not including the terminating null wide character) which would have been written, if the limit were not imposed.\n\n2,5) number of wide characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n6) number of wide characters written to `buffer`, not counting the null wide character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), or zero on runtime constraint violations, and negative value on encoding errors.\n\n7) number of wide characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\nWhile narrow strings provide [`vsnprintf`](vfprintf \"c/io/vfprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call `vswprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`vsnwprintf_s`, unlike `vswprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <wchar.h>\n \nvoid debug_wlog(const wchar_t *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args;\n    va_start(args, fmt);\n    wchar_t buf[1024];\n    int rc2 = vswprintf(buf, sizeof buf / sizeof *buf, fmt, args);\n    va_end(args);\n \n    if(rc2 > 0)\n       wprintf(L\"%s [debug]: %ls\\n\", time_buf, buf);\n    else\n       wprintf(L\"%s [debug]: (string too long)\\n\", time_buf);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"\");\n    debug_wlog(L\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 22:12:38.476575 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.5 The vfwprintf function (p: 417-418)\n  - 7.29.2.7 The vswprintf function (p: 419)\n  - 7.29.2.9 The vwprintf function (p: 420)\n  - K.3.9.1.6 The vfwprintf_s function (p: 632)\n  - K.3.9.1.8 The vsnwprintf_s function (p: 633-634)\n  - K.3.9.1.9 The vswprintf_s function (p: 634-635)\n  - K.3.9.1.11 The vwprintf_s function (p: 636)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.5 The vfwprintf function (p: 363)\n  - 7.24.2.7 The vswprintf function (p: 364)\n  - 7.24.2.9 The vwprintf function (p: 365)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwprintf](https://en.cppreference.com/w/c/io/vfwprintf)"
- name: vsprintf
  summary: Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks
  description: "# vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s, vsprintf_s, vsnprintf_s\n\n[TABLE]\n\nLoads the data from the locations, defined by `vlist`, converts them to character string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a character string `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz - 1` characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vsprintf_s` only), the string to be stored in `buffer` (including the trailing null)) would be exceed `bufsz`\n\nAs with all bounds-checked functions, `vprintf_s` , `vfprintf_s`, `vsprintf_s`, and `vsnprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                    |\n|--------|-----|------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                     |\n| buffer | \\-  | pointer to a character string to write to                                          |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                |\n| format | \\-  | pointer to a null-terminated character string specifying how to interpret the data |\n| vlist  | \\-  | variable argument list containing the data to print.                               |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) The number of characters written if successful or negative value if an error occurred.\n\n4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `buf_size` limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions do not invoke `va_end`, and it must be done by the caller.\n\n`vsnprintf_s`, unlike `vsprintf_s`, will truncate the result to fit within the array pointed to by `buffer`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n \nvoid debug_log(const char *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    char buf[1+vsnprintf(NULL, 0, fmt, args1)];\n    va_end(args1);\n    vsnprintf(buf, sizeof buf, fmt, args2);\n    va_end(args2);\n \n    printf(\"%s [debug]: %s\\n\", time_buf, buf);\n}\n \nint main(void)\n{\n    debug_log(\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 21:58:09.072683 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.8 The vfprintf function (p: 238)\n  - 7.21.6.10 The vprintf function (p: 239)\n  - 7.21.6.12 The vsnprintf function (p: 239-240)\n  - 7.21.6.13 The vsprintf function (p: 240)\n  - K.3.5.3.8 The vfprintf_s function (p: 434)\n  - K.3.5.3.10 The vprintf_s function (p: 435)\n  - K.3.5.3.12 The vsnprintf_s function (p: 436-437)\n  - K.3.5.3.13 The vsprintf_s function (p: 437)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.8 The vfprintf function (p: 326-327)\n  - 7.21.6.10 The vprintf function (p: 328)\n  - 7.21.6.12 The vsnprintf function (p: 329)\n  - 7.21.6.13 The vsprintf function (p: 329)\n  - K.3.5.3.8 The vfprintf_s function (p: 597)\n  - K.3.5.3.10 The vprintf_s function (p: 598-599)\n  - K.3.5.3.12 The vsnprintf_s function (p: 600)\n  - K.3.5.3.13 The vsprintf_s function (p: 601)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.8 The vfprintf function (p: 292)\n  - 7.19.6.10 The vprintf function (p: 293)\n  - 7.19.6.12 The vsnprintf function (p: 294)\n  - 7.19.6.13 The vsprintf function (p: 295)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.7 The vfprintf function\n  - 4.9.6.8 The vprintf function\n  - 4.9.6.9 The vsprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfprintf](https://en.cppreference.com/w/c/io/vfprintf)"
- name: vsprintf_s
  summary: Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks
  description: "# vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s, vsprintf_s, vsnprintf_s\n\n[TABLE]\n\nLoads the data from the locations, defined by `vlist`, converts them to character string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a character string `buffer`.\n\n4) Writes the results to a character string `buffer`. At most `bufsz - 1` characters are written. The resulting character string will be terminated with a null character, unless `bufsz` is zero. If `bufsz` is zero, nothing is written and `buffer` may be a null pointer, however the return value (number of bytes that would be written not including the null terminator) is still calculated and returned.\n\n5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vsprintf_s` only), the string to be stored in `buffer` (including the trailing null)) would be exceed `bufsz`\n\nAs with all bounds-checked functions, `vprintf_s` , `vfprintf_s`, `vsprintf_s`, and `vsnprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                    |\n|--------|-----|------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                     |\n| buffer | \\-  | pointer to a character string to write to                                          |\n| bufsz  | \\-  | up to bufsz - 1 characters may be written, plus the null terminator                |\n| format | \\-  | pointer to a null-terminated character string specifying how to interpret the data |\n| vlist  | \\-  | variable argument list containing the data to print.                               |\n\n  \nThe **format** string consists of ordinary byte characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1-3) The number of characters written if successful or negative value if an error occurred.\n\n4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `buf_size` limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed.\n\n5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.\n\n7) number of characters written to `buffer`, not counting the null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), or zero on runtime constraint violations, and negative value on encoding errors\n\n8) number of characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions do not invoke `va_end`, and it must be done by the caller.\n\n`vsnprintf_s`, unlike `vsprintf_s`, will truncate the result to fit within the array pointed to by `buffer`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n \nvoid debug_log(const char *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    char buf[1+vsnprintf(NULL, 0, fmt, args1)];\n    va_end(args1);\n    vsnprintf(buf, sizeof buf, fmt, args2);\n    va_end(args2);\n \n    printf(\"%s [debug]: %s\\n\", time_buf, buf);\n}\n \nint main(void)\n{\n    debug_log(\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 21:58:09.072683 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.21.6.8 The vfprintf function (p: 238)\n  - 7.21.6.10 The vprintf function (p: 239)\n  - 7.21.6.12 The vsnprintf function (p: 239-240)\n  - 7.21.6.13 The vsprintf function (p: 240)\n  - K.3.5.3.8 The vfprintf_s function (p: 434)\n  - K.3.5.3.10 The vprintf_s function (p: 435)\n  - K.3.5.3.12 The vsnprintf_s function (p: 436-437)\n  - K.3.5.3.13 The vsprintf_s function (p: 437)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.8 The vfprintf function (p: 326-327)\n  - 7.21.6.10 The vprintf function (p: 328)\n  - 7.21.6.12 The vsnprintf function (p: 329)\n  - 7.21.6.13 The vsprintf function (p: 329)\n  - K.3.5.3.8 The vfprintf_s function (p: 597)\n  - K.3.5.3.10 The vprintf_s function (p: 598-599)\n  - K.3.5.3.12 The vsnprintf_s function (p: 600)\n  - K.3.5.3.13 The vsprintf_s function (p: 601)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.8 The vfprintf function (p: 292)\n  - 7.19.6.10 The vprintf function (p: 293)\n  - 7.19.6.12 The vsnprintf function (p: 294)\n  - 7.19.6.13 The vsprintf function (p: 295)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.9.6.7 The vfprintf function\n  - 4.9.6.8 The vprintf function\n  - 4.9.6.9 The vsprintf function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfprintf](https://en.cppreference.com/w/c/io/vfprintf)"
- name: vsscanf
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) Reads the data from file stream `stream`\n\n3) Reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %c into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vscanf_s` , `vfscanf_s`, and `vsscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                     |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdarg.h>\n \nbool checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    int rc = vsscanf(buf, fmt, ap);\n    va_end(ap);\n    return rc == count;\n}\n \nint main(void)\n{\n    int n, m;\n \n    printf(\"Parsing '1 2'...\");\n    if(checked_sscanf(2, \"1 2\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n \n    printf(\"Parsing '1 a'...\");\n    if(checked_sscanf(2, \"1 a\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n}\n```\n\nOutput:\n\n```\nParsing '1 2'...success\nParsing '1 a'...failure\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.9 The vfscanf function (p: 327)\n  - 7.21.6.11 The vscanf function (p: 328)\n  - 7.21.6.14 The vsscanf function (p: 330)\n  - K.3.5.3.9 The vfscanf_s function (p: 597-598)\n  - K.3.5.3.11 The vscanf_s function (p: 599)\n  - K.3.5.3.14 The vsscanf_s function (p: 602)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.9 The vfscanf function (p: 293)\n  - 7.19.6.11 The vscanf function (p: 294)\n  - 7.19.6.14 The vsscanf function (p: 295)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfscanf](https://en.cppreference.com/w/c/io/vfscanf)"
- name: vsscanf_s
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\")\n\n2) Reads the data from file stream `stream`\n\n3) Reads the data from null-terminated character string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %c into a single char) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vscanf_s` , `vfscanf_s`, and `vsscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                                 |\n| buffer | \\-  | pointer to a null-terminated character string to read from                     |\n| format | \\-  | pointer to a null-terminated character string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                     |\n\n  \nThe **format** string consists of\n\n- non-whitespace multibyte characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`isspace`](../string/byte/isspace \"c/string/byte/isspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nThe conversion specifiers `lc`, `ls`, and `l[` perform multibyte-to-wide character conversion as if by calling [`mbrtowc`](../string/multibyte/mbrtowc \"c/string/multibyte/mbrtowc\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdarg.h>\n \nbool checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    int rc = vsscanf(buf, fmt, ap);\n    va_end(ap);\n    return rc == count;\n}\n \nint main(void)\n{\n    int n, m;\n \n    printf(\"Parsing '1 2'...\");\n    if(checked_sscanf(2, \"1 2\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n \n    printf(\"Parsing '1 a'...\");\n    if(checked_sscanf(2, \"1 a\", \"%d %d\", &n, &m))\n        puts(\"success\");\n    else\n        puts(\"failure\");\n}\n```\n\nOutput:\n\n```\nParsing '1 2'...success\nParsing '1 a'...failure\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.21.6.9 The vfscanf function (p: 327)\n  - 7.21.6.11 The vscanf function (p: 328)\n  - 7.21.6.14 The vsscanf function (p: 330)\n  - K.3.5.3.9 The vfscanf_s function (p: 597-598)\n  - K.3.5.3.11 The vscanf_s function (p: 599)\n  - K.3.5.3.14 The vsscanf_s function (p: 602)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.19.6.9 The vfscanf function (p: 293)\n  - 7.19.6.11 The vscanf function (p: 294)\n  - 7.19.6.14 The vsscanf function (p: 295)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfscanf](https://en.cppreference.com/w/c/io/vfscanf)"
- name: vswprintf
  summary: Loads the data from locations, defined by vlist, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# vwprintf, vfwprintf, vswprintf, vwprintf_s, vfwprintf_s, vswprintf_s, vsnwprintf_s\n\n[TABLE]\n\nLoads the data from locations, defined by `vlist`, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. The resulting wide character string will be terminated with a null wide character, unless `bufsz` is zero.\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vswprintf_s` only), the string to be stored in `buffer` (including the trailing wide null) would be exceed `bufsz`\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by `buffer`. As with all bounds-checked functions, `vwprintf_s` , `vfwprintf_s`, `vswprintf_s`, and `vsnwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                    |\n|--------|-----|----------------------------------------------------------------------------------------------------|\n| stream | \\-  | output wide stream to write to                                                                     |\n| buffer | \\-  | pointer to a wide string to write to                                                               |\n| bufsz  | \\-  | maximum number of wide characters to write                                                         |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                      |\n| vlist  | \\-  | [variable argument list](../language/variadic \"c/language/variadic\") containing the data to print. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,4) The number of wide characters written if successful or negative value if an error occurred.\n\n3) The number of wide characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `bufsz` limit, function returns the total number of characters (not including the terminating null wide character) which would have been written, if the limit were not imposed.\n\n2,5) number of wide characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n6) number of wide characters written to `buffer`, not counting the null wide character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), or zero on runtime constraint violations, and negative value on encoding errors.\n\n7) number of wide characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\nWhile narrow strings provide [`vsnprintf`](vfprintf \"c/io/vfprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call `vswprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`vsnwprintf_s`, unlike `vswprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <wchar.h>\n \nvoid debug_wlog(const wchar_t *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args;\n    va_start(args, fmt);\n    wchar_t buf[1024];\n    int rc2 = vswprintf(buf, sizeof buf / sizeof *buf, fmt, args);\n    va_end(args);\n \n    if(rc2 > 0)\n       wprintf(L\"%s [debug]: %ls\\n\", time_buf, buf);\n    else\n       wprintf(L\"%s [debug]: (string too long)\\n\", time_buf);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"\");\n    debug_wlog(L\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 22:12:38.476575 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.5 The vfwprintf function (p: 417-418)\n  - 7.29.2.7 The vswprintf function (p: 419)\n  - 7.29.2.9 The vwprintf function (p: 420)\n  - K.3.9.1.6 The vfwprintf_s function (p: 632)\n  - K.3.9.1.8 The vsnwprintf_s function (p: 633-634)\n  - K.3.9.1.9 The vswprintf_s function (p: 634-635)\n  - K.3.9.1.11 The vwprintf_s function (p: 636)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.5 The vfwprintf function (p: 363)\n  - 7.24.2.7 The vswprintf function (p: 364)\n  - 7.24.2.9 The vwprintf function (p: 365)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwprintf](https://en.cppreference.com/w/c/io/vfwprintf)"
- name: vswprintf_s
  summary: Loads the data from locations, defined by vlist, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# vwprintf, vfwprintf, vswprintf, vwprintf_s, vfwprintf_s, vswprintf_s, vsnwprintf_s\n\n[TABLE]\n\nLoads the data from locations, defined by `vlist`, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. The resulting wide character string will be terminated with a null wide character, unless `bufsz` is zero.\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vswprintf_s` only), the string to be stored in `buffer` (including the trailing wide null) would be exceed `bufsz`\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by `buffer`. As with all bounds-checked functions, `vwprintf_s` , `vfwprintf_s`, `vswprintf_s`, and `vsnwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                    |\n|--------|-----|----------------------------------------------------------------------------------------------------|\n| stream | \\-  | output wide stream to write to                                                                     |\n| buffer | \\-  | pointer to a wide string to write to                                                               |\n| bufsz  | \\-  | maximum number of wide characters to write                                                         |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                      |\n| vlist  | \\-  | [variable argument list](../language/variadic \"c/language/variadic\") containing the data to print. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,4) The number of wide characters written if successful or negative value if an error occurred.\n\n3) The number of wide characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `bufsz` limit, function returns the total number of characters (not including the terminating null wide character) which would have been written, if the limit were not imposed.\n\n2,5) number of wide characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n6) number of wide characters written to `buffer`, not counting the null wide character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), or zero on runtime constraint violations, and negative value on encoding errors.\n\n7) number of wide characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\nWhile narrow strings provide [`vsnprintf`](vfprintf \"c/io/vfprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call `vswprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`vsnwprintf_s`, unlike `vswprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <wchar.h>\n \nvoid debug_wlog(const wchar_t *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args;\n    va_start(args, fmt);\n    wchar_t buf[1024];\n    int rc2 = vswprintf(buf, sizeof buf / sizeof *buf, fmt, args);\n    va_end(args);\n \n    if(rc2 > 0)\n       wprintf(L\"%s [debug]: %ls\\n\", time_buf, buf);\n    else\n       wprintf(L\"%s [debug]: (string too long)\\n\", time_buf);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"\");\n    debug_wlog(L\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 22:12:38.476575 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.5 The vfwprintf function (p: 417-418)\n  - 7.29.2.7 The vswprintf function (p: 419)\n  - 7.29.2.9 The vwprintf function (p: 420)\n  - K.3.9.1.6 The vfwprintf_s function (p: 632)\n  - K.3.9.1.8 The vsnwprintf_s function (p: 633-634)\n  - K.3.9.1.9 The vswprintf_s function (p: 634-635)\n  - K.3.9.1.11 The vwprintf_s function (p: 636)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.5 The vfwprintf function (p: 363)\n  - 7.24.2.7 The vswprintf function (p: 364)\n  - 7.24.2.9 The vwprintf function (p: 365)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwprintf](https://en.cppreference.com/w/c/io/vfwprintf)"
- name: vswscanf
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vwscanf, vfwscanf, vswscanf, vwscanf_s, vfwscanf_s, vswscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vwscanf_s` , `vfwscanf_s`, and `vswscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions may invoke `va_arg`, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.6 The vfwscanf function (p: 418)\n  - 7.29.2.8 The vswscanf function (p: 419)\n  - 7.29.2.10 The vwscanf function (p: 420)\n  - K.3.9.1.7 The vfwscanf_s function (p: 632-633)\n  - K.3.9.1.10 The vswscanf_s function (p: 635-636)\n  - K.3.9.1.12 The vwscanf_s function (p: 637)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.6 The vfwscanf function (p: 364)\n  - 7.24.2.8 The vswscanf function (p: 365)\n  - 7.24.2.10 The vwscanf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwscanf](https://en.cppreference.com/w/c/io/vfwscanf)"
- name: vswscanf_s
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vwscanf, vfwscanf, vswscanf, vwscanf_s, vfwscanf_s, vswscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vwscanf_s` , `vfwscanf_s`, and `vswscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions may invoke `va_arg`, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.6 The vfwscanf function (p: 418)\n  - 7.29.2.8 The vswscanf function (p: 419)\n  - 7.29.2.10 The vwscanf function (p: 420)\n  - K.3.9.1.7 The vfwscanf_s function (p: 632-633)\n  - K.3.9.1.10 The vswscanf_s function (p: 635-636)\n  - K.3.9.1.12 The vwscanf_s function (p: 637)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.6 The vfwscanf function (p: 364)\n  - 7.24.2.8 The vswscanf function (p: 365)\n  - 7.24.2.10 The vwscanf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwscanf](https://en.cppreference.com/w/c/io/vfwscanf)"
- name: vwprintf
  summary: Loads the data from locations, defined by vlist, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# vwprintf, vfwprintf, vswprintf, vwprintf_s, vfwprintf_s, vswprintf_s, vsnwprintf_s\n\n[TABLE]\n\nLoads the data from locations, defined by `vlist`, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. The resulting wide character string will be terminated with a null wide character, unless `bufsz` is zero.\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vswprintf_s` only), the string to be stored in `buffer` (including the trailing wide null) would be exceed `bufsz`\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by `buffer`. As with all bounds-checked functions, `vwprintf_s` , `vfwprintf_s`, `vswprintf_s`, and `vsnwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                    |\n|--------|-----|----------------------------------------------------------------------------------------------------|\n| stream | \\-  | output wide stream to write to                                                                     |\n| buffer | \\-  | pointer to a wide string to write to                                                               |\n| bufsz  | \\-  | maximum number of wide characters to write                                                         |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                      |\n| vlist  | \\-  | [variable argument list](../language/variadic \"c/language/variadic\") containing the data to print. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,4) The number of wide characters written if successful or negative value if an error occurred.\n\n3) The number of wide characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `bufsz` limit, function returns the total number of characters (not including the terminating null wide character) which would have been written, if the limit were not imposed.\n\n2,5) number of wide characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n6) number of wide characters written to `buffer`, not counting the null wide character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), or zero on runtime constraint violations, and negative value on encoding errors.\n\n7) number of wide characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\nWhile narrow strings provide [`vsnprintf`](vfprintf \"c/io/vfprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call `vswprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`vsnwprintf_s`, unlike `vswprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <wchar.h>\n \nvoid debug_wlog(const wchar_t *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args;\n    va_start(args, fmt);\n    wchar_t buf[1024];\n    int rc2 = vswprintf(buf, sizeof buf / sizeof *buf, fmt, args);\n    va_end(args);\n \n    if(rc2 > 0)\n       wprintf(L\"%s [debug]: %ls\\n\", time_buf, buf);\n    else\n       wprintf(L\"%s [debug]: (string too long)\\n\", time_buf);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"\");\n    debug_wlog(L\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 22:12:38.476575 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.5 The vfwprintf function (p: 417-418)\n  - 7.29.2.7 The vswprintf function (p: 419)\n  - 7.29.2.9 The vwprintf function (p: 420)\n  - K.3.9.1.6 The vfwprintf_s function (p: 632)\n  - K.3.9.1.8 The vsnwprintf_s function (p: 633-634)\n  - K.3.9.1.9 The vswprintf_s function (p: 634-635)\n  - K.3.9.1.11 The vwprintf_s function (p: 636)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.5 The vfwprintf function (p: 363)\n  - 7.24.2.7 The vswprintf function (p: 364)\n  - 7.24.2.9 The vwprintf function (p: 365)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwprintf](https://en.cppreference.com/w/c/io/vfwprintf)"
- name: vwprintf_s
  summary: Loads the data from locations, defined by vlist, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# vwprintf, vfwprintf, vswprintf, vwprintf_s, vfwprintf_s, vswprintf_s, vsnwprintf_s\n\n[TABLE]\n\nLoads the data from locations, defined by `vlist`, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) Writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. The resulting wide character string will be terminated with a null wide character, unless `bufsz` is zero.\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (for `vswprintf_s` only), the string to be stored in `buffer` (including the trailing wide null) would be exceed `bufsz`\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by `buffer`. As with all bounds-checked functions, `vwprintf_s` , `vfwprintf_s`, `vswprintf_s`, and `vsnwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                    |\n|--------|-----|----------------------------------------------------------------------------------------------------|\n| stream | \\-  | output wide stream to write to                                                                     |\n| buffer | \\-  | pointer to a wide string to write to                                                               |\n| bufsz  | \\-  | maximum number of wide characters to write                                                         |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                      |\n| vlist  | \\-  | [variable argument list](../language/variadic \"c/language/variadic\") containing the data to print. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,4) The number of wide characters written if successful or negative value if an error occurred.\n\n3) The number of wide characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to `bufsz` limit, function returns the total number of characters (not including the terminating null wide character) which would have been written, if the limit were not imposed.\n\n2,5) number of wide characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.\n\n6) number of wide characters written to `buffer`, not counting the null wide character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), or zero on runtime constraint violations, and negative value on encoding errors.\n\n7) number of wide characters not including the terminating null character (which is always written as long as `buffer` is not a null pointer and `bufsz` is not zero and not greater than `RSIZE_MAX/sizeof(wchar_t)`), which would have been written to `buffer` if `bufsz` was ignored, or a negative value if a runtime constraints violation or an encoding error occurred.\n\n### Notes\n\nAll these functions invoke `va_arg` at least once, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\nWhile narrow strings provide [`vsnprintf`](vfprintf \"c/io/vfprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call `vswprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`vsnwprintf_s`, unlike `vswprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <wchar.h>\n \nvoid debug_wlog(const wchar_t *fmt, ...)\n{\n    struct timespec ts;\n    timespec_get(&ts, TIME_UTC);\n    char time_buf[100];\n    size_t rc = strftime(time_buf, sizeof time_buf, \"%D %T\", gmtime(&ts.tv_sec));\n    snprintf(time_buf + rc, sizeof time_buf - rc, \".%06ld UTC\", ts.tv_nsec / 1000);\n \n    va_list args;\n    va_start(args, fmt);\n    wchar_t buf[1024];\n    int rc2 = vswprintf(buf, sizeof buf / sizeof *buf, fmt, args);\n    va_end(args);\n \n    if(rc2 > 0)\n       wprintf(L\"%s [debug]: %ls\\n\", time_buf, buf);\n    else\n       wprintf(L\"%s [debug]: (string too long)\\n\", time_buf);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"\");\n    debug_wlog(L\"Logging, %d, %d, %d\", 1, 2, 3);\n}\n```\n\nPossible output:\n\n```\n02/20/15 22:12:38.476575 UTC [debug]: Logging, 1, 2, 3\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.5 The vfwprintf function (p: 417-418)\n  - 7.29.2.7 The vswprintf function (p: 419)\n  - 7.29.2.9 The vwprintf function (p: 420)\n  - K.3.9.1.6 The vfwprintf_s function (p: 632)\n  - K.3.9.1.8 The vsnwprintf_s function (p: 633-634)\n  - K.3.9.1.9 The vswprintf_s function (p: 634-635)\n  - K.3.9.1.11 The vwprintf_s function (p: 636)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.5 The vfwprintf function (p: 363)\n  - 7.24.2.7 The vswprintf function (p: 364)\n  - 7.24.2.9 The vwprintf function (p: 365)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwprintf](https://en.cppreference.com/w/c/io/vfwprintf)"
- name: vwscanf
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vwscanf, vfwscanf, vswscanf, vwscanf_s, vfwscanf_s, vswscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vwscanf_s` , `vfwscanf_s`, and `vswscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions may invoke `va_arg`, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.6 The vfwscanf function (p: 418)\n  - 7.29.2.8 The vswscanf function (p: 419)\n  - 7.29.2.10 The vwscanf function (p: 420)\n  - K.3.9.1.7 The vfwscanf_s function (p: 632-633)\n  - K.3.9.1.10 The vswscanf_s function (p: 635-636)\n  - K.3.9.1.12 The vwscanf_s function (p: 637)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.6 The vfwscanf function (p: 364)\n  - 7.24.2.8 The vswscanf function (p: 365)\n  - 7.24.2.10 The vwscanf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwscanf](https://en.cppreference.com/w/c/io/vfwscanf)"
- name: vwscanf_s
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist
  description: "# vwscanf, vfwscanf, vswscanf, vwscanf_s, vfwscanf_s, vswscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into locations defined by `vlist`.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be 1 when reading with a %lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by %c, %s, or %\\[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs with all bounds-checked functions, `vwscanf_s` , `vfwscanf_s`, and `vswscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| vlist  | \\-  | variable argument list containing the receiving arguments.                |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Notes\n\nAll these functions may invoke `va_arg`, the value of `arg` is indeterminate after the return. These functions to not invoke `va_end`, and it must be done by the caller.\n\n### Example\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.6 The vfwscanf function (p: 418)\n  - 7.29.2.8 The vswscanf function (p: 419)\n  - 7.29.2.10 The vwscanf function (p: 420)\n  - K.3.9.1.7 The vfwscanf_s function (p: 632-633)\n  - K.3.9.1.10 The vswscanf_s function (p: 635-636)\n  - K.3.9.1.12 The vwscanf_s function (p: 637)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.6 The vfwscanf function (p: 364)\n  - 7.24.2.8 The vswscanf function (p: 365)\n  - 7.24.2.10 The vwscanf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/vfwscanf](https://en.cppreference.com/w/c/io/vfwscanf)"
- name: wcrtomb
  summary: Converts a wide character to its narrow multibyte representation
  description: "# wcrtomb, wcrtomb_s\n\n[TABLE]\n\nConverts a wide character to its narrow multibyte representation.\n\n1) If `s` is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of `wc` (including any shift sequences, and taking into account the current multibyte conversion state `*ps`), and stores the multibyte character representation in the character array whose first element is pointed to by `s`, updating `*ps` as necessary. At most `MB_CUR_MAX` bytes can be written by this function.\n\nIf `s` is a null pointer, the call is equivalent to `wcrtomb(buf, L'\\0', ps)` for some internal buffer `buf`.\n\nIf wc is the null wide character `L'\\0'`, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter `*ps` is updated to represent the initial shift state.\n\nIf the environment macro `__STDC_ISO_10646__` is defined, the values of type `wchar_t` are the same as the short identifiers of the characters in the Unicode required set (typically UTF-32 encoding); otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\n2) Same as (1), except that\n\nif `s` is a null pointer, the call is equivalent to `wcrtomb_s(&retval, buf, sizeof buf, L'\\0', ps)` with internal variables `retval` and `buf` (whose size is greater than `MB_CUR_MAX`)\n\nthe result is returned in the out-parameter `retval`\n\nthe following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `retval` or `ps` is a null pointer.\n- `ssz` is zero or greater than `RSIZE_MAX` (unless `s` is null)\n- `ssz` is less than the number of bytes that would be written (unless `s` is null)\n- `s` is a null pointer but `ssz` is not zero\n\nAs with all bounds-checked functions, `wcrtomb_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                                                                                     |\n|--------|-----|-------------------------------------------------------------------------------------------------------------------------------------|\n| s      | \\-  | pointer to narrow character array where the multibyte character will be stored                                                      |\n| wc     | \\-  | the wide character to convert                                                                                                       |\n| ps     | \\-  | pointer to the conversion state object used when interpreting the multibyte string                                                  |\n| ssz    | \\-  | max number of bytes to write (the size of the buffer `s`)                                                                           |\n| retval | \\-  | pointer to an out-parameter where the result (number of bytes in the multibyte string including any shift sequences) will be stored |\n\n### Return value\n\n1) On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by `s`.\n\nOn failure (if `wc` is not a valid wide character), returns `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1`, stores [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") in [`errno`](../../error/errno \"c/error/errno\"), and leaves `*ps` in unspecified state.\n\n2) Returns zero on success and non-zero on failure, in which case, `s[0]` is set to `'\\0'` (unless `s` is null or `ssz` is zero or greater than `RSIZE_MAX`) and `*retval` is set to `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` (unless `retval` is null)\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    mbstate_t state;\n    memset(&state, 0, sizeof state);\n    wchar_t in[] = L\"zß水🍌\"; // or \"z\\u00df\\u6c34\\U0001F34C\"\n    size_t in_sz = sizeof in / sizeof *in;\n \n    printf(\"Processing %zu wchar_t units: [ \", in_sz);\n    for(size_t n = 0; n < in_sz; ++n) printf(\"%#x \", (unsigned int)in[n]);\n    puts(\"]\");\n \n    char out[MB_CUR_MAX * in_sz];\n    char *p = out;\n    for(size_t n = 0; n < in_sz; ++n) {\n        int rc = wcrtomb(p, in[n], &state); \n        if(rc == -1) break;\n        p += rc;\n    }\n \n    size_t out_sz = p - out;\n    printf(\"into %zu UTF-8 code units: [ \", out_sz);\n    for(size_t x = 0; x < out_sz; ++x) printf(\"%#x \", +(unsigned char)out[x]);\n    puts(\"]\");\n}\n```\n\nOutput:\n\n```\nProcessing 5 wchar_t units: [ 0x7a 0xdf 0x6c34 0x1f34c 0 ]\ninto 11 UTF-8 code units: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c 0 ]\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.3.3 The wcrtomb function (p: 444)\n  - K.3.9.3.1.1 The wcrtomb_s function (p: 647-648)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.3.3 The wcrtomb function (p: 390)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/wcrtomb](https://en.cppreference.com/w/c/string/multibyte/wcrtomb)"
- name: wcrtomb_s
  summary: Converts a wide character to its narrow multibyte representation
  description: "# wcrtomb, wcrtomb_s\n\n[TABLE]\n\nConverts a wide character to its narrow multibyte representation.\n\n1) If `s` is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of `wc` (including any shift sequences, and taking into account the current multibyte conversion state `*ps`), and stores the multibyte character representation in the character array whose first element is pointed to by `s`, updating `*ps` as necessary. At most `MB_CUR_MAX` bytes can be written by this function.\n\nIf `s` is a null pointer, the call is equivalent to `wcrtomb(buf, L'\\0', ps)` for some internal buffer `buf`.\n\nIf wc is the null wide character `L'\\0'`, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter `*ps` is updated to represent the initial shift state.\n\nIf the environment macro `__STDC_ISO_10646__` is defined, the values of type `wchar_t` are the same as the short identifiers of the characters in the Unicode required set (typically UTF-32 encoding); otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\n2) Same as (1), except that\n\nif `s` is a null pointer, the call is equivalent to `wcrtomb_s(&retval, buf, sizeof buf, L'\\0', ps)` with internal variables `retval` and `buf` (whose size is greater than `MB_CUR_MAX`)\n\nthe result is returned in the out-parameter `retval`\n\nthe following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `retval` or `ps` is a null pointer.\n- `ssz` is zero or greater than `RSIZE_MAX` (unless `s` is null)\n- `ssz` is less than the number of bytes that would be written (unless `s` is null)\n- `s` is a null pointer but `ssz` is not zero\n\nAs with all bounds-checked functions, `wcrtomb_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                                                                                     |\n|--------|-----|-------------------------------------------------------------------------------------------------------------------------------------|\n| s      | \\-  | pointer to narrow character array where the multibyte character will be stored                                                      |\n| wc     | \\-  | the wide character to convert                                                                                                       |\n| ps     | \\-  | pointer to the conversion state object used when interpreting the multibyte string                                                  |\n| ssz    | \\-  | max number of bytes to write (the size of the buffer `s`)                                                                           |\n| retval | \\-  | pointer to an out-parameter where the result (number of bytes in the multibyte string including any shift sequences) will be stored |\n\n### Return value\n\n1) On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by `s`.\n\nOn failure (if `wc` is not a valid wide character), returns `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1`, stores [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") in [`errno`](../../error/errno \"c/error/errno\"), and leaves `*ps` in unspecified state.\n\n2) Returns zero on success and non-zero on failure, in which case, `s[0]` is set to `'\\0'` (unless `s` is null or `ssz` is zero or greater than `RSIZE_MAX`) and `*retval` is set to `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` (unless `retval` is null)\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\n#include <stdlib.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    mbstate_t state;\n    memset(&state, 0, sizeof state);\n    wchar_t in[] = L\"zß水🍌\"; // or \"z\\u00df\\u6c34\\U0001F34C\"\n    size_t in_sz = sizeof in / sizeof *in;\n \n    printf(\"Processing %zu wchar_t units: [ \", in_sz);\n    for(size_t n = 0; n < in_sz; ++n) printf(\"%#x \", (unsigned int)in[n]);\n    puts(\"]\");\n \n    char out[MB_CUR_MAX * in_sz];\n    char *p = out;\n    for(size_t n = 0; n < in_sz; ++n) {\n        int rc = wcrtomb(p, in[n], &state); \n        if(rc == -1) break;\n        p += rc;\n    }\n \n    size_t out_sz = p - out;\n    printf(\"into %zu UTF-8 code units: [ \", out_sz);\n    for(size_t x = 0; x < out_sz; ++x) printf(\"%#x \", +(unsigned char)out[x]);\n    puts(\"]\");\n}\n```\n\nOutput:\n\n```\nProcessing 5 wchar_t units: [ 0x7a 0xdf 0x6c34 0x1f34c 0 ]\ninto 11 UTF-8 code units: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c 0 ]\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.3.3 The wcrtomb function (p: 444)\n  - K.3.9.3.1.1 The wcrtomb_s function (p: 647-648)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.3.3 The wcrtomb function (p: 390)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/wcrtomb](https://en.cppreference.com/w/c/string/multibyte/wcrtomb)"
- name: wcscat
  summary: 'Output:'
  description: "# wcscat, wcscat_s\n\n[TABLE]\n\n1) Appends a copy of the wide string pointed to by `src` to the end of the wide string pointed to by `dest`. The wide character `src[0]` replaces the null terminator at the end of `dest`. The resulting wide string is null-terminated. The behavior is undefined if the destination array is not large enough for the contents of both `str` and `dest` and the terminating null wide character. The behavior is undefined if the strings overlap.\n\n2) Same as (1), except that it may clobber the rest of the destination array (from the last character written to `destsz`) with unspecified values and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- there is no null terminator in the first `destsz` wide characters of `dest`\n- truncation would occur (the available space at the end of `dest` would not fit every wide character, including the null terminator, of `src`)\n- overlap would occur between the source and the destination strings\n\nAs with all bounds-checked functions, `wcscat_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                                     |\n|--------|-----|-------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the null-terminated wide string to append to                             |\n| src    | \\-  | pointer to the null-terminated wide string to copy from                             |\n| destsz | \\-  | maximum number of characters to write, typically the size of the destination buffer |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes `L'\\0'` to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`).\n\n### Example\n\n```\n#include <wchar.h> \n#include <stdio.h>\n#include <locale.h>\n \nint main(void) \n{\n    wchar_t str[50] = L\"Земля, прощай.\";\n    wcscat(str, L\" \");\n    wcscat(str, L\"В добрый путь.\");\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"%ls\", str);\n}\n```\n\nOutput:\n\n```\nЗемля, прощай. В добрый путь.\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.3.1 The wcscat function (p: 315)\n  - K.3.9.2.2.1 The wcscat_s function (p: 466)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.3.1 The wcscat function (p: 432)\n  - K.3.9.2.2.1 The wcscat_s function (p: 642-643)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.3.1 The wcscat function (p: 378)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcscat](https://en.cppreference.com/w/c/string/wide/wcscat)"
- name: wcscat_s
  summary: 'Output:'
  description: "# wcscat, wcscat_s\n\n[TABLE]\n\n1) Appends a copy of the wide string pointed to by `src` to the end of the wide string pointed to by `dest`. The wide character `src[0]` replaces the null terminator at the end of `dest`. The resulting wide string is null-terminated. The behavior is undefined if the destination array is not large enough for the contents of both `str` and `dest` and the terminating null wide character. The behavior is undefined if the strings overlap.\n\n2) Same as (1), except that it may clobber the rest of the destination array (from the last character written to `destsz`) with unspecified values and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- there is no null terminator in the first `destsz` wide characters of `dest`\n- truncation would occur (the available space at the end of `dest` would not fit every wide character, including the null terminator, of `src`)\n- overlap would occur between the source and the destination strings\n\nAs with all bounds-checked functions, `wcscat_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                                     |\n|--------|-----|-------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the null-terminated wide string to append to                             |\n| src    | \\-  | pointer to the null-terminated wide string to copy from                             |\n| destsz | \\-  | maximum number of characters to write, typically the size of the destination buffer |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes `L'\\0'` to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`).\n\n### Example\n\n```\n#include <wchar.h> \n#include <stdio.h>\n#include <locale.h>\n \nint main(void) \n{\n    wchar_t str[50] = L\"Земля, прощай.\";\n    wcscat(str, L\" \");\n    wcscat(str, L\"В добрый путь.\");\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"%ls\", str);\n}\n```\n\nOutput:\n\n```\nЗемля, прощай. В добрый путь.\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.3.1 The wcscat function (p: 315)\n  - K.3.9.2.2.1 The wcscat_s function (p: 466)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.3.1 The wcscat function (p: 432)\n  - K.3.9.2.2.1 The wcscat_s function (p: 642-643)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.3.1 The wcscat function (p: 378)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcscat](https://en.cppreference.com/w/c/string/wide/wcscat)"
- name: wcschr
  summary: Pointer to the found character in str, or a null pointer if no such character is found
  description: "# wcschr\n\n[TABLE]\n\n1) Finds the first occurrence of the wide character `ch` in the wide string pointed to by `str`.\n\n2) Type-generic function equivalent to (1). Let `T` be an unqualified wide character object type.\n\n- If `str` is of type `const T*`, the return type is `const wchar_t*`.\n- Otherwise, if `str` is of type `T*`, the return type is `wchar_t*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(wcschr)` or a function pointer is used), the actual function declaration (1) becomes visible.\n\n### Parameters\n\n|     |     |                                                           |\n|-----|-----|-----------------------------------------------------------|\n| str | \\-  | pointer to the null-terminated wide string to be analyzed |\n| ch  | \\-  | wide character to search for                              |\n\n### Return value\n\nPointer to the found character in `str`, or a null pointer if no such character is found.\n\n### Example\n\n```\n#include <wchar.h>\n#include <stdio.h>\n#include <locale.h>\n \nint main(void)\n{\n    wchar_t arr[] = L\"白猫 黒猫 кошки\";\n    wchar_t *cat = wcschr(arr, L'猫');\n    wchar_t *dog = wcschr(arr, L'犬');\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    if(cat)\n        printf(\"The character 猫 found at position %td\\n\", cat-arr);\n    else\n        puts(\"The character 猫 not found\");\n \n    if(dog)\n        printf(\"The character 犬 found at position %td\\n\", dog-arr);\n    else\n        puts(\"The character 犬 not found\");\n}\n```\n\nOutput:\n\n```\nThe character 猫 found at position 1\nThe character 犬 not found\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.5.1 The wcschr function (p: 435)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.5.1 The wcschr function (p: 381)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcschr](https://en.cppreference.com/w/c/string/wide/wcschr)"
- name: wcscmp
  summary: Compares two null-terminated wide strings lexicographically
  description: "# wcscmp\n\n[TABLE]\n\nCompares two null-terminated wide strings lexicographically.\n\nThe sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.\n\nThe behavior is undefined if `lhs` or `rhs` are not pointers to null-terminated wide strings.\n\n### Parameters\n\n|          |     |                                                         |\n|----------|-----|---------------------------------------------------------|\n| lhs, rhs | \\-  | pointers to the null-terminated wide strings to compare |\n\n### Return value\n\nNegative value if `lhs` appears before `rhs` in lexicographical order.\n\nZero if `lhs` and `rhs` compare equal.\n\nPositive value if `lhs` appears after `rhs` in lexicographical order.\n\n### Notes\n\nThis function is not locale-sensitive, unlike [`wcscoll`](wcscoll \"c/string/wide/wcscoll\"), and the order may not be meaningful when characters from different Unicode blocks are used together or when the order of code units does not match any collation order.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nvoid demo(const wchar_t* lhs, const wchar_t* rhs)\n{\n    int rc = wcscmp(lhs, rhs);\n    const char *rel = rc < 0 ? \"precedes\" : rc > 0 ? \"follows\" : \"equals\";\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"[%ls] %s [%ls]\\n\", lhs, rel, rhs);\n}\n \nint main(void)\n{\n    const wchar_t* string = L\"どうもありがとうございます\";\n    demo(string, L\"どうも\");\n    demo(string, L\"助かった\");\n    demo(string + 9, L\"ありがとうございます\" + 6);\n}\n```\n\nPossible output:\n\n```\n[どうもありがとうございます] follows [どうも]\n[どうもありがとうございます] precedes [助かった]\n[ざいます] equals [ざいます]\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.29.4.4.1 The wcscmp function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.4.1 The wcscmp function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.4.1 The wcscmp function (p: 433)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.4.1 The wcscmp function (p: 379)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcscmp](https://en.cppreference.com/w/c/string/wide/wcscmp)"
- name: wcscoll
  summary: Compares two null-terminated wide strings according to the collation order defined by the LC_COLLATE category of the currently installed locale
  description: "# wcscoll\n\n[TABLE]\n\nCompares two null-terminated wide strings according to the collation order defined by the [`LC_COLLATE`](../../locale/lc_categories \"c/locale/LC categories\") category of the currently installed locale.\n\n### Parameters\n\n|          |     |                                                         |\n|----------|-----|---------------------------------------------------------|\n| lhs, rhs | \\-  | pointers to the null-terminated wide strings to compare |\n\n### Return value\n\nNegative value if `lhs` is *less than* (precedes) `rhs`.\n\n`​0​` if `lhs` is *equal to* `rhs`.\n\nPositive value if `lhs` is *greater than* (follows) `rhs`.\n\n### Notes\n\nCollation order is the dictionary order: the position of the letter in the national alphabet (its *equivalence class*) has higher priority than its case or variant. Within an equivalence class, lowercase characters collate before their uppercase equivalents and locale-specific order may apply to the characters with diacritics. In some locales, groups of characters compare as single *collation units*. For example, `\"ch\"` in Czech follows `\"h\"` and precedes `\"i\"`, and `\"dzs\"` in Hungarian follows `\"dz\"` and precedes `\"g\"`.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n \nvoid try_compare(const wchar_t* p1, const wchar_t* p2)\n{\n    if(wcscoll(p1, p2) < 0)\n        printf(\"%ls before %ls\\n\", p1, p2);\n    else\n        printf(\"%ls before %ls\\n\", p2, p1);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"In the American locale: \");\n    try_compare(L\"hrnec\", L\"chrt\");\n \n    setlocale(LC_COLLATE, \"cs_CZ.utf8\");\n    printf(\"In the Czech locale: \");\n    try_compare(L\"hrnec\", L\"chrt\");\n \n    setlocale(LC_COLLATE, \"en_US.utf8\");\n    printf(\"In the American locale: \");\n    try_compare(L\"år\", L\"ängel\");\n \n    setlocale(LC_COLLATE, \"sv_SE.utf8\");\n    printf(\"In the Swedish locale: \");\n    try_compare(L\"år\", L\"ängel\");\n}\n```\n\nPossible output:\n\n```\nIn the American locale: chrt before hrnec\nIn the Czech locale: hrnec before chrt\nIn the American locale: ängel before år\nIn the Swedish locale: år before ängel\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.4.2 The wcscoll function (p: 433-434)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.4.2 The wcscoll function (p: 379-380)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcscoll](https://en.cppreference.com/w/c/string/wide/wcscoll)"
- name: wcscpy
  summary: 'Output:'
  description: "# wcscpy, wcscpy_s\n\n[TABLE]\n\n1) Copies the wide string pointed to by `src` (including the terminating null wide character) to wide character array pointed to by `dest`. The behavior is undefined if the `dest` array is not large enough. The behavior is undefined if the strings overlap.\n\n2) Same as (1), except that it may clobber the rest of the destination array with unspecified values and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` is zero or greater than `RSIZE_MAX / sizeof(wchar_t)`\n- `destsz` is less or equal `wcsnlen_s(src, destsz)`, in other words, truncation would occur\n- overlap would occur between the source and the destination strings\n\nAs with all bounds-checked functions, `wcscpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                                     |\n|--------|-----|-------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the wide character array to copy to                                      |\n| src    | \\-  | pointer to the null-terminated wide string to copy from                             |\n| destsz | \\-  | maximum number of characters to write, typically the size of the destination buffer |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes `L'\\0'` to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RMAX_SIZE / sizeof(wchar_t)`).\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    wchar_t* src = L\"犬 means dog\";\n//  src[0] = L'狗' ; // this would be undefined behavior\n    wchar_t dst[wcslen(src) + 1]; // +1 for the null terminator\n    wcscpy(dst, src);\n    dst[0] = L'狗'; // OK\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"src = %ls\\ndst = %ls\\n\", src, dst);\n}\n```\n\nOutput:\n\n```\nsrc = 犬 means dog\ndst = 狗 means dog\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.29.4.1.2 The wcscpy function (p: TBD)\n  - K.3.9.2.1.1 The wcscpy_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.1.2 The wcscpy function (p: TBD)\n  - K.3.9.2.1.1 The wcscpy_s function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.1.2 The wcscpy function (p: 430)\n  - K.3.9.2.1.1 The wcscpy_s function (p: 639)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.1.2 The wcscpy function (p: 376)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcscpy](https://en.cppreference.com/w/c/string/wide/wcscpy)"
- name: wcscpy_s
  summary: 'Output:'
  description: "# wcscpy, wcscpy_s\n\n[TABLE]\n\n1) Copies the wide string pointed to by `src` (including the terminating null wide character) to wide character array pointed to by `dest`. The behavior is undefined if the `dest` array is not large enough. The behavior is undefined if the strings overlap.\n\n2) Same as (1), except that it may clobber the rest of the destination array with unspecified values and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` is zero or greater than `RSIZE_MAX / sizeof(wchar_t)`\n- `destsz` is less or equal `wcsnlen_s(src, destsz)`, in other words, truncation would occur\n- overlap would occur between the source and the destination strings\n\nAs with all bounds-checked functions, `wcscpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                                     |\n|--------|-----|-------------------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the wide character array to copy to                                      |\n| src    | \\-  | pointer to the null-terminated wide string to copy from                             |\n| destsz | \\-  | maximum number of characters to write, typically the size of the destination buffer |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes `L'\\0'` to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RMAX_SIZE / sizeof(wchar_t)`).\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    wchar_t* src = L\"犬 means dog\";\n//  src[0] = L'狗' ; // this would be undefined behavior\n    wchar_t dst[wcslen(src) + 1]; // +1 for the null terminator\n    wcscpy(dst, src);\n    dst[0] = L'狗'; // OK\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"src = %ls\\ndst = %ls\\n\", src, dst);\n}\n```\n\nOutput:\n\n```\nsrc = 犬 means dog\ndst = 狗 means dog\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.29.4.1.2 The wcscpy function (p: TBD)\n  - K.3.9.2.1.1 The wcscpy_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.1.2 The wcscpy function (p: TBD)\n  - K.3.9.2.1.1 The wcscpy_s function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.1.2 The wcscpy function (p: 430)\n  - K.3.9.2.1.1 The wcscpy_s function (p: 639)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.1.2 The wcscpy function (p: 376)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcscpy](https://en.cppreference.com/w/c/string/wide/wcscpy)"
- name: wcscspn
  summary: Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src
  description: "# wcscspn\n\n[TABLE]\n\nReturns the length of the maximum initial segment of the wide string pointed to by `dest`, that consists of only the characters *not* found in wide string pointed to by `src`.\n\n### Parameters\n\n|      |     |                                                                                       |\n|------|-----|---------------------------------------------------------------------------------------|\n| dest | \\-  | pointer to the null-terminated wide string to be analyzed                             |\n| src  | \\-  | pointer to the null-terminated wide string that contains the characters to search for |\n\n### Return value\n\nThe length of the maximum initial segment that contains only characters not found in the character string pointed to by `src`\n\n### Example\n\n```\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    wchar_t dest[] = L\"白猫 黑狗 甲虫\";\n    /*                      └───┐   */\n    const wchar_t *src = L\"甲虫,黑狗\";\n \n    const size_t len = wcscspn(dest, src);\n    dest[len] = L'\\0'; /* terminates the segment to print it out */\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    wprintf(L\"The length of maximum initial segment is %td.\\n\"\n            L\"The segment is \\\"%ls\\\".\\n\", len, dest);\n}\n```\n\nOutput:\n\n```\nThe length of maximum initial segment is 3.\nThe segment is \"白猫 \".\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.5.2 The wcscspn function (p: 435-436)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.5.2 The wcscspn function (p: 381-382)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcscspn](https://en.cppreference.com/w/c/string/wide/wcscspn)"
- name: wcsftime
  summary: Converts the date and time information from a given calendar time time to a null-terminated wide character string str according to format string format
  description: "# wcsftime\n\n[TABLE]\n\nConverts the date and time information from a given calendar time `time` to a null-terminated wide character string `str` according to [format string](#Format_string) `format`. Up to `count` bytes are written.\n\n### Parameters\n\n|        |     |                                                                                                          |\n|--------|-----|----------------------------------------------------------------------------------------------------------|\n| str    | \\-  | pointer to the first element of the wchar_t array for output                                             |\n| count  | \\-  | maximum number of wide characters to write                                                               |\n| format | \\-  | pointer to a null-terminated wide character string specifying the [format of conversion](#Format_string) |\n\n### Format string\n\nThe format string consists of zero or more conversion specifiers and ordinary characters (except `%`). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with `%` character, optionally followed by `E` or `O` modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:\n\n[TABLE]\n\n### Return value\n\nnumber of wide characters written into the wide character array pointed to by `str` not including the terminating `L'\\0'` on success. If `count` was reached before the entire string could be stored, `​0​` is returned and the contents are undefined.\n\n### Example\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <wchar.h>\n#include <locale.h>\n \nint main(void)\n{\n    wchar_t buff[40];\n    struct tm my_time = { .tm_year=112, // = year 2012\n                          .tm_mon=9,    // = 10th month\n                          .tm_mday=9,   // = 9th day\n                          .tm_hour=8,   // = 8 hours\n                          .tm_min=10,   // = 10 minutes\n                          .tm_sec=20    // = 20 secs\n    };\n \n    if (wcsftime(buff, sizeof buff, L\"%A %c\", &my_time)) {\n        printf(\"%ls\\n\", buff);\n    } else {\n        puts(\"wcsftime failed\");\n    }\n \n    setlocale(LC_ALL, \"ja_JP.utf8\");\n \n    if (wcsftime(buff, sizeof buff, L\"%A %c\", &my_time)) {\n        printf(\"%ls\\n\", buff);\n    } else {\n        puts(\"wcsftime failed\");\n    }\n}\n```\n\nOutput:\n\n```\nSunday Sun Oct  9 08:10:20 2012\n日曜日 2012年10月09日 08時10分20秒\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.5.1 The wcsftime function (p: 230-231)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.5.1 The wcsftime function (p: 439-440)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.5.1 The wcsftime function (p: 385-386)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/chrono/wcsftime](https://en.cppreference.com/w/c/chrono/wcsftime)"
- name: wcslen
  summary: strnlen_s and wcsnlen_s are the only bounds-checked functions that do not invoke the runtime constraints handler
  description: "# wcslen, wcsnlen_s\n\n[TABLE]\n\n1) Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character.\n\n2) Same as (1), except that the function returns zero if `str` is a null pointer and returns `strsz` if the null wide character was not found in the first `strsz` wide characters of `src` As with all bounds-checked functions, `wcslen_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../../io \"c/io\")..\n\n### Parameters\n\n|       |     |                                                           |\n|-------|-----|-----------------------------------------------------------|\n| str   | \\-  | pointer to the null-terminated wide string to be examined |\n| strsz | \\-  | maximum number of wide characters to examine              |\n\n### Return value\n\n1) The length of the null-terminated wide string `str`.\n\n2) The length of the null-terminated wide string `str` on success, zero if `str` is a null pointer, `strsz` if the null wide character was not found.\n\n### Notes\n\n`strnlen_s` and `wcsnlen_s` are the only [bounds-checked functions](../../error \"c/error\") that do not invoke the runtime constraints handler. They are pure utility functions used to provide limited support for non-null terminated strings.\n\n### Example\n\n```\n#include <wchar.h>\n#include <stdio.h>\n \nint main(void)\n{\n    wchar_t str[] = L\"How many wide characters does this string contain?\";\n \n    printf(\"without null character: %zu\\n\", wcslen(str));\n    printf(\"with null character: %zu\\n\", sizeof str / sizeof *str);\n}\n```\n\nOutput:\n\n```\nwithout null character: 50\nwith null character: 51\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.6.1 The wcslen function (p: 439)\n  - K.3.9.2.4.1 The wcsnlen_s function (p: 646-647)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.6.1 The wcslen function (p: 385)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcslen](https://en.cppreference.com/w/c/string/wide/wcslen)"
- name: wcsncat
  summary: 'Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for wcsncat_s, it is possible to get the truncating behavior by specifying count equal to the size of the destination array minus one: it will copy the first count wide characters and append the null terminator as always: wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);'
  description: "# wcsncat, wcsncat_s\n\n[TABLE]\n\n1) Appends at most `count` wide characters from the wide string pointed to by `src`, stopping if the null terminator is copied, to the end of the character string pointed to by `dest`. The wide character `src[0]` replaces the null terminator at the end of `dest`. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is `count+1`).\n\nThe behavior is undefined if the destination array is not large enough for the contents of both `str` and `dest` and the terminating null wide character.\n\nThe behavior is undefined if the strings overlap.\n\n2) Same as (1), except that this function may clobber the remainder of the destination array (from the last wide character written to `destsz`) and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` or `count` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- there is no null wide character in the first `destsz` wide characters of `dest`\n- truncation would occur: `count` or the length of `src`, whichever is less, exceeds the space available between the null terminator of `dest` and `destsz`.\n- overlap would occur between the source and the destination strings\n\nAs with all bounds-checked functions, `wcsncat_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                         |\n|--------|-----|---------------------------------------------------------|\n| dest   | \\-  | pointer to the null-terminated wide string to append to |\n| src    | \\-  | pointer to the null-terminated wide string to copy from |\n| count  | \\-  | maximum number of wide characters to copy               |\n| destsz | \\-  | the size of the destination buffer                      |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes `L'\\0'` to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`).\n\n### Notes\n\nAlthough truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for `wcsncat_s`, it is possible to get the truncating behavior by specifying `count` equal to the size of the destination array minus one: it will copy the first `count` wide characters and append the null terminator as always: `wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);`\n\n### Example\n\n```\n#include <wchar.h> \n#include <stdio.h>\n#include <locale.h>\n \nint main(void) \n{\n    wchar_t str[50] = L\"Земля, прощай.\";\n    wcsncat(str, L\" \", 1);\n    wcsncat(str, L\"В добрый путь.\", 8); // only append the first 8 wide chars\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"%ls\", str);\n}\n```\n\nPossible output:\n\n```\nЗемля, прощай. В добрый\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.3.2 The wcsncat function (p: 315)\n  - K.3.9.2.2.2 The wcsncat_s function (p: 466-467)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.3.2 The wcsncat function (p: 432-433)\n  - K.3.9.2.2.2 The wcsncat_s function (p: 643-644)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.3.2 The wcsncat function (p: 378-379)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcsncat](https://en.cppreference.com/w/c/string/wide/wcsncat)"
- name: wcsncat_s
  summary: 'Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for wcsncat_s, it is possible to get the truncating behavior by specifying count equal to the size of the destination array minus one: it will copy the first count wide characters and append the null terminator as always: wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);'
  description: "# wcsncat, wcsncat_s\n\n[TABLE]\n\n1) Appends at most `count` wide characters from the wide string pointed to by `src`, stopping if the null terminator is copied, to the end of the character string pointed to by `dest`. The wide character `src[0]` replaces the null terminator at the end of `dest`. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is `count+1`).\n\nThe behavior is undefined if the destination array is not large enough for the contents of both `str` and `dest` and the terminating null wide character.\n\nThe behavior is undefined if the strings overlap.\n\n2) Same as (1), except that this function may clobber the remainder of the destination array (from the last wide character written to `destsz`) and that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` or `count` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- there is no null wide character in the first `destsz` wide characters of `dest`\n- truncation would occur: `count` or the length of `src`, whichever is less, exceeds the space available between the null terminator of `dest` and `destsz`.\n- overlap would occur between the source and the destination strings\n\nAs with all bounds-checked functions, `wcsncat_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                         |\n|--------|-----|---------------------------------------------------------|\n| dest   | \\-  | pointer to the null-terminated wide string to append to |\n| src    | \\-  | pointer to the null-terminated wide string to copy from |\n| count  | \\-  | maximum number of wide characters to copy               |\n| destsz | \\-  | the size of the destination buffer                      |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes `L'\\0'` to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`).\n\n### Notes\n\nAlthough truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for `wcsncat_s`, it is possible to get the truncating behavior by specifying `count` equal to the size of the destination array minus one: it will copy the first `count` wide characters and append the null terminator as always: `wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);`\n\n### Example\n\n```\n#include <wchar.h> \n#include <stdio.h>\n#include <locale.h>\n \nint main(void) \n{\n    wchar_t str[50] = L\"Земля, прощай.\";\n    wcsncat(str, L\" \", 1);\n    wcsncat(str, L\"В добрый путь.\", 8); // only append the first 8 wide chars\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"%ls\", str);\n}\n```\n\nPossible output:\n\n```\nЗемля, прощай. В добрый\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.3.2 The wcsncat function (p: 315)\n  - K.3.9.2.2.2 The wcsncat_s function (p: 466-467)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.3.2 The wcsncat function (p: 432-433)\n  - K.3.9.2.2.2 The wcsncat_s function (p: 643-644)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.3.2 The wcsncat function (p: 378-379)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcsncat](https://en.cppreference.com/w/c/string/wide/wcsncat)"
- name: wcsncmp
  summary: Compares at most count wide characters of two null-terminated wide strings
  description: "# wcsncmp\n\n[TABLE]\n\nCompares at most `count` wide characters of two null-terminated wide strings. The comparison is done lexicographically.\n\nThe sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.\n\nThe behavior is undefined if `lhs` or `rhs` are not pointers to null-terminated strings.\n\n### Parameters\n\n|          |     |                                                         |\n|----------|-----|---------------------------------------------------------|\n| lhs, rhs | \\-  | pointers to the null-terminated wide strings to compare |\n| count    | \\-  | maximum number of characters to compare                 |\n\n### Return value\n\nNegative value if `lhs` appears before `rhs` in lexicographical order.\n\nZero if `lhs` and `rhs` compare equal.\n\nPositive value if `lhs` appears after `rhs` in lexicographical order.\n\n### Notes\n\nThis function is not locale-sensitive, unlike [`wcscoll`](wcscoll \"c/string/wide/wcscoll\") and [`wcsxfrm`](wcsxfrm \"c/string/wide/wcsxfrm\").\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n \nvoid demo(const wchar_t *lhs, const wchar_t *rhs, int sz)\n{\n    int rc = wcsncmp(lhs, rhs, sz);\n    if(rc == 0)\n        printf(\"First %d characters of [%ls] equal [%ls]\\n\", sz, lhs, rhs);\n    else if(rc < 0)\n        printf(\"First %d characters of [%ls] precede [%ls]\\n\", sz, lhs, rhs);\n    else if(rc > 0)\n        printf(\"First %d characters of [%ls] follow [%ls]\\n\", sz, lhs, rhs);\n}\n \nint main(void)\n{\n    const wchar_t *str1 = L\"안녕하세요\";\n    const wchar_t *str2 = L\"안녕히 가십시오\";\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    demo(str1, str2, 5);\n    demo(str2, str1, 8);\n    demo(str1, str2, 2);\n}\n```\n\nOutput:\n\n```\nFirst 5 characters of [안녕하세요] precede [안녕히 가십시오]\nFirst 8 characters of [안녕히 가십시오] follow [안녕하세요]\nFirst 2 characters of [안녕하세요] equal [안녕히 가십시오]\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.4.3 The wcsncmp function (p: 434)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.4.3 The wcsncmp function (p: 380)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcsncmp](https://en.cppreference.com/w/c/string/wide/wcsncmp)"
- name: wcsncpy
  summary: In typical usage, count is the number of elements in the destination array
  description: "# wcsncpy, wcsncpy_s\n\n[TABLE]\n\n1) Copies at most `count` characters of the wide string pointed to by `src` (including the terminating null wide character) to wide character array pointed to by `dest`.\n\nIf `count` is reached before the entire string `src` was copied, the resulting wide character array is not null-terminated.\n\nIf, after copying the terminating null wide character from `src`, `count` is not reached, additional null wide characters are written to `dest` until the total of `count` characters have been written.\n\nIf the strings overlap, the behavior is undefined.\n\n2) Same as (1), except that the function does not continue writing zeroes into the destination array to pad up to `count`, it stops after writing the terminating null character (if there was no null in the source, it writes one at `dest[count]` and then stops). Also, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` or `count` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- `count` is greater or equal `destsz`, but `destsz` is less or equal `wcsnlen_s(src, count)`, in other words, truncation would occur\n- overlap would occur between the source and the destination strings\n\nAs with all bounds-checked functions, `wcsncpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                |\n|--------|-----|------------------------------------------------|\n| dest   | \\-  | pointer to the wide character array to copy to |\n| src    | \\-  | pointer to the wide string to copy from        |\n| count  | \\-  | maximum number of wide characters to copy      |\n| destsz | \\-  | the size of the destination buffer             |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes `L'\\0'` to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`) and may clobber the rest of the destination array with unspecified values.\n\n### Notes\n\nIn typical usage, `count` is the number of elements in the destination array.\n\nAlthough truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for `wcsncpy_s`, it is possible to get the truncating behavior by specifying `count` equal to the size of the destination array minus one: it will copy the first `count` wide characters and append the null wide terminator as always: `wcsncpy_s(dst, sizeof dst / sizeof *dst, src, (sizeof dst / sizeof *dst)-1);`\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n \nint main(void)\n{\n    const wchar_t src[] = L\"わゐ\";\n    wchar_t dest[6] = {L'あ', L'い', L'う', L'え', L'お'};\n \n    wcsncpy(dest, src, 4); // this will copy わゐ and repeat L'\\0' two times\n \n    puts(\"The contents of dest are: \");\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    const long dest_size = sizeof dest / sizeof *dest;\n    for(wchar_t* p = dest; p-dest != dest_size; ++p) {\n        *p ? printf(\"%lc \", *p)\n           : printf(\"\\\\0 \");\n    }\n}\n```\n\nPossible output:\n\n```\nThe contents of dest are: \nわ ゐ \\0 \\0 お \\0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.2.2 The wcsncpy function (p: 314)\n  - K.3.9.2.1.2 The wcsncpy_s function (p: 464)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.2.2 The wcsncpy function (p: 431)\n  - K.3.9.2.1.2 The wcsncpy_s function (p: 640-641)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.2.2 The wcsncpy function (p: 377)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcsncpy](https://en.cppreference.com/w/c/string/wide/wcsncpy)"
- name: wcsncpy_s
  summary: In typical usage, count is the number of elements in the destination array
  description: "# wcsncpy, wcsncpy_s\n\n[TABLE]\n\n1) Copies at most `count` characters of the wide string pointed to by `src` (including the terminating null wide character) to wide character array pointed to by `dest`.\n\nIf `count` is reached before the entire string `src` was copied, the resulting wide character array is not null-terminated.\n\nIf, after copying the terminating null wide character from `src`, `count` is not reached, additional null wide characters are written to `dest` until the total of `count` characters have been written.\n\nIf the strings overlap, the behavior is undefined.\n\n2) Same as (1), except that the function does not continue writing zeroes into the destination array to pad up to `count`, it stops after writing the terminating null character (if there was no null in the source, it writes one at `dest[count]` and then stops). Also, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` or `count` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- `count` is greater or equal `destsz`, but `destsz` is less or equal `wcsnlen_s(src, count)`, in other words, truncation would occur\n- overlap would occur between the source and the destination strings\n\nAs with all bounds-checked functions, `wcsncpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                |\n|--------|-----|------------------------------------------------|\n| dest   | \\-  | pointer to the wide character array to copy to |\n| src    | \\-  | pointer to the wide string to copy from        |\n| count  | \\-  | maximum number of wide characters to copy      |\n| destsz | \\-  | the size of the destination buffer             |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, writes `L'\\0'` to `dest[0]` (unless `dest` is a null pointer or `destsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`) and may clobber the rest of the destination array with unspecified values.\n\n### Notes\n\nIn typical usage, `count` is the number of elements in the destination array.\n\nAlthough truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for `wcsncpy_s`, it is possible to get the truncating behavior by specifying `count` equal to the size of the destination array minus one: it will copy the first `count` wide characters and append the null wide terminator as always: `wcsncpy_s(dst, sizeof dst / sizeof *dst, src, (sizeof dst / sizeof *dst)-1);`\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n \nint main(void)\n{\n    const wchar_t src[] = L\"わゐ\";\n    wchar_t dest[6] = {L'あ', L'い', L'う', L'え', L'お'};\n \n    wcsncpy(dest, src, 4); // this will copy わゐ and repeat L'\\0' two times\n \n    puts(\"The contents of dest are: \");\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    const long dest_size = sizeof dest / sizeof *dest;\n    for(wchar_t* p = dest; p-dest != dest_size; ++p) {\n        *p ? printf(\"%lc \", *p)\n           : printf(\"\\\\0 \");\n    }\n}\n```\n\nPossible output:\n\n```\nThe contents of dest are: \nわ ゐ \\0 \\0 お \\0\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.2.2 The wcsncpy function (p: 314)\n  - K.3.9.2.1.2 The wcsncpy_s function (p: 464)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.2.2 The wcsncpy function (p: 431)\n  - K.3.9.2.1.2 The wcsncpy_s function (p: 640-641)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.2.2 The wcsncpy function (p: 377)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcsncpy](https://en.cppreference.com/w/c/string/wide/wcsncpy)"
- name: wcsnlen_s
  summary: strnlen_s and wcsnlen_s are the only bounds-checked functions that do not invoke the runtime constraints handler
  description: "# wcslen, wcsnlen_s\n\n[TABLE]\n\n1) Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character.\n\n2) Same as (1), except that the function returns zero if `str` is a null pointer and returns `strsz` if the null wide character was not found in the first `strsz` wide characters of `src` As with all bounds-checked functions, `wcslen_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../../io \"c/io\")..\n\n### Parameters\n\n|       |     |                                                           |\n|-------|-----|-----------------------------------------------------------|\n| str   | \\-  | pointer to the null-terminated wide string to be examined |\n| strsz | \\-  | maximum number of wide characters to examine              |\n\n### Return value\n\n1) The length of the null-terminated wide string `str`.\n\n2) The length of the null-terminated wide string `str` on success, zero if `str` is a null pointer, `strsz` if the null wide character was not found.\n\n### Notes\n\n`strnlen_s` and `wcsnlen_s` are the only [bounds-checked functions](../../error \"c/error\") that do not invoke the runtime constraints handler. They are pure utility functions used to provide limited support for non-null terminated strings.\n\n### Example\n\n```\n#include <wchar.h>\n#include <stdio.h>\n \nint main(void)\n{\n    wchar_t str[] = L\"How many wide characters does this string contain?\";\n \n    printf(\"without null character: %zu\\n\", wcslen(str));\n    printf(\"with null character: %zu\\n\", sizeof str / sizeof *str);\n}\n```\n\nOutput:\n\n```\nwithout null character: 50\nwith null character: 51\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.6.1 The wcslen function (p: 439)\n  - K.3.9.2.4.1 The wcsnlen_s function (p: 646-647)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.6.1 The wcslen function (p: 385)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcslen](https://en.cppreference.com/w/c/string/wide/wcslen)"
- name: wcspbrk
  summary: Pointer to the first character in dest, that is also in str, or a null pointer if no such character exists
  description: "# wcspbrk\n\n[TABLE]\n\n1) Finds the first character in wide string pointed to by `dest`, that is also in wide string pointed to by `str`.\n\n2) Type-generic function equivalent to (1). Let `T` be an unqualified wide character object type.\n\n- If `dest` is of type `const T*`, the return type is `const wchar_t*`.\n- Otherwise, if `dest` is of type `T*`, the return type is `wchar_t*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(wcspbrk)` or a function pointer is used), the actual function declaration (1) becomes visible.\n\n### Parameters\n\n|      |     |                                                                                       |\n|------|-----|---------------------------------------------------------------------------------------|\n| dest | \\-  | pointer to the null-terminated wide string to be analyzed                             |\n| src  | \\-  | pointer to the null-terminated wide string that contains the characters to search for |\n\n### Return value\n\nPointer to the first character in `dest`, that is also in `str`, or a null pointer if no such character exists.\n\n### Notes\n\nThe name stands for \"wide character string pointer break\", because it returns a pointer to the first of the separator (\"break\") characters.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    const wchar_t* str = L\"Hello world, friend of mine!\";\n    const wchar_t* sep = L\" ,!\";\n \n    unsigned int cnt = 0;\n    do {\n       str = wcspbrk(str, sep); // find separator\n       if (str) str += wcsspn(str, sep); // skip separator\n       ++cnt; // increment word count\n    } while (str && *str);\n \n    wprintf(L\"There are %u words.\\n\", cnt);\n}\n```\n\nOutput:\n\n```\nThere are 5 words.\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.5.3 The wcspbrk function (p: 436)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.5.3 The wcspbrk function (p: 382)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcspbrk](https://en.cppreference.com/w/c/string/wide/wcspbrk)"
- name: wcsrchr
  summary: Pointer to the found character in str, or a null pointer if no such character is found
  description: "# wcsrchr\n\n[TABLE]\n\n1) Finds the last occurrence of the wide character `ch` in the wide string pointed to by `str`.\n\n2) Type-generic function equivalent to (1). Let `T` be an unqualified wide character object type.\n\n- If `str` is of type `const T*`, the return type is `const wchar_t*`.\n- Otherwise, if `str` is of type `T*`, the return type is `wchar_t*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(wcsrchr)` or a function pointer is used), the actual function declaration (1) becomes visible.\n\n### Parameters\n\n|     |     |                                                           |\n|-----|-----|-----------------------------------------------------------|\n| str | \\-  | pointer to the null-terminated wide string to be analyzed |\n| ch  | \\-  | wide character to search for                              |\n\n### Return value\n\nPointer to the found character in `str`, or a null pointer if no such character is found.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    wchar_t arr[] = L\"白猫 黒猫 кошки\";\n    wchar_t *cat = wcsrchr(arr, L'猫');\n    wchar_t *dog = wcsrchr(arr, L'犬');\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    cat ? printf(\"The character 猫 found at position %td\\n\", cat - arr)\n        : puts(\"The character 猫 not found\");\n \n    dog ? printf(\"The character 犬 found at position %td\\n\", dog - arr)\n        : puts(\"The character 犬 not found\");\n}\n```\n\nOutput:\n\n```\nThe character 猫 found at position 4\nThe character 犬 not found\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.31.4.6.4 The wcsrchr function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.5.4 The wcsrchr function (p: 318)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.5.4 The wcsrchr function (p: 436)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.5.4 The wcsrchr function (p: 382)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcsrchr](https://en.cppreference.com/w/c/string/wide/wcsrchr)"
- name: wcsrtombs
  summary: 'Output:'
  description: "# wcsrtombs, wcsrtombs_s\n\n[TABLE]\n\n1) Converts a sequence of wide characters from the array whose first element is pointed to by `*src` to its narrow multibyte representation that begins in the conversion state described by `*ps`. If `dst` is not null, converted characters are stored in the successive elements of the char array pointed to by `dst`. No more than `len` bytes are written to the destination array. Each character is converted as if by a call to [`wcrtomb`](wcrtomb \"c/string/multibyte/wcrtomb\"). The conversion stops if:\n\n- The null character `L'\\0'` was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by `'\\0'`, `*src` is set to null pointer value and `*ps` represents the initial shift state.\n- A `wchar_t` was found that does not correspond to a valid character in the current C locale. `*src` is set to point at the first unconverted wide character.\n- the next multibyte character to be stored would exceed `len`. `*src` is set to point at the first unconverted wide character. This condition is not checked if `dst` is a null pointer.\n\n2) Same as (1), except that\n\n- the function returns its result as an out-parameter `retval`\n- if the conversion stops without writing a null character, the function will store `'\\0'` in the next byte in `dst`, which may be `dst[len]` or `dst[dstsz]`, whichever comes first (meaning up to len+1/dstsz+1 total bytes may be written). In this case, there may be no unshift sequence written before the terminating null.\n- the function clobbers the destination array from the terminating null and until `dstsz`\n- If `src` and `dst` overlap, the behavior is unspecified.\n- the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n&nbsp;\n\n- `retval`, `ps`, `src`, or `*src` is a null pointer\n- `dstsz` or `len` is greater than `RSIZE_MAX` (unless `dst` is null)\n- `dstsz` is not zero (unless `dst` is null)\n- `len` is greater than `dstsz` and the conversion does not encounter null or encoding error in the `src` array by the time `dstsz` is reached (unless `dst` is null)\n\nAs with all bounds-checked functions, `wcsrtombs_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                                                     |\n|--------|-----|-----------------------------------------------------------------------------------------------------|\n| dst    | \\-  | pointer to narrow character array where the multibyte characters will be stored                     |\n| src    | \\-  | pointer to pointer to the first element of a null-terminated wide string                            |\n| len    | \\-  | number of bytes available in the array pointed to by dst                                            |\n| ps     | \\-  | pointer to the conversion state object                                                              |\n| dstsz  | \\-  | max number of bytes that will be written (size of the `dst` array)                                  |\n| retval | \\-  | pointer to a [`size_t`](../../types/size_t \"c/types/size t\") object where the result will be stored |\n\n### Return value\n\n1) On success, returns the number of bytes (including any shift sequences, but excluding the terminating `'\\0'`) written to the character array whose first element is pointed to by `dst`. If `dst` is a null pointer, returns the number of bytes that would have been written. On conversion error (if invalid wide character was encountered), returns `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1`, stores [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") in [`errno`](../../error/errno \"c/error/errno\"), and leaves `*ps` in unspecified state.\n\n2) Returns zero on success (in which case the number of bytes excluding terminating zero that were, or would be written to `dst`, is stored in `*retval`), non-zero on error. In case of a runtime constraint violation, stores `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` in `*retval` (unless `retval` is null) and sets `dst[0]` to `'\\0'` (unless `dst` is null or `dstmax` is zero or greater than `RSIZE_MAX`)\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\n \nvoid print_wide(const wchar_t* wstr)\n{\n    mbstate_t state;\n    memset(&state, 0, sizeof state);\n    size_t len = 1 + wcsrtombs(NULL, &wstr, 0, &state);\n    char mbstr[len];\n    wcsrtombs(mbstr, &wstr, len, &state);\n    printf(\"Multibyte string: %s\\n\", mbstr);\n    printf(\"Length, including '\\\\0': %zu\\n\", len);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    print_wide(L\"z\\u00df\\u6c34\\U0001f34c\"); // or L\"zß水🍌\"\n}\n```\n\nOutput:\n\n```\nMultibyte string: zß水🍌\nLength, including '\\0': 11\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.6.4.2 The wcsrtombs function (p: 324-325)\n  - K.3.9.3.2.2 The wcsrtombs_s function (p: 471-472)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.4.2 The wcsrtombs function (p: 446)\n  - K.3.9.3.2.2 The wcsrtombs_s function (p: 649-651)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.4.2 The wcsrtombs function (p: 392)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/wcsrtombs](https://en.cppreference.com/w/c/string/multibyte/wcsrtombs)"
- name: wcsrtombs_s
  summary: 'Output:'
  description: "# wcsrtombs, wcsrtombs_s\n\n[TABLE]\n\n1) Converts a sequence of wide characters from the array whose first element is pointed to by `*src` to its narrow multibyte representation that begins in the conversion state described by `*ps`. If `dst` is not null, converted characters are stored in the successive elements of the char array pointed to by `dst`. No more than `len` bytes are written to the destination array. Each character is converted as if by a call to [`wcrtomb`](wcrtomb \"c/string/multibyte/wcrtomb\"). The conversion stops if:\n\n- The null character `L'\\0'` was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by `'\\0'`, `*src` is set to null pointer value and `*ps` represents the initial shift state.\n- A `wchar_t` was found that does not correspond to a valid character in the current C locale. `*src` is set to point at the first unconverted wide character.\n- the next multibyte character to be stored would exceed `len`. `*src` is set to point at the first unconverted wide character. This condition is not checked if `dst` is a null pointer.\n\n2) Same as (1), except that\n\n- the function returns its result as an out-parameter `retval`\n- if the conversion stops without writing a null character, the function will store `'\\0'` in the next byte in `dst`, which may be `dst[len]` or `dst[dstsz]`, whichever comes first (meaning up to len+1/dstsz+1 total bytes may be written). In this case, there may be no unshift sequence written before the terminating null.\n- the function clobbers the destination array from the terminating null and until `dstsz`\n- If `src` and `dst` overlap, the behavior is unspecified.\n- the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n&nbsp;\n\n- `retval`, `ps`, `src`, or `*src` is a null pointer\n- `dstsz` or `len` is greater than `RSIZE_MAX` (unless `dst` is null)\n- `dstsz` is not zero (unless `dst` is null)\n- `len` is greater than `dstsz` and the conversion does not encounter null or encoding error in the `src` array by the time `dstsz` is reached (unless `dst` is null)\n\nAs with all bounds-checked functions, `wcsrtombs_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                                                     |\n|--------|-----|-----------------------------------------------------------------------------------------------------|\n| dst    | \\-  | pointer to narrow character array where the multibyte characters will be stored                     |\n| src    | \\-  | pointer to pointer to the first element of a null-terminated wide string                            |\n| len    | \\-  | number of bytes available in the array pointed to by dst                                            |\n| ps     | \\-  | pointer to the conversion state object                                                              |\n| dstsz  | \\-  | max number of bytes that will be written (size of the `dst` array)                                  |\n| retval | \\-  | pointer to a [`size_t`](../../types/size_t \"c/types/size t\") object where the result will be stored |\n\n### Return value\n\n1) On success, returns the number of bytes (including any shift sequences, but excluding the terminating `'\\0'`) written to the character array whose first element is pointed to by `dst`. If `dst` is a null pointer, returns the number of bytes that would have been written. On conversion error (if invalid wide character was encountered), returns `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1`, stores [`EILSEQ`](../../error/errno_macros \"c/error/errno macros\") in [`errno`](../../error/errno \"c/error/errno\"), and leaves `*ps` in unspecified state.\n\n2) Returns zero on success (in which case the number of bytes excluding terminating zero that were, or would be written to `dst`, is stored in `*retval`), non-zero on error. In case of a runtime constraint violation, stores `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` in `*retval` (unless `retval` is null) and sets `dst[0]` to `'\\0'` (unless `dst` is null or `dstmax` is zero or greater than `RSIZE_MAX`)\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\n \nvoid print_wide(const wchar_t* wstr)\n{\n    mbstate_t state;\n    memset(&state, 0, sizeof state);\n    size_t len = 1 + wcsrtombs(NULL, &wstr, 0, &state);\n    char mbstr[len];\n    wcsrtombs(mbstr, &wstr, len, &state);\n    printf(\"Multibyte string: %s\\n\", mbstr);\n    printf(\"Length, including '\\\\0': %zu\\n\", len);\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    print_wide(L\"z\\u00df\\u6c34\\U0001f34c\"); // or L\"zß水🍌\"\n}\n```\n\nOutput:\n\n```\nMultibyte string: zß水🍌\nLength, including '\\0': 11\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.6.4.2 The wcsrtombs function (p: 324-325)\n  - K.3.9.3.2.2 The wcsrtombs_s function (p: 471-472)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.4.2 The wcsrtombs function (p: 446)\n  - K.3.9.3.2.2 The wcsrtombs_s function (p: 649-651)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.4.2 The wcsrtombs function (p: 392)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/wcsrtombs](https://en.cppreference.com/w/c/string/multibyte/wcsrtombs)"
- name: wcsspn
  summary: Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src
  description: "# wcsspn\n\n[TABLE]\n\nReturns the length of the maximum initial segment of the wide string pointed to by `dest`, that consists of only the characters found in wide string pointed to by `src`.\n\n### Parameters\n\n|      |     |                                                                                       |\n|------|-----|---------------------------------------------------------------------------------------|\n| dest | \\-  | pointer to the null-terminated wide string to be analyzed                             |\n| src  | \\-  | pointer to the null-terminated wide string that contains the characters to search for |\n\n### Return value\n\nThe length of the maximum initial segment that contains only characters from wide string pointed to by `src`\n\n### Example\n\n```\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    wchar_t dest[] = L\"白猫 黑狗 甲虫\";\n    const wchar_t src[] = L\" 狗猫 白黑 \";\n    const size_t len = wcsspn(dest, src);\n    dest[len] = L'\\0'; /* terminates the segment to print it out */\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    wprintf(L\"The length of maximum initial segment is %td.\\n\"\n            L\"The segment is \\\"%ls\\\".\\n\", len, dest);\n}\n```\n\nOutput:\n\n```\nThe length of maximum initial segment is 6.\nThe segment is \"白猫 黑狗 \".\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.5.5 The wcsspn function (p: 436)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.5.5 The wcsspn function (p: 382)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcsspn](https://en.cppreference.com/w/c/string/wide/wcsspn)"
- name: wcsstr
  summary: Pointer to the first character of the found substring in dest, or a null pointer if no such substring is found
  description: "# wcsstr\n\n[TABLE]\n\n1) Finds the first occurrence of the wide string `src` in the wide string pointed to by `dest`. The terminating null characters are not compared.\n\n2) Type-generic function equivalent to (1). Let `T` be an unqualified wide character object type.\n\n- If `dest` is of type `const T*`, the return type is `const wchar_t*`.\n- Otherwise, if `dest` is of type `T*`, the return type is `wchar_t*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(wcsstr)` or a function pointer is used), the actual function declaration (1) becomes visible.\n\n### Parameters\n\n|      |     |                                                          |\n|------|-----|----------------------------------------------------------|\n| dest | \\-  | pointer to the null-terminated wide string to examine    |\n| src  | \\-  | pointer to the null-terminated wide string to search for |\n\n### Return value\n\nPointer to the first character of the found substring in `dest`, or a null pointer if no such substring is found. If `src` points to an empty string, `dest` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"ru_RU.UTF-8\");\n \n    wchar_t str[5][64] = {\n        L\"Строка, где есть подстрока 'но'.\",\n        L\"Строка, где такой подстроки нет.\",\n        L\"Он здесь.\",\n        L\"Здесь он.\",\n        L\"Его нет.\"\n    };\n \n    for (size_t i = 0; i < 5; ++i) {\n        if (wcsstr(str[i], L\"но\")) {\n            wprintf(L\"%ls\\n\", str[i]);\n        }\n    }\n}\n```\n\nOutput:\n\n```\nСтрока, где есть подстрока 'но'.\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.5.6 The wcsstr function (p: 437)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.5.6 The wcsstr function (p: 383)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcsstr](https://en.cppreference.com/w/c/string/wide/wcsstr)"
- name: wcstod
  summary: Interprets a floating point value in a wide string pointed to by str
  description: "# wcstof, wcstod, wcstold\n\n[TABLE]\n\nInterprets a floating point value in a wide string pointed to by `str`.\n\nFunction discards any whitespace characters (as determined by [`iswspace`](iswspace \"c/string/wide/iswspace\")) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:\n\n- decimal floating-point expression. It consists of the following parts:\n  - (optional) plus or minus sign\n  - nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C [locale](../../locale/setlocale \"c/locale/setlocale\")) (defines significand)\n  - (optional) `e` or `E` followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent to base 10)\n\n[TABLE]\n\n- any other expression that may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\")\n\nThe functions sets the pointer pointed to by `str_end` to point to the wide character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated wide string to be interpreted |\n| str_end | \\-  | pointer to a pointer to a wide character.                    |\n\n### Return value\n\nFloating point value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs and [`HUGE_VAL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\"), [`HUGE_VALF`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") or [`HUGE_VALL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <errno.h>\n#include <wchar.h>\n \nint main(void)\n{\n    const wchar_t *p = L\"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\";\n    printf(\"Parsing L\\\"%ls\\\":\\n\", p);\n    wchar_t *end;\n    for (double f = wcstod(p, &end); p != end; f = wcstod(p, &end))\n    {\n        printf(\"'%.*ls' -> \", (int)(end-p), p);\n        p = end;\n        if (errno == ERANGE){\n            printf(\"range error, got \");\n            errno = 0;\n        }\n        printf(\"%f\\n\", f);\n    }\n}\n```\n\nOutput:\n\n```\nParsing L\"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\":\n'111.11' -> 111.110000\n' -2.22' -> -2.220000\n' 0X1.BC70A3D70A3D7P+6' -> 111.110000\n'  1.18973e+4932' -> range error, got inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.1.1 The wcstod, wcstof, and wcstold functions (p: 426-428)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.1.1 The wcstod, wcstof, and wcstold functions (p: 372-374)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstof](https://en.cppreference.com/w/c/string/wide/wcstof)"
- name: wcstof
  summary: Interprets a floating point value in a wide string pointed to by str
  description: "# wcstof, wcstod, wcstold\n\n[TABLE]\n\nInterprets a floating point value in a wide string pointed to by `str`.\n\nFunction discards any whitespace characters (as determined by [`iswspace`](iswspace \"c/string/wide/iswspace\")) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:\n\n- decimal floating-point expression. It consists of the following parts:\n  - (optional) plus or minus sign\n  - nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C [locale](../../locale/setlocale \"c/locale/setlocale\")) (defines significand)\n  - (optional) `e` or `E` followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent to base 10)\n\n[TABLE]\n\n- any other expression that may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\")\n\nThe functions sets the pointer pointed to by `str_end` to point to the wide character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated wide string to be interpreted |\n| str_end | \\-  | pointer to a pointer to a wide character.                    |\n\n### Return value\n\nFloating point value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs and [`HUGE_VAL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\"), [`HUGE_VALF`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") or [`HUGE_VALL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <errno.h>\n#include <wchar.h>\n \nint main(void)\n{\n    const wchar_t *p = L\"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\";\n    printf(\"Parsing L\\\"%ls\\\":\\n\", p);\n    wchar_t *end;\n    for (double f = wcstod(p, &end); p != end; f = wcstod(p, &end))\n    {\n        printf(\"'%.*ls' -> \", (int)(end-p), p);\n        p = end;\n        if (errno == ERANGE){\n            printf(\"range error, got \");\n            errno = 0;\n        }\n        printf(\"%f\\n\", f);\n    }\n}\n```\n\nOutput:\n\n```\nParsing L\"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\":\n'111.11' -> 111.110000\n' -2.22' -> -2.220000\n' 0X1.BC70A3D70A3D7P+6' -> 111.110000\n'  1.18973e+4932' -> range error, got inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.1.1 The wcstod, wcstof, and wcstold functions (p: 426-428)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.1.1 The wcstod, wcstof, and wcstold functions (p: 372-374)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstof](https://en.cppreference.com/w/c/string/wide/wcstof)"
- name: wcstoimax
  summary: Interprets an unsigned integer value in a wide string pointed to by nptr
  description: "# wcstoimax, wcstoumax\n\n[TABLE]\n\nInterprets an unsigned integer value in a wide string pointed to by `nptr`.\n\nDiscards any whitespace characters (as identified by calling [`iswspace`](iswspace \"c/string/wide/iswspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type, which applies unsigned integer wraparound rules.\n\nThe functions sets the pointer pointed to by `endptr` to point to the wide character past the last character interpreted. If `endptr` is a null pointer, it is ignored.\n\n### Parameters\n\n|        |     |                                                              |\n|--------|-----|--------------------------------------------------------------|\n| nptr   | \\-  | pointer to the null-terminated wide string to be interpreted |\n| endptr | \\-  | pointer to a pointer to a wide character.                    |\n| base   | \\-  | *base* of the interpreted integer value                      |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs and [`INTMAX_MAX`](../../types/integer \"c/types/integer\"), [`INTMAX_MIN`](../../types/integer \"c/types/integer\"), [`UINTMAX_MAX`](../../types/integer \"c/types/integer\"), or `​0​` is returned, as appropriate. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <string.h>\n#include <wchar.h>\n \nint main(void)\n{\n  wchar_t* endptr;\n \n  wprintf(L\"%ld\\n\", wcstoimax(L\" -123junk\", &endptr, 10)); /* base 10                    */\n  wprintf(L\"%ld\\n\", wcstoimax(L\"11111111\", &endptr, 2));   /* base 2                     */\n  wprintf(L\"%ld\\n\", wcstoimax(L\"XyZ\", &endptr, 36));       /* base 36                    */\n  wprintf(L\"%ld\\n\", wcstoimax(L\"010\", &endptr, 0));        /* octal auto-detection       */\n  wprintf(L\"%ld\\n\", wcstoimax(L\"10\", &endptr, 0));         /* decimal auto-detection     */\n  wprintf(L\"%ld\\n\", wcstoimax(L\"0x10\", &endptr, 0));       /* hexadecimal auto-detection */\n \n  /* range error             */\n  /* LONG_MAX+1 --> LONG_MAX */\n  errno = 0;\n  wprintf(L\"%ld\\n\", wcstoimax(L\"9223372036854775808\", &endptr, 10));\n  wprintf(L\"%s\\n\", strerror(errno));\n}\n```\n\nOutput:\n\n```\n-123\n255\n44027\n8\n10\n16\n9223372036854775807\nNumerical result out of range\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.4 The wcstoimax and wcstoumax functions (p: 220)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.4 The wcstoimax and wcstoumax functions (p: 201)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstoimax](https://en.cppreference.com/w/c/string/wide/wcstoimax)"
- name: wcstok
  summary: Returns pointer to the beginning of the next token or null pointer if there are no more tokens
  description: "# wcstok, wcstok_s\n\n[TABLE]\n\n1) Finds the next token in a null-terminated wide string pointed to by `str`. The separator characters are identified by null-terminated wide string pointed to by `delim`.\n\nThis function is designed to be called multiples times to obtain successive tokens from the same string.\n\n- If `str ``!``=`` `[`NULL`](http://en.cppreference.com/w/c/types/NULL), the call is treated as the first call to `wcstok` for this particular wide string. The function searches for the first wide character which is *not* contained in `delim`.\n- If no such wide character was found, there are no tokens in `str` at all, and the function returns a null pointer.\n- If such wide character was found, it is the *beginning of the token*. The function then searches from that point on for the first wide character that *is* contained in `delim`.\n  - If no such wide character was found, `str` has only one token, and future calls to `wcstok` will return a null pointer\n  - If such wide character was found, it is *replaced* by the null wide character `L'\\0'` and the parser state (typically a pointer to the following wide character) is stored in the user-provided location `*ptr`.\n- The function then returns the pointer to the beginning of the token\n- If `str ``==`` `[`NULL`](http://en.cppreference.com/w/c/types/NULL), the call is treated as a subsequent call to `wcstok`: the function continues from where it left in the previous invocation with the same `*ptr`. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as `str`.\n\n2) Same as (1), except that on every step, writes the number of characters left to see in `str` into `*strmax`. Repeat calls (with null `str`) must pass both `strmax` and `ptr` with the values stored by the previous call. Also, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function, without storing anything in the object pointed to by `ptr`\n\n- `strmax`, `delim`, or `ptr` is a null pointer\n- on a non-initial call (with null `str`), `*ptr` is a null pointer\n- on the first call, `*strmax` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- search for the end of a token reaches the end of the source string (as measured by the initial value of `*strmax`)) without encountering the null terminator\n\nAs all bounds-checked functions, `wcstok_s` is only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including `wchar.h`.\n\n### Parameters\n\n|        |     |                                                                                                                                   |\n|--------|-----|-----------------------------------------------------------------------------------------------------------------------------------|\n| str    | \\-  | pointer to the null-terminated wide string to tokenize                                                                            |\n| delim  | \\-  | pointer to the null-terminated wide string identifying delimiters                                                                 |\n| ptr    | \\-  | pointer to an object of type `wchar_t*`, which is used by both `wcstok` and `wcstok_s` to store the internal state of the parser  |\n| strmax | \\-  | pointer to an object which initially holds the size of `str`: wcstok_s stores the number of characters that remain to be examined |\n\n### Return value\n\nReturns pointer to the beginning of the next token or null pointer if there are no more tokens.\n\n### Note\n\nThis function is destructive: it writes the `L'\\0'` characters in the elements of the string `str`. In particular, a wide string literal cannot be used as the first argument of `wcstok`.\n\nUnlike [`strtok`](../byte/strtok \"c/string/byte/strtok\"), `wcstok` does not update static storage: it stores the parser state in the user-provided location.\n\nUnlike most other tokenizers, the delimiters in `wcstok` can be different for each subsequent token, and can even depend on the contents of the previous tokens.\n\n### Example\n\n```\n#include <wchar.h>\n#include <stdio.h>\n \nint main(void)\n{\n    wchar_t input[] = L\"A bird came down the walk\";\n    printf(\"Parsing the input string '%ls'\\n\", input);\n    wchar_t *buffer;\n    wchar_t *token = wcstok(input, L\" \", &buffer);\n    while(token) {\n        printf(\"%ls\\n\", token);\n        token = wcstok(NULL, L\" \", &buffer);\n    }\n \n    printf(\"Contents of the input string now: '\");\n    for(size_t n = 0; n < sizeof input / sizeof *input; ++n)\n        input[n] ? printf(\"%lc\", input[n]) : printf(\"\\\\0\");\n    puts(\"'\");\n}\n```\n\nOutput:\n\n```\nParsing the input string 'A bird came down the walk'\nA\nbird\ncame\ndown\nthe\nwalk\nContents of the input string now: 'A\\0bird\\0came\\0down\\0the\\0walk\\0'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.5.7 The wcstok function (p: 437-438)\n  - K.3.9.2.3.1 The wcstok_s function (p: 645-646)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.5.7 The wcstok function (p: 383-384)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstok](https://en.cppreference.com/w/c/string/wide/wcstok)"
- name: wcstok_s
  summary: Returns pointer to the beginning of the next token or null pointer if there are no more tokens
  description: "# wcstok, wcstok_s\n\n[TABLE]\n\n1) Finds the next token in a null-terminated wide string pointed to by `str`. The separator characters are identified by null-terminated wide string pointed to by `delim`.\n\nThis function is designed to be called multiples times to obtain successive tokens from the same string.\n\n- If `str ``!``=`` `[`NULL`](http://en.cppreference.com/w/c/types/NULL), the call is treated as the first call to `wcstok` for this particular wide string. The function searches for the first wide character which is *not* contained in `delim`.\n- If no such wide character was found, there are no tokens in `str` at all, and the function returns a null pointer.\n- If such wide character was found, it is the *beginning of the token*. The function then searches from that point on for the first wide character that *is* contained in `delim`.\n  - If no such wide character was found, `str` has only one token, and future calls to `wcstok` will return a null pointer\n  - If such wide character was found, it is *replaced* by the null wide character `L'\\0'` and the parser state (typically a pointer to the following wide character) is stored in the user-provided location `*ptr`.\n- The function then returns the pointer to the beginning of the token\n- If `str ``==`` `[`NULL`](http://en.cppreference.com/w/c/types/NULL), the call is treated as a subsequent call to `wcstok`: the function continues from where it left in the previous invocation with the same `*ptr`. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as `str`.\n\n2) Same as (1), except that on every step, writes the number of characters left to see in `str` into `*strmax`. Repeat calls (with null `str`) must pass both `strmax` and `ptr` with the values stored by the previous call. Also, the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function, without storing anything in the object pointed to by `ptr`\n\n- `strmax`, `delim`, or `ptr` is a null pointer\n- on a non-initial call (with null `str`), `*ptr` is a null pointer\n- on the first call, `*strmax` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- search for the end of a token reaches the end of the source string (as measured by the initial value of `*strmax`)) without encountering the null terminator\n\nAs all bounds-checked functions, `wcstok_s` is only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including `wchar.h`.\n\n### Parameters\n\n|        |     |                                                                                                                                   |\n|--------|-----|-----------------------------------------------------------------------------------------------------------------------------------|\n| str    | \\-  | pointer to the null-terminated wide string to tokenize                                                                            |\n| delim  | \\-  | pointer to the null-terminated wide string identifying delimiters                                                                 |\n| ptr    | \\-  | pointer to an object of type `wchar_t*`, which is used by both `wcstok` and `wcstok_s` to store the internal state of the parser  |\n| strmax | \\-  | pointer to an object which initially holds the size of `str`: wcstok_s stores the number of characters that remain to be examined |\n\n### Return value\n\nReturns pointer to the beginning of the next token or null pointer if there are no more tokens.\n\n### Note\n\nThis function is destructive: it writes the `L'\\0'` characters in the elements of the string `str`. In particular, a wide string literal cannot be used as the first argument of `wcstok`.\n\nUnlike [`strtok`](../byte/strtok \"c/string/byte/strtok\"), `wcstok` does not update static storage: it stores the parser state in the user-provided location.\n\nUnlike most other tokenizers, the delimiters in `wcstok` can be different for each subsequent token, and can even depend on the contents of the previous tokens.\n\n### Example\n\n```\n#include <wchar.h>\n#include <stdio.h>\n \nint main(void)\n{\n    wchar_t input[] = L\"A bird came down the walk\";\n    printf(\"Parsing the input string '%ls'\\n\", input);\n    wchar_t *buffer;\n    wchar_t *token = wcstok(input, L\" \", &buffer);\n    while(token) {\n        printf(\"%ls\\n\", token);\n        token = wcstok(NULL, L\" \", &buffer);\n    }\n \n    printf(\"Contents of the input string now: '\");\n    for(size_t n = 0; n < sizeof input / sizeof *input; ++n)\n        input[n] ? printf(\"%lc\", input[n]) : printf(\"\\\\0\");\n    puts(\"'\");\n}\n```\n\nOutput:\n\n```\nParsing the input string 'A bird came down the walk'\nA\nbird\ncame\ndown\nthe\nwalk\nContents of the input string now: 'A\\0bird\\0came\\0down\\0the\\0walk\\0'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.5.7 The wcstok function (p: 437-438)\n  - K.3.9.2.3.1 The wcstok_s function (p: 645-646)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.5.7 The wcstok function (p: 383-384)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstok](https://en.cppreference.com/w/c/string/wide/wcstok)"
- name: wcstol
  summary: Interprets an integer value in a wide string pointed to by str
  description: "# wcstol, wcstoll\n\n[TABLE]\n\nInterprets an integer value in a wide string pointed to by `str`.\n\nDiscards any whitespace characters (as identified by calling [`iswspace`](iswspace \"c/string/wide/iswspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type.\n\nThe functions sets the pointer pointed to by `str_end` to point to the wide character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated wide string to be interpreted |\n| str_end | \\-  | pointer to a pointer to wide character                       |\n| base    | \\-  | *base* of the interpreted integer value                      |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs and [`LONG_MAX`](../../types/limits \"c/types/limits\"), [`LONG_MIN`](../../types/limits \"c/types/limits\"), [`LLONG_MAX`](../../types/limits \"c/types/limits\") or [`LLONG_MIN`](../../types/limits \"c/types/limits\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <errno.h>\n#include <wchar.h>\n \nint main(void)\n{\n    const wchar_t *p = L\"10 200000000000000000000000000000 30 -40\";\n    printf(\"Parsing L'%ls':\\n\", p);\n    wchar_t *end;\n    for (long i = wcstol(p, &end, 10);\n         p != end;\n         i = wcstol(p, &end, 10))\n    {\n        printf(\"'%.*ls' -> \", (int)(end-p), p);\n        p = end;\n        if (errno == ERANGE){\n            printf(\"range error, got \");\n            errno = 0;\n        }\n        printf(\"%ld\\n\", i);\n    }\n}\n```\n\nOutput:\n\n```\nParsing L'10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 9223372036854775807\n' 30' -> 30\n' -40' -> -40\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions (p: 429-430)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions (p: 375-376)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstol](https://en.cppreference.com/w/c/string/wide/wcstol)"
- name: wcstold
  summary: Interprets a floating point value in a wide string pointed to by str
  description: "# wcstof, wcstod, wcstold\n\n[TABLE]\n\nInterprets a floating point value in a wide string pointed to by `str`.\n\nFunction discards any whitespace characters (as determined by [`iswspace`](iswspace \"c/string/wide/iswspace\")) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:\n\n- decimal floating-point expression. It consists of the following parts:\n  - (optional) plus or minus sign\n  - nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C [locale](../../locale/setlocale \"c/locale/setlocale\")) (defines significand)\n  - (optional) `e` or `E` followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent to base 10)\n\n[TABLE]\n\n- any other expression that may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\")\n\nThe functions sets the pointer pointed to by `str_end` to point to the wide character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated wide string to be interpreted |\n| str_end | \\-  | pointer to a pointer to a wide character.                    |\n\n### Return value\n\nFloating point value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs and [`HUGE_VAL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\"), [`HUGE_VALF`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") or [`HUGE_VALL`](../../numeric/math/huge_val \"c/numeric/math/HUGE VAL\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <errno.h>\n#include <wchar.h>\n \nint main(void)\n{\n    const wchar_t *p = L\"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\";\n    printf(\"Parsing L\\\"%ls\\\":\\n\", p);\n    wchar_t *end;\n    for (double f = wcstod(p, &end); p != end; f = wcstod(p, &end))\n    {\n        printf(\"'%.*ls' -> \", (int)(end-p), p);\n        p = end;\n        if (errno == ERANGE){\n            printf(\"range error, got \");\n            errno = 0;\n        }\n        printf(\"%f\\n\", f);\n    }\n}\n```\n\nOutput:\n\n```\nParsing L\"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\":\n'111.11' -> 111.110000\n' -2.22' -> -2.220000\n' 0X1.BC70A3D70A3D7P+6' -> 111.110000\n'  1.18973e+4932' -> range error, got inf\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.1.1 The wcstod, wcstof, and wcstold functions (p: 426-428)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.1.1 The wcstod, wcstof, and wcstold functions (p: 372-374)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstof](https://en.cppreference.com/w/c/string/wide/wcstof)"
- name: wcstoll
  summary: Interprets an integer value in a wide string pointed to by str
  description: "# wcstol, wcstoll\n\n[TABLE]\n\nInterprets an integer value in a wide string pointed to by `str`.\n\nDiscards any whitespace characters (as identified by calling [`iswspace`](iswspace \"c/string/wide/iswspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type.\n\nThe functions sets the pointer pointed to by `str_end` to point to the wide character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated wide string to be interpreted |\n| str_end | \\-  | pointer to a pointer to wide character                       |\n| base    | \\-  | *base* of the interpreted integer value                      |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs and [`LONG_MAX`](../../types/limits \"c/types/limits\"), [`LONG_MIN`](../../types/limits \"c/types/limits\"), [`LLONG_MAX`](../../types/limits \"c/types/limits\") or [`LLONG_MIN`](../../types/limits \"c/types/limits\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <errno.h>\n#include <wchar.h>\n \nint main(void)\n{\n    const wchar_t *p = L\"10 200000000000000000000000000000 30 -40\";\n    printf(\"Parsing L'%ls':\\n\", p);\n    wchar_t *end;\n    for (long i = wcstol(p, &end, 10);\n         p != end;\n         i = wcstol(p, &end, 10))\n    {\n        printf(\"'%.*ls' -> \", (int)(end-p), p);\n        p = end;\n        if (errno == ERANGE){\n            printf(\"range error, got \");\n            errno = 0;\n        }\n        printf(\"%ld\\n\", i);\n    }\n}\n```\n\nOutput:\n\n```\nParsing L'10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 9223372036854775807\n' 30' -> 30\n' -40' -> -40\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions (p: 429-430)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions (p: 375-376)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstol](https://en.cppreference.com/w/c/string/wide/wcstol)"
- name: wcstombs
  summary: In most implementations, wcstombs updates a global static object of type mbstate_t as it processes through the string, and cannot be called simultaneously by two threads, wcsrtombs or wcstombs_s should be used in such cases
  description: "# wcstombs, wcstombs_s\n\n[TABLE]\n\n1) Converts a sequence of wide characters from the array whose first element is pointed to by `src` to its narrow multibyte representation that begins in the initial shift state. Converted characters are stored in the successive elements of the char array pointed to by `dst`. No more than `len` bytes are written to the destination array.\n\nEach character is converted as if by a call to [`wctomb`](wctomb \"c/string/multibyte/wctomb\"), except that the wctomb's conversion state is unaffected. The conversion stops if:\n\n\\* The null character `L'\\0'` was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by `'\\0'`,\n\n\\* A `wchar_t` was found that does not correspond to a valid character in the current C locale.\n\n\\* The next multibyte character to be stored would exceed `len`.\n\nIf `src` and `dst` overlap, the behavior is unspecified.\n\n2) Same as (1), except that\n\n\\* conversion is as-if by [`wcrtomb`](wcrtomb \"c/string/multibyte/wcrtomb\"), not [`wctomb`](wctomb \"c/string/multibyte/wctomb\")\n\n\\* the function returns its result as an out-parameter `retval`\n\n\\* if the conversion stops without writing a null character, the function will store `'\\0'` in the next byte in `dst`, which may be `dst[len]` or `dst[dstsz]`, whichever comes first (meaning up to len+1/dstsz+1 total bytes may be written). In this case, there may be no unshift sequence written before the terminating null.\n\n\\* if `dst` is a null pointer, the number of bytes that would be produced is stored in `*retval`\n\n\\* the function clobbers the destination array from the terminating null and until `dstsz`\n\n\\* If `src` and `dst` overlap, the behavior is unspecified.\n\n\\* the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `retval` or `src` is a null pointer\n- `dstsz` or `len` is greater than `RSIZE_MAX` (unless `dst` is null)\n- `dstsz` is not zero (unless `dst` is null)\n- `len` is greater than `dstsz` and the conversion does not encounter null or encoding error in the `src` array by the time `dstsz` is reached (unless `dst` is null)\n\nAs with all bounds-checked functions, `wcstombs_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../../program \"c/program\").\n\n### Notes\n\nIn most implementations, `wcstombs` updates a global static object of type [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\") as it processes through the string, and cannot be called simultaneously by two threads, [`wcsrtombs`](wcsrtombs \"c/string/multibyte/wcsrtombs\") or `wcstombs_s` should be used in such cases.\n\nPOSIX specifies a common extension: if `dst` is a null pointer, this function returns the number of bytes that would be written to `dst`, if converted. Similar behavior is standard for [`wcsrtombs`](wcsrtombs \"c/string/multibyte/wcsrtombs\") and `wcstombs_s`.\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| dst    | \\-  | pointer to narrow character array where the multibyte character will be stored |\n| src    | \\-  | pointer to the first element of a null-terminated wide string to convert       |\n| len    | \\-  | number of bytes available in the array pointed to by dst                       |\n| dstsz  | \\-  | max number of bytes that will be written (size of the `dst` array)             |\n| retval | \\-  | pointer to a size_t object where the result will be stored                     |\n\n### Return value\n\n1) On success, returns the number of bytes (including any shift sequences, but excluding the terminating `'\\0'`) written to the character array whose first element is pointed to by `dst`. On conversion error (if invalid wide character was encountered), returns `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1`.\n\n2) Returns zero on success (in which case the number of bytes excluding terminating zero that were, or would be written to `dst`, is stored in `*retval`), non-zero on error. In case of a runtime constraint violation, stores `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` in `*retval` (unless `retval` is null) and sets `dst[0]` to `'\\0'` (unless `dst` is null or `dstmax` is zero or greater than `RSIZE_MAX`)\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n \nint main(void)\n{\n    // 4 wide characters\n    const wchar_t src[] = L\"z\\u00df\\u6c34\\U0001f34c\";\n    // they occupy 10 bytes in UTF-8\n    char dst[11];\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"wide-character string: '%ls'\\n\",src);\n    for (size_t ndx=0; ndx < sizeof src/sizeof src[0]; ++ndx)\n        printf(\"   src[%2zu] = %#8x\\n\", ndx, src[ndx]);\n \n    int rtn_val = wcstombs(dst, src, sizeof dst);\n    printf(\"rtn_val = %d\\n\", rtn_val);\n    if (rtn_val > 0)\n        printf(\"multibyte string:  '%s'\\n\",dst);\n    for (size_t ndx=0; ndx<sizeof dst; ++ndx)\n        printf(\"   dst[%2zu] = %#2x\\n\", ndx, (unsigned char)dst[ndx]);\n}\n```\n\nOutput:\n\n```\nwide-character string: 'zß水🍌'\n   src[ 0] =     0x7a\n   src[ 1] =     0xdf\n   src[ 2] =   0x6c34\n   src[ 3] =  0x1f34c\n   src[ 4] =        0\nrtn_val = 10\nmultibyte string:  'zß水🍌'\n   dst[ 0] = 0x7a\n   dst[ 1] = 0xc3\n   dst[ 2] = 0x9f\n   dst[ 3] = 0xe6\n   dst[ 4] = 0xb0\n   dst[ 5] = 0xb4\n   dst[ 6] = 0xf0\n   dst[ 7] = 0x9f\n   dst[ 8] = 0x8d\n   dst[ 9] = 0x8c\n   dst[10] =  0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.8.2 The wcstombs function (p: 360)\n  - K.3.6.5.2 The wcstombs_s function (p: 612-614)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.8.2 The wcstombs function (p: 324)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.8.2 The wcstombs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/wcstombs](https://en.cppreference.com/w/c/string/multibyte/wcstombs)"
- name: wcstombs_s
  summary: In most implementations, wcstombs updates a global static object of type mbstate_t as it processes through the string, and cannot be called simultaneously by two threads, wcsrtombs or wcstombs_s should be used in such cases
  description: "# wcstombs, wcstombs_s\n\n[TABLE]\n\n1) Converts a sequence of wide characters from the array whose first element is pointed to by `src` to its narrow multibyte representation that begins in the initial shift state. Converted characters are stored in the successive elements of the char array pointed to by `dst`. No more than `len` bytes are written to the destination array.\n\nEach character is converted as if by a call to [`wctomb`](wctomb \"c/string/multibyte/wctomb\"), except that the wctomb's conversion state is unaffected. The conversion stops if:\n\n\\* The null character `L'\\0'` was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by `'\\0'`,\n\n\\* A `wchar_t` was found that does not correspond to a valid character in the current C locale.\n\n\\* The next multibyte character to be stored would exceed `len`.\n\nIf `src` and `dst` overlap, the behavior is unspecified.\n\n2) Same as (1), except that\n\n\\* conversion is as-if by [`wcrtomb`](wcrtomb \"c/string/multibyte/wcrtomb\"), not [`wctomb`](wctomb \"c/string/multibyte/wctomb\")\n\n\\* the function returns its result as an out-parameter `retval`\n\n\\* if the conversion stops without writing a null character, the function will store `'\\0'` in the next byte in `dst`, which may be `dst[len]` or `dst[dstsz]`, whichever comes first (meaning up to len+1/dstsz+1 total bytes may be written). In this case, there may be no unshift sequence written before the terminating null.\n\n\\* if `dst` is a null pointer, the number of bytes that would be produced is stored in `*retval`\n\n\\* the function clobbers the destination array from the terminating null and until `dstsz`\n\n\\* If `src` and `dst` overlap, the behavior is unspecified.\n\n\\* the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `retval` or `src` is a null pointer\n- `dstsz` or `len` is greater than `RSIZE_MAX` (unless `dst` is null)\n- `dstsz` is not zero (unless `dst` is null)\n- `len` is greater than `dstsz` and the conversion does not encounter null or encoding error in the `src` array by the time `dstsz` is reached (unless `dst` is null)\n\nAs with all bounds-checked functions, `wcstombs_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../../program \"c/program\").\n\n### Notes\n\nIn most implementations, `wcstombs` updates a global static object of type [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\") as it processes through the string, and cannot be called simultaneously by two threads, [`wcsrtombs`](wcsrtombs \"c/string/multibyte/wcsrtombs\") or `wcstombs_s` should be used in such cases.\n\nPOSIX specifies a common extension: if `dst` is a null pointer, this function returns the number of bytes that would be written to `dst`, if converted. Similar behavior is standard for [`wcsrtombs`](wcsrtombs \"c/string/multibyte/wcsrtombs\") and `wcstombs_s`.\n\n### Parameters\n\n|        |     |                                                                                |\n|--------|-----|--------------------------------------------------------------------------------|\n| dst    | \\-  | pointer to narrow character array where the multibyte character will be stored |\n| src    | \\-  | pointer to the first element of a null-terminated wide string to convert       |\n| len    | \\-  | number of bytes available in the array pointed to by dst                       |\n| dstsz  | \\-  | max number of bytes that will be written (size of the `dst` array)             |\n| retval | \\-  | pointer to a size_t object where the result will be stored                     |\n\n### Return value\n\n1) On success, returns the number of bytes (including any shift sequences, but excluding the terminating `'\\0'`) written to the character array whose first element is pointed to by `dst`. On conversion error (if invalid wide character was encountered), returns `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1`.\n\n2) Returns zero on success (in which case the number of bytes excluding terminating zero that were, or would be written to `dst`, is stored in `*retval`), non-zero on error. In case of a runtime constraint violation, stores `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` in `*retval` (unless `retval` is null) and sets `dst[0]` to `'\\0'` (unless `dst` is null or `dstmax` is zero or greater than `RSIZE_MAX`)\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n \nint main(void)\n{\n    // 4 wide characters\n    const wchar_t src[] = L\"z\\u00df\\u6c34\\U0001f34c\";\n    // they occupy 10 bytes in UTF-8\n    char dst[11];\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"wide-character string: '%ls'\\n\",src);\n    for (size_t ndx=0; ndx < sizeof src/sizeof src[0]; ++ndx)\n        printf(\"   src[%2zu] = %#8x\\n\", ndx, src[ndx]);\n \n    int rtn_val = wcstombs(dst, src, sizeof dst);\n    printf(\"rtn_val = %d\\n\", rtn_val);\n    if (rtn_val > 0)\n        printf(\"multibyte string:  '%s'\\n\",dst);\n    for (size_t ndx=0; ndx<sizeof dst; ++ndx)\n        printf(\"   dst[%2zu] = %#2x\\n\", ndx, (unsigned char)dst[ndx]);\n}\n```\n\nOutput:\n\n```\nwide-character string: 'zß水🍌'\n   src[ 0] =     0x7a\n   src[ 1] =     0xdf\n   src[ 2] =   0x6c34\n   src[ 3] =  0x1f34c\n   src[ 4] =        0\nrtn_val = 10\nmultibyte string:  'zß水🍌'\n   dst[ 0] = 0x7a\n   dst[ 1] = 0xc3\n   dst[ 2] = 0x9f\n   dst[ 3] = 0xe6\n   dst[ 4] = 0xb0\n   dst[ 5] = 0xb4\n   dst[ 6] = 0xf0\n   dst[ 7] = 0x9f\n   dst[ 8] = 0x8d\n   dst[ 9] = 0x8c\n   dst[10] =  0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.8.2 The wcstombs function (p: 360)\n  - K.3.6.5.2 The wcstombs_s function (p: 612-614)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.8.2 The wcstombs function (p: 324)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.8.2 The wcstombs function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/wcstombs](https://en.cppreference.com/w/c/string/multibyte/wcstombs)"
- name: wcstoul
  summary: Interprets an unsigned integer value in a wide string pointed to by str
  description: "# wcstoul, wcstoull\n\n[TABLE]\n\nInterprets an unsigned integer value in a wide string pointed to by `str`.\n\nDiscards any whitespace characters (as identified by calling [`iswspace`](iswspace \"c/string/wide/iswspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type, which applies unsigned integer wraparound rules.\n\nThe functions sets the pointer pointed to by `str_end` to point to the wide character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated wide string to be interpreted |\n| str_end | \\-  | pointer to a pointer to a wide character.                    |\n| base    | \\-  | *base* of the interpreted integer value                      |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs and [`ULONG_MAX`](../../types/limits \"c/types/limits\") or [`ULLONG_MAX`](../../types/limits \"c/types/limits\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <errno.h>\n#include <wchar.h>\n \nint main(void)\n{\n    const wchar_t *p = L\"10 200000000000000000000000000000 30 40\";\n    printf(\"Parsing L'%ls':\\n\", p);\n    wchar_t *end;\n    for (unsigned long i = wcstoul(p, &end, 10);\n         p != end;\n         i = wcstoul(p, &end, 10))\n    {\n        printf(\"'%.*ls' -> \", (int)(end-p), p);\n        p = end;\n        if (errno == ERANGE){\n            printf(\"range error, got \");\n            errno = 0;\n        }\n        printf(\"%lu\\n\", i);\n    }\n}\n```\n\nOutput:\n\n```\nParsing '10 200000000000000000000000000000 30 40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' 40' -> 40\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions (p: 429-430)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions (p: 375-376)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstoul](https://en.cppreference.com/w/c/string/wide/wcstoul)"
- name: wcstoull
  summary: Interprets an unsigned integer value in a wide string pointed to by str
  description: "# wcstoul, wcstoull\n\n[TABLE]\n\nInterprets an unsigned integer value in a wide string pointed to by `str`.\n\nDiscards any whitespace characters (as identified by calling [`iswspace`](iswspace \"c/string/wide/iswspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type, which applies unsigned integer wraparound rules.\n\nThe functions sets the pointer pointed to by `str_end` to point to the wide character past the last character interpreted. If `str_end` is a null pointer, it is ignored.\n\n### Parameters\n\n|         |     |                                                              |\n|---------|-----|--------------------------------------------------------------|\n| str     | \\-  | pointer to the null-terminated wide string to be interpreted |\n| str_end | \\-  | pointer to a pointer to a wide character.                    |\n| base    | \\-  | *base* of the interpreted integer value                      |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs and [`ULONG_MAX`](../../types/limits \"c/types/limits\") or [`ULLONG_MAX`](../../types/limits \"c/types/limits\") is returned. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <stdio.h>\n#include <errno.h>\n#include <wchar.h>\n \nint main(void)\n{\n    const wchar_t *p = L\"10 200000000000000000000000000000 30 40\";\n    printf(\"Parsing L'%ls':\\n\", p);\n    wchar_t *end;\n    for (unsigned long i = wcstoul(p, &end, 10);\n         p != end;\n         i = wcstoul(p, &end, 10))\n    {\n        printf(\"'%.*ls' -> \", (int)(end-p), p);\n        p = end;\n        if (errno == ERANGE){\n            printf(\"range error, got \");\n            errno = 0;\n        }\n        printf(\"%lu\\n\", i);\n    }\n}\n```\n\nOutput:\n\n```\nParsing '10 200000000000000000000000000000 30 40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' 40' -> 40\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions (p: 429-430)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions (p: 375-376)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstoul](https://en.cppreference.com/w/c/string/wide/wcstoul)"
- name: wcstoumax
  summary: Interprets an unsigned integer value in a wide string pointed to by nptr
  description: "# wcstoimax, wcstoumax\n\n[TABLE]\n\nInterprets an unsigned integer value in a wide string pointed to by `nptr`.\n\nDiscards any whitespace characters (as identified by calling [`iswspace`](iswspace \"c/string/wide/iswspace\")) until the first non-whitespace character is found, then takes as many characters as possible to form a valid *base-n* (where n=`base`) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:\n\n- (optional) plus or minus sign\n- (optional) prefix (`0`) indicating octal base (applies only when the base is `8` or `​0​`)\n- (optional) prefix (`0x` or `0X`) indicating hexadecimal base (applies only when the base is `16` or `​0​`)\n- a sequence of digits\n\nThe set of valid values for base is `{0,2,3,...,36}.` The set of valid digits for base-`2` integers is `{0,1},` for base-`3` integers is `{0,1,2},` and so on. For bases larger than `10`, valid digits include alphabetic characters, starting from `Aa` for base-`11` integer, to `Zz` for base-`36` integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C [locale](../../locale/setlocale \"c/locale/setlocale\").\n\nIf the value of `base` is `​0​`, the numeric base is auto-detected: if the prefix is `0`, the base is octal, if the prefix is `0x` or `0X`, the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by [unary minus](../../language/operator_arithmetic#Unary_arithmetic \"c/language/operator arithmetic\") in the result type, which applies unsigned integer wraparound rules.\n\nThe functions sets the pointer pointed to by `endptr` to point to the wide character past the last character interpreted. If `endptr` is a null pointer, it is ignored.\n\n### Parameters\n\n|        |     |                                                              |\n|--------|-----|--------------------------------------------------------------|\n| nptr   | \\-  | pointer to the null-terminated wide string to be interpreted |\n| endptr | \\-  | pointer to a pointer to a wide character.                    |\n| base   | \\-  | *base* of the interpreted integer value                      |\n\n### Return value\n\nInteger value corresponding to the contents of `str` on success. If the converted value falls out of range of corresponding return type, range error occurs and [`INTMAX_MAX`](../../types/integer \"c/types/integer\"), [`INTMAX_MIN`](../../types/integer \"c/types/integer\"), [`UINTMAX_MAX`](../../types/integer \"c/types/integer\"), or `​0​` is returned, as appropriate. If no conversion can be performed, `​0​` is returned.\n\n### Example\n\n```\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <string.h>\n#include <wchar.h>\n \nint main(void)\n{\n  wchar_t* endptr;\n \n  wprintf(L\"%ld\\n\", wcstoimax(L\" -123junk\", &endptr, 10)); /* base 10                    */\n  wprintf(L\"%ld\\n\", wcstoimax(L\"11111111\", &endptr, 2));   /* base 2                     */\n  wprintf(L\"%ld\\n\", wcstoimax(L\"XyZ\", &endptr, 36));       /* base 36                    */\n  wprintf(L\"%ld\\n\", wcstoimax(L\"010\", &endptr, 0));        /* octal auto-detection       */\n  wprintf(L\"%ld\\n\", wcstoimax(L\"10\", &endptr, 0));         /* decimal auto-detection     */\n  wprintf(L\"%ld\\n\", wcstoimax(L\"0x10\", &endptr, 0));       /* hexadecimal auto-detection */\n \n  /* range error             */\n  /* LONG_MAX+1 --> LONG_MAX */\n  errno = 0;\n  wprintf(L\"%ld\\n\", wcstoimax(L\"9223372036854775808\", &endptr, 10));\n  wprintf(L\"%s\\n\", strerror(errno));\n}\n```\n\nOutput:\n\n```\n-123\n255\n44027\n8\n10\n16\n9223372036854775807\nNumerical result out of range\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.8.2.4 The wcstoimax and wcstoumax functions (p: 220)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.8.2.4 The wcstoimax and wcstoumax functions (p: 201)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcstoimax](https://en.cppreference.com/w/c/string/wide/wcstoimax)"
- name: wcsxfrm
  summary: Transforms the null-terminated wide string pointed to by src into the implementation-defined form such that comparing two transformed strings with wcscmp gives the same result as comparing the original strings with wcscoll, in the current C locale
  description: "# wcsxfrm\n\n[TABLE]\n\nTransforms the null-terminated wide string pointed to by `src` into the implementation-defined form such that comparing two transformed strings with [`wcscmp`](wcscmp \"c/string/wide/wcscmp\") gives the same result as comparing the original strings with [`wcscoll`](wcscoll \"c/string/wide/wcscoll\"), in the current C locale.\n\nThe first `count` characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.\n\nIf `count` is `​0​`, then `dest` is allowed to be a null pointer.\n\n### Notes\n\nThe correct length of the buffer that can receive the entire transformed string is `1``+``wcsxfrm``(`[`NULL`](http://en.cppreference.com/w/c/types/NULL)`, src, ``0``)`\n\nThis function is used when making multiple locale-dependent comparisons using the same wide string or set of wide strings, because it is more efficient to use `wcsxfrm` to transform all the strings just once, and subsequently compare the transformed wide strings with [`wcscmp`](wcscmp \"c/string/wide/wcscmp\").\n\n### Parameters\n\n|       |     |                                                                                                  |\n|-------|-----|--------------------------------------------------------------------------------------------------|\n| dest  | \\-  | pointer to the first element of a wide null-terminated string to write the transformed string to |\n| src   | \\-  | pointer to the null-terminated wide character string to transform                                |\n| count | \\-  | maximum number of characters to output                                                           |\n\n### Return value\n\nThe length of the transformed wide string, not including the terminating null-character.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"sv_SE.utf8\");\n \n    const wchar_t *in1 = L\"\\u00e5r\";\n    wchar_t out1[1+wcsxfrm(NULL, in1, 0)];\n    wcsxfrm(out1, in1, sizeof out1/sizeof *out1);\n \n    const wchar_t *in2 = L\"\\u00e4ngel\";\n    wchar_t out2[1+wcsxfrm(NULL, in2, 0)];\n    wcsxfrm(out2, in2, sizeof out2/sizeof *out2);\n \n    printf(\"In the Swedish locale: \");\n    if(wcscmp(out1, out2) < 0)\n         printf(\"%ls before %ls\\n\", in1, in2);\n    else\n         printf(\"%ls before %ls\\n\", in2, in1);\n \n    printf(\"In lexicographical comparison: \");\n    if(wcscmp(in1, in2) < 0)\n         printf(\"%ls before %ls\\n\", in1, in2);\n    else\n         printf(\"%ls before %ls\\n\", in2, in1);\n}\n```\n\nOutput:\n\n```\nIn the Swedish locale: år before ängel\nIn lexicographical comparison: ängel before år\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.4.4 The wcsxfrm function (p: 434-435)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.4.4 The wcsxfrm function (p: 380-381)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wcsxfrm](https://en.cppreference.com/w/c/string/wide/wcsxfrm)"
- name: wctob
  summary: Narrows a wide character c if its multibyte character equivalent in the initial shift state is a single byte
  description: "# wctob\n\n[TABLE]\n\nNarrows a wide character `c` if its multibyte character equivalent in the initial shift state is a single byte.\n\nThis is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.\n\n### Parameters\n\n|     |     |                          |\n|-----|-----|--------------------------|\n| c   | \\-  | wide character to narrow |\n\n### Return value\n\n[`EOF`](../../io \"c/io\") if `c` does not represent a multibyte character with length `1` in initial shift state.\n\notherwise, the single-byte representation of `c` as `unsigned char` converted to `int`\n\n### Example\n\n```\n#include <locale.h>\n#include <wchar.h>\n#include <stdio.h>\n#include <assert.h>\n \nvoid try_narrowing(wchar_t c)\n{\n    int cn = wctob(c);\n    if(cn != EOF)\n        printf(\"%#x narrowed to %#x\\n\", c, cn);\n    else\n        printf(\"%#x could not be narrowed\\n\", c);\n}\n \nint main(void)\n{\n    char* utf_locale_present = setlocale(LC_ALL, \"th_TH.utf8\");\n    assert(utf_locale_present);\n    puts(\"In Thai UTF-8 locale:\");\n    try_narrowing(L'a');\n    try_narrowing(L'๛');\n \n    char* tis_locale_present = setlocale(LC_ALL, \"th_TH.tis620\");\n    assert(tis_locale_present);\n    puts(\"In Thai TIS-620 locale:\");\n    try_narrowing(L'a');\n    try_narrowing(L'๛');\n}\n```\n\nPossible output:\n\n```\nIn Thai UTF-8 locale:\n0x61 narrowed to 0x61\n0xe5b could not be narrowed\nIn Thai TIS-620 locale:\n0x61 narrowed to 0x61\n0xe5b narrowed to 0xfb\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.6.1.2 The wctob function (p: 441)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.6.1.2 The wctob function (p: 387)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/wctob](https://en.cppreference.com/w/c/string/multibyte/wctob)"
- name: wctomb
  summary: Each call to wctomb updates the internal global conversion state (a static object of type mbstate_t, known only to this function)
  description: "# wctomb, wctomb_s\n\n[TABLE]\n\n1) Converts a wide character `wc` to multibyte encoding and stores it (including any shift sequences) in the char array whose first element is pointed to by `s`. No more than `MB_CUR_MAX` characters are stored. The conversion is affected by the current locale's LC_CTYPE category.\n\nIf `wc` is the null character, the null byte is written to `s`, preceded by any shift sequences necessary to restore the initial shift state.\n\nIf `s` is a null pointer, this function resets the global conversion state and determines whether shift sequences are used.\n\n2) Same as (1), except that the result is returned in the out-parameter `status` and the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `ssz` is less than the number of bytes that would be written (unless `s` is null)\n- `ssz` is greater than `RSIZE_MAX` (unless `s` is null)\n- `s` is a null pointer but `ssz` is not zero\n\nAs with all bounds-checked functions, `wctomb_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../../program \"c/program\").\n\n### Notes\n\nEach call to `wctomb` updates the internal global conversion state (a static object of type [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\"), known only to this function). If the multibyte encoding uses shift states, this function is not reentrant. In any case, multiple threads should not call `wctomb` without synchronization: [`wcrtomb`](wcrtomb \"c/string/multibyte/wcrtomb\") or `wctomb_s` may be used instead.\n\nUnlike most bounds-checked functions, `wctomb_s` does not null-terminate its output, because it is designed to be used in loops that process strings character-by-character.\n\n### Parameters\n\n|        |     |                                                                                                                             |\n|--------|-----|-----------------------------------------------------------------------------------------------------------------------------|\n| s      | \\-  | pointer to the character array for output                                                                                   |\n| wc     | \\-  | wide character to convert                                                                                                   |\n| ssz    | \\-  | maximum number of bytes to write to `s` (size of the array `s`)                                                             |\n| status | \\-  | pointer to an out-parameter where the result (length of the multibyte sequence or the shift sequence status) will be stored |\n\n### Return value\n\n1) If `s` is not a null pointer, returns the number of bytes that are contained in the multibyte representation of `wc` or `-1` if `wc` is not a valid character.\n\nIf `s` is a null pointer, resets its internal conversion state to represent the initial shift state and returns `​0​` if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).\n\n2) zero on success, in which case the multibyte representation of `wc` is stored in `s` and its length is stored in `*status`, or, if `s` is null, the shift sequence status is stored in `status`). Non-zero on encoding error or runtime constraint violation, in which case `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` is stored in `*status`. The value stored in `*status` never exceeds `MB_CUR_MAX`\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n \nvoid demo(wchar_t wc)\n{\n    const char* dep = wctomb(NULL, wc) ? \"Yes\" : \"No\";\n    printf(\"State-dependent encoding? %s.\\n\", dep);\n \n    char mb[MB_CUR_MAX];\n    int len = wctomb(mb, wc);\n    printf(\"wide char '%lc' -> multibyte char [\", wc);\n    for (int idx = 0; idx < len; ++idx)\n        printf(\"%s%#2x\", idx ? \" \" : \"\", (unsigned char)mb[idx]);\n    printf(\"]\\n\");\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"MB_CUR_MAX = %zu\\n\", MB_CUR_MAX);\n    demo(L'A');\n    demo(L'\\u00df');\n    demo(L'\\U0001d10b');\n}\n```\n\nPossible output:\n\n```\nMB_CUR_MAX = 6\nState-dependent encoding? No.\nwide char 'A' -> multibyte char [0x41]\nState-dependent encoding? No.\nwide char 'ß' -> multibyte char [0xc3 0x9f]\nState-dependent encoding? No.\nwide char '𝄋' -> multibyte char [0xf0 0x9d 0x84 0x8b]\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.7.3 The wctomb function (p: 261)\n  - K.3.6.4.1 The wctomb_s function (p: 443)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.7.3 The wctomb function (p: 358-359)\n  - K.3.6.4.1 The wctomb_s function (p: 610-611)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.7.3 The wctomb function (p: 322-323)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.7.3 The wctomb function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/wctomb](https://en.cppreference.com/w/c/string/multibyte/wctomb)"
- name: wctomb_s
  summary: Each call to wctomb updates the internal global conversion state (a static object of type mbstate_t, known only to this function)
  description: "# wctomb, wctomb_s\n\n[TABLE]\n\n1) Converts a wide character `wc` to multibyte encoding and stores it (including any shift sequences) in the char array whose first element is pointed to by `s`. No more than `MB_CUR_MAX` characters are stored. The conversion is affected by the current locale's LC_CTYPE category.\n\nIf `wc` is the null character, the null byte is written to `s`, preceded by any shift sequences necessary to restore the initial shift state.\n\nIf `s` is a null pointer, this function resets the global conversion state and determines whether shift sequences are used.\n\n2) Same as (1), except that the result is returned in the out-parameter `status` and the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `ssz` is less than the number of bytes that would be written (unless `s` is null)\n- `ssz` is greater than `RSIZE_MAX` (unless `s` is null)\n- `s` is a null pointer but `ssz` is not zero\n\nAs with all bounds-checked functions, `wctomb_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdlib.h>`](../../program \"c/program\").\n\n### Notes\n\nEach call to `wctomb` updates the internal global conversion state (a static object of type [`mbstate_t`](mbstate_t \"c/string/multibyte/mbstate t\"), known only to this function). If the multibyte encoding uses shift states, this function is not reentrant. In any case, multiple threads should not call `wctomb` without synchronization: [`wcrtomb`](wcrtomb \"c/string/multibyte/wcrtomb\") or `wctomb_s` may be used instead.\n\nUnlike most bounds-checked functions, `wctomb_s` does not null-terminate its output, because it is designed to be used in loops that process strings character-by-character.\n\n### Parameters\n\n|        |     |                                                                                                                             |\n|--------|-----|-----------------------------------------------------------------------------------------------------------------------------|\n| s      | \\-  | pointer to the character array for output                                                                                   |\n| wc     | \\-  | wide character to convert                                                                                                   |\n| ssz    | \\-  | maximum number of bytes to write to `s` (size of the array `s`)                                                             |\n| status | \\-  | pointer to an out-parameter where the result (length of the multibyte sequence or the shift sequence status) will be stored |\n\n### Return value\n\n1) If `s` is not a null pointer, returns the number of bytes that are contained in the multibyte representation of `wc` or `-1` if `wc` is not a valid character.\n\nIf `s` is a null pointer, resets its internal conversion state to represent the initial shift state and returns `​0​` if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).\n\n2) zero on success, in which case the multibyte representation of `wc` is stored in `s` and its length is stored in `*status`, or, if `s` is null, the shift sequence status is stored in `status`). Non-zero on encoding error or runtime constraint violation, in which case `(`[`size_t`](http://en.cppreference.com/w/c/types/size_t)`)``-``1` is stored in `*status`. The value stored in `*status` never exceeds `MB_CUR_MAX`\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n \nvoid demo(wchar_t wc)\n{\n    const char* dep = wctomb(NULL, wc) ? \"Yes\" : \"No\";\n    printf(\"State-dependent encoding? %s.\\n\", dep);\n \n    char mb[MB_CUR_MAX];\n    int len = wctomb(mb, wc);\n    printf(\"wide char '%lc' -> multibyte char [\", wc);\n    for (int idx = 0; idx < len; ++idx)\n        printf(\"%s%#2x\", idx ? \" \" : \"\", (unsigned char)mb[idx]);\n    printf(\"]\\n\");\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"MB_CUR_MAX = %zu\\n\", MB_CUR_MAX);\n    demo(L'A');\n    demo(L'\\u00df');\n    demo(L'\\U0001d10b');\n}\n```\n\nPossible output:\n\n```\nMB_CUR_MAX = 6\nState-dependent encoding? No.\nwide char 'A' -> multibyte char [0x41]\nState-dependent encoding? No.\nwide char 'ß' -> multibyte char [0xc3 0x9f]\nState-dependent encoding? No.\nwide char '𝄋' -> multibyte char [0xf0 0x9d 0x84 0x8b]\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.22.7.3 The wctomb function (p: 261)\n  - K.3.6.4.1 The wctomb_s function (p: 443)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.22.7.3 The wctomb function (p: 358-359)\n  - K.3.6.4.1 The wctomb_s function (p: 610-611)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.20.7.3 The wctomb function (p: 322-323)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 4.10.7.3 The wctomb function\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/multibyte/wctomb](https://en.cppreference.com/w/c/string/multibyte/wctomb)"
- name: wctrans
  summary: Constructs a value of type wctrans_t that describes a LC_CTYPE category of wide character mapping
  description: "# wctrans\n\n[TABLE]\n\nConstructs a value of type `wctrans_t` that describes a [`LC_CTYPE`](../../locale/lc_categories \"c/locale/LC categories\") category of wide character mapping. It may be one of the standard mappings, or a locale-specific mapping, such as `\"tojhira\"` or `\"tojkata\"`.\n\n### Parameters\n\n[TABLE]\n\n### Return value\n\n`wctrans_t` object suitable for use with [`towctrans`](towctrans \"c/string/wide/towctrans\") to map wide characters according to the named mapping of the current C locale or zero if `str` does not name a mapping supported by the current C locale.\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.3.2.2 The wctrans function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.3.2.2 The wctrans function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.3.2.2 The wctrans function (p: 454)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.3.2,2 The wctrans function (p: 400)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wctrans](https://en.cppreference.com/w/c/string/wide/wctrans)"
- name: wctype
  summary: Constructs a value of type wctype_t that describes a LC_CTYPE category of wide character classification
  description: "# wctype\n\n[TABLE]\n\nConstructs a value of type `wctype_t` that describes a [`LC_CTYPE`](../../locale/lc_categories \"c/locale/LC categories\") category of wide character classification. It may be one of the standard classification categories, or a locale-specific category, such as `\"jkanji\"`.\n\n### Parameters\n\n|     |     |                                                   |\n|-----|-----|---------------------------------------------------|\n| str | \\-  | C string holding the name of the desired category |\n\nThe following values of `str` are supported in all C locales:\n\n| value of `str` | effect                                                                                |\n|----------------|---------------------------------------------------------------------------------------|\n| `\"alnum\"`      | identifies the category used by [`iswalnum`](iswalnum \"c/string/wide/iswalnum\")       |\n| `\"alpha\"`      | identifies the category used by [`iswalpha`](iswalpha \"c/string/wide/iswalpha\")       |\n| `\"blank\"`      | identifies the category used by [`iswblank`](iswblank \"c/string/wide/iswblank\") (C99) |\n| `\"cntrl\"`      | identifies the category used by [`iswcntrl`](iswcntrl \"c/string/wide/iswcntrl\")       |\n| `\"digit\"`      | identifies the category used by [`iswdigit`](iswdigit \"c/string/wide/iswdigit\")       |\n| `\"graph\"`      | identifies the category used by [`iswgraph`](iswgraph \"c/string/wide/iswgraph\")       |\n| `\"lower\"`      | identifies the category used by [`iswlower`](iswlower \"c/string/wide/iswlower\")       |\n| `\"print\"`      | identifies the category used by [`iswprint`](iswprint \"c/string/wide/iswprint\")       |\n| `\"space\"`      | identifies the category used by [`iswspace`](iswspace \"c/string/wide/iswspace\")       |\n| `\"upper\"`      | identifies the category used by [`iswupper`](iswupper \"c/string/wide/iswupper\")       |\n| `\"xdigit\"`     | identifies the category used by [`iswxdigit`](iswxdigit \"c/string/wide/iswxdigit\")    |\n\n### Return value\n\n`wctype_t` object suitable for use with [`iswctype`](iswctype \"c/string/wide/iswctype\") to classify wide characters according to the named category of the current C locale or zero if `str` does not name a category supported by the current C locale.\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.30.2.2.2 The wctype function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.30.2.2.2 The wctype function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.30.2.2.2 The wctype function (p: 452)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.25.2.2.2 The wctype function (p: 398)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wctype](https://en.cppreference.com/w/c/string/wide/wctype)"
- name: while
  summary: ''
  description: "# C keywords: while\n\n### Usage\n\n- [`while` loop](../language/while \"c/language/while\"): as the declaration of the loop\n- [`do-while` loop](../language/do \"c/language/do\"): as the declaration of the terminating condition of the loop\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/keyword/while](https://en.cppreference.com/w/c/keyword/while)"
- name: while loop
  summary: Executes a statement repeatedly, until the value of expression becomes equal to zero
  description: "# while loop\n\nExecutes a statement repeatedly, until the value of expression becomes equal to zero. The test takes place before each iteration.\n\n### Syntax\n\n|                                                            |     |     |\n|------------------------------------------------------------|-----|-----|\n| attr-spec-seq(optional) `while (` expression `)` statement |     |     |\n\n|               |     |                                                                                                                                                                                                                        |\n|---------------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| expression    | \\-  | any [expression](expressions \"c/language/expressions\") of [scalar type](type#Type_groups \"c/language/type\"). This expression is evaluated before each iteration, and if it compares equal to zero, the loop is exited. |\n| statement     | \\-  | any [statement](statements \"c/language/statements\"), typically a compound statement, which serves as the body of the loop                                                                                              |\n| attr-spec-seq | \\-  | (C23)optional list of [attributes](attributes \"c/language/attributes\"), applied to the loop statement                                                                                                                  |\n\n### Explanation\n\nA `while` statement causes the statement (also called *the loop body*) to be executed repeatedly until the expression (also called *controlling expression*) compares equal to zero. The repetition occurs regardless of whether the loop body is entered normally or by a [goto](goto \"c/language/goto\") into the middle of statement.\n\nThe evaluation of expression takes place before each execution of statement (unless entered by a goto). If the controlling expression needs to be evaluated after the loop body, the [do-while loop](do \"c/language/do\") may be used.\n\nIf the execution of the loop needs to be terminated at some point, [break statement](break \"c/language/break\") can be used as a terminating statement.\n\nIf the execution of the loop needs to be continued at the end of the loop body, [continue statement](continue \"c/language/continue\") can be used as a shortcut.\n\nA program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; `while(true)` is always an endless loop.\n\n|                                                                                                                                                                                                                   |             |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|\n| As with all other selection and iteration statements, the while statement establishes [block scope](scope \"c/language/scope\"): any identifier introduced in the expression goes out of scope after the statement. | (since C99) |\n\n### Notes\n\nBoolean and pointer expressions are often used as loop controlling expressions. The boolean value `false` and the null pointer value of any pointer type compare equal to zero.\n\n### Keywords\n\n[`while`](../keyword/while \"c/keyword/while\")\n\n### Example\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nenum { SIZE = 8 };\nint main(void)\n{\n    // trivial example\n    int array[SIZE], n = 0;\n    while(n < SIZE) array[n++] = rand() % 2;\n    puts(\"Array filled!\");\n    n = 0;\n    while(n < SIZE) printf(\"%d \", array[n++]);\n    printf(\"\\n\");\n \n    // classic strcpy() implementation\n    // (copies a null-terminated string from src to dst)\n    char src[] = \"Hello, world\", dst[sizeof src], *p = dst, *q = src;\n    while((*p++ = *q++)) // double parentheses (that are not strictly necessary)\n                         // used to suppress warnings, ensuring that this is an\n                         // assignment (as opposed to a comparison) by intention,\n                         // whose result is used as a truth value\n        ; // null statement\n    puts(dst);\n}\n```\n\nOutput:\n\n```\nArray filled!\n1 0 1 1 1 1 0 0 \nHello, world\n```\n\n### References\n\n- C17 standard (ISO/IEC 9899:2018):\n  - 6.8.5.1 The while statement (p: 109)\n- C11 standard (ISO/IEC 9899:2011):\n  - 6.8.5.1 The while statement (p: 151)\n- C99 standard (ISO/IEC 9899:1999):\n  - 6.8.5.1 The while statement (p: 136)\n- C89/C90 standard (ISO/IEC 9899:1990):\n  - 3.6.5.1 The while statement\n\n### See also\n\n|                                                                                                             |     |\n|-------------------------------------------------------------------------------------------------------------|-----|\n| [C++ documentation](https://en.cppreference.com/w/cpp/language/while \"cpp/language/while\") for `while` loop |     |\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/language/while](https://en.cppreference.com/w/c/language/while)"
- name: wmemchr
  summary: If count is zero, the function returns a null pointer
  description: "# wmemchr\n\n[TABLE]\n\n1) Locates the first occurrence of wide character `ch` in the initial `count` wide characters of the wide character array or integer array of compatible type, pointed to by `ptr`.\n\n2) Type-generic function equivalent to (1). Let `T` be an unqualified wide character object type.\n\n- If `ptr` is of type `const T*`, the return type is `const wchar_t*`.\n- Otherwise, if `ptr` is of type `T*`, the return type is `wchar_t*`.\n- Otherwise, the behavior is undefined.\n\nIf a macro definition of each of these generic functions is suppressed to access an actual function (e.g. if `(wmemchr)` or a function pointer is used), the actual function declaration (1) becomes visible.\n\nIf `count` is zero, the function returns a null pointer.\n\n### Parameters\n\n|       |     |                                                    |\n|-------|-----|----------------------------------------------------|\n| ptr   | \\-  | pointer to the wide character array to be examined |\n| ch    | \\-  | wide character to search for                       |\n| count | \\-  | number of wide characters to examine               |\n\n### Return value\n\nPointer to the location of the wide character, or a null pointer if no such character is found.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    wchar_t str[] = L\"诺不轻信，故人不负我\\0诺不轻许，故我不负人。\";\n    size_t sz = sizeof str / sizeof *str;\n \n    wchar_t target = L'许';\n    wchar_t* result = wmemchr(str, target, sz);\n \n    if (result)\n    {\n        setlocale(LC_ALL, \"en_US.utf8\");\n        printf(\"Found '%lc' at position %td\\n\",target, result - str);\n    }\n}\n```\n\nPossible output:\n\n```\nFound '许' at position 14\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.29.4.5.8 The wmemchr function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.5.8 The wmemchr function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.5.8 The wmemchr function (p: 438)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.5.8 The wmemchr function (p: 384)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wmemchr](https://en.cppreference.com/w/c/string/wide/wmemchr)"
- name: wmemcmp
  summary: Compares the first count wide characters of the wide character (or compatible integer type) arrays pointed to by lhs and rhs
  description: "# wmemcmp\n\n[TABLE]\n\nCompares the first `count` wide characters of the wide character (or compatible integer type) arrays pointed to by `lhs` and `rhs`. The comparison is done lexicographically.\n\nThe sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.\n\nIf `count` is zero, the function does nothing.\n\n### Parameters\n\n|          |     |                                                  |\n|----------|-----|--------------------------------------------------|\n| lhs, rhs | \\-  | pointers to the wide character arrays to compare |\n| count    | \\-  | number of wide characters to examine             |\n\n### Return value\n\nNegative value if the value of the first differing wide character in `lhs` is less than the value of the corresponding wide character in `rhs`: `lhs` precedes `rhs` in lexicographical order.\n\n`​0​` if all `count` wide characters of `lhs` and `rhs` are equal.\n\nPositive value if the value of the first differing wide character in `lhs` is greater than the value of the corresponding wide character in `rhs`: `rhs` precedes `lhs` in lexicographical order.\n\n### Notes\n\nThis function is not locale-sensitive and pays no attention to the values of the `wchar_t` objects it examines: nulls as well as invalid wide characters are compared too.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nvoid demo(const wchar_t* lhs, const wchar_t* rhs, size_t sz)\n{\n    for (size_t n = 0; n < sz; ++n)\n        putwchar(lhs[n]);\n \n    int rc = wmemcmp(lhs, rhs, sz);\n    if (rc == 0)\n        wprintf(L\" compares equal to \");\n    else if(rc < 0)\n        wprintf(L\" precedes \");\n    else if(rc > 0)\n        wprintf(L\" follows \");\n \n    for (size_t n = 0; n < sz; ++n)\n        putwchar(rhs[n]);\n    wprintf(L\" in lexicographical order\\n\");\n}\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    wchar_t a1[] = {L'α',L'β',L'γ'};\n    wchar_t a2[] = {L'α',L'β',L'δ'};\n \n    size_t sz = sizeof a1 / sizeof *a1;\n    demo(a1, a2, sz);\n    demo(a2, a1, sz);\n    demo(a1, a1, sz);\n}\n```\n\nOutput:\n\n```\nαβγ precedes αβδ in lexicographical order\nαβδ follows αβγ in lexicographical order\nαβγ compares equal to αβγ in lexicographical order\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.29.4.4.5 The wmemcmp function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.4.5 The wmemcmp function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.4.5 The wmemcmp function (p: 435)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.4.5 The wmemcmp function (p: 381)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wmemcmp](https://en.cppreference.com/w/c/string/wide/wmemcmp)"
- name: wmemcpy
  summary: This function's analog for byte strings is strncpy, not strcpy
  description: "# wmemcpy, wmemcpy_s\n\n[TABLE]\n\n1) Copies exactly `count` successive wide characters from the wide character array pointed to by `src` to the wide character array pointed to by `dest`. If the objects overlap, the behavior is undefined. If `count` is zero, the function does nothing.\n\n2) Same as (1), except that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX/sizeof(wchar_t)`\n- `count` is greater than `destsz` (overflow would occur)\n- overlap would occur between the source and the destination arrays\n\nAs with all bounds-checked functions, `wmemcpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                             |\n|--------|-----|-----------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the wide character array to copy to                              |\n| src    | \\-  | pointer to the wide character array to copy from                            |\n| count  | \\-  | number of wide characters to copy                                           |\n| destsz | \\-  | max number of wide characters to write (the size of the destination buffer) |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, fills the entire `dst` up to and not including `dst+dstsz` with null wide characters, `L'\\0'` (unless `dest` is null or `destsz` is greater than `RSIZE_MAX/sizeof(wchar_t)`)\n\n### Notes\n\nThis function's analog for byte strings is [`strncpy`](../byte/strncpy \"c/string/byte/strncpy\"), not [`strcpy`](../byte/strcpy \"c/string/byte/strcpy\").\n\nThis function is not locale-sensitive and pays no attention to the values of the `wchar_t` objects it copies: nulls as well as invalid characters are copied too.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n \nint main(void)\n{\n    wchar_t from1[] = L\"नमस्ते\";\n    size_t sz1 = sizeof from1 / sizeof *from1;\n    wchar_t from2[] = L\"Բարև\";\n    size_t sz2 = sizeof from2 / sizeof *from2;\n    wchar_t to[sz1 + sz2];\n    wmemcpy(to, from1, sz1); // copy from1, along with its null terminator\n    wmemcpy(to + sz1, from2, sz2); // append from2, along with its null terminator\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"Wide array contains: \");\n    for(size_t n = 0; n < sizeof to / sizeof *to; ++n)\n        if(to[n])\n            printf(\"%lc\", to[n]);\n        else\n            printf(\"\\\\0\");\n    printf(\"\\n\");\n}\n```\n\nPossible output:\n\n```\nWide array contains: नमस्ते\\0Բարև\\0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.2.3 The wmemcpy function (p: 431)\n  - K.3.9.2.1.3 The wmemcpy_s function (p: 641)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.2.3 The wmemcpy function (p: 377)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wmemcpy](https://en.cppreference.com/w/c/string/wide/wmemcpy)"
- name: wmemcpy_s
  summary: This function's analog for byte strings is strncpy, not strcpy
  description: "# wmemcpy, wmemcpy_s\n\n[TABLE]\n\n1) Copies exactly `count` successive wide characters from the wide character array pointed to by `src` to the wide character array pointed to by `dest`. If the objects overlap, the behavior is undefined. If `count` is zero, the function does nothing.\n\n2) Same as (1), except that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX/sizeof(wchar_t)`\n- `count` is greater than `destsz` (overflow would occur)\n- overlap would occur between the source and the destination arrays\n\nAs with all bounds-checked functions, `wmemcpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                             |\n|--------|-----|-----------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the wide character array to copy to                              |\n| src    | \\-  | pointer to the wide character array to copy from                            |\n| count  | \\-  | number of wide characters to copy                                           |\n| destsz | \\-  | max number of wide characters to write (the size of the destination buffer) |\n\n### Return value\n\n1) returns a copy of `dest`\n\n2) returns zero on success, returns non-zero on error. Also, on error, fills the entire `dst` up to and not including `dst+dstsz` with null wide characters, `L'\\0'` (unless `dest` is null or `destsz` is greater than `RSIZE_MAX/sizeof(wchar_t)`)\n\n### Notes\n\nThis function's analog for byte strings is [`strncpy`](../byte/strncpy \"c/string/byte/strncpy\"), not [`strcpy`](../byte/strcpy \"c/string/byte/strcpy\").\n\nThis function is not locale-sensitive and pays no attention to the values of the `wchar_t` objects it copies: nulls as well as invalid characters are copied too.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n \nint main(void)\n{\n    wchar_t from1[] = L\"नमस्ते\";\n    size_t sz1 = sizeof from1 / sizeof *from1;\n    wchar_t from2[] = L\"Բարև\";\n    size_t sz2 = sizeof from2 / sizeof *from2;\n    wchar_t to[sz1 + sz2];\n    wmemcpy(to, from1, sz1); // copy from1, along with its null terminator\n    wmemcpy(to + sz1, from2, sz2); // append from2, along with its null terminator\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    printf(\"Wide array contains: \");\n    for(size_t n = 0; n < sizeof to / sizeof *to; ++n)\n        if(to[n])\n            printf(\"%lc\", to[n]);\n        else\n            printf(\"\\\\0\");\n    printf(\"\\n\");\n}\n```\n\nPossible output:\n\n```\nWide array contains: नमस्ते\\0Բարև\\0\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.2.3 The wmemcpy function (p: 431)\n  - K.3.9.2.1.3 The wmemcpy_s function (p: 641)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.2.3 The wmemcpy function (p: 377)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wmemcpy](https://en.cppreference.com/w/c/string/wide/wmemcpy)"
- name: wmemmove
  summary: 'This function is not locale-sensitive and pays no attention to the values of the wchar_t objects it copies: nulls as well as invalid characters are copied too'
  description: "# wmemmove, wmemmove_s\n\n[TABLE]\n\n1) Copies exactly `count` successive wide characters from the wide character array pointed to by `src` to the wide character array pointed to by `dest`. If `count` is zero, the function does nothing. The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to `dest`.\n\n2) Same as (1), except that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX / sizeof(wchar_t)`\n- `count` is greater than `destsz` (overflow would occur)\n\nAs with all bounds-checked functions, `wmemcpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                             |\n|--------|-----|-----------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the wide character array to copy to                              |\n| src    | \\-  | pointer to the wide character array to copy from                            |\n| destsz | \\-  | max number of wide characters to write (the size of the destination buffer) |\n| count  | \\-  | number of wide characters to copy                                           |\n\n### Return value\n\n1) Returns a copy of `dest`\n\n2) Returns zero on success, returns non-zero on error. Also, on error, fills the entire `dst` up to and not including `dst+dstsz` with null wide characters, `L'\\0'` (unless `dest` is null or `destsz` is greater than `RSIZE_MAX/sizeof(wchar_t)`)\n\n### Notes\n\nThis function is not locale-sensitive and pays no attention to the values of the `wchar_t` objects it copies: nulls as well as invalid characters are copied too.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    wchar_t str[] = L\"αβγδεζηθικλμνξοπρστυφχψω\";\n    printf(\"%ls\\n\", str);\n    wmemmove(str + 4, str + 3, 3); // copy from [δεζ] to [εζη]\n    printf(\"%ls\\n\", str);\n}\n```\n\nOutput:\n\n```\nαβγδεζηθικλμνξοπρστυφχψω\nαβγδδεζθικλμνξοπρστυφχψω\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.29.4.2.4 The wmemmove function (p: TBD)\n  - K.3.9.2.1.4 The wmemmove_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.2.4 The wmemmove function (p: TBD)\n  - K.3.9.2.1.4 The wmemmove_s function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.2.4 The wmemmove function (p: 432)\n  - K.3.9.2.1.4 The wmemmove_s function (p: 642)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.2.4 The wmemmove function (p: 378)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wmemmove](https://en.cppreference.com/w/c/string/wide/wmemmove)"
- name: wmemmove_s
  summary: 'This function is not locale-sensitive and pays no attention to the values of the wchar_t objects it copies: nulls as well as invalid characters are copied too'
  description: "# wmemmove, wmemmove_s\n\n[TABLE]\n\n1) Copies exactly `count` successive wide characters from the wide character array pointed to by `src` to the wide character array pointed to by `dest`. If `count` is zero, the function does nothing. The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to `dest`.\n\n2) Same as (1), except that the following errors are detected at runtime and call the currently installed [constraint handler](../../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- `src` or `dest` is a null pointer\n- `destsz` or `count` is greater than `RSIZE_MAX / sizeof(wchar_t)`\n- `count` is greater than `destsz` (overflow would occur)\n\nAs with all bounds-checked functions, `wmemcpy_s` only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                             |\n|--------|-----|-----------------------------------------------------------------------------|\n| dest   | \\-  | pointer to the wide character array to copy to                              |\n| src    | \\-  | pointer to the wide character array to copy from                            |\n| destsz | \\-  | max number of wide characters to write (the size of the destination buffer) |\n| count  | \\-  | number of wide characters to copy                                           |\n\n### Return value\n\n1) Returns a copy of `dest`\n\n2) Returns zero on success, returns non-zero on error. Also, on error, fills the entire `dst` up to and not including `dst+dstsz` with null wide characters, `L'\\0'` (unless `dest` is null or `destsz` is greater than `RSIZE_MAX/sizeof(wchar_t)`)\n\n### Notes\n\nThis function is not locale-sensitive and pays no attention to the values of the `wchar_t` objects it copies: nulls as well as invalid characters are copied too.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    setlocale(LC_ALL, \"en_US.utf8\");\n \n    wchar_t str[] = L\"αβγδεζηθικλμνξοπρστυφχψω\";\n    printf(\"%ls\\n\", str);\n    wmemmove(str + 4, str + 3, 3); // copy from [δεζ] to [εζη]\n    printf(\"%ls\\n\", str);\n}\n```\n\nOutput:\n\n```\nαβγδεζηθικλμνξοπρστυφχψω\nαβγδδεζθικλμνξοπρστυφχψω\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.29.4.2.4 The wmemmove function (p: TBD)\n  - K.3.9.2.1.4 The wmemmove_s function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.2.4 The wmemmove function (p: TBD)\n  - K.3.9.2.1.4 The wmemmove_s function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.2.4 The wmemmove function (p: 432)\n  - K.3.9.2.1.4 The wmemmove_s function (p: 642)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.2.4 The wmemmove function (p: 378)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wmemmove](https://en.cppreference.com/w/c/string/wide/wmemmove)"
- name: wmemset
  summary: Copies the wide character ch into each of the first count wide characters of the wide character array (or integer array of compatible type) pointed to by dest
  description: "# wmemset\n\n[TABLE]\n\nCopies the wide character `ch` into each of the first `count` wide characters of the wide character array (or integer array of compatible type) pointed to by `dest`.\n\nIf overflow occurs, the behavior is undefined.\n\nIf `count` is zero, the function does nothing.\n\n### Parameters\n\n|       |     |                                             |\n|-------|-----|---------------------------------------------|\n| dest  | \\-  | pointer to the wide character array to fill |\n| ch    | \\-  | fill wide character                         |\n| count | \\-  | number of wide characters to fill           |\n\n### Return value\n\nReturns a copy of `dest`\n\n### Notes\n\nThis function is not locale-sensitive and pays no attention to the values of the `wchar_t` objects it writes: nulls as well as invalid wide characters are written too.\n\n### Example\n\n```\n#include <locale.h>\n#include <stdio.h>\n#include <wchar.h>\n \nint main(void)\n{\n    wchar_t ar[10] = L\"1234567890\"; // no trailing null in the array\n    wmemset(ar, L'\\U0001f34c', 5); // replaces [12345] with the 🍌 bananas\n    wmemset(ar + 5, L'蕉', 5); // replaces [67890] with the 蕉 bananas\n \n    setlocale(LC_ALL, \"en_US.utf8\");\n    for (size_t n = 0; n < sizeof ar / sizeof *ar; ++n)\n        putwchar(ar[n]);\n    putwchar(L'\\n');\n}\n```\n\nOutput:\n\n```\n🍌🍌🍌🍌🍌蕉蕉蕉蕉蕉\n```\n\n### References\n\n- C23 standard (ISO/IEC 9899:2023):\n  - 7.29.4.6.2 The wmemset function (p: TBD)\n- C17 standard (ISO/IEC 9899:2018):\n  - 7.29.4.6.2 The wmemset function (p: TBD)\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.4.6.2 The wmemset function (p: 439)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.4.6.2 The wmemset function (p: 385)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/string/wide/wmemset](https://en.cppreference.com/w/c/string/wide/wmemset)"
- name: wprintf
  summary: Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# wprintf, fwprintf, swprintf, wprintf_s, fwprintf_s, swprintf_s, snwprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) If `bufsz` is greater than zero, writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. If `bufsz` is zero, nothing is written (and `buffer` may be a null pointer).\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (only for `swprintf_s`) the number of wide characters to be written, including the null, would exceed `bufsz`.\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by s. As with all bounds-checked functions, `wprintf_s` , `fwprintf_s`, `swprintf_s`, and `snwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a wide character string to write to                                                                                                                                                                                                                                                                                                                                                                                           |\n| bufsz  | \\-  | up to `bufsz-1` wide characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                 |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) Number of wide characters written if successful or negative value if an error occurred.\n\n3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than `size` (including when `size` is zero).\n\n4,5) Number of wide characters written if successful or negative value if an error occurred.\n\n6) Number of wide characters (not counting the terminating null) that were written to `buffer`. Returns a negative value on encoding errors and on overflow. Returns zero on all other errors.\n\n7) Number of wide characters (not counting the terminating null) that would have been written to `buffer` had `bufsz` been sufficiently large, or a negative value if an error occurs. (meaning, write was successful and complete only if the return is nonnegative and less than `bufsz`)\n\n### Notes\n\nWhile narrow strings provide [`snprintf`](fprintf \"c/io/fprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until `snwprintf_s`)(since C11), and in order to determine the buffer size, the program may need to call `swprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`snwprintf_s`, unlike `swprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    char narrow_str[] = \"z\\u00df\\u6c34\\U0001f34c\";\n                    // or \"zß水🍌\"\n                    // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator\n    setlocale(LC_ALL, \"en_US.utf8\");\n    swprintf(warr, sizeof warr/sizeof *warr,\n              L\"Converted from UTF-8: '%s'\", narrow_str);\n    wprintf(L\"%ls\\n\", warr);\n}\n```\n\nOutput:\n\n```\nConverted from UTF-8: 'zß水🍌'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.1 The fwprintf function (p: 403-410)\n  - 7.29.2.3 The swprintf function (p: 416)\n  - 7.29.2.11 The wprintf function (p: 421)\n  - K.3.9.1.1 The fwprintf_s function (p: 628)\n  - K.3.9.1.4 The swprintf_s function (p: 630-631)\n  - K.3.9.1.13 The wprintf_s function (p: 637-638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.1 The fwprintf function (p: 349-356)\n  - 7.24.2.3 The swprintf function (p: 362)\n  - 7.24.2.11 The wprintf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwprintf](https://en.cppreference.com/w/c/io/fwprintf)"
- name: wprintf_s
  summary: Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks
  description: "# wprintf, fwprintf, swprintf, wprintf_s, fwprintf_s, swprintf_s, snwprintf_s\n\n[TABLE]\n\nLoads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.\n\n1) Writes the results to [`stdout`](std_streams \"c/io/std streams\").\n\n2) Writes the results to a file stream `stream`.\n\n3) If `bufsz` is greater than zero, writes the results to a wide string `buffer`. At most `bufsz-1` wide characters are written followed by null wide character. If `bufsz` is zero, nothing is written (and `buffer` may be a null pointer).\n\n4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- the conversion specifier `%n` is present in `format`\n- any of the arguments corresponding to `%s` is a null pointer\n- `format` or `buffer` is a null pointer\n- `bufsz` is zero or greater than `RSIZE_MAX/sizeof(wchar_t)`\n- encoding errors occur in any of string and character conversion specifiers\n- (only for `swprintf_s`) the number of wide characters to be written, including the null, would exceed `bufsz`.\n\n7) Same as (6), except it will truncate the result to fit within the array pointed to by s. As with all bounds-checked functions, `wprintf_s` , `fwprintf_s`, `swprintf_s`, and `snwprintf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<stdio.h>`](../io \"c/io\").\n\n### Parameters\n\n|        |     |                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n|--------|-----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| stream | \\-  | output file stream to write to                                                                                                                                                                                                                                                                                                                                                                                                           |\n| buffer | \\-  | pointer to a wide character string to write to                                                                                                                                                                                                                                                                                                                                                                                           |\n| bufsz  | \\-  | up to `bufsz-1` wide characters may be written, plus the null terminator                                                                                                                                                                                                                                                                                                                                                                 |\n| format | \\-  | pointer to a null-terminated wide string specifying how to interpret the data                                                                                                                                                                                                                                                                                                                                                            |\n| ...    | \\-  | arguments specifying data to print. If any argument after [default argument promotions](../language/conversion#Default_argument_promotions \"c/language/conversion\") is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by `format`, the behavior is undefined. If there are more arguments than required by `format`, the extraneous arguments are evaluated and ignored. |\n\n  \nThe **format** string consists of ordinary wide characters (except `%`), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n- introductory `%` character.\n- (optional) one or more flags that modify the behavior of the conversion:\n  - `-`: the result of the conversion is left-justified within the field (by default it is right-justified).\n  - `+`: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative).\n  - *space*: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if `+` flag is present.\n  - `#`: *alternative form* of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.\n  - `0`: for integer and floating point number conversions, leading zeros are used to pad the field instead of *space* characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if `-` flag is present.\n- (optional) integer value or `*` that specifies minimum field width. The result is padded with *space* characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when `*` is used, the width is specified by an additional argument of type `int`, which appears before the argument to be converted and the argument supplying precision if one is supplied. If the value of the argument is negative, it results with the `-` flag specified and positive field width (Note: This is the minimum width: The value is never truncated.).\n  - (optional) `.` followed by integer number or `*`, or neither that specifies *precision* of the conversion. In the case when `*` is used, the *precision* is specified by an additional argument of type `int`, which appears before the argument to be converted, but after the argument supplying minimum field width if one is supplied. If the value of this argument is negative, it is ignored. If neither a number nor `*` is used, the precision is taken as zero. See the table below for exact effects of *precision*.\n  - (optional) *length modifier* that specifies the size of the argument (in combination with the conversion format specifier, it specifies the type of the corresponding argument).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nThe floating point conversion functions convert infinity to `inf` or `infinity`. Which one is used is implementation defined.\n\nNot-a-number is converted to `nan` or `nan(`*`char_sequence`*`)`. Which one is used is implementation defined.\n\nThe conversions `F`, `E`, `G`, `A` output `INF`, `INFINITY`, `NAN` instead.\n\nEven though `%c` expects `int` argument, it is safe to pass a `char` because of the integer promotion that takes place when a variadic function is called.\n\nThe correct conversion specifications for the fixed-width character types ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`PRIdMAX`](../types/integer \"c/types/integer\"), [`PRIuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThe memory-writing conversion specifier `%n` is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked `printf_s` family of functions.\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple `%n` results in the same variable or, as an edge case, printing a string modified by an earlier `%n` within the same call.\n\nIf a conversion specification is invalid, the behavior is undefined.\n\n### Return value\n\n1,2) Number of wide characters written if successful or negative value if an error occurred.\n\n3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than `size` (including when `size` is zero).\n\n4,5) Number of wide characters written if successful or negative value if an error occurred.\n\n6) Number of wide characters (not counting the terminating null) that were written to `buffer`. Returns a negative value on encoding errors and on overflow. Returns zero on all other errors.\n\n7) Number of wide characters (not counting the terminating null) that would have been written to `buffer` had `bufsz` been sufficiently large, or a negative value if an error occurs. (meaning, write was successful and complete only if the return is nonnegative and less than `bufsz`)\n\n### Notes\n\nWhile narrow strings provide [`snprintf`](fprintf \"c/io/fprintf\"), which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until `snwprintf_s`)(since C11), and in order to determine the buffer size, the program may need to call `swprintf`, check the result value, and reallocate a larger buffer, trying again until successful.\n\n`snwprintf_s`, unlike `swprintf_s`, will truncate the result to fit within the array pointed to by `buffer`, even though truncation is treated as an error by most bounds-checked functions.\n\n### Example\n\n```\n#include <locale.h>\n#include <wchar.h>\n \nint main(void)\n{\n    char narrow_str[] = \"z\\u00df\\u6c34\\U0001f34c\";\n                    // or \"zß水🍌\"\n                    // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator\n    setlocale(LC_ALL, \"en_US.utf8\");\n    swprintf(warr, sizeof warr/sizeof *warr,\n              L\"Converted from UTF-8: '%s'\", narrow_str);\n    wprintf(L\"%ls\\n\", warr);\n}\n```\n\nOutput:\n\n```\nConverted from UTF-8: 'zß水🍌'\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.1 The fwprintf function (p: 403-410)\n  - 7.29.2.3 The swprintf function (p: 416)\n  - 7.29.2.11 The wprintf function (p: 421)\n  - K.3.9.1.1 The fwprintf_s function (p: 628)\n  - K.3.9.1.4 The swprintf_s function (p: 630-631)\n  - K.3.9.1.13 The wprintf_s function (p: 637-638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.1 The fwprintf function (p: 349-356)\n  - 7.24.2.3 The swprintf function (p: 362)\n  - 7.24.2.11 The wprintf function (p: 366)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwprintf](https://en.cppreference.com/w/c/io/fwprintf)"
- name: wscanf
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into given locations
  description: "# wscanf, fwscanf, swscanf, wscanf_s, fwscanf_s, swscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%lc` into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs all bounds-checked functions, `wscanf_s`, `fwscanf_s`, and `swscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../string/wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                      |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <string.h>\n \n#define NUM_VARS   3\n#define ERR_READ   2\n#define ERR_WRITE  3\n \nint main(void) {\n    wchar_t state[64];\n    wchar_t capital[64];\n    unsigned int population = 0;\n    int elevation = 0;\n    int age = 0;\n    float pi = 0;\n \n#if INTERACTIVE_MODE\n    wprintf(L\"Enter state, age, and pi value: \");\n    if (wscanf(L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#else\n    wchar_t* input = L\"California 170 3.141592\";\n    if (swscanf(input, L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#endif\n    wprintf(L\"State: %ls\\nAge  : %d years\\nPi   : %.5f\\n\\n\", state, age, pi);\n \n    FILE* fp = tmpfile();\n    if (fp) {\n        // write some data to temp file\n        if (!fwprintf(fp, L\"Mississippi Jackson 420000 807\")) {\n            fprintf(stderr, \"Error writing to file.\\n\");\n            fclose(fp);\n            return ERR_WRITE;\n        }\n        // rewind file pointer\n        rewind(fp);\n \n        // read data into variables\n        fwscanf(fp, L\"%ls%ls%u%d\", state, capital, &population, &elevation);\n        wprintf(L\"State  : %ls\\nCapital: %ls\\nJackson population (in 2020): %u\\n\"\n                L\"Highest elevation: %dft\\n\",\n                state, capital, population, elevation);\n        fclose(fp);\n    }\n}\n```\n\nPossible output:\n\n```\nState: California\nAge  : 170 years\nPi   : 3.14159\n \nState  : Mississippi\nCapital: Jackson\nJackson population (in 2020): 420000\nHighest elevation: 807ft\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.2 The fwscanf function (p: 410-416)\n  - 7.29.2.4 The swscanf function (p: 417)\n  - 7.29.2.12 The wscanf function (p: 421)\n  - K.3.9.1.2 The fwscanf_s function (p: 628-629)\n  - K.3.9.1.5 The swscanf_s function (p: 631)\n  - K.3.9.1.14 The wscanf_s function (p: 638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.2 The fwscanf function (p: 356-362)\n  - 7.24.2.4 The swscanf function (p: 362)\n  - 7.24.2.12 The wscanf function (p: 366-367)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwscanf](https://en.cppreference.com/w/c/io/fwscanf)"
- name: wscanf_s
  summary: Reads data from the a variety of sources, interprets it according to format and stores the results into given locations
  description: "# wscanf, fwscanf, swscanf, wscanf_s, fwscanf_s, swscanf_s\n\n[TABLE]\n\nReads data from the a variety of sources, interprets it according to `format` and stores the results into given locations.\n\n1) Reads the data from [`stdin`](std_streams \"c/io/std streams\").\n\n2) Reads the data from file stream `stream`.\n\n3) Reads the data from null-terminated wide string `buffer`. Reaching the end of the string is equivalent to reaching the end-of-file condition for `fwscanf`\n\n4-6) Same as (1-3), except that `%c`, `%s`, and `%[` conversion specifiers each expect two arguments (the usual pointer and a value of type `rsize_t` indicating the size of the receiving array, which may be `1` when reading with a `%lc` into a single wide character) and except that the following errors are detected at runtime and call the currently installed [constraint handler](../error/set_constraint_handler_s \"c/error/set constraint handler s\") function:\n\n- any of the arguments of pointer type is a null pointer\n- `format`, `stream`, or `buffer` is a null pointer\n- the number of characters that would be written by `%c`, `%s`, or `%[`, plus the terminating null character, would exceed the second (`rsize_t`) argument provided for each of those conversion specifiers\n- optionally, any other detectable error, such as unknown conversion specifier\n\nAs all bounds-checked functions, `wscanf_s`, `fwscanf_s`, and `swscanf_s` are only guaranteed to be available if `__STDC_LIB_EXT1__` is defined by the implementation and if the user defines `__STDC_WANT_LIB_EXT1__` to the integer constant `1` before including [`<wchar.h>`](../string/wide \"c/string/wide\").\n\n### Parameters\n\n|        |     |                                                                           |\n|--------|-----|---------------------------------------------------------------------------|\n| stream | \\-  | input file stream to read from                                            |\n| buffer | \\-  | pointer to a null-terminated wide string to read from                     |\n| format | \\-  | pointer to a null-terminated wide string specifying how to read the input |\n| ...    | \\-  | receiving arguments.                                                      |\n\n  \nThe **format** string consists of\n\n- non-whitespace wide characters except `%`: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.\n- whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\") in a loop). Note that there is no difference between `\"\\n\"`, `\" \"`, `\"\\t\\t\"`, or other whitespace in the format string.\n- conversion specifications. Each conversion specification has the following format:\n  - introductory `%` character.\n  - (optional) assignment-suppressing character `*`. If this option is present, the function does not assign the result of the conversion to any receiving argument.\n  - (optional) integer number (greater than zero) that specifies *maximum field width*, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that `%s` and `%[` may lead to buffer overflow if the width is not provided.\n  - (optional) *length modifier* that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).\n  - conversion format specifier.\n\nThe following format specifiers are available:\n\n[TABLE]\n\nFor every conversion specifier other than `n`, the longest sequence of input characters which does not exceed any specified ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\n\nAll conversion specifiers other than `[`, `c`, and `n` consume and discard all leading whitespace characters (determined as if by calling [`iswspace`](../string/wide/iswspace \"c/string/wide/iswspace\")) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\n\nIf the length specifier `l` is not used, the conversion specifiers `c`, `s`, and `[` perform wide-to-multibyte character conversion as if by calling [`wcrtomb`](../string/multibyte/wcrtomb \"c/string/multibyte/wcrtomb\") with an [`mbstate_t`](../string/multibyte/mbstate_t \"c/string/multibyte/mbstate t\") object initialized to zero before the first character is converted.\n\nThe conversion specifiers `s` and `[` always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of `%s` or `%[`, without specifying the destination array size, is as unsafe as [`gets`](gets \"c/io/gets\").\n\nThe correct conversion specifications for the [fixed-width integer types](../types/integer \"c/types/integer\") ([`int8_t`](../types/integer \"c/types/integer\"), etc) are defined in the header [`<inttypes.h>`](../types/integer \"c/types/integer\") (although [`SCNdMAX`](../types/integer \"c/types/integer\"), [`SCNuMAX`](../types/integer \"c/types/integer\"), etc is synonymous with `%jd`, `%ju`, etc).\n\nThere is a [sequence point](../language/eval_order \"c/language/eval order\") after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\n\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing `\"100er\"` with the conversion specifier `%f`, the sequence `\"100e\"` (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with `\"r\"` remaining. Some existing implementations do not follow this rule and roll back to consume only `\"100\"`, leaving `\"er\"`, e.g. [glibc bug 1765](https://sourceware.org/bugzilla/show_bug.cgi?id=1765).\n\n### Return value\n\n1-3) Number of receiving arguments successfully assigned, or [`EOF`](../io \"c/io\") if read failure occurs before the first receiving argument was assigned.\n\n4-6) Same as (1-3), except that [`EOF`](../io \"c/io\") is also returned if there is a runtime constraint violation.\n\n### Example\n\n```\n#include <stdio.h>\n#include <wchar.h>\n#include <string.h>\n \n#define NUM_VARS   3\n#define ERR_READ   2\n#define ERR_WRITE  3\n \nint main(void) {\n    wchar_t state[64];\n    wchar_t capital[64];\n    unsigned int population = 0;\n    int elevation = 0;\n    int age = 0;\n    float pi = 0;\n \n#if INTERACTIVE_MODE\n    wprintf(L\"Enter state, age, and pi value: \");\n    if (wscanf(L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#else\n    wchar_t* input = L\"California 170 3.141592\";\n    if (swscanf(input, L\"%ls%d%f\", state, &age, &pi) != NUM_VARS) {\n        fprintf(stderr, \"Error reading input.\\n\");\n        return ERR_READ;\n    }\n#endif\n    wprintf(L\"State: %ls\\nAge  : %d years\\nPi   : %.5f\\n\\n\", state, age, pi);\n \n    FILE* fp = tmpfile();\n    if (fp) {\n        // write some data to temp file\n        if (!fwprintf(fp, L\"Mississippi Jackson 420000 807\")) {\n            fprintf(stderr, \"Error writing to file.\\n\");\n            fclose(fp);\n            return ERR_WRITE;\n        }\n        // rewind file pointer\n        rewind(fp);\n \n        // read data into variables\n        fwscanf(fp, L\"%ls%ls%u%d\", state, capital, &population, &elevation);\n        wprintf(L\"State  : %ls\\nCapital: %ls\\nJackson population (in 2020): %u\\n\"\n                L\"Highest elevation: %dft\\n\",\n                state, capital, population, elevation);\n        fclose(fp);\n    }\n}\n```\n\nPossible output:\n\n```\nState: California\nAge  : 170 years\nPi   : 3.14159\n \nState  : Mississippi\nCapital: Jackson\nJackson population (in 2020): 420000\nHighest elevation: 807ft\n```\n\n### References\n\n- C11 standard (ISO/IEC 9899:2011):\n  - 7.29.2.2 The fwscanf function (p: 410-416)\n  - 7.29.2.4 The swscanf function (p: 417)\n  - 7.29.2.12 The wscanf function (p: 421)\n  - K.3.9.1.2 The fwscanf_s function (p: 628-629)\n  - K.3.9.1.5 The swscanf_s function (p: 631)\n  - K.3.9.1.14 The wscanf_s function (p: 638)\n- C99 standard (ISO/IEC 9899:1999):\n  - 7.24.2.2 The fwscanf function (p: 356-362)\n  - 7.24.2.4 The swscanf function (p: 362)\n  - 7.24.2.12 The wscanf function (p: 366-367)\n\n### See also\n\n[TABLE]\n\n© cppreference.com  \nLicensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.  \n[https://en.cppreference.com/w/c/io/fwscanf](https://en.cppreference.com/w/c/io/fwscanf)"
