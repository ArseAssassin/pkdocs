---
name: Nix
slug: nix
text_format: markdown
generator: src:devdocs
version: null
copyright: |-
  © 2022 NixOS Contributors
  Licensed under the LGPL License.
  https://nixos.org/manual/nix/stable/expressions/builtins.html
homepage: https://nixos.org/

---
- name: builtins.abort
  summary: Abort Nix expression evaluation and print the error message s
  description: |-
    ## `builtins.abort ``s`

    Abort Nix expression evaluation and print the error message *s*.
- name: builtins.add
  summary: Return the sum of the numbers e1 and e2
  description: |-
    ## `builtins.add ``e1`` ``e2`

    Return the sum of the numbers *e1* and *e2*.
- name: builtins.all
  summary: Return true if the function pred returns true for all elements of list, and false otherwise
  description: |-
    ## `builtins.all ``pred`` ``list`

    Return `true` if the function *pred* returns `true` for all elements of *list*, and `false` otherwise.
- name: builtins.any
  summary: Return true if the function pred returns true for at least one element of list, and false otherwise
  description: |-
    ## `builtins.any ``pred`` ``list`

    Return `true` if the function *pred* returns `true` for at least one element of *list*, and `false` otherwise.
- name: builtins.attrNames
  summary: Return the names of the attributes in the set set in an alphabetically sorted list
  description: |-
    ## `builtins.attrNames ``set`

    Return the names of the attributes in the set *set* in an alphabetically sorted list. For instance, `builtins.attrNames { y = 1; x = "foo"; }` evaluates to `[ "x" "y" ]`.
- name: builtins.attrValues
  summary: Return the values of the attributes in the set set in the order corresponding to the sorted attribute names
  description: |-
    ## `builtins.attrValues ``set`

    Return the values of the attributes in the set *set* in the order corresponding to the sorted attribute names.
- name: builtins.baseNameOf
  summary: Return the base name of the string s, that is, everything following the final slash in the string
  description: |-
    ## `builtins.baseNameOf ``s`

    Return the *base name* of the string *s*, that is, everything following the final slash in the string. This is similar to the GNU `basename` command.
- name: builtins.bitAnd
  summary: Return the bitwise AND of the integers e1 and e2
  description: |-
    ## `builtins.bitAnd ``e1`` ``e2`

    Return the bitwise AND of the integers *e1* and *e2*.
- name: builtins.bitOr
  summary: Return the bitwise OR of the integers e1 and e2
  description: |-
    ## `builtins.bitOr ``e1`` ``e2`

    Return the bitwise OR of the integers *e1* and *e2*.
- name: builtins.bitXor
  summary: Return the bitwise XOR of the integers e1 and e2
  description: |-
    ## `builtins.bitXor ``e1`` ``e2`

    Return the bitwise XOR of the integers *e1* and *e2*.
- name: builtins.break
  summary: In debug mode (enabled using --debugger), pause Nix expression evaluation and enter the REPL
  description: |-
    ## `builtins.break ``v`

    In debug mode (enabled using `--debugger`), pause Nix expression evaluation and enter the REPL. Otherwise, return the argument `v`.
- name: builtins.catAttrs
  summary: Collect each attribute named attr from a list of attribute sets
  description: |-
    ## `builtins.catAttrs ``attr`` ``list`

    Collect each attribute named *attr* from a list of attribute sets. Attrsets that don't contain the named attribute are ignored. For example,

    ```
    builtins.catAttrs "a" [{a = 1;} {b = 0;} {a = 2;}]
    ```

    evaluates to `[1 2]`.
- name: builtins.ceil
  summary: Converts an IEEE-754 double-precision floating-point number (double) to the next higher integer
  description: |-
    ## `builtins.ceil ``double`

    Converts an IEEE-754 double-precision floating-point number (*double*) to the next higher integer.

    If the datatype is neither an integer nor a "float", an evaluation error will be thrown.
- name: builtins.compareVersions
  summary: Compare two strings representing versions and return -1 if version s1 is older than version s2, 0 if they are the same, and 1 if s1 is newer than s2
  description: |-
    ## `builtins.compareVersions ``s1`` ``s2`

    Compare two strings representing versions and return `-1` if version *s1* is older than version *s2*, `0` if they are the same, and `1` if *s1* is newer than *s2*. The version comparison algorithm is the same as the one used by [`nix-env -u`](https://nixos.org/manual/nix/stable/command-ref/nix-env.html#operation---upgrade).
- name: builtins.concatLists
  summary: Concatenate a list of lists into a single list
  description: |-
    ## `builtins.concatLists ``lists`

    Concatenate a list of lists into a single list.
- name: builtins.concatMap
  summary: This function is equivalent to builtins.concatLists (map f list) but is more efficient
  description: |-
    ## `builtins.concatMap ``f`` ``list`

    This function is equivalent to `builtins.concatLists (map f list)` but is more efficient.
- name: builtins.concatStringsSep
  summary: Concatenate a list of strings with a separator between each element, e.g
  description: |-
    ## `builtins.concatStringsSep ``separator`` ``list`

    Concatenate a list of strings with a separator between each element, e.g. `concatStringsSep "/" ["usr" "local" "bin"] == "usr/local/bin"`.
- name: builtins.deepSeq
  summary: 'This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are also evaluated recursively'
  description: |-
    ## `builtins.deepSeq ``e1`` ``e2`

    This is like `seq e1 e2`, except that *e1* is evaluated *deeply*: if it’s a list or set, its elements or attributes are also evaluated recursively.
- name: builtins.dirOf
  summary: Return the directory part of the string s, that is, everything before the final slash in the string
  description: |-
    ## `builtins.dirOf ``s`

    Return the directory part of the string *s*, that is, everything before the final slash in the string. This is similar to the GNU `dirname` command.
- name: builtins.div
  summary: Return the quotient of the numbers e1 and e2
  description: |-
    ## `builtins.div ``e1`` ``e2`

    Return the quotient of the numbers *e1* and *e2*.
- name: builtins.elem
  summary: Return true if a value equal to x occurs in the list xs, and false otherwise
  description: |-
    ## `builtins.elem ``x`` ``xs`

    Return `true` if a value equal to *x* occurs in the list *xs*, and `false` otherwise.
- name: builtins.elemAt
  summary: Return element n from the list xs
  description: |-
    ## `builtins.elemAt ``xs`` ``n`

    Return element *n* from the list *xs*. Elements are counted starting from 0. A fatal error occurs if the index is out of bounds.
- name: builtins.fetchClosure
  summary: Fetch a Nix store closure from a binary cache, rewriting it into content-addressed form
  description: |-
    ## `builtins.fetchClosure ``args`

    Fetch a Nix store closure from a binary cache, rewriting it into content-addressed form. For example,

    ```
    builtins.fetchClosure {
      fromStore = "https://cache.nixos.org";
      fromPath = /nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1;
      toPath = /nix/store/ldbhlwhh39wha58rm61bkiiwm6j7211j-git-2.33.1;
    }
    ```

    fetches `/nix/store/r2jd...` from the specified binary cache, and rewrites it into the content-addressed store path `/nix/store/ldbh...`.

    If `fromPath` is already content-addressed, or if you are allowing impure evaluation (`--impure`), then `toPath` may be omitted.

    To find out the correct value for `toPath` given a `fromPath`, you can use `nix store make-content-addressed`:

        # nix store make-content-addressed --from https://cache.nixos.org /nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1
        rewrote '/nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1' to '/nix/store/ldbhlwhh39wha58rm61bkiiwm6j7211j-git-2.33.1'

    This function is similar to `builtins.storePath` in that it allows you to use a previously built store path in a Nix expression. However, it is more reproducible because it requires specifying a binary cache from which the path can be fetched. Also, requiring a content-addressed final store path avoids the need for users to configure binary cache public keys.

    This function is only available if you enable the experimental feature `fetch-closure`.
- name: builtins.fetchGit
  summary: Fetch a path from git
  description: "## `builtins.fetchGit ``args`\n\nFetch a path from git. *args* can be a URL, in which case the HEAD of the repo at that URL is fetched. Otherwise, it can be an attribute with the following attributes (all except `url` optional):\n\n- url  \n  The URL of the repo.\n\n- name  \n  The name of the directory the repo should be exported to in the store. Defaults to the basename of the URL.\n\n- rev  \n  The git revision to fetch. Defaults to the tip of `ref`.\n\n- ref  \n  The git ref to look for the requested revision under. This is often a branch or tag name. Defaults to `HEAD`.\n\n  By default, the `ref` value is prefixed with `refs/heads/`. As of Nix 2.3.0 Nix will not prefix `refs/heads/` if `ref` starts with `refs/`.\n\n- submodules  \n  A Boolean parameter that specifies whether submodules should be checked out. Defaults to `false`.\n\n- shallow  \n  A Boolean parameter that specifies whether fetching a shallow clone is allowed. Defaults to `false`.\n\n- allRefs  \n  Whether to fetch all refs of the repository. With this argument being true, it's possible to load a `rev` from *any* `ref` (by default only `rev`s from the specified `ref` are supported).\n\nHere are some examples of how to use `fetchGit`.\n\n- To fetch a private repository over SSH:\n\n  ```\n  builtins.fetchGit {\n    url = \"git@github.com:my-secret/repository.git\";\n    ref = \"master\";\n    rev = \"adab8b916a45068c044658c4158d81878f9ed1c3\";\n  }\n  ```\n\n- To fetch an arbitrary reference:\n\n  ```\n  builtins.fetchGit {\n    url = \"https://github.com/NixOS/nix.git\";\n    ref = \"refs/heads/0.5-release\";\n  }\n  ```\n\n- If the revision you're looking for is in the default branch of the git repository you don't strictly need to specify the branch name in the `ref` attribute.\n\n  However, if the revision you're looking for is in a future branch for the non-default branch you will need to specify the the `ref` attribute as well.\n\n  ```\n  builtins.fetchGit {\n    url = \"https://github.com/nixos/nix.git\";\n    rev = \"841fcbd04755c7a2865c51c1e2d3b045976b7452\";\n    ref = \"1.11-maintenance\";\n  }\n  ```\n\n  > **Note**\n  >\n  > It is nice to always specify the branch which a revision belongs to. Without the branch being specified, the fetcher might fail if the default branch changes. Additionally, it can be confusing to try a commit from a non-default branch and see the fetch fail. If the branch is specified the fault is much more obvious.\n\n- If the revision you're looking for is in the default branch of the git repository you may omit the `ref` attribute.\n\n  ```\n  builtins.fetchGit {\n    url = \"https://github.com/nixos/nix.git\";\n    rev = \"841fcbd04755c7a2865c51c1e2d3b045976b7452\";\n  }\n  ```\n\n- To fetch a specific tag:\n\n  ```\n  builtins.fetchGit {\n    url = \"https://github.com/nixos/nix.git\";\n    ref = \"refs/tags/1.9\";\n  }\n  ```\n\n- To fetch the latest version of a remote branch:\n\n  ```\n  builtins.fetchGit {\n    url = \"ssh://git@github.com/nixos/nix.git\";\n    ref = \"master\";\n  }\n  ```\n\n  > **Note**\n  >\n  > Nix will refetch the branch in accordance with the option `tarball-ttl`.\n\n  > **Note**\n  >\n  > This behavior is disabled in *Pure evaluation mode*."
- name: builtins.fetchTarball
  summary: Download the specified URL, unpack it and return the path of the unpacked tree
  description: |-
    ## `builtins.fetchTarball ``args`

    Download the specified URL, unpack it and return the path of the unpacked tree. The file must be a tape archive (`.tar`) compressed with `gzip`, `bzip2` or `xz`. The top-level path component of the files in the tarball is removed, so it is best if the tarball contains a single directory at top level. The typical use of the function is to obtain external Nix expression dependencies, such as a particular version of Nixpkgs, e.g.

    ```
    with import (fetchTarball https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz) {};

    stdenv.mkDerivation { … }
    ```

    The fetched tarball is cached for a certain amount of time (1 hour by default) in `~/.cache/nix/tarballs/`. You can change the cache timeout either on the command line with `--tarball-ttl` *number-of-seconds* or in the Nix configuration file by adding the line `tarball-ttl = ` *number-of-seconds*.

    Note that when obtaining the hash with `nix-prefetch-url` the option `--unpack` is required.

    This function can also verify the contents against a hash. In that case, the function takes a set instead of a URL. The set requires the attribute `url` and the attribute `sha256`, e.g.

    ```
    with import (fetchTarball {
      url = "https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz";
      sha256 = "1jppksrfvbk5ypiqdz4cddxdl8z6zyzdb2srq8fcffr327ld5jj2";
    }) {};

    stdenv.mkDerivation { … }
    ```

    This function is not available if [restricted evaluation mode](https://nixos.org/manual/nix/stable/command-ref/conf-file.html) is enabled.
- name: builtins.fetchurl
  summary: Download the specified URL and return the path of the downloaded file
  description: |-
    ## `builtins.fetchurl ``url`

    Download the specified URL and return the path of the downloaded file. This function is not available if [restricted evaluation mode](https://nixos.org/manual/nix/stable/command-ref/conf-file.html) is enabled.
- name: builtins.filter
  summary: Return a list consisting of the elements of list for which the function f returns true
  description: |-
    ## `builtins.filter ``f`` ``list`

    Return a list consisting of the elements of *list* for which the function *f* returns `true`.
- name: builtins.filterSource
  summary: filterSource should not be used to filter store paths
  description: |-
    ## `builtins.filterSource ``e1`` ``e2`

    > **Warning**
    >
    > `filterSource` should not be used to filter store paths. Since `filterSource` uses the name of the input directory while naming the output directory, doing so will produce a directory name in the form of `<hash2>-<hash>-<name>`, where `<hash>-<name>` is the name of the input directory. Since `<hash>` depends on the unfiltered directory, the name of the output directory will indirectly depend on files that are filtered out by the function. This will trigger a rebuild even when a filtered out file is changed. Use `builtins.path` instead, which allows specifying the name of the output directory.

    This function allows you to copy sources into the Nix store while filtering certain files. For instance, suppose that you want to use the directory `source-dir` as an input to a Nix expression, e.g.

    ```
    stdenv.mkDerivation {
      ...
      src = ./source-dir;
    }
    ```

    However, if `source-dir` is a Subversion working copy, then all those annoying `.svn` subdirectories will also be copied to the store. Worse, the contents of those directories may change a lot, causing lots of spurious rebuilds. With `filterSource` you can filter out the `.svn` directories:

    ```
    src = builtins.filterSource
      (path: type: type != "directory" || baseNameOf path != ".svn")
      ./source-dir;
    ```

    Thus, the first argument *e1* must be a predicate function that is called for each regular file, directory or symlink in the source tree *e2*. If the function returns `true`, the file is copied to the Nix store, otherwise it is omitted. The function is called with two arguments. The first is the full path of the file. The second is a string that identifies the type of the file, which is either `"regular"`, `"directory"`, `"symlink"` or `"unknown"` (for other kinds of files such as device nodes or fifos — but note that those cannot be copied to the Nix store, so if the predicate returns `true` for them, the copy will fail). If you exclude a directory, the entire corresponding subtree of *e2* will be excluded.
- name: builtins.floor
  summary: Converts an IEEE-754 double-precision floating-point number (double) to the next lower integer
  description: |-
    ## `builtins.floor ``double`

    Converts an IEEE-754 double-precision floating-point number (*double*) to the next lower integer.

    If the datatype is neither an integer nor a "float", an evaluation error will be thrown.
- name: builtins.foldl'
  summary: Reduce a list by applying a binary operator, from left to right, e.g
  description: |-
    ## `builtins.foldl' ``op`` ``nul`` ``list`

    Reduce a list by applying a binary operator, from left to right, e.g. `foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2) ...`. The operator is applied strictly, i.e., its arguments are evaluated first. For example, `foldl' (x: y: x + y) 0 [1 2 3]` evaluates to 6.
- name: builtins.fromJSON
  summary: Convert a JSON string to a Nix value
  description: |-
    ## `builtins.fromJSON ``e`

    Convert a JSON string to a Nix value. For example,

    ```
    builtins.fromJSON ''{"x": [1, 2, 3], "y": null}''
    ```

    returns the value `{ x = [ 1 2 3 ]; y = null; }`.
- name: builtins.functionArgs
  summary: Return a set containing the names of the formal arguments expected by the function f
  description: |-
    ## `builtins.functionArgs ``f`

    Return a set containing the names of the formal arguments expected by the function *f*. The value of each attribute is a Boolean denoting whether the corresponding argument has a default value. For instance, `functionArgs ({ x, y ? 123}: ...) = { x = false; y = true; }`.

    "Formal argument" here refers to the attributes pattern-matched by the function. Plain lambdas are not included, e.g. `functionArgs (x: ...) = { }`.
- name: builtins.genericClosure
  summary: Take an attrset with values named startSet and operator in order to return a list of attrsets by starting with the startSet, recursively applying the operator function to each element
  description: |-
    ## `builtins.genericClosure ``attrset`

    Take an *attrset* with values named `startSet` and `operator` in order to return a *list of attrsets* by starting with the `startSet`, recursively applying the `operator` function to each element. The *attrsets* in the `startSet` and produced by the `operator` must each contain value named `key` which are comparable to each other. The result is produced by repeatedly calling the operator for each element encountered with a unique key, terminating when no new elements are produced. For example,

        builtins.genericClosure {
          startSet = [ {key = 5;} ];
          operator = item: [{
            key = if (item.key / 2 ) * 2 == item.key
                 then item.key / 2
                 else 3 * item.key + 1;
          }];
        }

    evaluates to

        [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ]
- name: builtins.genList
  summary: Generate list of size length, with each element i equal to the value returned by generator i
  description: |-
    ## `builtins.genList ``generator`` ``length`

    Generate list of size *length*, with each element *i* equal to the value returned by *generator* `i`. For example,

    ```
    builtins.genList (x: x * x) 5
    ```

    returns the list `[ 0 1 4 9 16 ]`.
- name: builtins.getAttr
  summary: getAttr returns the attribute named s from set
  description: |-
    ## `builtins.getAttr ``s`` ``set`

    `getAttr` returns the attribute named *s* from *set*. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the `.` operator, since *s* is an expression rather than an identifier.
- name: builtins.getEnv
  summary: getEnv returns the value of the environment variable s, or an empty string if the variable doesn’t exist
  description: |-
    ## `builtins.getEnv ``s`

    `getEnv` returns the value of the environment variable *s*, or an empty string if the variable doesn’t exist. This function should be used with care, as it can introduce all sorts of nasty environment dependencies in your Nix expression.

    `getEnv` is used in Nix Packages to locate the file `~/.nixpkgs/config.nix`, which contains user-local settings for Nix Packages. (That is, it does a `getEnv "HOME"` to locate the user’s home directory.)
- name: builtins.getFlake
  summary: Fetch a flake from a flake reference, and return its output attributes and some metadata
  description: |-
    ## `builtins.getFlake ``args`

    Fetch a flake from a flake reference, and return its output attributes and some metadata. For example:

    ```
    (builtins.getFlake "nix/55bc52401966fbffa525c574c14f67b00bc4fb3a").packages.x86_64-linux.nix
    ```

    Unless impure evaluation is allowed (`--impure`), the flake reference must be "locked", e.g. contain a Git revision or content hash. An example of an unlocked usage is:

    ```
    (builtins.getFlake "github:edolstra/dwarffs").rev
    ```

    This function is only available if you enable the experimental feature `flakes`.
- name: builtins.groupBy
  summary: Groups elements of list together by the string returned from the function f called on each element
  description: |-
    ## `builtins.groupBy ``f`` ``list`

    Groups elements of *list* together by the string returned from the function *f* called on each element. It returns an attribute set where each attribute value contains the elements of *list* that are mapped to the same corresponding attribute name returned by *f*.

    For example,

    ```
    builtins.groupBy (builtins.substring 0 1) ["foo" "bar" "baz"]
    ```

    evaluates to

    ```
    { b = [ "bar" "baz" ]; f = [ "foo" ]; }
    ```
- name: builtins.hasAttr
  summary: hasAttr returns true if set has an attribute named s, and false otherwise
  description: |-
    ## `builtins.hasAttr ``s`` ``set`

    `hasAttr` returns `true` if *set* has an attribute named *s*, and `false` otherwise. This is a dynamic version of the `?` operator, since *s* is an expression rather than an identifier.
- name: builtins.hashFile
  summary: Return a base-16 representation of the cryptographic hash of the file at path p
  description: |-
    ## `builtins.hashFile ``type`` ``p`

    Return a base-16 representation of the cryptographic hash of the file at path *p*. The hash algorithm specified by *type* must be one of `"md5"`, `"sha1"`, `"sha256"` or `"sha512"`.
- name: builtins.hashString
  summary: Return a base-16 representation of the cryptographic hash of string s
  description: |-
    ## `builtins.hashString ``type`` ``s`

    Return a base-16 representation of the cryptographic hash of string *s*. The hash algorithm specified by *type* must be one of `"md5"`, `"sha1"`, `"sha256"` or `"sha512"`.
- name: builtins.head
  summary: Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list
  description: |-
    ## `builtins.head ``list`

    Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether a list is empty by comparing it with `[]`.
- name: builtins.import
  summary: Load, parse and return the Nix expression in the file path
  description: |-
    ## `builtins.import ``path`

    Load, parse and return the Nix expression in the file *path*. If *path* is a directory, the file `default.nix` in that directory is loaded. Evaluation aborts if the file doesn’t exist or contains an incorrect Nix expression. `import` implements Nix’s module system: you can put any Nix expression (such as a set or a function) in a separate file, and use it from Nix expressions in other files.

    > **Note**
    >
    > Unlike some languages, `import` is a regular function in Nix. Paths using the angle bracket syntax (e.g., `import` *\<foo\>*) are [normal path values](https://nixos.org/manual/nix/stable/expressions/language-values.html).

    A Nix expression loaded by `import` must not contain any *free variables* (identifiers that are not defined in the Nix expression itself and are not built-in). Therefore, it cannot refer to variables that are in scope at the call site. For instance, if you have a calling expression

    ```
    rec {
      x = 123;
      y = import ./foo.nix;
    }
    ```

    then the following `foo.nix` will give an error:

    ```
    x + 456
    ```

    since `x` is not in scope in `foo.nix`. If you want `x` to be available in `foo.nix`, you should pass it as a function argument:

    ```
    rec {
      x = 123;
      y = import ./foo.nix x;
    }
    ```

    and

    ```
    x: x + 456
    ```

    (The function argument doesn’t have to be called `x` in `foo.nix`; any name would work.)
- name: builtins.intersectAttrs
  summary: Return a set consisting of the attributes in the set e2 that also exist in the set e1
  description: |-
    ## `builtins.intersectAttrs ``e1`` ``e2`

    Return a set consisting of the attributes in the set *e2* that also exist in the set *e1*.
- name: builtins.isAttrs
  summary: Return true if e evaluates to a set, and false otherwise
  description: |-
    ## `builtins.isAttrs ``e`

    Return `true` if *e* evaluates to a set, and `false` otherwise.
- name: builtins.isBool
  summary: Return true if e evaluates to a bool, and false otherwise
  description: |-
    ## `builtins.isBool ``e`

    Return `true` if *e* evaluates to a bool, and `false` otherwise.
- name: builtins.isFloat
  summary: Return true if e evaluates to a float, and false otherwise
  description: |-
    ## `builtins.isFloat ``e`

    Return `true` if *e* evaluates to a float, and `false` otherwise.
- name: builtins.isFunction
  summary: Return true if e evaluates to a function, and false otherwise
  description: |-
    ## `builtins.isFunction ``e`

    Return `true` if *e* evaluates to a function, and `false` otherwise.
- name: builtins.isInt
  summary: Return true if e evaluates to an integer, and false otherwise
  description: |-
    ## `builtins.isInt ``e`

    Return `true` if *e* evaluates to an integer, and `false` otherwise.
- name: builtins.isList
  summary: Return true if e evaluates to a list, and false otherwise
  description: |-
    ## `builtins.isList ``e`

    Return `true` if *e* evaluates to a list, and `false` otherwise.
- name: builtins.isNull
  summary: Return true if e evaluates to null, and false otherwise
  description: |-
    ## `builtins.isNull ``e`

    Return `true` if *e* evaluates to `null`, and `false` otherwise.

    > **Warning**
    >
    > This function is *deprecated*; just write `e == null` instead.
- name: builtins.isPath
  summary: Return true if e evaluates to a path, and false otherwise
  description: |-
    ## `builtins.isPath ``e`

    Return `true` if *e* evaluates to a path, and `false` otherwise.
- name: builtins.isString
  summary: Return true if e evaluates to a string, and false otherwise
  description: |-
    ## `builtins.isString ``e`

    Return `true` if *e* evaluates to a string, and `false` otherwise.
- name: builtins.length
  summary: Return the length of the list e
  description: |-
    ## `builtins.length ``e`

    Return the length of the list *e*.
- name: builtins.lessThan
  summary: Return true if the number e1 is less than the number e2, and false otherwise
  description: |-
    ## `builtins.lessThan ``e1`` ``e2`

    Return `true` if the number *e1* is less than the number *e2*, and `false` otherwise. Evaluation aborts if either *e1* or *e2* does not evaluate to a number.
- name: builtins.listToAttrs
  summary: Construct a set from a list specifying the names and values of each attribute
  description: |-
    ## `builtins.listToAttrs ``e`

    Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting of a string-valued attribute `name` specifying the name of the attribute, and an attribute `value` specifying its value. Example:

    ```
    builtins.listToAttrs
      [ { name = "foo"; value = 123; }
        { name = "bar"; value = 456; }
      ]
    ```

    evaluates to

    ```
    { foo = 123; bar = 456; }
    ```
- name: builtins.map
  summary: Apply the function f to each element in the list list
  description: |-
    ## `builtins.map ``f`` ``list`

    Apply the function *f* to each element in the list *list*. For example,

    ```
    map (x: "foo" + x) [ "bar" "bla" "abc" ]
    ```

    evaluates to `[ "foobar" "foobla" "fooabc" ]`.
- name: builtins.mapAttrs
  summary: Apply function f to every element of attrset
  description: |-
    ## `builtins.mapAttrs ``f`` ``attrset`

    Apply function *f* to every element of *attrset*. For example,

    ```
    builtins.mapAttrs (name: value: value * 10) { a = 1; b = 2; }
    ```

    evaluates to `{ a = 10; b = 20; }`.
- name: builtins.match
  summary: Returns a list if the extended POSIX regular expression regex matches str precisely, otherwise returns null
  description: |-
    ## `builtins.match ``regex`` ``str`

    Returns a list if the [extended POSIX regular expression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04) *regex* matches *str* precisely, otherwise returns `null`. Each item in the list is a regex group.

    ```
    builtins.match "ab" "abc"
    ```

    Evaluates to `null`.

    ```
    builtins.match "abc" "abc"
    ```

    Evaluates to `[ ]`.

    ```
    builtins.match "a(b)(c)" "abc"
    ```

    Evaluates to `[ "b" "c" ]`.

    ```
    builtins.match "[[:space:]]+([[:upper:]]+)[[:space:]]+" "  FOO   "
    ```

    Evaluates to `[ "FOO" ]`.
- name: builtins.mul
  summary: Return the product of the numbers e1 and e2
  description: |-
    ## `builtins.mul ``e1`` ``e2`

    Return the product of the numbers *e1* and *e2*.
- name: builtins.parseDrvName
  summary: Split the string s into a package name and version
  description: |-
    ## `builtins.parseDrvName ``s`

    Split the string *s* into a package name and version. The package name is everything up to but not including the first dash followed by a digit, and the version is everything following that dash. The result is returned in a set `{ name, version }`. Thus, `builtins.parseDrvName "nix-0.12pre12876"` returns `{ name = "nix"; version = "0.12pre12876"; }`.
- name: builtins.partition
  summary: Given a predicate function pred, this function returns an attrset containing a list named right, containing the elements in list for which pred returned true, and a list named wrong, containing the elements for which it returned false
  description: |-
    ## `builtins.partition ``pred`` ``list`

    Given a predicate function *pred*, this function returns an attrset containing a list named `right`, containing the elements in *list* for which *pred* returned `true`, and a list named `wrong`, containing the elements for which it returned `false`. For example,

    ```
    builtins.partition (x: x > 10) [1 23 9 3 42]
    ```

    evaluates to

    ```
    { right = [ 23 42 ]; wrong = [ 1 9 3 ]; }
    ```
- name: builtins.path
  summary: An enrichment of the built-in path type, based on the attributes present in args
  description: "## `builtins.path ``args`\n\nAn enrichment of the built-in path type, based on the attributes present in *args*. All are optional except `path`:\n\n- path  \n  The underlying path.\n\n- name  \n  The name of the path when added to the store. This can used to reference paths that have nix-illegal characters in their names, like `@`.\n\n- filter  \n  A function of the type expected by `builtins.filterSource`, with the same semantics.\n\n- recursive  \n  When `false`, when `path` is added to the store it is with a flat hash, rather than a hash of the NAR serialization of the file. Thus, `path` must refer to a regular file, not a directory. This allows similar behavior to `fetchurl`. Defaults to `true`.\n\n- sha256  \n  When provided, this is the expected hash of the file at the path. Evaluation will fail if the hash is incorrect, and providing a hash allows `builtins.path` to be used even when the `pure-eval` nix config option is on."
- name: builtins.pathExists
  summary: Return true if the path path exists at evaluation time, and false otherwise
  description: |-
    ## `builtins.pathExists ``path`

    Return `true` if the path *path* exists at evaluation time, and `false` otherwise.
- name: builtins.placeholder
  summary: Return a placeholder string for the specified output that will be substituted by the corresponding output path at build time
  description: |-
    ## `builtins.placeholder ``output`

    Return a placeholder string for the specified *output* that will be substituted by the corresponding output path at build time. Typical outputs would be `"out"`, `"bin"` or `"dev"`.
- name: builtins.readDir
  summary: Return the contents of the directory path as a set mapping directory entries to the corresponding file type
  description: |-
    ## `builtins.readDir ``path`

    Return the contents of the directory *path* as a set mapping directory entries to the corresponding file type. For instance, if directory `A` contains a regular file `B` and another directory `C`, then `builtins.readDir ./A` will return the set

    ```
    { B = "regular"; C = "directory"; }
    ```

    The possible values for the file type are `"regular"`, `"directory"`, `"symlink"` and `"unknown"`.
- name: builtins.readFile
  summary: Return the contents of the file path as a string
  description: |-
    ## `builtins.readFile ``path`

    Return the contents of the file *path* as a string.
- name: builtins.removeAttrs
  summary: Remove the attributes listed in list from set
  description: |-
    ## `builtins.removeAttrs ``set`` ``list`

    Remove the attributes listed in *list* from *set*. The attributes don’t have to exist in *set*. For instance,

    ```
    removeAttrs { x = 1; y = 2; z = 3; } [ "a" "x" "z" ]
    ```

    evaluates to `{ y = 2; }`.
- name: builtins.replaceStrings
  summary: Given string s, replace every occurrence of the strings in from with the corresponding string in to
  description: |-
    ## `builtins.replaceStrings ``from`` ``to`` ``s`

    Given string *s*, replace every occurrence of the strings in *from* with the corresponding string in *to*. For example,

    ```
    builtins.replaceStrings ["oo" "a"] ["a" "i"] "foobar"
    ```

    evaluates to `"fabir"`.
- name: builtins.seq
  summary: Evaluate e1, then evaluate and return e2
  description: |-
    ## `builtins.seq ``e1`` ``e2`

    Evaluate *e1*, then evaluate and return *e2*. This ensures that a computation is strict in the value of *e1*.
- name: builtins.sort
  summary: Return list in sorted order
  description: |-
    ## `builtins.sort ``comparator`` ``list`

    Return *list* in sorted order. It repeatedly calls the function *comparator* with two elements. The comparator should return `true` if the first element is less than the second, and `false` otherwise. For example,

    ```
    builtins.sort builtins.lessThan [ 483 249 526 147 42 77 ]
    ```

    produces the list `[ 42 77 147 249 483 526 ]`.

    This is a stable sort: it preserves the relative order of elements deemed equal by the comparator.
- name: builtins.split
  summary: Returns a list composed of non matched strings interleaved with the lists of the extended POSIX regular expression regex matches of str
  description: |-
    ## `builtins.split ``regex`` ``str`

    Returns a list composed of non matched strings interleaved with the lists of the [extended POSIX regular expression](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04) *regex* matches of *str*. Each item in the lists of matched sequences is a regex group.

    ```
    builtins.split "(a)b" "abc"
    ```

    Evaluates to `[ "" [ "a" ] "c" ]`.

    ```
    builtins.split "([ac])" "abc"
    ```

    Evaluates to `[ "" [ "a" ] "b" [ "c" ] "" ]`.

    ```
    builtins.split "(a)|(c)" "abc"
    ```

    Evaluates to `[ "" [ "a" null ] "b" [ null "c" ] "" ]`.

    ```
    builtins.split "([[:upper:]]+)" " FOO "
    ```

    Evaluates to `[ " " [ "FOO" ] " " ]`.
- name: builtins.splitVersion
  summary: Split a string representing a version into its components, by the same version splitting logic underlying the version comparison in nix-env -u
  description: |-
    ## `builtins.splitVersion ``s`

    Split a string representing a version into its components, by the same version splitting logic underlying the version comparison in [`nix-env -u`](https://nixos.org/manual/nix/stable/command-ref/nix-env.html#operation---upgrade).
- name: builtins.storePath
  summary: This function allows you to define a dependency on an already existing store path
  description: |-
    ## `builtins.storePath ``path`

    This function allows you to define a dependency on an already existing store path. For example, the derivation attribute `src = builtins.storePath /nix/store/f1d18v1y…-source` causes the derivation to depend on the specified path, which must exist or be substitutable. Note that this differs from a plain path (e.g. `src = /nix/store/f1d18v1y…-source`) in that the latter causes the path to be *copied* again to the Nix store, resulting in a new path (e.g. `/nix/store/ld01dnzc…-source-source`).

    This function is not available in pure evaluation mode.
- name: builtins.stringLength
  summary: Return the length of the string e
  description: |-
    ## `builtins.stringLength ``e`

    Return the length of the string *e*. If *e* is not a string, evaluation is aborted.
- name: builtins.sub
  summary: Return the difference between the numbers e1 and e2
  description: |-
    ## `builtins.sub ``e1`` ``e2`

    Return the difference between the numbers *e1* and *e2*.
- name: builtins.substring
  summary: Return the substring of s from character position start (zero-based) up to but not including start + len
  description: |-
    ## `builtins.substring ``start`` ``len`` ``s`

    Return the substring of *s* from character position *start* (zero-based) up to but not including *start + len*. If *start* is greater than the length of the string, an empty string is returned, and if *start + len* lies beyond the end of the string, only the substring up to the end of the string is returned. *start* must be non-negative. For example,

    ```
    builtins.substring 0 3 "nixos"
    ```

    evaluates to `"nix"`.
- name: builtins.tail
  summary: Return the second to last elements of a list; abort evaluation if the argument isn’t a list or is an empty list
  description: |-
    ## `builtins.tail ``list`

    Return the second to last elements of a list; abort evaluation if the argument isn’t a list or is an empty list.

    > **Warning**
    >
    > This function should generally be avoided since it's inefficient: unlike Haskell's `tail`, it takes O(n) time, so recursing over a list by repeatedly calling `tail` takes O(n^2) time.
- name: builtins.throw
  summary: Throw an error message s
  description: |-
    ## `builtins.throw ``s`

    Throw an error message *s*. This usually aborts Nix expression evaluation, but in `nix-env -qa` and other commands that try to evaluate a set of derivations to get information about those derivations, a derivation that throws an error is silently skipped (which is not the case for `abort`).
- name: builtins.toFile
  summary: Store the string s in a file in the Nix store and return its path
  description: |-
    ## `builtins.toFile ``name`` ``s`

    Store the string *s* in a file in the Nix store and return its path. The file has suffix *name*. This file can be used as an input to derivations. One application is to write builders “inline”. For instance, the following Nix expression combines the [Nix expression for GNU Hello](https://nixos.org/manual/nix/stable/expressions/expression-syntax.html) and its [build script](https://nixos.org/manual/nix/stable/expressions/build-script.html) into one file:

    ```
    { stdenv, fetchurl, perl }:

    stdenv.mkDerivation {
      name = "hello-2.1.1";

      builder = builtins.toFile "builder.sh" "
        source $stdenv/setup

        PATH=$perl/bin:$PATH

        tar xvfz $src
        cd hello-*
        ./configure --prefix=$out
        make
        make install
      ";

      src = fetchurl {
        url = "http://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz";
        sha256 = "1md7jsfd8pa45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465";
      };
      inherit perl;
    }
    ```

    It is even possible for one file to refer to another, e.g.,

    ```
    builder = let
      configFile = builtins.toFile "foo.conf" "
        # This is some dummy configuration file.
        ...
      ";
    in builtins.toFile "builder.sh" "
      source $stdenv/setup
      ...
      cp ${configFile} $out/etc/foo.conf
    ";
    ```

    Note that `${configFile}` is an [antiquotation](https://nixos.org/manual/nix/stable/expressions/language-values.html), so the result of the expression `configFile` (i.e., a path like `/nix/store/m7p7jfny445k...-foo.conf`) will be spliced into the resulting string.

    It is however *not* allowed to have files mutually referring to each other, like so:

    ```
    let
      foo = builtins.toFile "foo" "...${bar}...";
      bar = builtins.toFile "bar" "...${foo}...";
    in foo
    ```

    This is not allowed because it would cause a cyclic dependency in the computation of the cryptographic hashes for `foo` and `bar`.

    It is also not possible to reference the result of a derivation. If you are using Nixpkgs, the `writeTextFile` function is able to do that.
- name: builtins.toJSON
  summary: Return a string containing a JSON representation of e
  description: |-
    ## `builtins.toJSON ``e`

    Return a string containing a JSON representation of *e*. Strings, integers, floats, booleans, nulls and lists are mapped to their JSON equivalents. Sets (except derivations) are represented as objects. Derivations are translated to a JSON string containing the derivation’s output path. Paths are copied to the store and represented as a JSON string of the resulting store path.
- name: builtins.toPath
  summary: DEPRECATED
  description: |-
    ## `builtins.toPath ``s`

    **DEPRECATED.** Use `/. + "/path"` to convert a string into an absolute path. For relative paths, use `./. + "/path"`.
- name: builtins.toString
  summary: Convert the expression e to a string
  description: |-
    ## `builtins.toString ``e`

    Convert the expression *e* to a string. *e* can be:

    - A string (in which case the string is returned unmodified).

    - A path (e.g., `toString /foo/bar` yields `"/foo/bar"`.

    - A set containing `{ __toString = self: ...; }` or `{ outPath = ...; }`.

    - An integer.

    - A list, in which case the string representations of its elements are joined with spaces.

    - A Boolean (`false` yields `""`, `true` yields `"1"`).

    - `null`, which yields the empty string.
- name: builtins.toXML
  summary: Return a string containing an XML representation of e
  description: |-
    ## `builtins.toXML ``e`

    Return a string containing an XML representation of *e*. The main application for `toXML` is to communicate information with the builder in a more structured format than plain environment variables.

    Here is an example where this is the case:

    ```
    { stdenv, fetchurl, libxslt, jira, uberwiki }:

    stdenv.mkDerivation (rec {
      name = "web-server";

      buildInputs = [ libxslt ];

      builder = builtins.toFile "builder.sh" "
        source $stdenv/setup
        mkdir $out
        echo "$servlets" | xsltproc ${stylesheet} - > $out/server-conf.xml ①
      ";

      stylesheet = builtins.toFile "stylesheet.xsl" ②
       "<?xml version='1.0' encoding='UTF-8'?>
        <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>
          <xsl:template match='/'>
            <Configure>
              <xsl:for-each select='/expr/list/attrs'>
                <Call name='addWebApplication'>
                  <Arg><xsl:value-of select=\"attr[@name = 'path']/string/@value\" /></Arg>
                  <Arg><xsl:value-of select=\"attr[@name = 'war']/path/@value\" /></Arg>
                </Call>
              </xsl:for-each>
            </Configure>
          </xsl:template>
        </xsl:stylesheet>
      ";

      servlets = builtins.toXML [ ③
        { path = "/bugtracker"; war = jira + "/lib/atlassian-jira.war"; }
        { path = "/wiki"; war = uberwiki + "/uberwiki.war"; }
      ];
    })
    ```

    The builder is supposed to generate the configuration file for a [Jetty servlet container](http://jetty.mortbay.org/). A servlet container contains a number of servlets (`*.war` files) each exported under a specific URI prefix. So the servlet configuration is a list of sets containing the `path` and `war` of the servlet (①). This kind of information is difficult to communicate with the normal method of passing information through an environment variable, which just concatenates everything together into a string (which might just work in this case, but wouldn’t work if fields are optional or contain lists themselves). Instead the Nix expression is converted to an XML representation with `toXML`, which is unambiguous and can easily be processed with the appropriate tools. For instance, in the example an XSLT stylesheet (at point ②) is applied to it (at point ①) to generate the XML configuration file for the Jetty server. The XML representation produced at point ③ by `toXML` is as follows:

    ```
    <?xml version='1.0' encoding='utf-8'?>
    <expr>
      <list>
        <attrs>
          <attr name="path">
            <string value="/bugtracker" />
          </attr>
          <attr name="war">
            <path value="/nix/store/d1jh9pasa7k2...-jira/lib/atlassian-jira.war" />
          </attr>
        </attrs>
        <attrs>
          <attr name="path">
            <string value="/wiki" />
          </attr>
          <attr name="war">
            <path value="/nix/store/y6423b1yi4sx...-uberwiki/uberwiki.war" />
          </attr>
        </attrs>
      </list>
    </expr>
    ```

    Note that we used the `toFile` built-in to write the builder and the stylesheet “inline” in the Nix expression. The path of the stylesheet is spliced into the builder using the syntax `xsltproc ${stylesheet}`.
- name: builtins.trace
  summary: Evaluate e1 and print its abstract syntax representation on standard error
  description: |-
    ## `builtins.trace ``e1`` ``e2`

    Evaluate *e1* and print its abstract syntax representation on standard error. Then return *e2*. This function is useful for debugging.
- name: builtins.traceVerbose
  summary: Evaluate e1 and print its abstract syntax representation on standard error if --trace-verbose is enabled
  description: |-
    ## `builtins.traceVerbose ``e1`` ``e2`

    Evaluate *e1* and print its abstract syntax representation on standard error if `--trace-verbose` is enabled. Then return *e2*. This function is useful for debugging.
- name: builtins.tryEval
  summary: Try to shallowly evaluate e
  description: |-
    ## `builtins.tryEval ``e`

    Try to shallowly evaluate *e*. Return a set containing the attributes `success` (`true` if *e* evaluated successfully, `false` if an error was thrown) and `value`, equalling *e* if successful and `false` otherwise. `tryEval` will only prevent errors created by `throw` or `assert` from being thrown. Errors `tryEval` will not catch are for example those created by `abort` and type errors generated by builtins. Also note that this doesn't evaluate *e* deeply, so `let e = { x = throw ""; }; in (builtins.tryEval e).success` will be `true`. Using `builtins.deepSeq` one can get the expected result: `let e = { x = throw ""; }; in (builtins.tryEval (builtins.deepSeq e e)).success` will be `false`.
- name: builtins.typeOf
  summary: null
  description: |-
    ## `builtins.typeOf ``e`

    Return a string representing the type of the value *e*, namely `"int"`, `"bool"`, `"string"`, `"path"`, `"null"`, `"set"`, `"list"`, `"lambda"` or `"float"`.
- name: builtins.zipAttrsWith
  summary: Transpose a list of attribute sets into an attribute set of lists, then apply mapAttrs
  description: "## `builtins.zipAttrsWith ``f`` ``list`\n\nTranspose a list of attribute sets into an attribute set of lists, then apply `mapAttrs`.\n\n`f` receives two arguments: the attribute name and a non-empty list of all values encountered for that attribute name.\n\nThe result is an attribute set where the attribute names are the union of the attribute names in each element of `list`. The attribute values are the return values of `f`.\n\n```\nbuiltins.zipAttrsWith\n  (name: values: { inherit name values; })\n  [ { a = \"x\"; } { a = \"y\"; b = \"z\"; } ]\n```\n\nevaluates to\n\n    {\n      a = { name = \"a\"; values = [ \"x\" \"y\" ]; };\n      b = { name = \"b\"; values = [ \"z\" ]; };\n    }\n\n© 2022 NixOS Contributors  \nLicensed under the LGPL License.  \n[https://nixos.org/manual/nix/stable/expressions/builtins.html](https://nixos.org/manual/nix/stable/expressions/builtins.html)"
- name: lib.asserts.assertMsg
  summary: Print a trace message if pred is false
  description: "## `lib.asserts.assertMsg`\n\n##### `assertMsg :: Bool -> String -> Bool`\n\nLocated at [lib/asserts.nix:19](https://github.com/NixOS/nixpkgs/blob/master/lib/asserts.nix#L19) in `<nixpkgs>`.\n\nPrint a trace message if `pred` is false.\n\nIntended to be used to augment asserts with helpful error messages.\n\n `pred`  \nCondition under which the `msg` should *not* be printed.\n\n `msg`  \nMessage to print.\n\n**Example: Printing when the predicate is false**\n\n``` programlisting\nassert lib.asserts.assertMsg (\"foo\" == \"bar\") \"foo is not bar, silly\"\nstderr> trace: foo is not bar, silly\nstderr> assert failed\n```"
- name: lib.asserts.assertOneOf
  summary: Specialized asserts.assertMsg for checking if val is one of the elements of xs
  description: "## `lib.asserts.assertOneOf`\n\n##### `assertOneOf :: String -> String -> StringList -> Bool`\n\nLocated at [lib/asserts.nix:36](https://github.com/NixOS/nixpkgs/blob/master/lib/asserts.nix#L36) in `<nixpkgs>`.\n\nSpecialized `asserts.assertMsg` for checking if `val` is one of the elements of `xs`. Useful for checking enums.\n\n `name`  \nThe name of the variable the user entered `val` into, for inclusion in the error message.\n\n `val`  \nThe value of what the user provided, to be compared against the values in `xs`.\n\n `xs`  \nThe list of valid values.\n\n**Example: Ensuring a user provided a possible value**\n\n``` programlisting\nlet sslLibrary = \"bearssl\";\nin lib.asserts.assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"libressl\" ];\n=> false\nstderr> trace: sslLibrary must be one of \"openssl\", \"libressl\", but is: \"bearssl\"\n        \n```"
- name: lib.attrset.attrByPath
  summary: Return an attribute from within nested attribute sets
  description: "## `lib.attrset.attrByPath`\n\n##### `attrByPath :: [String] -> Any -> AttrSet -> Any`\n\nLocated at [lib/attrsets.nix:24](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L24) in `<nixpkgs>`.\n\nReturn an attribute from within nested attribute sets.\n\n `attrPath`  \nA list of strings representing the path through the nested attribute set `set`.\n\n `default`  \nDefault value if `attrPath` does not resolve to an existing value.\n\n `set`  \nThe nested attributeset to select values from.\n\n**Example: Extracting a value from a nested attribute set**\n\n``` programlisting\nlet set = { a = { b = 3; }; };\nin lib.attrsets.attrByPath [ \"a\" \"b\" ] 0 set\n=> 3\n```\n\n  \n\n**Example: No value at the path, instead using the default**\n\n``` programlisting\nlib.attrsets.attrByPath [ \"a\" \"b\" ] 0 {}\n=> 0\n```"
- name: lib.attrsets.attrVals
  summary: Return the specified attributes from a set
  description: "## `lib.attrsets.attrVals`\n\n##### `attrVals :: [String] -> AttrSet -> [Any]`\n\nLocated at [lib/attrsets.nix:184](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L184) in `<nixpkgs>`.\n\nReturn the specified attributes from a set. All values must exist.\n\n `nameList`  \nThe list of attributes to fetch from `set`. Each attribute name must exist on the attrbitue set.\n\n `set`  \nThe set to get attribute values from.\n\n**Example: Getting several values from an attribute set**\n\n``` programlisting\nlib.attrsets.attrVals [ \"a\" \"b\" \"c\" ] { a = 1; b = 2; c = 3; }\n=> [ 1 2 3 ]\n```\n\n  \n\n**Example: Getting missing values from an attribute set**\n\n``` programlisting\nlib.attrsets.attrVals [ \"d\" ] { }\nerror: attribute 'd' missing\n```"
- name: lib.attrsets.attrValues
  summary: Get all the attribute values from an attribute set
  description: "## `lib.attrsets.attrValues`\n\n##### `attrValues :: AttrSet -> [Any]`\n\nLocated at [lib/attrsets.nix:194](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L194) in `<nixpkgs>`.\n\nGet all the attribute values from an attribute set.\n\nProvides a backwards-compatible interface of `builtins.attrValues` for Nix version older than 1.8.\n\n `attrs`  \nThe attribute set.\n\n**Example:**\n\n``` programlisting\nlib.attrsets.attrValues { a = 1; b = 2; c = 3; }\n=> [ 1 2 3 ]\n```"
- name: lib.attrsets.cartesianProductOfSets
  summary: Return the cartesian product of attribute set value combinations
  description: "## `lib.attrsets.cartesianProductOfSets`\n\n##### `cartesianProductOfSets :: AttrSet -> [ AttrSet ]`\n\nLocated at [lib/attrsets.nix:297](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L297) in `<nixpkgs>`.\n\nReturn the cartesian product of attribute set value combinations.\n\n `set`  \nAn attribute set with attributes that carry lists of values.\n\n**Example: Creating the cartesian product of a list of attribute values**\n\n``` programlisting\ncartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; }\n=> [\n     { a = 1; b = 10; }\n     { a = 1; b = 20; }\n     { a = 2; b = 10; }\n     { a = 2; b = 20; }\n   ]\n```"
- name: lib.attrsets.catAttrs
  summary: Collect each attribute named `attr' from the list of attribute sets, sets
  description: "## `lib.attrsets.catAttrs`\n\n##### `catAttrs :: String -> [AttrSet] -> [Any]`\n\nLocated at [lib/attrsets.nix:213](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L213) in `<nixpkgs>`.\n\nCollect each attribute named \\`attr' from the list of attribute sets, `sets`. Sets that don't contain the named attribute are ignored.\n\nProvides a backwards-compatible interface of `builtins.catAttrs` for Nix version older than 1.9.\n\n `attr`  \nAttribute name to select from each attribute set in `sets`.\n\n `sets`  \nThe list of attribute sets to select `attr` from.\n\n**Example: Collect an attribute from a list of attribute sets.**\n\nAttribute sets which don't have the attribute are ignored.\n\n``` programlisting\ncatAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}]\n=> [ 1 2 ]\n      \n```"
- name: lib.attrsets.collect
  summary: Recursively collect sets that verify a given predicate named pred from the set attrs
  description: "## `lib.attrsets.collect`\n\n##### `collect :: (Any -> Bool) -> AttrSet -> [Any]`\n\nLocated at [lib/attrsets.nix:278](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L278) in `<nixpkgs>`.\n\nRecursively collect sets that verify a given predicate named `pred` from the set `attrs`. The recursion stops when `pred` returns `true`.\n\n `pred`  \n`Any -> Bool`\n\nGiven an attribute's value, determine if recursion should stop.\n\n `value`  \nThe attribute set value.\n\n `attrs`  \nThe attribute set to recursively collect.\n\n**Example: Collecting all lists from an attribute set**\n\n``` programlisting\nlib.attrsets.collect isList { a = { b = [\"b\"]; }; c = [1]; }\n=> [[\"b\"] [1]]\n```\n\n  \n\n**Example: Collecting all attribute-sets which contain the outPath attribute name.**\n\n``` programlisting\ncollect (x: x ? outPath)\n  { a = { outPath = \"a/\"; }; b = { outPath = \"b/\"; }; }\n=> [{ outPath = \"a/\"; } { outPath = \"b/\"; }]\n```"
- name: lib.attrsets.filterAttrs
  summary: Filter an attribute set by removing all attributes for which the given predicate return false
  description: "## `lib.attrsets.filterAttrs`\n\n##### `filterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet`\n\nLocated at [lib/attrsets.nix:224](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L224) in `<nixpkgs>`.\n\nFilter an attribute set by removing all attributes for which the given predicate return false.\n\n `pred`  \n`String -> Any -> Bool`\n\nPredicate which returns true to include an attribute, or returns false to exclude it.\n\n `name`  \nThe attribute's name\n\n `value`  \nThe attribute's value\n\nReturns `true` to include the attribute, `false` to exclude the attribute.\n\n `set`  \nThe attribute set to filter\n\n**Example: Filtering an attributeset**\n\n``` programlisting\nfilterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; }\n=> { foo = 1; }\n```"
- name: lib.attrsets.filterAttrsRecursive
  summary: Filter an attribute set recursively by removing all attributes for which the given predicate return false
  description: "## `lib.attrsets.filterAttrsRecursive`\n\n##### `filterAttrsRecursive :: (String -> Any -> Bool) -> AttrSet -> AttrSet`\n\nLocated at [lib/attrsets.nix:235](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L235) in `<nixpkgs>`.\n\nFilter an attribute set recursively by removing all attributes for which the given predicate return false.\n\n `pred`  \n`String -> Any -> Bool`\n\nPredicate which returns true to include an attribute, or returns false to exclude it.\n\n `name`  \nThe attribute's name\n\n `value`  \nThe attribute's value\n\nReturns `true` to include the attribute, `false` to exclude the attribute.\n\n `set`  \nThe attribute set to filter\n\n**Example: Recursively filtering an attribute set**\n\n``` programlisting\nlib.attrsets.filterAttrsRecursive\n  (n: v: v != null)\n  {\n    levelA = {\n      example = \"hi\";\n      levelB = {\n        hello = \"there\";\n        this-one-is-present = {\n          this-is-excluded = null;\n        };\n      };\n      this-one-is-also-excluded = null;\n    };\n    also-excluded = null;\n  }\n=> {\n     levelA = {\n       example = \"hi\";\n       levelB = {\n         hello = \"there\";\n         this-one-is-present = { };\n       };\n     };\n   }\n     \n```"
- name: lib.attrsets.foldAttrs
  summary: Apply fold function to values grouped by key
  description: "## `lib.attrsets.foldAttrs`\n\n##### `foldAttrs :: (Any -> Any -> Any) -> Any -> [AttrSets] -> Any`\n\nLocated at [lib/attrsets.nix:254](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L254) in `<nixpkgs>`.\n\nApply fold function to values grouped by key.\n\n `op`  \n`Any -> Any -> Any`\n\nGiven a value `val` and a collector `col`, combine the two.\n\n `val`  \nAn attribute's value\n\n `col`  \nThe result of previous `op` calls with other values and `nul`.\n\n `nul`  \nThe null-value, the starting value.\n\n `list_of_attrs`  \nA list of attribute sets to fold together by key.\n\n**Example: Combining an attribute of lists in to one attribute set**\n\n``` programlisting\nlib.attrsets.foldAttrs\n  (n: a: [n] ++ a) []\n  [\n    { a = 2; b = 7; }\n    { a = 3; }\n    { b = 6; }\n  ]\n=> { a = [ 2 3 ]; b = [ 7 6 ]; }\n```"
- name: lib.attrsets.genAttrs
  summary: Generate an attribute set by mapping a function over a list of attribute names
  description: "## `lib.attrsets.genAttrs`\n\n##### `genAttrs :: [ String ] -> (String -> Any) -> AttrSet`\n\nLocated at [lib/attrsets.nix:413](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L413) in `<nixpkgs>`.\n\nGenerate an attribute set by mapping a function over a list of attribute names.\n\n `names`  \nNames of values in the resulting attribute set.\n\n `f`  \n`String -> Any`\n\nTakes the name of the attribute and return the attribute's value.\n\n `name`  \nThe name of the attribute to generate a value for.\n\n**Example: Generate an attrset based on names only**\n\n``` programlisting\nlib.attrsets.genAttrs [ \"foo\" \"bar\" ] (name: \"x_${name}\")\n=> { foo = \"x_foo\"; bar = \"x_bar\"; }\n     \n```"
- name: lib.attrsets.getAttrFromPath
  summary: Like Section 5.1.2.1, “lib.attrset.attrByPath” except without a default, and it will throw if the value doesn't exist
  description: "## `lib.attrsets.getAttrFromPath`\n\n##### `getAttrFromPath :: [String] -> AttrSet -> Value`\n\nLocated at [lib/attrsets.nix:76](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L76) in `<nixpkgs>`.\n\nLike [Section 5.1.2.1, “`lib.attrset.attrByPath`”](#function-library-lib.attrsets.attrByPath \"5.1.2.1. lib.attrset.attrByPath\") except without a default, and it will throw if the value doesn't exist.\n\n `attrPath`  \nA list of strings representing the path through the nested attribute set `set`.\n\n `set`  \nThe nested attribute set to find the value in.\n\n**Example: Succesfully getting a value from an attribute set**\n\n``` programlisting\nlib.attrsets.getAttrFromPath [ \"a\" \"b\" ] { a = { b = 3; }; }\n=> 3\n```\n\n  \n\n**Example: Throwing after failing to get a value from an attribute set**\n\n``` programlisting\nlib.attrsets.getAttrFromPath [ \"x\" \"y\" ] { }\n=> error: cannot find attribute `x.y'\n```"
- name: lib.attrsets.hasAttrByPath
  summary: Determine if an attribute exists within a nested attribute set
  description: "## `lib.attrsets.hasAttrByPath`\n\n##### `hasAttrByPath :: [String] -> AttrSet -> Bool`\n\nLocated at [lib/attrsets.nix:42](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L42) in `<nixpkgs>`.\n\nDetermine if an attribute exists within a nested attribute set.\n\n `attrPath`  \nA list of strings representing the path through the nested attribute set `set`.\n\n `set`  \nThe nested attributeset to check.\n\n**Example: A nested value does exist inside a set**\n\n``` programlisting\nlib.attrsets.hasAttrByPath\n  [ \"a\" \"b\" \"c\" \"d\" ]\n  { a = { b = { c = { d = 123; }; }; }; }\n=> true\n```"
- name: lib.attrsets.isDerivation
  summary: Check whether the argument is a derivation
  description: "## `lib.attrsets.isDerivation`\n\n##### `isDerivation :: Any -> Bool`\n\nLocated at [lib/attrsets.nix:427](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L427) in `<nixpkgs>`.\n\nCheck whether the argument is a derivation. Any set with `{ type = \"derivation\"; }` counts as a derivation.\n\n `value`  \nThe value which is possibly a derivation.\n\n**Example: A package is a derivation**\n\n``` programlisting\nlib.attrsets.isDerivation (import <nixpkgs> {}).ruby\n=> true\n     \n```\n\n  \n\n**Example: Anything else is not a derivation**\n\n``` programlisting\nlib.attrsets.isDerivation \"foobar\"\n=> false\n     \n```"
- name: lib.attrsets.mapAttrs
  summary: Apply a function to each element in an attribute set, creating a new attribute set
  description: "## `lib.attrsets.mapAttrs`\n\nLocated at [lib/attrsets.nix:325](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L325) in `<nixpkgs>`.\n\nApply a function to each element in an attribute set, creating a new attribute set.\n\nProvides a backwards-compatible interface of `builtins.mapAttrs` for Nix version older than 2.1.\n\n `fn`  \n`String -> Any -> Any`\n\nGiven an attribute's name and value, return a new value.\n\n `name`  \nThe name of the attribute.\n\n `value`  \nThe attribute's value.\n\n**Example: Modifying each value of an attribute set**\n\n``` programlisting\nlib.attrsets.mapAttrs\n  (name: value: name + \"-\" + value)\n  { x = \"foo\"; y = \"bar\"; }\n=> { x = \"x-foo\"; y = \"y-bar\"; }\n```"
- name: lib.attrsets.mapAttrs'
  summary: Like mapAttrs, but allows the name of each attribute to be changed in addition to the value
  description: "## `lib.attrsets.mapAttrs'`\n\n##### `mapAttrs' :: (String -> Any -> { name = String; value = Any }) -> AttrSet -> AttrSet`\n\nLocated at [lib/attrsets.nix:339](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L339) in `<nixpkgs>`.\n\nLike `mapAttrs`, but allows the name of each attribute to be changed in addition to the value. The applied function should return both the new name and value as a `nameValuePair`.\n\n `fn`  \n`String -> Any -> { name = String; value = Any }`\n\nGiven an attribute's name and value, return a new [name value pair](#function-library-lib.attrsets.nameValuePair \"5.1.2.12. lib.attrsets.nameValuePair\").\n\n `name`  \nThe name of the attribute.\n\n `value`  \nThe attribute's value.\n\n `set`  \nThe attribute set to map over.\n\n**Example: Change the name and value of each attribute of an attribute set**\n\n``` programlisting\nlib.attrsets.mapAttrs' (name: value: lib.attrsets.nameValuePair (\"foo_\" + name) (\"bar-\" + value))\n   { x = \"a\"; y = \"b\"; }\n=> { foo_x = \"bar-a\"; foo_y = \"bar-b\"; }\n\n    \n```"
- name: lib.attrsets.mapAttrsRecursive
  summary: Like mapAttrs, except that it recursively applies itself to attribute sets
  description: "## `lib.attrsets.mapAttrsRecursive`\n\n##### `mapAttrsRecursive :: ([String] > Any -> Any) -> AttrSet -> AttrSet`\n\nLocated at [lib/attrsets.nix:372](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L372) in `<nixpkgs>`.\n\nLike `mapAttrs`, except that it recursively applies itself to attribute sets. Also, the first argument of the argument function is a *list* of the names of the containing attributes.\n\n `f`  \n`[ String ] -> Any -> Any`\n\nGiven a list of attribute names and value, return a new value.\n\n `name_path`  \nThe list of attribute names to this value.\n\nFor example, the `name_path` for the `example` string in the attribute set `{ foo = { bar = \"example\"; }; }` is `[ \"foo\" \"bar\" ]`.\n\n `value`  \nThe attribute's value.\n\n `set`  \nThe attribute set to recursively map over.\n\n**Example: A contrived example of using lib.attrsets.mapAttrsRecursive**\n\n``` programlisting\nmapAttrsRecursive\n  (path: value: concatStringsSep \"-\" (path ++ [value]))\n  {\n    n = {\n      a = \"A\";\n      m = {\n        b = \"B\";\n        c = \"C\";\n      };\n    };\n    d = \"D\";\n  }\n=> {\n     n = {\n       a = \"n-a-A\";\n       m = {\n         b = \"n-m-b-B\";\n         c = \"n-m-c-C\";\n       };\n     };\n     d = \"d-D\";\n   }\n    \n```"
- name: lib.attrsets.mapAttrsRecursiveCond
  summary: Like mapAttrsRecursive, but it takes an additional predicate function that tells it whether to recursive into an attribute set
  description: "## `lib.attrsets.mapAttrsRecursiveCond`\n\n##### `mapAttrsRecursiveCond :: (AttrSet -> Bool) -> ([ String ] -> Any -> Any) -> AttrSet -> AttrSet`\n\nLocated at [lib/attrsets.nix:393](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L393) in `<nixpkgs>`.\n\nLike `mapAttrsRecursive`, but it takes an additional predicate function that tells it whether to recursive into an attribute set. If it returns false, `mapAttrsRecursiveCond` does not recurse, but does apply the map function. It is returns true, it does recurse, and does not apply the map function.\n\n `cond`  \n`(AttrSet -> Bool)`\n\nDetermine if `mapAttrsRecursive` should recurse deeper in to the attribute set.\n\n `attributeset`  \nAn attribute set.\n\n `f`  \n`[ String ] -> Any -> Any`\n\nGiven a list of attribute names and value, return a new value.\n\n `name_path`  \nThe list of attribute names to this value.\n\nFor example, the `name_path` for the `example` string in the attribute set `{ foo = { bar = \"example\"; }; }` is `[ \"foo\" \"bar\" ]`.\n\n `value`  \nThe attribute's value.\n\n `set`  \nThe attribute set to recursively map over.\n\n**Example: Only convert attribute values to JSON if the containing attribute set is marked for recursion**\n\n``` programlisting\nlib.attrsets.mapAttrsRecursiveCond\n  ({ recurse ? false, ... }: recurse)\n  (name: value: builtins.toJSON value)\n  {\n    dorecur = {\n      recurse = true;\n      hello = \"there\";\n    };\n    dontrecur = {\n      converted-to- = \"json\";\n    };\n  }\n=> {\n     dorecur = {\n       hello = \"\\\"there\\\"\";\n       recurse = \"true\";\n     };\n     dontrecur = \"{\\\"converted-to\\\":\\\"json\\\"}\";\n   }\n    \n```"
- name: lib.attrsets.mapAttrsToList
  summary: Call fn for each attribute in the given set and return the result in a list
  description: "## `lib.attrsets.mapAttrsToList`\n\n##### `mapAttrsToList :: (String -> Any -> Any) -> AttrSet -> [Any]`\n\nLocated at [lib/attrsets.nix:355](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L355) in `<nixpkgs>`.\n\nCall `fn` for each attribute in the given `set` and return the result in a list.\n\n `fn`  \n`String -> Any -> Any`\n\nGiven an attribute's name and value, return a new value.\n\n `name`  \nThe name of the attribute.\n\n `value`  \nThe attribute's value.\n\n `set`  \nThe attribute set to map over.\n\n**Example: Combine attribute values and names in to a list**\n\n``` programlisting\nlib.attrsets.mapAttrsToList (name: value: \"${name}=${value}\")\n   { x = \"a\"; y = \"b\"; }\n=> [ \"x=a\" \"y=b\" ]\n```"
- name: lib.attrsets.nameValuePair
  summary: Utility function that creates a {name, value} pair as expected by builtins.listToAttrs
  description: "## `lib.attrsets.nameValuePair`\n\n##### `nameValuePair :: String -> Any -> AttrSet`\n\nLocated at [lib/attrsets.nix:312](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L312) in `<nixpkgs>`.\n\nUtility function that creates a `{name, value}` pair as expected by `builtins.listToAttrs`.\n\n `name`  \nThe attribute name.\n\n `value`  \nThe attribute value.\n\n**Example: Creating a name value pair**\n\n``` programlisting\nnameValuePair \"some\" 6\n=> { name = \"some\"; value = 6; }\n```"
- name: lib.attrsets.optionalAttrs
  summary: Conditionally return an attribute set or an empty attribute set
  description: "## `lib.attrsets.optionalAttrs`\n\n##### `optionalAttrs :: Bool -> AttrSet`\n\nLocated at [lib/attrsets.nix:453](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L453) in `<nixpkgs>`.\n\nConditionally return an attribute set or an empty attribute set.\n\n `cond`  \nCondition under which the `as` attribute set is returned.\n\n `as`  \nThe attribute set to return if `cond` is true.\n\n**Example: Return the provided attribute set when cond is true**\n\n``` programlisting\nlib.attrsets.optionalAttrs true { my = \"set\"; }\n=> { my = \"set\"; }\n     \n```\n\n  \n\n**Example: Return an empty attribute set when cond is false**\n\n``` programlisting\nlib.attrsets.optionalAttrs false { my = \"set\"; }\n=> { }\n     \n```"
- name: lib.attrsets.recurseIntoAttrs
  summary: Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc
  description: "## `lib.attrsets.recurseIntoAttrs`\n\n##### `recurseIntoAttrs :: AttrSet -> AttrSet`\n\nLocated at [lib/attrsets.nix:617](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L617) in `<nixpkgs>`.\n\nMake various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc.\n\nThis function only affects a single attribute set; it does not apply itself recursively for nested attribute sets.\n\n `attrs`  \nAn attribute set to scan for derivations.\n\n**Example: Making Nix look inside an attribute set**\n\n``` programlisting\n{ pkgs ? import <nixpkgs> {} }:\n{\n  myTools = pkgs.lib.recurseIntoAttrs {\n    inherit (pkgs) hello figlet;\n  };\n}\n```"
- name: lib.attrsets.recursiveUpdate
  summary: A recursive variant of the update operator //. The recursion stops when one of the attribute values is not an attribute set, in which case the right hand side value takes precedence over the left hand side value
  description: "## `lib.attrsets.recursiveUpdate`\n\n##### `recursiveUpdate :: AttrSet -> AttrSet -> AttrSet`\n\nLocated at [lib/attrsets.nix:547](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L547) in `<nixpkgs>`.\n\nA recursive variant of the update operator `//`. The recursion stops when one of the attribute values is not an attribute set, in which case the right hand side value takes precedence over the left hand side value.\n\n `lhs`  \nThe left hand attribute set of the merge.\n\n `rhs`  \nThe right hand attribute set of the merge.\n\n**Example: Recursively merging two attribute sets**\n\n``` programlisting\nrecursiveUpdate\n  {\n    boot.loader.grub.enable = true;\n    boot.loader.grub.device = \"/dev/hda\";\n  }\n  {\n    boot.loader.grub.device = \"\";\n  }\n=> {\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"\";\n}\n```"
- name: lib.attrsets.recursiveUpdateUntil
  summary: Does the same as the update operator // except that attributes are merged until the given predicate is verified
  description: "## `lib.attrsets.recursiveUpdateUntil`\n\n##### `recursiveUpdateUntil :: ( [ String ] -> AttrSet -> AttrSet -> Bool ) -> AttrSet -> AttrSet -> AttrSet`\n\nLocated at [lib/attrsets.nix:516](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L516) in `<nixpkgs>`.\n\nDoes the same as the update operator `//` except that attributes are merged until the given predicate is verified. The predicate should accept 3 arguments which are the path to reach the attribute, a part of the first attribute set and a part of the second attribute set. When the predicate is verified, the value of the first attribute set is replaced by the value of the second attribute set.\n\n `pred`  \n`[ String ] -> AttrSet -> AttrSet -> Bool`\n\n `path`  \nThe path to the values in the left and right hand sides.\n\n `l`  \nThe left hand side value.\n\n `r`  \nThe right hand side value.\n\n `lhs`  \nThe left hand attribute set of the merge.\n\n `rhs`  \nThe right hand attribute set of the merge.\n\n**Example: Recursively merging two attribute sets**\n\n``` programlisting\nlib.attrsets.recursiveUpdateUntil (path: l: r: path == [\"foo\"])\n  {\n    # first attribute set\n    foo.bar = 1;\n    foo.baz = 2;\n    bar = 3;\n  }\n  {\n    #second attribute set\n    foo.bar = 1;\n    foo.quz = 2;\n    baz = 4;\n  }\n=> {\n  foo.bar = 1; # 'foo.*' from the second set\n  foo.quz = 2; #\n  bar = 3;     # 'bar' from the first set\n  baz = 4;     # 'baz' from the second set\n}\n     \n```"
- name: lib.attrsets.setAttrByPath
  summary: Create a new attribute set with value set at the nested attribute location specified in attrPath
  description: "## `lib.attrsets.setAttrByPath`\n\n##### `setAttrByPath :: [String] -> Any -> AttrSet`\n\nLocated at [lib/attrsets.nix:57](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L57) in `<nixpkgs>`.\n\nCreate a new attribute set with `value` set at the nested attribute location specified in `attrPath`.\n\n `attrPath`  \nA list of strings representing the path through the nested attribute set.\n\n `value`  \nThe value to set at the location described by `attrPath`.\n\n**Example: Creating a new nested attribute set**\n\n``` programlisting\nlib.attrsets.setAttrByPath [ \"a\" \"b\" ] 3\n=> { a = { b = 3; }; }\n```"
- name: lib.attrsets.toDerivation
  summary: Converts a store path to a fake derivation
  description: "## `lib.attrsets.toDerivation`\n\n##### `toDerivation :: Path -> Derivation`\n\nLocated at [lib/attrsets.nix:430](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L430) in `<nixpkgs>`.\n\nConverts a store path to a fake derivation.\n\n `path`  \nA store path to convert to a derivation."
- name: lib.attrsets.zipAttrs
  summary: Merge sets of attributes and combine each attribute value in to a list
  description: "## `lib.attrsets.zipAttrs`\n\n##### `zipAttrs :: [ AttrSet ] -> AttrSet`\n\nLocated at [lib/attrsets.nix:486](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L486) in `<nixpkgs>`.\n\nMerge sets of attributes and combine each attribute value in to a list. Similar to [Section 5.1.2.23, “`lib.attrsets.zipAttrsWith`”](#function-library-lib.attrsets.zipAttrsWith \"5.1.2.23. lib.attrsets.zipAttrsWith\") where the merge function returns a list of all values.\n\n `sets`  \nA list of attribute sets to zip together.\n\n**Example: Combining a list of attribute sets**\n\n``` programlisting\nlib.attrsets.zipAttrs\n  [\n    { a = 1; b = 1; c = 1; }\n    { a = 10; }\n    { b = 100; }\n    { c = 1000; }\n  ]\n=> { a = [ 1 10 ]; b = [ 1 100 ]; c = [ 1 1000 ]; }\n     \n```"
- name: lib.attrsets.zipAttrsWith
  summary: Merge sets of attributes and use the function f to merge attribute values
  description: "## `lib.attrsets.zipAttrsWith`\n\n##### `zipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet`\n\nLocated at [lib/attrsets.nix:478](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L478) in `<nixpkgs>`.\n\nMerge sets of attributes and use the function `f` to merge attribute values. Similar to [Section 5.1.2.22, “`lib.attrsets.zipAttrsWithNames`”](#function-library-lib.attrsets.zipAttrsWithNames \"5.1.2.22. lib.attrsets.zipAttrsWithNames\") where all key names are passed for `names`.\n\n `f`  \n`(String -> [ Any ] -> Any`\n\nAccepts an attribute name, all the values, and returns a combined value.\n\n `name`  \nThe name of the attribute each value came from.\n\n `vs`  \nA list of values collected from the list of attribute sets.\n\n `sets`  \nA list of attribute sets to zip together.\n\n**Example: Summing a list of attribute sets of numbers**\n\n``` programlisting\nlib.attrsets.zipAttrsWith\n  (name: vals: \"${name} ${toString (builtins.foldl' (a: b: a + b) 0 vals)}\")\n  [\n    { a = 1; b = 1; c = 1; }\n    { a = 10; }\n    { b = 100; }\n    { c = 1000; }\n  ]\n=> { a = \"a 11\"; b = \"b 101\"; c = \"c 1001\"; }\n     \n```"
- name: lib.attrsets.zipAttrsWithNames
  summary: Merge sets of attributes and use the function f to merge attribute values where the attribute name is in names
  description: "## `lib.attrsets.zipAttrsWithNames`\n\n##### `zipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet`\n\nLocated at [lib/attrsets.nix:463](https://github.com/NixOS/nixpkgs/blob/master/lib/attrsets.nix#L463) in `<nixpkgs>`.\n\nMerge sets of attributes and use the function `f` to merge attribute values where the attribute name is in `names`.\n\n `names`  \nA list of attribute names to zip.\n\n `f`  \n`(String -> [ Any ] -> Any`\n\nAccepts an attribute name, all the values, and returns a combined value.\n\n `name`  \nThe name of the attribute each value came from.\n\n `vs`  \nA list of values collected from the list of attribute sets.\n\n `sets`  \nA list of attribute sets to zip together.\n\n**Example: Summing a list of attribute sets of numbers**\n\n``` programlisting\nlib.attrsets.zipAttrsWithNames\n  [ \"a\" \"b\" ]\n  (name: vals: \"${name} ${toString (builtins.foldl' (a: b: a + b) 0 vals)}\")\n  [\n    { a = 1; b = 1; c = 1; }\n    { a = 10; }\n    { b = 100; }\n    { c = 1000; }\n  ]\n=> { a = \"a 11\"; b = \"b 101\"; }\n     \n```"
- name: lib.debug.runTests
  summary: Evaluate a set of tests
  description: "## `lib.debug.runTests`\n\nEvaluate a set of tests. A test is an attribute set \\`{expr, expected}\\`, denoting an expression and its expected result. The result is a list of failed tests, each represented as \\`{name, expected, actual}\\`, denoting the attribute name of the failing test and its expected and actual results.\n\nUsed for regression testing of the functions in lib; see tests.nix for an example. Only tests having names starting with \"test\" are run.\n\nAdd attr { tests = \\[\"testName\"\\]; } to run these tests only.\n\n `tests`  \nTests to run\n\nLocated at [lib/debug.nix:188](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L188) in `<nixpkgs>`."
- name: lib.debug.testAllTrue
  summary: null
  description: "## `lib.debug.testAllTrue`\n\nCreate a test assuming that list elements are \\`true\\`.\n\n `expr`  \nFunction argument\n\n**Example: lib.debug.testAllTrue usage example**\n\n``` programlisting\n{ testX = allTrue [ true ]; }\n```\n\n  \n\nLocated at [lib/debug.nix:204](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L204) in `<nixpkgs>`."
- name: lib.debug.traceFnSeqN
  summary: This is useful for adding around a function call, to see the before/after of values as they are transformed
  description: "## `lib.debug.traceFnSeqN`\n\nTrace the input and output of a function \\`f\\` named \\`name\\`, both down to \\`depth\\`.\n\nThis is useful for adding around a function call, to see the before/after of values as they are transformed.\n\n `depth`  \nFunction argument\n\n `name`  \nFunction argument\n\n `f`  \nFunction argument\n\n `v`  \nFunction argument\n\n**Example: lib.debug.traceFnSeqN usage example**\n\n``` programlisting\ntraceFnSeqN 2 \"id\" (x: x) { a.b.c = 3; }\ntrace: { fn = \"id\"; from = { a.b = {…}; }; to = { a.b = {…}; }; }\n=> { a.b.c = 3; }\n```\n\n  \n\nLocated at [lib/debug.nix:162](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L162) in `<nixpkgs>`."
- name: lib.debug.traceIf
  summary: Conditionally trace the supplied message, based on a predicate
  description: "## `lib.debug.traceIf`\n\n##### `traceIf :: bool -> string -> a -> a`\n\nConditionally trace the supplied message, based on a predicate.\n\n `pred`  \nPredicate to check\n\n `msg`  \nMessage that should be traced\n\n `x`  \nValue to return\n\n**Example: lib.debug.traceIf usage example**\n\n``` programlisting\ntraceIf true \"hello\" 3\ntrace: hello\n=> 3\n```\n\n  \n\nLocated at [lib/debug.nix:51](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L51) in `<nixpkgs>`."
- name: lib.debug.traceSeq
  summary: '`builtins.trace`, but the value is `builtins.deepSeq`ed first'
  description: "## `lib.debug.traceSeq`\n\n##### `traceSeq :: a -> b -> b`\n\n\\`builtins.trace\\`, but the value is \\`builtins.deepSeq\\`ed first.\n\n `x`  \nThe value to trace\n\n `y`  \nThe value to return\n\n**Example: lib.debug.traceSeq usage example**\n\n``` programlisting\ntrace { a.b.c = 3; } null\ntrace: { a = <CODE>; }\n=> null\ntraceSeq { a.b.c = 3; } null\ntrace: { a = { b = { c = 3; }; }; }\n=> null\n```\n\n  \n\nLocated at [lib/debug.nix:98](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L98) in `<nixpkgs>`."
- name: lib.debug.traceSeqN
  summary: Like `traceSeq`, but only evaluate down to depth n
  description: "## `lib.debug.traceSeqN`\n\nLike \\`traceSeq\\`, but only evaluate down to depth n. This is very useful because lots of \\`traceSeq\\` usages lead to an infinite recursion.\n\n `depth`  \nFunction argument\n\n `x`  \nFunction argument\n\n `y`  \nFunction argument\n\n**Example: lib.debug.traceSeqN usage example**\n\n``` programlisting\ntraceSeqN 2 { a.b.c = 3; } null\ntrace: { a = { b = {…}; }; }\n=> null\n```\n\n  \n\nLocated at [lib/debug.nix:113](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L113) in `<nixpkgs>`."
- name: lib.debug.traceVal
  summary: Trace the supplied value and return it
  description: "## `lib.debug.traceVal`\n\n##### `traceVal :: a -> a`\n\nTrace the supplied value and return it.\n\n**Example: lib.debug.traceVal usage example**\n\n``` programlisting\ntraceVal 42\n# trace: 42\n=> 42\n```\n\n  \n\nLocated at [lib/debug.nix:84](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L84) in `<nixpkgs>`."
- name: lib.debug.traceValFn
  summary: Trace the supplied value after applying a function to it, and return the original value
  description: "## `lib.debug.traceValFn`\n\n##### `traceValFn :: (a -> b) -> a -> a`\n\nTrace the supplied value after applying a function to it, and return the original value.\n\n `f`  \nFunction to apply\n\n `x`  \nValue to trace and return\n\n**Example: lib.debug.traceValFn usage example**\n\n``` programlisting\ntraceValFn (v: \"mystring ${v}\") \"foo\"\ntrace: mystring foo\n=> \"foo\"\n```\n\n  \n\nLocated at [lib/debug.nix:69](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L69) in `<nixpkgs>`."
- name: lib.debug.traceValSeq
  summary: null
  description: |-
    ## `lib.debug.traceValSeq`

    A combination of \`traceVal\` and \`traceSeq\`.

    Located at [lib/debug.nix:137](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L137) in `<nixpkgs>`.
- name: lib.debug.traceValSeqFn
  summary: A combination of `traceVal` and `traceSeq` that applies a provided function to the value to be traced after `deepSeq`ing it
  description: "## `lib.debug.traceValSeqFn`\n\nA combination of \\`traceVal\\` and \\`traceSeq\\` that applies a provided function to the value to be traced after \\`deepSeq\\`ing it.\n\n `f`  \nFunction to apply\n\n `v`  \nValue to trace\n\nLocated at [lib/debug.nix:130](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L130) in `<nixpkgs>`."
- name: lib.debug.traceValSeqN
  summary: null
  description: |-
    ## `lib.debug.traceValSeqN`

    A combination of \`traceVal\` and \`traceSeqN\`.

    Located at [lib/debug.nix:149](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L149) in `<nixpkgs>`.
- name: lib.debug.traceValSeqNFn
  summary: A combination of `traceVal` and `traceSeqN` that applies a provided function to the value to be traced
  description: "## `lib.debug.traceValSeqNFn`\n\nA combination of \\`traceVal\\` and \\`traceSeqN\\` that applies a provided function to the value to be traced.\n\n `f`  \nFunction to apply\n\n `depth`  \nFunction argument\n\n `v`  \nValue to trace\n\nLocated at [lib/debug.nix:141](https://github.com/NixOS/nixpkgs/blob/master/lib/debug.nix#L141) in `<nixpkgs>`."
- name: lib.lists.all
  summary: null
  description: "## `lib.lists.all`\n\n##### `all :: (a -> bool) -> [a] -> bool`\n\nReturn true if function \\`pred\\` returns true for all elements of \\`list\\`.\n\n**Example: lib.lists.all usage example**\n\n``` programlisting\nall (x: x < 3) [ 1 2 ]\n=> true\nall (x: x < 3) [ 1 2 3 ]\n=> false\n```\n\n  \n\nLocated at [lib/lists.nix:228](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L228) in `<nixpkgs>`."
- name: lib.lists.any
  summary: null
  description: "## `lib.lists.any`\n\n##### `any :: (a -> bool) -> [a] -> bool`\n\nReturn true if function \\`pred\\` returns true for at least one element of \\`list\\`.\n\n**Example: lib.lists.any usage example**\n\n``` programlisting\nany isString [ 1 \"a\" { } ]\n=> true\nany isString [ 1 { } ]\n=> false\n```\n\n  \n\nLocated at [lib/lists.nix:215](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L215) in `<nixpkgs>`."
- name: lib.lists.compareLists
  summary: Compare two lists element-by-element
  description: "## `lib.lists.compareLists`\n\nCompare two lists element-by-element.\n\n `cmp`  \nFunction argument\n\n `a`  \nFunction argument\n\n `b`  \nFunction argument\n\n**Example: lib.lists.compareLists usage example**\n\n``` programlisting\ncompareLists compare [] []\n=> 0\ncompareLists compare [] [ \"a\" ]\n=> -1\ncompareLists compare [ \"a\" ] []\n=> 1\ncompareLists compare [ \"a\" \"b\" ] [ \"a\" \"c\" ]\n=> 1\n```\n\n  \n\nLocated at [lib/lists.nix:512](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L512) in `<nixpkgs>`."
- name: lib.lists.concatMap
  summary: Map and concatenate the result
  description: "## `lib.lists.concatMap`\n\n##### `concatMap :: (a -> [b]) -> [a] -> [b]`\n\nMap and concatenate the result.\n\n**Example: lib.lists.concatMap usage example**\n\n``` programlisting\nconcatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"]\n=> [ \"a\" \"z\" \"b\" \"z\" ]\n```\n\n  \n\nLocated at [lib/lists.nix:127](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L127) in `<nixpkgs>`."
- name: lib.lists.count
  summary: Count how many elements of `list` match the supplied predicate function
  description: "## `lib.lists.count`\n\n##### `count :: (a -> bool) -> [a] -> int`\n\nCount how many elements of \\`list\\` match the supplied predicate function.\n\n `pred`  \nPredicate\n\n**Example: lib.lists.count usage example**\n\n``` programlisting\ncount (x: x == 3) [ 3 2 3 4 6 ]\n=> 2\n```\n\n  \n\nLocated at [lib/lists.nix:239](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L239) in `<nixpkgs>`."
- name: lib.lists.crossLists
  summary: Return the image of the cross product of some lists by a function
  description: "## `lib.lists.crossLists`\n\nReturn the image of the cross product of some lists by a function.\n\n**Example: lib.lists.crossLists usage example**\n\n``` programlisting\ncrossLists (x:y: \"${toString x}${toString y}\") [[1 2] [3 4]]\n=> [ \"13\" \"14\" \"23\" \"24\" ]\n```\n\n  \n\nLocated at [lib/lists.nix:633](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L633) in `<nixpkgs>`."
- name: lib.lists.drop
  summary: Remove the first (at most) N elements of a list
  description: "## `lib.lists.drop`\n\n##### `drop :: int -> [a] -> [a]`\n\nRemove the first (at most) N elements of a list.\n\n `count`  \nNumber of elements to drop\n\n `list`  \nInput list\n\n**Example: lib.lists.drop usage example**\n\n``` programlisting\ndrop 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"c\" \"d\" ]\ndrop 2 [ ]\n=> [ ]\n```\n\n  \n\nLocated at [lib/lists.nix:567](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L567) in `<nixpkgs>`."
- name: lib.lists.findFirst
  summary: Find the first element in the list matching the specified predicate or return `default` if no such element exists
  description: "## `lib.lists.findFirst`\n\n##### `findFirst :: (a -> bool) -> a -> [a] -> a`\n\nFind the first element in the list matching the specified predicate or return \\`default\\` if no such element exists.\n\n `pred`  \nPredicate\n\n `default`  \nDefault value to return\n\n `list`  \nInput list\n\n**Example: lib.lists.findFirst usage example**\n\n``` programlisting\nfindFirst (x: x > 3) 7 [ 1 6 4 ]\n=> 6\nfindFirst (x: x > 9) 7 [ 1 6 4 ]\n=> 7\n```\n\n  \n\nLocated at [lib/lists.nix:194](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L194) in `<nixpkgs>`."
- name: lib.lists.findSingle
  summary: Find the sole element in the list matching the specified predicate, returns `default` if no such element exists, or `multiple` if there are multiple matching elements
  description: "## `lib.lists.findSingle`\n\n##### `findSingle :: (a -> bool) -> a -> a -> [a] -> a`\n\nFind the sole element in the list matching the specified predicate, returns \\`default\\` if no such element exists, or \\`multiple\\` if there are multiple matching elements.\n\n `pred`  \nPredicate\n\n `default`  \nDefault value to return if element was not found.\n\n `multiple`  \nDefault value to return if more than one element was found\n\n `list`  \nInput list\n\n**Example: lib.lists.findSingle usage example**\n\n``` programlisting\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ]\n=> \"multiple\"\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ]\n=> 3\nfindSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ]\n=> \"none\"\n```\n\n  \n\nLocated at [lib/lists.nix:169](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L169) in `<nixpkgs>`."
- name: lib.lists.flatten
  summary: Flatten the argument into a single list; that is, nested lists are spliced into the top-level lists
  description: "## `lib.lists.flatten`\n\nFlatten the argument into a single list; that is, nested lists are spliced into the top-level lists.\n\n `x`  \nFunction argument\n\n**Example: lib.lists.flatten usage example**\n\n``` programlisting\nflatten [1 [2 [3] 4] 5]\n=> [1 2 3 4 5]\nflatten 1\n=> [1]\n```\n\n  \n\nLocated at [lib/lists.nix:138](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L138) in `<nixpkgs>`."
- name: lib.lists.fold
  summary: null
  description: |-
    ## `lib.lists.fold`

    \`fold\` is an alias of \`foldr\` for historic reasons

    Located at [lib/lists.nix:64](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L64) in `<nixpkgs>`.
- name: lib.lists.foldl
  summary: null
  description: "## `lib.lists.foldl`\n\n##### `foldl :: (b -> a -> b) -> b -> [a] -> b`\n\n“left fold”, like \\`foldr\\`, but from the left: \\`foldl op nul \\[x_1 x_2 ... x_n\\] == op (... (op (op nul x_1) x_2) ... x_n)\\`.\n\n `op`  \nFunction argument\n\n `nul`  \nFunction argument\n\n `list`  \nFunction argument\n\n**Example: lib.lists.foldl usage example**\n\n``` programlisting\nlconcat = foldl (a: b: a + b) \"z\"\nlconcat [ \"a\" \"b\" \"c\" ]\n=> \"zabc\"\n# different types\nlstrange = foldl (str: int: str + toString (int + 1)) \"a\"\nlstrange [ 1 2 3 4 ]\n=> \"a2345\"\n```\n\n  \n\nLocated at [lib/lists.nix:81](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L81) in `<nixpkgs>`."
- name: lib.lists.foldl'
  summary: The difference is that evaluation is forced upon access
  description: |-
    ## `lib.lists.foldl'`

    ##### `foldl' :: (b -> a -> b) -> b -> [a] -> b`

    Strict version of \`foldl\`.

    The difference is that evaluation is forced upon access. Usually used with small whole results (in contrast with lazily-generated list or large lists where only a part is consumed.)

    Located at [lib/lists.nix:97](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L97) in `<nixpkgs>`.
- name: lib.lists.foldr
  summary: null
  description: "## `lib.lists.foldr`\n\n##### `foldr :: (a -> b -> b) -> b -> [a] -> b`\n\n“right fold” a binary function \\`op\\` between successive elements of \\`list\\` with \\`nul' as the starting value, i.e., \\`foldr op nul \\[x_1 x_2 ... x_n\\] == op x_1 (op x_2 ... (op x_n nul))\\`.\n\n `op`  \nFunction argument\n\n `nul`  \nFunction argument\n\n `list`  \nFunction argument\n\n**Example: lib.lists.foldr usage example**\n\n``` programlisting\nconcat = foldr (a: b: a + b) \"z\"\nconcat [ \"a\" \"b\" \"c\" ]\n=> \"abcz\"\n# different types\nstrange = foldr (int: str: toString (int + 1) + str) \"a\"\nstrange [ 1 2 3 4 ]\n=> \"2345a\"\n```\n\n  \n\nLocated at [lib/lists.nix:53](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L53) in `<nixpkgs>`."
- name: lib.lists.forEach
  summary: Apply the function to each element in the list
  description: "## `lib.lists.forEach`\n\n##### `forEach :: [a] -> (a -> b) -> [b]`\n\nApply the function to each element in the list. Same as \\`map\\`, but arguments flipped.\n\n `xs`  \nFunction argument\n\n `f`  \nFunction argument\n\n**Example: lib.lists.forEach usage example**\n\n``` programlisting\nforEach [ 1 2 ] (x:\ntoString x\n)\n=> [ \"1\" \"2\" ]\n```\n\n  \n\nLocated at [lib/lists.nix:36](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L36) in `<nixpkgs>`."
- name: lib.lists.groupBy'
  summary: Splits the elements of a list into many lists, using the return value of a predicate
  description: "## `lib.lists.groupBy'`\n\nSplits the elements of a list into many lists, using the return value of a predicate. Predicate should return a string which becomes keys of attrset \\`groupBy' returns.\n\n\\`groupBy'\\` allows to customise the combining function and initial value\n\n `op`  \nFunction argument\n\n `nul`  \nFunction argument\n\n `pred`  \nFunction argument\n\n `lst`  \nFunction argument\n\n**Example: lib.lists.groupBy' usage example**\n\n``` programlisting\ngroupBy (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n=> { true = [ 5 3 4 ]; false = [ 1 2 ]; }\ngroupBy (x: x.name) [ {name = \"icewm\"; script = \"icewm &\";}\n{name = \"xfce\";  script = \"xfce4-session &\";}\n{name = \"icewm\"; script = \"icewmbg &\";}\n{name = \"mate\";  script = \"gnome-session &\";}\n]\n=> { icewm = [ { name = \"icewm\"; script = \"icewm &\"; }\n{ name = \"icewm\"; script = \"icewmbg &\"; } ];\nmate  = [ { name = \"mate\";  script = \"gnome-session &\"; } ];\nxfce  = [ { name = \"xfce\";  script = \"xfce4-session &\"; } ];\n}\n\ngroupBy' builtins.add 0 (x: boolToString (x > 2)) [ 5 1 2 3 4 ]\n=> { true = 12; false = 3; }\n```\n\n  \n\nLocated at [lib/lists.nix:344](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L344) in `<nixpkgs>`."
- name: lib.lists.imap0
  summary: null
  description: "## `lib.lists.imap0`\n\n##### `imap0 :: (int -> a -> b) -> [a] -> [b]`\n\nMap with index starting from 0\n\n `f`  \nFunction argument\n\n `list`  \nFunction argument\n\n**Example: lib.lists.imap0 usage example**\n\n``` programlisting\nimap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-0\" \"b-1\" ]\n```\n\n  \n\nLocated at [lib/lists.nix:107](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L107) in `<nixpkgs>`."
- name: lib.lists.imap1
  summary: null
  description: "## `lib.lists.imap1`\n\n##### `imap1 :: (int -> a -> b) -> [a] -> [b]`\n\nMap with index starting from 1\n\n `f`  \nFunction argument\n\n `list`  \nFunction argument\n\n**Example: lib.lists.imap1 usage example**\n\n``` programlisting\nimap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"]\n=> [ \"a-1\" \"b-2\" ]\n```\n\n  \n\nLocated at [lib/lists.nix:117](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L117) in `<nixpkgs>`."
- name: lib.lists.init
  summary: Return all elements but the last
  description: "## `lib.lists.init`\n\n##### `init :: [a] -> [a]`\n\nReturn all elements but the last.\n\nThis function throws an error if the list is empty.\n\n `list`  \nFunction argument\n\n**Example: lib.lists.init usage example**\n\n``` programlisting\ninit [ 1 2 3 ]\n=> [ 1 2 ]\n```\n\n  \n\nLocated at [lib/lists.nix:622](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L622) in `<nixpkgs>`."
- name: lib.lists.intersectLists
  summary: Intersects list 'e' and another list
  description: "## `lib.lists.intersectLists`\n\nIntersects list 'e' and another list. O(nm) complexity.\n\n `e`  \nFunction argument\n\n**Example: lib.lists.intersectLists usage example**\n\n``` programlisting\nintersectLists [ 1 2 3 ] [ 6 3 2 ]\n=> [ 3 2 ]\n```\n\n  \n\nLocated at [lib/lists.nix:654](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L654) in `<nixpkgs>`."
- name: lib.lists.last
  summary: Return the last element of a list
  description: "## `lib.lists.last`\n\n##### `last :: [a] -> a`\n\nReturn the last element of a list.\n\nThis function throws an error if the list is empty.\n\n `list`  \nFunction argument\n\n**Example: lib.lists.last usage example**\n\n``` programlisting\nlast [ 1 2 3 ]\n=> 3\n```\n\n  \n\nLocated at [lib/lists.nix:608](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L608) in `<nixpkgs>`."
- name: lib.lists.listDfs
  summary: null
  description: "## `lib.lists.listDfs`\n\nDepth-First Search (DFS) for lists \\`list != \\[\\]\\`.\n\n\\`before a b == true\\` means that \\`b\\` depends on \\`a\\` (there's an edge from \\`b\\` to \\`a\\`).\n\n `stopOnCycles`  \nFunction argument\n\n `before`  \nFunction argument\n\n `list`  \nFunction argument\n\n**Example: lib.lists.listDfs usage example**\n\n``` programlisting\nlistDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ]\n== { minimal = \"/\";                  # minimal element\nvisited = [ \"/home/user\" ];     # seen elements (in reverse order)\nrest    = [ \"/home\" \"other\" ];  # everything else\n}\n\nlistDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ]\n== { cycle   = \"/\";                  # cycle encountered at this element\nloops   = [ \"/\" ];              # and continues to these elements\nvisited = [ \"/\" \"/home/user\" ]; # elements leading to the cycle (in reverse order)\nrest    = [ \"/home\" \"other\" ];  # everything else\n```\n\n  \n\nLocated at [lib/lists.nix:416](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L416) in `<nixpkgs>`."
- name: lib.lists.mutuallyExclusive
  summary: Test if two lists have no common element
  description: "## `lib.lists.mutuallyExclusive`\n\nTest if two lists have no common element. It should be slightly more efficient than (intersectLists a b == \\[\\])\n\n `a`  \nFunction argument\n\n `b`  \nFunction argument\n\nLocated at [lib/lists.nix:667](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L667) in `<nixpkgs>`."
- name: lib.lists.naturalSort
  summary: Sort list using "Natural sorting". Numeric portions of strings are sorted in numeric order
  description: "## `lib.lists.naturalSort`\n\nSort list using \"Natural sorting\". Numeric portions of strings are sorted in numeric order.\n\n `lst`  \nFunction argument\n\n**Example: lib.lists.naturalSort usage example**\n\n``` programlisting\nnaturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"]\n=> [\"disk8\" \"disk9\" \"disk11\" \"disk100\"]\nnaturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"]\n=> [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"]\nnaturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"]\n=> [ \"v0.0.9\" \"v0.2\" \"v0.15\" ]\n```\n\n  \n\nLocated at [lib/lists.nix:535](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L535) in `<nixpkgs>`."
- name: lib.lists.optional
  summary: Return a singleton list or an empty list, depending on a boolean value
  description: "## `lib.lists.optional`\n\n##### `optional :: bool -> a -> [a]`\n\nReturn a singleton list or an empty list, depending on a boolean value. Useful when building lists with optional elements (e.g. \\`++ optional (system == \"i686-linux\") firefox').\n\n `cond`  \nFunction argument\n\n `elem`  \nFunction argument\n\n**Example: lib.lists.optional usage example**\n\n``` programlisting\noptional true \"foo\"\n=> [ \"foo\" ]\noptional false \"foo\"\n=> [ ]\n```\n\n  \n\nLocated at [lib/lists.nix:255](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L255) in `<nixpkgs>`."
- name: lib.lists.optionals
  summary: Return a list or an empty list, depending on a boolean value
  description: "## `lib.lists.optionals`\n\n##### `optionals :: bool -> [a] -> [a]`\n\nReturn a list or an empty list, depending on a boolean value.\n\n `cond`  \nCondition\n\n `elems`  \nList to return if condition is true\n\n**Example: lib.lists.optionals usage example**\n\n``` programlisting\noptionals true [ 2 3 ]\n=> [ 2 3 ]\noptionals false [ 2 3 ]\n=> [ ]\n```\n\n  \n\nLocated at [lib/lists.nix:267](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L267) in `<nixpkgs>`."
- name: lib.lists.partition
  summary: Splits the elements of a list in two lists, `right` and `wrong`, depending on the evaluation of a predicate
  description: "## `lib.lists.partition`\n\n##### `(a -> bool) -> [a] -> { right :: [a], wrong :: [a] }`\n\nSplits the elements of a list in two lists, \\`right\\` and \\`wrong\\`, depending on the evaluation of a predicate.\n\n**Example: lib.lists.partition usage example**\n\n``` programlisting\npartition (x: x > 2) [ 5 1 2 3 4 ]\n=> { right = [ 5 3 4 ]; wrong = [ 1 2 ]; }\n```\n\n  \n\nLocated at [lib/lists.nix:315](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L315) in `<nixpkgs>`."
- name: lib.lists.range
  summary: null
  description: "## `lib.lists.range`\n\n##### `range :: int -> int -> [int]`\n\nReturn a list of integers from \\`first' up to and including \\`last'.\n\n `first`  \nFirst integer in the range\n\n `last`  \nLast integer in the range\n\n**Example: lib.lists.range usage example**\n\n``` programlisting\nrange 2 4\n=> [ 2 3 4 ]\nrange 3 2\n=> [ ]\n```\n\n  \n\nLocated at [lib/lists.nix:296](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L296) in `<nixpkgs>`."
- name: lib.lists.remove
  summary: Remove elements equal to 'e' from a list
  description: "## `lib.lists.remove`\n\n##### `remove :: a -> [a] -> [a]`\n\nRemove elements equal to 'e' from a list. Useful for buildInputs.\n\n `e`  \nElement to remove from the list\n\n**Example: lib.lists.remove usage example**\n\n``` programlisting\nremove 3 [ 1 3 4 3 ]\n=> [ 1 4 ]\n```\n\n  \n\nLocated at [lib/lists.nix:151](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L151) in `<nixpkgs>`."
- name: lib.lists.reverseList
  summary: Reverse the order of the elements of a list
  description: "## `lib.lists.reverseList`\n\n##### `reverseList :: [a] -> [a]`\n\nReverse the order of the elements of a list.\n\n `xs`  \nFunction argument\n\n**Example: lib.lists.reverseList usage example**\n\n``` programlisting\n\nreverseList [ \"b\" \"o\" \"j\" ]\n=> [ \"j\" \"o\" \"b\" ]\n```\n\n  \n\nLocated at [lib/lists.nix:394](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L394) in `<nixpkgs>`."
- name: lib.lists.singleton
  summary: Create a list consisting of a single element
  description: "## `lib.lists.singleton`\n\n##### `singleton :: a -> [a]`\n\nCreate a list consisting of a single element. \\`singleton x\\` is sometimes more convenient with respect to indentation than \\`\\[x\\]\\` when x spans multiple lines.\n\n `x`  \nFunction argument\n\n**Example: lib.lists.singleton usage example**\n\n``` programlisting\nsingleton \"foo\"\n=> [ \"foo\" ]\n```\n\n  \n\nLocated at [lib/lists.nix:23](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L23) in `<nixpkgs>`."
- name: lib.lists.sort
  summary: Sort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the second argument
  description: "## `lib.lists.sort`\n\nSort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the second argument. The returned list is sorted in an increasing order. The implementation does a quick-sort.\n\n**Example: lib.lists.sort usage example**\n\n``` programlisting\nsort (a: b: a < b) [ 5 3 7 ]\n=> [ 3 5 7 ]\n```\n\n  \n\nLocated at [lib/lists.nix:483](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L483) in `<nixpkgs>`."
- name: lib.lists.sublist
  summary: null
  description: "## `lib.lists.sublist`\n\n##### `sublist :: int -> int -> [a] -> [a]`\n\nReturn a list consisting of at most \\`count\\` elements of \\`list\\`, starting at index \\`start\\`.\n\n `start`  \nIndex at which to start the sublist\n\n `count`  \nNumber of elements to take\n\n `list`  \nInput list\n\n**Example: lib.lists.sublist usage example**\n\n``` programlisting\nsublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ]\n=> [ \"b\" \"c\" \"d\" ]\nsublist 1 3 [ ]\n=> [ ]\n```\n\n  \n\nLocated at [lib/lists.nix:584](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L584) in `<nixpkgs>`."
- name: lib.lists.subtractLists
  summary: Subtracts list 'e' from another list
  description: "## `lib.lists.subtractLists`\n\nSubtracts list 'e' from another list. O(nm) complexity.\n\n `e`  \nFunction argument\n\n**Example: lib.lists.subtractLists usage example**\n\n``` programlisting\nsubtractLists [ 3 2 ] [ 1 2 3 4 5 3 ]\n=> [ 1 4 5 ]\n```\n\n  \n\nLocated at [lib/lists.nix:662](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L662) in `<nixpkgs>`."
- name: lib.lists.take
  summary: Return the first (at most) N elements of a list
  description: "## `lib.lists.take`\n\n##### `take :: int -> [a] -> [a]`\n\nReturn the first (at most) N elements of a list.\n\n `count`  \nNumber of elements to take\n\n**Example: lib.lists.take usage example**\n\n``` programlisting\ntake 2 [ \"a\" \"b\" \"c\" \"d\" ]\n=> [ \"a\" \"b\" ]\ntake 2 [ ]\n=> [ ]\n```\n\n  \n\nLocated at [lib/lists.nix:553](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L553) in `<nixpkgs>`."
- name: lib.lists.toList
  summary: If argument is a list, return it; else, wrap it in a singleton list
  description: "## `lib.lists.toList`\n\nIf argument is a list, return it; else, wrap it in a singleton list. If you're using this, you should almost certainly reconsider if there isn't a more \"well-typed\" approach.\n\n `x`  \nFunction argument\n\n**Example: lib.lists.toList usage example**\n\n``` programlisting\ntoList [ 1 2 ]\n=> [ 1 2 ]\ntoList \"hi\"\n=> [ \"hi \"]\n```\n\n  \n\nLocated at [lib/lists.nix:284](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L284) in `<nixpkgs>`."
- name: lib.lists.toposort
  summary: Sort a list based on a partial ordering using DFS
  description: "## `lib.lists.toposort`\n\nSort a list based on a partial ordering using DFS. This implementation is O(N^2), if your ordering is linear, use \\`sort\\` instead.\n\n\\`before a b == true\\` means that \\`b\\` should be after \\`a\\` in the result.\n\n `before`  \nFunction argument\n\n `list`  \nFunction argument\n\n**Example: lib.lists.toposort usage example**\n\n``` programlisting\n\ntoposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ]\n== { result = [ \"/\" \"/home\" \"/home/user\" \"other\" ]; }\n\ntoposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ]\n== { cycle = [ \"/home/user\" \"/\" \"/\" ]; # path leading to a cycle\nloops = [ \"/\" ]; }                # loops back to these elements\n\ntoposort hasPrefix [ \"other\" \"/home/user\" \"/home\" \"/\" ]\n== { result = [ \"other\" \"/\" \"/home\" \"/home/user\" ]; }\n\ntoposort (a: b: a < b) [ 3 2 1 ] == { result = [ 1 2 3 ]; }\n```\n\n  \n\nLocated at [lib/lists.nix:455](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L455) in `<nixpkgs>`."
- name: lib.lists.unique
  summary: Remove duplicate elements from the list
  description: "## `lib.lists.unique`\n\n##### `unique :: [a] -> [a]`\n\nRemove duplicate elements from the list. O(n^2) complexity.\n\n**Example: lib.lists.unique usage example**\n\n``` programlisting\nunique [ 3 2 3 4 ]\n=> [ 3 2 4 ]\n```\n\n  \n\nLocated at [lib/lists.nix:646](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L646) in `<nixpkgs>`."
- name: lib.lists.zipLists
  summary: Merges two lists of the same size together
  description: "## `lib.lists.zipLists`\n\n##### `zipLists :: [a] -> [b] -> [{ fst :: a, snd :: b}]`\n\nMerges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest.\n\n**Example: lib.lists.zipLists usage example**\n\n``` programlisting\nzipLists [ 1 2 ] [ \"a\" \"b\" ]\n=> [ { fst = 1; snd = \"a\"; } { fst = 2; snd = \"b\"; } ]\n```\n\n  \n\nLocated at [lib/lists.nix:383](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L383) in `<nixpkgs>`."
- name: lib.lists.zipListsWith
  summary: Merges two lists of the same size together
  description: "## `lib.lists.zipListsWith`\n\n##### `zipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c]`\n\nMerges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. How both lists are merged is defined by the first argument.\n\n `f`  \nFunction to zip elements of both lists\n\n `fst`  \nFirst list\n\n `snd`  \nSecond list\n\n**Example: lib.lists.zipListsWith usage example**\n\n``` programlisting\nzipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"]\n=> [\"he\" \"lo\"]\n```\n\n  \n\nLocated at [lib/lists.nix:364](https://github.com/NixOS/nixpkgs/blob/master/lib/lists.nix#L364) in `<nixpkgs>`."
- name: lib.options.getFiles
  summary: null
  description: "## `lib.options.getFiles`\n\n##### `getFiles :: [ { file :: a } ] -> [a]`\n\nExtracts values of all \"file\" keys of the given list\n\n**Example: lib.options.getFiles usage example**\n\n``` programlisting\ngetFiles [ { file = \"file1\"; } { file = \"file2\"; } ] // => [ \"file1\" \"file2\" ]\ngetFiles [ ]                                         // => [ ]\n```\n\n  \n\nLocated at [lib/options.nix:212](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L212) in `<nixpkgs>`."
- name: lib.options.getValues
  summary: Extracts values of all "value" keys of the given list
  description: "## `lib.options.getValues`\n\n##### `getValues :: [ { value :: a } ] -> [a]`\n\nExtracts values of all \"value\" keys of the given list.\n\n**Example: lib.options.getValues usage example**\n\n``` programlisting\ngetValues [ { value = 1; } { value = 2; } ] // => [ 1 2 ]\ngetValues [ ]                               // => [ ]\n```\n\n  \n\nLocated at [lib/options.nix:202](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L202) in `<nixpkgs>`."
- name: lib.options.isOption
  summary: null
  description: "## `lib.options.isOption`\n\n##### `isOption :: a -> bool`\n\nReturns true when the given argument is an option\n\n**Example: lib.options.isOption usage example**\n\n``` programlisting\nisOption 1             // => false\nisOption (mkOption {}) // => true\n```\n\n  \n\nLocated at [lib/options.nix:50](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L50) in `<nixpkgs>`."
- name: lib.options.literalDocBook
  summary: For use in the `defaultText` and `example` option attributes
  description: "## `lib.options.literalDocBook`\n\nFor use in the \\`defaultText\\` and \\`example\\` option attributes. Causes the given DocBook text to be inserted verbatim in the documentation, for when a \\`literalExpression\\` would be too hard to read.\n\n `text`  \nFunction argument\n\nLocated at [lib/options.nix:279](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L279) in `<nixpkgs>`."
- name: lib.options.literalExpression
  summary: For use in the `defaultText` and `example` option attributes
  description: "## `lib.options.literalExpression`\n\nFor use in the \\`defaultText\\` and \\`example\\` option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values, e.g. functions, or values that depend on other values or packages.\n\n `text`  \nFunction argument\n\nLocated at [lib/options.nix:268](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L268) in `<nixpkgs>`."
- name: lib.options.mergeEqualOption
  summary: '"Merge" option definitions by checking that they all have the same value'
  description: "## `lib.options.mergeEqualOption`\n\n\"Merge\" option definitions by checking that they all have the same value.\n\n `loc`  \nFunction argument\n\n `defs`  \nFunction argument\n\nLocated at [lib/options.nix:182](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L182) in `<nixpkgs>`."
- name: lib.options.mkEnableOption
  summary: null
  description: "## `lib.options.mkEnableOption`\n\nCreates an Option attribute set for a boolean value option i.e an option to be toggled on or off:\n\n `name`  \nName for the created option\n\n**Example: lib.options.mkEnableOption usage example**\n\n``` programlisting\nmkEnableOption \"foo\"\n=> { _type = \"option\"; default = false; description = \"Whether to enable foo.\"; example = true; type = { ... }; }\n```\n\n  \n\nLocated at [lib/options.nix:92](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L92) in `<nixpkgs>`."
- name: lib.options.mkOption
  summary: Creates an Option attribute set
  description: "## `lib.options.mkOption`\n\nCreates an Option attribute set. mkOption accepts an attribute set with the following keys:\n\nAll keys default to \\`null\\` when not given.\n\n `pattern`  \nStructured function argument\n\n `default`  \nDefault value used when no definition is given in the configuration.\n\n `defaultText`  \nTextual representation of the default, for the manual.\n\n `example`  \nExample value used in the manual.\n\n `description`  \nString describing the option.\n\n `relatedPackages`  \nRelated packages used in the manual (see \\`genRelatedPackages\\` in ../nixos/lib/make-options-doc/default.nix).\n\n `type`  \nOption type, providing type-checking and value merging.\n\n `apply`  \nFunction that converts the option value to something else.\n\n `internal`  \nWhether the option is for NixOS developers only.\n\n `visible`  \nWhether the option shows up in the manual. Default: true. Use false to hide the option and any sub-options from submodules. Use \"shallow\" to hide only sub-options.\n\n `readOnly`  \nWhether the option can be set only once\n\n**Example: lib.options.mkOption usage example**\n\n``` programlisting\nmkOption { }  // => { _type = \"option\"; }\nmkOption { default = \"foo\"; } // => { _type = \"option\"; default = \"foo\"; }\n```\n\n  \n\nLocated at [lib/options.nix:60](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L60) in `<nixpkgs>`."
- name: lib.options.mkPackageOption
  summary: Creates an Option attribute set for an option that specifies the package a module should use for some purpose
  description: "## `lib.options.mkPackageOption`\n\n##### `mkPackageOption :: pkgs -> string -> { default :: [string], example :: null | string | [string] } -> optionThe package is specified as a list of strings representing its attribute path in nixpkgs.Because of this, you need to pass nixpkgs itself as the first argument.The second argument is the name of the option, used in the description \"The <name> package to use.\".You can also pass an example value, either a literal string or a package's attribute path.You can omit the default path if the name of the option is also attribute path in nixpkgs.`\n\nCreates an Option attribute set for an option that specifies the package a module should use for some purpose.\n\n `pkgs`  \nPackage set (a specific version of nixpkgs)\n\n `name`  \nName for the package, shown in option description\n\n `pattern`  \nStructured function argument\n\n `default`  \nFunction argument\n\n `example`  \nFunction argument\n\n**Example: lib.options.mkPackageOption usage example**\n\n``` programlisting\nmkPackageOption pkgs \"hello\" { }\n=> { _type = \"option\"; default = «derivation /nix/store/3r2vg51hlxj3cx5vscp0vkv60bqxkaq0-hello-2.10.drv»; defaultText = { ... }; description = \"The hello package to use.\"; type = { ... }; }\n\n\nmkPackageOption pkgs \"GHC\" {\ndefault = [ \"ghc\" ];\nexample = \"pkgs.haskell.package.ghc922.ghc.withPackages (hkgs: [ hkgs.primes ])\";\n}\n=> { _type = \"option\"; default = «derivation /nix/store/jxx55cxsjrf8kyh3fp2ya17q99w7541r-ghc-8.10.7.drv»; defaultText = { ... }; description = \"The GHC package to use.\"; example = { ... }; type = { ... }; }\n```\n\n  \n\nLocated at [lib/options.nix:127](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L127) in `<nixpkgs>`."
- name: lib.options.mkSinkUndeclaredOptions
  summary: This option accepts anything, but it does not produce any result
  description: "## `lib.options.mkSinkUndeclaredOptions`\n\nThis option accepts anything, but it does not produce any result.\n\nThis is useful for sharing a module across different module sets without having to implement similar features as long as the values of the options are not accessed.\n\n `attrs`  \nFunction argument\n\nLocated at [lib/options.nix:149](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L149) in `<nixpkgs>`."
- name: lib.options.scrubOptionValue
  summary: This function recursively removes all derivation attributes from `x` except for the `name` attribute
  description: "## `lib.options.scrubOptionValue`\n\nThis function recursively removes all derivation attributes from \\`x\\` except for the \\`name\\` attribute.\n\nThis is to make the generation of \\`options.xml\\` much more efficient: the XML representation of derivations is very large (on the order of megabytes) and is not actually used by the manual generator.\n\n `x`  \nFunction argument\n\nLocated at [lib/options.nix:255](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L255) in `<nixpkgs>`."
- name: lib.options.showOption
  summary: Convert an option, described as a list of the option parts in to a safe, human readable version
  description: "## `lib.options.showOption`\n\nConvert an option, described as a list of the option parts in to a safe, human readable version.\n\n `parts`  \nFunction argument\n\n**Example: lib.options.showOption usage example**\n\n``` programlisting\n(showOption [\"foo\" \"bar\" \"baz\"]) == \"foo.bar.baz\"\n(showOption [\"foo\" \"bar.baz\" \"tux\"]) == \"foo.bar.baz.tux\"\n\nPlaceholders will not be quoted as they are not actual values:\n(showOption [\"foo\" \"*\" \"bar\"]) == \"foo.*.bar\"\n(showOption [\"foo\" \"<name>\" \"bar\"]) == \"foo.<name>.bar\"\n\nUnlike attributes, options can also start with numbers:\n(showOption [\"windowManager\" \"2bwm\" \"enable\"]) == \"windowManager.2bwm.enable\"\n```\n\n  \n\nLocated at [lib/options.nix:299](https://github.com/NixOS/nixpkgs/blob/master/lib/options.nix#L299) in `<nixpkgs>`."
- name: lib.sources.cleanSource
  summary: Filters a source tree removing version control files and directories using cleanSourceFilter
  description: "## `lib.sources.cleanSource`\n\nFilters a source tree removing version control files and directories using cleanSourceFilter.\n\n `src`  \nFunction argument\n\n**Example: lib.sources.cleanSource usage example**\n\n``` programlisting\ncleanSource ./.\n```\n\n  \n\nLocated at [lib/sources.nix:265](https://github.com/NixOS/nixpkgs/blob/master/lib/sources.nix#L265) in `<nixpkgs>`."
- name: lib.sources.cleanSourceFilter
  summary: A basic filter for `cleanSourceWith` that removes directories of version control system, backup files (*~) and some generated files
  description: "## `lib.sources.cleanSourceFilter`\n\nA basic filter for \\`cleanSourceWith\\` that removes directories of version control system, backup files (\\*~) and some generated files.\n\n `name`  \nFunction argument\n\n `type`  \nFunction argument\n\nLocated at [lib/sources.nix:265](https://github.com/NixOS/nixpkgs/blob/master/lib/sources.nix#L265) in `<nixpkgs>`."
- name: lib.sources.cleanSourceWith
  summary: Like `builtins.filterSource`, except it will compose with itself, allowing you to chain multiple calls together without any intermediate copies being put in the nix store
  description: "## `lib.sources.cleanSourceWith`\n\nLike \\`builtins.filterSource\\`, except it will compose with itself, allowing you to chain multiple calls together without any intermediate copies being put in the nix store.\n\n `pattern`  \nStructured function argument\n\n `src`  \nA path or cleanSourceWith result to filter and/or rename.\n\n `filter`  \nOptional with default value: constant true (include everything)\n\n `name`  \nOptional name to use as part of the store path.\n\n**Example: lib.sources.cleanSourceWith usage example**\n\n``` programlisting\nlib.cleanSourceWith {\nfilter = f;\nsrc = lib.cleanSourceWith {\nfilter = g;\nsrc = ./.;\n};\n}\n# Succeeds!\n\nbuiltins.filterSource f (builtins.filterSource g ./.)\n# Fails!\n```\n\n  \n\nLocated at [lib/sources.nix:265](https://github.com/NixOS/nixpkgs/blob/master/lib/sources.nix#L265) in `<nixpkgs>`."
- name: lib.sources.commitIdFromGitRepo
  summary: Get the commit id of a git repo
  description: "## `lib.sources.commitIdFromGitRepo`\n\nGet the commit id of a git repo.\n\n**Example: lib.sources.commitIdFromGitRepo usage example**\n\n``` programlisting\ncommitIdFromGitRepo <nixpkgs/.git>\n```\n\n  \n\nLocated at [lib/sources.nix:265](https://github.com/NixOS/nixpkgs/blob/master/lib/sources.nix#L265) in `<nixpkgs>`."
- name: lib.sources.pathIsDirectory
  summary: Returns true if the path exists and is a directory, false otherwise
  description: "## `lib.sources.pathIsDirectory`\n\nReturns true if the path exists and is a directory, false otherwise.\n\n `path`  \nFunction argument\n\nLocated at [lib/sources.nix:265](https://github.com/NixOS/nixpkgs/blob/master/lib/sources.nix#L265) in `<nixpkgs>`."
- name: lib.sources.pathIsRegularFile
  summary: Returns true if the path exists and is a regular file, false otherwise
  description: "## `lib.sources.pathIsRegularFile`\n\nReturns true if the path exists and is a regular file, false otherwise.\n\n `path`  \nFunction argument\n\nLocated at [lib/sources.nix:265](https://github.com/NixOS/nixpkgs/blob/master/lib/sources.nix#L265) in `<nixpkgs>`."
- name: lib.sources.pathType
  summary: 'Returns the type of a path: regular (for file), symlink, or directory'
  description: "## `lib.sources.pathType`\n\nReturns the type of a path: regular (for file), symlink, or directory.\n\n `path`  \nFunction argument\n\nLocated at [lib/sources.nix:265](https://github.com/NixOS/nixpkgs/blob/master/lib/sources.nix#L265) in `<nixpkgs>`."
- name: lib.sources.sourceByRegex
  summary: Filter sources by a list of regular expressions
  description: "## `lib.sources.sourceByRegex`\n\nFilter sources by a list of regular expressions.\n\n `src`  \nFunction argument\n\n `regexes`  \nFunction argument\n\n**Example: lib.sources.sourceByRegex usage example**\n\n``` programlisting\nsrc = sourceByRegex ./my-subproject [\".*\\.py$\" \"^database.sql$\"]\n```\n\n  \n\nLocated at [lib/sources.nix:265](https://github.com/NixOS/nixpkgs/blob/master/lib/sources.nix#L265) in `<nixpkgs>`."
- name: lib.sources.sourceFilesBySuffices
  summary: Get all files ending with the specified suffices from the given source directory or its descendants, omitting files that do not match any suffix
  description: "## `lib.sources.sourceFilesBySuffices`\n\n##### `sourceLike -> [String] -> Source`\n\nGet all files ending with the specified suffices from the given source directory or its descendants, omitting files that do not match any suffix. The result of the example below will include files like \\`./dir/module.c\\` and \\`./dir/subdir/doc.xml\\` if present.\n\n `src`  \nPath or source containing the files to be returned\n\n `exts`  \nA list of file suffix strings\n\n**Example: lib.sources.sourceFilesBySuffices usage example**\n\n``` programlisting\nsourceFilesBySuffices ./. [ \".xml\" \".c\" ]\n```\n\n  \n\nLocated at [lib/sources.nix:265](https://github.com/NixOS/nixpkgs/blob/master/lib/sources.nix#L265) in `<nixpkgs>`."
- name: lib.sources.trace
  summary: Add logging to a source, for troubleshooting the filtering behavior
  description: "## `lib.sources.trace`\n\n##### `sources.trace :: sourceLike -> Source`\n\nAdd logging to a source, for troubleshooting the filtering behavior.\n\n `src`  \nSource to debug. The returned source will behave like this source, but also log its filter invocations.\n\nLocated at [lib/sources.nix:265](https://github.com/NixOS/nixpkgs/blob/master/lib/sources.nix#L265) in `<nixpkgs>`."
- name: lib.strings.addContextFrom
  summary: Appends string context from another string
  description: "## `lib.strings.addContextFrom`\n\nAppends string context from another string. This is an implementation detail of Nix.\n\nStrings in Nix carry an invisible \\`context\\` which is a list of strings representing store paths. If the string is later used in a derivation attribute, the derivation will properly populate the inputDrvs and inputSrcs.\n\n `a`  \nFunction argument\n\n `b`  \nFunction argument\n\n**Example: lib.strings.addContextFrom usage example**\n\n``` programlisting\npkgs = import <nixpkgs> { };\naddContextFrom pkgs.coreutils \"bar\"\n=> \"bar\"\n```\n\n  \n\nLocated at [lib/strings.nix:487](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L487) in `<nixpkgs>`."
- name: lib.strings.commonPrefixLength
  summary: Returns the length of the prefix common to both strings
  description: "## `lib.strings.commonPrefixLength`\n\nReturns the length of the prefix common to both strings.\n\n `a`  \nFunction argument\n\n `b`  \nFunction argument\n\nLocated at [lib/strings.nix:877](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L877) in `<nixpkgs>`."
- name: lib.strings.commonSuffixLength
  summary: Returns the length of the suffix common to both strings
  description: "## `lib.strings.commonSuffixLength`\n\nReturns the length of the suffix common to both strings.\n\n `a`  \nFunction argument\n\n `b`  \nFunction argument\n\nLocated at [lib/strings.nix:885](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L885) in `<nixpkgs>`."
- name: lib.strings.concatImapStrings
  summary: Like `concatMapStrings` except that the f functions also gets the position as a parameter
  description: "## `lib.strings.concatImapStrings`\n\n##### `concatImapStrings :: (int -> a -> string) -> [a] -> string`\n\nLike \\`concatMapStrings\\` except that the f functions also gets the position as a parameter.\n\n `f`  \nFunction argument\n\n `list`  \nFunction argument\n\n**Example: lib.strings.concatImapStrings usage example**\n\n``` programlisting\nconcatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"]\n=> \"1-foo2-bar\"\n```\n\n  \n\nLocated at [lib/strings.nix:65](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L65) in `<nixpkgs>`."
- name: lib.strings.concatImapStringsSep
  summary: Same as `concatMapStringsSep`, but the mapping function additionally receives the position of its argument
  description: "## `lib.strings.concatImapStringsSep`\n\n##### `concatIMapStringsSep :: string -> (int -> a -> string) -> [a] -> string`\n\nSame as \\`concatMapStringsSep\\`, but the mapping function additionally receives the position of its argument.\n\n `sep`  \nSeparator to add between elements\n\n `f`  \nFunction that receives elements and their positions\n\n `list`  \nList of input strings\n\n**Example: lib.strings.concatImapStringsSep usage example**\n\n``` programlisting\nconcatImapStringsSep \"-\" (pos: x: toString (x / pos)) [ 6 6 6 ]\n=> \"6-3-2\"\n```\n\n  \n\nLocated at [lib/strings.nix:122](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L122) in `<nixpkgs>`."
- name: lib.strings.concatMapStrings
  summary: Map a function over a list and concatenate the resulting strings
  description: "## `lib.strings.concatMapStrings`\n\n##### `concatMapStrings :: (a -> string) -> [a] -> string`\n\nMap a function over a list and concatenate the resulting strings.\n\n `f`  \nFunction argument\n\n `list`  \nFunction argument\n\n**Example: lib.strings.concatMapStrings usage example**\n\n``` programlisting\nconcatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"]\n=> \"afooabar\"\n```\n\n  \n\nLocated at [lib/strings.nix:54](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L54) in `<nixpkgs>`."
- name: lib.strings.concatMapStringsSep
  summary: Maps a function over a list of strings and then concatenates the result with the specified separator interspersed between elements
  description: "## `lib.strings.concatMapStringsSep`\n\n##### `concatMapStringsSep :: string -> (a -> string) -> [a] -> string`\n\nMaps a function over a list of strings and then concatenates the result with the specified separator interspersed between elements.\n\n `sep`  \nSeparator to add between elements\n\n `f`  \nFunction to map over the list\n\n `list`  \nList of input strings\n\n**Example: lib.strings.concatMapStringsSep usage example**\n\n``` programlisting\nconcatMapStringsSep \"-\" (x: toUpper x)  [\"foo\" \"bar\" \"baz\"]\n=> \"FOO-BAR-BAZ\"\n```\n\n  \n\nLocated at [lib/strings.nix:105](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L105) in `<nixpkgs>`."
- name: lib.strings.concatStrings
  summary: Concatenate a list of strings
  description: "## `lib.strings.concatStrings`\n\n##### `concatStrings :: [string] -> string`\n\nConcatenate a list of strings.\n\n**Example: lib.strings.concatStrings usage example**\n\n``` programlisting\nconcatStrings [\"foo\" \"bar\"]\n=> \"foobar\"\n```\n\n  \n\nLocated at [lib/strings.nix:44](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L44) in `<nixpkgs>`."
- name: lib.strings.concatStringsSep
  summary: null
  description: "## `lib.strings.concatStringsSep`\n\n##### `concatStringsSep :: string -> [string] -> string`\n\nConcatenate a list of strings with a separator between each element\n\n**Example: lib.strings.concatStringsSep usage example**\n\n``` programlisting\nconcatStringsSep \"/\" [\"usr\" \"local\" \"bin\"]\n=> \"usr/local/bin\"\n```\n\n  \n\nLocated at [lib/strings.nix:92](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L92) in `<nixpkgs>`."
- name: lib.strings.enableFeature
  summary: Create an --{enable,disable}-<feat> string that can be passed to standard GNU Autoconf scripts
  description: "## `lib.strings.enableFeature`\n\nCreate an --{enable,disable}-\\<feat\\> string that can be passed to standard GNU Autoconf scripts.\n\n `enable`  \nFunction argument\n\n `feat`  \nFunction argument\n\n**Example: lib.strings.enableFeature usage example**\n\n``` programlisting\nenableFeature true \"shared\"\n=> \"--enable-shared\"\nenableFeature false \"shared\"\n=> \"--disable-shared\"\n```\n\n  \n\nLocated at [lib/strings.nix:635](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L635) in `<nixpkgs>`."
- name: lib.strings.enableFeatureAs
  summary: Create an --{enable-<feat>=<value>,disable-<feat>} string that can be passed to standard GNU Autoconf scripts
  description: "## `lib.strings.enableFeatureAs`\n\nCreate an --{enable-\\<feat\\>=\\<value\\>,disable-\\<feat\\>} string that can be passed to standard GNU Autoconf scripts.\n\n `enable`  \nFunction argument\n\n `feat`  \nFunction argument\n\n `value`  \nFunction argument\n\n**Example: lib.strings.enableFeatureAs usage example**\n\n``` programlisting\nenableFeatureAs true \"shared\" \"foo\"\n=> \"--enable-shared=foo\"\nenableFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--disable-shared\"\n```\n\n  \n\nLocated at [lib/strings.nix:648](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L648) in `<nixpkgs>`."
- name: lib.strings.escape
  summary: Escape occurrence of the elements of `list` in `string` by prefixing it with a backslash
  description: "## `lib.strings.escape`\n\n##### `escape :: [string] -> string -> string`\n\nEscape occurrence of the elements of \\`list\\` in \\`string\\` by prefixing it with a backslash.\n\n `list`  \nFunction argument\n\n**Example: lib.strings.escape usage example**\n\n``` programlisting\nescape [\"(\" \")\"] \"(foo)\"\n=> \"\\\\(foo\\\\)\"\n```\n\n  \n\nLocated at [lib/strings.nix:306](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L306) in `<nixpkgs>`."
- name: lib.strings.escapeNixIdentifier
  summary: Quotes a string if it can't be used as an identifier directly
  description: "## `lib.strings.escapeNixIdentifier`\n\n##### `string -> string`\n\nQuotes a string if it can't be used as an identifier directly.\n\n `s`  \nFunction argument\n\n**Example: lib.strings.escapeNixIdentifier usage example**\n\n``` programlisting\nescapeNixIdentifier \"hello\"\n=> \"hello\"\nescapeNixIdentifier \"0abc\"\n=> \"\\\"0abc\\\"\"\n```\n\n  \n\nLocated at [lib/strings.nix:418](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L418) in `<nixpkgs>`."
- name: lib.strings.escapeNixString
  summary: null
  description: "## `lib.strings.escapeNixString`\n\n##### `string -> string`\n\nTurn a string into a Nix expression representing that string\n\n `s`  \nFunction argument\n\n**Example: lib.strings.escapeNixString usage example**\n\n``` programlisting\nescapeNixString \"hello\\${}\\n\"\n=> \"\\\"hello\\\\\\${}\\\\n\\\"\"\n```\n\n  \n\nLocated at [lib/strings.nix:396](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L396) in `<nixpkgs>`."
- name: lib.strings.escapeRegex
  summary: null
  description: "## `lib.strings.escapeRegex`\n\n##### `string -> string`\n\nTurn a string into an exact regular expression\n\n**Example: lib.strings.escapeRegex usage example**\n\n``` programlisting\nescapeRegex \"[^a-z]*\"\n=> \"\\\\[\\\\^a-z]\\\\*\"\n```\n\n  \n\nLocated at [lib/strings.nix:406](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L406) in `<nixpkgs>`."
- name: lib.strings.escapeShellArg
  summary: Quote string to be used safely within the Bourne shell
  description: "## `lib.strings.escapeShellArg`\n\n##### `escapeShellArg :: string -> string`\n\nQuote string to be used safely within the Bourne shell.\n\n `arg`  \nFunction argument\n\n**Example: lib.strings.escapeShellArg usage example**\n\n``` programlisting\nescapeShellArg \"esc'ape\\nme\"\n=> \"'esc'\\\\''ape\\nme'\"\n```\n\n  \n\nLocated at [lib/strings.nix:316](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L316) in `<nixpkgs>`."
- name: lib.strings.escapeShellArgs
  summary: Quote all arguments to be safely passed to the Bourne shell
  description: "## `lib.strings.escapeShellArgs`\n\n##### `escapeShellArgs :: [string] -> string`\n\nQuote all arguments to be safely passed to the Bourne shell.\n\n**Example: lib.strings.escapeShellArgs usage example**\n\n``` programlisting\nescapeShellArgs [\"one\" \"two three\" \"four'five\"]\n=> \"'one' 'two three' 'four'\\\\''five'\"\n```\n\n  \n\nLocated at [lib/strings.nix:326](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L326) in `<nixpkgs>`."
- name: lib.strings.escapeXML
  summary: Escapes a string such that it is safe to include verbatim in an XML document
  description: "## `lib.strings.escapeXML`\n\n##### `string -> string`\n\nEscapes a string such that it is safe to include verbatim in an XML document.\n\n**Example: lib.strings.escapeXML usage example**\n\n``` programlisting\nescapeXML ''\"test\" 'test' < & >''\n=> \"&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;\"\n```\n\n  \n\nLocated at [lib/strings.nix:432](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L432) in `<nixpkgs>`."
- name: lib.strings.fileContents
  summary: null
  description: "## `lib.strings.fileContents`\n\n##### `fileContents :: path -> string`\n\nRead the contents of a file removing the trailing \\n\n\n `file`  \nFunction argument\n\n**Example: lib.strings.fileContents usage example**\n\n``` programlisting\n$ echo \"1.0\" > ./version\n\nfileContents ./version\n=> \"1.0\"\n```\n\n  \n\nLocated at [lib/strings.nix:802](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L802) in `<nixpkgs>`."
- name: lib.strings.fixedWidthNumber
  summary: Format a number adding leading zeroes up to fixed width
  description: "## `lib.strings.fixedWidthNumber`\n\nFormat a number adding leading zeroes up to fixed width.\n\n `width`  \nFunction argument\n\n `n`  \nFunction argument\n\n**Example: lib.strings.fixedWidthNumber usage example**\n\n``` programlisting\nfixedWidthNumber 5 15\n=> \"00015\"\n```\n\n  \n\nLocated at [lib/strings.nix:703](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L703) in `<nixpkgs>`."
- name: lib.strings.fixedWidthString
  summary: Create a fixed width string with additional prefix to match required width
  description: "## `lib.strings.fixedWidthString`\n\n##### `fixedWidthString :: int -> string -> string -> string`\n\nCreate a fixed width string with additional prefix to match required width.\n\nThis function will fail if the input string is longer than the requested length.\n\n `width`  \nFunction argument\n\n `filler`  \nFunction argument\n\n `str`  \nFunction argument\n\n**Example: lib.strings.fixedWidthString usage example**\n\n``` programlisting\nfixedWidthString 5 \"0\" (toString 15)\n=> \"00015\"\n```\n\n  \n\nLocated at [lib/strings.nix:686](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L686) in `<nixpkgs>`."
- name: lib.strings.floatToString
  summary: null
  description: "## `lib.strings.floatToString`\n\nConvert a float to a string, but emit a warning when precision is lost during the conversion\n\n `float`  \nFunction argument\n\n**Example: lib.strings.floatToString usage example**\n\n``` programlisting\nfloatToString 0.000001\n=> \"0.000001\"\nfloatToString 0.0000001\n=> trace: warning: Imprecise conversion from float to string 0.000000\n\"0.000000\"\n```\n\n  \n\nLocated at [lib/strings.nix:715](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L715) in `<nixpkgs>`."
- name: lib.strings.getName
  summary: This function takes an argument that's either a derivation or a derivation's "name" attribute and extracts the name part from that argument
  description: "## `lib.strings.getName`\n\nThis function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the name part from that argument.\n\n `x`  \nFunction argument\n\n**Example: lib.strings.getName usage example**\n\n``` programlisting\ngetName \"youtube-dl-2016.01.01\"\n=> \"youtube-dl\"\ngetName pkgs.youtube-dl\n=> \"youtube-dl\"\n```\n\n  \n\nLocated at [lib/strings.nix:586](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L586) in `<nixpkgs>`."
- name: lib.strings.getVersion
  summary: This function takes an argument that's either a derivation or a derivation's "name" attribute and extracts the version part from that argument
  description: "## `lib.strings.getVersion`\n\nThis function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the version part from that argument.\n\n `x`  \nFunction argument\n\n**Example: lib.strings.getVersion usage example**\n\n``` programlisting\ngetVersion \"youtube-dl-2016.01.01\"\n=> \"2016.01.01\"\ngetVersion pkgs.youtube-dl\n=> \"2016.01.01\"\n```\n\n  \n\nLocated at [lib/strings.nix:603](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L603) in `<nixpkgs>`."
- name: lib.strings.hasInfix
  summary: null
  description: "## `lib.strings.hasInfix`\n\n##### `hasInfix :: string -> string -> bool`\n\nDetermine whether a string contains the given infix\n\n `infix`  \nFunction argument\n\n `content`  \nFunction argument\n\n**Example: lib.strings.hasInfix usage example**\n\n``` programlisting\nhasInfix \"bc\" \"abcd\"\n=> true\nhasInfix \"ab\" \"abcd\"\n=> true\nhasInfix \"cd\" \"abcd\"\n=> true\nhasInfix \"foo\" \"abcd\"\n=> false\n```\n\n  \n\nLocated at [lib/strings.nix:256](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L256) in `<nixpkgs>`."
- name: lib.strings.hasPrefix
  summary: Determine whether a string has given prefix
  description: "## `lib.strings.hasPrefix`\n\n##### `hasPrefix :: string -> string -> bool`\n\nDetermine whether a string has given prefix.\n\n `pref`  \nPrefix to check for\n\n `str`  \nInput string\n\n**Example: lib.strings.hasPrefix usage example**\n\n``` programlisting\nhasPrefix \"foo\" \"foobar\"\n=> true\nhasPrefix \"foo\" \"barfoo\"\n=> false\n```\n\n  \n\nLocated at [lib/strings.nix:215](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L215) in `<nixpkgs>`."
- name: lib.strings.hasSuffix
  summary: Determine whether a string has given suffix
  description: "## `lib.strings.hasSuffix`\n\n##### `hasSuffix :: string -> string -> bool`\n\nDetermine whether a string has given suffix.\n\n `suffix`  \nSuffix to check for\n\n `content`  \nInput string\n\n**Example: lib.strings.hasSuffix usage example**\n\n``` programlisting\nhasSuffix \"foo\" \"foobar\"\n=> false\nhasSuffix \"foo\" \"barfoo\"\n=> true\n```\n\n  \n\nLocated at [lib/strings.nix:231](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L231) in `<nixpkgs>`."
- name: lib.strings.intersperse
  summary: null
  description: "## `lib.strings.intersperse`\n\n##### `intersperse :: a -> [a] -> [a]`\n\nPlace an element between each element of a list\n\n `separator`  \nSeparator to add between elements\n\n `list`  \nInput list\n\n**Example: lib.strings.intersperse usage example**\n\n``` programlisting\nintersperse \"/\" [\"usr\" \"local\" \"bin\"]\n=> [\"usr\" \"/\" \"local\" \"/\" \"bin\"].\n```\n\n  \n\nLocated at [lib/strings.nix:75](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L75) in `<nixpkgs>`."
- name: lib.strings.isCoercibleToString
  summary: null
  description: "## `lib.strings.isCoercibleToString`\n\nCheck whether a value can be coerced to a string\n\n `x`  \nFunction argument\n\nLocated at [lib/strings.nix:722](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L722) in `<nixpkgs>`."
- name: lib.strings.isStorePath
  summary: Check whether a value is a store path
  description: "## `lib.strings.isStorePath`\n\nCheck whether a value is a store path.\n\n `x`  \nFunction argument\n\n**Example: lib.strings.isStorePath usage example**\n\n``` programlisting\nisStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11/bin/python\"\n=> false\nisStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11\"\n=> true\nisStorePath pkgs.python\n=> true\nisStorePath [] || isStorePath 42 || isStorePath {} || …\n=> false\n```\n\n  \n\nLocated at [lib/strings.nix:740](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L740) in `<nixpkgs>`."
- name: lib.strings.isValidPosixName
  summary: Test whether the given name is a valid POSIX shell variable name
  description: "## `lib.strings.isValidPosixName`\n\n##### `string -> bool`\n\nTest whether the given name is a valid POSIX shell variable name.\n\n `name`  \nFunction argument\n\n**Example: lib.strings.isValidPosixName usage example**\n\n``` programlisting\nisValidPosixName \"foo_bar000\"\n=> true\nisValidPosixName \"0-bad.jpg\"\n=> false\n```\n\n  \n\nLocated at [lib/strings.nix:338](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L338) in `<nixpkgs>`."
- name: lib.strings.levenshtein
  summary: Computes the Levenshtein distance between two strings
  description: "## `lib.strings.levenshtein`\n\n##### `levenshtein :: string -> string -> int`\n\nComputes the Levenshtein distance between two strings. Complexity O(n\\*m) where n and m are the lengths of the strings. Algorithm adjusted from https://stackoverflow.com/a/9750974/6605742\n\n `a`  \nFunction argument\n\n `b`  \nFunction argument\n\n**Example: lib.strings.levenshtein usage example**\n\n``` programlisting\nlevenshtein \"foo\" \"foo\"\n=> 0\nlevenshtein \"book\" \"hook\"\n=> 1\nlevenshtein \"hello\" \"Heyo\"\n=> 3\n```\n\n  \n\nLocated at [lib/strings.nix:856](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L856) in `<nixpkgs>`."
- name: lib.strings.levenshteinAtMost
  summary: null
  description: "## `lib.strings.levenshteinAtMost`\n\n##### `levenshteinAtMost :: int -> string -> string -> bool`\n\nReturns whether the levenshtein distance between two strings is at most some value Complexity is O(min(n,m)) for k \\<= 2 and O(n\\*m) otherwise\n\n**Example: lib.strings.levenshteinAtMost usage example**\n\n``` programlisting\nlevenshteinAtMost 0 \"foo\" \"foo\"\n=> true\nlevenshteinAtMost 1 \"foo\" \"boa\"\n=> false\nlevenshteinAtMost 2 \"foo\" \"boa\"\n=> true\nlevenshteinAtMost 2 \"This is a sentence\" \"this is a sentense.\"\n=> false\nlevenshteinAtMost 3 \"This is a sentence\" \"this is a sentense.\"\n=> true\n```\n\n  \n\nLocated at [lib/strings.nix:909](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L909) in `<nixpkgs>`."
- name: lib.strings.makeBinPath
  summary: Construct a binary search path (such as $PATH) containing the binaries for a set of packages
  description: "## `lib.strings.makeBinPath`\n\nConstruct a binary search path (such as $PATH) containing the binaries for a set of packages.\n\n**Example: lib.strings.makeBinPath usage example**\n\n``` programlisting\nmakeBinPath [\"/root\" \"/usr\" \"/usr/local\"]\n=> \"/root/bin:/usr/bin:/usr/local/bin\"\n```\n\n  \n\nLocated at [lib/strings.nix:186](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L186) in `<nixpkgs>`."
- name: lib.strings.makeLibraryPath
  summary: null
  description: "## `lib.strings.makeLibraryPath`\n\nConstruct a library search path (such as RPATH) containing the libraries for a set of packages\n\n**Example: lib.strings.makeLibraryPath usage example**\n\n``` programlisting\nmakeLibraryPath [ \"/usr\" \"/usr/local\" ]\n=> \"/usr/lib:/usr/local/lib\"\npkgs = import <nixpkgs> { }\nmakeLibraryPath [ pkgs.openssl pkgs.zlib ]\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r/lib:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/lib\"\n```\n\n  \n\nLocated at [lib/strings.nix:177](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L177) in `<nixpkgs>`."
- name: lib.strings.makeSearchPath
  summary: Construct a Unix-style, colon-separated search path consisting of the given `subDir` appended to each of the given paths
  description: "## `lib.strings.makeSearchPath`\n\n##### `makeSearchPath :: string -> [string] -> string`\n\nConstruct a Unix-style, colon-separated search path consisting of the given \\`subDir\\` appended to each of the given paths.\n\n `subDir`  \nDirectory name to append\n\n `paths`  \nList of base paths\n\n**Example: lib.strings.makeSearchPath usage example**\n\n``` programlisting\nmakeSearchPath \"bin\" [\"/root\" \"/usr\" \"/usr/local\"]\n=> \"/root/bin:/usr/bin:/usr/local/bin\"\nmakeSearchPath \"bin\" [\"\"]\n=> \"/bin\"\n```\n\n  \n\nLocated at [lib/strings.nix:141](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L141) in `<nixpkgs>`."
- name: lib.strings.makeSearchPathOutput
  summary: Construct a Unix-style search path by appending the given `subDir` to the specified `output` of each of the packages
  description: "## `lib.strings.makeSearchPathOutput`\n\n##### `string -> string -> [package] -> string`\n\nConstruct a Unix-style search path by appending the given \\`subDir\\` to the specified \\`output\\` of each of the packages. If no output by the given name is found, fallback to \\`.out\\` and then to the default.\n\n `output`  \nPackage output to use\n\n `subDir`  \nDirectory name to append\n\n `pkgs`  \nList of packages\n\n**Example: lib.strings.makeSearchPathOutput usage example**\n\n``` programlisting\nmakeSearchPathOutput \"dev\" \"bin\" [ pkgs.openssl pkgs.zlib ]\n=> \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev/bin:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/bin\"\n```\n\n  \n\nLocated at [lib/strings.nix:159](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L159) in `<nixpkgs>`."
- name: lib.strings.nameFromURL
  summary: Extract name with version from URL
  description: "## `lib.strings.nameFromURL`\n\nExtract name with version from URL. Ask for separator which is supposed to start extension.\n\n `url`  \nFunction argument\n\n `sep`  \nFunction argument\n\n**Example: lib.strings.nameFromURL usage example**\n\n``` programlisting\nnameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"-\"\n=> \"nix\"\nnameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"_\"\n=> \"nix-1.7-x86\"\n```\n\n  \n\nLocated at [lib/strings.nix:619](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L619) in `<nixpkgs>`."
- name: lib.strings.optionalString
  summary: Depending on the boolean `cond', return either the given string or the empty string
  description: "## `lib.strings.optionalString`\n\n##### `optionalString :: bool -> string -> string`\n\nDepending on the boolean \\`cond', return either the given string or the empty string. Useful to concatenate against a bigger string.\n\n `cond`  \nCondition\n\n `string`  \nString to return if condition is true\n\n**Example: lib.strings.optionalString usage example**\n\n``` programlisting\noptionalString true \"some-string\"\n=> \"some-string\"\noptionalString false \"some-string\"\n=> \"\"\n```\n\n  \n\nLocated at [lib/strings.nix:199](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L199) in `<nixpkgs>`."
- name: lib.strings.readPathsFromFile
  summary: Read a list of paths from `file`, relative to the `rootPath`. Lines beginning with `#` are treated as comments and ignored
  description: "## `lib.strings.readPathsFromFile`\n\nRead a list of paths from \\`file\\`, relative to the \\`rootPath\\`. Lines beginning with \\`#\\` are treated as comments and ignored. Whitespace is significant.\n\nNOTE: This function is not performant and should be avoided.\n\n**Example: lib.strings.readPathsFromFile usage example**\n\n``` programlisting\nreadPathsFromFile /prefix\n./pkgs/development/libraries/qt-5/5.4/qtbase/series\n=> [ \"/prefix/dlopen-resolv.patch\" \"/prefix/tzdir.patch\"\n\"/prefix/dlopen-libXcursor.patch\" \"/prefix/dlopen-openssl.patch\"\n\"/prefix/dlopen-dbus.patch\" \"/prefix/xdg-config-dirs.patch\"\n\"/prefix/nix-profiles-library-paths.patch\"\n\"/prefix/compose-search-path.patch\" ]\n```\n\n  \n\nLocated at [lib/strings.nix:782](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L782) in `<nixpkgs>`."
- name: lib.strings.removePrefix
  summary: Return a string without the specified prefix, if the prefix matches
  description: "## `lib.strings.removePrefix`\n\n##### `string -> string -> string`\n\nReturn a string without the specified prefix, if the prefix matches.\n\n `prefix`  \nPrefix to remove if it matches\n\n `str`  \nInput string\n\n**Example: lib.strings.removePrefix usage example**\n\n``` programlisting\nremovePrefix \"foo.\" \"foo.bar.baz\"\n=> \"bar.baz\"\nremovePrefix \"xxx\" \"foo.bar.baz\"\n=> \"foo.bar.baz\"\n```\n\n  \n\nLocated at [lib/strings.nix:516](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L516) in `<nixpkgs>`."
- name: lib.strings.removeSuffix
  summary: Return a string without the specified suffix, if the suffix matches
  description: "## `lib.strings.removeSuffix`\n\n##### `string -> string -> string`\n\nReturn a string without the specified suffix, if the suffix matches.\n\n `suffix`  \nSuffix to remove if it matches\n\n `str`  \nInput string\n\n**Example: lib.strings.removeSuffix usage example**\n\n``` programlisting\nremoveSuffix \"front\" \"homefront\"\n=> \"home\"\nremoveSuffix \"xxx\" \"homefront\"\n=> \"homefront\"\n```\n\n  \n\nLocated at [lib/strings.nix:540](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L540) in `<nixpkgs>`."
- name: lib.strings.sanitizeDerivationName
  summary: Creates a valid derivation name from a potentially invalid one
  description: "## `lib.strings.sanitizeDerivationName`\n\n##### `sanitizeDerivationName :: String -> String`\n\nCreates a valid derivation name from a potentially invalid one.\n\n**Example: lib.strings.sanitizeDerivationName usage example**\n\n``` programlisting\nsanitizeDerivationName \"../hello.bar # foo\"\n=> \"-hello.bar-foo\"\nsanitizeDerivationName \"\"\n=> \"unknown\"\nsanitizeDerivationName pkgs.hello\n=> \"-nix-store-2g75chlbpxlrqn15zlby2dfh8hr9qwbk-hello-2.10\"\n```\n\n  \n\nLocated at [lib/strings.nix:817](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L817) in `<nixpkgs>`."
- name: lib.strings.splitString
  summary: Cut a string with a separator and produces a list of strings which were separated by this separator
  description: "## `lib.strings.splitString`\n\nCut a string with a separator and produces a list of strings which were separated by this separator.\n\n `_sep`  \nFunction argument\n\n `_s`  \nFunction argument\n\n**Example: lib.strings.splitString usage example**\n\n``` programlisting\nsplitString \".\" \"foo.bar.baz\"\n=> [ \"foo\" \"bar\" \"baz\" ]\nsplitString \"/\" \"/usr/local/bin\"\n=> [ \"\" \"usr\" \"local\" \"bin\" ]\n```\n\n  \n\nLocated at [lib/strings.nix:498](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L498) in `<nixpkgs>`."
- name: lib.strings.stringAsChars
  summary: Manipulate a string character by character and replace them by strings before concatenating the results
  description: "## `lib.strings.stringAsChars`\n\n##### `stringAsChars :: (string -> string) -> string -> string`\n\nManipulate a string character by character and replace them by strings before concatenating the results.\n\n `f`  \nFunction to map over each individual character\n\n `s`  \nInput string\n\n**Example: lib.strings.stringAsChars usage example**\n\n``` programlisting\nstringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\"\n=> \"nix\"\n```\n\n  \n\nLocated at [lib/strings.nix:289](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L289) in `<nixpkgs>`."
- name: lib.strings.stringToCharacters
  summary: Convert a string to a list of characters (i.e
  description: "## `lib.strings.stringToCharacters`\n\n##### `stringToCharacters :: string -> [string]`\n\nConvert a string to a list of characters (i.e. singleton strings). This allows you to, e.g., map a function over each character. However, note that this will likely be horribly inefficient; Nix is not a general purpose programming language. Complex string manipulations should, if appropriate, be done in a derivation. Also note that Nix treats strings as a list of bytes and thus doesn't handle unicode.\n\n `s`  \nFunction argument\n\n**Example: lib.strings.stringToCharacters usage example**\n\n``` programlisting\nstringToCharacters \"\"\n=> [ ]\nstringToCharacters \"abc\"\n=> [ \"a\" \"b\" \"c\" ]\nstringToCharacters \"💩\"\n=> [ \"�\" \"�\" \"�\" \"�\" ]\n```\n\n  \n\nLocated at [lib/strings.nix:277](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L277) in `<nixpkgs>`."
- name: lib.strings.toInt
  summary: Parse a string as an int
  description: "## `lib.strings.toInt`\n\n##### `string -> int`\n\nParse a string as an int.\n\n `str`  \nFunction argument\n\n**Example: lib.strings.toInt usage example**\n\n``` programlisting\ntoInt \"1337\"\n=> 1337\ntoInt \"-4\"\n=> -4\ntoInt \"3.14\"\n=> error: floating point JSON numbers are not supported\n```\n\n  \n\nLocated at [lib/strings.nix:761](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L761) in `<nixpkgs>`."
- name: lib.strings.toLower
  summary: Converts an ASCII string to lower-case
  description: "## `lib.strings.toLower`\n\n##### `toLower :: string -> string`\n\nConverts an ASCII string to lower-case.\n\n**Example: lib.strings.toLower usage example**\n\n``` programlisting\ntoLower \"HOME\"\n=> \"home\"\n```\n\n  \n\nLocated at [lib/strings.nix:462](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L462) in `<nixpkgs>`."
- name: lib.strings.toShellVar
  summary: Translate a Nix value into a shell variable declaration, with proper escaping
  description: "## `lib.strings.toShellVar`\n\n##### `string -> (string | listOf string | attrsOf string) -> string`\n\nTranslate a Nix value into a shell variable declaration, with proper escaping.\n\nThe value can be a string (mapped to a regular variable), a list of strings (mapped to a Bash-style array) or an attribute set of strings (mapped to a Bash-style associative array). Note that \"string\" includes string-coercible values like paths or derivations.\n\nStrings are translated into POSIX sh-compatible code; lists and attribute sets assume a shell that understands Bash syntax (e.g. Bash or ZSH).\n\n `name`  \nFunction argument\n\n `value`  \nFunction argument\n\n**Example: lib.strings.toShellVar usage example**\n\n``` programlisting\n''\n${toShellVar \"foo\" \"some string\"}\n[[ \"$foo\" == \"some string\" ]]\n''\n```\n\n  \n\nLocated at [lib/strings.nix:358](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L358) in `<nixpkgs>`."
- name: lib.strings.toShellVars
  summary: null
  description: "## `lib.strings.toShellVars`\n\n##### `attrsOf (string | listOf string | attrsOf string) -> string`\n\nTranslate an attribute set into corresponding shell variable declarations using \\`toShellVar\\`.\n\n `vars`  \nFunction argument\n\n**Example: lib.strings.toShellVars usage example**\n\n``` programlisting\nlet\nfoo = \"value\";\nbar = foo;\nin ''\n${toShellVars { inherit foo bar; }}\n[[ \"$foo\" == \"$bar\" ]]\n''\n```\n\n  \n\nLocated at [lib/strings.nix:386](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L386) in `<nixpkgs>`."
- name: lib.strings.toUpper
  summary: Converts an ASCII string to upper-case
  description: "## `lib.strings.toUpper`\n\n##### `toUpper :: string -> string`\n\nConverts an ASCII string to upper-case.\n\n**Example: lib.strings.toUpper usage example**\n\n``` programlisting\ntoUpper \"home\"\n=> \"HOME\"\n```\n\n  \n\nLocated at [lib/strings.nix:472](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L472) in `<nixpkgs>`."
- name: lib.strings.versionAtLeast
  summary: Return true if string v1 denotes a version equal to or newer than v2
  description: "## `lib.strings.versionAtLeast`\n\nReturn true if string v1 denotes a version equal to or newer than v2.\n\n `v1`  \nFunction argument\n\n `v2`  \nFunction argument\n\n**Example: lib.strings.versionAtLeast usage example**\n\n``` programlisting\nversionAtLeast \"1.1\" \"1.0\"\n=> true\nversionAtLeast \"1.1\" \"1.1\"\n=> true\nversionAtLeast \"1.1\" \"1.2\"\n=> false\n```\n\n  \n\nLocated at [lib/strings.nix:574](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L574) in `<nixpkgs>`."
- name: lib.strings.versionOlder
  summary: Return true if string v1 denotes a version older than v2
  description: "## `lib.strings.versionOlder`\n\nReturn true if string v1 denotes a version older than v2.\n\n `v1`  \nFunction argument\n\n `v2`  \nFunction argument\n\n**Example: lib.strings.versionOlder usage example**\n\n``` programlisting\nversionOlder \"1.1\" \"1.2\"\n=> true\nversionOlder \"1.1\" \"1.1\"\n=> false\n```\n\n  \n\nLocated at [lib/strings.nix:562](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L562) in `<nixpkgs>`."
- name: lib.strings.withFeature
  summary: Create an --{with,without}-<feat> string that can be passed to standard GNU Autoconf scripts
  description: "## `lib.strings.withFeature`\n\nCreate an --{with,without}-\\<feat\\> string that can be passed to standard GNU Autoconf scripts.\n\n `with_`  \nFunction argument\n\n `feat`  \nFunction argument\n\n**Example: lib.strings.withFeature usage example**\n\n``` programlisting\nwithFeature true \"shared\"\n=> \"--with-shared\"\nwithFeature false \"shared\"\n=> \"--without-shared\"\n```\n\n  \n\nLocated at [lib/strings.nix:659](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L659) in `<nixpkgs>`."
- name: lib.strings.withFeatureAs
  summary: Create an --{with-<feat>=<value>,without-<feat>} string that can be passed to standard GNU Autoconf scripts
  description: "## `lib.strings.withFeatureAs`\n\nCreate an --{with-\\<feat\\>=\\<value\\>,without-\\<feat\\>} string that can be passed to standard GNU Autoconf scripts.\n\n `with_`  \nFunction argument\n\n `feat`  \nFunction argument\n\n `value`  \nFunction argument\n\n**Example: lib.strings.withFeatureAs usage example**\n\n``` programlisting\nwithFeatureAs true \"shared\" \"foo\"\n=> \"--with-shared=foo\"\nwithFeatureAs false \"shared\" (throw \"ignored\")\n=> \"--without-shared\"\n```\n\n  \n\nLocated at [lib/strings.nix:672](https://github.com/NixOS/nixpkgs/blob/master/lib/strings.nix#L672) in `<nixpkgs>`."
- name: lib.trivial.and
  summary: null
  description: "## `lib.trivial.and`\n\nboolean “and”\n\n `x`  \nFunction argument\n\n `y`  \nFunction argument\n\nLocated at [lib/trivial.nix:86](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L86) in `<nixpkgs>`."
- name: lib.trivial.bitAnd
  summary: null
  description: |-
    ## `lib.trivial.bitAnd`

    bitwise “and”

    Located at [lib/trivial.nix:89](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L89) in `<nixpkgs>`.
- name: lib.trivial.bitNot
  summary: null
  description: |-
    ## `lib.trivial.bitNot`

    bitwise “not”

    Located at [lib/trivial.nix:104](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L104) in `<nixpkgs>`.
- name: lib.trivial.bitOr
  summary: null
  description: |-
    ## `lib.trivial.bitOr`

    bitwise “or”

    Located at [lib/trivial.nix:94](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L94) in `<nixpkgs>`.
- name: lib.trivial.bitXor
  summary: null
  description: |-
    ## `lib.trivial.bitXor`

    bitwise “xor”

    Located at [lib/trivial.nix:99](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L99) in `<nixpkgs>`.
- name: lib.trivial.boolToString
  summary: Convert a boolean to a string
  description: "## `lib.trivial.boolToString`\n\n##### `boolToString :: bool -> string`\n\nConvert a boolean to a string.\n\nThis function uses the strings \"true\" and \"false\" to represent boolean values. Calling \\`toString\\` on a bool instead returns \"1\" and \"\" (sic!).\n\n `b`  \nFunction argument\n\nLocated at [lib/trivial.nix:114](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L114) in `<nixpkgs>`."
- name: lib.trivial.checkListOfEnum
  summary: Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise
  description: "## `lib.trivial.checkListOfEnum`\n\n##### `String -> List ComparableVal -> List ComparableVal -> a -> a`\n\nCheck if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise.\n\n `msg`  \nFunction argument\n\n `valid`  \nFunction argument\n\n `given`  \nFunction argument\n\n**Example: lib.trivial.checkListOfEnum usage example**\n\n``` programlisting\nlet colorVariants = [\"bright\" \"dark\" \"black\"]\nin checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants;\n=>\nerror: color variants: bright, black unexpected; valid ones: standard, light, dark\n```\n\n  \n\nLocated at [lib/trivial.nix:398](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L398) in `<nixpkgs>`."
- name: lib.trivial.codeName
  summary: Returns the current nixpkgs release code name
  description: |-
    ## `lib.trivial.codeName`

    Returns the current nixpkgs release code name.

    On each release the first letter is bumped and a new animal is chosen starting with that new letter.

    Located at [lib/trivial.nix:198](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L198) in `<nixpkgs>`.
- name: lib.trivial.compare
  summary: null
  description: "## `lib.trivial.compare`\n\nC-style comparisons\n\na \\< b, compare a b =\\> -1 a == b, compare a b =\\> 0 a \\> b, compare a b =\\> 1\n\n `a`  \nFunction argument\n\n `b`  \nFunction argument\n\nLocated at [lib/trivial.nix:260](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L260) in `<nixpkgs>`."
- name: lib.trivial.concat
  summary: null
  description: "## `lib.trivial.concat`\n\n##### `concat :: [a] -> [a] -> [a]`\n\nConcatenate two lists\n\n `x`  \nFunction argument\n\n `y`  \nFunction argument\n\n**Example: lib.trivial.concat usage example**\n\n``` programlisting\nconcat [ 1 2 ] [ 3 4 ]\n=> [ 1 2 3 4 ]\n```\n\n  \n\nLocated at [lib/trivial.nix:80](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L80) in `<nixpkgs>`."
- name: lib.trivial.const
  summary: Ignores the second argument
  description: "## `lib.trivial.const`\n\n##### `const :: a -> b -> a`\n\nThe constant function\n\nIgnores the second argument. If called with only one argument, constructs a function that always returns a static value.\n\n `x`  \nValue to return\n\n `y`  \nValue to ignore\n\n**Example: lib.trivial.const usage example**\n\n``` programlisting\nlet f = const 5; in f 10\n=> 5\n```\n\n  \n\nLocated at [lib/trivial.nix:26](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L26) in `<nixpkgs>`."
- name: lib.trivial.flip
  summary: Flip the order of the arguments of a binary function
  description: "## `lib.trivial.flip`\n\n##### `flip :: (a -> b -> c) -> (b -> a -> c)`\n\nFlip the order of the arguments of a binary function.\n\n `f`  \nFunction argument\n\n `a`  \nFunction argument\n\n `b`  \nFunction argument\n\n**Example: lib.trivial.flip usage example**\n\n``` programlisting\nflip concat [1] [2]\n=> [ 2 1 ]\n```\n\n  \n\nLocated at [lib/trivial.nix:138](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L138) in `<nixpkgs>`."
- name: lib.trivial.functionArgs
  summary: Extract the expected function arguments from a function
  description: "## `lib.trivial.functionArgs`\n\nExtract the expected function arguments from a function. This works both with nix-native { a, b ? foo, ... }: style functions and functions with args set with 'setFunctionArgs'. It has the same return type and semantics as builtins.functionArgs. setFunctionArgs : (a → b) → Map String Bool.\n\n `f`  \nFunction argument\n\nLocated at [lib/trivial.nix:433](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L433) in `<nixpkgs>`."
- name: lib.trivial.id
  summary: null
  description: "## `lib.trivial.id`\n\n##### `id :: a -> a`\n\nThe identity function For when you need a function that does “nothing”.\n\n `x`  \nThe value to return\n\nLocated at [lib/trivial.nix:12](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L12) in `<nixpkgs>`."
- name: lib.trivial.importJSON
  summary: Reads a JSON file
  description: "## `lib.trivial.importJSON`\n\nReads a JSON file.\n\nType :: path -\\> any\n\n `path`  \nFunction argument\n\nLocated at [lib/trivial.nix:305](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L305) in `<nixpkgs>`."
- name: lib.trivial.importTOML
  summary: Reads a TOML file
  description: "## `lib.trivial.importTOML`\n\nReads a TOML file.\n\nType :: path -\\> any\n\n `path`  \nFunction argument\n\nLocated at [lib/trivial.nix:312](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L312) in `<nixpkgs>`."
- name: lib.trivial.inNixShell
  summary: Determine whether the function is being called from inside a Nix shell
  description: |-
    ## `lib.trivial.inNixShell`

    ##### `inNixShell :: bool`

    Determine whether the function is being called from inside a Nix shell.

    Located at [lib/trivial.nix:230](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L230) in `<nixpkgs>`.
- name: lib.trivial.isFunction
  summary: Check whether something is a function or something annotated with function args
  description: "## `lib.trivial.isFunction`\n\nCheck whether something is a function or something annotated with function args.\n\n `f`  \nFunction argument\n\nLocated at [lib/trivial.nix:441](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L441) in `<nixpkgs>`."
- name: lib.trivial.isInOldestRelease
  summary: release Release number of feature introduction as an integer, e.g
  description: "## `lib.trivial.isInOldestRelease`\n\nWhether a feature is supported in all supported releases (at the time of release branch-off, if applicable). See \\`oldestSupportedRelease\\`.\n\n `release`  \nRelease number of feature introduction as an integer, e.g. 2111 for 21.11. Set it to the upcoming release, matching the nixpkgs/.version file.\n\nLocated at [lib/trivial.nix:186](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L186) in `<nixpkgs>`."
- name: lib.trivial.mapNullable
  summary: Apply function if the supplied argument is non-null
  description: "## `lib.trivial.mapNullable`\n\nApply function if the supplied argument is non-null.\n\n `f`  \nFunction to call\n\n `a`  \nArgument to check for null before passing it to \\`f\\`\n\n**Example: lib.trivial.mapNullable usage example**\n\n``` programlisting\nmapNullable (x: x+1) null\n=> null\nmapNullable (x: x+1) 22\n=> 23\n```\n\n  \n\nLocated at [lib/trivial.nix:148](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L148) in `<nixpkgs>`."
- name: lib.trivial.max
  summary: Return maximum of two numbers
  description: "## `lib.trivial.max`\n\nReturn maximum of two numbers.\n\n `x`  \nFunction argument\n\n `y`  \nFunction argument\n\nLocated at [lib/trivial.nix:239](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L239) in `<nixpkgs>`."
- name: lib.trivial.mergeAttrs
  summary: null
  description: "## `lib.trivial.mergeAttrs`\n\nMerge two attribute sets shallowly, right side trumps left\n\nmergeAttrs :: attrs -\\> attrs -\\> attrs\n\n `x`  \nLeft attribute set\n\n `y`  \nRight attribute set (higher precedence for equal keys)\n\n**Example: lib.trivial.mergeAttrs usage example**\n\n``` programlisting\nmergeAttrs { a = 1; b = 2; } { b = 3; c = 4; }\n=> { a = 1; b = 3; c = 4; }\n```\n\n  \n\nLocated at [lib/trivial.nix:124](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L124) in `<nixpkgs>`."
- name: lib.trivial.min
  summary: Return minimum of two numbers
  description: "## `lib.trivial.min`\n\nReturn minimum of two numbers.\n\n `x`  \nFunction argument\n\n `y`  \nFunction argument\n\nLocated at [lib/trivial.nix:236](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L236) in `<nixpkgs>`."
- name: lib.trivial.mod
  summary: null
  description: "## `lib.trivial.mod`\n\nInteger modulus\n\n `base`  \nFunction argument\n\n `int`  \nFunction argument\n\n**Example: lib.trivial.mod usage example**\n\n``` programlisting\nmod 11 10\n=> 1\nmod 1 10\n=> 1\n```\n\n  \n\nLocated at [lib/trivial.nix:249](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L249) in `<nixpkgs>`."
- name: lib.trivial.oldestSupportedRelease
  summary: The latest release that is supported, at the time of release branch-off, if applicable
  description: |-
    ## `lib.trivial.oldestSupportedRelease`

    The latest release that is supported, at the time of release branch-off, if applicable.

    Ideally, out-of-tree modules should be able to evaluate cleanly with all supported Nixpkgs versions (master, release and old release until EOL). So if possible, deprecation warnings should take effect only when all out-of-tree expressions/libs/modules can upgrade to the new way without losing support for supported Nixpkgs versions.

    This release number allows deprecation warnings to be implemented such that they take effect as soon as the oldest release reaches end of life.

    Located at [lib/trivial.nix:180](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L180) in `<nixpkgs>`.
- name: lib.trivial.or
  summary: null
  description: "## `lib.trivial.or`\n\nboolean “or”\n\n `x`  \nFunction argument\n\n `y`  \nFunction argument\n\nLocated at [lib/trivial.nix:83](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L83) in `<nixpkgs>`."
- name: lib.trivial.pipe
  summary: Pipes a value through a list of functions, left to right
  description: "## `lib.trivial.pipe`\n\n##### `pipe :: a -> [<functions>] -> <return type of last function>`\n\nPipes a value through a list of functions, left to right.\n\n `val`  \nFunction argument\n\n `functions`  \nFunction argument\n\n**Example: lib.trivial.pipe usage example**\n\n``` programlisting\npipe 2 [\n(x: x + 2)  # 2 + 2 = 4\n(x: x * 2)  # 4 * 2 = 8\n]\n=> 8\n\n# ideal to do text transformations\npipe [ \"a/b\" \"a/c\" ] [\n\n# create the cp command\n(map (file: ''cp \"${src}/${file}\" $out\\n''))\n\n# concatenate all commands into one string\nlib.concatStrings\n\n# make that string into a nix derivation\n(pkgs.runCommand \"copy-to-out\" {})\n\n]\n=> <drv which copies all files to $out>\n\nThe output type of each function has to be the input type\nof the next function, and the last function returns the\nfinal value.\n```\n\n  \n\nLocated at [lib/trivial.nix:61](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L61) in `<nixpkgs>`."
- name: lib.trivial.release
  summary: Returns the current nixpkgs release number as string
  description: |-
    ## `lib.trivial.release`

    Returns the current nixpkgs release number as string.

    Located at [lib/trivial.nix:167](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L167) in `<nixpkgs>`.
- name: lib.trivial.revisionWithDefault
  summary: Attempts to return the the current revision of nixpkgs and returns the supplied default value otherwise
  description: "## `lib.trivial.revisionWithDefault`\n\n##### `revisionWithDefault :: string -> string`\n\nAttempts to return the the current revision of nixpkgs and returns the supplied default value otherwise.\n\n `default`  \nDefault value to return if revision can not be determined\n\nLocated at [lib/trivial.nix:212](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L212) in `<nixpkgs>`."
- name: lib.trivial.setFunctionArgs
  summary: Add metadata about expected function arguments to a function
  description: "## `lib.trivial.setFunctionArgs`\n\nAdd metadata about expected function arguments to a function. The metadata should match the format given by builtins.functionArgs, i.e. a set from expected argument to a bool representing whether that argument has a default or not. setFunctionArgs : (a → b) → Map String Bool → (a → b)\n\nThis function is necessary because you can't dynamically create a function of the { a, b ? foo, ... }: format, but some facilities like callPackage expect to be able to query expected arguments.\n\n `f`  \nFunction argument\n\n `args`  \nFunction argument\n\nLocated at [lib/trivial.nix:421](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L421) in `<nixpkgs>`."
- name: lib.trivial.splitByAndCompare
  summary: Split type into two subtypes by predicate `p`, take all elements of the first subtype to be less than all the elements of the second subtype, compare elements of a single subtype with `yes` and `no` respectively
  description: "## `lib.trivial.splitByAndCompare`\n\n##### `(a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int)`\n\nSplit type into two subtypes by predicate \\`p\\`, take all elements of the first subtype to be less than all the elements of the second subtype, compare elements of a single subtype with \\`yes\\` and \\`no\\` respectively.\n\n `p`  \nPredicate\n\n `yes`  \nComparison function if predicate holds for both values\n\n `no`  \nComparison function if predicate holds for neither value\n\n `a`  \nFirst value to compare\n\n `b`  \nSecond value to compare\n\n**Example: lib.trivial.splitByAndCompare usage example**\n\n``` programlisting\nlet cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in\n\ncmp \"a\" \"z\" => -1\ncmp \"fooa\" \"fooz\" => -1\n\ncmp \"f\" \"a\" => 1\ncmp \"fooa\" \"a\" => -1\n# while\ncompare \"fooa\" \"a\" => 1\n```\n\n  \n\nLocated at [lib/trivial.nix:285](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L285) in `<nixpkgs>`."
- name: lib.trivial.throwIf
  summary: null
  description: "## `lib.trivial.throwIf`\n\n##### `bool -> string -> a -> a`\n\nLike throwIfNot, but negated (throw if the first argument is \\`true\\`).\n\n `cond`  \nFunction argument\n\n `msg`  \nFunction argument\n\nLocated at [lib/trivial.nix:386](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L386) in `<nixpkgs>`."
- name: lib.trivial.throwIfNot
  summary: Like the `assert b; e` expression, but with a custom error message and without the semicolon
  description: "## `lib.trivial.throwIfNot`\n\n##### `bool -> string -> a -> a`\n\nLike the \\`assert b; e\\` expression, but with a custom error message and without the semicolon.\n\nIf true, return the identity function, \\`r: r\\`.\n\nIf false, throw the error message.\n\nCalls can be juxtaposed using function application, as \\`(r: r) a = a\\`, so \\`(r: r) (r: r) a = a\\`, and so forth.\n\n `cond`  \nFunction argument\n\n `msg`  \nFunction argument\n\n**Example: lib.trivial.throwIfNot usage example**\n\n``` programlisting\n\nthrowIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\"\nlib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays\npkgs\n```\n\n  \n\nLocated at [lib/trivial.nix:379](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L379) in `<nixpkgs>`."
- name: lib.trivial.toBaseDigits
  summary: '`toBaseDigits base i` converts the positive integer i to a list of its digits in the given base'
  description: "## `lib.trivial.toBaseDigits`\n\n\\`toBaseDigits base i\\` converts the positive integer i to a list of its digits in the given base. For example:\n\ntoBaseDigits 10 123 =\\> \\[ 1 2 3 \\]\n\ntoBaseDigits 2 6 =\\> \\[ 1 1 0 \\]\n\ntoBaseDigits 16 250 =\\> \\[ 15 10 \\]\n\n `base`  \nFunction argument\n\n `i`  \nFunction argument\n\nLocated at [lib/trivial.nix:498](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L498) in `<nixpkgs>`."
- name: lib.trivial.toFunction
  summary: Turns any non-callable values into constant functions
  description: "## `lib.trivial.toFunction`\n\nTurns any non-callable values into constant functions. Returns callable values as is.\n\n `v`  \nAny value\n\n**Example: lib.trivial.toFunction usage example**\n\n``` programlisting\n\nnix-repl> lib.toFunction 1 2\n1\n\nnix-repl> lib.toFunction (x: x + 1) 2\n3\n```\n\n  \n\nLocated at [lib/trivial.nix:456](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L456) in `<nixpkgs>`."
- name: lib.trivial.toHexString
  summary: Convert the given positive integer to a string of its hexadecimal representation
  description: "## `lib.trivial.toHexString`\n\nConvert the given positive integer to a string of its hexadecimal representation. For example:\n\ntoHexString 0 =\\> \"0\"\n\ntoHexString 16 =\\> \"10\"\n\ntoHexString 250 =\\> \"FA\"\n\n `i`  \nFunction argument\n\nLocated at [lib/trivial.nix:472](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L472) in `<nixpkgs>`."
- name: lib.trivial.version
  summary: Returns the current full nixpkgs version number
  description: |-
    ## `lib.trivial.version`

    Returns the current full nixpkgs version number.

    Located at [lib/trivial.nix:164](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L164) in `<nixpkgs>`.
- name: lib.trivial.versionSuffix
  summary: Returns the current nixpkgs version suffix as string
  description: |-
    ## `lib.trivial.versionSuffix`

    Returns the current nixpkgs version suffix as string.

    Located at [lib/trivial.nix:201](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L201) in `<nixpkgs>`.
- name: lib.trivial.warn
  summary: Print a warning before returning the second argument
  description: |-
    ## `lib.trivial.warn`

    ##### `string -> a -> a`

    Print a warning before returning the second argument. This function behaves like \`builtins.trace\`, but requires a string message and formats it as a warning, including the \`warning: \` prefix.

    To get a call stack trace and abort evaluation, set the environment variable \`NIX_ABORT_ON_WARN=true\` and set the Nix options \`--option pure-eval false --show-trace\`

    Located at [lib/trivial.nix:340](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L340) in `<nixpkgs>`.
- name: lib.trivial.warnIf
  summary: null
  description: "## `lib.trivial.warnIf`\n\n##### `bool -> string -> a -> a`\n\nLike warn, but only warn when the first argument is \\`true\\`.\n\n `cond`  \nFunction argument\n\n `msg`  \nFunction argument\n\nLocated at [lib/trivial.nix:350](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L350) in `<nixpkgs>`."
- name: lib.trivial.warnIfNot
  summary: null
  description: "## `lib.trivial.warnIfNot`\n\n##### `bool -> string -> a -> a`\n\nLike warnIf, but negated (warn if the first argument is \\`false\\`).\n\n `cond`  \nFunction argument\n\n `msg`  \nFunction argument\n\nLocated at [lib/trivial.nix:357](https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L357) in `<nixpkgs>`."
- name: pkgs.appimageTools
  summary: pkgs.appimageTools is a set of functions for extracting and wrapping AppImage files
  description: |-
    ## `pkgs.appimageTools`

    `pkgs.appimageTools` is a set of functions for extracting and wrapping [AppImage](https://appimage.org/) files. They are meant to be used if traditional packaging from source is infeasible, or it would take too long. To quickly run an AppImage file, `pkgs.appimage-run` can be used as well.

    Warning

    The `appimageTools` API is unstable and may be subject to backwards-incompatible changes in the future.

    ### `AppImage formats`

    There are different formats for AppImages, see [the specification](https://github.com/AppImage/AppImageSpec/blob/74ad9ca2f94bf864a4a0dac1f369dd4f00bd1c28/draft.md#image-format) for details.

    - Type 1 images are ISO 9660 files that are also ELF executables.

    - Type 2 images are ELF executables with an appended filesystem.

    They can be told apart with `file -k`:

    ``` programlisting
    $ file -k type1.AppImage
    type1.AppImage: ELF 64-bit LSB executable, x86-64, version 1 (SYSV) ISO 9660 CD-ROM filesystem data 'AppImage' (Lepton 3.x), scale 0-0,
    spot sensor temperature 0.000000, unit celsius, color scheme 0, calibration: offset 0.000000, slope 0.000000, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.18, BuildID[sha1]=d629f6099d2344ad82818172add1d38c5e11bc6d, stripped\012- data

    $ file -k type2.AppImage
    type2.AppImage: ELF 64-bit LSB executable, x86-64, version 1 (SYSV) (Lepton 3.x), scale 232-60668, spot sensor temperature -4.187500, color scheme 15, show scale bar, calibration: offset -0.000000, slope 0.000000 (Lepton 2.x), scale 4111-45000, spot sensor temperature 412442.250000, color scheme 3, minimum point enabled, calibration: offset -75402534979642766821519867692934234112.000000, slope 5815371847733706829839455140374904832.000000, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.18, BuildID[sha1]=79dcc4e55a61c293c5e19edbd8d65b202842579f, stripped\012- data
    ```

    Note how the type 1 AppImage is described as an `ISO 9660 CD-ROM filesystem`, and the type 2 AppImage is not.

    ### `Wrapping`

    Depending on the type of AppImage you’re wrapping, you’ll have to use `wrapType1` or `wrapType2`.

    ``` programlisting
    appimageTools.wrapType2 { # or wrapType1
      name = "patchwork";
      src = fetchurl {
        url = "https://github.com/ssbc/patchwork/releases/download/v3.11.4/Patchwork-3.11.4-linux-x86_64.AppImage";
        sha256 = "1blsprpkvm0ws9b96gb36f0rbf8f5jgmw4x6dsb1kswr4ysf591s";
      };
      extraPkgs = pkgs: with pkgs; [ ];
    }
    ```

    - `name` specifies the name of the resulting image.

    - `src` specifies the AppImage file to extract.

    - `extraPkgs` allows you to pass a function to include additional packages inside the FHS environment your AppImage is going to run in. There are a few ways to learn which dependencies an application needs:

      - Looking through the extracted AppImage files, reading its scripts and running `patchelf` and `ldd` on its executables. This can also be done in `appimage-run`, by setting `APPIMAGE_DEBUG_EXEC=bash`.

      - Running `strace -vfefile` on the wrapped executable, looking for libraries that can’t be found.
- name: pkgs.buildFHSUserEnv
  summary: buildFHSUserEnv provides a way to build and run FHS-compatible lightweight sandboxes
  description: |-
    ## `pkgs.buildFHSUserEnv`

    `buildFHSUserEnv` provides a way to build and run FHS-compatible lightweight sandboxes. It creates an isolated root with bound `/nix/store`, so its footprint in terms of disk space needed is quite small. This allows one to run software which is hard or unfeasible to patch for NixOS – 3rd-party source trees with FHS assumptions, games distributed as tarballs, software with integrity checking and/or external self-updated binaries. It uses Linux namespaces feature to create temporary lightweight environments which are destroyed after all child processes exit, without root user rights requirement. Accepted arguments are:

    - `name` Environment name.

    - `targetPkgs` Packages to be installed for the main host’s architecture (i.e. x86_64 on x86_64 installations). Along with libraries binaries are also installed.

    - `multiPkgs` Packages to be installed for all architectures supported by a host (i.e. i686 and x86_64 on x86_64 installations). Only libraries are installed by default.

    - `extraBuildCommands` Additional commands to be executed for finalizing the directory structure.

    - `extraBuildCommandsMulti` Like `extraBuildCommands`, but executed only on multilib architectures.

    - `extraOutputsToInstall` Additional derivation outputs to be linked for both target and multi-architecture packages.

    - `extraInstallCommands` Additional commands to be executed for finalizing the derivation with runner script.

    - `runScript` A command that would be executed inside the sandbox and passed all the command line arguments. It defaults to `bash`.

    - `profile` Optional script for `/etc/profile` within the sandbox.

    One can create a simple environment using a `shell.nix` like that:

    ``` programlisting
    { pkgs ? import <nixpkgs> {} }:

    (pkgs.buildFHSUserEnv {
      name = "simple-x11-env";
      targetPkgs = pkgs: (with pkgs;
        [ udev
          alsa-lib
        ]) ++ (with pkgs.xorg;
        [ libX11
          libXcursor
          libXrandr
        ]);
      multiPkgs = pkgs: (with pkgs;
        [ udev
          alsa-lib
        ]);
      runScript = "bash";
    }).env
    ```

    Running `nix-shell` would then drop you into a shell with these libraries and binaries available. You can use this to run closed-source applications which expect FHS structure without hassles: simply change `runScript` to the application path, e.g. `./bin/start.sh` – relative paths are supported.

    Additionally, the FHS builder links all relocated gsettings-schemas (the glib setup-hook moves them to `share/gsettings-schemas/${name}/glib-2.0/schemas`) to their standard FHS location. This means you don’t need to wrap binaries with `wrapGAppsHook`.
- name: pkgs.dockerTools
  summary: pkgs.dockerTools is a set of functions for creating and manipulating Docker images according to the Docker Image Specification v1.2.0
  description: |-
    ## `pkgs.dockerTools`

    `pkgs.dockerTools` is a set of functions for creating and manipulating Docker images according to the [Docker Image Specification v1.2.0](https://github.com/moby/moby/blob/master/image/spec/v1.2.md#docker-image-specification-v120). Docker itself is not used to perform any of the operations done by these functions.
- name: pkgs.dockerTools.buildImage
  summary: This function is analogous to the docker build command, in that it can be used to build a Docker-compatible repository tarball containing a single image with one or multiple layers
  description: |-
    ### `pkgs.dockerTools.buildImage`

    This function is analogous to the `docker build` command, in that it can be used to build a Docker-compatible repository tarball containing a single image with one or multiple layers. As such, the result is suitable for being loaded in Docker with `docker load`.

    The parameters of `buildImage` with relative example values are described below:

    ``` programlisting
    buildImage {
      name = "redis";
      tag = "latest";

      fromImage = someBaseImage;
      fromImageName = null;
      fromImageTag = "latest";

      contents = pkgs.redis;
      runAsRoot = ''
        #!${pkgs.runtimeShell}
        mkdir -p /data
      '';

      config = {
        Cmd = [ "/bin/redis-server" ];
        WorkingDir = "/data";
        Volumes = { "/data" = { }; };
      };
    }
    ```

    The above example will build a Docker image `redis/latest` from the given base image. Loading and running this image in Docker results in `redis-server` being started automatically.

    - `name` specifies the name of the resulting image. This is the only required argument for `buildImage`.

    - `tag` specifies the tag of the resulting image. By default it’s `null`, which indicates that the nix output hash will be used as tag.

    - `fromImage` is the repository tarball containing the base image. It must be a valid Docker image, such as exported by `docker save`. By default it’s `null`, which can be seen as equivalent to `FROM scratch` of a `Dockerfile`.

    - `fromImageName` can be used to further specify the base image within the repository, in case it contains multiple images. By default it’s `null`, in which case `buildImage` will peek the first image available in the repository.

    - `fromImageTag` can be used to further specify the tag of the base image within the repository, in case an image contains multiple tags. By default it’s `null`, in which case `buildImage` will peek the first tag available for the base image.

    - `contents` is a derivation that will be copied in the new layer of the resulting image. This can be similarly seen as `ADD contents/ /` in a `Dockerfile`. By default it’s `null`.

    - `runAsRoot` is a bash script that will run as root in an environment that overlays the existing layers of the base image with the new resulting layer, including the previously copied `contents` derivation. This can be similarly seen as `RUN ...` in a `Dockerfile`.

    > ***NOTE:*** Using this parameter requires the `kvm` device to be available.

    - `config` is used to specify the configuration of the containers that will be started off the built image in Docker. The available options are listed in the [Docker Image Specification v1.2.0](https://github.com/moby/moby/blob/master/image/spec/v1.2.md#image-json-field-descriptions).

    After the new layer has been created, its closure (to which `contents`, `config` and `runAsRoot` contribute) will be copied in the layer itself. Only new dependencies that are not already in the existing layers will be copied.

    At the end of the process, only one new single layer will be produced and added to the resulting image.

    The resulting repository will only list the single image `image/tag`. In the case of [the `buildImage` example](#ex-dockerTools-buildImage), it would be `redis/latest`.

    It is possible to inspect the arguments with which an image was built using its `buildArgs` attribute.

    > ***NOTE:*** If you see errors similar to `getProtocolByName: does not exist (no such protocol name: tcp)` you may need to add `pkgs.iana-etc` to `contents`.

    > ***NOTE:*** If you see errors similar to `Error_Protocol ("certificate has unknown CA",True,UnknownCa)` you may need to add `pkgs.cacert` to `contents`.

    By default `buildImage` will use a static date of one second past the UNIX Epoch. This allows `buildImage` to produce binary reproducible images. When listing images with `docker images`, the newly created images will be listed like this:

    ``` programlisting
    $ docker images
    REPOSITORY   TAG      IMAGE ID       CREATED        SIZE
    hello        latest   08c791c7846e   48 years ago   25.2MB
    ```

    You can break binary reproducibility but have a sorted, meaningful `CREATED` column by setting `created` to `now`.

    ``` programlisting
    pkgs.dockerTools.buildImage {
      name = "hello";
      tag = "latest";
      created = "now";
      contents = pkgs.hello;

      config.Cmd = [ "/bin/hello" ];
    }
    ```

    Now the Docker CLI will display a reasonable date and sort the images as expected:

    ``` programlisting
    $ docker images
    REPOSITORY   TAG      IMAGE ID       CREATED              SIZE
    hello        latest   de2bf4786de6   About a minute ago   25.2MB
    ```

    However, the produced images will not be binary reproducible.
- name: pkgs.dockerTools.buildLayeredImage
  summary: Create a Docker image with many of the store paths being on their own layer to improve sharing between images
  description: "### `pkgs.dockerTools.buildLayeredImage`\n\nCreate a Docker image with many of the store paths being on their own layer to improve sharing between images. The image is realized into the Nix store as a gzipped tarball. Depending on the intended usage, many users might prefer to use `streamLayeredImage` instead, which this function uses internally.\n\n `name`  \nThe name of the resulting image.\n\n `tag`  *optional*  \nTag of the generated image.\n\n*Default:* the output path’s hash\n\n `fromImage`  *optional*  \nThe repository tarball containing the base image. It must be a valid Docker image, such as one exported by `docker save`.\n\n*Default:*`null`, which can be seen as equivalent to `FROM scratch` of a `Dockerfile`.\n\n `contents`  *optional*  \nTop-level paths in the container. Either a single derivation, or a list of derivations.\n\n*Default:* `[]`\n\n `config`  *optional*  \nRun-time configuration of the container. A full list of the options are available at in the [Docker Image Specification v1.2.0](https://github.com/moby/moby/blob/master/image/spec/v1.2.md#image-json-field-descriptions).\n\n*Default:* `{}`\n\n `created`  *optional*  \nDate and time the layers were created. Follows the same `now` exception supported by `buildImage`.\n\n*Default:* `1970-01-01T00:00:01Z`\n\n `maxLayers`  *optional*  \nMaximum number of layers to create.\n\n*Default:* `100`\n\n*Maximum:* `125`\n\n `extraCommands`  *optional*  \nShell commands to run while building the final layer, without access to most of the layer contents. Changes to this layer are “on top” of all the other layers, so can create additional directories and files.\n\n `fakeRootCommands`  *optional*  \nShell commands to run while creating the archive for the final layer in a fakeroot environment. Unlike `extraCommands`, you can run `chown` to change the owners of the files in the archive, changing fakeroot’s state instead of the real filesystem. The latter would require privileges that the build user does not have. Static binaries do not interact with the fakeroot environment. By default all files in the archive will be owned by root.\n\n `enableFakechroot`  *optional*  \nWhether to run in `fakeRootCommands` in `fakechroot`, making programs behave as though `/` is the root of the image being created, while files in the Nix store are available as usual. This allows scripts that perform installation in `/` to work as expected. Considering that `fakechroot` is implemented via the same mechanism as `fakeroot`, the same caveats apply.\n\n*Default:* `false`\n\n#### `Behavior of ``contents` in the final image\n\nEach path directly listed in `contents` will have a symlink in the root of the image.\n\nFor example:\n\n``` programlisting\npkgs.dockerTools.buildLayeredImage {\n  name = \"hello\";\n  contents = [ pkgs.hello ];\n}\n```\n\nwill create symlinks for all the paths in the `hello` package:\n\n``` programlisting\n/bin/hello -> /nix/store/h1zb1padqbbb7jicsvkmrym3r6snphxg-hello-2.10/bin/hello\n/share/info/hello.info -> /nix/store/h1zb1padqbbb7jicsvkmrym3r6snphxg-hello-2.10/share/info/hello.info\n/share/locale/bg/LC_MESSAGES/hello.mo -> /nix/store/h1zb1padqbbb7jicsvkmrym3r6snphxg-hello-2.10/share/locale/bg/LC_MESSAGES/hello.mo\n```\n\n#### `Automatic inclusion of ``config` references\n\nThe closure of `config` is automatically included in the closure of the final image.\n\nThis allows you to make very simple Docker images with very little code. This container will start up and run `hello`:\n\n``` programlisting\npkgs.dockerTools.buildLayeredImage {\n  name = \"hello\";\n  config.Cmd = [ \"${pkgs.hello}/bin/hello\" ];\n}\n```\n\n#### `Adjusting ` `maxLayers`\n\nIncreasing the `maxLayers` increases the number of layers which have a chance to be shared between different images.\n\nModern Docker installations support up to 128 layers, but older versions support as few as 42.\n\nIf the produced image will not be extended by other Docker builds, it is safe to set `maxLayers` to `128`. However, it will be impossible to extend the image further.\n\nThe first (`maxLayers-2`) most “popular” paths will have their own individual layers, then layer \\#`maxLayers-1` will contain all the remaining “unpopular” paths, and finally layer \\#`maxLayers` will contain the Image configuration.\n\nDocker’s Layers are not inherently ordered, they are content-addressable and are not explicitly layered until they are composed in to an Image."
- name: pkgs.dockerTools.exportImage
  summary: This function is analogous to the docker export command, in that it can be used to flatten a Docker image that contains multiple layers
  description: |-
    ### `pkgs.dockerTools.exportImage`

    This function is analogous to the `docker export` command, in that it can be used to flatten a Docker image that contains multiple layers. It is in fact the result of the merge of all the layers of the image. As such, the result is suitable for being imported in Docker with `docker import`.

    > ***NOTE:*** Using this function requires the `kvm` device to be available.

    The parameters of `exportImage` are the following:

    ``` programlisting
    exportImage {
      fromImage = someLayeredImage;
      fromImageName = null;
      fromImageTag = null;

      name = someLayeredImage.name;
    }
    ```

    The parameters relative to the base image have the same synopsis as described in [buildImage](#ssec-pkgs-dockerTools-buildImage "15.2.1. buildImage"), except that `fromImage` is the only required argument in this case.

    The `name` argument is the name of the derivation output, which defaults to `fromImage.name`.
- name: pkgs.dockerTools.pullImage
  summary: This function is analogous to the docker pull command, in that it can be used to pull a Docker image from a Docker registry
  description: |-
    ### `pkgs.dockerTools.pullImage`

    This function is analogous to the `docker pull` command, in that it can be used to pull a Docker image from a Docker registry. By default [Docker Hub](https://hub.docker.com/) is used to pull images.

    Its parameters are described in the example below:

    ``` programlisting
    pullImage {
      imageName = "nixos/nix";
      imageDigest =
        "sha256:20d9485b25ecfd89204e843a962c1bd70e9cc6858d65d7f5fadc340246e2116b";
      finalImageName = "nix";
      finalImageTag = "1.11";
      sha256 = "0mqjy3zq2v6rrhizgb9nvhczl87lcfphq9601wcprdika2jz7qh8";
      os = "linux";
      arch = "x86_64";
    }
    ```

    - `imageName` specifies the name of the image to be downloaded, which can also include the registry namespace (e.g. `nixos`). This argument is required.

    - `imageDigest` specifies the digest of the image to be downloaded. This argument is required.

    - `finalImageName`, if specified, this is the name of the image to be created. Note it is never used to fetch the image since we prefer to rely on the immutable digest ID. By default it’s equal to `imageName`.

    - `finalImageTag`, if specified, this is the tag of the image to be created. Note it is never used to fetch the image since we prefer to rely on the immutable digest ID. By default it’s `latest`.

    - `sha256` is the checksum of the whole fetched image. This argument is required.

    - `os`, if specified, is the operating system of the fetched image. By default it’s `linux`.

    - `arch`, if specified, is the cpu architecture of the fetched image. By default it’s `x86_64`.

    `nix-prefetch-docker` command can be used to get required image parameters:

    ``` programlisting
    $ nix run nixpkgs.nix-prefetch-docker -c nix-prefetch-docker --image-name mysql --image-tag 5
    ```

    Since a given `imageName` may transparently refer to a manifest list of images which support multiple architectures and/or operating systems, you can supply the `--os` and `--arch` arguments to specify exactly which image you want. By default it will match the OS and architecture of the host the command is run on.

    ``` programlisting
    $ nix-prefetch-docker --image-name mysql --image-tag 5 --arch x86_64 --os linux
    ```

    Desired image name and tag can be set using `--final-image-name` and `--final-image-tag` arguments:

    ``` programlisting
    $ nix-prefetch-docker --image-name mysql --image-tag 5 --final-image-name eu.gcr.io/my-project/mysql --final-image-tag prod
    ```
- name: pkgs.dockerTools.shadowSetup
  summary: This constant string is a helper for setting up the base files for managing users and groups, only if such files don’t exist already
  description: |-
    ### `pkgs.dockerTools.shadowSetup`

    This constant string is a helper for setting up the base files for managing users and groups, only if such files don’t exist already. It is suitable for being used in a [`buildImage``runAsRoot`](#ex-dockerTools-buildImage-runAsRoot) script for cases like in the example below:

    ``` programlisting
    buildImage {
      name = "shadow-basic";

      runAsRoot = ''
        #!${pkgs.runtimeShell}
        ${pkgs.dockerTools.shadowSetup}
        groupadd -r redis
        useradd -r -g redis redis
        mkdir /data
        chown redis:redis /data
      '';
    }
    ```

    Creating base files like `/etc/passwd` or `/etc/login.defs` is necessary for shadow-utils to manipulate users and groups.
- name: pkgs.dockerTools.streamLayeredImage
  summary: Builds a script which, when run, will stream an uncompressed tarball of a Docker image to stdout
  description: |-
    ### `pkgs.dockerTools.streamLayeredImage`

    Builds a script which, when run, will stream an uncompressed tarball of a Docker image to stdout. The arguments to this function are as for `buildLayeredImage`. This method of constructing an image does not realize the image into the Nix store, so it saves on IO and disk/cache space, particularly with large images.

    The image produced by running the output script can be piped directly into `docker load`, to load it into the local docker daemon:

    ``` programlisting
    $(nix-build) | docker load
    ```

    Alternatively, the image be piped via `gzip` into `skopeo`, e.g., to copy it into a registry:

    ``` programlisting
    $(nix-build) | gzip --fast | skopeo copy docker-archive:/dev/stdin docker://some_docker_registry/myimage:tag
    ```
- name: pkgs.fetchcvs
  summary: Used with CVS
  description: |-
    ## `pkgs.fetchcvs`

    Used with CVS. Expects `cvsRoot`, `tag`, and `sha256`.
- name: pkgs.fetchfossil
  summary: Used with Fossil
  description: |-
    ## `pkgs.fetchfossil`

    Used with Fossil. Expects `url` to a Fossil archive, `rev`, and `sha256`.
- name: pkgs.fetchFromBitbucket
  summary: This is used with BitBucket repositories
  description: |-
    ## `pkgs.fetchFromBitbucket`

    This is used with BitBucket repositories. The arguments expected are very similar to fetchFromGitHub above.
- name: pkgs.fetchFromGitea
  summary: fetchFromGitea expects five arguments
  description: |-
    ## `pkgs.fetchFromGitea`

    `fetchFromGitea` expects five arguments. `domain` is the gitea server name. `owner` is a string corresponding to the Gitea user or organization that controls this repository. `repo` corresponds to the name of the software repository. These are located at the top of every Gitea HTML page as `owner`/`repo`. `rev` corresponds to the Git commit hash or tag (e.g `v1.0`) that will be downloaded from Git. Finally, `sha256` corresponds to the hash of the extracted directory. Again, other hash algorithms are also available but `sha256` is currently preferred.
- name: pkgs.fetchFromGitHub
  summary: fetchFromGitHub expects four arguments
  description: |-
    ## `pkgs.fetchFromGitHub`

    `fetchFromGitHub` expects four arguments. `owner` is a string corresponding to the GitHub user or organization that controls this repository. `repo` corresponds to the name of the software repository. These are located at the top of every GitHub HTML page as `owner`/`repo`. `rev` corresponds to the Git commit hash or tag (e.g `v1.0`) that will be downloaded from Git. Finally, `sha256` corresponds to the hash of the extracted directory. Again, other hash algorithms are also available, but `sha256` is currently preferred.

    `fetchFromGitHub` uses `fetchzip` to download the source archive generated by GitHub for the specified revision. If `leaveDotGit`, `deepClone` or `fetchSubmodules` are set to `true`, `fetchFromGitHub` will use `fetchgit` instead. Refer to its section for documentation of these options.
- name: pkgs.fetchFromGitiles
  summary: This is used with Gitiles repositories
  description: |-
    ## `pkgs.fetchFromGitiles`

    This is used with Gitiles repositories. The arguments expected are similar to `fetchgit`.
- name: pkgs.fetchFromGitLab
  summary: This is used with GitLab repositories
  description: |-
    ## `pkgs.fetchFromGitLab`

    This is used with GitLab repositories. The arguments expected are very similar to `fetchFromGitHub` above.
- name: pkgs.fetchFromRepoOrCz
  summary: This is used with repo.or.cz repositories
  description: |-
    ## `pkgs.fetchFromRepoOrCz`

    This is used with repo.or.cz repositories. The arguments expected are very similar to `fetchFromGitHub` above.
- name: pkgs.fetchFromSavannah
  summary: This is used with Savannah repositories
  description: |-
    ## `pkgs.fetchFromSavannah`

    This is used with Savannah repositories. The arguments expected are very similar to `fetchFromGitHub` above.
- name: pkgs.fetchFromSourcehut
  summary: This is used with sourcehut repositories
  description: |-
    ## `pkgs.fetchFromSourcehut`

    This is used with sourcehut repositories. Similar to `fetchFromGitHub` above, it expects `owner`, `repo`, `rev` and `sha256`, but don’t forget the tilde (~) in front of the username! Expected arguments also include `vc` (“git” (default) or “hg”), `domain` and `fetchSubmodules`.

    If `fetchSubmodules` is `true`, `fetchFromSourcehut` uses `fetchgit` or `fetchhg` with `fetchSubmodules` or `fetchSubrepos` set to `true`, respectively. Otherwise, the fetcher uses `fetchzip`.
- name: pkgs.fetchgit
  summary: Used with Git
  description: |-
    ## `pkgs.fetchgit`

    Used with Git. Expects `url` to a Git repo, `rev`, and `sha256`. `rev` in this case can be full the git commit id (SHA1 hash) or a tag name like `refs/tags/v1.0`.

    Additionally, the following optional arguments can be given: `fetchSubmodules = true` makes `fetchgit` also fetch the submodules of a repository. If `deepClone` is set to true, the entire repository is cloned as opposing to just creating a shallow clone. `deepClone = true` also implies `leaveDotGit = true` which means that the `.git` directory of the clone won’t be removed after checkout.

    If only parts of the repository are needed, `sparseCheckout` can be used. This will prevent git from fetching unnecessary blobs from server, see [git sparse-checkout](https://git-scm.com/docs/git-sparse-checkout) and [git clone –filter](https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---filterltfilter-specgt) for more information:

    ``` programlisting
    { stdenv, fetchgit }:

    stdenv.mkDerivation {
      name = "hello";
      src = fetchgit {
        url = "https://...";
        sparseCheckout = ''
          path/to/be/included
          another/path
        '';
        sha256 = "0000000000000000000000000000000000000000000000000000";
      };
    }
    ```
- name: pkgs.fetchhg
  summary: Used with Mercurial
  description: |-
    ## `pkgs.fetchhg`

    Used with Mercurial. Expects `url`, `rev`, and `sha256`.

    A number of fetcher functions wrap part of `fetchurl` and `fetchzip`. They are mainly convenience functions intended for commonly used destinations of source code in Nixpkgs. These wrapper fetchers are listed below.
- name: pkgs.fetchsvn
  summary: Used with Subversion
  description: |-
    ## `pkgs.fetchsvn`

    Used with Subversion. Expects `url` to a Subversion directory, `rev`, and `sha256`.
- name: pkgs.mkShell
  summary: 'name (default: nix-shell). Set the name of the derivation'
  description: |-
    ## `pkgs.mkShell`

    `pkgs.mkShell` is a specialized `stdenv.mkDerivation` that removes some repetition when using it with `nix-shell` (or `nix develop`).

    ### Usage

    Here is a common usage example:

    ``` programlisting
    { pkgs ? import <nixpkgs> {} }:
    pkgs.mkShell {
      packages = [ pkgs.gnumake ];

      inputsFrom = [ pkgs.hello pkgs.gnutar ];

      shellHook = ''
        export DEBUG=1
      '';
    }
    ```

    ### Attributes

    - `name` (default: `nix-shell`). Set the name of the derivation.

    - `packages` (default: `[]`). Add executable packages to the `nix-shell` environment.

    - `inputsFrom` (default: `[]`). Add build dependencies of the listed derivations to the `nix-shell` environment.

    - `shellHook` (default: `""`). Bash statements that are executed by `nix-shell`.

    … all the attributes of `stdenv.mkDerivation`.

    ### Building the shell

    This derivation output will contain a text file that contains a reference to all the build inputs. This is useful in CI where we want to make sure that every derivation, and its dependencies, build properly. Or when creating a GC root so that the build dependencies don’t get garbage-collected.
- name: pkgs.ociTools
  summary: pkgs.ociTools is a set of functions for creating containers according to the OCI container specification v1.0.0
  description: |-
    ## `pkgs.ociTools`

    `pkgs.ociTools` is a set of functions for creating containers according to the [OCI container specification v1.0.0](https://github.com/opencontainers/runtime-spec). Beyond that, it makes no assumptions about the container runner you choose to use to run the created container.
- name: pkgs.ociTools.buildContainer
  summary: This function creates a simple OCI container that runs a single command inside of it
  description: |-
    ### `pkgs.ociTools.buildContainer`

    This function creates a simple OCI container that runs a single command inside of it. An OCI container consists of a `config.json` and a rootfs directory. The nix store of the container will contain all referenced dependencies of the given command.

    The parameters of `buildContainer` with an example value are described below:

    ``` programlisting
    buildContainer {
      args = [
        (with pkgs;
          writeScript "run.sh" ''
            #!${bash}/bin/bash
            exec ${bash}/bin/bash
          '').outPath
      ];

      mounts = {
        "/data" = {
          type = "none";
          source = "/var/lib/mydata";
          options = [ "bind" ];
        };
      };

      readonly = false;
    }
    ```

    - `args` specifies a set of arguments to run inside the container. This is the only required argument for `buildContainer`. All referenced packages inside the derivation will be made available inside the container.

    - `mounts` specifies additional mount points chosen by the user. By default only a minimal set of necessary filesystems are mounted into the container (e.g procfs, cgroupfs)

    - `readonly` makes the container's rootfs read-only if it is set to true. The default value is false `false`.
- name: pkgs.runCommand
  summary: This takes three arguments, name, env, and buildCommand
  description: |-
    ## `pkgs.runCommand`

    This takes three arguments, `name`, `env`, and `buildCommand`. `name` is just the name that Nix will append to the store path in the same way that `stdenv.mkDerivation` uses its `name` attribute. `env` is an attribute set specifying environment variables that will be set for this derivation. These attributes are then passed to the wrapped `stdenv.mkDerivation`. `buildCommand` specifies the commands that will be run to create this derivation. Note that you will need to create `$out` for Nix to register the command as successful.

    An example of using `runCommand` is provided below.

    ``` programlisting
    (import <nixpkgs> {}).runCommand "my-example" {} ''
      echo My example command is running

      mkdir $out

      echo I can write data to the Nix store > $out/message

      echo I can also run basic commands like:

      echo ls
      ls

      echo whoami
      whoami

      echo date
      date
    ''
    ```
- name: pkgs.runCommandCC
  summary: This works just like runCommand
  description: |-
    ## `pkgs.runCommandCC`

    This works just like `runCommand`. The only difference is that it also provides a C compiler in `buildCommand`’s environment. To minimize your dependencies, you should only use this if you are sure you will need a C compiler as part of running your command.
- name: pkgs.runCommandLocal
  summary: Variant of runCommand that forces the derivation to be built locally, it is not substituted
  description: |-
    ## `pkgs.runCommandLocal`

    Variant of `runCommand` that forces the derivation to be built locally, it is not substituted. This is intended for very cheap commands (\<1s execution time). It saves on the network round-trip and can speed up a build.

    Note

    This sets [`allowSubstitutes` to `false`](https://nixos.org/nix/manual/#adv-attr-allowSubstitutes), so only use `runCommandLocal` if you are certain the user will always have a builder for the `system` of the derivation. This should be true for most trivial use cases (e.g., just copying some files to a different location or adding symlinks) because there the `system` is usually the same as `builtins.currentSystem`.
- name: pkgs.snapTools
  summary: pkgs.snapTools is a set of functions for creating Snapcraft images
  description: "## `pkgs.snapTools`\n\n`pkgs.snapTools` is a set of functions for creating Snapcraft images. Snap and Snapcraft is not used to perform these operations.\n\n### `The makeSnap Function`\n\n`makeSnap` takes a single named argument, `meta`. This argument mirrors [the upstream `snap.yaml` format](https://docs.snapcraft.io/snap-format) exactly.\n\nThe `base` should not be specified, as `makeSnap` will force set it.\n\nCurrently, `makeSnap` does not support creating GUI stubs.\n\n### `Build a Hello World Snap`\n\nThe following expression packages GNU Hello as a Snapcraft snap.\n\n``` programlisting\nlet\n  inherit (import <nixpkgs> { }) snapTools hello;\nin snapTools.makeSnap {\n  meta = {\n    name = \"hello\";\n    summary = hello.meta.description;\n    description = hello.meta.longDescription;\n    architectures = [ \"amd64\" ];\n    confinement = \"strict\";\n    apps.hello.command = \"${hello}/bin/hello\";\n  };\n}\n```\n\n`nix-build` this expression and install it with `snap install ./result --dangerous`. `hello` will now be the Snapcraft version of the package.\n\n### `Build a Graphical Snap`\n\nGraphical programs require many more integrations with the host. This example uses Firefox as an example because it is one of the most complicated programs we could package.\n\n``` programlisting\nlet\n  inherit (import <nixpkgs> { }) snapTools firefox;\nin snapTools.makeSnap {\n  meta = {\n    name = \"nix-example-firefox\";\n    summary = firefox.meta.description;\n    architectures = [ \"amd64\" ];\n    apps.nix-example-firefox = {\n      command = \"${firefox}/bin/firefox\";\n      plugs = [\n        \"pulseaudio\"\n        \"camera\"\n        \"browser-support\"\n        \"avahi-observe\"\n        \"cups-control\"\n        \"desktop\"\n        \"desktop-legacy\"\n        \"gsettings\"\n        \"home\"\n        \"network\"\n        \"mount-observe\"\n        \"removable-media\"\n        \"x11\"\n      ];\n    };\n    confinement = \"strict\";\n  };\n}\n```\n\n`nix-build` this expression and install it with `snap install ./result --dangerous`. `nix-example-firefox` will now be the Snapcraft version of the Firefox package.\n\nThe specific meaning behind plugs can be looked up in the [Snapcraft interface documentation](https://docs.snapcraft.io/supported-interfaces).\n\n© 2022 NixOS Contributors  \nLicensed under the LGPL License.  \n[https://nixos.org/manual/nixpkgs/stable/index.html](https://nixos.org/manual/nixpkgs/stable/index.html)"
- name: pkgs.symlinkJoin
  summary: This can be used to put many derivations into the same directory structure
  description: |-
    ## `pkgs.symlinkJoin`

    This can be used to put many derivations into the same directory structure. It works by creating a new derivation and adding symlinks to each of the paths listed. It expects two arguments, `name`, and `paths`. `name` is the name used in the Nix store path for the created derivation. `paths` is a list of paths that will be symlinked. These paths can be to Nix store derivations or any other subdirectory contained within. Here is an example:

    ``` programlisting
    # adds symlinks of hello and stack to current build and prints "links added"
    symlinkJoin { name = "myexample"; paths = [ pkgs.hello pkgs.stack ]; postBuild = "echo links added"; }
    ```

    This creates a derivation with a directory structure like the following:

    ``` programlisting
    /nix/store/sglsr5g079a5235hy29da3mq3hv8sjmm-myexample
    |-- bin
    |   |-- hello -> /nix/store/qy93dp4a3rqyn2mz63fbxjg228hffwyw-hello-2.10/bin/hello
    |   `-- stack -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/bin/stack
    `-- share
        |-- bash-completion
        |   `-- completions
        |       `-- stack -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/share/bash-completion/completions/stack
        |-- fish
        |   `-- vendor_completions.d
        |       `-- stack.fish -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/share/fish/vendor_completions.d/stack.fish
    ...
    ```
- name: pkgs.writeDirectReferencesToFile
  summary: Writes the set of references to the output file, that is, their immediate dependencies
  description: |-
    ## `pkgs.writeDirectReferencesToFile`

    Writes the set of references to the output file, that is, their immediate dependencies.

    This produces the equivalent of `nix-store -q --references`.

    For example,

    ``` programlisting
    writeDirectReferencesToFile (writeScriptBin "hi" ''${hello}/bin/hello'')
    ```

    produces an output path `/nix/store/<hash>-runtime-references` containing

    ``` programlisting
    /nix/store/<hash>-hello-2.10
    ```

    but none of `hello`’s dependencies because those are not referenced directly by `hi`’s output.
- name: pkgs.writeReferencesToFile
  summary: Writes the closure of transitive dependencies to a file
  description: |-
    ## `pkgs.writeReferencesToFile`

    Writes the closure of transitive dependencies to a file.

    This produces the equivalent of `nix-store -q --requisites`.

    For example,

    ``` programlisting
    writeReferencesToFile (writeScriptBin "hi" ''${hello}/bin/hello'')
    ```

    produces an output path `/nix/store/<hash>-runtime-deps` containing

    ``` programlisting
    /nix/store/<hash>-hello-2.10
    /nix/store/<hash>-hi
    /nix/store/<hash>-libidn2-2.3.0
    /nix/store/<hash>-libunistring-0.9.10
    /nix/store/<hash>-glibc-2.32-40
    ```

    You can see that this includes `hi`, the original input path, `hello`, which is a direct reference, but also the other paths that are indirectly required to run `hello`.
- name: pkgs.writeShellApplication
  summary: This can be used to easily produce a shell script that has some dependencies (runtimeInputs). It automatically sets the PATH of the script to contain all of the listed inputs, sets some sanity shellopts (errexit, nounset, pipefail), and checks the resulting script with shellcheck
  description: |-
    ## `pkgs.writeShellApplication`

    This can be used to easily produce a shell script that has some dependencies (`runtimeInputs`). It automatically sets the `PATH` of the script to contain all of the listed inputs, sets some sanity shellopts (`errexit`, `nounset`, `pipefail`), and checks the resulting script with [`shellcheck`](https://github.com/koalaman/shellcheck).

    For example, look at the following code:

    ``` programlisting
    writeShellApplication {
      name = "show-nixos-org";

      runtimeInputs = [ curl w3m ];

      text = ''
        curl -s 'https://nixos.org' | w3m -dump -T text/html
      '';
    }
    ```

    Unlike with normal `writeShellScriptBin`, there is no need to manually write out `${curl}/bin/curl`, setting the PATH was handled by `writeShellApplication`. Moreover, the script is being checked with `shellcheck` for more strict validation.
