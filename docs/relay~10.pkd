---
name: Relay
slug: relay~10
text_format: markdown
generator: src:devdocs
version: '10'
copyright: |-
  © 2020–present Facebook Inc.
  Licensed under the BSD License.
  https://relay.dev/docs/en/introduction-to-relay
homepage: https://relay.dev/

---
- name: '@argumentDefinitions'
  id: graphql-in-relay#argumentdefinitions
  summary: '@argumentDefinitions is a directive used to specify arguments taken by a fragment'
  belongs_to: GraphQL in Relay
  description: "### `@argumentDefinitions`\n\n`@argumentDefinitions` is a directive used to specify arguments taken by a fragment. For example:\n\n``` javascript\n          fragment TodoList_list on TodoList @argumentDefinitions(\n  count: {type: \"Int\", defaultValue: 10},  # Optional argument\n  userID: {type: \"ID\"},                    # Required argument\n) {\n  title\n  todoItems(userID: $userID, first: $count) {  # Use fragment arguments here as variables\n    ...TodoItem_item\n  }\n}\n\n        \n```\n\nSee the [Fragment Container docs](fragment-container#passing-arguments-to-a-fragment) for more details."
- name: '@arguments'
  id: graphql-in-relay#arguments
  summary: '@arguments is a directive used to pass arguments to a fragment that was defined using @argumentDefinitions'
  belongs_to: GraphQL in Relay
  description: "### `@arguments`\n\n`@arguments` is a directive used to pass arguments to a fragment that was defined using [`@argumentDefinitions`](#argumentdefinitions). For example:\n\n``` javascript\n          query TodoListQuery($userID: ID) {\n  ...TodoList_list @arguments(count: $count, userID: $userID) # Pass arguments here\n}\n\n        \n```\n\nSee the [Fragment Container docs](fragment-container#passing-arguments-to-a-fragment) for more details."
- name: '@connection'
  id: pagination-container#connection
  summary: Pagination Container works in a very similar way to the Fragment Container in that you also specify the data requirements for a component via GraphQL fragments in the fragmentSpec
  belongs_to: Pagination Container
  description: "## `@connection`\n\nPagination Container works in a very similar way to the [Fragment Container](fragment-container) in that you also specify the data requirements for a component via GraphQL fragments in the `fragmentSpec`.\n\nHowever, when [specifying connection fragments](#createpaginationcontainer) for a Pagination Container, it is expected that at least one of the fragments contains a [GraphQL connection](https://relay.dev/graphql/connections.htm) to paginate over, and that the connection field is annotated with a `@connection` directive.\n\nThe purpose of the `@connection` directive is to allow Relay to uniquely identify different connections under a parent type. The `@connection` directive takes 2 arguments that help identify the connection:\n\n``` javascript\n          @connection(key: String!, filters: [String])\n\n        \n```\n\n- `key`: **Required** String that serves as a unique identifier for the connection under the parent field type. A good practice could be `<ComponentName>_<fieldName | fieldAlias>`.\n- `filters`: **Optional** Array of strings that belong to the set of argument variables defined for the connection field (e.g. `orderBy`, `searchTerm`, etc). The values for the variables specified in this array will be used alongside the user-supplied `key` to uniquely identify a connection. If `filters` is not provided, by default Relay will use the set of all of the arguments the connection field takes, excluding pagination specific arguments (i.e. `first`/`last`, `after`/`before`).\n\n### Examples\n\nSpecifying just the `key`:\n\n``` javascript\n          fragment Feed_user on User {\n  # This connection, under a specific User, will be uniquely identified by\n  # the key \"Feed_feed\" and the value of `$orderBy` (given that no `filters` were provided)\n  feed(\n    first: $count\n    after: $cursor\n    orderby: $orderBy\n  ) @connection(key: \"Feed_feed\") {\n    edges {\n      node {\n        id,\n        ...Story_story\n      }\n  }\n}\n\n        \n```\n\nSpecifying `key` and `filters`:\n\n``` javascript\n          fragment Feed_user on User {\n  # This connection, under a specific User, will be uniquely identified by\n  # the key \"Feed_feed\" and /only/ the value of `$searchTerm`, i.e.\n  # different values of `orderBy` will not distinguish connections.\n  feed(\n    first: $count\n    after: $cursor\n    orderby: $orderBy\n    search_term: $searchTerm\n  ) @connection(key: \"Feed_feed\", filters: [\"searchTerm\"]) {\n    edges {\n      node {\n        id,\n        ...Story_story\n      }\n  }\n}\n\n        \n```"
- name: '@connection()'
  id: graphql-in-relay#connectionkey-string-filters-string
  summary: When using the Pagination Container, Relay expects connection fields to be annotated with a @connection directive
  belongs_to: GraphQL in Relay
  description: |-
    ### `@connection(key: String!, filters: [String])`

    When using the [Pagination Container](pagination-container), Relay expects connection fields to be annotated with a `@connection` directive. For more detailed information and an example, check out the [docs on using `@connection` inside a Pagination Container](pagination-container#connection).
- name: '@inline'
  id: graphql-in-relay#inline
  summary: By default, Relay will only expose the data for fields explicitly requested by a component's fragment, which is known as data masking
  belongs_to: GraphQL in Relay
  description: "### `@inline`\n\nBy default, Relay will only expose the data for fields explicitly requested by a [component's fragment](fragment-container#createfragmentcontainer), which is known as [data masking](thinking-in-relay#data-masking). Fragment data is unmasked for use in React components by `createFragmentContainer`. However, you may want to use fragment data in non-React functions that are called from React.\n\nNon-React functions can also take advantage of data masking. A fragment can be defined with the `@inline` directive and stored in a local variable. The non-React function can then \"unmask\" the data using the `readInlineData` function.\n\nIn the example below, the function `processItemData` is called from a React component. It requires an item object with a specific set of fields. All React components that use this function should spread the `processItemData_item` fragment to ensure all of the correct item data is loaded for this function.\n\n``` javascript\n          import {graphql, readInlineData} from 'react-relay';\n\n// non-React function called from React\nfunctionprocessItemData(itemRef) {\n  const item = readInlineData(graphql`\n    fragment processItemData_item on Item @inline {\n      title\n      price\n      creator {\n        name\n      }\n    }\n  `, itemRef);\n  sendToThirdPartyApi({\n    title: item.title,\n    price: item.price,\n    creatorName: item.creator.name\n  });\n}\n\n        \n```\n\n``` javascript\n          // React ComponentfunctionMyComponent({item}) {\n  functionhandleClick() {\n    processItemData(item);\n  }\n\n  return (\n    <button onClick={handleClick}>Process {item.title}</button>\n  );\n}\n\nexport default createFragmentContainer(MyComponent, {\n  item: graphql`\n    fragment MyComponent_item on Item {\n      ...processItemData_item\n      title\n    }\n  `\n});\n\n        \n```"
- name: '@relay()'
  id: graphql-in-relay#relayplural-boolean
  summary: 'When defining a fragment for use with a Fragment container, you can use the @relay(plural: true) directive to indicate that container expects the prop for that fragment to be a list of items instead of a single item'
  belongs_to: GraphQL in Relay
  description: "### `@relay(plural: Boolean)`\n\nWhen defining a fragment for use with a Fragment container, you can use the `@relay(plural: true)` directive to indicate that container expects the prop for that fragment to be a list of items instead of a single item. A query or parent that spreads a `@relay(plural: true)` fragment should do so within a plural field (ie a field backed by a [GraphQL list](http://graphql.org/learn/schema/#lists-and-non-null). For example:\n\n``` javascript\n          // Plural fragment definition\ngraphql`\nfragment TodoItems_items on TodoItem @relay(plural: true) {\n  id\n  text\n}`;\n\n// Plural fragment usage: note the parent type is a list of items (`TodoItem[]`)\nfragment TodoApp_app on App {\n  items {\n    // parent type is a list here\n    ...TodoItem_items\n  }\n}\n\n        \n```"
- name: '@relay()'
  id: graphql-in-relay#relaymask-boolean
  summary: 'It is not recommended to use @relay(mask: false)'
  belongs_to: GraphQL in Relay
  description: "### `@relay(mask: Boolean)`\n\nIt is not recommended to use `@relay(mask: false)`. Please instead consider using the `@inline` fragment.\n\n`@relay(mask: false)` can be used to prevent data masking; when including a fragment and annotating it with `@relay(mask: false)`, its data will be available directly to the parent instead of being masked for a different container.\n\nApplied to a fragment definition, `@relay(mask: false)` changes the generated Flow types to be better usable when the fragment is included with the same directive. The Flow types will no longer be exact objects and no longer contain internal marker fields.\n\nThis may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.\n\nKeep in mind that it is typically considered an **anti-pattern** to create a single fragment shared across many containers. Abusing this directive could result in over-fetching in your application.\n\nIn the example below, the `user` prop will include the data for `id` and `name` fields wherever `...Component_internUser` is included, instead of Relay's normal behavior to mask those fields:\n\n``` javascript\n          graphql`\n  fragment Component_internUser on InternUser @relay(mask: false) {\n    id\n    name\n  }\n`;\n\nexport default createFragmentContainer(\n  ({ user }) => /* ... */,\n  graphql`\n    fragment Component_user on User {\n      internUser {\n        manager {\n          ...Component_internUser @relay(mask: false)\n        }\n        ... on Employee {\n          admins {\n            ...Component_internUser @relay(mask: false)\n          }\n          reports {\n            ...Component_internUser @relay(mask: false)\n          }\n        }\n      }\n    }\n  `,\n);\n\n        \n```"
- name: A simple example
  id: relay-environment#a-simple-example
  summary: For more details on creating a Network, see the NetworkLayer guide
  belongs_to: Relay Environment
  description: "## A simple example\n\nTo create an environment instance in Relay Modern, use the `RelayModernEnvironment` class:\n\n``` javascript\n          const {\n  Environment,\n  Network,\n  RecordSource,\n  Store,\n} = require('relay-runtime');\n\nconst source = new RecordSource();\nconst store = new Store(source);\nconst network = Network.create(/*...*/); // see note below\nconst handlerProvider = null;\n\nconst environment = new Environment({\n  handlerProvider, // Can omit.\n  network,\n  store,\n});\n\n        \n```\n\nFor more details on creating a Network, see the [NetworkLayer guide](network-layer).\n\nOnce you have an environment, you can pass it in to your [`QueryRenderer`](query-renderer) instance, or into mutations via the `commitUpdate` function (see \"[Mutations](mutations)\")."
- name: Achieving View Consistency
  id: thinking-in-graphql#achieving-view-consistency
  summary: There are a variety of solutions for keeping views up to date with a flattened cache
  belongs_to: Thinking in GraphQL
  description: |-
    ### Achieving View Consistency

    There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (`1`), the author (`2`), and the comments (`3` and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies *only* the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default `shouldComponentUpdate`). Without this strategy, every view would re-render for even the tiniest change.

    Note that this solution will also work for *writes*: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.
- name: Adding a handlerProvider
  id: relay-environment#adding-a-handlerprovider
  summary: The example above did not configure a handlerProvider, which means that a default one will be provided
  belongs_to: Relay Environment
  description: "## Adding a `handlerProvider`\n\nThe example above did not configure a `handlerProvider`, which means that a default one will be provided. Relay Modern comes with a built-in handler that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the [Relay Cursor Connections Specification](https://relay.dev/graphql/connections.htm), and well-supported by Relay itself).\n\nIf you wish to provide your own `handlerProvider`, you can do so:\n\n``` javascript\n          const {\n  ConnectionHandler,\n} = require('relay-runtime');\n\nfunctionhandlerProvider(handle) {\n  switch (handle) {\n    // Augment (or remove from) this list:\n    case 'connection': return ConnectionHandler;\n  }\n  throw new Error(\n    `handlerProvider: No handler provided for ${handle}`\n  );\n}\n\n        \n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/relay-environment.html](https://relay.dev/docs/en/relay-environment.html)"
- name: Advanced usage
  id: graphql-in-relay#advanced-usage
  summary: In addition to the bin script, the relay-compiler package also exports library code which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output
  belongs_to: GraphQL in Relay
  description: "### Advanced usage\n\nIn addition to the bin script, the `relay-compiler` package also [exports library code](https://github.com/facebook/relay/blob/master/packages/relay-compiler/index.js) which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.\n\nIf you find you need to do something unique (like generate types that conform to an older version of Flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own `FileWriter` and `ASTCache`, or by adding on an additional `IRTransform`. Note, the internal APIs of the `RelayCompiler` are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/graphql-in-relay.html](https://relay.dev/docs/en/graphql-in-relay.html)"
- name: Architecture Overview
  id: architecture-overview
  summary: This document, together with Runtime Architecture and Compiler Architecture, describes the high-level architecture of Relay "Modern". The intended audience includes developers interested in contributing to Relay, developers hoping to utilize the building blocks of Relay to create higher-level APIs, and anyone interested in understanding more about Relay internals
  description: "# Architecture Overview\n\nThis document, together with [Runtime Architecture](runtime-architecture) and [Compiler Architecture](compiler-architecture), describes the high-level architecture of Relay \"Modern\". The intended audience includes developers interested in contributing to Relay, developers hoping to utilize the building blocks of Relay to create higher-level APIs, and anyone interested in understanding more about Relay internals. For developers wanting to learn more about *using* Relay to build products, the other sections might be more helpful.\n\n## Core Modules\n\nRelay Modern is composed of three core modules:\n\n- **Relay Compiler:** A GraphQL to GraphQL optimizing *compiler*, providing general utilities for transforming and optimizing queries as well as generating build artifacts. A novel feature of the compiler is that it facilitates experimentation with new GraphQL features - in the form of custom directives - by making it easy to translate code using these directives into standard, spec-compliant GraphQL.\n- **Relay Runtime:** A full-featured, high-performance GraphQL *runtime* that can be used to build higher-level client APIs. The runtime features a normalized object cache, optimized \"write\" and \"read\" operations, a generic abstraction for incrementally fetching field data (such as for pagination), garbage collection for removing unreferenced cache entries, optimistic mutations with arbitrary logic, support for building subscriptions and live queries, and more.\n- **React/Relay:** A high-level *product API* that integrates the Relay Runtime with React. This is the primary public interface to Relay for most product developers, featuring APIs to fetch the data for a query or define data dependencies for reusable components (aka containers).\n\nNote that these modules are *loosely coupled*. For example, the compiler emits representations of queries in a well-defined format that the runtime consumes (the \"Concrete\" node interfaces in `RelayConcreteNode`), such that the compiler implementation can be swapped out if desired. React/Relay relies only on the well-documented public interface of the runtime, such that the actual implementation can be swapped out (in fact, we've upgraded the classic Relay core to also implement this same API). We hope that this loose coupling will allow the community to explore new use-cases such as the development of specialized product APIs using the Relay runtime or integrations of the runtime with view libraries other than React.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/architecture-overview](https://relay.dev/docs/en/architecture-overview)"
- name: Available Props
  id: fragment-container#available-props
  summary: To start, let's build the plain React version of a hypothetical <TodoItem /> component that displays the text and completion status of a Todo
  belongs_to: Fragment Container
  description: "### Available Props\n\nThe Component resulting from `createFragmentContainer` will receive the following `props`:\n\n``` javascript\n          typeProps = {\n  relay: {\n    environment: Environment,\n  },\n  // Additional props as specified by the fragmentSpec\n}\n\n        \n```\n\n- `relay`:\n  - `environment`: The current [Relay Environment](relay-environment)\n\n## Example\n\nTo start, let's build the plain React version of a hypothetical `<TodoItem />` component that displays the text and completion status of a `Todo`."
- name: Available Props
  id: refetch-container#available-props
  summary: null
  belongs_to: Refetch Container
  description: "### Available Props\n\nThe Component resulting from `createRefetchContainer` will receive the following `props`:\n\n``` javascript\n          type Props = {\n  relay: {\n    environment: Environment,\n    refetch(), // See #refetch section\n  },\n  // Additional props as specified by the fragmentSpec\n}\n\n        \n```\n\n- `relay`:\n  - `environment`: The current [Relay Environment](relay-environment)\n  - `refetch`: See `refetch`[docs](#refetch)\n\n&nbsp;"
- name: Available Props
  id: pagination-container#available-props
  summary: null
  belongs_to: Pagination Container
  description: "### Available Props\n\nThe Component resulting from `createPaginationContainer` will receive the following `props`:\n\n``` javascript\n          type Props = {\n  relay: {\n    environment: Environment,\n    hasMore(), // See #hasMore section\n    isLoading(), // See #isLoading section\n    loadMore(), // See #loadMore section\n    refetchConnection(), // See #refetchConnection section\n  },\n  // Additional props as specified by the fragmentSpec\n}\n\n        \n```\n\n- `relay`:\n  - `environment`: The current [Relay Environment](relay-environment)\n  - `hasMore`: See `hasMore`[docs](#hasmore)\n  - `isLoading`: See `isLoading`[docs](#isloading)\n  - `loadMore`: See `loadMore`[docs](#loadmore)\n  - `refetchConnection`: See `refetchConnection`[docs](#refetchconnection)\n\n&nbsp;"
- name: Cache Consistency
  id: thinking-in-graphql#cache-consistency
  summary: With GraphQL it is very common for the results of multiple queries to overlap
  belongs_to: Thinking in GraphQL
  description: "## Cache Consistency\n\nWith GraphQL it is very common for the results of multiple queries to overlap. However, our response cache from the previous section doesn't account for this overlap — it caches based on distinct queries. For example, if we issue a query to fetch stories:\n\n``` javascript\n          query { stories { id, text, likeCount } }\n\n        \n```\n\nand then later refetch one of the stories whose `likeCount` has since been incremented:\n\n``` javascript\n          query { story(id: \"123\") { id, text, likeCount } }\n\n        \n```\n\nWe'll now see different `likeCount`s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count."
- name: Cache Updates
  id: thinking-in-graphql#cache-updates
  summary: Note that this normalized cache structure allows overlapping results to be cached without duplication
  belongs_to: Thinking in GraphQL
  description: "### Cache Updates\n\nNote that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.\n\nThe first query was for a list of stories:\n\n``` javascript\n          query { stories { id, text, likeCount } }\n\n        \n```\n\nWith a normalized response cache, a record would be created for each story in the list. The `stories` field would store links to each of these records.\n\nThe second query refetched the information for one of those stories:\n\n``` javascript\n          query { story(id: \"123\") { id, text, likeCount } }\n\n        \n```\n\nWhen this response is normalized, Relay can detect that this result overlaps with existing data based on its `id`. Rather than create a new record, Relay will update the existing `123` record. The new `likeCount` is therefore available to *both* queries, as well as any other query that might reference this story."
- name: Caching
  id: network-layer#caching
  summary: Relay modern makes no assumptions about what to cache and will garbage collect any data that is no longer referenced
  belongs_to: Network Layer
  description: "## Caching\n\nRelay modern makes no assumptions about what to cache and will garbage collect any data that is no longer referenced.\n\nYou have to implement your own cache strategy. A simple solution is to use `QueryResponseCache` (an in-memory cache):\n\n``` javascript\n          import {\n  Environment,\n  Network,\n  QueryResponseCache,\n  RecordSource,\n  Store,\n} from 'relay-runtime';\n\nconst oneMinute = 60 * 1000;\nconst cache = new QueryResponseCache({ size: 250, ttl: oneMinute });\n\nfunctionfetchQuery(\n  operation,\n  variables,\n  cacheConfig,\n) {\n  const queryID = operation.text;\n  const isMutation = operation.operationKind === 'mutation';\n  const isQuery = operation.operationKind === 'query';\n  const forceFetch = cacheConfig && cacheConfig.force;\n\n  // Try to get data from cache on queries\n  const fromCache = cache.get(queryID, variables);\n  if (\n    isQuery &&\n    fromCache !== null &&\n    !forceFetch\n  ) {\n    return fromCache;\n  }\n\n  // Otherwise, fetch data from server\n  return fetch('/graphql', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      query: operation.text,\n      variables,\n    }),\n  }).then(response => {\n    return response.json();\n  }).then(json => {\n    // Update cache on queries\n    if (isQuery && json) {\n      cache.set(queryID, variables, json);\n    }\n    // Clear cache on mutations\n    if (isMutation) {\n      cache.clear();\n    }\n\n    return json;\n  });\n}\n\nconst environment = new Environment({\n  network: Network.create(fetchQuery),\n  store: new Store(new RecordSource()),\n});\n\nexport default environment;\n\n        \n```"
- name: Caching A Graph
  id: thinking-in-graphql#caching-a-graph
  summary: The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of records
  belongs_to: Thinking in GraphQL
  description: "### Caching A Graph\n\nThe solution to caching GraphQL is to normalize the hierarchical response into a flat collection of **records**. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored *once* regardless of how it is fetched.\n\nHere's an example query that fetches a story's text and its author's name:\n\n``` javascript\n          query {\n  story(id: \"1\") {\n    text,\n    author {\n      name\n    }\n  }\n}\n\n        \n```\n\nAnd here's a possible response:\n\n``` javascript\n          query: {\n  story: {\n     text: \"Relay is open-source!\",\n     author: {\n       name: \"Jan\"\n     }\n  }\n}\n\n        \n```\n\nAlthough the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:\n\n``` javascript\n          Map {\n  // `story(id: \"1\")`\n  1: Map {\n    text: 'Relay is open-source!',\n    author: Link(2),\n  },\n  // `story.author`\n  2: Map {\n    name: 'Jan',\n  },\n};\n\n        \n```\n\nThis is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things)."
- name: Client Caching
  id: thinking-in-graphql#client-caching
  summary: Repeatedly refetching information from the server can get quite slow
  belongs_to: Thinking in GraphQL
  description: "## Client Caching\n\nRepeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: *caching*.\n\nIn a resource-oriented REST system, we can maintain a **response cache** based on URIs:\n\n``` javascript\n          var _cache = new Map();\nrest.get = uri => {\n  if (!_cache.has(uri)) {\n    _cache.set(uri, fetch(uri));\n  }\n  return _cache.get(uri);\n};\n\n        \n```\n\nResponse-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:\n\n``` javascript\n          var _cache = new Map();\ngraphql.get = queryText => {\n  if (!_cache.has(queryText)) {\n    _cache.set(queryText, fetchGraphQL(queryText));\n  }\n  return _cache.get(queryText);\n};\n\n        \n```\n\nNow, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency."
- name: Client schema extensions
  id: graphql-in-relay#client-schema-extensions
  summary: The Relay Compiler fully supports client-side schema extensions, which allows you to extend the server schema by defining additional GraphQL types and fields on the client
  belongs_to: GraphQL in Relay
  description: "### Client schema extensions\n\nThe Relay Compiler fully supports client-side schema extensions, which allows you to extend the server schema by defining additional GraphQL types and fields on the client. Relay expects the client schema to be located in your `--src` directory.\n\nFor example, assuming the server schema `./schema.graphql`:\n\n``` javascript\n          schema {\n  query: Root\n}\n\ntype Root {\n  title: String!\n}\n\n        \n```\n\nWe can create a `./src/clientSchema.graphql` and define a new type called `Setting`:\n\n``` javascript\n          typeSetting {\n  name: String!\n  active: Boolean!\n}\n\n        \n```\n\nWe can then extend existing server types in the client schema `./src/clientSchema.graphql` with our new `Setting` type, like so:\n\n``` javascript\n          extend type Root {\n  settings: [Setting]\n}\n\n        \n```\n\nAny fields specified in the client schema, can be fetched from the [Relay Store](relay-store), by selecting it in a query or fragment.\n\nFor more details, refer to the [Local state management section](local-state-management)."
- name: commitMutation
  id: mutations#commitmutation
  summary: Use commitMutation to create and execute mutations
  belongs_to: Mutations
  description: "## `commitMutation`\n\nUse `commitMutation` to create and execute mutations. `commitMutation` has the following signature:\n\n``` javascript\n          commitMutation(\n  environment: Environment,\n  config: {\n    mutation: GraphQLTaggedNode,\n    variables: {[name: string]: mixed},\n    onCompleted?: ?(response: ?Object, errors: ?Array<PayloadError>) => void,\n    onError?: ?(error: Error) => void,\n    optimisticResponse?: Object,\n    optimisticUpdater?: ?(store: RecordSourceSelectorProxy) => void,\n    updater?: ?(store: RecordSourceSelectorProxy, data: SelectorData) => void,\n    configs?: Array<DeclarativeMutationConfig>,\n    cacheConfig?: CacheConfig,\n  },\n);\n\n        \n```\n\n### Arguments\n\n- `environment`: The [Relay Environment](relay-environment). **Note:** To ensure the mutation is performed on the correct `environment`, it's recommended to use the environment available within components (from `this.props.relay.environment`), instead of referencing a global environment.\n- `config`:\n  - `mutation`: The `graphql` tagged mutation query.\n  - `variables`: Object containing the variables needed for the mutation. For example, if the mutation defines an `$input` variable, this object should contain an `input` key, whose shape must match the shape of the data expected by the mutation as defined by the GraphQL schema.\n  - `onCompleted`: Callback function executed when the request is completed and the in-memory Relay store is updated with the `updater` function. Takes a `response` object, which is the updated response from the store, and `errors`, an array containing any errors from the server.\n  - `onError`: Callback function executed if Relay encounters an error during the request.\n  - `optimisticResponse`: Object containing the data to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. This object must have the same shape as the mutation's response type, as defined by the GraphQL schema. If provided, Relay will use the `optimisticResponse` data to update the fields on the relevant records in the local data store, *before* `optimisticUpdater` is executed. If an error occurs during the mutation request, the optimistic update will be rolled back.\n  - `optimisticUpdater`: Function used to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. If an error occurs during the mutation request, the optimistic update will be rolled back. This function takes a `store`, which is a proxy of the in-memory [Relay Store](relay-store). In this function, the client defines 'how to' update the local data via the `store` instance. For details on how to use the `store`, please refer to our [Relay Store API Reference](relay-store). **Please note:**\n    - It is usually preferable to just pass an `optimisticResponse` option instead of an `optimisticUpdater`, unless you need to perform updates on the local records that are more complicated than just updating fields (e.g. deleting records or adding items to collections).\n    - If you do decide to use an `optimisticUpdater`, often times it can be the same function as `updater`.\n  - `updater`: Function used to update the local in-memory store based on the **real** server response from the mutation. If `updater` is not provided, by default, Relay will know to automatically update the fields on the records referenced in the mutation response; however, you should pass an `updater` if you need to make more complicated updates than just updating fields (e.g. deleting records or adding items to collections). When the server response comes back, Relay first reverts any changes introduced by `optimisticUpdater` or `optimisticResponse` and will then execute `updater`. This function takes a `store`, which is a proxy of the in-memory [Relay Store](relay-store). In this function, the client defines 'how to' update the local data based on the server response via the `store` instance. For details on how to use the `store`, please refer to our [Relay Store API Reference](relay-store).\n  - `configs`: Array containing objects describing `optimisticUpdater`/`updater` configurations. `configs` provides a convenient way to specify the `updater` behavior without having to write an `updater` function. See our section on [Updater Configs](#updater-configs) for more details.\n  - `cacheConfig?`: Optional object containing a set of cache configuration options\n\n&nbsp;"
- name: Committing Local Updates
  id: mutations#committing-local-updates
  summary: Use commitLocalUpdate when you need to update the local store without necessarily executing a mutation (such as in the case of debounced operations)
  belongs_to: Mutations
  description: "## Committing Local Updates\n\nUse `commitLocalUpdate` when you need to update the local store without necessarily executing a mutation (such as in the case of debounced operations). The function takes in a Relay `environment` and an `updater` function.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/mutations.html](https://relay.dev/docs/en/mutations.html)"
- name: Comparison to Classic Relay
  id: runtime-architecture#comparison-to-classic-relay
  summary: For users of classic Relay, note that the runtime makes as few assumptions as possible about GraphQL
  belongs_to: Runtime Architecture
  description: |-
    ## Comparison to Classic Relay

    For users of classic Relay, note that the runtime makes as few assumptions as possible about GraphQL. Compared to earlier versions of Relay there is no concept of routes, there are no limitations on mutation input arguments or side-effects, arbitrary root fields just work, etc. At present, the main restriction from classic Relay that remains is the use of the `Node` interface and `id` field for object identification. However there is no fundamental reason that this restriction can't be relaxed (there is a single place in the codebase where object identity is determined), and we welcome feedback from the community about ways to support customizable object identity without negatively impacting performance.
- name: Compiler Architecture
  id: compiler-architecture
  summary: The compiler is a set of modules designed to extract GraphQL documents from across a codebase, transform/optimize them, and generate build artifacts
  description: "# Compiler Architecture\n\nThe compiler is a set of modules designed to extract GraphQL documents from across a codebase, transform/optimize them, and generate build artifacts. Examples of common types of artifacts include optimized GraphQL to persist to your server, runtime representations of the queries for use with GraphQL clients such as the Relay runtime, or generated source code for use with GraphQL frameworks for compiled languages (Java/Swift/etc).\n\n## Data Flow\n\nThe high-level flow of data through the compiler is represented in the following diagram:\n\n``` javascript\n                   ┌─────────────┐┌─────────────┐\n                   │   GraphQL   ││   Schema    │\n                   └─────────────┘└─────────────┘\n                          │              │              parse\n                          └───────┬──────┘\n                                  ▼\n                   ┌────────────────────────────┐\n                   │      CompilerContext       │\n                   │                            │\n                   │   ┌─────┐ ┌─────┐ ┌─────┐  │──┐\n                   │   │ IR  │ │ IR  │ │ ... │  │  │\n                   │   └─────┘ └─────┘ └─────┘  │  │\n                   └────────────────────────────┘  │  transform/\n                          │    │      ▲            │   optimize\n                          │    │      └────────────┘\n                          │    │\n                          │    └──────────┐\n                          │  print        │  codegen\n                          ▼               ▼\n                   ┌─────────────┐ ┌─────────────┐\n                   │   GraphQL   │ │  Artifacts  │\n                   └─────────────┘ └─────────────┘\n```\n\n1.  GraphQL text is extracted from source files and \"parsed\" into an intermediate representation (IR) using information from the schema.\n2.  The set of IR documents forms a CompilerContext, which is then transformed and optimized.\n3.  Finally, GraphQL is printed (e.g. to files, saved to a database, etc) and any artifacts are generated.\n\n## Data Types & Modules\n\nThe compiler module is composed of a set of core building blocks as well as a helper that packages them together in an easy to use API. Some of the main data types and modules in the compiler are as follows:\n\n- `IR` (Intermediate Representation): an (effectively immutable) representation of a GraphQL document (query, fragment, field, etc) as a tree structure, including type information from a schema. Compared to the standard GraphQL AST (produced by e.g. `graphql-js`) the main difference is that it encodes more of the semantics of GraphQL. For example, conditional branches (`@include` and `@skip`) are represented directly, making it easier to target optimizations for these directives (One such optimization is to merge sibling fields with the same condition, potentially reducing the number of conditionals that must be evaluated at runtime).\n- `CompilerContext`: an immutable representation of a corpus of GraphQL documents. It contains the schema and a mapping of document names to document representations (as IR, see above).\n- `Transform`: a \"map\"-like function that accepts a `CompilerContext` as input and returns a new, modified context as output. Examples below.\n- `Parser`: Converts a GraphQL schema and raw GraphQL text into typed IR objects.\n- `Printer`: a function that accepts IR and converts it to a GraphQL string.\n\nThe `RelayCompiler` module is a helper class that demonstrates one way of combining these primitives. It takes IR transforms, and given IR definitions, constructs a CompilerContext from them, transforming them, and generating output artifacts intended for use with Relay runtime.\n\n## Transforms\n\nOne of the main goals of the compiler is to provide a consistent platform for writing tools that transform or optimize GraphQL. This includes the ability to experiment with new directives by transforming them away at compile time. Transform functions should typically perform a single type of modification - it's expected that an app will have multiple transforms configured in the compiler instance.\n\nHere are a few examples of some of the included transforms:\n\n- `FlattenTransform`: Reduces extraneous levels of indirection in a query, inlining fields from anonymous fragments wherever they match the parent type. This can be beneficial when generating code to read the results of a query or process query results, as it reduces duplicate field processing. For example:\n\n``` javascript\n# before: `id` is processed twice\nfoo { # type FooType\n   id\n   ... on FooType { # matches the parent type, so this is extraneous\n     id\n   }\n }\n\n # after: `id` is processed once\n foo {\n   id\n }\n```\n\n- `SkipRedundantNodeTransform`: A more advanced version of flattening, this eliminates more complex cases of field duplication such as when a field is fetched both unconditionally and conditionally, or is fetched by two different sub-fragments. For example:\n\n``` javascript\n# before: `id` processed up to 2x\nfoo {\n  bar {\n    id\n  }\n  ... on FooType @include(if: $cond) { # can't be flattened due to conditional\n    id # but this field is guaranteed to be fetched regardless\n  }\n}\n\n# after: `id` processed at most once\nfoo {\n  bar {\n    id\n  }\n}\n```\n\n- `GenerateRequisiteFieldTransform`: This optional, Relay-specific transform inserts `id` fields for globally identifiable objects and `__typename` fields wherever the type cannot be statically determined (e.g. for unions).\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/compiler-architecture.html](https://relay.dev/docs/en/compiler-architecture.html)"
- name: Composing Fragments
  id: fragment-container#composing-fragments
  summary: Fragment composition works similarly — a parent container's fragment composes the fragment for each of its children
  belongs_to: Fragment Container
  description: "### Composing Fragments\n\nFragment composition works similarly — a parent container's fragment composes the fragment for each of its children. In this case, `<TodoList />` needs to fetch information about the `Todo`s that are required by `<TodoItem />`.\n\n``` javascript\n          classTodoListextendsReact.Component{/* as above */}\n\nexportdefault createFragmentContainer(TodoList, {\n  // This `list` fragment corresponds to the prop named `list` that is\n  // expected to be populated with server data by the `<TodoList>` component.\n  list: graphql`\n    fragment TodoList_list on TodoList {\n      # Specify any fields required by '<TodoList>' itself.\n      title\n      # Include a reference to the fragment from the child component.\n      todoItems {\n        ...TodoItem_item\n      }\n    }\n  `,\n});\n\n        \n```\n\nNote that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type `Story` into a parent's field of type `User`. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).\n\n### Passing Arguments to a Fragment\n\n#### `@argumentDefinitions`\n\nWhen defining a fragment, you can use the [`@argumentDefinitions`](graphql-in-relay#argumentdefinitions) directive to specify any arguments, with potentially default values, that the fragment expects.\n\nFor example, let's redefine our `TodoList_list` fragment to take some arguments using `@argumentDefinitions`:\n\n``` javascript\n          fragment TodoList_list on TodoList @argumentDefinitions(\n  count: {type: \"Int\", defaultValue: 10},  # Optional argument\n  userID: {type: \"ID\"},                    # Required argument\n) {\n  title\n  todoItems(userID: $userID, first: $count) {  # Use fragment arguments here as variables\n    ...TodoItem_item\n  }\n}\n\n        \n```\n\nAny arguments defined inside `@argumentDefinitions` will be local variables available inside the fragment's scope. However, a fragment can also reference global variables that were defined in the root query.\n\n#### `@arguments`\n\nIn order to pass arguments to a fragment that has `@argumentDefinitions`, you need to use the [`@arguments`](graphql-in-relay#arguments) directive.\n\nFollowing our `TodoList_list` example, we would pass arguments to the fragment like so:\n\n``` javascript\n          query TodoListQuery($count: Int, $userID: ID) {\n  ...TodoList_list @arguments(count: $count, userID: $userID) # Pass arguments here\n}\n\n        \n```"
- name: Composing Views
  id: fragment-container#composing-views
  summary: View composition is exactly what you're used to — Relay containers are just standard React components
  belongs_to: Fragment Container
  description: "### Composing Views\n\nView composition is *exactly* what you're used to — Relay containers are just standard React components. Here's the `<TodoList />` component:\n\n``` javascript\n          classTodoListextendsReact.Component{\n  render() {\n    // Expects a `list` with a string `title`, as well as the information// for the `<TodoItem>`s (we'll get that next).const list = this.props.list;\n    return (\n      <View>\n        {/* It works just like a React component, because it is one! */}\n        <Text>{list.title}</Text>\n        {list.todoItems.map(item => <TodoItem item={item} />)}\n      </View>\n    );\n  }\n}\n\n        \n```"
- name: ConnectionHandler
  id: relay-store#connectionhandler
  summary: ConnectionHandler is a utility module exposed by relay-runtime that aids in the manipulation of connections
  belongs_to: Relay Store
  description: "## ConnectionHandler\n\n`ConnectionHandler` is a utility module exposed by `relay-runtime` that aids in the manipulation of connections. `ConnectionHandler` exposes the following interface:\n\n``` javascript\n          interface ConnectionHandler {\n  getConnection(\n    record: RecordProxy,\n    key: string,\n    filters?: ?Object,\n  ): ?RecordProxy,\n  createEdge(\n    store: RecordSourceProxy,\n    connection: RecordProxy,\n    node: RecordProxy,\n    edgeType: string,\n  ): RecordProxy,\n  insertEdgeBefore(\n    connection: RecordProxy,\n    newEdge: RecordProxy,\n    cursor?: ?string,\n  ): void,\n  insertEdgeAfter(\n    connection: RecordProxy,\n    newEdge: RecordProxy,\n    cursor?: ?string,\n  ): void,\n  deleteNode(connection: RecordProxy, nodeID: string): void\n}\n\n        \n```"
- name: Container Composition
  id: fragment-container#container-composition
  summary: React and Relay support creating arbitrarily complex applications through composition
  belongs_to: Fragment Container
  description: |-
    ## Container Composition

    React and Relay support creating arbitrarily complex applications through *composition*. Larger components can be created by composing smaller components, helping us to create modular, robust applications.

    Let's explore how this works via a `<TodoList />` component that composes the `<TodoItem />` we defined above.
- name: copyFieldsFrom()
  id: relay-store#copyfieldsfromsourcerecord-recordproxy-void
  summary: Mutates the current record by copying the fields over from the passed in record sourceRecord
  belongs_to: Relay Store
  description: "### `copyFieldsFrom(sourceRecord: RecordProxy): void`\n\nMutates the current record by copying the fields over from the passed in record `sourceRecord`.\n\n#### Example\n\n``` javascript\n          const record = store.get(id1);\nconst otherRecord = store.get(id2);\nrecord.copyFieldsFrom(otherRecord); // Mutates `record`\n\n        \n```"
- name: Core Modules
  id: architecture-overview#core-modules
  summary: Note that these modules are loosely coupled
  belongs_to: Architecture Overview
  description: "## Core Modules\n\nRelay Modern is composed of three core modules:\n\n- **Relay Compiler:** A GraphQL to GraphQL optimizing *compiler*, providing general utilities for transforming and optimizing queries as well as generating build artifacts. A novel feature of the compiler is that it facilitates experimentation with new GraphQL features - in the form of custom directives - by making it easy to translate code using these directives into standard, spec-compliant GraphQL.\n- **Relay Runtime:** A full-featured, high-performance GraphQL *runtime* that can be used to build higher-level client APIs. The runtime features a normalized object cache, optimized \"write\" and \"read\" operations, a generic abstraction for incrementally fetching field data (such as for pagination), garbage collection for removing unreferenced cache entries, optimistic mutations with arbitrary logic, support for building subscriptions and live queries, and more.\n- **React/Relay:** A high-level *product API* that integrates the Relay Runtime with React. This is the primary public interface to Relay for most product developers, featuring APIs to fetch the data for a query or define data dependencies for reusable components (aka containers).\n\nNote that these modules are *loosely coupled*. For example, the compiler emits representations of queries in a well-defined format that the runtime consumes (the \"Concrete\" node interfaces in `RelayConcreteNode`), such that the compiler implementation can be swapped out if desired. React/Relay relies only on the well-documented public interface of the runtime, such that the actual implementation can be swapped out (in fact, we've upgraded the classic Relay core to also implement this same API). We hope that this loose coupling will allow the community to explore new use-cases such as the development of specialized product APIs using the Relay runtime or integrations of the runtime with view libraries other than React.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/architecture-overview](https://relay.dev/docs/en/architecture-overview)"
- name: create()
  id: relay-store#createdataid-string-typename-string-recordproxy
  summary: Creates a new record in the store given a dataID and the typeName as defined by the GraphQL schema
  belongs_to: Relay Store
  description: "### `create(dataID: string, typeName: string): RecordProxy`\n\nCreates a new record in the store given a `dataID` and the `typeName` as defined by the GraphQL schema. Returns a [`RecordProxy`](#recordproxy) which serves as an interface to mutate the newly created record.\n\n#### Example\n\n``` javascript\n          const record = store.create(dataID, 'Todo');\n\n        \n```"
- name: createFragmentContainer
  id: fragment-container#createfragmentcontainer
  summary: null
  belongs_to: Fragment Container
  description: "## `createFragmentContainer`\n\n`createFragmentContainer` has the following signature:\n\n``` javascript\n          createFragmentContainer(\n  component: ReactComponentClass,\n  fragmentSpec: {[string]: GraphQLTaggedNode},\n): ReactComponentClass;\n\n        \n```\n\n### Arguments\n\n- `component`: The React Component *class* of the component requiring the fragment data.\n- `fragmentSpec`: Specifies the data requirements for the Component via a GraphQL fragment. The required data will be available on the component as props that match the shape of the provided fragment. `fragmentSpec` should be an object whose keys are prop names and values are `graphql` tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.\n  - **Note:**`relay-compiler` enforces fragments to be named as `<FileName>_<propName>`.\n\n&nbsp;"
- name: createPaginationContainer
  id: pagination-container#createpaginationcontainer
  summary: null
  belongs_to: Pagination Container
  description: "## `createPaginationContainer`\n\n`createPaginationContainer` has the following signature:\n\n``` javascript\n          createPaginationContainer(\n  component: ReactComponentClass,\n  fragmentSpec: {[string]: GraphQLTaggedNode},\n  connectionConfig: ConnectionConfig,\n): ReactComponentClass;\n\ntype ConnectionConfig = {\n  direction?: 'backward' | 'forward',\n  getConnectionFromProps?: (props: Object) => ?ConnectionData,\n  getFragmentVariables?: (previousVariables: Object, totalCount: number) => Object,\n  getVariables: (\n    props: Object,\n    paginationInfo: {count: number, cursor: ?string},\n    fragmentVariables: Object,\n  ) => Object,\n  query: GraphQLTaggedNode,\n};\n\ntype ConnectionData = {\n  edges?: ?Array<any>,\n  pageInfo?: ?{\n    endCursor: ?string,\n    hasNextPage: boolean,\n    hasPreviousPage: boolean,\n    startCursor: ?string,\n  },\n};\n\n        \n```\n\n### Arguments\n\n- `component`: The React Component *class* of the component requiring the fragment data.\n- `fragmentSpec`: Specifies the data requirements for the Component via a GraphQL fragment. It is expected that one of the fragments specified here will contain a [`@connection`](#connection) for pagination. The required data will be available on the component as props that match the shape of the provided fragment. `fragmentSpec` should be an object whose keys are prop names and values are `graphql` tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.\n  - **Note:**`relay-compiler` enforces fragments to be named as `<FileName>_<propName>`.\n- `connectionConfig`:\n  - `direction`: Either \"forward\" to indicate forward pagination using after/first, or \"backward\" to indicate backwards pagination using before/last. If not provided, Relay will infer the direction based on the provided `@connection` directive.\n  - `getConnectionFromProps`: Function that should indicate which connection to paginate over, given the fragment props (i.e. the props corresponding to the `fragmentSpec`). This is necessary in most cases because the Relay can't automatically tell which connection you mean to paginate over (a container might fetch multiple fragments and connections, but can only paginate one of them). If not provided, Relay will try infer the correct connection to paginate over based on the provided `@connection` directive. See our [example](#pagination-example) for more details.\n  - `getFragmentVariables`: Function that should return the bag of variables to use for reading out the data from the store when re-rendering the component. This function takes the previous set of variables passed to the pagination `query`, and the number of elements that have been fetched in total so far. Specifically, this indicates which variables to use when reading out the data from the local data store *after* the new pagination `query` has been fetched. If not specified, Relay will default to using all of the previous variables and using the total count for the `count` variable. This option is analogous to [`renderVariables`](refetch-container#refetch) in the Refetch Container. See our [example](#pagination-example) for more details.\n  - `getVariables`: Function that should return the variables to pass to the pagination `query` when fetching it from the server, given the current `props`, `count` and `cursor`. You may set whatever variables here, as well as modify the defaults to use for after/first/before/last arguments. See our [example](#pagination-example) for more details.\n  - `query`: A `graphql` tagged query to be used as the pagination query to fetch more data upon calling [`loadMore`](#loadmore).\n\n&nbsp;"
- name: createRefetchContainer
  id: refetch-container#createrefetchcontainer
  summary: null
  belongs_to: Refetch Container
  description: "## `createRefetchContainer`\n\n`createRefetchContainer` has the following signature:\n\n``` javascript\n          createRefetchContainer(\n  component: ReactComponentClass,\n  fragmentSpec: {[string]: GraphQLTaggedNode},\n  refetchQuery: GraphQLTaggedNode,\n): ReactComponentClass;\n\n        \n```\n\n### Arguments\n\n- `component`: The React Component *class* of the component requiring the fragment data.\n- `fragmentSpec`: Specifies the data requirements for the Component via a GraphQL fragment. The required data will be available on the component as props that match the shape of the provided fragment. `fragmentSpec` should be an object whose keys are prop names and values are `graphql` tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.\n  - **Note:**`relay-compiler` enforces fragments to be named as `<FileName>_<propName>`.\n- `refetchQuery`: A `graphql` tagged query to be fetched upon calling [`props.relay.refetch`](#refetch). As with any query, upon fetching this query, its result will be normalized into the store, any relevant subscriptions associated with the changed records will be fired, and subscribed components will re-render.\n\n&nbsp;"
- name: Custom open-source implementations
  id: network-layer#custom-open-source-implementations
  summary: 'react-relay-network-modern on npm - is a Network Layer for Relay Modern which has built-in highly customizable middlewares for commonly used scenarios: batching query requests, caching, authentication, request retrying, logging'
  belongs_to: Network Layer
  description: "## Custom open-source implementations\n\n**[react-relay-network-modern](https://github.com/relay-tools/react-relay-network-modern)** on [npm](https://www.npmjs.com/package/react-relay-network-modern) - is a Network Layer for Relay Modern which has built-in highly customizable middlewares for commonly used scenarios: batching query requests, caching, authentication, request retrying, logging. Moreover, you may write your own middlewares with custom logic.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/network-layer.html](https://relay.dev/docs/en/network-layer.html)"
- name: Data Components aka Containers
  id: thinking-in-relay#data-components-aka-containers
  summary: Relay allows developers to annotate their React components with data dependencies by creating containers
  belongs_to: Thinking In Relay
  description: "## Data Components aka Containers\n\nRelay allows developers to annotate their React components with data dependencies by creating **containers**. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a `<Story />` component might implement a view for rendering any `Story` item. The actual story to render would be determined by the data passed to the component: `<Story story={ ... } />`. The equivalent in GraphQL are **fragments**: named query snippets that specify what data to fetch *for an object of a given type*. We might describe the data needed by `<Story>` as follows:\n\n``` javascript\n          fragment Story_story on Story {\n  text\n  author {\n    name\n    photo\n  }\n}\n\n        \n```\n\nAnd this fragment can then be used to define the Story container:\n\n``` javascript\n          const {createFragmentContainer, graphql} = require('react-relay');\n\n// Plain React component.\n// Usage: `<Story story={ ... } />`\nclassStoryextendsReact.Component{ ... }\n\n// Higher-order component that wraps `<Story />`\nconst StoryContainer = createFragmentContainer(Story, {\n  // Define a fragment with a name matching the `story` prop expected above\n  story: graphql`\n    fragment Story_story on Story {\n      text\n      author {\n        name\n        photo\n      }\n    }\n  `\n})\n\n        \n```"
- name: Data Dependencies With GraphQL
  id: fragment-container#data-dependencies-with-graphql
  summary: In Relay, data dependencies are described using GraphQL
  belongs_to: Fragment Container
  description: "### Data Dependencies With GraphQL\n\nIn Relay, data dependencies are described using [GraphQL](https://github.com/facebook/graphql). For `<TodoItem />`, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the `item` prop.\n\n``` javascript\n          graphql`\n  # This fragment only applies to objects of type 'Todo'.\n  fragment TodoItem_item on Todo {\n    text\n    isComplete\n  }\n`\n\n        \n```"
- name: Data Flow
  id: compiler-architecture#data-flow
  summary: null
  belongs_to: Compiler Architecture
  description: "## Data Flow\n\nThe high-level flow of data through the compiler is represented in the following diagram:\n\n``` javascript\n                             ┌─────────────┐┌─────────────┐\n                   │   GraphQL   ││   Schema    │\n                   └─────────────┘└─────────────┘\n                          │              │              parse\n                          └───────┬──────┘\n                                  ▼\n                   ┌────────────────────────────┐\n                   │      CompilerContext       │\n                   │                            │\n                   │   ┌─────┐ ┌─────┐ ┌─────┐  │──┐\n                   │   │ IR  │ │ IR  │ │ ... │  │  │\n                   │   └─────┘ └─────┘ └─────┘  │  │\n                   └────────────────────────────┘  │  transform/\n                          │    │      ▲            │   optimize\n                          │    │      └────────────┘\n                          │    │\n                          │    └──────────┐\n                          │  print        │  codegen\n                          ▼               ▼\n                   ┌─────────────┐ ┌─────────────┐\n                   │   GraphQL   │ │  Artifacts  │\n                   └─────────────┘ └─────────────┘\n\n        \n```\n\n1.  GraphQL text is extracted from source files and \"parsed\" into an intermediate representation (IR) using information from the schema.\n2.  The set of IR documents forms a CompilerContext, which is then transformed and optimized.\n3.  Finally, GraphQL is printed (e.g. to files, saved to a database, etc) and any artifacts are generated."
- name: Data Masking
  id: thinking-in-relay#data-masking
  summary: With typical approaches to data-fetching we found that it was common for two components to have implicit dependencies
  belongs_to: Thinking In Relay
  description: "## Data Masking\n\nWith typical approaches to data-fetching we found that it was common for two components to have *implicit dependencies*. For example `<StoryHeader />` might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as `<Story />`. Then when we changed `<Story />` and removed that data-fetching logic, `<StoryHeader />` would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.\n\nWe've seen that Relay containers ensure that GraphQL fragments are fetched *before* the component is rendered. But containers also provide another benefit that isn't immediately obvious: **data masking**. Relay only allows components to access data they specifically ask for in GraphQL fragments — nothing more. So if one component queries for a Story's `text`, and another for its `author`, each can see *only* the field that they asked for. In fact, components can't even see the data requested by their *children*: that would also break encapsulation.\n\nRelay also goes further: it uses opaque identifiers on `props` to validate that we've explicitly fetched the data for a component before rendering it. If `<Story />` renders `<StoryHeader />` but forgets to include its fragment, Relay will warn that the data for `<StoryHeader />` is missing. In fact, Relay will warn *even if* some other component happened to fetch the same data required by `<StoryHeader />`. This warning tells us that although things *might* work now they're highly likely to break later.\n\n# Conclusion\n\nGraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for **declarative data-fetching**. By separating *what* data to fetch from *how* it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies — React, Relay, and GraphQL — are powerful on their own, the combination is a **UI platform** that allows us to *move fast* and *ship high-quality apps at scale*.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/thinking-in-relay.html](https://relay.dev/docs/en/thinking-in-relay.html)"
- name: Data Model
  id: runtime-architecture#data-model
  summary: Relay Runtime is designed for use with GraphQL schemas that describe object graphs in which objects have a type, an identity, and a set of fields with values
  belongs_to: Runtime Architecture
  description: "## Data Model\n\nRelay Runtime is designed for use with GraphQL schemas that describe **object graphs** in which objects have a type, an identity, and a set of fields with values. Objects may reference each other, which is represented by fields whose values are one or more other objects in the graph \\[1\\]. To distinguish from JavaScript `Object`s, these units of data are referred to as `Record`s. Relay represents both its internal cache as well as query/mutation/etc results as a mapping of **data ID**s to **records**. The data ID is the unique (with respect to the cache) identifier for a record - it may be the value of an actual `id` field or based on the path to the record from the nearest object with an `id` (such path-based ids are called **client ids**). Each `Record` stores its data ID, type, and any fields that have been fetched. Multiple records are stored together as a `RecordSource`: a mapping of data IDs to `Record` instances.\n\nFor example, a user and their address might be represented as follows:\n\n``` javascript\n          // GraphQL Fragment\nfragment on User {\n  id\n  name\n  address {\n    city\n  }\n}\n\n// Response\n{\n  id: '842472',\n  name: 'Joe',\n  address: {\n    city: 'Seattle',\n  }\n}\n\n// Normalized Representation\nRecordSource {\n  '842472': Record {\n    __id: '842472',\n    __typename: 'User', // the type is known statically from the fragment\n    id: '842472',\n    name: 'Joe',\n    address: {__ref: 'client:842472:address'}, // link to another record\n  },\n  'client:842472:address': Record {\n    // A client ID, derived from the path from parent & parent's ID\n    __id: 'client:842472:address',\n    __typename: 'Address',\n    city: 'Seattle',\n  }\n}\n\n        \n```\n\n\\[1\\] Note that GraphQL itself does not impose this constraint, and Relay Runtime may also be used for schemas that do not conform to it. For example, both systems can be used to query a single denormalized table. However, many of the features that Relay Runtime provides, such as caching and normalization, work best when the data is represented as a normalized graph with stable identities for discrete pieces of information."
- name: Data Types
  id: runtime-architecture#data-types
  summary: null
  belongs_to: Runtime Architecture
  description: |-
    ## Data Types

    (subsequent sections explain how these types are used in practice):

    - `DataID` (type): A globally unique or client-generated identifier for a record, stored as a string.
    - `Record` (type): A representation of a distinct data entity with an identity, type, and fields. Note that the actual runtime representation is opaque to the system: all accesses to `Record` objects (including record creation) is mediated through the `RelayModernRecord` module. This allows the representation itself to be changed in a single place (e.g. to use `Map`s or a custom class). It is important that other code does not assume that `Record`s will always be plain objects.
    - `RecordSource` (type): A collection of records keyed by their data ID, used both to represent the cache and updates to it. For example the store's record cache is a `RecordSource` and the results of queries/mutations/subscriptions are normalized into `RecordSource`s that are published to a store. Sources also define methods for asynchronously loading records in order to (eventually) support offline use-cases. Currently the only implementation of this interface is `RelayInMemoryRecordSource`; future implementations may add support for loading records from disk.
    - `Store` (type): The source of truth for an instance of `RelayRuntime`, holding the canonical set of records in the form of a `RecordSource` (though this is not required). Currently the only implementation is `RelayModernStore`.
    - `Network` (type): Provides methods for fetching query data from and executing mutations against an external data source.
    - `Environment` (type): Represents an encapsulated environment combining a `Store` and `Network`, providing a high-level API for interacting with both. This is the main public API of `RelayRuntime`.

    Types for working with queries and their results include:

    - `Selector` (type): A selector defines the starting point for a traversal into the graph for the purposes of targeting a subgraph, combining a GraphQL fragment, variables, and the Data ID for the root object from which traversal should progress. Intuitively, this "selects" a portion of the object graph.
    - `Snapshot` (type): The (immutable) results of executing a `Selector` at a given point in time. This includes the selector itself, the results of executing it, and a list of the Data IDs from which data was retrieved (useful in determining when these results might change).

    &nbsp;
- name: Data Types & Modules
  id: compiler-architecture#data-types--modules
  summary: The compiler module is composed of a set of core building blocks as well as a helper that packages them together in an easy to use API
  belongs_to: Compiler Architecture
  description: |-
    ## Data Types & Modules

    The compiler module is composed of a set of core building blocks as well as a helper that packages them together in an easy to use API. Some of the main data types and modules in the compiler are as follows:

    - `IR` (Intermediate Representation): an (effectively immutable) representation of a GraphQL document (query, fragment, field, etc) as a tree structure, including type information from a schema. Compared to the standard GraphQL AST (produced by e.g. `graphql-js`) the main difference is that it encodes more of the semantics of GraphQL. For example, conditional branches (`@include` and `@skip`) are represented directly, making it easier to target optimizations for these directives (One such optimization is to merge sibling fields with the same condition, potentially reducing the number of conditionals that must be evaluated at runtime).
    - `CompilerContext`: an immutable representation of a corpus of GraphQL documents. It contains the schema and a mapping of document names to document representations (as IR, see above).
    - `Transform`: a "map"-like function that accepts a `CompilerContext` as input and returns a new, modified context as output. Examples below.
    - `Parser`: Converts a GraphQL schema and raw GraphQL text into typed IR objects.
    - `Printer`: a function that accepts IR and converts it to a GraphQL string.

    The `RelayCompiler` module is a helper class that demonstrates one way of combining these primitives. It takes IR transforms, and given IR definitions, constructs a CompilerContext from them, transforming them, and generating output artifacts intended for use with Relay runtime.
- name: Data-Fetching APIs
  id: thinking-in-graphql#data-fetching-apis
  summary: So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL
  belongs_to: Thinking in GraphQL
  description: "## Data-Fetching APIs\n\nSo far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:\n\n- Fetching all the data for a view hierarchy.\n- Managing asynchronous state transitions and coordinating concurrent requests.\n- Managing errors.\n- Retrying failed requests.\n- Updating the local cache after receiving query/mutation responses.\n- Queuing mutations to avoid race conditions.\n- Optimistically updating the UI while waiting for the server to respond to mutations.\n\nWe've found that typical approaches to data-fetching — with imperative APIs — force developers to deal with too much of this non-essential complexity. For example, consider *optimistic UI updates*. This is a way of giving the user feedback while waiting for a server response. The logic of *what* to do can be quite clear: when the user clicks \"like\", mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying *what* data we need often dictates *how* and *when* it is fetched. Next, we'll explore our approach to solving these concerns with **Relay**.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/thinking-in-graphql](https://relay.dev/docs/en/thinking-in-graphql)"
- name: Data/View Consistency
  id: thinking-in-graphql#dataview-consistency
  summary: A normalized cache ensures that the cache is consistent
  belongs_to: Thinking in GraphQL
  description: "## Data/View Consistency\n\nA normalized cache ensures that the *cache* is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.\n\nConsider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:\n\n``` javascript\n          query {\n  story(id: \"1\") {\n    text,\n    author { name, photo },\n    comments {\n      text,\n      author { name, photo }\n    }\n  }\n}\n\n        \n```\n\nAfter initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as `author`:\n\n``` javascript\n          // Note: This is pseudo-code for `Map` initialization to make the structure// more obvious.Map {\n  // `story(id: \"1\")`\n  1: Map {\n    text: 'got GraphQL?',\n    author: Link(2),\n    comments: [Link(3)],\n  },\n  // `story.author`\n  2: Map {\n    name: 'Yuzhi',\n    photo: 'http://.../photo1.jpg',\n  },\n  // `story.comments[0]`\n  3: Map {\n    text: 'Here\\'s how to get one!',\n    author: Link(2),\n  },\n}\n\n        \n```\n\nThe author of this story also commented on it — quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the *only* part of our cached data that changes:\n\n``` javascript\n          Map {\n  ...\n  2: Map {\n    ...\n    photo: 'http://.../photo2.jpg',\n  },\n}\n\n        \n```\n\nThe value of the `photo` field has changed; and therefore the record `2` has also changed. And that's it. Nothing else in the *cache* is affected. But clearly our *view* needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.\n\nA standard response is to \"just use immutable data structures\" — but let's see what would happen if we did:\n\n``` javascript\n          ImmutableMap {\n  1: ImmutableMap {/* same as before */}\n  2: ImmutableMap {\n    ... // other fields unchanged\n    photo: 'http://.../photo2.jpg',\n  },\n  3: ImmutableMap {/* same as before */}\n}\n\n        \n```\n\nIf we replace `2` with a new immutable record, we'll also get a new immutable instance of the cache object. However, records `1` and `3` are untouched. Because the data is normalized, we can't tell that `story`'s contents have changed just by looking at the `story` record alone."
- name: Defining Containers
  id: fragment-container#defining-containers
  summary: Given the plain React component and a GraphQL fragment, we can now define a Fragment Container to specify this component's data requirements
  belongs_to: Fragment Container
  description: "### Defining Containers\n\nGiven the plain React component and a GraphQL fragment, we can now define a Fragment Container to specify this component's data requirements. Let's look at the code first and then see what's happening:\n\n``` javascript\n          // TodoItem.jsimport {createFragmentContainer, graphql} from 'react-relay';\n\nclassTodoItemextendsReact.Component{/* as above */}\n\n// Export a *new* React component that wraps the original `<TodoItem>`.\nexport default createFragmentContainer(TodoItem, {\n  // For each of the props that depend on server data, we define a corresponding\n  // key in this object. Here, the component expects server data to populate the\n  // `item` prop, so we'll specify the fragment from above at the `item` key.\n  item: graphql`\n    fragment TodoItem_item on Todo {\n      text\n      isComplete\n    }\n  `,\n});\n\n        \n```"
- name: delete()
  id: relay-store#deletedataid-string-void
  summary: Deletes a record from the store given its dataID
  belongs_to: Relay Store
  description: "### `delete(dataID: string): void`\n\nDeletes a record from the store given its `dataID`.\n\n#### Example\n\n``` javascript\n          store.delete(dataID);\n\n        \n```"
- name: deleteNode()
  id: relay-store#deletenodeconnection-recordproxy-nodeid-string-void
  summary: Given a connection, deletes any edges whose id matches the given id
  belongs_to: Relay Store
  description: "### `deleteNode(connection: RecordProxy, nodeID: string): void`\n\nGiven a connection, deletes any edges whose id matches the given id.\n\n#### Example\n\n``` javascript\n          const user = store.get(userID);\nconst friends = ConnectionHandler.getConnection(user, 'friends');\nConnectionHandler.deleteNode(friends, idToDelete);\n\n        \n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/relay-store.html](https://relay.dev/docs/en/relay-store.html)"
- name: Directives
  id: graphql-in-relay#directives
  summary: Relay uses directives to add additional information to GraphQL documents, which are used by the Relay Compiler to generate the appropriate runtime artifacts
  belongs_to: GraphQL in Relay
  description: |-
    ## Directives

    Relay uses directives to add additional information to GraphQL documents, which are used by the [Relay Compiler](#relay-compiler) to generate the appropriate runtime artifacts. These directives only appear in your application code and are removed from requests sent to your GraphQL server.

    **Note:** The relay-compiler will maintain any directives supported by your server (such as `@include` or `@skip`) so they remain part of the request to the GraphQL server and won't alter generated runtime artifacts.
- name: Edge creation and insertion
  id: relay-store#edge-creation-and-insertion
  summary: Creates an edge given a store, a connection, the edge type, and a record that holds that connection
  belongs_to: Relay Store
  description: "### Edge creation and insertion\n\n#### `createEdge(store: RecordSourceProxy, connection: RecordProxy, node: RecordProxy, edgeType: string)`\n\nCreates an edge given a [`store`](#recordsourceselectorproxy), a connection, the edge type, and a record that holds that connection.\n\n#### `insertEdgeBefore(connection: RecordProxy, newEdge: RecordProxy, cursor?: ?string)`\n\nGiven a connection, inserts the edge at the beginning of the connection, or before the specified `cursor`.\n\n#### `insertEdgeAfter(connection: RecordProxy, newEdge: RecordProxy, cursor?: ?string)`\n\nGiven a connection, inserts the edge at the end of the connection, or after the specified `cursor`.\n\n#### Example\n\n``` javascript\n          const user = store.get(userID);\nconst friends = ConnectionHandler.getConnection(user, 'friends');\nconst edge = ConnectionHandler.createEdge(store, friends, user, 'UserEdge');\n\n// No cursor provided, append the edge at the end.\nConnectionHandler.insertEdgeAfter(friends, edge);\n\n// No cursor provided, Insert the edge at the front:\nConnectionHandler.insertEdgeBefore(friends, edge);\n\n        \n```"
- name: Fetching Data
  id: thinking-in-graphql#fetching-data
  summary: Imagine we have a simple application that fetches a list of stories, and some details about each one
  belongs_to: Thinking in GraphQL
  description: "## Fetching Data\n\nImagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:\n\n``` javascript\n          // Fetch the list of story IDs but not their details:\nrest.get('/stories').then(stories =>\n  // This resolves to a list of items with linked resources:\n  // `[ { href: \"http://.../story/1\" }, ... ]`\n  Promise.all(stories.map(story =>\n    rest.get(story.href) // Follow the links\n  ))\n).then(stories => {\n  // This resolves to a list of story items:\n  // `[ { id: \"...\", text: \"...\" } ]`\n  console.log(stories);\n});\n\n        \n```\n\nNote that this approach requires *n+1* requests to the server: 1 to fetch the list, and *n* to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):\n\n``` javascript\n          graphql.get(`query { stories { id, text } }`).then(\n  stories => {\n    // A list of story items:\n    // `[ { id: \"...\", text: \"...\" } ]`\n    console.log(stories);\n  }\n);\n\n        \n```\n\nSo far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:\n\n- All data is fetched in a single round trip.\n- The client and server are decoupled: the client specifies the data needed instead of *relying on* the server endpoint to return the correct data.\n\nFor a simple application that's already a nice improvement."
- name: Fetching Data For a View
  id: thinking-in-relay#fetching-data-for-a-view
  summary: 'In our experience, the overwhelming majority of products want one specific behavior: fetch all the data for a view hierarchy while displaying a loading indicator, and then render the entire view once the data is ready'
  belongs_to: Thinking In Relay
  description: |-
    ## Fetching Data For a View

    In our experience, the overwhelming majority of products want one specific behavior: fetch *all* the data for a view hierarchy while displaying a loading indicator, and then render the *entire* view once the data is ready.

    One solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing *any* root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in *components*.

    The next logical approach is to use `render()` as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that *components use data to figure out what to render!* In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or *statically*.

    This is where GraphQL comes into play. Components specify one or multiple GraphQL fragments for some of their props describing their data requirements. Each GraphQL fragment has a unique name within an application which allows us to determine the query needed to fetch the full query tree in a build step and load all the required data in a single network request efficiently at runtime.
- name: fetchQuery
  id: fetch-query
  summary: You can use the fetchQuery function to imperatively make GraphQL Requests
  description: "# fetchQuery\n\nYou can use the `fetchQuery` function to imperatively make GraphQL Requests. This is useful for cases where you want to make requests outside of React but still utilize the Relay store and network layer.\n\n``` javascript\nimport {fetchQuery, graphql} from 'relay-runtime';\n\nconst query = graphql`\n  query ExampleQuery($pageID: ID!) {\n    page(id: $pageID) {\n      name\n    }\n  }\n`;\n\nconst variables = {\n  pageID: '110798995619330',\n};\n\nfetchQuery(environment, query, variables)\n  .then(data => {\n    // access the graphql response\n  });\n```\n\n## Arguments\n\n- `environment`: The [Relay Environment](relay-environment)\n- `query`: The `graphql` tagged query. **Note:** `relay-compiler` enforces the query to be named as `<FileName>Query`.\n- `variables`: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value.\n- `cacheConfig?`: Optional object containing a set of cache configuration options, i.e. `force: true` requires the fetch to be issued regardless of the state of any configured response cache. See [the types](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/relay-runtime/lib/util/RelayRuntimeTypes.d.ts#L22-L35) for more `cacheConfig` options.\n\n## Return Value\n\nThe function returns a `Promise` that resolves with an object containing data obtained from the query.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/fetch-query](https://relay.dev/docs/en/fetch-query)"
- name: Fragment Container
  id: fragment-container
  summary: A Fragment Container is a higher-order component that allows components to specify their data requirements
  description: "# Fragment Container\n\nA Fragment Container is a [higher-order component](https://reactjs.org/docs/higher-order-components.html) that allows components to specify their data requirements. A container does not directly fetch data, but instead declares a *specification* of the data needed for rendering, and then Relay will guarantee that this data is available *before* rendering occurs.\n\nTable of Contents:\n\n- [`createFragmentContainer`](#createfragmentcontainer)\n- [Example](#example)\n- [Container Composition](#container-composition)\n- [Rendering Containers](#rendering-containers)\n\n## `createFragmentContainer`\n\n`createFragmentContainer` has the following signature:\n\n``` javascript\ncreateFragmentContainer(\n  component: ReactComponentClass,\n  fragmentSpec: {[string]: GraphQLTaggedNode},\n): ReactComponentClass;\n```\n\n### Arguments\n\n- `component`: The React Component *class* of the component requiring the fragment data.\n- `fragmentSpec`: Specifies the data requirements for the Component via a GraphQL fragment. The required data will be available on the component as props that match the shape of the provided fragment. `fragmentSpec` should be an object whose keys are prop names and values are `graphql` tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.\n  - **Note:** `relay-compiler` enforces fragments to be named as `<FileName>_<propName>`.\n\n### Available Props\n\nThe Component resulting from `createFragmentContainer` will receive the following `props`:\n\n``` javascript\ntype Props = {\n  relay: {\n    environment: Environment,\n  },\n  // Additional props as specified by the fragmentSpec\n}\n```\n\n- `relay`:\n  - `environment`: The current [Relay Environment](relay-environment)\n\n## Example\n\nTo start, let's build the plain React version of a hypothetical `<TodoItem />` component that displays the text and completion status of a `Todo`.\n\n### React Component\n\nHere's a basic implementation of `<TodoItem />` that ignores styling in order to highlight the functionality:\n\n``` javascript\n// TodoItem.js\nclass TodoItem extends React.Component {\n  render() {\n    // Expects the `item` prop to have the following shape:\n    // {\n    //   item: {\n    //     text,\n    //     isComplete\n    //   }\n    // }\n    const item = this.props.item;\n    return (\n      <View>\n        <Checkbox checked={item.isComplete} />\n        <Text>{item.text}</Text>\n      </View>\n    );\n  }\n}\n```\n\n### Data Dependencies With GraphQL\n\nIn Relay, data dependencies are described using [GraphQL](https://github.com/facebook/graphql). For `<TodoItem />`, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the `item` prop.\n\n``` javascript\ngraphql`\n  # This fragment only applies to objects of type 'Todo'.\n  fragment TodoItem_item on Todo {\n    text\n    isComplete\n  }\n`\n```\n\n### Defining Containers\n\nGiven the plain React component and a GraphQL fragment, we can now define a Fragment Container to specify this component's data requirements. Let's look at the code first and then see what's happening:\n\n``` javascript\n// TodoItem.js\nimport {createFragmentContainer, graphql} from 'react-relay';\n\nclass TodoItem extends React.Component {/* as above */}\n\n// Export a *new* React component that wraps the original `<TodoItem>`.\nexport default createFragmentContainer(TodoItem, {\n  // For each of the props that depend on server data, we define a corresponding\n  // key in this object. Here, the component expects server data to populate the\n  // `item` prop, so we'll specify the fragment from above at the `item` key.\n  item: graphql`\n    fragment TodoItem_item on Todo {\n      text\n      isComplete\n    }\n  `,\n});\n```\n\n## Container Composition\n\nReact and Relay support creating arbitrarily complex applications through *composition*. Larger components can be created by composing smaller components, helping us to create modular, robust applications.\n\nLet's explore how this works via a `<TodoList />` component that composes the `<TodoItem />` we defined above.\n\n### Composing Views\n\nView composition is *exactly* what you're used to — Relay containers are just standard React components. Here's the `<TodoList />` component:\n\n``` javascript\nclass TodoList extends React.Component {\n  render() {\n    // Expects a `list` with a string `title`, as well as the information\n    // for the `<TodoItem>`s (we'll get that next).\n    const list = this.props.list;\n    return (\n      <View>\n        {/* It works just like a React component, because it is one! */}\n        <Text>{list.title}</Text>\n        {list.todoItems.map(item => <TodoItem item={item} />)}\n      </View>\n    );\n  }\n}\n```\n\n### Composing Fragments\n\nFragment composition works similarly — a parent container's fragment composes the fragment for each of its children. In this case, `<TodoList />` needs to fetch information about the `Todo`s that are required by `<TodoItem />`.\n\n``` javascript\nclass TodoList extends React.Component {/* as above */}\n\nexport default createFragmentContainer(TodoList, {\n  // This `list` fragment corresponds to the prop named `list` that is\n  // expected to be populated with server data by the `<TodoList>` component.\n  list: graphql`\n    fragment TodoList_list on TodoList {\n      # Specify any fields required by '<TodoList>' itself.\n      title\n      # Include a reference to the fragment from the child component.\n      todoItems {\n        ...TodoItem_item\n      }\n    }\n  `,\n});\n```\n\nNote that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type `Story` into a parent's field of type `User`. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).\n\n### Passing Arguments to a Fragment\n\n#### `@argumentDefinitions`\n\nWhen defining a fragment, you can use the [`@argumentDefinitions`](graphql-in-relay#argumentdefinitions) directive to specify any arguments, with potentially default values, that the fragment expects.\n\nFor example, let's redefine our `TodoList_list` fragment to take some arguments using `@argumentDefinitions`:\n\n``` javascript\nfragment TodoList_list on TodoList @argumentDefinitions(\n  count: {type: \"Int\", defaultValue: 10},  # Optional argument\n  userID: {type: \"ID\"},                    # Required argument\n) {\n  title\n  todoItems(userID: $userID, first: $count) {  # Use fragment arguments here as variables\n    ...TodoItem_item\n  }\n}\n```\n\nAny arguments defined inside `@argumentDefinitions` will be local variables available inside the fragment's scope. However, a fragment can also reference global variables that were defined in the root query.\n\n#### `@arguments`\n\nIn order to pass arguments to a fragment that has `@argumentDefinitions`, you need to use the [`@arguments`](graphql-in-relay#arguments) directive.\n\nFollowing our `TodoList_list` example, we would pass arguments to the fragment like so:\n\n``` javascript\nquery TodoListQuery($count: Int, $userID: ID) {\n  ...TodoList_list @arguments(count: $count, userID: $userID) # Pass arguments here\n}\n```\n\n## Rendering Containers\n\nAs we've learned, Relay fragment containers only declare data requirements as GraphQL fragments. In order to actually fetch and render the specified data, we need to use a `QueryRenderer` component to render a root query and any fragment containers included within. Please refer to our [`QueryRenderer`](query-renderer) docs for more details.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/fragment-container.html](https://relay.dev/docs/en/fragment-container.html)"
- name: get()
  id: relay-store#getdataid-string-recordproxy
  summary: Retrieves a record from the store given its dataID
  belongs_to: Relay Store
  description: "### `get(dataID: string): ?RecordProxy`\n\nRetrieves a record from the store given its `dataID`. Returns a [`RecordProxy`](#recordproxy) which serves as an interface to mutate the record.\n\n#### Example\n\n``` javascript\n          const record = store.get(dataID);\n\n        \n```"
- name: getConnection()
  id: relay-store#getconnectionrecord-recordproxy-key-string-filters-object
  summary: Given a record and a connection key, and optionally a set of filters, getConnection retrieves a RecordProxy that represents a connection that was annotated with a @connection directive
  belongs_to: Relay Store
  description: "### `getConnection(record: RecordProxy, key: string, filters?: ?Object)`\n\nGiven a record and a connection key, and optionally a set of filters, `getConnection` retrieves a [`RecordProxy`](#recordproxy) that represents a connection that was annotated with a `@connection` directive.\n\nFirst, let's take a look at a plain connection:\n\n``` javascript\n          fragment FriendsFragment on User {\n  friends(first: 10) {\n    edges {\n      node {\n        id\n      }\n    }\n  }\n}\n\n        \n```\n\nAccessing a plain connection field like this is the same as other regular field:\n\n``` javascript\n          // The `friends` connection record can be accessed with:const user = store.get(userID);\nconst friends = user && user.getLinkedRecord('friends');\n\n// Access fields on the connection:\nconst edges = friends && friends.getLinkedRecords('edges');\n\n        \n```\n\nIn a [pagination container](pagination-container), we usually annotate the actual connection field with `@connection` to tell Relay which part needs to be paginated:\n\n``` javascript\n          fragment FriendsFragment on User {\n  friends(first: 10, orderby: \"firstname\") @connection(\n    key: \"FriendsFragment_friends\",\n  ) {\n    edges {\n      node {\n        id\n      }\n    }\n  }\n}\n\n        \n```\n\nFor connections like the above, `ConnectionHandler` helps us find the record:\n\n``` javascript\n          import {ConnectionHandler} from 'relay-runtime';\n\n// The `friends` connection record can be accessed with:\nconst user = store.get(userID);\nconst friends = ConnectionHandler.getConnection(\n user,                        // parent record\n 'FriendsFragment_friends'    // connection key\n {orderby: 'firstname'}       // 'filters' that is used to identify the connection\n);\n// Access fields on the connection:\nconst edges = friends.getLinkedRecords('edges');\n\n        \n```"
- name: getDataID()
  id: relay-store#getdataid-string
  summary: Returns the dataID of the current record
  belongs_to: Relay Store
  description: "### `getDataID(): string`\n\nReturns the dataID of the current record.\n\n#### Example\n\n``` javascript\n          const id = record.getDataID();\n\n        \n```"
- name: getLinkedRecord()
  id: relay-store#getlinkedrecordname-string-arguments-object-recordproxy
  summary: Retrieves a record associated with the current record given the field name, as defined by the GraphQL document
  belongs_to: Relay Store
  description: "### `getLinkedRecord(name: string, arguments?: ?Object): ?RecordProxy`\n\nRetrieves a record associated with the current record given the field name, as defined by the GraphQL document. Returns a `RecordProxy`.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          rootField {\n  viewer {\n    id\n    name\n  }\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const rootField = store.getRootField('rootField');\nconst viewer = rootField.getLinkedRecord('viewer');\n\n        \n```\n\nOptionally, if the linked record takes arguments, you can pass a bag of `variables` as well.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          rootField {\n  viewer(arg: $arg) {\n    id\n  }\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const rootField = store.getRootField('rootField');\nconst viewer = rootField.getLinkedRecord('viewer', {arg: 'value'});\n\n        \n```"
- name: getLinkedRecords()
  id: relay-store#getlinkedrecordsname-string-arguments-object-arrayrecordproxy
  summary: Retrieves the set of records associated with the current record given the field name, as defined by the GraphQL document
  belongs_to: Relay Store
  description: "### `getLinkedRecords(name: string, arguments?: ?Object): ?Array<?RecordProxy>`\n\nRetrieves the set of records associated with the current record given the field name, as defined by the GraphQL document. Returns an array of `RecordProxies`.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          rootField {\n  nodes {\n    # ...\n  }\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const rootField = store.getRootField('rootField');\nconst nodes = rootField.getLinkedRecords('nodes');\n\n        \n```\n\nOptionally, if the linked record takes arguments, you can pass a bag of `variables` as well.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          rootField {\n  nodes(first: $count) {\n    # ...\n  }\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const rootField = store.getRootField('rootField');\nconst viewer = rootField.getLinkedRecord('viewer', {count: 10});\n\n        \n```"
- name: getOrCreateLinkedRecord()
  id: relay-store#getorcreatelinkedrecordname-string-typename-string-arguments-object
  summary: Retrieves the a record associated with the current record given the field name, as defined by the GraphQL document
  belongs_to: Relay Store
  description: "### `getOrCreateLinkedRecord(name: string, typeName: string, arguments?: ?Object)`\n\nRetrieves the a record associated with the current record given the field name, as defined by the GraphQL document. If the linked record does not exist, it will be created given the type name. Returns a `RecordProxy`.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          rootField {\n  viewer {\n    id\n  }\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const rootField = store.getRootField('rootField');\nconst newViewer = rootField.getOrCreateLinkedRecord('viewer', 'User'); // Will create if it doesn't exist\n\n        \n```\n\nOptionally, if the linked record takes arguments, you can pass a bag of `variables` as well."
- name: getPluralRootField()
  id: relay-store#getpluralrootfieldfieldname-string-arrayrecordproxy
  summary: Retrieves a root field that represents a collection from the store given the fieldName, as defined by the GraphQL document
  belongs_to: Relay Store
  description: "### `getPluralRootField(fieldName: string): ?Array<?RecordProxy>`\n\nRetrieves a root field that represents a collection from the store given the `fieldName`, as defined by the GraphQL document. Returns an array of [`RecordProxies`](#recordproxy).\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          nodes(first: 10) {\n  # ...\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const nodes = store.getPluralRootField('nodes');\n\n        \n```"
- name: getRoot()
  id: relay-store#getroot-recordproxy
  summary: Returns the RecordProxy representing the root of the GraphQL document
  belongs_to: Relay Store
  description: "### `getRoot(): RecordProxy`\n\nReturns the [`RecordProxy`](#recordproxy) representing the root of the GraphQL document.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          viewer {\n  id\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          // Represents root queryconst root = store.getRoot();\n\n        \n```"
- name: getRootField()
  id: relay-store#getrootfieldfieldname-string-recordproxy
  summary: Retrieves a root field from the store given the fieldName, as defined by the GraphQL document
  belongs_to: Relay Store
  description: "### `getRootField(fieldName: string): ?RecordProxy`\n\nRetrieves a root field from the store given the `fieldName`, as defined by the GraphQL document. Returns a [`RecordProxy`](#recordproxy) which serves as an interface to mutate the record.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          viewer {\n  id\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const viewer = store.getRootField('viewer');\n\n        \n```"
- name: getType()
  id: relay-store#gettype-string
  summary: Gets the type of the current record, as defined by the GraphQL schema
  belongs_to: Relay Store
  description: "### `getType(): string`\n\nGets the type of the current record, as defined by the GraphQL schema.\n\n#### Example\n\n``` javascript\n          const type = user.getType();  // User\n\n        \n```"
- name: getValue()
  id: relay-store#getvaluename-string-arguments-object-mixed
  summary: Gets the value of a field in the current record given the field name
  belongs_to: Relay Store
  description: "### `getValue(name: string, arguments?: ?Object): mixed`\n\nGets the value of a field in the current record given the field name.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          viewer {\n  id\n  name\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const name = viewer.getValue('name');\n\n        \n```\n\nOptionally, if the field takes arguments, you can pass a bag of `variables`.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          viewer {\n  id\n  name(arg: $arg)\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const name = viewer.getValue('name', {arg: 'value'});\n\n        \n```"
- name: graphql
  id: graphql-in-relay#graphql
  summary: The graphql template tag provided by Relay serves as the mechanism to write queries, fragments, mutations or subscriptions in the GraphQL language
  belongs_to: GraphQL in Relay
  description: "## `graphql`\n\nThe `graphql` template tag provided by Relay serves as the mechanism to write queries, fragments, mutations or subscriptions in the [GraphQL](http://graphql.org/learn/) language. For example:\n\n``` javascript\n          import {graphql} from 'react-relay';\n\ngraphql`\n  query MyQuery {\n    viewer {\n      id\n    }\n  }\n`;\n\n        \n```\n\nThe result of using the `graphql` template tag is a `GraphQLTaggedNode`; a runtime representation of the GraphQL document which can be used to define [Query Renderers](query-renderer), [Fragment Containers](fragment-container), [Refetch Containers](refetch-container), [Pagination Containers](pagination-container), etc.\n\nNote that `graphql` template tags are **never executed at runtime**. Instead, they are compiled ahead of time by the [Relay Compiler](#relay-compiler) into generated artifacts that live alongside your source code, and which Relay requires to operate at runtime. The [Relay Babel plugin](installation-and-setup#setup-babel-plugin-relay) will then convert the `graphql` literals in your code into `require()` calls for the generated files."
- name: GraphQL in Relay
  id: graphql-in-relay
  summary: The graphql template tag provided by Relay serves as the mechanism to write queries, fragments, mutations or subscriptions in the GraphQL language
  description: "# GraphQL in Relay\n\nTable of Contents:\n\n- [`graphql`](#graphql)\n- [Directives](#directives)\n- [Relay Compiler](#relay-compiler)\n\n## `graphql`\n\nThe `graphql` template tag provided by Relay serves as the mechanism to write queries, fragments, mutations or subscriptions in the [GraphQL](http://graphql.org/learn/) language. For example:\n\n``` javascript\nimport {graphql} from 'react-relay';\n\ngraphql`\n  query MyQuery {\n    viewer {\n      id\n    }\n  }\n`;\n```\n\nThe result of using the `graphql` template tag is a `GraphQLTaggedNode`; a runtime representation of the GraphQL document which can be used to define [Query Renderers](query-renderer), [Fragment Containers](fragment-container), [Refetch Containers](refetch-container), [Pagination Containers](pagination-container), etc.\n\nNote that `graphql` template tags are **never executed at runtime**. Instead, they are compiled ahead of time by the [Relay Compiler](#relay-compiler) into generated artifacts that live alongside your source code, and which Relay requires to operate at runtime. The [Relay Babel plugin](installation-and-setup#setup-babel-plugin-relay) will then convert the `graphql` literals in your code into `require()` calls for the generated files.\n\n## Directives\n\nRelay uses directives to add additional information to GraphQL documents, which are used by the [Relay Compiler](#relay-compiler) to generate the appropriate runtime artifacts. These directives only appear in your application code and are removed from requests sent to your GraphQL server.\n\n**Note:** The relay-compiler will maintain any directives supported by your server (such as `@include` or `@skip`) so they remain part of the request to the GraphQL server and won't alter generated runtime artifacts.\n\n### `@arguments`\n\n`@arguments` is a directive used to pass arguments to a fragment that was defined using [`@argumentDefinitions`](#argumentdefinitions). For example:\n\n``` javascript\nquery TodoListQuery($userID: ID) {\n  ...TodoList_list @arguments(count: $count, userID: $userID) # Pass arguments here\n}\n```\n\nSee the [Fragment Container docs](fragment-container#passing-arguments-to-a-fragment) for more details.\n\n### `@argumentDefinitions`\n\n`@argumentDefinitions` is a directive used to specify arguments taken by a fragment. For example:\n\n``` javascript\nfragment TodoList_list on TodoList @argumentDefinitions(\n  count: {type: \"Int\", defaultValue: 10},  # Optional argument\n  userID: {type: \"ID\"},                    # Required argument\n) {\n  title\n  todoItems(userID: $userID, first: $count) {  # Use fragment arguments here as variables\n    ...TodoItem_item\n  }\n}\n```\n\nSee the [Fragment Container docs](fragment-container#passing-arguments-to-a-fragment) for more details.\n\n### `@connection(key: String!, filters: [String])`\n\nWhen using the [Pagination Container](pagination-container), Relay expects connection fields to be annotated with a `@connection` directive. For more detailed information and an example, check out the [docs on using `@connection` inside a Pagination Container](pagination-container#connection).\n\n### `@relay(plural: Boolean)`\n\nWhen defining a fragment for use with a Fragment container, you can use the `@relay(plural: true)` directive to indicate that container expects the prop for that fragment to be a list of items instead of a single item. A query or parent that spreads a `@relay(plural: true)` fragment should do so within a plural field (ie a field backed by a [GraphQL list](http://graphql.org/learn/schema/#lists-and-non-null). For example:\n\n``` javascript\n// Plural fragment definition\ngraphql`\nfragment TodoItems_items on TodoItem @relay(plural: true) {\n  id\n  text\n}`;\n\n// Plural fragment usage: note the parent type is a list of items (`TodoItem[]`)\nfragment TodoApp_app on App {\n  items {\n    // parent type is a list here\n    ...TodoItem_items\n  }\n}\n```\n\n### `@inline`\n\nBy default, Relay will only expose the data for fields explicitly requested by a [component's fragment](fragment-container#createfragmentcontainer), which is known as [data masking](thinking-in-relay#data-masking). Fragment data is unmasked for use in React components by `createFragmentContainer`. However, you may want to use fragment data in non-React functions that are called from React.\n\nNon-React functions can also take advantage of data masking. A fragment can be defined with the `@inline` directive and stored in a local variable. The non-React function can then \"unmask\" the data using the `readInlineData` function.\n\nIn the example below, the function `processItemData` is called from a React component. It requires an item object with a specific set of fields. All React components that use this function should spread the `processItemData_item` fragment to ensure all of the correct item data is loaded for this function.\n\n``` javascript\nimport {graphql, readInlineData} from 'react-relay';\n\n// non-React function called from React\nfunction processItemData(itemRef) {\n  const item = readInlineData(graphql`\n    fragment processItemData_item on Item @inline {\n      title\n      price\n      creator {\n        name\n      }\n    }\n  `, itemRef);\n  sendToThirdPartyApi({\n    title: item.title,\n    price: item.price,\n    creatorName: item.creator.name\n  });\n}\n```\n\n``` javascript\n// React Component\nfunction MyComponent({item}) {\n  function handleClick() {\n    processItemData(item);\n  }\n\n  return (\n    <button onClick={handleClick}>Process {item.title}</button>\n  );\n}\n\nexport default createFragmentContainer(MyComponent, {\n  item: graphql`\n    fragment MyComponent_item on Item {\n      ...processItemData_item\n      title\n    }\n  `\n});\n```\n\n### `@relay(mask: Boolean)`\n\nIt is not recommended to use `@relay(mask: false)`. Please instead consider using the `@inline` fragment.\n\n`@relay(mask: false)` can be used to prevent data masking; when including a fragment and annotating it with `@relay(mask: false)`, its data will be available directly to the parent instead of being masked for a different container.\n\nApplied to a fragment definition, `@relay(mask: false)` changes the generated Flow types to be better usable when the fragment is included with the same directive. The Flow types will no longer be exact objects and no longer contain internal marker fields.\n\nThis may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.\n\nKeep in mind that it is typically considered an **anti-pattern** to create a single fragment shared across many containers. Abusing this directive could result in over-fetching in your application.\n\nIn the example below, the `user` prop will include the data for `id` and `name` fields wherever `...Component_internUser` is included, instead of Relay's normal behavior to mask those fields:\n\n``` javascript\ngraphql`\n  fragment Component_internUser on InternUser @relay(mask: false) {\n    id\n    name\n  }\n`;\n\nexport default createFragmentContainer(\n  ({ user }) => /* ... */,\n  graphql`\n    fragment Component_user on User {\n      internUser {\n        manager {\n          ...Component_internUser @relay(mask: false)\n        }\n        ... on Employee {\n          admins {\n            ...Component_internUser @relay(mask: false)\n          }\n          reports {\n            ...Component_internUser @relay(mask: false)\n          }\n        }\n      }\n    }\n  `,\n);\n```\n\n## Relay Compiler\n\nRelay uses the Relay Compiler to convert [`graphql`](#graphql) literals into generated files that live alongside your source files.\n\nA query like the following:\n\n``` javascript\ngraphql`\n  fragment MyComponent on Type {\n    field\n  }\n`\n```\n\nWill cause a generated file to appear in `./__generated__/MyComponent.graphql`, with both runtime artifacts (which help to read and write from the Relay Store) and [Flow types](https://flow.org/) to help you write type-safe code.\n\nThe Relay Compiler is responsible for generating code as part of a build step which can then be referenced at runtime. By building the query ahead of time, the Relay's runtime is not responsible for generating a query string, and various optimizations can be performed on the query that could be too expensive at runtime (for example, fields that are duplicated in the query can be merged during the build step, to improve efficiency of processing the GraphQL response).\n\n### Persisting queries\n\nRelay Compiler supports the use of **persisted queries**, in which each version of a query is associated to a unique ID on the server and the runtime uploads only the persisted ID instead of the full query text. This has several benefits: it can significantly reduce the time to send a query (and the upload bytes) and enables *whitelisting* of queries. For example, you may choose to disallow queries in text form and only allow queries that have been persisted (and that presumably have passed your internal code review process).\n\nPersisted queries can be enabled by instructing Relay Compiler to emit metadata about each query, mutation, and subscription into a JSON file. The generated file will contain a mapping of query identifiers to query text, which you can then save to your server. To enable persisted queries, use the `--persist-output` flag to the compiler:\n\n``` javascript\n\"scripts\": {\n  \"relay\": \"relay-compiler --src ./src --schema ./schema.graphql --persist-output ./path/to/persisted-queries.json\"\n}\n```\n\nRelay Compiler will then create the id =\\> query text mapping in the path you specify. You can then use this complete json file in your server side to map query ids to operation text.\n\nFor more details, refer to the [Persisted Queries section](persisted-queries).\n\n### Set up relay-compiler\n\nSee our relay-compiler section in our [Installation and Setup guide](installation-and-setup#set-up-relay-compiler).\n\n### GraphQL Schema\n\nTo use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a `schema.graphql` like:\n\n``` javascript\nschema {\n  query: Root\n}\n\ntype Root {\n  dictionary: [Word]\n}\n\ntype Word {\n  id: String!\n  definition: WordDefinition\n}\n\ntype WordDefinition {\n  text: String\n  image: String\n}\n```\n\n### Source files\n\nAdditionally, you need a directory containing `.js` files that use the `graphql` tag to describe GraphQL queries and fragments. Let's call this `./src`.\n\nThen run `yarn run relay` as set up before.\n\nThis will create a series of `__generated__` directories that are co-located with the corresponding files containing `graphql` tags.\n\nFor example, given the two files:\n\n- `src/Components/DictionaryComponent.js`\n\n  ``` javascript\n  const DictionaryWordFragment = graphql`\n    fragment DictionaryComponent_word on Word {\n      id\n      definition {\n        ...DictionaryComponent_definition\n      }\n    }\n  `\n\n  const DictionaryDefinitionFragment = graphql`\n    fragment DictionaryComponent_definition on WordDefinition {\n      text\n      image\n    }\n  `\n  ```\n\n- `src/Queries/DictionaryQuery.js`\n\n  ``` javascript\n  const DictionaryQuery = graphql`\n    query DictionaryQuery {\n      dictionary {\n        ...DictionaryComponent_word\n      }\n    }\n  `\n  ```\n\nThis would produce three generated files, and two `__generated__` directories:\n\n- `src/Components/__generated__/DictionaryComponent_word.graphql.js`\n- `src/Components/__generated__/DictionaryComponent_definition.graphql.js`\n- `src/Queries/__generated__/DictionaryQuery.graphql.js`\n\n### Importing generated definitions\n\nTypically you will not need to import your generated definitions. The [Relay Babel plugin](installation-and-setup#setup-babel-plugin-relay) will then convert the `graphql` literals in your code into `require()` calls for the generated files.\n\nHowever the Relay Compiler also automatically generates [Flow](https://flow.org) types as [type comments](https://flow.org/en/docs/types/comments/). For example, you can import the generated Flow types like so:\n\n``` javascript\nimport type {DictionaryComponent_word} from './__generated__/DictionaryComponent_word.graphql';\n```\n\n### Client schema extensions\n\nThe Relay Compiler fully supports client-side schema extensions, which allows you to extend the server schema by defining additional GraphQL types and fields on the client. Relay expects the client schema to be located in your `--src` directory.\n\nFor example, assuming the server schema `./schema.graphql`:\n\n``` javascript\nschema {\n  query: Root\n}\n\ntype Root {\n  title: String!\n}\n```\n\nWe can create a `./src/clientSchema.graphql` and define a new type called `Setting`:\n\n``` javascript\ntype Setting {\n  name: String!\n  active: Boolean!\n}\n```\n\nWe can then extend existing server types in the client schema `./src/clientSchema.graphql` with our new `Setting` type, like so:\n\n``` javascript\nextend type Root {\n  settings: [Setting]\n}\n```\n\nAny fields specified in the client schema, can be fetched from the [Relay Store](relay-store), by selecting it in a query or fragment.\n\nFor more details, refer to the [Local state management section](local-state-management).\n\n### Advanced usage\n\nIn addition to the bin script, the `relay-compiler` package also [exports library code](https://github.com/facebook/relay/blob/master/packages/relay-compiler/index.js) which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.\n\nIf you find you need to do something unique (like generate types that conform to an older version of Flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own `FileWriter` and `ASTCache`, or by adding on an additional `IRTransform`. Note, the internal APIs of the `RelayCompiler` are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/graphql-in-relay.html](https://relay.dev/docs/en/graphql-in-relay.html)"
- name: GraphQL Schema
  id: graphql-in-relay#graphql-schema
  summary: To use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API
  belongs_to: GraphQL in Relay
  description: "### GraphQL Schema\n\nTo use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a `schema.graphql` like:\n\n``` javascript\n          schema {\n  query: Root\n}\n\ntype Root {\n  dictionary: [Word]\n}\n\ntype Word {\n  id: String!\n  definition: WordDefinition\n}\n\ntype WordDefinition {\n  text: String\n  image: String\n}\n\n        \n```"
- name: hasMore
  id: pagination-container#hasmore
  summary: hasMore is a function available on the relay prop
  belongs_to: Pagination Container
  description: "## `hasMore`\n\n`hasMore` is a function available on the `relay` [prop](#available-props). This function indicates whether there are more pages to fetch from the server or not.\n\n``` javascript\n          hasMore: () => boolean,\n\n        \n```"
- name: Importing generated definitions
  id: graphql-in-relay#importing-generated-definitions
  summary: Typically you will not need to import your generated definitions
  belongs_to: GraphQL in Relay
  description: "### Importing generated definitions\n\nTypically you will not need to import your generated definitions. The [Relay Babel plugin](installation-and-setup#setup-babel-plugin-relay) will then convert the `graphql` literals in your code into `require()` calls for the generated files.\n\nHowever the Relay Compiler also automatically generates [Flow](https://flow.org) types as [type comments](https://flow.org/en/docs/types/comments/). For example, you can import the generated Flow types like so:\n\n``` javascript\n          import type {DictionaryComponent_word} from './__generated__/DictionaryComponent_word.graphql';\n\n        \n```"
- name: invalidateRecord()
  id: relay-store#invalidaterecord-void
  summary: Invalidates the record
  belongs_to: Relay Store
  description: "### `invalidateRecord(): void`\n\nInvalidates the record. This will cause any query that references this record to be considered stale until the next time it is refetched, and will be considered to require a refetch the next time such a query is checked with `environment.check()`.\n\n#### Example\n\n``` javascript\n          const record = store.get('4');\nrecord.invalidateRecord();\n\n        \n```\n\nAfter invalidating a record, any query that references the invalidated record and that is checked before refetching it will be considered stale:\n\n``` javascript\n          environment.check(query) === 'stale'\n\n        \n```"
- name: invalidateStore()
  id: relay-store#invalidatestore-void
  summary: Globally invalidates the Relay store
  belongs_to: Relay Store
  description: "### `invalidateStore(): void`\n\nGlobally invalidates the Relay store. This will cause any data that was written to the store before invalidation occurred to be considered stale, and will be considered to require refetch the next time a query is checked with `environment.check()`.\n\n#### Example\n\n``` javascript\n          store.invalidateStore();\n\n        \n```\n\nAfter global invalidation, any query that is checked before refetching it will be considered stale:\n\n``` javascript\n          environment.check(query) === 'stale'\n\n        \n```"
- name: isLoading
  id: pagination-container#isloading
  summary: isLoading is a function available on the relay prop
  belongs_to: Pagination Container
  description: "## `isLoading`\n\n`isLoading` is a function available on the `relay` [prop](#available-props). This function indicates if a previous call to [`loadMore()`](#loadmore) is still pending. This is convenient for avoiding duplicate load calls.\n\n``` javascript\n          isLoading: () => boolean,\n\n        \n```"
- name: Loading more data
  id: refetch-container#loading-more-data
  summary: In this example we are using a Refetch Container to fetch more stories in a story feed component
  belongs_to: Refetch Container
  description: "### Loading more data\n\nIn this example we are using a Refetch Container to fetch more stories in a story feed component.\n\n``` javascript\n          import {createRefetchContainer, graphql} from 'react-relay';\n\nclassFeedStoriesextendsReact.Component{\n  render() {\n    return (\n      <div>\n        {this.props.feed.stories.edges.map(\n          edge => <Story story={edge.node} key={edge.node.id} />\n        )}\n        <button\n          onPress={this._loadMore}\n          title=\"Load More\"\n        />\n      </div>\n    );\n  }\n\n  _loadMore() {\n    // Increments the number of stories being rendered by 10.\n    const refetchVariables = fragmentVariables => ({\n      count: fragmentVariables.count + 10,\n    });\n    this.props.relay.refetch(refetchVariables);\n  }\n}\n\nexport default createRefetchContainer(\n  FeedStories,\n  {\n    feed: graphql`\n      fragment FeedStories_feed on Feed\n      @argumentDefinitions(\n        count: {type: \"Int\", defaultValue: 10}\n      ) {\n        stories(first: $count) {\n          edges {\n            node {\n              id\n              ...Story_story\n            }\n          }\n        }\n      }\n    `\n  },\n  graphql`\n    # Refetch query to be fetched upon calling `refetch`.\n    # Notice that we re-use our fragment and the shape of this query matches our fragment spec.\n    query FeedStoriesRefetchQuery($count: Int) {\n      feed {\n        ...FeedStories_feed @arguments(count: $count)\n      }\n    }\n  `,\n);\n\n        \n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/refetch-container](https://relay.dev/docs/en/refetch-container)"
- name: loadMore
  id: pagination-container#loadmore
  summary: loadMore is a function available on the relay prop
  belongs_to: Pagination Container
  description: "## `loadMore`\n\n`loadMore` is a function available on the `relay` [prop](#available-props). You can call `loadMore()` to fetch more items from the server based on the `connectionConfig` provided to the container. This will return null if there are no more items to fetch, otherwise it will fetch more items and return a Disposable that can be used to cancel the fetch.\n\n``` javascript\n          loadMore(\n  pageSize: number,\n  callback: ?(error: ?Error) => void,\n  options?: RefetchOptions\n): ?Disposable\n\n        \n```\n\n### Arguments:\n\n- `pageSize`: The number of **additional** items to fetch (not the total).\n- `callback`: Function called when the new page has been fetched. If an error occurred during refetch, this function will receive that error as an argument.\n- `options`: Optional object containing set of options.\n  - `force`: If the [Network Layer](network-layer) has been configured with a cache, this option forces a refetch even if the data for this query and variables is already available in the cache.\n\n&nbsp;"
- name: Mutations
  id: mutations
  summary: Use commitMutation to create and execute mutations
  description: "# Mutations\n\nTable of Contents:\n\n- [`commitMutation`](#commitmutation)\n- [Simple Example](#simple-example)\n- [Optimistic Updates](#optimistic-updates)\n- [Updater Configs](#updater-configs)\n- [Using updater and optimisticUpdater](#using-updater-and-optimisticupdater)\n- [Committing Local Updates](#committing-local-updates)\n\n## `commitMutation`\n\nUse `commitMutation` to create and execute mutations. `commitMutation` has the following signature:\n\n``` javascript\ncommitMutation(\n  environment: Environment,\n  config: {\n    mutation: GraphQLTaggedNode,\n    variables: {[name: string]: mixed},\n    onCompleted?: ?(response: ?Object, errors: ?Array<PayloadError>) => void,\n    onError?: ?(error: Error) => void,\n    optimisticResponse?: Object,\n    optimisticUpdater?: ?(store: RecordSourceSelectorProxy) => void,\n    updater?: ?(store: RecordSourceSelectorProxy, data: SelectorData) => void,\n    configs?: Array<DeclarativeMutationConfig>,\n    cacheConfig?: CacheConfig,\n  },\n);\n```\n\n### Arguments\n\n- `environment`: The [Relay Environment](relay-environment). **Note:** To ensure the mutation is performed on the correct `environment`, it's recommended to use the environment available within components (from `this.props.relay.environment`), instead of referencing a global environment.\n- `config`:\n  - `mutation`: The `graphql` tagged mutation query.\n  - `variables`: Object containing the variables needed for the mutation. For example, if the mutation defines an `$input` variable, this object should contain an `input` key, whose shape must match the shape of the data expected by the mutation as defined by the GraphQL schema.\n  - `onCompleted`: Callback function executed when the request is completed and the in-memory Relay store is updated with the `updater` function. Takes a `response` object, which is the updated response from the store, and `errors`, an array containing any errors from the server.\n  - `onError`: Callback function executed if Relay encounters an error during the request.\n  - `optimisticResponse`: Object containing the data to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. This object must have the same shape as the mutation's response type, as defined by the GraphQL schema. If provided, Relay will use the `optimisticResponse` data to update the fields on the relevant records in the local data store, *before* `optimisticUpdater` is executed. If an error occurs during the mutation request, the optimistic update will be rolled back.\n  - `optimisticUpdater`: Function used to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. If an error occurs during the mutation request, the optimistic update will be rolled back. This function takes a `store`, which is a proxy of the in-memory [Relay Store](relay-store). In this function, the client defines 'how to' update the local data via the `store` instance. For details on how to use the `store`, please refer to our [Relay Store API Reference](relay-store). **Please note:**\n    - It is usually preferable to just pass an `optimisticResponse` option instead of an `optimisticUpdater`, unless you need to perform updates on the local records that are more complicated than just updating fields (e.g. deleting records or adding items to collections).\n    - If you do decide to use an `optimisticUpdater`, often times it can be the same function as `updater`.\n  - `updater`: Function used to update the local in-memory store based on the **real** server response from the mutation. If `updater` is not provided, by default, Relay will know to automatically update the fields on the records referenced in the mutation response; however, you should pass an `updater` if you need to make more complicated updates than just updating fields (e.g. deleting records or adding items to collections). When the server response comes back, Relay first reverts any changes introduced by `optimisticUpdater` or `optimisticResponse` and will then execute `updater`. This function takes a `store`, which is a proxy of the in-memory [Relay Store](relay-store). In this function, the client defines 'how to' update the local data based on the server response via the `store` instance. For details on how to use the `store`, please refer to our [Relay Store API Reference](relay-store).\n  - `configs`: Array containing objects describing `optimisticUpdater`/`updater` configurations. `configs` provides a convenient way to specify the `updater` behavior without having to write an `updater` function. See our section on [Updater Configs](#updater-configs) for more details.\n  - `cacheConfig?`: Optional object containing a set of cache configuration options\n\n## Simple Example\n\nExample of a simple mutation:\n\n``` javascript\nimport {commitMutation, graphql} from 'react-relay';\n\nconst mutation = graphql`\n  mutation MarkReadNotificationMutation(\n    $storyID: ID!\n  ) {\n    markReadNotification(id: $storyID) {\n      notification {\n        seenState\n      }\n    }\n  }\n`;\n\nfunction markNotificationAsRead(environment, storyID) {\n  const variables = {\n    storyID,\n  };\n\n  commitMutation(\n    environment,\n    {\n      mutation,\n      variables,\n      onCompleted: (response, errors) => {\n        console.log('Response received from server.')\n      },\n      onError: err => console.error(err),\n    },\n  );\n}\n```\n\n## Optimistic Updates\n\nTo improve perceived responsiveness, you may wish to perform an \"optimistic update\", in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. The simplest way to do this is by providing an `optimisticResponse` and adding it to the `config` that we pass into `commitMutation`:\n\n``` javascript\nconst mutation = graphql`\n  mutation MarkReadNotificationMutation(\n    $storyID: ID!\n  ) {\n    markReadNotification(id: $storyID) {\n      notification {\n        seenState\n      }\n    }\n  }\n`;\n\nconst optimisticResponse = {\n  markReadNotification: {\n    notification: {\n      seenState: SEEN,\n    },\n  },\n};\n\ncommitMutation(\n  environment,\n  {\n    mutation,\n    optimisticResponse,\n    variables,\n  },\n);\n```\n\nAnother way to enable optimistic updates is via the `optimisticUpdater`, which can be used for more complicated update scenarios. Using `optimisticUpdater` is covered in the section [below](#using-updater-and-optimisticupdater).\n\n## Updater Configs\n\nWe can give Relay instructions in the form of a `configs` array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following config types:\n\n### NODE_DELETE\n\nGiven a `deletedIDFieldName`, Relay will remove the node(s) from the store.\n\n**Note**: this will not remove it from any connection it might be in. If you want to remove a node from a connection, take a look at [RANGE_DELETE](#RANGE_DELETE).\n\n#### Arguments\n\n- `deletedIDFieldName: string`: The field name in the response that contains the DataID or DataIDs of the deleted node or nodes\n\n#### Example\n\n``` javascript\nconst mutation = graphql`\n  mutation DestroyShipMutation($target: ID!) {\n    destroyShip(target: $target) {\n      destroyedShipId\n      faction {\n        ships {\n          id\n        }\n      }\n    }\n  }\n`;\n\nconst configs = [{\n  type: 'NODE_DELETE',\n  deletedIDFieldName: 'destroyedShipId',\n}];\n```\n\n### RANGE_ADD\n\nGiven a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.\n\n#### Arguments\n\n- `parentID: string`: The DataID of the parent node that contains the connection.\n- `connectionInfo: Array<{key: string, filters?: Variables, rangeBehavior: string}>`: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore).\n  - `filters`: An object containing GraphQL calls e.g. `const filters = {'orderby': 'chronological'};`.\n- `edgeName: string`: The field name in the response that represents the newly created edge\n\n#### Example\n\n``` javascript\nconst mutation = graphql`\n  mutation AddShipMutation($factionID: ID!, $name: String!) {\n    addShip(factionID: $factionID, name: $name) {\n      shipEdge {\n        node {\n          name\n        }\n      }\n    }\n  }\n`;\n\nfunction commit(environment, factionID, name) {\n  return commitMutation(environment, {\n    mutation,\n    variables: {\n      factionID,\n      name,\n    },\n    configs: [{\n      type: 'RANGE_ADD',\n      parentID: factionID,\n      connectionInfo: [{\n        key: 'AddShip_ships',\n        rangeBehavior: 'append',\n      }],\n      edgeName: 'shipEdge',\n    }],\n  });\n}\n```\n\n### RANGE_DELETE\n\nGiven a parent, `connectionKeys`, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.\n\n#### Arguments\n\n- `parentID: string`: The DataID of the parent node that contains the connection.\n- `connectionKeys: Array<{key: string, filters?: Variables}>`: An array of objects containing a connection key and optionally filters.\n  - `filters`: An object containing GraphQL calls e.g. `const filters = {'orderby': 'chronological'};`.\n- `pathToConnection: Array<string>`: An array containing the field names between the parent and the connection, including the parent and the connection.\n- `deletedIDFieldName: string | Array<string>`: The field name in the response that contains the DataID or DataIDs of the removed node or nodes, or the path to the node or nodes removed from the connection\n\n#### Example\n\n``` javascript\nconst mutation = graphql`\n  mutation RemoveTagMutation($todoID: ID!, $tagID: ID!) {\n    removeTag(todo: $todoID, tag: $tagID) {\n      removedTagID\n    }\n  }\n`;\n\nfunction commit(environment, todoID, tagID) {\n  return commitMutation(environment, {\n    mutation,\n    variables: {\n      todoID,\n      tagID,\n    },\n    configs: [{\n      type: 'RANGE_DELETE',\n      parentID: todoID,\n      connectionKeys: [{\n        key: 'RemoveTags_tags',\n      }],\n      pathToConnection: ['todo', 'tags'],\n      deletedIDFieldName: 'removedTagID',\n    }],\n  });\n}\n```\n\n## Using updater and optimisticUpdater\n\n`updater` and `optimisticUpdater` are functions that you can pass to a `commitMutation` call when you need full control over how to update the local data store, either optimistically, or based on a server response. Often times, both of these can be the same function.\n\nWhen you provide these functions, this is roughly what happens during the mutation request:\n\n- If `optimisticResponse` is provided, Relay will use it to update the fields under the records as specified by the ids in the `optimisticResponse`.\n- If `optimisticUpdater` is provided, Relay will execute it and update the store accordingly.\n- After the network comes back, if any optimistic update was applied, it will be rolled back.\n- Relay will then automatically update the fields under the record corresponding to the ids in the response payload.\n- If an `updater` was provided, Relay will execute it and update the store accordingly. The server payload will be available to the `updater` as a root field in the store.\n\nHere are a quick example of adding a todo item to a Todo list using this [example schema](https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L36):\n\n``` javascript\n// AddTodoMutation.js\nimport {commitMutation, graphql} from 'react-relay';\nimport {ConnectionHandler} from 'relay-runtime';\n\nconst mutation = graphql`\n  mutation AddTodoMutation($text: String!) {\n    addTodo(text: $text) {\n      todoEdge {\n        cursor\n        node {\n          complete\n          id\n          text\n        }\n      }\n      viewer {\n        id\n        totalCount\n      }\n    }\n  }\n`;\n\nfunction sharedUpdater(store, user, newEdge) {\n  // Get the current user record from the store\n  const userProxy = store.get(user.id);\n\n  // Get the user's Todo List using ConnectionHandler helper\n  const conn = ConnectionHandler.getConnection(\n    userProxy,\n    'TodoList_todos', // This is the connection identifier, defined here\n    // https://github.com/relayjs/relay-examples/blob/master/todo/js/components/TodoList.js#L76\n  );\n\n  // Insert the new todo into the Todo List connection\n  ConnectionHandler.insertEdgeAfter(conn, newEdge);\n}\n\nlet tempID = 0;\n\nfunction commit(environment, text, user) {\n  return commitMutation(environment, {\n    mutation,\n    variables: {\n      text,\n    },\n    updater: (store) => {\n      // Get the payload returned from the server\n      const payload = store.getRootField('addTodo');\n\n      // Get the edge of the newly created Todo record\n      const newEdge = payload.getLinkedRecord('todoEdge');\n\n      // Add it to the user's todo list\n      sharedUpdater(store, user, newEdge);\n    },\n    optimisticUpdater: (store) => {\n      // Create a Todo record in our store with a temporary ID\n      const id = 'client:newTodo:' + tempID++;\n      const node = store.create(id, 'Todo');\n      node.setValue(text, 'text');\n      node.setValue(id, 'id');\n\n      // Create a new edge that contains the newly created Todo record\n      const newEdge = store.create(\n        'client:newEdge:' + tempID++,\n        'TodoEdge',\n      );\n      newEdge.setLinkedRecord(node, 'node');\n\n      // Add it to the user's todo list\n      sharedUpdater(store, user, newEdge);\n\n      // Given that we don't have a server response here,\n      // we also need to update the todo item count on the user\n      const userRecord = store.get(user.id);\n      userRecord.setValue(\n        userRecord.getValue('totalCount') + 1,\n        'totalCount',\n      );\n    },\n  });\n}\n```\n\nFor details on how to interact with the Relay Store, please refer to our Relay Store [docs](relay-store).\n\n## Committing Local Updates\n\nUse `commitLocalUpdate` when you need to update the local store without necessarily executing a mutation (such as in the case of debounced operations). The function takes in a Relay `environment` and an `updater` function.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/mutations.html](https://relay.dev/docs/en/mutations.html)"
- name: Mutations
  id: thinking-in-graphql#mutations
  summary: So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes
  belongs_to: Thinking in GraphQL
  description: "## Mutations\n\nSo far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called **mutations**. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:\n\n``` javascript\n          // Give a human-readable name and define the types of the inputs,// in this case the id of the story to mark as liked.\nmutation StoryLike($storyID: String) {\n   // Call the mutation field and trigger its side effects\n   storyLike(storyID: $storyID) {\n     // Define fields to re-fetch after the mutation completes\n     likeCount\n   }\n}\n\n        \n```\n\nNotice that we're querying for data that *may* have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over *any* data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.\n\nWe've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying *data storage* (disk) and data changes in your *product-visible schema* (GraphQL). The perfect example of this is privacy: returning a user-facing field such as `age` might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to *see* that `age` (Are we friends? Is my age shared? Did I block you? etc.).\n\nGiven these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas — let's look at them briefly in order to understand why Relay uses the approach that it does:\n\n- Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the *entire* query, wait to download the results, and wait to process them again. This is very inefficient.\n\n- Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that *isn't* currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.\n\n- Option 3: Re-fetch a fixed list of fields that *may* change after the mutation. We'll call this list a **fat query**. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.\n\n- Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called **tracked queries**. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more."
- name: Network Layer
  id: network-layer
  summary: In order to know how to access your GraphQL server, Relay Modern requires developers to provide an object implementing the NetworkLayer interface when creating an instance of a Relay Environment
  description: "# Network Layer\n\nIn order to know how to access your GraphQL server, Relay Modern requires developers to provide an object implementing the `NetworkLayer` interface when creating an instance of a [Relay Environment](relay-environment). The environment uses this network layer to execute queries, mutations, and (if your server supports them) subscriptions. This allows developers to use whatever transport (HTTP, WebSockets, etc) and authentication is most appropriate for their application, decoupling the environment from the particulars of each application's network configuration.\n\nCurrently the easiest way to create a network layer is via a helper from the `relay-runtime` package:\n\n``` javascript\nimport {\n  Environment,\n  Network,\n  RecordSource,\n  Store,\n} from 'relay-runtime';\n\n// Define a function that fetches the results of an operation (query/mutation/etc)\n// and returns its results as a Promise:\nfunction fetchQuery(\n  operation,\n  variables,\n  cacheConfig,\n  uploadables,\n) {\n  return fetch('/graphql', {\n    method: 'POST',\n    headers: {\n      // Add authentication and other headers here\n      'content-type': 'application/json'\n    },\n    body: JSON.stringify({\n      query: operation.text, // GraphQL text from input\n      variables,\n    }),\n  }).then(response => {\n    return response.json();\n  });\n}\n\n// Create a network layer from the fetch function\nconst network = Network.create(fetchQuery);\nconst store = new Store(new RecordSource())\n\nconst environment = new Environment({\n  network,\n  store\n  // ... other options\n});\n\nexport default environment;\n```\n\nNote that this is a basic example to help you get started. This example could be extended with additional features such as request/response caching (enabled e.g. when `cacheConfig.force` is false) and uploading form data for mutations (the `uploadables` parameter).\n\n## Caching\n\nRelay modern makes no assumptions about what to cache and will garbage collect any data that is no longer referenced.\n\nYou have to implement your own cache strategy. A simple solution is to use `QueryResponseCache` (an in-memory cache):\n\n``` javascript\nimport {\n  Environment,\n  Network,\n  QueryResponseCache,\n  RecordSource,\n  Store,\n} from 'relay-runtime';\n\nconst oneMinute = 60 * 1000;\nconst cache = new QueryResponseCache({ size: 250, ttl: oneMinute });\n\nfunction fetchQuery(\n  operation,\n  variables,\n  cacheConfig,\n) {\n  const queryID = operation.text;\n  const isMutation = operation.operationKind === 'mutation';\n  const isQuery = operation.operationKind === 'query';\n  const forceFetch = cacheConfig && cacheConfig.force;\n\n  // Try to get data from cache on queries\n  const fromCache = cache.get(queryID, variables);\n  if (\n    isQuery &&\n    fromCache !== null &&\n    !forceFetch\n  ) {\n    return fromCache;\n  }\n\n  // Otherwise, fetch data from server\n  return fetch('/graphql', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      query: operation.text,\n      variables,\n    }),\n  }).then(response => {\n    return response.json();\n  }).then(json => {\n    // Update cache on queries\n    if (isQuery && json) {\n      cache.set(queryID, variables, json);\n    }\n    // Clear cache on mutations\n    if (isMutation) {\n      cache.clear();\n    }\n\n    return json;\n  });\n}\n\nconst environment = new Environment({\n  network: Network.create(fetchQuery),\n  store: new Store(new RecordSource()),\n});\n\nexport default environment;\n```\n\n## Custom open-source implementations\n\n**[react-relay-network-modern](https://github.com/relay-tools/react-relay-network-modern)** on [npm](https://www.npmjs.com/package/react-relay-network-modern) - is a Network Layer for Relay Modern which has built-in highly customizable middlewares for commonly used scenarios: batching query requests, caching, authentication, request retrying, logging. Moreover, you may write your own middlewares with custom logic.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/network-layer.html](https://relay.dev/docs/en/network-layer.html)"
- name: NODE_DELETE
  id: mutations#node_delete
  summary: Given a deletedIDFieldName, Relay will remove the node(s) from the store
  belongs_to: Mutations
  description: "### NODE_DELETE\n\nGiven a `deletedIDFieldName`, Relay will remove the node(s) from the store.\n\n**Note**: this will not remove it from any connection it might be in. If you want to remove a node from a connection, take a look at [RANGE_DELETE](#RANGE_DELETE).\n\n#### Arguments\n\n- `deletedIDFieldName: string`: The field name in the response that contains the DataID or DataIDs of the deleted node or nodes\n\n#### Example\n\n``` javascript\n          const mutation = graphql`\n  mutation DestroyShipMutation($target: ID!) {\n    destroyShip(target: $target) {\n      destroyedShipId\n      faction {\n        ships {\n          id\n        }\n      }\n    }\n  }\n`;\n\nconst configs = [{\n  type: 'NODE_DELETE',\n  deletedIDFieldName: 'destroyedShipId',\n}];\n\n        \n```"
- name: Optimistic Updates
  id: mutations#optimistic-updates
  summary: To improve perceived responsiveness, you may wish to perform an "optimistic update", in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back
  belongs_to: Mutations
  description: "## Optimistic Updates\n\nTo improve perceived responsiveness, you may wish to perform an \"optimistic update\", in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. The simplest way to do this is by providing an `optimisticResponse` and adding it to the `config` that we pass into `commitMutation`:\n\n``` javascript\n          const mutation = graphql`\n  mutation MarkReadNotificationMutation(\n    $storyID: ID!\n  ) {\n    markReadNotification(id: $storyID) {\n      notification {\n        seenState\n      }\n    }\n  }\n`;\n\nconst optimisticResponse = {\n  markReadNotification: {\n    notification: {\n      seenState: SEEN,\n    },\n  },\n};\n\ncommitMutation(\n  environment,\n  {\n    mutation,\n    optimisticResponse,\n    variables,\n  },\n);\n\n        \n```\n\nAnother way to enable optimistic updates is via the `optimisticUpdater`, which can be used for more complicated update scenarios. Using `optimisticUpdater` is covered in the section [below](#using-updater-and-optimisticupdater)."
- name: Pagination Container
  id: pagination-container
  summary: Pagination Container is also a higher-order component, similar to a Fragment Container, that is designed to simplify the workflow of loading more items in a list — in many cases, we don't want to fetch all the data at once but lazily load more data
  description: "# Pagination Container\n\nPagination Container is also a [higher-order component](https://reactjs.org/docs/higher-order-components.html), similar to a [Fragment Container](fragment-container), that is designed to simplify the workflow of loading more items in a list — in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out [this page](https://relay.dev/graphql/connections.htm).\n\nTable of Contents:\n\n- [`@connection`](#connection)\n- [`createPaginationContainer`](#createpaginationcontainer)\n- [`hasMore`](#hasmore)\n- [`isLoading`](#isloading)\n- [`loadMore`](#loadmore)\n- [`refetchConnection`](#refetchconnection)\n- [Pagination Example](#pagination-example)\n\n## `@connection`\n\nPagination Container works in a very similar way to the [Fragment Container](fragment-container) in that you also specify the data requirements for a component via GraphQL fragments in the `fragmentSpec`.\n\nHowever, when [specifying connection fragments](#createpaginationcontainer) for a Pagination Container, it is expected that at least one of the fragments contains a [GraphQL connection](https://relay.dev/graphql/connections.htm) to paginate over, and that the connection field is annotated with a `@connection` directive.\n\nThe purpose of the `@connection` directive is to allow Relay to uniquely identify different connections under a parent type. The `@connection` directive takes 2 arguments that help identify the connection:\n\n``` javascript\n@connection(key: String!, filters: [String])\n```\n\n- `key`: **Required** String that serves as a unique identifier for the connection under the parent field type. A good practice could be `<ComponentName>_<fieldName | fieldAlias>`.\n- `filters`: **Optional** Array of strings that belong to the set of argument variables defined for the connection field (e.g. `orderBy`, `searchTerm`, etc). The values for the variables specified in this array will be used alongside the user-supplied `key` to uniquely identify a connection. If `filters` is not provided, by default Relay will use the set of all of the arguments the connection field takes, excluding pagination specific arguments (i.e. `first`/`last`, `after`/`before`).\n\n### Examples\n\nSpecifying just the `key`:\n\n``` javascript\nfragment Feed_user on User {\n  # This connection, under a specific User, will be uniquely identified by\n  # the key \"Feed_feed\" and the value of `$orderBy` (given that no `filters` were provided)\n  feed(\n    first: $count\n    after: $cursor\n    orderby: $orderBy\n  ) @connection(key: \"Feed_feed\") {\n    edges {\n      node {\n        id,\n        ...Story_story\n      }\n  }\n}\n```\n\nSpecifying `key` and `filters`:\n\n``` javascript\nfragment Feed_user on User {\n  # This connection, under a specific User, will be uniquely identified by\n  # the key \"Feed_feed\" and /only/ the value of `$searchTerm`, i.e.\n  # different values of `orderBy` will not distinguish connections.\n  feed(\n    first: $count\n    after: $cursor\n    orderby: $orderBy\n    search_term: $searchTerm\n  ) @connection(key: \"Feed_feed\", filters: [\"searchTerm\"]) {\n    edges {\n      node {\n        id,\n        ...Story_story\n      }\n  }\n}\n```\n\n## `createPaginationContainer`\n\n`createPaginationContainer` has the following signature:\n\n``` javascript\ncreatePaginationContainer(\n  component: ReactComponentClass,\n  fragmentSpec: {[string]: GraphQLTaggedNode},\n  connectionConfig: ConnectionConfig,\n): ReactComponentClass;\n\ntype ConnectionConfig = {\n  direction?: 'backward' | 'forward',\n  getConnectionFromProps?: (props: Object) => ?ConnectionData,\n  getFragmentVariables?: (previousVariables: Object, totalCount: number) => Object,\n  getVariables: (\n    props: Object,\n    paginationInfo: {count: number, cursor: ?string},\n    fragmentVariables: Object,\n  ) => Object,\n  query: GraphQLTaggedNode,\n};\n\ntype ConnectionData = {\n  edges?: ?Array<any>,\n  pageInfo?: ?{\n    endCursor: ?string,\n    hasNextPage: boolean,\n    hasPreviousPage: boolean,\n    startCursor: ?string,\n  },\n};\n```\n\n### Arguments\n\n- `component`: The React Component *class* of the component requiring the fragment data.\n- `fragmentSpec`: Specifies the data requirements for the Component via a GraphQL fragment. It is expected that one of the fragments specified here will contain a [`@connection`](#connection) for pagination. The required data will be available on the component as props that match the shape of the provided fragment. `fragmentSpec` should be an object whose keys are prop names and values are `graphql` tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.\n  - **Note:** `relay-compiler` enforces fragments to be named as `<FileName>_<propName>`.\n- `connectionConfig`:\n  - `direction`: Either \"forward\" to indicate forward pagination using after/first, or \"backward\" to indicate backwards pagination using before/last. If not provided, Relay will infer the direction based on the provided `@connection` directive.\n  - `getConnectionFromProps`: Function that should indicate which connection to paginate over, given the fragment props (i.e. the props corresponding to the `fragmentSpec`). This is necessary in most cases because the Relay can't automatically tell which connection you mean to paginate over (a container might fetch multiple fragments and connections, but can only paginate one of them). If not provided, Relay will try infer the correct connection to paginate over based on the provided `@connection` directive. See our [example](#pagination-example) for more details.\n  - `getFragmentVariables`: Function that should return the bag of variables to use for reading out the data from the store when re-rendering the component. This function takes the previous set of variables passed to the pagination `query`, and the number of elements that have been fetched in total so far. Specifically, this indicates which variables to use when reading out the data from the local data store *after* the new pagination `query` has been fetched. If not specified, Relay will default to using all of the previous variables and using the total count for the `count` variable. This option is analogous to [`renderVariables`](refetch-container#refetch) in the Refetch Container. See our [example](#pagination-example) for more details.\n  - `getVariables`: Function that should return the variables to pass to the pagination `query` when fetching it from the server, given the current `props`, `count` and `cursor`. You may set whatever variables here, as well as modify the defaults to use for after/first/before/last arguments. See our [example](#pagination-example) for more details.\n  - `query`: A `graphql` tagged query to be used as the pagination query to fetch more data upon calling [`loadMore`](#loadmore).\n\n### Available Props\n\nThe Component resulting from `createPaginationContainer` will receive the following `props`:\n\n``` javascript\ntype Props = {\n  relay: {\n    environment: Environment,\n    hasMore(), // See #hasMore section\n    isLoading(), // See #isLoading section\n    loadMore(), // See #loadMore section\n    refetchConnection(), // See #refetchConnection section\n  },\n  // Additional props as specified by the fragmentSpec\n}\n```\n\n- `relay`:\n  - `environment`: The current [Relay Environment](relay-environment)\n  - `hasMore`: See `hasMore` [docs](#hasmore)\n  - `isLoading`: See `isLoading` [docs](#isloading)\n  - `loadMore`: See `loadMore` [docs](#loadmore)\n  - `refetchConnection`: See `refetchConnection` [docs](#refetchconnection)\n\n## `hasMore`\n\n`hasMore` is a function available on the `relay` [prop](#available-props). This function indicates whether there are more pages to fetch from the server or not.\n\n``` javascript\nhasMore: () => boolean,\n```\n\n## `isLoading`\n\n`isLoading` is a function available on the `relay` [prop](#available-props). This function indicates if a previous call to [`loadMore()`](#loadmore) is still pending. This is convenient for avoiding duplicate load calls.\n\n``` javascript\nisLoading: () => boolean,\n```\n\n## `loadMore`\n\n`loadMore` is a function available on the `relay` [prop](#available-props). You can call `loadMore()` to fetch more items from the server based on the `connectionConfig` provided to the container. This will return null if there are no more items to fetch, otherwise it will fetch more items and return a Disposable that can be used to cancel the fetch.\n\n``` javascript\nloadMore(\n  pageSize: number,\n  callback: ?(error: ?Error) => void,\n  options?: RefetchOptions\n): ?Disposable\n```\n\n### Arguments:\n\n- `pageSize`: The number of **additional** items to fetch (not the total).\n- `callback`: Function called when the new page has been fetched. If an error occurred during refetch, this function will receive that error as an argument.\n- `options`: Optional object containing set of options.\n  - `force`: If the [Network Layer](network-layer) has been configured with a cache, this option forces a refetch even if the data for this query and variables is already available in the cache.\n\n## `refetchConnection`\n\n`refetchConnection` is a function available on the `relay` [prop](#available-props). You can call `refetchConnection` to restart pagination on a connection from scratch, with optionally a completely new set of variables to pass to the pagination `query`. This is useful for example if you are paginating over a collection based on a userID and the userID changes, you'd want to start paginating over the new collection for the new user.\n\n``` javascript\nrefetchConnection:(\n  totalCount: number,\n  callback: (error: ?Error) => void,\n  refetchVariables: ?Variables,\n) => ?Disposable,\n```\n\n### Arguments:\n\n- `totalCount`: The total number of elements to fetch\n- `callback`: Function called when the new page has been fetched. If an error occurred during refetch, this function will receive that error as an argument.\n- `refetchVariables`: A potentially new bag of variables to pass to the pagination `query` when fetching it from the server.\n\n## Pagination Example\n\n``` javascript\n// Feed.js\nimport {createPaginationContainer, graphql} from 'react-relay';\n\nclass Feed extends React.Component {\n  render() {\n    return (\n      <div>\n        {this.props.user.feed.edges.map(\n          edge => <Story story={edge.node} key={edge.node.id} />\n        )}\n        <button\n          onPress={() => this._loadMore()}\n          title=\"Load More\"\n        />\n      </div>\n    );\n  }\n\n  _loadMore() {\n    if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {\n      return;\n    }\n\n    this.props.relay.loadMore(\n      10,  // Fetch the next 10 feed items\n      error => {\n        console.log(error);\n      },\n    );\n  }\n}\n\nmodule.exports = createPaginationContainer(\n  Feed,\n  {\n    user: graphql`\n      fragment Feed_user on User\n      @argumentDefinitions(\n        count: {type: \"Int\", defaultValue: 10}\n        cursor: {type: \"ID\"}\n        orderby: {type: \"[FriendsOrdering]\", defaultValue: [DATE_ADDED]}\n      ) {\n        feed(\n          first: $count\n          after: $cursor\n          orderby: $orderBy # Non-pagination variables\n        ) @connection(key: \"Feed_feed\") {\n          edges {\n            node {\n              id\n              ...Story_story\n            }\n          }\n        }\n      }\n    `,\n  },\n  {\n    direction: 'forward',\n    getConnectionFromProps(props) {\n      return props.user && props.user.feed;\n    },\n    // This is also the default implementation of `getFragmentVariables` if it isn't provided.\n    getFragmentVariables(prevVars, totalCount) {\n      return {\n        ...prevVars,\n        count: totalCount,\n      };\n    },\n    getVariables(props, {count, cursor}, fragmentVariables) {\n      return {\n        count,\n        cursor,\n        orderBy: fragmentVariables.orderBy,\n        // userID isn't specified as an @argument for the fragment, but it should be a variable available for the fragment under the query root.\n        userID: fragmentVariables.userID,\n      };\n    },\n    query: graphql`\n      # Pagination query to be fetched upon calling 'loadMore'.\n      # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.\n      query FeedPaginationQuery(\n        $count: Int!\n        $cursor: ID\n        $orderBy: [FriendsOrdering]!\n        $userID: ID!\n      ) {\n        user: node(id: $userID) {\n          ...Feed_user @arguments(count: $count, cursor: $cursor, orderBy: $orderBy)\n        }\n      }\n    `\n  }\n);\n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/pagination-container.html](https://relay.dev/docs/en/pagination-container.html)"
- name: Pagination Example
  id: pagination-container#pagination-example
  summary: © 2020–present Facebook Inc
  belongs_to: Pagination Container
  description: "## Pagination Example\n\n``` javascript\n          // Feed.jsimport {createPaginationContainer, graphql} from 'react-relay';\n\nclassFeedextendsReact.Component{\n  render() {\n    return (\n      <div>\n        {this.props.user.feed.edges.map(\n          edge => <Story story={edge.node} key={edge.node.id} />\n        )}\n        <button\n          onPress={() => this._loadMore()}\n          title=\"Load More\"\n        />\n      </div>\n    );\n  }\n\n  _loadMore() {\n    if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {\n      return;\n    }\n\n    this.props.relay.loadMore(\n      10,  // Fetch the next 10 feed items\n      error => {\n        console.log(error);\n      },\n    );\n  }\n}\n\nmodule.exports = createPaginationContainer(\n  Feed,\n  {\n    user: graphql`\n      fragment Feed_user on User\n      @argumentDefinitions(\n        count: {type: \"Int\", defaultValue: 10}\n        cursor: {type: \"ID\"}\n        orderby: {type: \"[FriendsOrdering]\", defaultValue: [DATE_ADDED]}\n      ) {\n        feed(\n          first: $count\n          after: $cursor\n          orderby: $orderBy # Non-pagination variables\n        ) @connection(key: \"Feed_feed\") {\n          edges {\n            node {\n              id\n              ...Story_story\n            }\n          }\n        }\n      }\n    `,\n  },\n  {\n    direction: 'forward',\n    getConnectionFromProps(props) {\n      return props.user && props.user.feed;\n    },\n    // This is also the default implementation of `getFragmentVariables` if it isn't provided.\n    getFragmentVariables(prevVars, totalCount) {\n      return {\n        ...prevVars,\n        count: totalCount,\n      };\n    },\n    getVariables(props, {count, cursor}, fragmentVariables) {\n      return {\n        count,\n        cursor,\n        orderBy: fragmentVariables.orderBy,\n        // userID isn't specified as an @argument for the fragment, but it should be a variable available for the fragment under the query root.\n        userID: fragmentVariables.userID,\n      };\n    },\n    query: graphql`\n      # Pagination query to be fetched upon calling 'loadMore'.\n      # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.\n      query FeedPaginationQuery(\n        $count: Int!\n        $cursor: ID\n        $orderBy: [FriendsOrdering]!\n        $userID: ID!\n      ) {\n        user: node(id: $userID) {\n          ...Feed_user @arguments(count: $count, cursor: $cursor, orderBy: $orderBy)\n        }\n      }\n    `\n  }\n);\n\n        \n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/pagination-container.html](https://relay.dev/docs/en/pagination-container.html)"
- name: Persisting queries
  id: graphql-in-relay#persisting-queries
  summary: Relay Compiler supports the use of persisted queries, in which each version of a query is associated to a unique ID on the server and the runtime uploads only the persisted ID instead of the full query text
  belongs_to: GraphQL in Relay
  description: "### Persisting queries\n\nRelay Compiler supports the use of **persisted queries**, in which each version of a query is associated to a unique ID on the server and the runtime uploads only the persisted ID instead of the full query text. This has several benefits: it can significantly reduce the time to send a query (and the upload bytes) and enables *whitelisting* of queries. For example, you may choose to disallow queries in text form and only allow queries that have been persisted (and that presumably have passed your internal code review process).\n\nPersisted queries can be enabled by instructing Relay Compiler to emit metadata about each query, mutation, and subscription into a JSON file. The generated file will contain a mapping of query identifiers to query text, which you can then save to your server. To enable persisted queries, use the `--persist-output` flag to the compiler:\n\n``` javascript\n          \"scripts\": {\n  \"relay\": \"relay-compiler --src ./src --schema ./schema.graphql --persist-output ./path/to/persisted-queries.json\"\n}\n\n        \n```\n\nRelay Compiler will then create the id =\\> query text mapping in the path you specify. You can then use this complete json file in your server side to map query ids to operation text.\n\nFor more details, refer to the [Persisted Queries section](persisted-queries)."
- name: Populating The Cache
  id: thinking-in-graphql#populating-the-cache
  summary: Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records
  belongs_to: Thinking in GraphQL
  description: |-
    ### Populating The Cache

    Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider `user(id: "456") { photo(size: 32) { uri } }` — how should we store `photo`? Using `photo` as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. `photo(size: 64) {...}`). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with `stories(first: 10, offset: 10)`, these new results should be *appended* to the existing list.

    Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the `photo` field from above might be cached with a generated field name such as `photo_size(32)` in order to uniquely identify the field and its argument values.
- name: Props
  id: query-renderer#props
  summary: © 2020–present Facebook Inc
  belongs_to: QueryRenderer
  description: "## Props\n\n- `environment`: The [Relay Environment](relay-environment)\n- `query`: The `graphql` tagged query. **Note:** `relay-compiler` enforces the query to be named as `<FileName>Query`. Optional, if not provided, an empty `props` object is passed to the `render` callback.\n- `cacheConfig?`: Optional object containing a set of cache configuration options, i.e. `force: true` requires the fetch to be issued regardless of the state of any configured response cache.\n- `fetchPolicy?`: Optional prop to indicate if data already present in the store should be used to render immediately and updated from the network afterwards using the `store-and-network` key. Using the `network-only` key, which is the default behavior, ignores data already present in the store and waits for the network results to come back.\n- `variables`: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value. **Note:** If a new set of variables is passed, the `QueryRenderer` will re-fetch the query.\n- `render`: Function of type `({error, props, retry}) => React.Node`. The output of this function will be rendered by the `QueryRenderer`.\n  - `props`: Object containing data obtained from the query; the shape of this object will match the shape of the query. If this object is not defined, it means that the data is still being fetched.\n  - `error`: Error will be defined if an error has occurred while fetching the query.\n  - `retry`: Reload the data. It is null if `query` was not provided.\n\n## Example\n\n``` javascript\n          // Example.jsimport React from 'react';\nimport { QueryRenderer, graphql } from 'react-relay';\n\nconst renderQuery = ({error, props}) => {\n  if (error) {\n    return <div>{error.message}</div>;\n  } else if (props) {\n    return <div>{props.page.name} is great!</div>;\n  }\n  return <div>Loading</div>;\n}\n  \nconst Example = (props) => {\n  return (\n    <QueryRenderer\n      environment={environment}\n      query={graphql`\n        query ExampleQuery($pageID: ID!) {\n          page(id: $pageID) {\n            name\n          }\n        }\n      `}\n      variables={{\n        pageID: '110798995619330',\n      }}\n      render={renderQuery}\n    />\n  );\n}\n\n        \n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/query-renderer.html](https://relay.dev/docs/en/query-renderer.html)"
- name: QueryRenderer
  id: query-renderer
  summary: A QueryRenderer is a React Component at the root of a Relay component tree
  description: "# QueryRenderer\n\nA `QueryRenderer` is a React Component at the root of a Relay component tree. It takes a query, fetches the given query, and uses the `render` prop to render the resulting data.\n\nAs React components, `QueryRenderer`s can be rendered anywhere that a React component can be rendered, i.e. not just at the top level but *within* other components or containers; for example, to lazily fetch additional data for a popover.\n\nHowever, a `QueryRenderer` will not start loading its data until it is mounted, so nested `QueryRenderer` components can lead to request waterfalls if used unnecessarily.\n\n## Props\n\n- `environment`: The [Relay Environment](relay-environment)\n- `query`: The `graphql` tagged query. **Note:** `relay-compiler` enforces the query to be named as `<FileName>Query`. Optional, if not provided, an empty `props` object is passed to the `render` callback.\n- `cacheConfig?`: Optional object containing a set of cache configuration options, i.e. `force: true` requires the fetch to be issued regardless of the state of any configured response cache.\n- `fetchPolicy?`: Optional prop to indicate if data already present in the store should be used to render immediately and updated from the network afterwards using the `store-and-network` key. Using the `network-only` key, which is the default behavior, ignores data already present in the store and waits for the network results to come back.\n- `variables`: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value. **Note:** If a new set of variables is passed, the `QueryRenderer` will re-fetch the query.\n- `render`: Function of type `({error, props, retry}) => React.Node`. The output of this function will be rendered by the `QueryRenderer`.\n  - `props`: Object containing data obtained from the query; the shape of this object will match the shape of the query. If this object is not defined, it means that the data is still being fetched.\n  - `error`: Error will be defined if an error has occurred while fetching the query.\n  - `retry`: Reload the data. It is null if `query` was not provided.\n\n## Example\n\n``` javascript\n// Example.js\nimport React from 'react';\nimport { QueryRenderer, graphql } from 'react-relay';\n\nconst renderQuery = ({error, props}) => {\n  if (error) {\n    return <div>{error.message}</div>;\n  } else if (props) {\n    return <div>{props.page.name} is great!</div>;\n  }\n  return <div>Loading</div>;\n}\n  \nconst Example = (props) => {\n  return (\n    <QueryRenderer\n      environment={environment}\n      query={graphql`\n        query ExampleQuery($pageID: ID!) {\n          page(id: $pageID) {\n            name\n          }\n        }\n      `}\n      variables={{\n        pageID: '110798995619330',\n      }}\n      render={renderQuery}\n    />\n  );\n}\n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/query-renderer.html](https://relay.dev/docs/en/query-renderer.html)"
- name: RANGE_ADD
  id: mutations#range_add
  summary: Given a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo
  belongs_to: Mutations
  description: "### RANGE_ADD\n\nGiven a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.\n\n#### Arguments\n\n- `parentID: string`: The DataID of the parent node that contains the connection.\n- `connectionInfo: Array<{key: string, filters?: Variables, rangeBehavior: string}>`: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore).\n  - `filters`: An object containing GraphQL calls e.g. `const filters = {'orderby': 'chronological'};`.\n- `edgeName: string`: The field name in the response that represents the newly created edge\n\n#### Example\n\n``` javascript\n          const mutation = graphql`\n  mutation AddShipMutation($factionID: ID!, $name: String!) {\n    addShip(factionID: $factionID, name: $name) {\n      shipEdge {\n        node {\n          name\n        }\n      }\n    }\n  }\n`;\n\nfunctioncommit(environment, factionID, name) {\n  return commitMutation(environment, {\n    mutation,\n    variables: {\n      factionID,\n      name,\n    },\n    configs: [{\n      type: 'RANGE_ADD',\n      parentID: factionID,\n      connectionInfo: [{\n        key: 'AddShip_ships',\n        rangeBehavior: 'append',\n      }],\n      edgeName: 'shipEdge',\n    }],\n  });\n}\n\n        \n```"
- name: RANGE_DELETE
  id: mutations#range_delete
  summary: Given a parent, connectionKeys, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store
  belongs_to: Mutations
  description: "### RANGE_DELETE\n\nGiven a parent, `connectionKeys`, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.\n\n#### Arguments\n\n- `parentID: string`: The DataID of the parent node that contains the connection.\n- `connectionKeys: Array<{key: string, filters?: Variables}>`: An array of objects containing a connection key and optionally filters.\n  - `filters`: An object containing GraphQL calls e.g. `const filters = {'orderby': 'chronological'};`.\n- `pathToConnection: Array<string>`: An array containing the field names between the parent and the connection, including the parent and the connection.\n- `deletedIDFieldName: string | Array<string>`: The field name in the response that contains the DataID or DataIDs of the removed node or nodes, or the path to the node or nodes removed from the connection\n\n#### Example\n\n``` javascript\n          const mutation = graphql`\n  mutation RemoveTagMutation($todoID: ID!, $tagID: ID!) {\n    removeTag(todo: $todoID, tag: $tagID) {\n      removedTagID\n    }\n  }\n`;\n\nfunctioncommit(environment, todoID, tagID) {\n  return commitMutation(environment, {\n    mutation,\n    variables: {\n      todoID,\n      tagID,\n    },\n    configs: [{\n      type: 'RANGE_DELETE',\n      parentID: todoID,\n      connectionKeys: [{\n        key: 'RemoveTags_tags',\n      }],\n      pathToConnection: ['todo', 'tags'],\n      deletedIDFieldName: 'removedTagID',\n    }],\n  });\n}\n\n        \n```"
- name: React Component
  id: fragment-container#react-component
  summary: null
  belongs_to: Fragment Container
  description: "### React Component\n\nHere's a basic implementation of `<TodoItem />` that ignores styling in order to highlight the functionality:\n\n``` javascript\n          // TodoItem.jsclassTodoItemextendsReact.Component{\n  render() {\n    // Expects the `item` prop to have the following shape:// {//   item: {//     text,//     isComplete//   }// }const item = this.props.item;\n    return (\n      <View><Checkbox checked={item.isComplete} /><Text>{item.text}</Text></View>\n    );\n  }\n}\n\n        \n```"
- name: Reading From Cache
  id: thinking-in-graphql#reading-from-cache
  summary: To read from the cache we can walk a query and resolve each field
  belongs_to: Thinking in GraphQL
  description: |-
    ### Reading From Cache

    To read from the cache we can walk a query and resolve each field. But wait: that sounds *exactly* like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous — we either have the data cached or we don't.

    Relay implements several variations of **query traversal**: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a "diff" traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.
- name: RecordProxy
  id: relay-store#recordproxy
  summary: null
  belongs_to: Relay Store
  description: "## RecordProxy\n\nThe `RecordProxy` serves as an interface to mutate records:\n\n``` javascript\n          interface RecordProxy {\n  copyFieldsFrom(sourceRecord: RecordProxy): void;\n  getDataID(): string;\n  getLinkedRecord(name: string, arguments?: ?Object): ?RecordProxy;\n  getLinkedRecords(name: string, arguments?: ?Object): ?Array<?RecordProxy>;\n  getOrCreateLinkedRecord(\n    name: string,\n    typeName: string,\n    arguments?: ?Object,\n  ): RecordProxy;\n  getType(): string;\n  getValue(name: string, arguments?: ?Object): mixed;\n  setLinkedRecord(\n    record: RecordProxy,\n    name: string,\n    arguments?: ?Object,\n  ): RecordProxy;\n  setLinkedRecords(\n    records: Array<?RecordProxy>,\n    name: string,\n    arguments?: ?Object,\n  ): RecordProxy;\n  setValue(value: mixed, name: string, arguments?: ?Object): RecordProxy;\n  invalidateRecord(): void;\n}\n\n        \n```"
- name: RecordSourceSelectorProxy
  id: relay-store#recordsourceselectorproxy
  summary: The RecordSourceSelectorProxy is the type of the store that updater functions receive as an argument
  belongs_to: Relay Store
  description: "## RecordSourceSelectorProxy\n\nThe `RecordSourceSelectorProxy` is the type of the `store` that [`updater` functions](mutations#using-updater-and-optimisticupdater) receive as an argument. The following is the `RecordSourceSelectorProxy` interface:\n\n``` javascript\n          interface RecordSourceSelectorProxy {\n  create(dataID: string, typeName: string): RecordProxy;\n  delete(dataID: string): void;\n  get(dataID: string): ?RecordProxy;\n  getRoot(): RecordProxy;\n  getRootField(fieldName: string): ?RecordProxy;\n  getPluralRootField(fieldName: string): ?Array<?RecordProxy>;\n  invalidateStore(): void;\n}\n\n        \n```"
- name: refetch
  id: refetch-container#refetch
  summary: refetch is a function available on the relay prop which can be used to execute the refetchQuery and potentially re-render the component with the newly fetched data
  belongs_to: Refetch Container
  description: "## `refetch`\n\n`refetch` is a function available on the `relay` [prop](#available-props) which can be used to execute the `refetchQuery` and potentially re-render the component with the newly fetched data. Specifically, upon fetching the `refetchQuery`, its result will be normalized into the store, and any relevant subscriptions associated with the changed records will be fired, causing relevant components to re-render.\n\n**Note:**`refetch` is meant to be used for changing variables in the component's fragment. Specifically, in order for *this* component to re-render, it must be subscribed to changes in the records affected by this query. If the fragment for the component doesn't use variables, the component won't be subscribed to changes to new records that might be fetched by this query. A common example of this is using `refetch` to fetch a new node and re-render the component with the data for the new node; in this case the fragment needs to use a variable for the node's id, otherwise the component won't pick up the changes for the new node.\n\n`refetch` has the following signature:\n\n``` javascript\n          type RefetchOptions = {\n  force?: boolean,\n};\n\ntype Disposable = {\n  dispose(): void,\n};\n\nrefetch(\n  refetchVariables: Object | (fragmentVariables: Object) => Object,\n  renderVariables: ?Object,\n  callback: ?(error: ?Error) => void,\n  options?: RefetchOptions,\n): Disposable,\n\n        \n```\n\n### Arguments\n\n- `refetchVariables`:\n  - A bag of variables to pass to the `refetchQuery` when fetching it from the server.\n  - Or, a function that receives the previous set of variables used to query the data, and returns a new set of variables to pass to the `refetchQuery` when fetching it from the server.\n- `renderVariables`: Optional bag of variables that indicate which variables to use for reading out the data from the store when re-rendering the component. Specifically, this indicates which variables to use when querying the data from the local data store *after* the new query has been fetched. If not specified, the `refetchVariables` will be used. This is useful when the data you need to render in your component doesn't necessarily match the data you queried the server for. For example, to implement pagination, you would fetch a page with variables like `{first: 5, after: '<cursor>'}`, but you might want to render the full collection with `{first: 10}`.\n- `callback`: Function to be called after the refetch has completed. If an error occurred during refetch, this function will receive that error as an argument.\n- `options`: Optional object containing set of options.\n  - `force`: If the [Network Layer](network-layer) has been configured with a cache, this option forces a refetch even if the data for this query and variables is already available in the cache.\n  - `fetchPolicy`: If the data is already present in the store, using the `'store-or-network'` option will use that data without making an additional network request. Using the `'network-only'` option, which is the default behavior, will ignore any data present in the store and make a network request.\n\n&nbsp;"
- name: Refetch Container
  id: refetch-container
  summary: A Refetch Container is also a higher-order component that works like a regular Fragment Container, but provides the additional ability to fetch a new GraphQL query with different variables and re-render the component with the new result
  description: "# Refetch Container\n\nA Refetch Container is also a [higher-order component](https://reactjs.org/docs/higher-order-components.html) that works like a regular [Fragment Container](fragment-container), but provides the additional ability to fetch a new GraphQL query with different variables and re-render the component with the new result.\n\nTable of Contents:\n\n- [`createRefetchContainer`](#createrefetchcontainer)\n- [`refetch`](#refetch)\n- [Examples](#examples)\n\n## `createRefetchContainer`\n\n`createRefetchContainer` has the following signature:\n\n``` javascript\ncreateRefetchContainer(\n  component: ReactComponentClass,\n  fragmentSpec: {[string]: GraphQLTaggedNode},\n  refetchQuery: GraphQLTaggedNode,\n): ReactComponentClass;\n```\n\n### Arguments\n\n- `component`: The React Component *class* of the component requiring the fragment data.\n- `fragmentSpec`: Specifies the data requirements for the Component via a GraphQL fragment. The required data will be available on the component as props that match the shape of the provided fragment. `fragmentSpec` should be an object whose keys are prop names and values are `graphql` tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.\n  - **Note:** `relay-compiler` enforces fragments to be named as `<FileName>_<propName>`.\n- `refetchQuery`: A `graphql` tagged query to be fetched upon calling [`props.relay.refetch`](#refetch). As with any query, upon fetching this query, its result will be normalized into the store, any relevant subscriptions associated with the changed records will be fired, and subscribed components will re-render.\n\n### Available Props\n\nThe Component resulting from `createRefetchContainer` will receive the following `props`:\n\n``` javascript\ntype Props = {\n  relay: {\n    environment: Environment,\n    refetch(), // See #refetch section\n  },\n  // Additional props as specified by the fragmentSpec\n}\n```\n\n- `relay`:\n  - `environment`: The current [Relay Environment](relay-environment)\n  - `refetch`: See `refetch` [docs](#refetch)\n\n## `refetch`\n\n`refetch` is a function available on the `relay` [prop](#available-props) which can be used to execute the `refetchQuery` and potentially re-render the component with the newly fetched data. Specifically, upon fetching the `refetchQuery`, its result will be normalized into the store, and any relevant subscriptions associated with the changed records will be fired, causing relevant components to re-render.\n\n**Note:** `refetch` is meant to be used for changing variables in the component's fragment. Specifically, in order for *this* component to re-render, it must be subscribed to changes in the records affected by this query. If the fragment for the component doesn't use variables, the component won't be subscribed to changes to new records that might be fetched by this query. A common example of this is using `refetch` to fetch a new node and re-render the component with the data for the new node; in this case the fragment needs to use a variable for the node's id, otherwise the component won't pick up the changes for the new node.\n\n`refetch` has the following signature:\n\n``` javascript\ntype RefetchOptions = {\n  force?: boolean,\n};\n\ntype Disposable = {\n  dispose(): void,\n};\n\nrefetch(\n  refetchVariables: Object | (fragmentVariables: Object) => Object,\n  renderVariables: ?Object,\n  callback: ?(error: ?Error) => void,\n  options?: RefetchOptions,\n): Disposable,\n```\n\n### Arguments\n\n- `refetchVariables`:\n  - A bag of variables to pass to the `refetchQuery` when fetching it from the server.\n  - Or, a function that receives the previous set of variables used to query the data, and returns a new set of variables to pass to the `refetchQuery` when fetching it from the server.\n- `renderVariables`: Optional bag of variables that indicate which variables to use for reading out the data from the store when re-rendering the component. Specifically, this indicates which variables to use when querying the data from the local data store *after* the new query has been fetched. If not specified, the `refetchVariables` will be used. This is useful when the data you need to render in your component doesn't necessarily match the data you queried the server for. For example, to implement pagination, you would fetch a page with variables like `{first: 5, after: '<cursor>'}`, but you might want to render the full collection with `{first: 10}`.\n- `callback`: Function to be called after the refetch has completed. If an error occurred during refetch, this function will receive that error as an argument.\n- `options`: Optional object containing set of options.\n  - `force`: If the [Network Layer](network-layer) has been configured with a cache, this option forces a refetch even if the data for this query and variables is already available in the cache.\n  - `fetchPolicy`: If the data is already present in the store, using the `'store-or-network'` option will use that data without making an additional network request. Using the `'network-only'` option, which is the default behavior, will ignore any data present in the store and make a network request.\n\n### Return Value\n\nReturns a `Disposable` on which you could call `dispose()` to cancel the refetch.\n\n## Examples\n\n### Refetching latest data\n\nIn this simple example, let's assume we want to fetch the latest data for a `TodoItem` from the server:\n\n``` javascript\n// TodoItem.js\nimport {createRefetchContainer, graphql} from 'react-relay';\n\nclass TodoItem extends React.Component {\n  render() {\n    const item = this.props.item;\n    return (\n      <View>\n        <Checkbox checked={item.isComplete} />\n        <Text>{item.text}</Text>\n        <button onPress={this._refetch} title=\"Refresh\" />\n      </View>\n    );\n  }\n\n  _refetch = () => {\n    this.props.relay.refetch(\n      {itemID: this.props.item.id},  // Our refetchQuery needs to know the `itemID`\n      null,  // We can use the refetchVariables as renderVariables\n      () => { console.log('Refetch done') },\n      {force: true},  // Assuming we've configured a network layer cache, we want to ensure we fetch the latest data.\n    );\n  }\n}\n\nexport default createRefetchContainer(\n  TodoItem,\n  {\n    item: graphql`\n      fragment TodoItem_item on Todo {\n        text\n        isComplete\n      }\n    `\n  },\n  graphql`\n    # Refetch query to be fetched upon calling `refetch`.\n    # Notice that we re-use our fragment and the shape of this query matches our fragment spec.\n    query TodoItemRefetchQuery($itemID: ID!) {\n      item: node(id: $itemID) {\n        ...TodoItem_item\n      }\n    }\n  `\n);\n```\n\n### Loading more data\n\nIn this example we are using a Refetch Container to fetch more stories in a story feed component.\n\n``` javascript\nimport {createRefetchContainer, graphql} from 'react-relay';\n\nclass FeedStories extends React.Component {\n  render() {\n    return (\n      <div>\n        {this.props.feed.stories.edges.map(\n          edge => <Story story={edge.node} key={edge.node.id} />\n        )}\n        <button\n          onPress={this._loadMore}\n          title=\"Load More\"\n        />\n      </div>\n    );\n  }\n\n  _loadMore() {\n    // Increments the number of stories being rendered by 10.\n    const refetchVariables = fragmentVariables => ({\n      count: fragmentVariables.count + 10,\n    });\n    this.props.relay.refetch(refetchVariables);\n  }\n}\n\nexport default createRefetchContainer(\n  FeedStories,\n  {\n    feed: graphql`\n      fragment FeedStories_feed on Feed\n      @argumentDefinitions(\n        count: {type: \"Int\", defaultValue: 10}\n      ) {\n        stories(first: $count) {\n          edges {\n            node {\n              id\n              ...Story_story\n            }\n          }\n        }\n      }\n    `\n  },\n  graphql`\n    # Refetch query to be fetched upon calling `refetch`.\n    # Notice that we re-use our fragment and the shape of this query matches our fragment spec.\n    query FeedStoriesRefetchQuery($count: Int) {\n      feed {\n        ...FeedStories_feed @arguments(count: $count)\n      }\n    }\n  `,\n);\n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/refetch-container](https://relay.dev/docs/en/refetch-container)"
- name: refetchConnection
  id: pagination-container#refetchconnection
  summary: refetchConnection is a function available on the relay prop
  belongs_to: Pagination Container
  description: "## `refetchConnection`\n\n`refetchConnection` is a function available on the `relay` [prop](#available-props). You can call `refetchConnection` to restart pagination on a connection from scratch, with optionally a completely new set of variables to pass to the pagination `query`. This is useful for example if you are paginating over a collection based on a userID and the userID changes, you'd want to start paginating over the new collection for the new user.\n\n``` javascript\n          refetchConnection:(\n  totalCount: number,\n  callback: (error: ?Error) => void,\n  refetchVariables: ?Variables,\n) => ?Disposable,\n\n        \n```\n\n### Arguments:\n\n- `totalCount`: The total number of elements to fetch\n- `callback`: Function called when the new page has been fetched. If an error occurred during refetch, this function will receive that error as an argument.\n- `refetchVariables`: A potentially new bag of variables to pass to the pagination `query` when fetching it from the server.\n\n&nbsp;"
- name: Refetching latest data
  id: refetch-container#refetching-latest-data
  summary: null
  belongs_to: Refetch Container
  description: "### Refetching latest data\n\nIn this simple example, let's assume we want to fetch the latest data for a `TodoItem` from the server:\n\n``` javascript\n          // TodoItem.jsimport {createRefetchContainer, graphql} from 'react-relay';\n\nclassTodoItemextendsReact.Component{\n  render() {\n    const item = this.props.item;\n    return (\n      <View><Checkbox checked={item.isComplete} /><Text>{item.text}</Text><button onPress={this._refetch} title=\"Refresh\" /></View>\n    );\n  }\n\n  _refetch = () => {\n    this.props.relay.refetch(\n      {itemID: this.props.item.id},  // Our refetchQuery needs to know the `itemID`\n      null,  // We can use the refetchVariables as renderVariables\n      () => { console.log('Refetch done') },\n      {force: true},  // Assuming we've configured a network layer cache, we want to ensure we fetch the latest data.\n    );\n  }\n}\n\nexport default createRefetchContainer(\n  TodoItem,\n  {\n    item: graphql`\n      fragment TodoItem_item on Todo {\n        text\n        isComplete\n      }\n    `\n  },\n  graphql`\n    # Refetch query to be fetched upon calling `refetch`.\n    # Notice that we re-use our fragment and the shape of this query matches our fragment spec.\n    query TodoItemRefetchQuery($itemID: ID!) {\n      item: node(id: $itemID) {\n        ...TodoItem_item\n      }\n    }\n  `\n);\n\n        \n```"
- name: Relay Compiler
  id: graphql-in-relay#relay-compiler
  summary: Relay uses the Relay Compiler to convert graphql literals into generated files that live alongside your source files
  belongs_to: GraphQL in Relay
  description: "## Relay Compiler\n\nRelay uses the Relay Compiler to convert [`graphql`](#graphql) literals into generated files that live alongside your source files.\n\nA query like the following:\n\n``` javascript\n          graphql`\n  fragment MyComponent on Type {\n    field\n  }\n`\n\n        \n```\n\nWill cause a generated file to appear in `./__generated__/MyComponent.graphql`, with both runtime artifacts (which help to read and write from the Relay Store) and [Flow types](https://flow.org/) to help you write type-safe code.\n\nThe Relay Compiler is responsible for generating code as part of a build step which can then be referenced at runtime. By building the query ahead of time, the Relay's runtime is not responsible for generating a query string, and various optimizations can be performed on the query that could be too expensive at runtime (for example, fields that are duplicated in the query can be merged during the build step, to improve efficiency of processing the GraphQL response)."
- name: Relay Environment
  id: relay-environment
  summary: The Relay "Environment" bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate
  description: "# Relay Environment\n\nThe Relay \"Environment\" bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate.\n\nMost applications will create a single Environment instance and use it throughout. In specific situations, however, you may want to create multiple environments for different purposes. For example, you may create a new environment instance whenever the user logs in or out in order to prevent data for different users being cached together. Similarly, a server rendered application may create a new environment instance per request, so that each request gets its own cache and user data does not overlap. Alternatively, you might have multiple products or features within a larger application, and you want each one to have product-specific network-handling or caching.\n\n## A simple example\n\nTo create an environment instance in Relay Modern, use the `RelayModernEnvironment` class:\n\n``` javascript\nconst {\n  Environment,\n  Network,\n  RecordSource,\n  Store,\n} = require('relay-runtime');\n\nconst source = new RecordSource();\nconst store = new Store(source);\nconst network = Network.create(/*...*/); // see note below\nconst handlerProvider = null;\n\nconst environment = new Environment({\n  handlerProvider, // Can omit.\n  network,\n  store,\n});\n```\n\nFor more details on creating a Network, see the [NetworkLayer guide](network-layer).\n\nOnce you have an environment, you can pass it in to your [`QueryRenderer`](query-renderer) instance, or into mutations via the `commitUpdate` function (see \"[Mutations](mutations)\").\n\n## Adding a `handlerProvider`\n\nThe example above did not configure a `handlerProvider`, which means that a default one will be provided. Relay Modern comes with a built-in handler that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the [Relay Cursor Connections Specification](https://relay.dev/graphql/connections.htm), and well-supported by Relay itself).\n\nIf you wish to provide your own `handlerProvider`, you can do so:\n\n``` javascript\nconst {\n  ConnectionHandler,\n} = require('relay-runtime');\n\nfunction handlerProvider(handle) {\n  switch (handle) {\n    // Augment (or remove from) this list:\n    case 'connection': return ConnectionHandler;\n  }\n  throw new Error(\n    `handlerProvider: No handler provided for ${handle}`\n  );\n}\n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/relay-environment.html](https://relay.dev/docs/en/relay-environment.html)"
- name: Relay Store
  id: relay-store
  summary: The Relay Store can be used to programmatically update client-side data inside updater functions
  description: "# Relay Store\n\nThe Relay Store can be used to programmatically update client-side data inside [`updater` functions](mutations#using-updater-and-optimisticupdater). The following is a reference of the Relay Store interface.\n\nTable of Contents:\n\n- [RecordSourceSelectorProxy](#recordsourceselectorproxy)\n- [RecordProxy](#recordproxy)\n- [ConnectionHandler](#connectionhandler)\n\n## RecordSourceSelectorProxy\n\nThe `RecordSourceSelectorProxy` is the type of the `store` that [`updater` functions](mutations#using-updater-and-optimisticupdater) receive as an argument. The following is the `RecordSourceSelectorProxy` interface:\n\n``` javascript\ninterface RecordSourceSelectorProxy {\n  create(dataID: string, typeName: string): RecordProxy;\n  delete(dataID: string): void;\n  get(dataID: string): ?RecordProxy;\n  getRoot(): RecordProxy;\n  getRootField(fieldName: string): ?RecordProxy;\n  getPluralRootField(fieldName: string): ?Array<?RecordProxy>;\n  invalidateStore(): void;\n}\n```\n\n### `create(dataID: string, typeName: string): RecordProxy`\n\nCreates a new record in the store given a `dataID` and the `typeName` as defined by the GraphQL schema. Returns a [`RecordProxy`](#recordproxy) which serves as an interface to mutate the newly created record.\n\n#### Example\n\n``` javascript\nconst record = store.create(dataID, 'Todo');\n```\n\n### `delete(dataID: string): void`\n\nDeletes a record from the store given its `dataID`.\n\n#### Example\n\n``` javascript\nstore.delete(dataID);\n```\n\n### `get(dataID: string): ?RecordProxy`\n\nRetrieves a record from the store given its `dataID`. Returns a [`RecordProxy`](#recordproxy) which serves as an interface to mutate the record.\n\n#### Example\n\n``` javascript\nconst record = store.get(dataID);\n```\n\n### `getRoot(): RecordProxy`\n\nReturns the [`RecordProxy`](#recordproxy) representing the root of the GraphQL document.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nviewer {\n  id\n}\n```\n\nUsage:\n\n``` javascript\n// Represents root query\nconst root = store.getRoot();\n```\n\n### `getRootField(fieldName: string): ?RecordProxy`\n\nRetrieves a root field from the store given the `fieldName`, as defined by the GraphQL document. Returns a [`RecordProxy`](#recordproxy) which serves as an interface to mutate the record.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nviewer {\n  id\n}\n```\n\nUsage:\n\n``` javascript\nconst viewer = store.getRootField('viewer');\n```\n\n### `getPluralRootField(fieldName: string): ?Array<?RecordProxy>`\n\nRetrieves a root field that represents a collection from the store given the `fieldName`, as defined by the GraphQL document. Returns an array of [`RecordProxies`](#recordproxy).\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nnodes(first: 10) {\n  # ...\n}\n```\n\nUsage:\n\n``` javascript\nconst nodes = store.getPluralRootField('nodes');\n```\n\n### `invalidateStore(): void`\n\nGlobally invalidates the Relay store. This will cause any data that was written to the store before invalidation occurred to be considered stale, and will be considered to require refetch the next time a query is checked with `environment.check()`.\n\n#### Example\n\n``` javascript\nstore.invalidateStore();\n```\n\nAfter global invalidation, any query that is checked before refetching it will be considered stale:\n\n``` javascript\nenvironment.check(query) === 'stale'\n```\n\n## RecordProxy\n\nThe `RecordProxy` serves as an interface to mutate records:\n\n``` javascript\ninterface RecordProxy {\n  copyFieldsFrom(sourceRecord: RecordProxy): void;\n  getDataID(): string;\n  getLinkedRecord(name: string, arguments?: ?Object): ?RecordProxy;\n  getLinkedRecords(name: string, arguments?: ?Object): ?Array<?RecordProxy>;\n  getOrCreateLinkedRecord(\n    name: string,\n    typeName: string,\n    arguments?: ?Object,\n  ): RecordProxy;\n  getType(): string;\n  getValue(name: string, arguments?: ?Object): mixed;\n  setLinkedRecord(\n    record: RecordProxy,\n    name: string,\n    arguments?: ?Object,\n  ): RecordProxy;\n  setLinkedRecords(\n    records: Array<?RecordProxy>,\n    name: string,\n    arguments?: ?Object,\n  ): RecordProxy;\n  setValue(value: mixed, name: string, arguments?: ?Object): RecordProxy;\n  invalidateRecord(): void;\n}\n```\n\n### `getDataID(): string`\n\nReturns the dataID of the current record.\n\n#### Example\n\n``` javascript\nconst id = record.getDataID();\n```\n\n### `getType(): string`\n\nGets the type of the current record, as defined by the GraphQL schema.\n\n#### Example\n\n``` javascript\nconst type = user.getType();  // User\n```\n\n### `getValue(name: string, arguments?: ?Object): mixed`\n\nGets the value of a field in the current record given the field name.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nviewer {\n  id\n  name\n}\n```\n\nUsage:\n\n``` javascript\nconst name = viewer.getValue('name');\n```\n\nOptionally, if the field takes arguments, you can pass a bag of `variables`.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nviewer {\n  id\n  name(arg: $arg)\n}\n```\n\nUsage:\n\n``` javascript\nconst name = viewer.getValue('name', {arg: 'value'});\n```\n\n### `getLinkedRecord(name: string, arguments?: ?Object): ?RecordProxy`\n\nRetrieves a record associated with the current record given the field name, as defined by the GraphQL document. Returns a `RecordProxy`.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nrootField {\n  viewer {\n    id\n    name\n  }\n}\n```\n\nUsage:\n\n``` javascript\nconst rootField = store.getRootField('rootField');\nconst viewer = rootField.getLinkedRecord('viewer');\n```\n\nOptionally, if the linked record takes arguments, you can pass a bag of `variables` as well.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nrootField {\n  viewer(arg: $arg) {\n    id\n  }\n}\n```\n\nUsage:\n\n``` javascript\nconst rootField = store.getRootField('rootField');\nconst viewer = rootField.getLinkedRecord('viewer', {arg: 'value'});\n```\n\n### `getLinkedRecords(name: string, arguments?: ?Object): ?Array<?RecordProxy>`\n\nRetrieves the set of records associated with the current record given the field name, as defined by the GraphQL document. Returns an array of `RecordProxies`.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nrootField {\n  nodes {\n    # ...\n  }\n}\n```\n\nUsage:\n\n``` javascript\nconst rootField = store.getRootField('rootField');\nconst nodes = rootField.getLinkedRecords('nodes');\n```\n\nOptionally, if the linked record takes arguments, you can pass a bag of `variables` as well.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nrootField {\n  nodes(first: $count) {\n    # ...\n  }\n}\n```\n\nUsage:\n\n``` javascript\nconst rootField = store.getRootField('rootField');\nconst viewer = rootField.getLinkedRecord('viewer', {count: 10});\n```\n\n### `getOrCreateLinkedRecord(name: string, typeName: string, arguments?: ?Object)`\n\nRetrieves the a record associated with the current record given the field name, as defined by the GraphQL document. If the linked record does not exist, it will be created given the type name. Returns a `RecordProxy`.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nrootField {\n  viewer {\n    id\n  }\n}\n```\n\nUsage:\n\n``` javascript\nconst rootField = store.getRootField('rootField');\nconst newViewer = rootField.getOrCreateLinkedRecord('viewer', 'User'); // Will create if it doesn't exist\n```\n\nOptionally, if the linked record takes arguments, you can pass a bag of `variables` as well.\n\n### `setValue(value: mixed, name: string, arguments?: ?Object): RecordProxy`\n\nMutates the current record by setting a new value on the specified field. Returns the mutated record.\n\nGiven the GraphQL document:\n\n``` javascript\nviewer {\n  id\n  name\n}\n```\n\nUsage:\n\n``` javascript\nviewer.setValue('New Name', 'name');\n```\n\nOptionally, if the field takes arguments, you can pass a bag of `variables`.\n\n``` javascript\nviewer.setValue('New Name', 'name', {arg: 'value'});\n```\n\n### `copyFieldsFrom(sourceRecord: RecordProxy): void`\n\nMutates the current record by copying the fields over from the passed in record `sourceRecord`.\n\n#### Example\n\n``` javascript\nconst record = store.get(id1);\nconst otherRecord = store.get(id2);\nrecord.copyFieldsFrom(otherRecord); // Mutates `record`\n```\n\n### `setLinkedRecord(record: RecordProxy, name: string, arguments?: ?Object)`\n\nMutates the current record by setting a new linked record on the given the field name.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nrootField {\n  viewer {\n    id\n  }\n}\n```\n\nUsage:\n\n``` javascript\nconst rootField = store.getRootField('rootField');\nconst newViewer = store.create(/* ... */)''\nrootField.setLinkedRecord(newViewer, 'viewer'); //\n```\n\nOptionally, if the linked record takes arguments, you can pass a bag of `variables` as well.\n\n### `setLinkedRecords(records: Array<RecordProxy>, name: string, variables?: ?Object)`\n\nMutates the current record by setting a new set of linked records on the given the field name.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\nrootField {\n  nodes {\n    # ...\n  }\n}\n```\n\nUsage:\n\n``` javascript\nconst rootField = store.getRootField('rootField');\nconst newNode = store.create(/* ... */);\nconst newNodes = [...rootField.getLinkedRecords('nodes'), newNode];\nrootField.setLinkedRecords(newNodes, 'nodes'); //\n```\n\nOptionally, if the linked record takes arguments, you can pass a bag of `variables` as well.\n\n### `invalidateRecord(): void`\n\nInvalidates the record. This will cause any query that references this record to be considered stale until the next time it is refetched, and will be considered to require a refetch the next time such a query is checked with `environment.check()`.\n\n#### Example\n\n``` javascript\nconst record = store.get('4');\nrecord.invalidateRecord();\n```\n\nAfter invalidating a record, any query that references the invalidated record and that is checked before refetching it will be considered stale:\n\n``` javascript\nenvironment.check(query) === 'stale'\n```\n\n## ConnectionHandler\n\n`ConnectionHandler` is a utility module exposed by `relay-runtime` that aids in the manipulation of connections. `ConnectionHandler` exposes the following interface:\n\n``` javascript\ninterface ConnectionHandler {\n  getConnection(\n    record: RecordProxy,\n    key: string,\n    filters?: ?Object,\n  ): ?RecordProxy,\n  createEdge(\n    store: RecordSourceProxy,\n    connection: RecordProxy,\n    node: RecordProxy,\n    edgeType: string,\n  ): RecordProxy,\n  insertEdgeBefore(\n    connection: RecordProxy,\n    newEdge: RecordProxy,\n    cursor?: ?string,\n  ): void,\n  insertEdgeAfter(\n    connection: RecordProxy,\n    newEdge: RecordProxy,\n    cursor?: ?string,\n  ): void,\n  deleteNode(connection: RecordProxy, nodeID: string): void\n}\n```\n\n### `getConnection(record: RecordProxy, key: string, filters?: ?Object)`\n\nGiven a record and a connection key, and optionally a set of filters, `getConnection` retrieves a [`RecordProxy`](#recordproxy) that represents a connection that was annotated with a `@connection` directive.\n\nFirst, let's take a look at a plain connection:\n\n``` javascript\nfragment FriendsFragment on User {\n  friends(first: 10) {\n    edges {\n      node {\n        id\n      }\n    }\n  }\n}\n```\n\nAccessing a plain connection field like this is the same as other regular field:\n\n``` javascript\n// The `friends` connection record can be accessed with:\nconst user = store.get(userID);\nconst friends = user && user.getLinkedRecord('friends');\n\n// Access fields on the connection:\nconst edges = friends && friends.getLinkedRecords('edges');\n```\n\nIn a [pagination container](pagination-container), we usually annotate the actual connection field with `@connection` to tell Relay which part needs to be paginated:\n\n``` javascript\nfragment FriendsFragment on User {\n  friends(first: 10, orderby: \"firstname\") @connection(\n    key: \"FriendsFragment_friends\",\n  ) {\n    edges {\n      node {\n        id\n      }\n    }\n  }\n}\n```\n\nFor connections like the above, `ConnectionHandler` helps us find the record:\n\n``` javascript\nimport {ConnectionHandler} from 'relay-runtime';\n\n// The `friends` connection record can be accessed with:\nconst user = store.get(userID);\nconst friends = ConnectionHandler.getConnection(\n user,                        // parent record\n 'FriendsFragment_friends'    // connection key\n {orderby: 'firstname'}       // 'filters' that is used to identify the connection\n);\n// Access fields on the connection:\nconst edges = friends.getLinkedRecords('edges');\n```\n\n### Edge creation and insertion\n\n#### `createEdge(store: RecordSourceProxy, connection: RecordProxy, node: RecordProxy, edgeType: string)`\n\nCreates an edge given a [`store`](#recordsourceselectorproxy), a connection, the edge type, and a record that holds that connection.\n\n#### `insertEdgeBefore(connection: RecordProxy, newEdge: RecordProxy, cursor?: ?string)`\n\nGiven a connection, inserts the edge at the beginning of the connection, or before the specified `cursor`.\n\n#### `insertEdgeAfter(connection: RecordProxy, newEdge: RecordProxy, cursor?: ?string)`\n\nGiven a connection, inserts the edge at the end of the connection, or after the specified `cursor`.\n\n#### Example\n\n``` javascript\nconst user = store.get(userID);\nconst friends = ConnectionHandler.getConnection(user, 'friends');\nconst edge = ConnectionHandler.createEdge(store, friends, user, 'UserEdge');\n\n// No cursor provided, append the edge at the end.\nConnectionHandler.insertEdgeAfter(friends, edge);\n\n// No cursor provided, Insert the edge at the front:\nConnectionHandler.insertEdgeBefore(friends, edge);\n```\n\n### `deleteNode(connection: RecordProxy, nodeID: string): void`\n\nGiven a connection, deletes any edges whose id matches the given id.\n\n#### Example\n\n``` javascript\nconst user = store.get(userID);\nconst friends = ConnectionHandler.getConnection(user, 'friends');\nConnectionHandler.deleteNode(friends, idToDelete);\n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/relay-store.html](https://relay.dev/docs/en/relay-store.html)"
- name: Rendering
  id: thinking-in-relay#rendering
  summary: 'In React, rendering a view requires two inputs: the component to render, and a root DOM (UI) node to render into'
  belongs_to: Thinking In Relay
  description: "## Rendering\n\nIn React, rendering a view requires two inputs: the *component* to render, and a *root* DOM (UI) node to render into. Rendering Relay containers is similar: we need a *container* to render, and a *root* in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to `ReactDOM.render(component, domNode)`, Relay provides `<QueryRenderer query={...} variables={...} render={...}>` for this purpose. The `query` and `variables` define what data to fetch and `render` defines what to render. Here's how we might render `<StoryContainer>`:\n\n``` javascript\n          ReactDOM.render(\n  <QueryRenderer\n    environment={/* defined or imported above... */}\n    query={graphql`\n      query StoryQuery($storyID: ID!) {\n        node(id: $storyID) {\n          ...Story_story\n        }\n      }\n    `}\n    variables={{\n      storyID: '123',\n    }}\n    render={(props, error) => {\n      if (error) {\n        return <ErrorView />;\n      } else if (props) {\n        return <StoryContainer story={props.story} />;\n      } else {\n        return <LoadingIndicator />;\n      }\n    }}\n  />,\n  rootElement\n)\n\n        \n```\n\n`QueryRenderer` will then fetch the data and render `StoryContainer` once the data is available. Just as React allows developers to render views without directly manipulating the underlying view, Relay removes the need to directly communicate with the network."
- name: Rendering Containers
  id: fragment-container#rendering-containers
  summary: As we've learned, Relay fragment containers only declare data requirements as GraphQL fragments
  belongs_to: Fragment Container
  description: "## Rendering Containers\n\nAs we've learned, Relay fragment containers only declare data requirements as GraphQL fragments. In order to actually fetch and render the specified data, we need to use a `QueryRenderer` component to render a root query and any fragment containers included within. Please refer to our [`QueryRenderer`](query-renderer) docs for more details.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/fragment-container.html](https://relay.dev/docs/en/fragment-container.html)"
- name: Return Value
  id: refetch-container#return-value
  summary: Returns a Disposable on which you could call dispose() to cancel the refetch
  belongs_to: Refetch Container
  description: |-
    ### Return Value

    Returns a `Disposable` on which you could call `dispose()` to cancel the refetch.

    ## Examples
- name: Return Value
  id: fetch-query#return-value
  summary: The function returns a Promise that resolves with an object containing data obtained from the query
  belongs_to: fetchQuery
  description: "## Return Value\n\nThe function returns a `Promise` that resolves with an object containing data obtained from the query.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/fetch-query](https://relay.dev/docs/en/fetch-query)"
- name: Runtime Architecture
  id: runtime-architecture
  summary: The Relay runtime is a full-featured GraphQL client that is designed for high performance even on low-end mobile devices and is capable of scaling to large, complex apps
  description: "# Runtime Architecture\n\nThe Relay runtime is a full-featured GraphQL client that is designed for high performance even on low-end mobile devices and is capable of scaling to large, complex apps. The runtime API is not intended to be used directly in product code, but rather to provide a foundation for building higher-level product APIs such as React/Relay. This foundation includes:\n\n- A normalized, in-memory object graph/cache.\n- An optimized \"write\" operation for updating the cache with the results of queries/mutations/subscriptions.\n- A mechanism for reading data from the cache and subscribing for updates when these results change due to a mutation, subscription update, etc.\n- Garbage collection to evict entries from the cache when they can no longer be referenced by any view.\n- A generic mechanism for intercepting data prior to publishing it to the cache and either synthesizing new data or merging new and existing data together (which among other things enables the creation of a variety of pagination schemes).\n- Mutations with optimistic updates and the ability to update the cache with arbitrary logic.\n- Support for live queries where supported by the network/server.\n- Core primitives to enable subscriptions.\n- Core primitives for building offline/persisted caching.\n\n## Comparison to Classic Relay\n\nFor users of classic Relay, note that the runtime makes as few assumptions as possible about GraphQL. Compared to earlier versions of Relay there is no concept of routes, there are no limitations on mutation input arguments or side-effects, arbitrary root fields just work, etc. At present, the main restriction from classic Relay that remains is the use of the `Node` interface and `id` field for object identification. However there is no fundamental reason that this restriction can't be relaxed (there is a single place in the codebase where object identity is determined), and we welcome feedback from the community about ways to support customizable object identity without negatively impacting performance.\n\n## Data Types\n\n(subsequent sections explain how these types are used in practice):\n\n- `DataID` (type): A globally unique or client-generated identifier for a record, stored as a string.\n- `Record` (type): A representation of a distinct data entity with an identity, type, and fields. Note that the actual runtime representation is opaque to the system: all accesses to `Record` objects (including record creation) is mediated through the `RelayModernRecord` module. This allows the representation itself to be changed in a single place (e.g. to use `Map`s or a custom class). It is important that other code does not assume that `Record`s will always be plain objects.\n- `RecordSource` (type): A collection of records keyed by their data ID, used both to represent the cache and updates to it. For example the store's record cache is a `RecordSource` and the results of queries/mutations/subscriptions are normalized into `RecordSource`s that are published to a store. Sources also define methods for asynchronously loading records in order to (eventually) support offline use-cases. Currently the only implementation of this interface is `RelayInMemoryRecordSource`; future implementations may add support for loading records from disk.\n- `Store` (type): The source of truth for an instance of `RelayRuntime`, holding the canonical set of records in the form of a `RecordSource` (though this is not required). Currently the only implementation is `RelayModernStore`.\n- `Network` (type): Provides methods for fetching query data from and executing mutations against an external data source.\n- `Environment` (type): Represents an encapsulated environment combining a `Store` and `Network`, providing a high-level API for interacting with both. This is the main public API of `RelayRuntime`.\n\nTypes for working with queries and their results include:\n\n- `Selector` (type): A selector defines the starting point for a traversal into the graph for the purposes of targeting a subgraph, combining a GraphQL fragment, variables, and the Data ID for the root object from which traversal should progress. Intuitively, this \"selects\" a portion of the object graph.\n- `Snapshot` (type): The (immutable) results of executing a `Selector` at a given point in time. This includes the selector itself, the results of executing it, and a list of the Data IDs from which data was retrieved (useful in determining when these results might change).\n\n## Data Model\n\nRelay Runtime is designed for use with GraphQL schemas that describe **object graphs** in which objects have a type, an identity, and a set of fields with values. Objects may reference each other, which is represented by fields whose values are one or more other objects in the graph \\[1\\]. To distinguish from JavaScript `Object`s, these units of data are referred to as `Record`s. Relay represents both its internal cache as well as query/mutation/etc results as a mapping of **data ID**s to **records**. The data ID is the unique (with respect to the cache) identifier for a record - it may be the value of an actual `id` field or based on the path to the record from the nearest object with an `id` (such path-based ids are called **client ids**). Each `Record` stores its data ID, type, and any fields that have been fetched. Multiple records are stored together as a `RecordSource`: a mapping of data IDs to `Record` instances.\n\nFor example, a user and their address might be represented as follows:\n\n``` javascript\n// GraphQL Fragment\nfragment on User {\n  id\n  name\n  address {\n    city\n  }\n}\n\n// Response\n{\n  id: '842472',\n  name: 'Joe',\n  address: {\n    city: 'Seattle',\n  }\n}\n\n// Normalized Representation\nRecordSource {\n  '842472': Record {\n    __id: '842472',\n    __typename: 'User', // the type is known statically from the fragment\n    id: '842472',\n    name: 'Joe',\n    address: {__ref: 'client:842472:address'}, // link to another record\n  },\n  'client:842472:address': Record {\n    // A client ID, derived from the path from parent & parent's ID\n    __id: 'client:842472:address',\n    __typename: 'Address',\n    city: 'Seattle',\n  }\n}\n```\n\n\\[1\\] Note that GraphQL itself does not impose this constraint, and Relay Runtime may also be used for schemas that do not conform to it. For example, both systems can be used to query a single denormalized table. However, many of the features that Relay Runtime provides, such as caching and normalization, work best when the data is represented as a normalized graph with stable identities for discrete pieces of information.\n\n### Store Operations\n\nThe `Store` is the source of truth for application data and provides the following core operations.\n\n- `lookup(selector: Selector): Snapshot`: Reads the results of a selector from the store, returning the value given the data currently in the store.\n\n- `subscribe(snapshot: Snapshot, callback: (snapshot: Snapshot) => void): Disposable`: Subscribe to changes to the results of a selector. The callback is called when data has been published to the store that would cause the results of the snapshot's selector to change.\n\n- `publish(source: RecordSource): void`: Update the store with new information. All updates to the store are expressed in this form, including the results of queries/mutation/subscriptions as well as optimistic mutation updates. All of those operations internally create a new `RecordSource` instance and ultimately publish it to the store. Note that `publish()` does *not* immediately update any `subscribe()`-ers. Internally, the store compares the new `RecordSource` with its internal source, updating it as necessary:\n\n  - Records that exist only in the published source are added to the store.\n  - Records that exist in both are merged into a new record (inputs unchanged), with the result added to the store.\n  - Records that are null in the published source are deleted (set to null) in the store.\n  - Records with a special sentinel value are removed from the store. This supports un-publishing optimistically created records.\n\n- `notify(): void`: Calls any `subscribe()`-ers whose results have changed due to intervening `publish()`-es. Separating `publish()` and `notify()` allows for multiple payloads to be published before performing any downstream update logic (such as rendering).\n\n- `retain(selector: Selector): Disposable`: Ensure that all the records necessary to fulfill the given selector are retained in-memory. The records will not be eligible for garbage collection until the returned reference is disposed.\n\n### Example Data Flow: Fetching Query Data\n\n``` javascript\n               ┌───────────────────────┐\n               │         Query         │\n               └───────────────────────┘\n                           │\n                           ▼\n                                             ┌ ─ ─ ─ ┐\n                         fetch ◀────────────▶ Server\n                                             └ ─ ─ ─ ┘\n                           │\n                     ┌─────┴───────┐\n                     ▼             ▼\n               ┌──────────┐  ┌──────────┐\n               │  Query   │  │ Response │\n               └──────────┘  └──────────┘\n                     │             │\n                     └─────┬───────┘\n                           │\n                           ▼\n                       normalize\n                           │\n                           ▼\n               ┌───────────────────────┐\n               │     RecordSource      │\n               │                       │\n               │┌──────┐┌──────┐┌─────┐│\n               ││Record││Record││ ... ││\n               │└──────┘└──────┘└─────┘│\n               └───────────────────────┘\n```\n\n1.  The query is fetched from the network.\n2.  The query and response are traversed together, extracting the results into `Record` objects which are added to a fresh `RecordSource`.\n\nThis fresh `RecordSource` would then be published to the store:\n\n``` javascript\n                        publish\n                           │\n                           ▼\n             ┌───────────────────────────┐\n             │           Store           │\n             │ ┌───────────────────────┐ │\n             │ │     RecordSource      │ │\n             │ │                       │ │\n             │ │┌ ─ ─ ─ ┌ ─ ─ ─ ┌ ─ ─ ┐│ │\n             │ │ Record│ Record│  ...  │ │  <--- records are updated\n             │ │└ ─ ─ ─ └ ─ ─ ─ └ ─ ─ ┘│ │\n             │ └───────────────────────┘ │\n             │ ┌───────────────────────┐ │\n             │ │     Subscriptions     │ │\n             │ │                       │ │\n             │ │┌──────┐┌──────┐┌─────┐│ │\n             │ ││ Sub. ││ Sub. ││ ... ││ │ <--- subscriptions do not fire yet\n             │ │└──────┘└──────┘└─────┘│ │\n             │ └───────────────────────┘ │\n             └───────────────────────────┘\n```\n\nPublishing the results updates the store but does *not* immediately notify any subscribers. This is accomplished by calling `notify()`...\n\n``` javascript\n                        notify\n                           │\n                           ▼\n             ┌───────────────────────────┐\n             │           Store           │\n             │ ┌───────────────────────┐ │\n             │ │     RecordSource      │ │\n             │ │                       │ │\n             │ │┌──────┐┌──────┐┌─────┐│ │\n             │ ││Record││Record││ ... ││ │\n             │ │└──────┘└──────┘└─────┘│ │\n             │ └───────────────────────┘ │\n             │ ┌───────────────────────┐ │\n             │ │     Subscriptions     │ │\n             │ │                       │ │\n             │ │┌ ─ ─ ─ ┌ ─ ─ ─ ┌ ─ ─ ┐│ │\n             │ │  Sub. │  Sub. │  ...  │ │ <--- affected subscriptions fire\n             │ │└ ─│─ ─ └ ─│─ ─ └ ─│─ ┘│ │\n             │ └───┼───────┼───────┼───┘ │\n             └─────┼───────┼───────┼─────┘\n                   │       │       │\n                   ▼       │       │\n               callback    │       │\n                           ▼       │\n                       callback    │\n                                   ▼\n                               callback\n```\n\n...which calls the callbacks for any `subscribe()`-ers whose results have changed. Each subscription is checked as follows:\n\n1.  First, the list of data IDs that have changed since the last `notify()` is compared against data IDs listed in the subscription's latest `Snapshot`. If there is no overlap, the subscription's results cannot possibly have changed (if you imagine the graph visually, there is no overlap between the part of the graph that changed and the part that is selected). In this case the subscription is ignored, otherwise processing continues.\n2.  Second, any subscriptions that do have overlapping data IDs are re-read, and the new/previous results are compared. If the result has not changed, the subscription is ignored (this can occur if a field of a record changed that is not relevant to the subscription's selector), otherwise processing continues.\n3.  Finally, subscriptions whose data actually changed are notified via their callback.\n\n### Example Data Flow: Reading and Observing the Store\n\nProducts access the store primarily via `lookup()` and `subscribe()`. Lookup reads the initial results of a fragment, and subscribe observes that result for any changes. Note that the output of `lookup()` - a `Snapshot` - is the input to `subscribe()`. This is important because the snapshot contains important information that can be used to optimize the subscription - if `subscribe()` accepted only a `Selector`, it would have to re-read the results in order to know what to subscribe to, which is less efficient.\n\nTherefore a typical data flow is as follows - note that this flow is managed automatically by higher-level APIs such as React/Relay. First a component will lookup the results of a selector against a record source (e.g. the store's canonical source):\n\n``` javascript\n    ┌───────────────────────┐       ┌──────────────┐\n    │     RecordSource      │       │              │\n    │                       │       │              │\n    │┌──────┐┌──────┐┌─────┐│       │   Selector   │\n    ││Record││Record││ ... ││       │              │\n    │└──────┘└──────┘└─────┘│       │              │\n    └───────────────────────┘       └──────────────┘\n                │                           │\n                │                           │\n                └──────────────┬────────────┘\n                               │\n                               │  lookup\n                               │  (read)\n                               │\n                               ▼\n                        ┌─────────────┐\n                        │             │\n                        │  Snapshot   │\n                        │             │\n                        └─────────────┘\n                               │\n                               │  render, etc\n                               │\n                               ▼\n```\n\nNext, it will `subscribe()` using this snapshot in order to be notified of any changes - see the above diagram for `publish()` and `notify()`.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/runtime-architecture.html](https://relay.dev/docs/en/runtime-architecture.html)"
- name: Set up relay-compiler
  id: graphql-in-relay#set-up-relay-compiler
  summary: See our relay-compiler section in our Installation and Setup guide
  belongs_to: GraphQL in Relay
  description: |-
    ### Set up relay-compiler

    See our relay-compiler section in our [Installation and Setup guide](installation-and-setup#set-up-relay-compiler).
- name: setLinkedRecord()
  id: relay-store#setlinkedrecordrecord-recordproxy-name-string-arguments-object
  summary: Mutates the current record by setting a new linked record on the given the field name
  belongs_to: Relay Store
  description: "### `setLinkedRecord(record: RecordProxy, name: string, arguments?: ?Object)`\n\nMutates the current record by setting a new linked record on the given the field name.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          rootField {\n  viewer {\n    id\n  }\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const rootField = store.getRootField('rootField');\nconst newViewer = store.create(/* ... */)''\nrootField.setLinkedRecord(newViewer, 'viewer'); //\n\n        \n```\n\nOptionally, if the linked record takes arguments, you can pass a bag of `variables` as well."
- name: setLinkedRecords()
  id: relay-store#setlinkedrecordsrecords-arrayrecordproxy-name-string-variables-object
  summary: Mutates the current record by setting a new set of linked records on the given the field name
  belongs_to: Relay Store
  description: "### `setLinkedRecords(records: Array<RecordProxy>, name: string, variables?: ?Object)`\n\nMutates the current record by setting a new set of linked records on the given the field name.\n\n#### Example\n\nGiven the GraphQL document:\n\n``` javascript\n          rootField {\n  nodes {\n    # ...\n  }\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          const rootField = store.getRootField('rootField');\nconst newNode = store.create(/* ... */);\nconst newNodes = [...rootField.getLinkedRecords('nodes'), newNode];\nrootField.setLinkedRecords(newNodes, 'nodes'); //\n\n        \n```\n\nOptionally, if the linked record takes arguments, you can pass a bag of `variables` as well."
- name: setValue()
  id: relay-store#setvaluevalue-mixed-name-string-arguments-object-recordproxy
  summary: Mutates the current record by setting a new value on the specified field
  belongs_to: Relay Store
  description: "### `setValue(value: mixed, name: string, arguments?: ?Object): RecordProxy`\n\nMutates the current record by setting a new value on the specified field. Returns the mutated record.\n\nGiven the GraphQL document:\n\n``` javascript\n          viewer {\n  id\n  name\n}\n\n        \n```\n\nUsage:\n\n``` javascript\n          viewer.setValue('New Name', 'name');\n\n        \n```\n\nOptionally, if the field takes arguments, you can pass a bag of `variables`.\n\n``` javascript\n          viewer.setValue('New Name', 'name', {arg: 'value'});\n\n        \n```"
- name: Simple Example
  id: mutations#simple-example
  summary: null
  belongs_to: Mutations
  description: "## Simple Example\n\nExample of a simple mutation:\n\n``` javascript\n          import {commitMutation, graphql} from 'react-relay';\n\nconst mutation = graphql`\n  mutation MarkReadNotificationMutation(\n    $storyID: ID!\n  ) {\n    markReadNotification(id: $storyID) {\n      notification {\n        seenState\n      }\n    }\n  }\n`;\n\nfunctionmarkNotificationAsRead(environment, storyID) {\n  const variables = {\n    storyID,\n  };\n\n  commitMutation(\n    environment,\n    {\n      mutation,\n      variables,\n      onCompleted: (response, errors) => {\n        console.log('Response received from server.')\n      },\n      onError: err => console.error(err),\n    },\n  );\n}\n\n        \n```"
- name: Source files
  id: graphql-in-relay#source-files
  summary: Additionally, you need a directory containing .js files that use the graphql tag to describe GraphQL queries and fragments
  belongs_to: GraphQL in Relay
  description: "### Source files\n\nAdditionally, you need a directory containing `.js` files that use the `graphql` tag to describe GraphQL queries and fragments. Let's call this `./src`.\n\nThen run `yarn run relay` as set up before.\n\nThis will create a series of `__generated__` directories that are co-located with the corresponding files containing `graphql` tags.\n\nFor example, given the two files:\n\n- `src/Components/DictionaryComponent.js`\n\n  ``` javascript\n                const DictionaryWordFragment = graphql`\n    fragment DictionaryComponent_word on Word {\n      id\n      definition {\n        ...DictionaryComponent_definition\n      }\n    }\n  `\n\n  const DictionaryDefinitionFragment = graphql`\n    fragment DictionaryComponent_definition on WordDefinition {\n      text\n      image\n    }\n  `\n\n              \n  ```\n\n- `src/Queries/DictionaryQuery.js`\n\n  ``` javascript\n                const DictionaryQuery = graphql`\n    query DictionaryQuery {\n      dictionary {\n        ...DictionaryComponent_word\n      }\n    }\n  `\n\n              \n  ```\n\nThis would produce three generated files, and two `__generated__` directories:\n\n- `src/Components/__generated__/DictionaryComponent_word.graphql.js`\n- `src/Components/__generated__/DictionaryComponent_definition.graphql.js`\n- `src/Queries/__generated__/DictionaryQuery.graphql.js`\n\n&nbsp;"
- name: Store Operations
  id: runtime-architecture#store-operations
  summary: The Store is the source of truth for application data and provides the following core operations
  belongs_to: Runtime Architecture
  description: "### Store Operations\n\nThe `Store` is the source of truth for application data and provides the following core operations.\n\n- `lookup(selector: Selector): Snapshot`: Reads the results of a selector from the store, returning the value given the data currently in the store.\n\n- `subscribe(snapshot: Snapshot, callback: (snapshot: Snapshot) => void): Disposable`: Subscribe to changes to the results of a selector. The callback is called when data has been published to the store that would cause the results of the snapshot's selector to change.\n\n- `publish(source: RecordSource): void`: Update the store with new information. All updates to the store are expressed in this form, including the results of queries/mutation/subscriptions as well as optimistic mutation updates. All of those operations internally create a new `RecordSource` instance and ultimately publish it to the store. Note that `publish()` does *not* immediately update any `subscribe()`-ers. Internally, the store compares the new `RecordSource` with its internal source, updating it as necessary:\n\n  - Records that exist only in the published source are added to the store.\n  - Records that exist in both are merged into a new record (inputs unchanged), with the result added to the store.\n  - Records that are null in the published source are deleted (set to null) in the store.\n  - Records with a special sentinel value are removed from the store. This supports un-publishing optimistically created records.\n\n- `notify(): void`: Calls any `subscribe()`-ers whose results have changed due to intervening `publish()`-es. Separating `publish()` and `notify()` allows for multiple payloads to be published before performing any downstream update logic (such as rendering).\n\n- `retain(selector: Selector): Disposable`: Ensure that all the records necessary to fulfill the given selector are retained in-memory. The records will not be eligible for garbage collection until the returned reference is disposed.\n\n### Example Data Flow: Fetching Query Data\n\n``` javascript\n                         ┌───────────────────────┐\n               │         Query         │\n               └───────────────────────┘\n                           │\n                           ▼\n                                             ┌ ─ ─ ─ ┐\n                         fetch ◀────────────▶ Server\n                                             └ ─ ─ ─ ┘\n                           │\n                     ┌─────┴───────┐\n                     ▼             ▼\n               ┌──────────┐  ┌──────────┐\n               │  Query   │  │ Response │\n               └──────────┘  └──────────┘\n                     │             │\n                     └─────┬───────┘\n                           │\n                           ▼\n                       normalize\n                           │\n                           ▼\n               ┌───────────────────────┐\n               │     RecordSource      │\n               │                       │\n               │┌──────┐┌──────┐┌─────┐│\n               ││Record││Record││ ... ││\n               │└──────┘└──────┘└─────┘│\n               └───────────────────────┘\n\n        \n```\n\n1.  The query is fetched from the network.\n2.  The query and response are traversed together, extracting the results into `Record` objects which are added to a fresh `RecordSource`.\n\nThis fresh `RecordSource` would then be published to the store:\n\n``` javascript\n                                  publish\n                           │\n                           ▼\n             ┌───────────────────────────┐\n             │           Store           │\n             │ ┌───────────────────────┐ │\n             │ │     RecordSource      │ │\n             │ │                       │ │\n             │ │┌ ─ ─ ─ ┌ ─ ─ ─ ┌ ─ ─ ┐│ │\n             │ │ Record│ Record│  ...  │ │  <--- records are updated\n             │ │└ ─ ─ ─ └ ─ ─ ─ └ ─ ─ ┘│ │\n             │ └───────────────────────┘ │\n             │ ┌───────────────────────┐ │\n             │ │     Subscriptions     │ │\n             │ │                       │ │\n             │ │┌──────┐┌──────┐┌─────┐│ │\n             │ ││ Sub. ││ Sub. ││ ... ││ │ <--- subscriptions do not fire yet\n             │ │└──────┘└──────┘└─────┘│ │\n             │ └───────────────────────┘ │\n             └───────────────────────────┘\n\n        \n```\n\nPublishing the results updates the store but does *not* immediately notify any subscribers. This is accomplished by calling `notify()`...\n\n``` javascript\n                                  notify\n                           │\n                           ▼\n             ┌───────────────────────────┐\n             │           Store           │\n             │ ┌───────────────────────┐ │\n             │ │     RecordSource      │ │\n             │ │                       │ │\n             │ │┌──────┐┌──────┐┌─────┐│ │\n             │ ││Record││Record││ ... ││ │\n             │ │└──────┘└──────┘└─────┘│ │\n             │ └───────────────────────┘ │\n             │ ┌───────────────────────┐ │\n             │ │     Subscriptions     │ │\n             │ │                       │ │\n             │ │┌ ─ ─ ─ ┌ ─ ─ ─ ┌ ─ ─ ┐│ │\n             │ │  Sub. │  Sub. │  ...  │ │ <--- affected subscriptions fire\n             │ │└ ─│─ ─ └ ─│─ ─ └ ─│─ ┘│ │\n             │ └───┼───────┼───────┼───┘ │\n             └─────┼───────┼───────┼─────┘\n                   │       │       │\n                   ▼       │       │\n               callback    │       │\n                           ▼       │\n                       callback    │\n                                   ▼\n                               callback\n\n        \n```\n\n...which calls the callbacks for any `subscribe()`-ers whose results have changed. Each subscription is checked as follows:\n\n1.  First, the list of data IDs that have changed since the last `notify()` is compared against data IDs listed in the subscription's latest `Snapshot`. If there is no overlap, the subscription's results cannot possibly have changed (if you imagine the graph visually, there is no overlap between the part of the graph that changed and the part that is selected). In this case the subscription is ignored, otherwise processing continues.\n2.  Second, any subscriptions that do have overlapping data IDs are re-read, and the new/previous results are compared. If the result has not changed, the subscription is ignored (this can occur if a field of a record changed that is not relevant to the subscription's selector), otherwise processing continues.\n3.  Finally, subscriptions whose data actually changed are notified via their callback.\n\n### Example Data Flow: Reading and Observing the Store\n\nProducts access the store primarily via `lookup()` and `subscribe()`. Lookup reads the initial results of a fragment, and subscribe observes that result for any changes. Note that the output of `lookup()` - a `Snapshot` - is the input to `subscribe()`. This is important because the snapshot contains important information that can be used to optimize the subscription - if `subscribe()` accepted only a `Selector`, it would have to re-read the results in order to know what to subscribe to, which is less efficient.\n\nTherefore a typical data flow is as follows - note that this flow is managed automatically by higher-level APIs such as React/Relay. First a component will lookup the results of a selector against a record source (e.g. the store's canonical source):\n\n``` javascript\n              ┌───────────────────────┐       ┌──────────────┐\n    │     RecordSource      │       │              │\n    │                       │       │              │\n    │┌──────┐┌──────┐┌─────┐│       │   Selector   │\n    ││Record││Record││ ... ││       │              │\n    │└──────┘└──────┘└─────┘│       │              │\n    └───────────────────────┘       └──────────────┘\n                │                           │\n                │                           │\n                └──────────────┬────────────┘\n                               │\n                               │  lookup\n                               │  (read)\n                               │\n                               ▼\n                        ┌─────────────┐\n                        │             │\n                        │  Snapshot   │\n                        │             │\n                        └─────────────┘\n                               │\n                               │  render, etc\n                               │\n                               ▼\n\n        \n```\n\nNext, it will `subscribe()` using this snapshot in order to be notified of any changes - see the above diagram for `publish()` and `notify()`.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/runtime-architecture.html](https://relay.dev/docs/en/runtime-architecture.html)"
- name: Subscriptions
  id: subscriptions
  summary: Relay exposes the following APIs to create subscriptions
  description: "# Subscriptions\n\nRelay exposes the following APIs to create subscriptions.\n\n``` javascript\nimport { requestSubscription } from 'react-relay';\n\ntype Variables = {[name: string]: any};\n\ntype Disposable = {\n  dispose(): void,\n};\n\nrequestSubscription(\n  environment: Environment,\n  config: {\n    subscription: GraphQLTaggedNode,\n    variables: Variables,\n    onCompleted?: ?() => void,\n    onError?: ?(error: Error) => void,\n    onNext?: ?(response: ?Object) => void,\n    updater?: ?(store: RecordSourceSelectorProxy, data: SelectorData) => void,\n    configs?: Array<DeclarativeMutationConfig>,\n    cacheConfig?: CacheConfig,\n  },\n) => Disposable;\n```\n\nThe function returns a `Disposable` on which you could call `dispose()` to cancel the refetch.\n\nNow let's take a closer look at the `config`:\n\n- `subscription`: the `graphql` tagged subscription query.\n- `variables`: an object that contains the variables needed for the subscription.\n- `onCompleted`: a callback function executed when the subscription is closed by the peer without error.\n- `onError`: a callback function executed when Relay or the server encounters an error processing the subscription.\n- `onNext`: a callback function executed each time a response is received from the server, with the raw GraphQL response payload.\n- `updater`: an optional function that can supply custom logic for updating the in-memory Relay store based on the server response.\n- `configs`: an array containing the updater configurations. It is the same as [`configs`](mutations#updater-configs) in `commitMutation`.\n- `cacheConfig?`: Optional object containing a set of cache configuration options\n\n## Example\n\nIn a simple subscription, you only need `subscription` and `variables`. This is appropriate when you are only changing the properties of existing records that can be identified by their `id`:\n\n``` javascript\nimport {\n  requestSubscription,\n  graphql,\n} from 'react-relay';\n\nconst subscription = graphql`\n  subscription MarkReadNotificationSubscription(\n    $storyID: ID!\n  ) {\n    markReadNotification(storyID: $storyID) {\n      notification {\n        seenState\n      }\n    }\n  }\n`;\n\nconst variables = {\n  storyID,\n};\n\nrequestSubscription(\n  yourEnvironment, // see Environment docs\n  {\n    subscription,\n    variables,\n    // optional but recommended:\n    onCompleted: () => {/* server closed the subscription */},\n    onError: error => console.error(error),\n  }\n);\n```\n\n# Configure Network\n\nYou will need to Configure your [Network](networklayer) to handle subscriptions. The below example uses [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws):\n\n``` javascript\nimport {\n    ...\n    Network,\n    Observable\n} from 'relay-runtime';\nimport { SubscriptionClient } from 'subscriptions-transport-ws';\n\n...\n\nconst subscriptionClient = new SubscriptionClient('ws://localhost:3000', {\n    reconnect: true,\n});\n\nconst subscribe = (request, variables) => {\n    const subscribeObservable = subscriptionClient.request({\n        query: request.text,\n        operationName: request.name,\n        variables,\n    });\n    // Important: Convert subscriptions-transport-ws observable type to Relay's\n    return Observable.from(subscribeObservable);\n};\n\nconst network = Network.create(fetchQuery, subscribe);\n\n...\n```\n\n# Updating the client on each response\n\nFor more complex use-cases, you may wish to perform custom logic to update Relay's in-memory cache when each subscription response is received. To do so, pass an `updater` function:\n\n``` javascript\nimport { ConnectionHandler } from 'relay-runtime';\n\nrequestSubscription(\n  environment,\n  {\n    subscription,\n    variables,\n    updater: store => {\n      // Get the notification\n      const rootField = store.getRootField('markReadNotification');\n      const notification = rootField.getLinkedRecord('notification');\n      // Add it to a connection\n      const viewer = store.getRoot().getLinkedRecord('viewer');\n      const notifications =\n        ConnectionHandler.getConnection(viewer, 'notifications');\n      const edge = ConnectionHandler.createEdge(\n        store,\n        notifications,\n        notification,\n        '<TypeOfNotificationsEdge>',\n      );\n      ConnectionHandler.insertEdgeAfter(notifications, edge);\n    },\n  },\n);\n```\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/subscriptions](https://relay.dev/docs/en/subscriptions)"
- name: Thinking in GraphQL
  id: thinking-in-graphql
  summary: GraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications
  description: "# Thinking in GraphQL\n\nGraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications. It provides a way for developers to specify the precise data needed for a view and enables a client to fetch that data in a single network request. Compared to traditional approaches such as REST, GraphQL helps applications to fetch data more efficiently (compared to resource-oriented REST approaches) and avoid duplication of server logic (which can occur with custom endpoints). Furthermore, GraphQL helps developers to decouple product code and server logic. For example, a product can fetch more or less information without requiring a change to every relevant server endpoint. It's a great way to fetch data.\n\nIn this article we'll explore what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems. Along the way we'll look at the design decisions behind Relay and see that it's not just a GraphQL client but also a framework for *declarative data-fetching*. Let's start at the beginning and fetch some data!\n\n## Fetching Data\n\nImagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:\n\n``` javascript\n// Fetch the list of story IDs but not their details:\nrest.get('/stories').then(stories =>\n  // This resolves to a list of items with linked resources:\n  // `[ { href: \"http://.../story/1\" }, ... ]`\n  Promise.all(stories.map(story =>\n    rest.get(story.href) // Follow the links\n  ))\n).then(stories => {\n  // This resolves to a list of story items:\n  // `[ { id: \"...\", text: \"...\" } ]`\n  console.log(stories);\n});\n```\n\nNote that this approach requires *n+1* requests to the server: 1 to fetch the list, and *n* to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):\n\n``` javascript\ngraphql.get(`query { stories { id, text } }`).then(\n  stories => {\n    // A list of story items:\n    // `[ { id: \"...\", text: \"...\" } ]`\n    console.log(stories);\n  }\n);\n```\n\nSo far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:\n\n- All data is fetched in a single round trip.\n- The client and server are decoupled: the client specifies the data needed instead of *relying on* the server endpoint to return the correct data.\n\nFor a simple application that's already a nice improvement.\n\n## Client Caching\n\nRepeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: *caching*.\n\nIn a resource-oriented REST system, we can maintain a **response cache** based on URIs:\n\n``` javascript\nvar _cache = new Map();\nrest.get = uri => {\n  if (!_cache.has(uri)) {\n    _cache.set(uri, fetch(uri));\n  }\n  return _cache.get(uri);\n};\n```\n\nResponse-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:\n\n``` javascript\nvar _cache = new Map();\ngraphql.get = queryText => {\n  if (!_cache.has(queryText)) {\n    _cache.set(queryText, fetchGraphQL(queryText));\n  }\n  return _cache.get(queryText);\n};\n```\n\nNow, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency.\n\n## Cache Consistency\n\nWith GraphQL it is very common for the results of multiple queries to overlap. However, our response cache from the previous section doesn't account for this overlap — it caches based on distinct queries. For example, if we issue a query to fetch stories:\n\n``` javascript\nquery { stories { id, text, likeCount } }\n```\n\nand then later refetch one of the stories whose `likeCount` has since been incremented:\n\n``` javascript\nquery { story(id: \"123\") { id, text, likeCount } }\n```\n\nWe'll now see different `likeCount`s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.\n\n### Caching A Graph\n\nThe solution to caching GraphQL is to normalize the hierarchical response into a flat collection of **records**. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored *once* regardless of how it is fetched.\n\nHere's an example query that fetches a story's text and its author's name:\n\n``` javascript\nquery {\n  story(id: \"1\") {\n    text,\n    author {\n      name\n    }\n  }\n}\n```\n\nAnd here's a possible response:\n\n``` javascript\nquery: {\n  story: {\n     text: \"Relay is open-source!\",\n     author: {\n       name: \"Jan\"\n     }\n  }\n}\n```\n\nAlthough the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:\n\n``` javascript\nMap {\n  // `story(id: \"1\")`\n  1: Map {\n    text: 'Relay is open-source!',\n    author: Link(2),\n  },\n  // `story.author`\n  2: Map {\n    name: 'Jan',\n  },\n};\n```\n\nThis is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).\n\n### Using The Cache\n\nSo how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to `_cache.has(key)` above, but for a graph).\n\n### Populating The Cache\n\nPopulating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider `user(id: \"456\") { photo(size: 32) { uri } }` — how should we store `photo`? Using `photo` as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. `photo(size: 64) {...}`). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with `stories(first: 10, offset: 10)`, these new results should be *appended* to the existing list.\n\nTherefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the `photo` field from above might be cached with a generated field name such as `photo_size(32)` in order to uniquely identify the field and its argument values.\n\n### Reading From Cache\n\nTo read from the cache we can walk a query and resolve each field. But wait: that sounds *exactly* like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous — we either have the data cached or we don't.\n\nRelay implements several variations of **query traversal**: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a \"diff\" traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.\n\n### Cache Updates\n\nNote that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.\n\nThe first query was for a list of stories:\n\n``` javascript\nquery { stories { id, text, likeCount } }\n```\n\nWith a normalized response cache, a record would be created for each story in the list. The `stories` field would store links to each of these records.\n\nThe second query refetched the information for one of those stories:\n\n``` javascript\nquery { story(id: \"123\") { id, text, likeCount } }\n```\n\nWhen this response is normalized, Relay can detect that this result overlaps with existing data based on its `id`. Rather than create a new record, Relay will update the existing `123` record. The new `likeCount` is therefore available to *both* queries, as well as any other query that might reference this story.\n\n## Data/View Consistency\n\nA normalized cache ensures that the *cache* is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.\n\nConsider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:\n\n``` javascript\nquery {\n  story(id: \"1\") {\n    text,\n    author { name, photo },\n    comments {\n      text,\n      author { name, photo }\n    }\n  }\n}\n```\n\nAfter initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as `author`:\n\n``` javascript\n// Note: This is pseudo-code for `Map` initialization to make the structure\n// more obvious.\nMap {\n  // `story(id: \"1\")`\n  1: Map {\n    text: 'got GraphQL?',\n    author: Link(2),\n    comments: [Link(3)],\n  },\n  // `story.author`\n  2: Map {\n    name: 'Yuzhi',\n    photo: 'http://.../photo1.jpg',\n  },\n  // `story.comments[0]`\n  3: Map {\n    text: 'Here\\'s how to get one!',\n    author: Link(2),\n  },\n}\n```\n\nThe author of this story also commented on it — quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the *only* part of our cached data that changes:\n\n``` javascript\nMap {\n  ...\n  2: Map {\n    ...\n    photo: 'http://.../photo2.jpg',\n  },\n}\n```\n\nThe value of the `photo` field has changed; and therefore the record `2` has also changed. And that's it. Nothing else in the *cache* is affected. But clearly our *view* needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.\n\nA standard response is to \"just use immutable data structures\" — but let's see what would happen if we did:\n\n``` javascript\nImmutableMap {\n  1: ImmutableMap {/* same as before */}\n  2: ImmutableMap {\n    ... // other fields unchanged\n    photo: 'http://.../photo2.jpg',\n  },\n  3: ImmutableMap {/* same as before */}\n}\n```\n\nIf we replace `2` with a new immutable record, we'll also get a new immutable instance of the cache object. However, records `1` and `3` are untouched. Because the data is normalized, we can't tell that `story`'s contents have changed just by looking at the `story` record alone.\n\n### Achieving View Consistency\n\nThere are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (`1`), the author (`2`), and the comments (`3` and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies *only* the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default `shouldComponentUpdate`). Without this strategy, every view would re-render for even the tiniest change.\n\nNote that this solution will also work for *writes*: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.\n\n## Mutations\n\nSo far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called **mutations**. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:\n\n``` javascript\n// Give a human-readable name and define the types of the inputs,\n// in this case the id of the story to mark as liked.\nmutation StoryLike($storyID: String) {\n   // Call the mutation field and trigger its side effects\n   storyLike(storyID: $storyID) {\n     // Define fields to re-fetch after the mutation completes\n     likeCount\n   }\n}\n```\n\nNotice that we're querying for data that *may* have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over *any* data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.\n\nWe've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying *data storage* (disk) and data changes in your *product-visible schema* (GraphQL). The perfect example of this is privacy: returning a user-facing field such as `age` might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to *see* that `age` (Are we friends? Is my age shared? Did I block you? etc.).\n\nGiven these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas — let's look at them briefly in order to understand why Relay uses the approach that it does:\n\n- Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the *entire* query, wait to download the results, and wait to process them again. This is very inefficient.\n\n- Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that *isn't* currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.\n\n- Option 3: Re-fetch a fixed list of fields that *may* change after the mutation. We'll call this list a **fat query**. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.\n\n- Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called **tracked queries**. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.\n\n## Data-Fetching APIs\n\nSo far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:\n\n- Fetching all the data for a view hierarchy.\n- Managing asynchronous state transitions and coordinating concurrent requests.\n- Managing errors.\n- Retrying failed requests.\n- Updating the local cache after receiving query/mutation responses.\n- Queuing mutations to avoid race conditions.\n- Optimistically updating the UI while waiting for the server to respond to mutations.\n\nWe've found that typical approaches to data-fetching — with imperative APIs — force developers to deal with too much of this non-essential complexity. For example, consider *optimistic UI updates*. This is a way of giving the user feedback while waiting for a server response. The logic of *what* to do can be quite clear: when the user clicks \"like\", mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying *what* data we need often dictates *how* and *when* it is fetched. Next, we'll explore our approach to solving these concerns with **Relay**.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/thinking-in-graphql](https://relay.dev/docs/en/thinking-in-graphql)"
- name: Thinking In Relay
  id: thinking-in-relay
  summary: Relay's approach to data-fetching is heavily inspired by our experience with React
  description: "# Thinking In Relay\n\nRelay's approach to data-fetching is heavily inspired by our experience with React. In particular, React breaks complex interfaces into reusable **components**, allowing developers to reason about discrete units of an application in isolation, and reducing the coupling between disparate parts of an application. Even more important is that these components are **declarative**: they allow developers to specify *what* the UI should look like for a given state, and not have to worry about *how* to show that UI. Unlike previous approaches that used imperative commands to manipulate native views (e.g. the DOM), React uses a UI description to automatically determine the necessary commands.\n\nLet's look at some product use-cases to understand how we incorporated these ideas into Relay. We'll assume a basic familiarity with React.\n\n## Fetching Data For a View\n\nIn our experience, the overwhelming majority of products want one specific behavior: fetch *all* the data for a view hierarchy while displaying a loading indicator, and then render the *entire* view once the data is ready.\n\nOne solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing *any* root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in *components*.\n\nThe next logical approach is to use `render()` as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that *components use data to figure out what to render!* In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or *statically*.\n\nThis is where GraphQL comes into play. Components specify one or multiple GraphQL fragments for some of their props describing their data requirements. Each GraphQL fragment has a unique name within an application which allows us to determine the query needed to fetch the full query tree in a build step and load all the required data in a single network request efficiently at runtime.\n\n## Data Components aka Containers\n\nRelay allows developers to annotate their React components with data dependencies by creating **containers**. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a `<Story />` component might implement a view for rendering any `Story` item. The actual story to render would be determined by the data passed to the component: `<Story story={ ... } />`. The equivalent in GraphQL are **fragments**: named query snippets that specify what data to fetch *for an object of a given type*. We might describe the data needed by `<Story>` as follows:\n\n``` javascript\nfragment Story_story on Story {\n  text\n  author {\n    name\n    photo\n  }\n}\n```\n\nAnd this fragment can then be used to define the Story container:\n\n``` javascript\nconst {createFragmentContainer, graphql} = require('react-relay');\n\n// Plain React component.\n// Usage: `<Story story={ ... } />`\nclass Story extends React.Component { ... }\n\n// Higher-order component that wraps `<Story />`\nconst StoryContainer = createFragmentContainer(Story, {\n  // Define a fragment with a name matching the `story` prop expected above\n  story: graphql`\n    fragment Story_story on Story {\n      text\n      author {\n        name\n        photo\n      }\n    }\n  `\n})\n```\n\n## Rendering\n\nIn React, rendering a view requires two inputs: the *component* to render, and a *root* DOM (UI) node to render into. Rendering Relay containers is similar: we need a *container* to render, and a *root* in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to `ReactDOM.render(component, domNode)`, Relay provides `<QueryRenderer query={...} variables={...} render={...}>` for this purpose. The `query` and `variables` define what data to fetch and `render` defines what to render. Here's how we might render `<StoryContainer>`:\n\n``` javascript\nReactDOM.render(\n  <QueryRenderer\n    environment={/* defined or imported above... */}\n    query={graphql`\n      query StoryQuery($storyID: ID!) {\n        node(id: $storyID) {\n          ...Story_story\n        }\n      }\n    `}\n    variables={{\n      storyID: '123',\n    }}\n    render={(props, error) => {\n      if (error) {\n        return <ErrorView />;\n      } else if (props) {\n        return <StoryContainer story={props.story} />;\n      } else {\n        return <LoadingIndicator />;\n      }\n    }}\n  />,\n  rootElement\n)\n```\n\n`QueryRenderer` will then fetch the data and render `StoryContainer` once the data is available. Just as React allows developers to render views without directly manipulating the underlying view, Relay removes the need to directly communicate with the network.\n\n## Data Masking\n\nWith typical approaches to data-fetching we found that it was common for two components to have *implicit dependencies*. For example `<StoryHeader />` might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as `<Story />`. Then when we changed `<Story />` and removed that data-fetching logic, `<StoryHeader />` would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.\n\nWe've seen that Relay containers ensure that GraphQL fragments are fetched *before* the component is rendered. But containers also provide another benefit that isn't immediately obvious: **data masking**. Relay only allows components to access data they specifically ask for in GraphQL fragments — nothing more. So if one component queries for a Story's `text`, and another for its `author`, each can see *only* the field that they asked for. In fact, components can't even see the data requested by their *children*: that would also break encapsulation.\n\nRelay also goes further: it uses opaque identifiers on `props` to validate that we've explicitly fetched the data for a component before rendering it. If `<Story />` renders `<StoryHeader />` but forgets to include its fragment, Relay will warn that the data for `<StoryHeader />` is missing. In fact, Relay will warn *even if* some other component happened to fetch the same data required by `<StoryHeader />`. This warning tells us that although things *might* work now they're highly likely to break later.\n\n# Conclusion\n\nGraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for **declarative data-fetching**. By separating *what* data to fetch from *how* it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies — React, Relay, and GraphQL — are powerful on their own, the combination is a **UI platform** that allows us to *move fast* and *ship high-quality apps at scale*.\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/thinking-in-relay.html](https://relay.dev/docs/en/thinking-in-relay.html)"
- name: Transforms
  id: compiler-architecture#transforms
  summary: One of the main goals of the compiler is to provide a consistent platform for writing tools that transform or optimize GraphQL
  belongs_to: Compiler Architecture
  description: "## Transforms\n\nOne of the main goals of the compiler is to provide a consistent platform for writing tools that transform or optimize GraphQL. This includes the ability to experiment with new directives by transforming them away at compile time. Transform functions should typically perform a single type of modification - it's expected that an app will have multiple transforms configured in the compiler instance.\n\nHere are a few examples of some of the included transforms:\n\n- `FlattenTransform`: Reduces extraneous levels of indirection in a query, inlining fields from anonymous fragments wherever they match the parent type. This can be beneficial when generating code to read the results of a query or process query results, as it reduces duplicate field processing. For example:\n\n``` javascript\n          # before: `id` is processed twice\nfoo { # type FooType\n   id\n   ... on FooType { # matches the parent type, so this is extraneous\n     id\n   }\n }\n\n # after: `id` is processed once\n foo {\n   id\n }\n\n        \n```\n\n- `SkipRedundantNodeTransform`: A more advanced version of flattening, this eliminates more complex cases of field duplication such as when a field is fetched both unconditionally and conditionally, or is fetched by two different sub-fragments. For example:\n\n``` javascript\n          # before: `id` processed up to 2xfoo {\n  bar {\n    id\n  }\n  ... on FooType @include(if: $cond) { # can't be flattened due to conditional\n    id # but this field is guaranteed to be fetched regardless\n  }\n}\n\n# after: `id` processed at most once\nfoo {\n  bar {\n    id\n  }\n}\n\n        \n```\n\n- `GenerateRequisiteFieldTransform`: This optional, Relay-specific transform inserts `id` fields for globally identifiable objects and `__typename` fields wherever the type cannot be statically determined (e.g. for unions).\n\n© 2020–present Facebook Inc.  \nLicensed under the BSD License.  \n[https://relay.dev/docs/en/compiler-architecture.html](https://relay.dev/docs/en/compiler-architecture.html)"
- name: Updater Configs
  id: mutations#updater-configs
  summary: We can give Relay instructions in the form of a configs array on how to use the response from each mutation to update the client-side store
  belongs_to: Mutations
  description: |-
    ## Updater Configs

    We can give Relay instructions in the form of a `configs` array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following config types:
- name: Using The Cache
  id: thinking-in-graphql#using-the-cache
  summary: 'So how do we use this cache? Let''s look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to _cache.has(key) above, but for a graph)'
  belongs_to: Thinking in GraphQL
  description: |-
    ### Using The Cache

    So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to `_cache.has(key)` above, but for a graph).
- name: Using updater and optimisticUpdater
  id: mutations#using-updater-and-optimisticupdater
  summary: updater and optimisticUpdater are functions that you can pass to a commitMutation call when you need full control over how to update the local data store, either optimistically, or based on a server response
  belongs_to: Mutations
  description: "## Using updater and optimisticUpdater\n\n`updater` and `optimisticUpdater` are functions that you can pass to a `commitMutation` call when you need full control over how to update the local data store, either optimistically, or based on a server response. Often times, both of these can be the same function.\n\nWhen you provide these functions, this is roughly what happens during the mutation request:\n\n- If `optimisticResponse` is provided, Relay will use it to update the fields under the records as specified by the ids in the `optimisticResponse`.\n- If `optimisticUpdater` is provided, Relay will execute it and update the store accordingly.\n- After the network comes back, if any optimistic update was applied, it will be rolled back.\n- Relay will then automatically update the fields under the record corresponding to the ids in the response payload.\n- If an `updater` was provided, Relay will execute it and update the store accordingly. The server payload will be available to the `updater` as a root field in the store.\n\nHere are a quick example of adding a todo item to a Todo list using this [example schema](https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L36):\n\n``` javascript\n          // AddTodoMutation.jsimport {commitMutation, graphql} from 'react-relay';\nimport {ConnectionHandler} from 'relay-runtime';\n\nconst mutation = graphql`\n  mutation AddTodoMutation($text: String!) {\n    addTodo(text: $text) {\n      todoEdge {\n        cursor\n        node {\n          complete\n          id\n          text\n        }\n      }\n      viewer {\n        id\n        totalCount\n      }\n    }\n  }\n`;\n\nfunctionsharedUpdater(store, user, newEdge) {\n  // Get the current user record from the store\n  const userProxy = store.get(user.id);\n\n  // Get the user's Todo List using ConnectionHandler helper\n  const conn = ConnectionHandler.getConnection(\n    userProxy,\n    'TodoList_todos', // This is the connection identifier, defined here\n    // https://github.com/relayjs/relay-examples/blob/master/todo/js/components/TodoList.js#L76\n  );\n\n  // Insert the new todo into the Todo List connection\n  ConnectionHandler.insertEdgeAfter(conn, newEdge);\n}\n\nlet tempID = 0;\n\nfunctioncommit(environment, text, user) {\n  return commitMutation(environment, {\n    mutation,\n    variables: {\n      text,\n    },\n    updater: (store) => {\n      // Get the payload returned from the server\n      const payload = store.getRootField('addTodo');\n\n      // Get the edge of the newly created Todo record\n      const newEdge = payload.getLinkedRecord('todoEdge');\n\n      // Add it to the user's todo list\n      sharedUpdater(store, user, newEdge);\n    },\n    optimisticUpdater: (store) => {\n      // Create a Todo record in our store with a temporary ID\n      const id = 'client:newTodo:' + tempID++;\n      const node = store.create(id, 'Todo');\n      node.setValue(text, 'text');\n      node.setValue(id, 'id');\n\n      // Create a new edge that contains the newly created Todo record\n      const newEdge = store.create(\n        'client:newEdge:' + tempID++,\n        'TodoEdge',\n      );\n      newEdge.setLinkedRecord(node, 'node');\n\n      // Add it to the user's todo list\n      sharedUpdater(store, user, newEdge);\n\n      // Given that we don't have a server response here,\n      // we also need to update the todo item count on the user\n      const userRecord = store.get(user.id);\n      userRecord.setValue(\n        userRecord.getValue('totalCount') + 1,\n        'totalCount',\n      );\n    },\n  });\n}\n\n        \n```\n\nFor details on how to interact with the Relay Store, please refer to our Relay Store [docs](relay-store)."
