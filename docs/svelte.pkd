---
name: Svelte
slug: svelte
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: ''
copyright: |-
  © 2016–2023 Rich Harris and contributors
  Licensed under the MIT License.
  https://svelte.dev/docs/introduction
homepage: https://svelte.dev/

---
- name: 1. export creates a component prop
  id: svelte-components#script-1-export-creates-a-component-prop
  summary: Svelte uses the export keyword to mark a variable declaration as a property or prop, which means it becomes accessible to consumers of the component (see the section on attributes and props for more information)
  belongs_to: svelte-components
  description: "### 1. export creates a component prop\n\nSvelte uses the `export` keyword to mark a variable declaration as a *property* or *prop*, which means it becomes accessible to consumers of the component (see the section on [attributes and props](basic-markup#attributes-and-props) for more information).\n\n``` javascript\n<script>\n    export let foo;\n\n    // Values that are passed in as props\n    // are immediately available\n    console.log({ foo });\n</script>\n```\n\nYou can specify a default initial value for a prop. It will be used if the component's consumer doesn't specify the prop on the component (or if its initial value is `undefined`) when instantiating the component. Note that if the values of props are subsequently updated, then any prop whose value is not specified will be set to `undefined` (rather than its initial value).\n\nIn development mode (see the [compiler options](svelte-compiler#compile)), a warning will be printed if no default initial value is provided and the consumer does not specify a value. To squelch this warning, ensure that a default initial value is specified, even if it is `undefined`.\n\n``` javascript\n<script>\n    export let bar = 'optional default initial value';\n    export let baz = undefined;\n</script>\n```\n\nIf you export a `const`, `class` or `function`, it is readonly from outside the component. Functions are valid prop values, however, as shown below.\n\nApp.svelte\n\n``` javascript\n<script>\n    // these are readonly\n    export const thisIs = 'readonly';\n\n    /** @param {string} name */\n    export function greet(name) {\n        alert(`hello ${name}!`);\n    }\n\n    // this is a prop\n    export let format = (n) => n.toFixed(2);\n</script>\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    // these are readonly\n    export const thisIs = 'readonly';\n    \n    export function greet(name: string) {\n        alert(`hello ${name}!`);\n    }\n    \n    // this is a prop\n    export let format = (n) => n.toFixed(2);\n</script>\n```\n\nReadonly props can be accessed as properties on the element, tied to the component using [`bind:this` syntax](component-directives#bind-this).\n\nYou can use reserved words as prop names.\n\nApp.svelte\n\n``` javascript\n<script>\n    /** @type {string} */\n    let className;\n\n    // creates a `class` property, even\n    // though it is a reserved word\n    export { className as class };\n</script>\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    let className: string;\n    \n    // creates a `class` property, even\n    // though it is a reserved word\n    export { className as class };\n</script>\n```"
- name: 2. Assignments are 'reactive'
  id: svelte-components#script-2-assignments-are-reactive
  summary: To change component state and trigger a re-render, just assign to a locally declared variable
  belongs_to: svelte-components
  description: |-
    ### 2. Assignments are 'reactive'

    To change component state and trigger a re-render, just assign to a locally declared variable.

    Update expressions (`count += 1`) and property assignments (`obj.x = y`) have the same effect.

    ``` javascript
    <script>
        let count = 0;

        function handleClick() {
            // calling this function will trigger an
            // update if the markup references `count`
            count = count + 1;
        }
    </script>
    ```

    Because Svelte's reactivity is based on assignments, using array methods like `.push()` and `.splice()` won't automatically trigger updates. A subsequent assignment is required to trigger the update. This and more details can also be found in the [tutorial](https://learn.svelte.dev/tutorial/updating-arrays-and-objects).

    ``` javascript
    <script>
        let arr = [0, 1];

        function handleClick() {
            // this method call does not trigger an update
            arr.push(2);
            // this assignment will trigger an update
            // if the markup references `arr`
            arr = arr;
        }
    </script>
    ```

    Svelte's `<script>` blocks are run only when the component is created, so assignments within a `<script>` block are not automatically run again when a prop updates. If you'd like to track changes to a prop, see the next example in the following section.

    ``` javascript
    <script>
        export let person;
        // this will only set `name` on component creation
        // it will not update when `person` does
        let { name } = person;
    </script>
    ```
- name: '3. $: marks a statement as reactive'
  id: svelte-components#script-3-$-marks-a-statement-as-reactive
  summary: Any top-level statement (i.e
  belongs_to: svelte-components
  description: "### 3. $: marks a statement as reactive\n\nAny top-level statement (i.e. not inside a block or a function) can be made reactive by prefixing it with the `$:` [JS label syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label). Reactive statements run after other script code and before the component markup is rendered, whenever the values that they depend on have changed.\n\n``` javascript\n<script>\n    export let title;\n    export let person;\n\n    // this will update `document.title` whenever\n    // the `title` prop changes\n    $: document.title = title;\n\n    $: {\n        console.log(`multiple statements can be combined`);\n        console.log(`the current title is ${title}`);\n    }\n\n    // this will update `name` when 'person' changes\n    $: ({ name } = person);\n\n    // don't do this. it will run before the previous line\n    let name2 = name;\n</script>\n```\n\nOnly values which directly appear within the `$:` block will become dependencies of the reactive statement. For example, in the code below `total` will only update when `x` changes, but not `y`.\n\nApp.svelte\n\n``` javascript\n<script>\n    let x = 0;\n    let y = 0;\n\n    /** @param {number} value */\n    function yPlusAValue(value) {\n        return value + y;\n    }\n\n    $: total = yPlusAValue(x);\n</script>\n\nTotal: {total}\n<button on:click={() => x++}> Increment X </button>\n\n<button on:click={() => y++}> Increment Y </button>\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    let x = 0;\n    let y = 0;\n    \n    function yPlusAValue(value: number) {\n        return value + y;\n    }\n    \n    $: total = yPlusAValue(x);\n</script>\n\nTotal: {total}\n<button on:click={() => x++}> Increment X </button>\n\n<button on:click={() => y++}> Increment Y </button>\n```\n\nIt is important to note that the reactive blocks are ordered via simple static analysis at compile time, and all the compiler looks at are the variables that are assigned to and used within the block itself, not in any functions called by them. This means that `yDependent` will not be updated when `x` is updated in the following example:\n\n``` javascript\n<script>\n    let x = 0;\n    let y = 0;\n\n    /** @param {number} value */\n    function setY(value) {\n        y = value;\n    }\n\n    $: yDependent = y;\n    $: setY(x);\n</script>\n```\n\nMoving the line `$: yDependent = y` below `$: setY(x)` will cause `yDependent` to be updated when `x` is updated.\n\nIf a statement consists entirely of an assignment to an undeclared variable, Svelte will inject a `let` declaration on your behalf.\n\nApp.svelte\n\n``` javascript\n<script>\n    /** @type {number} */\n    export let num;\n\n    // we don't need to declare `squared` and `cubed`\n    // — Svelte does it for us\n    $: squared = num * num;\n    $: cubed = squared * num;\n</script>\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    export let num: number;\n    \n    // we don't need to declare `squared` and `cubed`\n    // — Svelte does it for us\n    $: squared = num * num;\n    $: cubed = squared * num;\n</script>\n```"
- name: 4. Prefix stores with $ to access their values
  id: svelte-components#script-4-prefix-stores-with-$-to-access-their-values
  summary: A store is an object that allows reactive access to a value via a simple store contract
  belongs_to: svelte-components
  description: |-
    ### 4. Prefix stores with $ to access their values

    A *store* is an object that allows reactive access to a value via a simple *store contract*. The [`svelte/store` module](svelte-store) contains minimal store implementations which fulfil this contract.

    Any time you have a reference to a store, you can access its value inside a component by prefixing it with the `$` character. This causes Svelte to declare the prefixed variable, subscribe to the store at component initialization and unsubscribe when appropriate.

    Assignments to `$`-prefixed variables require that the variable be a writable store, and will result in a call to the store's `.set` method.

    Note that the store must be declared at the top level of the component — not inside an `if` block or a function, for example.

    Local variables (that do not represent store values) must *not* have a `$` prefix.

    ``` javascript
    <script>
        import { writable } from 'svelte/store';

        const count = writable(0);
        console.log($count); // logs 0

        count.set(1);
        console.log($count); // logs 1

        $count = 2;
        console.log($count); // logs 2
    </script>
    ```
- name: $$slots
  id: special-elements#slot-$$slots
  summary: $$slots is an object whose keys are the names of the slots passed into the component by the parent
  belongs_to: special-elements
  description: |-
    ### $$slots

    `$$slots` is an object whose keys are the names of the slots passed into the component by the parent. If the parent does not pass in a slot with a particular name, that name will not be present in `$$slots`. This allows components to render a slot (and other elements, like wrappers for styling) only if the parent provides it.

    Note that explicitly passing in an empty named slot will add that slot's name to `$$slots`. For example, if a parent passes `<div slot="title" />` to a child component, `$$slots.title` will be truthy within the child.

    ``` javascript
    <!-- Card.svelte -->
    <div>
        <slot name="title" />
        {#if $$slots.description}
            <!-- This <hr> and slot will render only if a slot named "description" is provided. -->
            <hr />
            <slot name="description" />
        {/if}
    </div>

    <!-- App.svelte -->
    <Card>
        <h1 slot="title">Blog Post Title</h1>
        <!-- No slot named "description" was provided so the optional slot will not be rendered. -->
    </Card>
    ```
- name: $destroy
  id: client-side-component-api#$destroy
  summary: Removes a component from the DOM and triggers any onDestroy handlers
  belongs_to: client-side-component-api
  description: |-
    ## $destroy

    ``` javascript
    component.$destroy();
    ```

    Removes a component from the DOM and triggers any `onDestroy` handlers.
- name: $on
  id: client-side-component-api#$on
  summary: Causes the callback function to be called whenever the component dispatches an event
  belongs_to: client-side-component-api
  description: |-
    ## $on

    ``` javascript
    component.$on(ev, callback);
    ```

    Causes the `callback` function to be called whenever the component dispatches an `event`.

    A function is returned that will remove the event listener when called.

    index.js

    ``` javascript
    const off = component.$on('selected', (event) => {
        console.log(event.detail.selection);
    });


    off();
    ```
- name: $set
  id: client-side-component-api#$set
  summary: Programmatically sets props on an instance
  belongs_to: client-side-component-api
  description: |-
    ## $set

    ``` javascript
    component.$set(props);
    ```

    Programmatically sets props on an instance. `component.$set({ x: 1 })` is equivalent to `x = 1` inside the component's `<script>` block.

    Calling this method schedules an update for the next microtask — the DOM is *not* updated synchronously.

    ``` javascript
    component.$set({ answer: 42 });
    ```
- name: --style-props
  id: component-directives#style-props
  summary: You can also pass styles as props to components for the purposes of theming, using CSS custom properties
  belongs_to: component-directives
  description: |-
    ## --style-props

    ``` javascript
    --style-props="anycssvalue"
    ```

    You can also pass styles as props to components for the purposes of theming, using CSS custom properties.

    Svelte's implementation is essentially syntactic sugar for adding a wrapper element. This example:

    ``` javascript
    <Slider bind:value min={0} --rail-color="black" --track-color="rgb(0, 0, 255)" />
    ```

    Desugars to this:

    ``` javascript
    <div style="display: contents; --rail-color: black; --track-color: rgb(0, 0, 255)">
        <Slider bind:value min={0} max={100} />
    </div>
    ```

    **Note**: Since this is an extra `<div>`, beware that your CSS structure might accidentally target this. Be mindful of this added wrapper element when using this feature.

    For SVG namespace, the example above desugars into using `<g>` instead:

    ``` javascript
    <g style="--rail-color: black; --track-color: rgb(0, 0, 255)">
        <Slider bind:value min={0} max={100} />
    </g>
    ```

    **Note**: Since this is an extra `<g>`, beware that your CSS structure might accidentally target this. Be mindful of this added wrapper element when using this feature.

    Svelte's CSS Variables support allows for easily themeable components:

    ``` javascript
    <style>
        .potato-slider-rail {
            background-color: var(--rail-color, var(--theme-color, 'purple'));
        }
    </style>
    ```

    So you can set a high-level theme color:

    ``` javascript
    /* global.css */
    html {
        --theme-color: black;
    }
    ```

    Or override it at the consumer level:

    ``` javascript
    <Slider --rail-color="goldenrod" />
    ```
- name: <script context="module">
  id: svelte-components#script-context-module
  summary: A <script> tag with a context="module" attribute runs once when the module first evaluates, rather than for each component instance
  belongs_to: svelte-components
  description: |-
    ## \<script context="module"\>

    A `<script>` tag with a `context="module"` attribute runs once when the module first evaluates, rather than for each component instance. Values declared in this block are accessible from a regular `<script>` (and the component markup) but not vice versa.

    You can `export` bindings from this block, and they will become exports of the compiled module.

    You cannot `export default`, since the default export is the component itself.

    > Variables defined in `module` scripts are not reactive — reassigning them will not trigger a rerender even though the variable itself will update. For values shared between multiple components, consider using a [store](svelte-store).

    ``` javascript
    <script context="module">
        let totalComponents = 0;

        // the export keyword allows this function to imported with e.g.
        // `import Example, { alertTotal } from './Example.svelte'`
        export function alertTotal() {
            alert(totalComponents);
        }
    </script>

    <script>
        totalComponents += 1;
        console.log(`total number of times this component has been created: ${totalComponents}`);
    </script>
    ```
- name: <script lang="ts">
  id: typescript#script-lang-ts
  summary: null
  belongs_to: typescript
  description: |-
    ## \<script lang="ts"\>

    To use TypeScript inside your Svelte components, add `lang="ts"` to your `script` tags:

    ``` javascript
    <script lang="ts">
        let name: string = 'world';

        function greet(name: string) {
            alert(`Hello, ${name}!`);
        }
    </script>
    ```
- name: <script>
  id: svelte-components#script
  summary: A <script> block contains JavaScript that runs when a component instance is created
  belongs_to: svelte-components
  description: |-
    ## \<script\>

    A `<script>` block contains JavaScript that runs when a component instance is created. Variables declared (or imported) at the top level are 'visible' from the component's markup. There are four additional rules:
- name: <slot key={value}>
  id: special-elements#slot-slot-key-value
  summary: Slots can be rendered zero or more times and can pass values back to the parent using props
  belongs_to: special-elements
  description: |-
    ### \<slot key={*value*}\>

    Slots can be rendered zero or more times and can pass values *back* to the parent using props. The parent exposes the values to the slot template using the `let:` directive.

    The usual shorthand rules apply — `let:item` is equivalent to `let:item={item}`, and `<slot {item}>` is equivalent to `<slot item={item}>`.

    ``` javascript
    <!-- FancyList.svelte -->
    <ul>
        {#each items as item}
            <li class="fancy">
                <slot prop={item} />
            </li>
        {/each}
    </ul>

    <!-- App.svelte -->
    <FancyList {items} let:prop={thing}>
        <div>{thing.text}</div>
    </FancyList>
    ```

    Named slots can also expose values. The `let:` directive goes on the element with the `slot` attribute.

    ``` javascript
    <!-- FancyList.svelte -->
    <ul>
        {#each items as item}
            <li class="fancy">
                <slot name="item" {item} />
            </li>
        {/each}
    </ul>

    <slot name="footer" />

    <!-- App.svelte -->
    <FancyList {items}>
        <div slot="item" let:item>{item.text}</div>
        <p slot="footer">Copyright (c) 2019 Svelte Industries</p>
    </FancyList>
    ```
- name: <slot name="name">
  id: special-elements#slot-slot-name-name
  summary: Named slots allow consumers to target specific areas
  belongs_to: special-elements
  description: |-
    ### \<slot name="*name*"\>

    Named slots allow consumers to target specific areas. They can also have fallback content.

    ``` javascript
    <!-- Widget.svelte -->
    <div>
        <slot name="header">No header was provided</slot>
        <p>Some content between header and footer</p>
        <slot name="footer" />
    </div>

    <!-- App.svelte -->
    <Widget>
        <h1 slot="header">Hello</h1>
        <p slot="footer">Copyright (c) 2019 Svelte Industries</p>
    </Widget>
    ```

    Components can be placed in a named slot using the syntax `<Component slot="name" />`. In order to place content in a slot without using a wrapper element, you can use the special element `<svelte:fragment>`.

    ``` javascript
    <!-- Widget.svelte -->
    <div>
        <slot name="header">No header was provided</slot>
        <p>Some content between header and footer</p>
        <slot name="footer" />
    </div>

    <!-- App.svelte -->
    <Widget>
        <HeaderComponent slot="header" />
        <svelte:fragment slot="footer">
            <p>All rights reserved.</p>
            <p>Copyright (c) 2019 Svelte Industries</p>
        </svelte:fragment>
    </Widget>
    ```
- name: <slot>
  id: special-elements#slot
  summary: Components can have child content, in the same way that elements can
  belongs_to: special-elements
  description: |-
    ## \<slot\>

    ``` javascript
    <slot><!-- optional fallback --></slot>
    ```

    ``` javascript
    <slot name="x"><!-- optional fallback --></slot>
    ```

    ``` javascript
    <slot prop={value} />
    ```

    Components can have child content, in the same way that elements can.

    The content is exposed in the child component using the `<slot>` element, which can contain fallback content that is rendered if no children are provided.

    ``` javascript
    <!-- Widget.svelte -->
    <div>
        <slot>
            this fallback content will be rendered when no content is provided, like in the first example
        </slot>
    </div>

    <!-- App.svelte -->
    <Widget />
    <!-- this component will render the default content -->

    <Widget>
        <p>this is some child content that will overwrite the default slot content</p>
    </Widget>
    ```

    Note: If you want to render regular `<slot>` element, You can use `<svelte:element this="slot" />`.
- name: <style>
  id: svelte-components#style
  summary: CSS inside a <style> block will be scoped to that component
  belongs_to: svelte-components
  description: "## \\<style\\>\n\nCSS inside a `<style>` block will be scoped to that component.\n\nThis works by adding a class to affected elements, which is based on a hash of the component styles (e.g. `svelte-123xyz`).\n\n``` javascript\n<style>\n    p {\n        /* this will only affect <p> elements in this component */\n        color: burlywood;\n    }\n</style>\n```\n\nTo apply styles to a selector globally, use the `:global(...)` modifier.\n\n``` javascript\n<style>\n    :global(body) {\n        /* this will apply to <body> */\n        margin: 0;\n    }\n\n    div :global(strong) {\n        /* this will apply to all <strong> elements, in any\n             component, that are inside <div> elements belonging\n             to this component */\n        color: goldenrod;\n    }\n\n    p:global(.red) {\n        /* this will apply to all <p> elements belonging to this\n             component with a class of red, even if class=\"red\" does\n             not initially appear in the markup, and is instead\n             added at runtime. This is useful when the class\n             of the element is dynamically applied, for instance\n             when updating the element's classList property directly. */\n    }\n</style>\n```\n\nIf you want to make @keyframes that are accessible globally, you need to prepend your keyframe names with `-global-`.\n\nThe `-global-` part will be removed when compiled, and the keyframe then be referenced using just `my-animation-name` elsewhere in your code.\n\n``` javascript\n<style>\n    @keyframes -global-my-animation-name {\n        /* code goes here */\n    }\n</style>\n```\n\nThere should only be 1 top-level `<style>` tag per component.\n\nHowever, it is possible to have `<style>` tag nested inside other elements or logic blocks.\n\nIn that case, the `<style>` tag will be inserted as-is into the DOM, no scoping or processing will be done on the `<style>` tag.\n\n``` javascript\n<div>\n    <style>\n        /* this style tag will be inserted as-is */\n        div {\n            /* this will apply to all `<div>` elements in the DOM */\n            color: red;\n        }\n    </style>\n</div>\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-components](https://svelte.dev/docs/svelte-components)"
- name: <svelte:body>
  id: special-elements#svelte-body
  summary: Similarly to <svelte:window>, this element allows you to add listeners to events on document.body, such as mouseenter and mouseleave, which don't fire on window
  belongs_to: special-elements
  description: |-
    ## \<svelte:body\>

    ``` javascript
    <svelte:body on:event={handler} />
    ```

    Similarly to `<svelte:window>`, this element allows you to add listeners to events on `document.body`, such as `mouseenter` and `mouseleave`, which don't fire on `window`. It also lets you use [actions](element-directives#use-action) on the `<body>` element.

    As with `<svelte:window>` and `<svelte:document>`, this element may only appear the top level of your component and must never be inside a block or element.

    ``` javascript
    <svelte:body on:mouseenter={handleMouseenter} on:mouseleave={handleMouseleave} use:someAction />
    ```
- name: <svelte:component>
  id: special-elements#svelte-component
  summary: The <svelte:component> element renders a component dynamically, using the component constructor specified as the this property
  belongs_to: special-elements
  description: |-
    ## \<svelte:component\>

    ``` javascript
    <svelte:component this={expression} />
    ```

    The `<svelte:component>` element renders a component dynamically, using the component constructor specified as the `this` property. When the property changes, the component is destroyed and recreated.

    If `this` is falsy, no component is rendered.

    ``` javascript
    <svelte:component this={currentSelection.component} foo={bar} />
    ```
- name: <svelte:document>
  id: special-elements#svelte-document
  summary: Similarly to <svelte:window>, this element allows you to add listeners to events on document, such as visibilitychange, which don't fire on window
  belongs_to: special-elements
  description: |-
    ## \<svelte:document\>

    ``` javascript
    <svelte:document on:event={handler} />
    ```

    ``` javascript
    <svelte:document bind:prop={value} />
    ```

    Similarly to `<svelte:window>`, this element allows you to add listeners to events on `document`, such as `visibilitychange`, which don't fire on `window`. It also lets you use [actions](element-directives#use-action) on `document`.

    As with `<svelte:window>`, this element may only appear the top level of your component and must never be inside a block or element.

    ``` javascript
    <svelte:document on:visibilitychange={handleVisibilityChange} use:someAction />
    ```

    You can also bind to the following properties:

    - `fullscreenElement`
    - `visibilityState`

    All are readonly.
- name: <svelte:element>
  id: special-elements#svelte-element
  summary: The <svelte:element> element lets you render an element of a dynamically specified type
  belongs_to: special-elements
  description: |-
    ## \<svelte:element\>

    ``` javascript
    <svelte:element this={expression} />
    ```

    The `<svelte:element>` element lets you render an element of a dynamically specified type. This is useful for example when displaying rich text content from a CMS. Any properties and event listeners present will be applied to the element.

    The only supported binding is `bind:this`, since the element type-specific bindings that Svelte does at build time (e.g. `bind:value` for input elements) do not work with a dynamic tag type.

    If `this` has a nullish value, the element and its children will not be rendered.

    If `this` is the name of a [void element](https://developer.mozilla.org/en-US/docs/Glossary/Void_element) (e.g., `br`) and `<svelte:element>` has child elements, a runtime error will be thrown in development mode.

    ``` javascript
    <script>
        let tag = 'div';

        export let handler;
    </script>

    <svelte:element this={tag} on:click={handler}>Foo</svelte:element>
    ```
- name: <svelte:fragment>
  id: special-elements#svelte-fragment
  summary: The <svelte:fragment> element allows you to place content in a named slot without wrapping it in a container DOM element
  belongs_to: special-elements
  description: "## \\<svelte:fragment\\>\n\nThe `<svelte:fragment>` element allows you to place content in a [named slot](special-elements#slot-slot-name-name) without wrapping it in a container DOM element. This keeps the flow layout of your document intact.\n\n``` javascript\n<!-- Widget.svelte -->\n<div>\n    <slot name=\"header\">No header was provided</slot>\n    <p>Some content between header and footer</p>\n    <slot name=\"footer\" />\n</div>\n\n<!-- App.svelte -->\n<Widget>\n    <h1 slot=\"header\">Hello</h1>\n    <svelte:fragment slot=\"footer\">\n        <p>All rights reserved.</p>\n        <p>Copyright (c) 2019 Svelte Industries</p>\n    </svelte:fragment>\n</Widget>\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/special-elements](https://svelte.dev/docs/special-elements)"
- name: <svelte:head>
  id: special-elements#svelte-head
  summary: This element makes it possible to insert elements into document.head
  belongs_to: special-elements
  description: |-
    ## \<svelte:head\>

    ``` javascript
    <svelte:head>...</svelte:head>
    ```

    This element makes it possible to insert elements into `document.head`. During server-side rendering, `head` content is exposed separately to the main `html` content.

    As with `<svelte:window>`, `<svelte:document>` and `<svelte:body>`, this element may only appear at the top level of your component and must never be inside a block or element.

    ``` javascript
    <svelte:head>
        <title>Hello world!</title>
        <meta name="description" content="This is where the description goes for SEO" />
    </svelte:head>
    ```
- name: <svelte:options>
  id: special-elements#svelte-options
  summary: The <svelte:options> element provides a place to specify per-component compiler options, which are detailed in the compiler section
  belongs_to: special-elements
  description: |-
    ## \<svelte:options\>

    ``` javascript
    <svelte:options option={value} />
    ```

    The `<svelte:options>` element provides a place to specify per-component compiler options, which are detailed in the [compiler section](svelte-compiler#compile). The possible options are:

    - `immutable={true}` — you never use mutable data, so the compiler can do simple referential equality checks to determine if values have changed
    - `immutable={false}` — the default. Svelte will be more conservative about whether or not mutable objects have changed
    - `accessors={true}` — adds getters and setters for the component's props
    - `accessors={false}` — the default
    - `namespace="..."` — the namespace where this component will be used, most commonly "svg"; use the "foreign" namespace to opt out of case-insensitive attribute names and HTML-specific warnings
    - `customElement="..."` — the name to use when compiling this component as a custom element

    ``` javascript
    <svelte:options customElement="my-custom-element" />
    ```
- name: <svelte:self>
  id: special-elements#svelte-self
  summary: The <svelte:self> element allows a component to include itself, recursively
  belongs_to: special-elements
  description: |-
    ## \<svelte:self\>

    The `<svelte:self>` element allows a component to include itself, recursively.

    It cannot appear at the top level of your markup; it must be inside an if or each block or passed to a component's slot to prevent an infinite loop.

    ``` javascript
    <script>
        /** @type {number} */
        export let count;
    </script>

    {#if count > 0}
        <p>counting down... {count}</p>
        <svelte:self count={count - 1} />
    {:else}
        <p>lift-off!</p>
    {/if}
    ```
- name: <svelte:window>
  id: special-elements#svelte-window
  summary: The <svelte:window> element allows you to add event listeners to the window object without worrying about removing them when the component is destroyed, or checking for the existence of window when server-side rendering
  belongs_to: special-elements
  description: |-
    ## \<svelte:window\>

    ``` javascript
    <svelte:window on:event={handler} />
    ```

    ``` javascript
    <svelte:window bind:prop={value} />
    ```

    The `<svelte:window>` element allows you to add event listeners to the `window` object without worrying about removing them when the component is destroyed, or checking for the existence of `window` when server-side rendering.

    Unlike `<svelte:self>`, this element may only appear at the top level of your component and must never be inside a block or element.

    ``` javascript
    <script>
        /** @param {KeyboardEvent} event */
        function handleKeydown(event) {
            alert(`pressed the ${event.key} key`);
        }
    </script>

    <svelte:window on:keydown={handleKeydown} />
    ```

    You can also bind to the following properties:

    - `innerWidth`
    - `innerHeight`
    - `outerWidth`
    - `outerHeight`
    - `scrollX`
    - `scrollY`
    - `online` — an alias for `window.navigator.onLine`
    - `devicePixelRatio`

    All except `scrollX` and `scrollY` are readonly.

    ``` javascript
    <svelte:window bind:scrollY={y} />
    ```

    > Note that the page will not be scrolled to the initial value to avoid accessibility issues. Only subsequent changes to the bound variable of `scrollX` and `scrollY` will cause scrolling. However, if the scrolling behaviour is desired, call `scrollTo()` in `onMount()`.
- name: a11y-accesskey
  id: accessibility-warnings#a11y-accesskey
  summary: Enforce no accesskey on element
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-accesskey

    Enforce no `accesskey` on element. Access keys are HTML attributes that allow web developers to assign keyboard shortcuts to elements. Inconsistencies between keyboard shortcuts and keyboard commands used by screen reader and keyboard-only users create accessibility complications. To avoid complications, access keys should not be used.

    ``` javascript
    <!-- A11y: Avoid using accesskey -->
    <div accessKey="z" />
    ```
- name: a11y-aria-activedescendant-has-tabindex
  id: accessibility-warnings#a11y-aria-activedescendant-has-tabindex
  summary: An element with aria-activedescendant must be tabbable, so it must either have an inherent tabindex or declare tabindex as an attribute
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-aria-activedescendant-has-tabindex

    An element with `aria-activedescendant` must be tabbable, so it must either have an inherent `tabindex` or declare `tabindex` as an attribute.

    ``` javascript
    <!-- A11y: Elements with attribute aria-activedescendant should have tabindex value -->
    <div aria-activedescendant="some-id" />
    ```
- name: a11y-aria-attributes
  id: accessibility-warnings#a11y-aria-attributes
  summary: Certain reserved DOM elements do not support ARIA roles, states and properties
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-aria-attributes

    Certain reserved DOM elements do not support ARIA roles, states and properties. This is often because they are not visible, for example `meta`, `html`, `script`, `style`. This rule enforces that these DOM elements do not contain the `aria-*` props.

    ``` javascript
    <!-- A11y: <meta> should not have aria-* attributes -->
    <meta aria-hidden="false" />
    ```
- name: a11y-autofocus
  id: accessibility-warnings#a11y-autofocus
  summary: Enforce that autofocus is not used on elements
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-autofocus

    Enforce that `autofocus` is not used on elements. Autofocusing elements can cause usability issues for sighted and non-sighted users alike.

    ``` javascript
    <!-- A11y: Avoid using autofocus -->
    <input autofocus />
    ```
- name: a11y-click-events-have-key-events
  id: accessibility-warnings#a11y-click-events-have-key-events
  summary: 'Enforce on:click is accompanied by at least one of the following: on:keyup, on:keydown, on:keypress'
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-click-events-have-key-events

    Enforce `on:click` is accompanied by at least one of the following: `on:keyup`, `on:keydown`, `on:keypress`. Coding for the keyboard is important for users with physical disabilities who cannot use a mouse, AT compatibility, and screenreader users.

    This does not apply for interactive or hidden elements.

    ``` javascript
    <!-- A11y: visible, non-interactive elements with an on:click event must be accompanied by an on:keydown, on:keyup, or on:keypress event. -->
    <div on:click={() => {}} />
    ```

    Note that the `keypress` event is now deprecated, so it is officially recommended to use either the `keyup` or `keydown` event instead, accordingly.
- name: a11y-distracting-elements
  id: accessibility-warnings#a11y-distracting-elements
  summary: Enforces that no distracting elements are used
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-distracting-elements

    Enforces that no distracting elements are used. Elements that can be visually distracting can cause accessibility issues with visually impaired users. Such elements are most likely deprecated, and should be avoided.

    The following elements are visually distracting: `<marquee>` and `<blink>`.

    ``` javascript
    <!-- A11y: Avoid <marquee> elements -->
    <marquee />
    ```
- name: a11y-hidden
  id: accessibility-warnings#a11y-hidden
  summary: Certain DOM elements are useful for screen reader navigation and should not be hidden
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-hidden

    Certain DOM elements are useful for screen reader navigation and should not be hidden.

    ``` javascript
    <!-- A11y: <h2> element should not be hidden -->
    <h2 aria-hidden="true">invisible header</h2>
    ```
- name: a11y-img-redundant-alt
  id: accessibility-warnings#a11y-img-redundant-alt
  summary: Enforce img alt attribute does not contain the word image, picture, or photo
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-img-redundant-alt

    Enforce img alt attribute does not contain the word image, picture, or photo. Screen readers already announce `img` elements as an image. There is no need to use words such as *image*, *photo*, and/or *picture*.

    ``` javascript
    <img src="foo" alt="Foo eating a sandwich." />

    <!-- aria-hidden, won't be announced by screen reader -->
    <img src="bar" aria-hidden="true" alt="Picture of me taking a photo of an image" />

    <!-- A11y: Screen readers already announce <img> elements as an image. -->
    <img src="foo" alt="Photo of foo being weird." />

    <!-- A11y: Screen readers already announce <img> elements as an image. -->
    <img src="bar" alt="Image of me at a bar!" />

    <!-- A11y: Screen readers already announce <img> elements as an image. -->
    <img src="foo" alt="Picture of baz fixing a bug." />
    ```
- name: a11y-incorrect-aria-attribute-type
  id: accessibility-warnings#a11y-incorrect-aria-attribute-type
  summary: Enforce that only the correct type of value is used for aria attributes
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-incorrect-aria-attribute-type

    Enforce that only the correct type of value is used for aria attributes. For example, `aria-hidden` should only receive a boolean.

    ``` javascript
    <!-- A11y: The value of 'aria-hidden' must be exactly one of true or false -->
    <div aria-hidden="yes" />
    ```
- name: a11y-interactive-supports-focus
  id: accessibility-warnings#a11y-interactive-supports-focus
  summary: Enforce that elements with an interactive role and interactive handlers (mouse or key press) must be focusable or tabbable
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-interactive-supports-focus

    Enforce that elements with an interactive role and interactive handlers (mouse or key press) must be focusable or tabbable.

    ``` javascript
    <!-- A11y: Elements with the 'button' interactive role must have a tabindex value. -->
    <div role="button" on:keypress={() => {}} />
    ```
- name: a11y-invalid-attribute
  id: accessibility-warnings#a11y-invalid-attribute
  summary: Enforce that attributes important for accessibility have a valid value
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-invalid-attribute

    Enforce that attributes important for accessibility have a valid value. For example, `href` should not be empty, `'#'`, or `javascript:`.

    ``` javascript
    <!-- A11y: '' is not a valid href attribute -->
    <a href="">invalid</a>
    ```
- name: a11y-label-has-associated-control
  id: accessibility-warnings#a11y-label-has-associated-control
  summary: Enforce that a label tag has a text label and an associated control
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-label-has-associated-control

    Enforce that a label tag has a text label and an associated control.

    There are two supported ways to associate a label with a control:

    - Wrapping a control in a label tag.
    - Adding `for` to a label and assigning it the ID of an input on the page.

    ``` javascript
    <label for="id">B</label>

    <label>C <input type="text" /></label>

    <!-- A11y: A form label must be associated with a control. -->
    <label>A</label>
    ```
- name: a11y-media-has-caption
  id: accessibility-warnings#a11y-media-has-caption
  summary: Providing captions for media is essential for deaf users to follow along
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-media-has-caption

    Providing captions for media is essential for deaf users to follow along. Captions should be a transcription or translation of the dialogue, sound effects, relevant musical cues, and other relevant audio information. Not only is this important for accessibility, but can also be useful for all users in the case that the media is unavailable (similar to `alt` text on an image when an image is unable to load).

    The captions should contain all important and relevant information to understand the corresponding media. This may mean that the captions are not a 1:1 mapping of the dialogue in the media content. However, captions are not necessary for video components with the `muted` attribute.

    ``` javascript
    <video><track kind="captions" /></video>

    <audio muted />

    <!-- A11y: Media elements must have a <track kind=\"captions\"> -->
    <video />

    <!-- A11y: Media elements must have a <track kind=\"captions\"> -->
    <video><track /></video>
    ```
- name: a11y-misplaced-role
  id: accessibility-warnings#a11y-misplaced-role
  summary: Certain reserved DOM elements do not support ARIA roles, states and properties
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-misplaced-role

    Certain reserved DOM elements do not support ARIA roles, states and properties. This is often because they are not visible, for example `meta`, `html`, `script`, `style`. This rule enforces that these DOM elements do not contain the `role` props.

    ``` javascript
    <!-- A11y: <meta> should not have role attribute -->
    <meta role="tooltip" />
    ```
- name: a11y-misplaced-scope
  id: accessibility-warnings#a11y-misplaced-scope
  summary: The scope attribute should only be used on <th> elements
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-misplaced-scope

    The scope attribute should only be used on `<th>` elements.

    ``` javascript
    <!-- A11y: The scope attribute should only be used with <th> elements -->
    <div scope="row" />
    ```
- name: a11y-missing-attribute
  id: accessibility-warnings#a11y-missing-attribute
  summary: Enforce that attributes required for accessibility are present on an element
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-missing-attribute

    Enforce that attributes required for accessibility are present on an element. This includes the following checks:

    - `<a>` should have an href (unless it's a [fragment-defining tag](https://github.com/sveltejs/svelte/issues/4697))
    - `<area>` should have alt, aria-label, or aria-labelledby
    - `<html>` should have lang
    - `<iframe>` should have title
    - `<img>` should have alt
    - `<object>` should have title, aria-label, or aria-labelledby
    - `<input type="image">` should have alt, aria-label, or aria-labelledby

    ``` javascript
    <!-- A11y: <input type=\"image\"> element should have an alt, aria-label or aria-labelledby attribute -->
    <input type="image" />

    <!-- A11y: <html> element should have a lang attribute -->
    <html />

    <!-- A11y: <a> element should have an href attribute -->
    <a>text</a>
    ```
- name: a11y-missing-content
  id: accessibility-warnings#a11y-missing-content
  summary: null
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-missing-content

    Enforce that heading elements (`h1`, `h2`, etc.) and anchors have content and that the content is accessible to screen readers

    ``` javascript
    <!-- A11y: <a> element should have child content -->
    <a href="/foo" />

    <!-- A11y: <h1> element should have child content -->
    <h1 />
    ```
- name: a11y-mouse-events-have-key-events
  id: accessibility-warnings#a11y-mouse-events-have-key-events
  summary: Enforce that on:mouseover and on:mouseout are accompanied by on:focus and on:blur, respectively
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-mouse-events-have-key-events

    Enforce that `on:mouseover` and `on:mouseout` are accompanied by `on:focus` and `on:blur`, respectively. This helps to ensure that any functionality triggered by these mouse events is also accessible to keyboard users.

    ``` javascript
    <!-- A11y: on:mouseover must be accompanied by on:focus -->
    <div on:mouseover={handleMouseover} />

    <!-- A11y: on:mouseout must be accompanied by on:blur -->
    <div on:mouseout={handleMouseout} />
    ```
- name: a11y-no-interactive-element-to-noninteractive-role
  id: accessibility-warnings#a11y-no-interactive-element-to-noninteractive-role
  summary: WAI-ARIA roles should not be used to convert an interactive element to a non-interactive element
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-no-interactive-element-to-noninteractive-role

    [WAI-ARIA](https://www.w3.org/TR/wai-aria-1.1/#usage_intro) roles should not be used to convert an interactive element to a non-interactive element. Non-interactive ARIA roles include `article`, `banner`, `complementary`, `img`, `listitem`, `main`, `region` and `tooltip`.

    ``` javascript
    <!-- A11y: <textarea> cannot have role 'listitem' -->
    <textarea role="listitem" />
    ```
- name: a11y-no-noninteractive-element-interactions
  id: accessibility-warnings#a11y-no-interactive-element-to-noninteractive-role-a11y-no-noninteractive-element-interactions
  summary: A non-interactive element does not support event handlers (mouse and key handlers)
  belongs_to: accessibility-warnings
  description: |-
    ### a11y-no-noninteractive-element-interactions

    A non-interactive element does not support event handlers (mouse and key handlers). Non-interactive elements include `<main>`, `<area>`, `<h1>` (,`<h2>`, etc), `<p>`, `<img>`, `<li>`, `<ul>` and `<ol>`. Non-interactive [WAI-ARIA roles](https://www.w3.org/TR/wai-aria-1.1/#usage_intro) include `article`, `banner`, `complementary`, `img`, `listitem`, `main`, `region` and `tooltip`.

    ``` javascript
    <!-- `A11y: Non-interactive element <li> should not be assigned mouse or keyboard event listeners.` -->
    <li on:click={() => {}} />

    <!-- `A11y: Non-interactive element <div> should not be assigned mouse or keyboard event listeners.` -->
    <div role="listitem" on:click={() => {}} />
    ```
- name: a11y-no-noninteractive-element-to-interactive-role
  id: accessibility-warnings#a11y-no-interactive-element-to-noninteractive-role-a11y-no-noninteractive-element-to-interactive-role
  summary: WAI-ARIA roles should not be used to convert a non-interactive element to an interactive element
  belongs_to: accessibility-warnings
  description: |-
    ### a11y-no-noninteractive-element-to-interactive-role

    [WAI-ARIA](https://www.w3.org/TR/wai-aria-1.1/#usage_intro) roles should not be used to convert a non-interactive element to an interactive element. Interactive ARIA roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`, `menuitemradio`, `option`, `radio`, `searchbox`, `switch` and `textbox`.

    ``` javascript
    <!-- A11y: Non-interactive element <h3> cannot have interactive role 'searchbox' -->
    <h3 role="searchbox">Button</h3>
    ```
- name: a11y-no-noninteractive-tabindex
  id: accessibility-warnings#a11y-no-noninteractive-tabindex
  summary: Tab key navigation should be limited to elements on the page that can be interacted with
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-no-noninteractive-tabindex

    Tab key navigation should be limited to elements on the page that can be interacted with.

    ``` javascript
    <!-- A11y: noninteractive element cannot have nonnegative tabIndex value -->
    <div tabindex="0" />
    ```
- name: a11y-no-redundant-roles
  id: accessibility-warnings#a11y-no-redundant-roles
  summary: Some HTML elements have default ARIA roles
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-no-redundant-roles

    Some HTML elements have default ARIA roles. Giving these elements an ARIA role that is already set by the browser [has no effect](https://www.w3.org/TR/using-aria/#aria-does-nothing) and is redundant.

    ``` javascript
    <!-- A11y: Redundant role 'button' -->
    <button role="button" />

    <!-- A11y: Redundant role 'img' -->
    <img role="img" src="foo.jpg" />
    ```
- name: a11y-no-static-element-interactions
  id: accessibility-warnings#a11y-no-static-element-interactions
  summary: Elements like <div> with interactive handlers like click must have an ARIA role
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-no-static-element-interactions

    Elements like `<div>` with interactive handlers like `click` must have an ARIA role.

    ``` javascript
    <!-- A11y: <div> with click handler must have an ARIA role -->
    <div on:click={() => ''} />
    ```
- name: a11y-positive-tabindex
  id: accessibility-warnings#a11y-positive-tabindex
  summary: Avoid positive tabindex property values
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-positive-tabindex

    Avoid positive `tabindex` property values. This will move elements out of the expected tab order, creating a confusing experience for keyboard users.

    ``` javascript
    <!-- A11y: avoid tabindex values above zero -->
    <div tabindex="1" />
    ```
- name: a11y-role-has-required-aria-props
  id: accessibility-warnings#a11y-role-has-required-aria-props
  summary: Elements with ARIA roles must have all required attributes for that role
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-role-has-required-aria-props

    Elements with ARIA roles must have all required attributes for that role.

    ``` javascript
    <!-- A11y: A11y: Elements with the ARIA role "checkbox" must have the following attributes defined: "aria-checked" -->
    <span role="checkbox" aria-labelledby="foo" tabindex="0" />
    ```
- name: a11y-role-supports-aria-props
  id: accessibility-warnings#a11y-role-supports-aria-props
  summary: Elements with explicit or implicit roles defined contain only aria-* properties supported by that role
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-role-supports-aria-props

    Elements with explicit or implicit roles defined contain only `aria-*` properties supported by that role.

    ``` javascript
    <!-- A11y: The attribute 'aria-multiline' is not supported by the role 'link'. -->
    <div role="link" aria-multiline />

    <!-- A11y: The attribute 'aria-required' is not supported by the role 'listitem'. This role is implicit on the element <li>. -->
    <li aria-required />
    ```
- name: a11y-structure
  id: accessibility-warnings#a11y-structure
  summary: Enforce that certain DOM elements have the correct structure
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-structure

    Enforce that certain DOM elements have the correct structure.

    ``` javascript
    <!-- A11y: <figcaption> must be an immediate child of <figure> -->
    <div>
        <figcaption>Image caption</figcaption>
    </div>
    ```
- name: a11y-unknown-aria-attribute
  id: accessibility-warnings#a11y-unknown-aria-attribute
  summary: Enforce that only known ARIA attributes are used
  belongs_to: accessibility-warnings
  description: |-
    ## a11y-unknown-aria-attribute

    Enforce that only known ARIA attributes are used. This is based on the [WAI-ARIA States and Properties spec](https://www.w3.org/WAI/PF/aria-1.1/states_and_properties).

    ``` javascript
    <!-- A11y: Unknown aria attribute 'aria-labeledby' (did you mean 'labelledby'?) -->
    <input type="image" aria-labeledby="foo" />
    ```
- name: a11y-unknown-role
  id: accessibility-warnings#a11y-unknown-role
  summary: Elements with ARIA roles must use a valid, non-abstract ARIA role
  belongs_to: accessibility-warnings
  description: "## a11y-unknown-role\n\nElements with ARIA roles must use a valid, non-abstract ARIA role. A reference to role definitions can be found at [WAI-ARIA](https://www.w3.org/TR/wai-aria/#role_definitions) site.\n\n``` javascript\n<!-- A11y: Unknown role 'toooltip' (did you mean 'tooltip'?) -->\n<div role=\"toooltip\" />\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/accessibility-warnings](https://svelte.dev/docs/accessibility-warnings)"
- name: accessibility-warnings
  id: accessibility-warnings
  summary: Accessibility (shortened to a11y) isn't always easy to get right, but Svelte will help by warning you at compile time if you write inaccessible markup
  description: "# Accessibility warnings\n\nAccessibility (shortened to a11y) isn't always easy to get right, but Svelte will help by warning you at compile time if you write inaccessible markup. However, keep in mind that many accessibility issues can only be identified at runtime using other automated tools and by manually testing your application.\n\nSome warnings may be incorrect in your concrete use case. You can disable such false positives by placing a `<!-- svelte-ignore a11y-<code> -->` comment above the line that causes the warning. Example:\n\n``` javascript\n<!-- svelte-ignore a11y-autofocus -->\n<input autofocus />\n```\n\nHere is a list of accessibility checks Svelte will do for you.\n\n## a11y-accesskey\n\nEnforce no `accesskey` on element. Access keys are HTML attributes that allow web developers to assign keyboard shortcuts to elements. Inconsistencies between keyboard shortcuts and keyboard commands used by screen reader and keyboard-only users create accessibility complications. To avoid complications, access keys should not be used.\n\n``` javascript\n<!-- A11y: Avoid using accesskey -->\n<div accessKey=\"z\" />\n```\n\n## a11y-aria-activedescendant-has-tabindex\n\nAn element with `aria-activedescendant` must be tabbable, so it must either have an inherent `tabindex` or declare `tabindex` as an attribute.\n\n``` javascript\n<!-- A11y: Elements with attribute aria-activedescendant should have tabindex value -->\n<div aria-activedescendant=\"some-id\" />\n```\n\n## a11y-aria-attributes\n\nCertain reserved DOM elements do not support ARIA roles, states and properties. This is often because they are not visible, for example `meta`, `html`, `script`, `style`. This rule enforces that these DOM elements do not contain the `aria-*` props.\n\n``` javascript\n<!-- A11y: <meta> should not have aria-* attributes -->\n<meta aria-hidden=\"false\" />\n```\n\n## a11y-autofocus\n\nEnforce that `autofocus` is not used on elements. Autofocusing elements can cause usability issues for sighted and non-sighted users alike.\n\n``` javascript\n<!-- A11y: Avoid using autofocus -->\n<input autofocus />\n```\n\n## a11y-click-events-have-key-events\n\nEnforce `on:click` is accompanied by at least one of the following: `on:keyup`, `on:keydown`, `on:keypress`. Coding for the keyboard is important for users with physical disabilities who cannot use a mouse, AT compatibility, and screenreader users.\n\nThis does not apply for interactive or hidden elements.\n\n``` javascript\n<!-- A11y: visible, non-interactive elements with an on:click event must be accompanied by an on:keydown, on:keyup, or on:keypress event. -->\n<div on:click={() => {}} />\n```\n\nNote that the `keypress` event is now deprecated, so it is officially recommended to use either the `keyup` or `keydown` event instead, accordingly.\n\n## a11y-distracting-elements\n\nEnforces that no distracting elements are used. Elements that can be visually distracting can cause accessibility issues with visually impaired users. Such elements are most likely deprecated, and should be avoided.\n\nThe following elements are visually distracting: `<marquee>` and `<blink>`.\n\n``` javascript\n<!-- A11y: Avoid <marquee> elements -->\n<marquee />\n```\n\n## a11y-hidden\n\nCertain DOM elements are useful for screen reader navigation and should not be hidden.\n\n``` javascript\n<!-- A11y: <h2> element should not be hidden -->\n<h2 aria-hidden=\"true\">invisible header</h2>\n```\n\n## a11y-img-redundant-alt\n\nEnforce img alt attribute does not contain the word image, picture, or photo. Screen readers already announce `img` elements as an image. There is no need to use words such as *image*, *photo*, and/or *picture*.\n\n``` javascript\n<img src=\"foo\" alt=\"Foo eating a sandwich.\" />\n\n<!-- aria-hidden, won't be announced by screen reader -->\n<img src=\"bar\" aria-hidden=\"true\" alt=\"Picture of me taking a photo of an image\" />\n\n<!-- A11y: Screen readers already announce <img> elements as an image. -->\n<img src=\"foo\" alt=\"Photo of foo being weird.\" />\n\n<!-- A11y: Screen readers already announce <img> elements as an image. -->\n<img src=\"bar\" alt=\"Image of me at a bar!\" />\n\n<!-- A11y: Screen readers already announce <img> elements as an image. -->\n<img src=\"foo\" alt=\"Picture of baz fixing a bug.\" />\n```\n\n## a11y-incorrect-aria-attribute-type\n\nEnforce that only the correct type of value is used for aria attributes. For example, `aria-hidden` should only receive a boolean.\n\n``` javascript\n<!-- A11y: The value of 'aria-hidden' must be exactly one of true or false -->\n<div aria-hidden=\"yes\" />\n```\n\n## a11y-invalid-attribute\n\nEnforce that attributes important for accessibility have a valid value. For example, `href` should not be empty, `'#'`, or `javascript:`.\n\n``` javascript\n<!-- A11y: '' is not a valid href attribute -->\n<a href=\"\">invalid</a>\n```\n\n## a11y-interactive-supports-focus\n\nEnforce that elements with an interactive role and interactive handlers (mouse or key press) must be focusable or tabbable.\n\n``` javascript\n<!-- A11y: Elements with the 'button' interactive role must have a tabindex value. -->\n<div role=\"button\" on:keypress={() => {}} />\n```\n\n## a11y-label-has-associated-control\n\nEnforce that a label tag has a text label and an associated control.\n\nThere are two supported ways to associate a label with a control:\n\n- Wrapping a control in a label tag.\n- Adding `for` to a label and assigning it the ID of an input on the page.\n\n``` javascript\n<label for=\"id\">B</label>\n\n<label>C <input type=\"text\" /></label>\n\n<!-- A11y: A form label must be associated with a control. -->\n<label>A</label>\n```\n\n## a11y-media-has-caption\n\nProviding captions for media is essential for deaf users to follow along. Captions should be a transcription or translation of the dialogue, sound effects, relevant musical cues, and other relevant audio information. Not only is this important for accessibility, but can also be useful for all users in the case that the media is unavailable (similar to `alt` text on an image when an image is unable to load).\n\nThe captions should contain all important and relevant information to understand the corresponding media. This may mean that the captions are not a 1:1 mapping of the dialogue in the media content. However, captions are not necessary for video components with the `muted` attribute.\n\n``` javascript\n<video><track kind=\"captions\" /></video>\n\n<audio muted />\n\n<!-- A11y: Media elements must have a <track kind=\\\"captions\\\"> -->\n<video />\n\n<!-- A11y: Media elements must have a <track kind=\\\"captions\\\"> -->\n<video><track /></video>\n```\n\n## a11y-misplaced-role\n\nCertain reserved DOM elements do not support ARIA roles, states and properties. This is often because they are not visible, for example `meta`, `html`, `script`, `style`. This rule enforces that these DOM elements do not contain the `role` props.\n\n``` javascript\n<!-- A11y: <meta> should not have role attribute -->\n<meta role=\"tooltip\" />\n```\n\n## a11y-misplaced-scope\n\nThe scope attribute should only be used on `<th>` elements.\n\n``` javascript\n<!-- A11y: The scope attribute should only be used with <th> elements -->\n<div scope=\"row\" />\n```\n\n## a11y-missing-attribute\n\nEnforce that attributes required for accessibility are present on an element. This includes the following checks:\n\n- `<a>` should have an href (unless it's a [fragment-defining tag](https://github.com/sveltejs/svelte/issues/4697))\n- `<area>` should have alt, aria-label, or aria-labelledby\n- `<html>` should have lang\n- `<iframe>` should have title\n- `<img>` should have alt\n- `<object>` should have title, aria-label, or aria-labelledby\n- `<input type=\"image\">` should have alt, aria-label, or aria-labelledby\n\n``` javascript\n<!-- A11y: <input type=\\\"image\\\"> element should have an alt, aria-label or aria-labelledby attribute -->\n<input type=\"image\" />\n\n<!-- A11y: <html> element should have a lang attribute -->\n<html />\n\n<!-- A11y: <a> element should have an href attribute -->\n<a>text</a>\n```\n\n## a11y-missing-content\n\nEnforce that heading elements (`h1`, `h2`, etc.) and anchors have content and that the content is accessible to screen readers\n\n``` javascript\n<!-- A11y: <a> element should have child content -->\n<a href=\"/foo\" />\n\n<!-- A11y: <h1> element should have child content -->\n<h1 />\n```\n\n## a11y-mouse-events-have-key-events\n\nEnforce that `on:mouseover` and `on:mouseout` are accompanied by `on:focus` and `on:blur`, respectively. This helps to ensure that any functionality triggered by these mouse events is also accessible to keyboard users.\n\n``` javascript\n<!-- A11y: on:mouseover must be accompanied by on:focus -->\n<div on:mouseover={handleMouseover} />\n\n<!-- A11y: on:mouseout must be accompanied by on:blur -->\n<div on:mouseout={handleMouseout} />\n```\n\n## a11y-no-redundant-roles\n\nSome HTML elements have default ARIA roles. Giving these elements an ARIA role that is already set by the browser [has no effect](https://www.w3.org/TR/using-aria/#aria-does-nothing) and is redundant.\n\n``` javascript\n<!-- A11y: Redundant role 'button' -->\n<button role=\"button\" />\n\n<!-- A11y: Redundant role 'img' -->\n<img role=\"img\" src=\"foo.jpg\" />\n```\n\n## a11y-no-interactive-element-to-noninteractive-role\n\n[WAI-ARIA](https://www.w3.org/TR/wai-aria-1.1/#usage_intro) roles should not be used to convert an interactive element to a non-interactive element. Non-interactive ARIA roles include `article`, `banner`, `complementary`, `img`, `listitem`, `main`, `region` and `tooltip`.\n\n``` javascript\n<!-- A11y: <textarea> cannot have role 'listitem' -->\n<textarea role=\"listitem\" />\n```\n\n### a11y-no-noninteractive-element-interactions\n\nA non-interactive element does not support event handlers (mouse and key handlers). Non-interactive elements include `<main>`, `<area>`, `<h1>` (,`<h2>`, etc), `<p>`, `<img>`, `<li>`, `<ul>` and `<ol>`. Non-interactive [WAI-ARIA roles](https://www.w3.org/TR/wai-aria-1.1/#usage_intro) include `article`, `banner`, `complementary`, `img`, `listitem`, `main`, `region` and `tooltip`.\n\n``` javascript\n<!-- `A11y: Non-interactive element <li> should not be assigned mouse or keyboard event listeners.` -->\n<li on:click={() => {}} />\n\n<!-- `A11y: Non-interactive element <div> should not be assigned mouse or keyboard event listeners.` -->\n<div role=\"listitem\" on:click={() => {}} />\n```\n\n### a11y-no-noninteractive-element-to-interactive-role\n\n[WAI-ARIA](https://www.w3.org/TR/wai-aria-1.1/#usage_intro) roles should not be used to convert a non-interactive element to an interactive element. Interactive ARIA roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`, `menuitemradio`, `option`, `radio`, `searchbox`, `switch` and `textbox`.\n\n``` javascript\n<!-- A11y: Non-interactive element <h3> cannot have interactive role 'searchbox' -->\n<h3 role=\"searchbox\">Button</h3>\n```\n\n## a11y-no-noninteractive-tabindex\n\nTab key navigation should be limited to elements on the page that can be interacted with.\n\n``` javascript\n<!-- A11y: noninteractive element cannot have nonnegative tabIndex value -->\n<div tabindex=\"0\" />\n```\n\n## a11y-no-static-element-interactions\n\nElements like `<div>` with interactive handlers like `click` must have an ARIA role.\n\n``` javascript\n<!-- A11y: <div> with click handler must have an ARIA role -->\n<div on:click={() => ''} />\n```\n\n## a11y-positive-tabindex\n\nAvoid positive `tabindex` property values. This will move elements out of the expected tab order, creating a confusing experience for keyboard users.\n\n``` javascript\n<!-- A11y: avoid tabindex values above zero -->\n<div tabindex=\"1\" />\n```\n\n## a11y-role-has-required-aria-props\n\nElements with ARIA roles must have all required attributes for that role.\n\n``` javascript\n<!-- A11y: A11y: Elements with the ARIA role \"checkbox\" must have the following attributes defined: \"aria-checked\" -->\n<span role=\"checkbox\" aria-labelledby=\"foo\" tabindex=\"0\" />\n```\n\n## a11y-role-supports-aria-props\n\nElements with explicit or implicit roles defined contain only `aria-*` properties supported by that role.\n\n``` javascript\n<!-- A11y: The attribute 'aria-multiline' is not supported by the role 'link'. -->\n<div role=\"link\" aria-multiline />\n\n<!-- A11y: The attribute 'aria-required' is not supported by the role 'listitem'. This role is implicit on the element <li>. -->\n<li aria-required />\n```\n\n## a11y-structure\n\nEnforce that certain DOM elements have the correct structure.\n\n``` javascript\n<!-- A11y: <figcaption> must be an immediate child of <figure> -->\n<div>\n    <figcaption>Image caption</figcaption>\n</div>\n```\n\n## a11y-unknown-aria-attribute\n\nEnforce that only known ARIA attributes are used. This is based on the [WAI-ARIA States and Properties spec](https://www.w3.org/WAI/PF/aria-1.1/states_and_properties).\n\n``` javascript\n<!-- A11y: Unknown aria attribute 'aria-labeledby' (did you mean 'labelledby'?) -->\n<input type=\"image\" aria-labeledby=\"foo\" />\n```\n\n## a11y-unknown-role\n\nElements with ARIA roles must use a valid, non-abstract ARIA role. A reference to role definitions can be found at [WAI-ARIA](https://www.w3.org/TR/wai-aria/#role_definitions) site.\n\n``` javascript\n<!-- A11y: Unknown role 'toooltip' (did you mean 'tooltip'?) -->\n<div role=\"toooltip\" />\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/accessibility-warnings](https://svelte.dev/docs/accessibility-warnings)"
- name: Action
  id: svelte-action#types-action
  summary: Actions are functions that are called when an element is created
  belongs_to: svelte-action
  description: |-
    ### Action

    Actions are functions that are called when an element is created. You can use this interface to type such actions. The following example defines an action that only works on `<div>` elements and optionally accepts a parameter which it has a default value for:

    ``` javascript
    export const myAction: Action<HTMLDivElement, { someProperty: boolean } | undefined> = (node, param = { someProperty: true }) => {
      // ...
    }
    ```

    [`Action`](svelte-action#types-action)`<HTMLDivElement>` and [`Action`](svelte-action#types-action)`<HTMLDivElement, undefined>` both signal that the action accepts no parameters.

    You can return an object with methods `update` and `destroy` from the function and type which additional attributes and events it has. See interface [`ActionReturn`](svelte-action#types-actionreturn) for more details.

    Docs: [https://svelte.dev/docs/svelte-action](svelte-action)

    ``` javascript
    interface Action<
        Element = HTMLElement,
        Parameter = undefined,
        Attributes extends Record<string, any> = Record<
            never,
            any
        >
    > {…}
    ```

    ``` javascript
    <Node extends Element>(
        ...args: undefined extends Parameter
            ? [node: Node, parameter?: Parameter]
            : [node: Node, parameter: Parameter]
    ): void | ActionReturn<Parameter, Attributes>;
    ```
- name: ActionReturn
  id: svelte-action#types-actionreturn
  summary: Actions can return an object containing the two properties defined in this interface
  belongs_to: svelte-action
  description: "### ActionReturn\n\nActions can return an object containing the two properties defined in this interface. Both are optional.\n\n- update: An action can have a parameter. This method will be called whenever that parameter changes, immediately after Svelte has applied updates to the markup. [`ActionReturn`](svelte-action#types-actionreturn) and [`ActionReturn`](svelte-action#types-actionreturn)`<undefined>` both mean that the action accepts no parameters.\n- destroy: Method that is called after the element is unmounted\n\nAdditionally, you can specify which additional attributes and events the action enables on the applied element. This applies to TypeScript typings only and has no effect at runtime.\n\nExample usage:\n\n``` javascript\ninterface Attributes {\n    newprop?: string;\n    'on:event': (e: CustomEvent<boolean>) => void;\n}\n\n\nexport function myAction(node: HTMLElement, parameter: Parameter): ActionReturn<Parameter, Attributes> {\n    // ...\n    return {\n        update: (updatedParameter) => {...},\n        destroy: () => {...}\n    };\n}\n```\n\nDocs: [https://svelte.dev/docs/svelte-action](svelte-action)\n\n``` javascript\ninterface ActionReturn<\n    Parameter = undefined,\n    Attributes extends Record<string, any> = Record<\n        never,\n        any\n    >\n> {…}\n```\n\n``` javascript\nupdate?: (parameter: Parameter) => void;\n```\n\n``` javascript\ndestroy?: () => void;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-action](https://svelte.dev/docs/svelte-action)"
- name: afterUpdate
  id: svelte#afterupdate
  summary: Schedules a callback to run immediately after the component has been updated
  belongs_to: svelte
  description: |-
    ## afterUpdate

    ``` javascript
    function afterUpdate(fn: () => any): void;
    ```

    Schedules a callback to run immediately after the component has been updated.

    > The first time the callback runs will be after the initial `onMount`

    ``` javascript
    <script>
        import { afterUpdate } from 'svelte';

        afterUpdate(() => {
            console.log('the component just updated');
        });
    </script>
    ```
- name: Alternatives to SvelteKit
  id: index#start-a-new-project-alternatives-to-sveltekit
  summary: If you don't want to use SvelteKit for some reason, you can also use Svelte with Vite (but without SvelteKit) by running npm create vite@latest and selecting the svelte option
  description: |-
    ### Alternatives to SvelteKit

    If you don't want to use SvelteKit for some reason, you can also use Svelte with Vite (but without SvelteKit) by running `npm create vite@latest` and selecting the `svelte` option. With this, `npm run build` will generate HTML, JS and CSS files inside the `dist` directory. In most cases, you will probably need to [choose a routing library](https://svelte.dev/faq#is-there-a-router) as well.

    Alternatively, there are [plugins for all the major web bundlers](https://sveltesociety.dev/tools#bundling) to handle Svelte compilation — which will output `.js` and `.css` that you can insert into your HTML — but most others won't handle SSR.
- name: animate:fn
  id: element-directives#animate-fn
  summary: An animation is triggered when the contents of a keyed each block are re-ordered
  belongs_to: element-directives
  description: |-
    ## animate:*fn*

    ``` javascript
    animate:name
    ```

    ``` javascript
    animate:name={params}
    ```

    ``` javascript
    animation = (node: HTMLElement, { from: DOMRect, to: DOMRect } , params: any) => {
        delay?: number,
        duration?: number,
        easing?: (t: number) => number,
        css?: (t: number, u: number) => string,
        tick?: (t: number, u: number) => void
    }
    ```

    ``` javascript
    DOMRect {
        bottom: number,
        height: number,
        ​​left: number,
        right: number,
        ​top: number,
        width: number,
        x: number,
        y: number
    }
    ```

    An animation is triggered when the contents of a [keyed each block](logic-blocks#each) are re-ordered. Animations do not run when an element is added or removed, only when the index of an existing data item within the each block changes. Animate directives must be on an element that is an *immediate* child of a keyed each block.

    Animations can be used with Svelte's [built-in animation functions](svelte-animate) or [custom animation functions](element-directives#custom-animation-functions).

    ``` javascript
    <!-- When `list` is reordered the animation will run-->
    {#each list as item, index (item)}
        <li animate:flip>{item}</li>
    {/each}
    ```
- name: Animation Parameters
  id: element-directives#animation-parameters
  summary: As with actions and transitions, animations can have parameters
  belongs_to: element-directives
  description: |-
    ## Animation Parameters

    As with actions and transitions, animations can have parameters.

    (The double `{{curlies}}` aren't a special syntax; this is an object literal inside an expression tag.)

    ``` javascript
    {#each list as item, index (item)}
        <li animate:flip={{ delay: 500 }}>{item}</li>
    {/each}
    ```
- name: AnimationConfig
  id: svelte-animate#types-animationconfig
  summary: null
  belongs_to: svelte-animate
  description: |-
    ### AnimationConfig

    ``` javascript
    interface AnimationConfig {…}
    ```

    ``` javascript
    delay?: number;
    ```

    ``` javascript
    duration?: number;
    ```

    ``` javascript
    easing?: (t: number) => number;
    ```

    ``` javascript
    css?: (t: number, u: number) => string;
    ```

    ``` javascript
    tick?: (t: number, u: number) => void;
    ```
- name: Are there any third-party resources?
  id: faq#are-there-any-third-party-resources
  summary: Svelte Society maintains a list of books and videos
  belongs_to: faq
  description: |-
    ## Are there any third-party resources?

    Svelte Society maintains a [list of books and videos](https://sveltesociety.dev/resources).
- name: Attributes
  id: svelte-action#attributes
  summary: Sometimes actions emit custom events and apply custom attributes to the element they are applied to
  belongs_to: svelte-action
  description: |-
    ## Attributes

    Sometimes actions emit custom events and apply custom attributes to the element they are applied to. To support this, actions typed with [`Action`](svelte-action#types-action) or [`ActionReturn`](svelte-action#types-actionreturn) type can have a last parameter, `Attributes`:

    ``` javascript
    <script>
        /**
         * @type {import('svelte/action').Action<HTMLDivElement, { prop: any }, { 'on:emit': (e: CustomEvent<string>) => void }>}
         */
        function foo(node, { prop }) {
            // the node has been mounted in the DOM

            //...LOGIC
            node.dispatchEvent(new CustomEvent('emit', { detail: 'hello' }));

            return {
                destroy() {
                    // the node has been removed from the DOM
                }
            };
        }
    </script>

    <div use:foo={{ prop: 'someValue' }} on:emit={handleEmit} />
    ```
- name: Attributes and props
  id: basic-markup#attributes-and-props
  summary: By default, attributes work exactly like their HTML counterparts
  belongs_to: basic-markup
  description: |-
    ## Attributes and props

    By default, attributes work exactly like their HTML counterparts.

    ``` javascript
    <div class="foo">
        <button disabled>can't touch this</button>
    </div>
    ```

    As in HTML, values may be unquoted.

    ``` javascript
    <input type=checkbox />
    ```

    Attribute values can contain JavaScript expressions.

    ``` javascript
    <a href="page/{p}">page {p}</a>
    ```

    Or they can *be* JavaScript expressions.

    ``` javascript
    <button disabled={!clickable}>...</button>
    ```

    Boolean attributes are included on the element if their value is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) and excluded if it's [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy).

    All other attributes are included unless their value is [nullish](https://developer.mozilla.org/en-US/docs/Glossary/Nullish) (`null` or `undefined`).

    ``` javascript
    <input required={false} placeholder="This input field is not required" />
    <div title={null}>This div has no title attribute</div>
    ```

    An expression might include characters that would cause syntax highlighting to fail in regular HTML, so quoting the value is permitted. The quotes do not affect how the value is parsed:

    ``` javascript
    <button disabled="{number !== 42}">...</button>
    ```

    When the attribute name and value match (`name={name}`), they can be replaced with `{name}`.

    ``` javascript
    <button {disabled}>...</button>
    <!-- equivalent to
    <button disabled={disabled}>...</button>
    -->
    ```

    By convention, values passed to components are referred to as *properties* or *props* rather than *attributes*, which are a feature of the DOM.

    As with elements, `name={name}` can be replaced with the `{name}` shorthand.

    ``` javascript
    <Widget foo={bar} answer={42} text="hello" />
    ```

    *Spread attributes* allow many attributes or properties to be passed to an element or component at once.

    An element or component can have multiple spread attributes, interspersed with regular ones.

    ``` javascript
    <Widget {...things} />
    ```

    `$$props` references all props that are passed to a component, including ones that are not declared with `export`. Using `$$props` will not perform as well as references to a specific prop because changes to any prop will cause Svelte to recheck all usages of `$$props`. But it can be useful in some cases – for example, when you don't know at compile time what props might be passed to a component.

    ``` javascript
    <Widget {...$$props} />
    ```

    `$$restProps` contains only the props which are *not* declared with `export`. It can be used to pass down other unknown attributes to an element in a component. It shares the same performance characteristics compared to specific property access as `$$props`.

    ``` javascript
    <input {...$$restProps} />
    ```

    > The `value` attribute of an `input` element or its children `option` elements must not be set with spread attributes when using `bind:group` or `bind:checked`. Svelte needs to be able to see the element's `value` directly in the markup in these cases so that it can link it to the bound variable.

    > Sometimes, the attribute order matters as Svelte sets attributes sequentially in JavaScript. For example, `<input type="range" min="0" max="1" value={0.5} step="0.1"/>`, Svelte will attempt to set the value to `1` (rounding up from 0.5 as the step by default is 1), and then set the step to `0.1`. To fix this, change it to `<input type="range" min="0" max="1" step="0.1" value={0.5}/>`.

    > Another example is `<img src="..." loading="lazy" />`. Svelte will set the img `src` before making the img element `loading="lazy"`, which is probably too late. Change this to `<img loading="lazy" src="...">` to make the image lazily loaded.
- name: basic-markup
  id: basic-markup
  summary: A lowercase tag, like <div>, denotes a regular HTML element
  description: "# Basic markup\n\n## Tags\n\nA lowercase tag, like `<div>`, denotes a regular HTML element. A capitalised tag, such as `<Widget>` or `<Namespace.Widget>`, indicates a *component*.\n\n``` javascript\n<script>\n    import Widget from './Widget.svelte';\n</script>\n\n<div>\n    <Widget />\n</div>\n```\n\n## Attributes and props\n\nBy default, attributes work exactly like their HTML counterparts.\n\n``` javascript\n<div class=\"foo\">\n    <button disabled>can't touch this</button>\n</div>\n```\n\nAs in HTML, values may be unquoted.\n\n``` javascript\n<input type=checkbox />\n```\n\nAttribute values can contain JavaScript expressions.\n\n``` javascript\n<a href=\"page/{p}\">page {p}</a>\n```\n\nOr they can *be* JavaScript expressions.\n\n``` javascript\n<button disabled={!clickable}>...</button>\n```\n\nBoolean attributes are included on the element if their value is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) and excluded if it's [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy).\n\nAll other attributes are included unless their value is [nullish](https://developer.mozilla.org/en-US/docs/Glossary/Nullish) (`null` or `undefined`).\n\n``` javascript\n<input required={false} placeholder=\"This input field is not required\" />\n<div title={null}>This div has no title attribute</div>\n```\n\nAn expression might include characters that would cause syntax highlighting to fail in regular HTML, so quoting the value is permitted. The quotes do not affect how the value is parsed:\n\n``` javascript\n<button disabled=\"{number !== 42}\">...</button>\n```\n\nWhen the attribute name and value match (`name={name}`), they can be replaced with `{name}`.\n\n``` javascript\n<button {disabled}>...</button>\n<!-- equivalent to\n<button disabled={disabled}>...</button>\n-->\n```\n\nBy convention, values passed to components are referred to as *properties* or *props* rather than *attributes*, which are a feature of the DOM.\n\nAs with elements, `name={name}` can be replaced with the `{name}` shorthand.\n\n``` javascript\n<Widget foo={bar} answer={42} text=\"hello\" />\n```\n\n*Spread attributes* allow many attributes or properties to be passed to an element or component at once.\n\nAn element or component can have multiple spread attributes, interspersed with regular ones.\n\n``` javascript\n<Widget {...things} />\n```\n\n`$$props` references all props that are passed to a component, including ones that are not declared with `export`. Using `$$props` will not perform as well as references to a specific prop because changes to any prop will cause Svelte to recheck all usages of `$$props`. But it can be useful in some cases – for example, when you don't know at compile time what props might be passed to a component.\n\n``` javascript\n<Widget {...$$props} />\n```\n\n`$$restProps` contains only the props which are *not* declared with `export`. It can be used to pass down other unknown attributes to an element in a component. It shares the same performance characteristics compared to specific property access as `$$props`.\n\n``` javascript\n<input {...$$restProps} />\n```\n\n> The `value` attribute of an `input` element or its children `option` elements must not be set with spread attributes when using `bind:group` or `bind:checked`. Svelte needs to be able to see the element's `value` directly in the markup in these cases so that it can link it to the bound variable.\n\n> Sometimes, the attribute order matters as Svelte sets attributes sequentially in JavaScript. For example, `<input type=\"range\" min=\"0\" max=\"1\" value={0.5} step=\"0.1\"/>`, Svelte will attempt to set the value to `1` (rounding up from 0.5 as the step by default is 1), and then set the step to `0.1`. To fix this, change it to `<input type=\"range\" min=\"0\" max=\"1\" step=\"0.1\" value={0.5}/>`.\n\n> Another example is `<img src=\"...\" loading=\"lazy\" />`. Svelte will set the img `src` before making the img element `loading=\"lazy\"`, which is probably too late. Change this to `<img loading=\"lazy\" src=\"...\">` to make the image lazily loaded.\n\n## Text expressions\n\nA JavaScript expression can be included as text by surrounding it with curly braces.\n\n``` javascript\n{expression}\n```\n\nCurly braces can be included in a Svelte template by using their [HTML entity](https://developer.mozilla.org/docs/Glossary/Entity) strings: `&lbrace;`, `&lcub;`, or `&#123;` for `{` and `&rbrace;`, `&rcub;`, or `&#125;` for `}`.\n\n> If you're using a regular expression (`RegExp`) [literal notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#literal_notation_and_constructor), you'll need to wrap it in parentheses.\n\n``` javascript\n<h1>Hello {name}!</h1>\n<p>{a} + {b} = {a + b}.</p>\n\n<div>{(/^[A-Za-z ]+$/).test(value) ? x : y}</div>\n```\n\n## Comments\n\nYou can use HTML comments inside components.\n\n``` javascript\n<!-- this is a comment! --><h1>Hello world</h1>\n```\n\nComments beginning with `svelte-ignore` disable warnings for the next block of markup. Usually, these are accessibility warnings; make sure that you're disabling them for a good reason.\n\n``` javascript\n<!-- svelte-ignore a11y-autofocus -->\n<input bind:value={name} autofocus />\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/basic-markup](https://svelte.dev/docs/basic-markup)"
- name: beforeUpdate
  id: svelte#beforeupdate
  summary: Schedules a callback to run immediately before the component is updated after any state change
  belongs_to: svelte
  description: |-
    ## beforeUpdate

    ``` javascript
    function beforeUpdate(fn: () => any): void;
    ```

    Schedules a callback to run immediately before the component is updated after any state change.

    > The first time the callback runs will be before the initial `onMount`

    ``` javascript
    <script>
        import { beforeUpdate } from 'svelte';

        beforeUpdate(() => {
            console.log('the component is about to update');
        });
    </script>
    ```
- name: bind:group
  id: element-directives#bind-group
  summary: Inputs that work together can use bind:group
  belongs_to: element-directives
  description: |-
    ## bind:group

    ``` javascript
    bind:group={variable}
    ```

    Inputs that work together can use `bind:group`.

    ``` javascript
    <script>
        let tortilla = 'Plain';

        /** @type {Array<string>} */
        let fillings = [];
    </script>

    <!-- grouped radio inputs are mutually exclusive -->
    <input type="radio" bind:group={tortilla} value="Plain" />
    <input type="radio" bind:group={tortilla} value="Whole wheat" />
    <input type="radio" bind:group={tortilla} value="Spinach" />

    <!-- grouped checkbox inputs populate an array -->
    <input type="checkbox" bind:group={fillings} value="Rice" />
    <input type="checkbox" bind:group={fillings} value="Beans" />
    <input type="checkbox" bind:group={fillings} value="Cheese" />
    <input type="checkbox" bind:group={fillings} value="Guac (extra)" />
    ```

    > `bind:group` only works if the inputs are in the same Svelte component.
- name: bind:property
  id: element-directives#bind-property
  summary: Data ordinarily flows down, from parent to child
  belongs_to: element-directives
  description: |-
    ## bind:*property*

    ``` javascript
    bind:property={variable}
    ```

    Data ordinarily flows down, from parent to child. The `bind:` directive allows data to flow the other way, from child to parent. Most bindings are specific to particular elements.

    The simplest bindings reflect the value of a property, such as `input.value`.

    ``` javascript
    <input bind:value={name} />
    <textarea bind:value={text} />

    <input type="checkbox" bind:checked={yes} />
    ```

    If the name matches the value, you can use a shorthand.

    ``` javascript
    <input bind:value />
    <!-- equivalent to
    <input bind:value={value} />
    -->
    ```

    Numeric input values are coerced; even though `input.value` is a string as far as the DOM is concerned, Svelte will treat it as a number. If the input is empty or invalid (in the case of `type="number"`), the value is `undefined`.

    ``` javascript
    <input type="number" bind:value={num} />
    <input type="range" bind:value={num} />
    ```

    On `<input>` elements with `type="file"`, you can use `bind:files` to get the [`FileList` of selected files](https://developer.mozilla.org/en-US/docs/Web/API/FileList). It is readonly.

    ``` javascript
    <label for="avatar">Upload a picture:</label>
    <input accept="image/png, image/jpeg" bind:files id="avatar" name="avatar" type="file" />
    ```

    If you're using `bind:` directives together with `on:` directives, the order that they're defined in affects the value of the bound variable when the event handler is called.

    ``` javascript
    <script>
        let value = 'Hello World';
    </script>

    <input
        on:input={() => console.log('Old value:', value)}
        bind:value
        on:input={() => console.log('New value:', value)}
    />
    ```

    Here we were binding to the value of a text input, which uses the `input` event. Bindings on other elements may use different events such as `change`.
- name: bind:property
  id: component-directives#bind-property
  summary: You can bind to component props using the same syntax as for elements
  belongs_to: component-directives
  description: |-
    ## bind:*property*

    ``` javascript
    bind:property={variable}
    ```

    You can bind to component props using the same syntax as for elements.

    ``` javascript
    <Keypad bind:value={pin} />
    ```

    While Svelte props are reactive without binding, that reactivity only flows downward into the component by default. Using `bind:property` allows changes to the property from within the component to flow back up out of the component.
- name: bind:this
  id: element-directives#bind-this
  summary: To get a reference to a DOM node, use bind:this
  belongs_to: element-directives
  description: |-
    ## bind:this

    ``` javascript
    bind:this={dom_node}
    ```

    To get a reference to a DOM node, use `bind:this`.

    ``` javascript
    <script>
        import { onMount } from 'svelte';

        /** @type {HTMLCanvasElement} */
        let canvasElement;

        onMount(() => {
            const ctx = canvasElement.getContext('2d');
            drawStuff(ctx);
        });
    </script>

    <canvas bind:this={canvasElement} />
    ```
- name: bind:this
  id: component-directives#bind-this
  summary: Components also support bind:this, allowing you to interact with component instances programmatically
  belongs_to: component-directives
  description: "## bind:this\n\n``` javascript\nbind:this={component_instance}\n```\n\nComponents also support `bind:this`, allowing you to interact with component instances programmatically.\n\n``` javascript\n<ShoppingCart bind:this={cart} />\n\n<button on:click={() => cart.empty()}> Empty shopping cart </button>\n```\n\n> Note that we can't do `{cart.empty}` since `cart` is `undefined` when the button is first rendered and throws an error.\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/component-directives](https://svelte.dev/docs/component-directives)"
- name: Binding <select> value
  id: element-directives#binding-select-value
  summary: A <select> value binding corresponds to the value property on the selected <option>, which can be any value (not just strings, as is normally the case in the DOM)
  belongs_to: element-directives
  description: |-
    ## Binding \<select\> value

    A `<select>` value binding corresponds to the `value` property on the selected `<option>`, which can be any value (not just strings, as is normally the case in the DOM).

    ``` javascript
    <select bind:value={selected}>
        <option value={a}>a</option>
        <option value={b}>b</option>
        <option value={c}>c</option>
    </select>
    ```

    A `<select multiple>` element behaves similarly to a checkbox group. The bound variable is an array with an entry corresponding to the `value` property of each selected `<option>`.

    ``` javascript
    <select multiple bind:value={fillings}>
        <option value="Rice">Rice</option>
        <option value="Beans">Beans</option>
        <option value="Cheese">Cheese</option>
        <option value="Guac (extra)">Guac (extra)</option>
    </select>
    ```

    When the value of an `<option>` matches its text content, the attribute can be omitted.

    ``` javascript
    <select multiple bind:value={fillings}>
        <option>Rice</option>
        <option>Beans</option>
        <option>Cheese</option>
        <option>Guac (extra)</option>
    </select>
    ```

    Elements with the `contenteditable` attribute support the following bindings:

    - [`innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)
    - [`innerText`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText)
    - [`textContent`](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent)

    There are slight differences between each of these, read more about them [here](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#Differences_from_innerText).

    ``` javascript
    <div contenteditable="true" bind:innerHTML={html} />
    ```

    `<details>` elements support binding to the `open` property.

    ``` javascript
    <details bind:open={isOpen}>
        <summary>Details</summary>
        <p>Something small enough to escape casual notice.</p>
    </details>
    ```
- name: Block-level element bindings
  id: element-directives#block-level-element-bindings
  summary: null
  belongs_to: element-directives
  description: |-
    ## Block-level element bindings

    Block-level elements have 4 read-only bindings, measured using a technique similar to [this one](http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/):

    - `clientWidth`
    - `clientHeight`
    - `offsetWidth`
    - `offsetHeight`

    ``` javascript
    <div bind:offsetWidth={width} bind:offsetHeight={height}>
        <Chart {width} {height} />
    </div>
    ```
- name: blur
  id: svelte-transition#blur
  summary: Animates a blur filter alongside an element's opacity
  belongs_to: svelte-transition
  description: |-
    ## blur

    ``` javascript
    function blur(
        node: Element,
        {
            delay,
            duration,
            easing,
            amount,
            opacity
        }?: BlurParams | undefined
    ): TransitionConfig;
    ```

    ``` javascript
    transition:blur={params}
    ```

    ``` javascript
    in:blur={params}
    ```

    ``` javascript
    out:blur={params}
    ```

    Animates a `blur` filter alongside an element's opacity.

    `blur` accepts the following parameters:

    - `delay` (`number`, default 0) — milliseconds before starting
    - `duration` (`number`, default 400) — milliseconds the transition lasts
    - `easing` (`function`, default `cubicInOut`) — an [easing function](svelte-easing)
    - `opacity` (`number`, default 0) - the opacity value to animate out to and in from
    - `amount` (`number | string`, default 5) - the size of the blur. Supports css units (for example: `"4rem"`). The default unit is `px`

    ``` javascript
    <script>
        import { blur } from 'svelte/transition';
    </script>

    {#if condition}
        <div transition:blur={{ amount: 10 }}>fades in and out</div>
    {/if}
    ```
- name: BlurParams
  id: svelte-transition#types-blurparams
  summary: null
  belongs_to: svelte-transition
  description: |-
    ### BlurParams

    ``` javascript
    interface BlurParams {…}
    ```

    ``` javascript
    delay?: number;
    ```

    ``` javascript
    duration?: number;
    ```

    ``` javascript
    easing?: EasingFunction;
    ```

    ``` javascript
    amount?: number | string;
    ```

    ``` javascript
    opacity?: number;
    ```
- name: Browser conditions for bundlers
  id: v4-migration-guide#browser-conditions-for-bundlers
  summary: Bundlers must now specify the browser condition when building a frontend bundle for the browser
  belongs_to: v4-migration-guide
  description: |-
    ## Browser conditions for bundlers

    Bundlers must now specify the `browser` condition when building a frontend bundle for the browser. SvelteKit and Vite will handle this automatically for you. If you're using any others, you may observe lifecycle callbacks such as `onMount` not get called and you'll need to update the module resolution configuration.

    - For Rollup this is done within the `@rollup/plugin-node-resolve` plugin by setting `browser: true` in its options. See the [`rollup-plugin-svelte`](https://github.com/sveltejs/rollup-plugin-svelte/#usage) documentation for more details
    - For wepback this is done by adding `"browser"` to the `conditionNames` array. You may also have to update your `alias` config, if you have set it. See the [`svelte-loader`](https://github.com/sveltejs/svelte-loader#usage) documentation for more details

    ([\#8516](https://github.com/sveltejs/svelte/issues/8516))
- name: Can I tell Svelte not to remove my unused styles?
  id: faq#can-i-tell-svelte-not-to-remove-my-unused-styles
  summary: No
  belongs_to: faq
  description: |-
    ## Can I tell Svelte not to remove my unused styles?

    No. Svelte removes the styles from the component and warns you about them in order to prevent issues that would otherwise arise.

    Svelte's component style scoping works by generating a class unique to the given component, adding it to the relevant elements in the component that are under Svelte's control, and then adding it to each of the selectors in that component's styles. When the compiler can't see what elements a style selector applies to, there would be two bad options for keeping it:

    - If it keeps the selector and adds the scoping class to it, the selector will likely not match the expected elements in the component, and they definitely won't if they were created by a child component or `{@html ...}`.
    - If it keeps the selector without adding the scoping class to it, the given style will become a global style, affecting your entire page.

    If you need to style something that Svelte can't identify at compile time, you will need to explicitly opt into global styles by using `:global(...)`. But also keep in mind that you can wrap `:global(...)` around only part of a selector. `.foo :global(.bar) { ... }` will style any `.bar` elements that appear within the component's `.foo` elements. As long as there's some parent element in the current component to start from, partially global selectors like this will almost always be able to get you what you want.
- name: Caveats and limitations
  id: custom-elements-api#caveats-and-limitations
  summary: Custom elements can be a useful way to package components for consumption in a non-Svelte app, as they will work with vanilla HTML and JavaScript as well as most frameworks
  belongs_to: custom-elements-api
  description: "## Caveats and limitations\n\nCustom elements can be a useful way to package components for consumption in a non-Svelte app, as they will work with vanilla HTML and JavaScript as well as [most frameworks](https://custom-elements-everywhere.com/). There are, however, some important differences to be aware of:\n\n- Styles are *encapsulated*, rather than merely *scoped* (unless you set `shadow: \"none\"`). This means that any non-component styles (such as you might have in a `global.css` file) will not apply to the custom element, including styles with the `:global(...)` modifier\n- Instead of being extracted out as a separate .css file, styles are inlined into the component as a JavaScript string\n- Custom elements are not generally suitable for server-side rendering, as the shadow DOM is invisible until JavaScript loads\n- In Svelte, slotted content renders *lazily*. In the DOM, it renders *eagerly*. In other words, it will always be created even if the component's `<slot>` element is inside an `{#if ...}` block. Similarly, including a `<slot>` in an `{#each ...}` block will not cause the slotted content to be rendered multiple times\n- The `let:` directive has no effect, because custom elements do not have a way to pass data to the parent component that fills the slot\n- Polyfills are required to support older browsers\n- You can use Svelte's context feature between regular Svelte components within a custom element, but you can't use them across custom elements. In other words, you can't use `setContext` on a parent custom element and read that with `getContext` in a child custom element.\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/custom-elements-api](https://svelte.dev/docs/custom-elements-api)"
- name: class:name
  id: element-directives#class-name
  summary: 'A class: directive provides a shorter way of toggling a class on an element'
  belongs_to: element-directives
  description: |-
    ## class:*name*

    ``` javascript
    class:name={value}
    ```

    ``` javascript
    class:name
    ```

    A `class:` directive provides a shorter way of toggling a class on an element.

    ``` javascript
    <!-- These are equivalent -->
    <div class={isActive ? 'active' : ''}>...</div>
    <div class:active={isActive}>...</div>

    <!-- Shorthand, for when name and value match -->
    <div class:active>...</div>

    <!-- Multiple class toggles can be included -->
    <div class:active class:inactive={!active} class:isAdmin>...</div>
    ```
- name: client-side-component-api
  id: client-side-component-api
  summary: 'A client-side component — that is, a component compiled with generate: ''dom'' (or the generate option left unspecified) is a JavaScript class'
  description: "# Client-side component API\n\n## Creating a component\n\n``` javascript\nconst component = new Component(options);\n```\n\nA client-side component — that is, a component compiled with `generate: 'dom'` (or the `generate` option left unspecified) is a JavaScript class.\n\n``` javascript\nimport App from './App.svelte';\n\n\nconst app = new App({\n    target: document.body,\n    props: {\n        // assuming App.svelte contains something like\n        // `export let answer`:\n        answer: 42\n    }\n});\n```\n\nThe following initialisation options can be provided:\n\n| option    | default     | description                                                                                          |\n|-----------|-------------|------------------------------------------------------------------------------------------------------|\n| `target`  | **none**    | An `HTMLElement` or `ShadowRoot` to render to. This option is required                               |\n| `anchor`  | `null`      | A child of `target` to render the component immediately before                                       |\n| `props`   | `{}`        | An object of properties to supply to the component                                                   |\n| `context` | `new Map()` | A `Map` of root-level context key-value pairs to supply to the component                             |\n| `hydrate` | `false`     | See below                                                                                            |\n| `intro`   | `false`     | If `true`, will play transitions on initial render, rather than waiting for subsequent state changes |\n\nExisting children of `target` are left where they are.\n\nThe `hydrate` option instructs Svelte to upgrade existing DOM (usually from server-side rendering) rather than creating new elements. It will only work if the component was compiled with the [`hydratable: true` option](svelte-compiler#compile). Hydration of `<head>` elements only works properly if the server-side rendering code was also compiled with `hydratable: true`, which adds a marker to each element in the `<head>` so that the component knows which elements it's responsible for removing during hydration.\n\nWhereas children of `target` are normally left alone, `hydrate: true` will cause any children to be removed. For that reason, the `anchor` option cannot be used alongside `hydrate: true`.\n\nThe existing DOM doesn't need to match the component — Svelte will 'repair' the DOM as it goes.\n\nindex.js\n\n``` javascript\nimport App from './App.svelte';\n\n\nconst app = new App({\n    target: document.querySelector('#server-rendered-html'),\n    hydrate: true\n});\n```\n\n## $set\n\n``` javascript\ncomponent.$set(props);\n```\n\nProgrammatically sets props on an instance. `component.$set({ x: 1 })` is equivalent to `x = 1` inside the component's `<script>` block.\n\nCalling this method schedules an update for the next microtask — the DOM is *not* updated synchronously.\n\n``` javascript\ncomponent.$set({ answer: 42 });\n```\n\n## $on\n\n``` javascript\ncomponent.$on(ev, callback);\n```\n\nCauses the `callback` function to be called whenever the component dispatches an `event`.\n\nA function is returned that will remove the event listener when called.\n\nindex.js\n\n``` javascript\nconst off = component.$on('selected', (event) => {\n    console.log(event.detail.selection);\n});\n\n\noff();\n```\n\n## $destroy\n\n``` javascript\ncomponent.$destroy();\n```\n\nRemoves a component from the DOM and triggers any `onDestroy` handlers.\n\n## Component props\n\n``` javascript\ncomponent.prop;\n```\n\n``` javascript\ncomponent.prop = value;\n```\n\nIf a component is compiled with `accessors: true`, each instance will have getters and setters corresponding to each of the component's props. Setting a value will cause a *synchronous* update, rather than the default async update caused by `component.$set(...)`.\n\nBy default, `accessors` is `false`, unless you're compiling as a custom element.\n\nindex.js\n\n``` javascript\nconsole.log(component.count);\ncomponent.count += 1;\n```\n\nindex.ts\n\n``` javascript\nconsole.log(component.count);\ncomponent.count += 1;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/client-side-component-api](https://svelte.dev/docs/client-side-component-api)"
- name: Comments
  id: basic-markup#comments
  summary: You can use HTML comments inside components
  belongs_to: basic-markup
  description: "## Comments\n\nYou can use HTML comments inside components.\n\n``` javascript\n<!-- this is a comment! --><h1>Hello world</h1>\n```\n\nComments beginning with `svelte-ignore` disable warnings for the next block of markup. Usually, these are accessibility warnings; make sure that you're disabling them for a good reason.\n\n``` javascript\n<!-- svelte-ignore a11y-autofocus -->\n<input bind:value={name} autofocus />\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/basic-markup](https://svelte.dev/docs/basic-markup)"
- name: compile
  id: svelte-compiler#compile
  summary: This is where the magic happens
  belongs_to: svelte-compiler
  description: |-
    ## compile

    ``` javascript
    function compile(
        source: string,
        options?: CompileOptions
    ): CompileResult;
    ```

    This is where the magic happens. `svelte.compile` takes your component source code, and turns it into a JavaScript module that exports a class.

    ``` javascript
    import { compile } from 'svelte/compiler';


    const result = compile(source, {
        // options
    });
    ```

    Refer to [CompileOptions](#types-compileoptions) for all the available options.

    The returned `result` object contains the code for your component, along with useful bits of metadata.

    ``` javascript
    const { js, css, ast, warnings, vars, stats } = compile(source);
    ```

    Refer to [CompileResult](#types-compileresult) for a full description of the compile result.
- name: CompileOptions
  id: svelte-compiler#types-compileoptions
  summary: Sets the name of the resulting JavaScript class (though the compiler will rename it if it would otherwise conflict with other variables in scope)
  belongs_to: svelte-compiler
  description: |-
    ### CompileOptions

    ``` javascript
    interface CompileOptions {…}
    ```

    ``` javascript
    name?: string;
    ```

    - default `'Component'`

    Sets the name of the resulting JavaScript class (though the compiler will rename it if it would otherwise conflict with other variables in scope). It will normally be inferred from `filename`

    ``` javascript
    filename?: string;
    ```

    - default `null`

    Used for debugging hints and sourcemaps. Your bundler plugin will set it automatically.

    ``` javascript
    generate?: 'dom' | 'ssr' | false;
    ```

    - default `'dom'`

    If `"dom"`, Svelte emits a JavaScript class for mounting to the DOM. If `"ssr"`, Svelte emits an object with a `render` method suitable for server-side rendering. If `false`, no JavaScript or CSS is returned; just metadata.

    ``` javascript
    errorMode?: 'throw' | 'warn';
    ```

    - default `'throw'`

    If `"throw"`, Svelte throws when a compilation error occurred. If `"warn"`, Svelte will treat errors as warnings and add them to the warning report.

    ``` javascript
    varsReport?: 'full' | 'strict' | false;
    ```

    - default `'strict'`

    If `"strict"`, Svelte returns a variables report with only variables that are not globals nor internals. If `"full"`, Svelte returns a variables report with all detected variables. If `false`, no variables report is returned.

    ``` javascript
    sourcemap?: object | string;
    ```

    - default `null`

    An initial sourcemap that will be merged into the final output sourcemap. This is usually the preprocessor sourcemap.

    ``` javascript
    enableSourcemap?: EnableSourcemap;
    ```

    - default `true`

    If `true`, Svelte generate sourcemaps for components. Use an object with `js` or `css` for more granular control of sourcemap generation.

    ``` javascript
    outputFilename?: string;
    ```

    - default `null`

    Used for your JavaScript sourcemap.

    ``` javascript
    cssOutputFilename?: string;
    ```

    - default `null`

    Used for your CSS sourcemap.

    ``` javascript
    sveltePath?: string;
    ```

    - default `'svelte'`

    The location of the `svelte` package. Any imports from `svelte` or `svelte/[module]` will be modified accordingly.

    ``` javascript
    dev?: boolean;
    ```

    - default `false`

    If `true`, causes extra code to be added to components that will perform runtime checks and provide debugging information during development.

    ``` javascript
    accessors?: boolean;
    ```

    - default `false`

    If `true`, getters and setters will be created for the component's props. If `false`, they will only be created for readonly exported values (i.e. those declared with `const`, `class` and `function`). If compiling with `customElement: true` this option defaults to `true`.

    ``` javascript
    immutable?: boolean;
    ```

    - default `false`

    If `true`, tells the compiler that you promise not to mutate any objects. This allows it to be less conservative about checking whether values have changed.

    ``` javascript
    hydratable?: boolean;
    ```

    - default `false`

    If `true` when generating DOM code, enables the `hydrate: true` runtime option, which allows a component to upgrade existing DOM rather than creating new DOM from scratch. When generating SSR code, this adds markers to `<head>` elements so that hydration knows which to replace.

    ``` javascript
    legacy?: boolean;
    ```

    - default `false`

    If `true`, generates code that will work in IE9 and IE10, which don't support things like `element.dataset`.

    ``` javascript
    customElement?: boolean;
    ```

    - default `false`

    If `true`, tells the compiler to generate a custom element constructor instead of a regular Svelte component.

    ``` javascript
    tag?: string;
    ```

    - default `null`

    A `string` that tells Svelte what tag name to register the custom element with. It must be a lowercase alphanumeric string with at least one hyphen, e.g. `"my-element"`.

    ``` javascript
    css?: 'injected' | 'external' | 'none' | boolean;
    ```

    - `'injected'` (formerly `true`), styles will be included in the JavaScript class and injected at runtime for the components actually rendered.
    - `'external'` (formerly `false`), the CSS will be returned in the `css` field of the compilation result. Most Svelte bundler plugins will set this to `'external'` and use the CSS that is statically generated for better performance, as it will result in smaller JavaScript bundles and the output can be served as cacheable `.css` files.
    - `'none'`, styles are completely avoided and no CSS output is generated.

    ``` javascript
    loopGuardTimeout?: number;
    ```

    - default `0`

    A `number` that tells Svelte to break the loop if it blocks the thread for more than `loopGuardTimeout` ms. This is useful to prevent infinite loops. **Only available when `dev: true`**.

    ``` javascript
    namespace?: string;
    ```

    - default `'html'`

    The namespace of the element; e.g., `"mathml"`, `"svg"`, `"foreign"`.

    ``` javascript
    cssHash?: CssHashGetter;
    ```

    - default `undefined`

    A function that takes a `{ hash, css, name, filename }` argument and returns the string that is used as a classname for scoped CSS. It defaults to returning `svelte-${hash(css)}`.

    ``` javascript
    preserveComments?: boolean;
    ```

    - default `false`

    If `true`, your HTML comments will be preserved during server-side rendering. By default, they are stripped out.

    ``` javascript
    preserveWhitespace?: boolean;
    ```

    - default `false`

    If `true`, whitespace inside and between elements is kept as you typed it, rather than removed or collapsed to a single space where possible.

    ``` javascript
    discloseVersion?: boolean;
    ```

    - default `true`

    If `true`, exposes the Svelte major version on the global `window` object in the browser.
- name: CompileResult
  id: svelte-compiler#types-compileresult
  summary: An array of warning objects that were generated during compilation
  belongs_to: svelte-compiler
  description: |-
    ### CompileResult

    The returned shape of `compile` from `svelte/compiler`

    ``` javascript
    interface CompileResult {…}
    ```

    ``` javascript
    js: {…}
    ```

    The resulting JavaScript code from compling the component

    ``` javascript
    code: string;
    ```

    Code as a string

    ``` javascript
    map: any;
    ```

    A source map

    ``` javascript
    css: CssResult;
    ```

    The resulting CSS code from compling the component

    ``` javascript
    ast: Ast;
    ```

    The abstract syntax tree representing the structure of the component

    ``` javascript
    warnings: Warning[];
    ```

    An array of warning objects that were generated during compilation. Each warning has several properties:

    - code is a string identifying the category of warning
    - message describes the issue in human-readable terms
    - start and end, if the warning relates to a specific location, are objects with line, column and character properties
    - frame, if applicable, is a string highlighting the offending code with line numbers

    ``` javascript
    vars: Var[];
    ```

    An array of the component's declarations used by tooling in the ecosystem (like our ESLint plugin) to infer more information

    ``` javascript
    stats: {
        timings: {
            total: number;
        };
    };
    ```

    An object used by the Svelte developer team for diagnosing the compiler. Avoid relying on it to stay the same!
- name: Component lifecycle
  id: custom-elements-api#component-lifecycle
  summary: Custom elements are created from Svelte components using a wrapper approach
  belongs_to: custom-elements-api
  description: |-
    ## Component lifecycle

    Custom elements are created from Svelte components using a wrapper approach. This means the inner Svelte component has no knowledge that it is a custom element. The custom element wrapper takes care of handling its lifecycle appropriately.

    When a custom element is created, the Svelte component it wraps is *not* created right away. It is only created in the next tick after the `connectedCallback` is invoked. Properties assigned to the custom element before it is inserted into the DOM are temporarily saved and then set on component creation, so their values are not lost. The same does not work for invoking exported functions on the custom element though, they are only available after the element has mounted. If you need to invoke functions before component creation, you can work around it by using the [`extend` option](#component-options).

    When a custom element written with Svelte is created or updated, the shadow DOM will reflect the value in the next tick, not immediately. This way updates can be batched, and DOM moves which temporarily (but synchronously) detach the element from the DOM don't lead to unmounting the inner component.

    The inner Svelte component is destroyed in the next tick after the `disconnectedCallback` is invoked.
- name: Component options
  id: custom-elements-api#component-options
  summary: When constructing a custom element, you can tailor several aspects by defining customElement as an object within <svelte:options> since Svelte 4
  belongs_to: custom-elements-api
  description: |-
    ## Component options

    When constructing a custom element, you can tailor several aspects by defining `customElement` as an object within `<svelte:options>` since Svelte 4. This object may contain the following properties:

    - `tag`: the mandatory `tag` property for the custom element's name
    - `shadow`: an optional property that can be set to `"none"` to forgo shadow root creation. Note that styles are then no longer encapsulated, and you can't use slots
    - `props`: an optional property to modify certain details and behaviors of your component's properties. It offers the following settings:
      - `attribute: string`: To update a custom element's prop, you have two alternatives: either set the property on the custom element's reference as illustrated above or use an HTML attribute. For the latter, the default attribute name is the lowercase property name. Modify this by assigning `attribute: "<desired name>"`.
      - `reflect: boolean`: By default, updated prop values do not reflect back to the DOM. To enable this behavior, set `reflect: true`.
      - `type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'`: While converting an attribute value to a prop value and reflecting it back, the prop value is assumed to be a `String` by default. This may not always be accurate. For instance, for a number type, define it using `type: "Number"` You don't need to list all properties, those not listed will use the default settings.
    - `extend`: an optional property which expects a function as its argument. It is passed the custom element class generated by Svelte and expects you to return a custom element class. This comes in handy if you have very specific requirements to the life cycle of the custom element or want to enhance the class to for example use [ElementInternals](https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals#examples) for better HTML form integration.

    ``` javascript
    <svelte:options
        customElement={{
            tag: 'custom-element',
            shadow: 'none',
            props: {
                name: { reflect: true, type: 'Number', attribute: 'element-index' }
            },
            extend: (customElementConstructor) => {
                // Extend the class so we can let it participate in HTML forms
                return class extends customElementConstructor {
                    static formAssociated = true;

                    constructor() {
                        super();
                        this.attachedInternals = this.attachInternals();
                    }

                    // Add the function here, not below in the component so that
                    // it's always available, not just when the inner Svelte component
                    // is mounted
                    randomIndex() {
                        this.elementIndex = Math.random();
                    }
                };
            }
        }}
    />

    <script>
        export let elementIndex;
        export let attachedInternals;
        // ...
        function check() {
            attachedInternals.checkValidity();
        }
    </script>

    ...
    ```
- name: Component props
  id: client-side-component-api#component-props
  summary: 'If a component is compiled with accessors: true, each instance will have getters and setters corresponding to each of the component''s props'
  belongs_to: client-side-component-api
  description: "## Component props\n\n``` javascript\ncomponent.prop;\n```\n\n``` javascript\ncomponent.prop = value;\n```\n\nIf a component is compiled with `accessors: true`, each instance will have getters and setters corresponding to each of the component's props. Setting a value will cause a *synchronous* update, rather than the default async update caused by `component.$set(...)`.\n\nBy default, `accessors` is `false`, unless you're compiling as a custom element.\n\nindex.js\n\n``` javascript\nconsole.log(component.count);\ncomponent.count += 1;\n```\n\nindex.ts\n\n``` javascript\nconsole.log(component.count);\ncomponent.count += 1;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/client-side-component-api](https://svelte.dev/docs/client-side-component-api)"
- name: component-directives
  id: component-directives
  summary: Components can emit events using createEventDispatcher or by forwarding DOM events
  description: "# Component directives\n\n## on:*eventname*\n\n``` javascript\non:eventname={handler}\n```\n\nComponents can emit events using [`createEventDispatcher`](svelte#createeventdispatcher) or by forwarding DOM events.\n\n``` javascript\n<script>\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n</script>\n\n<!-- programmatic dispatching -->\n<button on:click={() => dispatch('hello')}> one </button>\n\n<!-- declarative event forwarding -->\n<button on:click> two </button>\n```\n\nListening for component events looks the same as listening for DOM events:\n\n``` javascript\n<SomeComponent on:whatever={handler} />\n```\n\nAs with DOM events, if the `on:` directive is used without a value, the event will be forwarded, meaning that a consumer can listen for it.\n\n``` javascript\n<SomeComponent on:whatever />\n```\n\n## --style-props\n\n``` javascript\n--style-props=\"anycssvalue\"\n```\n\nYou can also pass styles as props to components for the purposes of theming, using CSS custom properties.\n\nSvelte's implementation is essentially syntactic sugar for adding a wrapper element. This example:\n\n``` javascript\n<Slider bind:value min={0} --rail-color=\"black\" --track-color=\"rgb(0, 0, 255)\" />\n```\n\nDesugars to this:\n\n``` javascript\n<div style=\"display: contents; --rail-color: black; --track-color: rgb(0, 0, 255)\">\n    <Slider bind:value min={0} max={100} />\n</div>\n```\n\n**Note**: Since this is an extra `<div>`, beware that your CSS structure might accidentally target this. Be mindful of this added wrapper element when using this feature.\n\nFor SVG namespace, the example above desugars into using `<g>` instead:\n\n``` javascript\n<g style=\"--rail-color: black; --track-color: rgb(0, 0, 255)\">\n    <Slider bind:value min={0} max={100} />\n</g>\n```\n\n**Note**: Since this is an extra `<g>`, beware that your CSS structure might accidentally target this. Be mindful of this added wrapper element when using this feature.\n\nSvelte's CSS Variables support allows for easily themeable components:\n\n``` javascript\n<style>\n    .potato-slider-rail {\n        background-color: var(--rail-color, var(--theme-color, 'purple'));\n    }\n</style>\n```\n\nSo you can set a high-level theme color:\n\n``` javascript\n/* global.css */\nhtml {\n    --theme-color: black;\n}\n```\n\nOr override it at the consumer level:\n\n``` javascript\n<Slider --rail-color=\"goldenrod\" />\n```\n\n## bind:*property*\n\n``` javascript\nbind:property={variable}\n```\n\nYou can bind to component props using the same syntax as for elements.\n\n``` javascript\n<Keypad bind:value={pin} />\n```\n\nWhile Svelte props are reactive without binding, that reactivity only flows downward into the component by default. Using `bind:property` allows changes to the property from within the component to flow back up out of the component.\n\n## bind:this\n\n``` javascript\nbind:this={component_instance}\n```\n\nComponents also support `bind:this`, allowing you to interact with component instances programmatically.\n\n``` javascript\n<ShoppingCart bind:this={cart} />\n\n<button on:click={() => cart.empty()}> Empty shopping cart </button>\n```\n\n> Note that we can't do `{cart.empty}` since `cart` is `undefined` when the button is first rendered and throws an error.\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/component-directives](https://svelte.dev/docs/component-directives)"
- name: ComponentConstructorOptions
  id: typescript#types-componentconstructoroptions
  summary: null
  belongs_to: typescript
  description: |-
    ### ComponentConstructorOptions

    ``` javascript
    interface ComponentConstructorOptions<
        Props extends Record<string, any> = Record<string, any>
    > {…}
    ```

    ``` javascript
    target: Element | Document | ShadowRoot;
    ```

    ``` javascript
    anchor?: Element;
    ```

    ``` javascript
    props?: Props;
    ```

    ``` javascript
    context?: Map<any, any>;
    ```

    ``` javascript
    hydrate?: boolean;
    ```

    ``` javascript
    intro?: boolean;
    ```

    ``` javascript
    $$inline?: boolean;
    ```
- name: ComponentConstructorOptions
  id: svelte#types-componentconstructoroptions
  summary: null
  belongs_to: svelte
  description: |-
    ### ComponentConstructorOptions

    ``` javascript
    interface ComponentConstructorOptions<
        Props extends Record<string, any> = Record<string, any>
    > {…}
    ```

    ``` javascript
    target: Element | Document | ShadowRoot;
    ```

    ``` javascript
    anchor?: Element;
    ```

    ``` javascript
    props?: Props;
    ```

    ``` javascript
    context?: Map<any, any>;
    ```

    ``` javascript
    hydrate?: boolean;
    ```

    ``` javascript
    intro?: boolean;
    ```

    ``` javascript
    $$inline?: boolean;
    ```
- name: ComponentEvents
  id: typescript#types-componentevents
  summary: Convenience type to get the events the given component expects
  belongs_to: typescript
  description: |-
    ### ComponentEvents

    Convenience type to get the events the given component expects. Example:

    ``` javascript
    <script lang="ts">
       import type { ComponentEvents } from 'svelte';
       import Component from './Component.svelte';

       function handleCloseEvent(event: ComponentEvents<Component>['close']) {
          console.log(event.detail);
       }
    </script>

    <Component on:close={handleCloseEvent} />
    ```

    ``` javascript
    type ComponentEvents<Component extends SvelteComponent_1> =
        Component extends SvelteComponent<any, infer Events>
            ? Events
            : never;
    ```
- name: ComponentEvents
  id: svelte#types-componentevents
  summary: Convenience type to get the events the given component expects
  belongs_to: svelte
  description: |-
    ### ComponentEvents

    Convenience type to get the events the given component expects. Example:

    ``` javascript
    <script lang="ts">
       import type { ComponentEvents } from 'svelte';
       import Component from './Component.svelte';

       function handleCloseEvent(event: ComponentEvents<Component>['close']) {
          console.log(event.detail);
       }
    </script>

    <Component on:close={handleCloseEvent} />
    ```

    ``` javascript
    type ComponentEvents<Component extends SvelteComponent_1> =
        Component extends SvelteComponent<any, infer Events>
            ? Events
            : never;
    ```
- name: ComponentProps
  id: svelte#types-componentprops
  summary: Convenience type to get the props the given component expects
  belongs_to: svelte
  description: |-
    ### ComponentProps

    Convenience type to get the props the given component expects. Example:

    ``` javascript
    <script lang="ts">
        import type { ComponentProps } from 'svelte';
        import Component from './Component.svelte';

        const props: ComponentProps<Component> = { foo: 'bar' }; // Errors if these aren't the correct props
    </script>
    ```

    ``` javascript
    type ComponentProps<Component extends SvelteComponent_1> =
        Component extends SvelteComponent<infer Props>
            ? Props
            : never;
    ```
- name: ComponentProps
  id: typescript#types-componentprops
  summary: Convenience type to get the props the given component expects
  belongs_to: typescript
  description: |-
    ### ComponentProps

    Convenience type to get the props the given component expects. Example:

    ``` javascript
    <script lang="ts">
        import type { ComponentProps } from 'svelte';
        import Component from './Component.svelte';

        const props: ComponentProps<Component> = { foo: 'bar' }; // Errors if these aren't the correct props
    </script>
    ```

    ``` javascript
    type ComponentProps<Component extends SvelteComponent_1> =
        Component extends SvelteComponent<infer Props>
            ? Props
            : never;
    ```
- name: ComponentType
  id: svelte#types-componenttype
  summary: Convenience type to get the type of a Svelte component
  belongs_to: svelte
  description: |-
    ### ComponentType

    Convenience type to get the type of a Svelte component. Useful for example in combination with dynamic components using `<svelte:component>`.

    Example:

    ``` javascript
    <script lang="ts">
        import type { ComponentType, SvelteComponent } from 'svelte';
        import Component1 from './Component1.svelte';
        import Component2 from './Component2.svelte';

        const component: ComponentType = someLogic() ? Component1 : Component2;
        const componentOfCertainSubType: ComponentType<SvelteComponent<{ needsThisProp: string }>> = someLogic() ? Component1 : Component2;
    </script>

    <svelte:component this={component} />
    <svelte:component this={componentOfCertainSubType} needsThisProp="hello" />
    ```

    ``` javascript
    type ComponentType<
        Component extends SvelteComponent = SvelteComponent
    > = (new (
        options: ComponentConstructorOptions<
            Component extends SvelteComponent<infer Props>
                ? Props
                : Record<string, any>
        >
    ) => Component) & {
        /** The custom element version of the component. Only present if compiled with the `customElement` compiler option */
        element?: typeof HTMLElement;
    };
    ```
- name: ComponentType
  id: typescript#types-componenttype
  summary: Convenience type to get the type of a Svelte component
  belongs_to: typescript
  description: |-
    ### ComponentType

    Convenience type to get the type of a Svelte component. Useful for example in combination with dynamic components using `<svelte:component>`.

    Example:

    ``` javascript
    <script lang="ts">
        import type { ComponentType, SvelteComponent } from 'svelte';
        import Component1 from './Component1.svelte';
        import Component2 from './Component2.svelte';

        const component: ComponentType = someLogic() ? Component1 : Component2;
        const componentOfCertainSubType: ComponentType<SvelteComponent<{ needsThisProp: string }>> = someLogic() ? Component1 : Component2;
    </script>

    <svelte:component this={component} />
    <svelte:component this={componentOfCertainSubType} needsThisProp="hello" />
    ```

    ``` javascript
    type ComponentType<
        Component extends SvelteComponent = SvelteComponent
    > = (new (
        options: ComponentConstructorOptions<
            Component extends SvelteComponent<infer Props>
                ? Props
                : Record<string, any>
        >
    ) => Component) & {
        /** The custom element version of the component. Only present if compiled with the `customElement` compiler option */
        element?: typeof HTMLElement;
    };
    ```
- name: createEventDispatcher
  id: svelte#createeventdispatcher
  summary: Creates an event dispatcher that can be used to dispatch component events
  belongs_to: svelte
  description: |-
    ## createEventDispatcher

    ``` javascript
    function createEventDispatcher<
        EventMap extends Record<string, any> = any
    >(): EventDispatcher<EventMap>;
    ```

    Creates an event dispatcher that can be used to dispatch [component events](component-directives#on-eventname). Event dispatchers are functions that can take two arguments: `name` and `detail`.

    Component events created with `createEventDispatcher` create a [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent). These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture). The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail) property and can contain any type of data.

    ``` javascript
    <script>
        import { createEventDispatcher } from 'svelte';

        const dispatch = createEventDispatcher();
    </script>

    <button on:click={() => dispatch('notify', 'detail value')}>Fire Event</button>
    ```

    Events dispatched from child components can be listened to in their parent. Any data provided when the event was dispatched is available on the `detail` property of the event object.

    ``` javascript
    <script>
        function callbackFunction(event) {
            console.log(`Notify fired! Detail: ${event.detail}`);
        }
    </script>

    <Child on:notify={callbackFunction} />
    ```

    Events can be cancelable by passing a third parameter to the dispatch function. The function returns `false` if the event is cancelled with `event.preventDefault()`, otherwise it returns `true`.

    ``` javascript
    <script>
        import { createEventDispatcher } from 'svelte';

        const dispatch = createEventDispatcher();

        function notify() {
            const shouldContinue = dispatch('notify', 'detail value', { cancelable: true });
            if (shouldContinue) {
                // no one called preventDefault
            } else {
                // a listener called preventDefault
            }
        }
    </script>
    ```

    You can type the event dispatcher to define which events it can receive. This will make your code more type safe both within the component (wrong calls are flagged) and when using the component (types of the events are now narrowed). See [here](typescript#script-lang-ts-events) how to do it.
- name: Creating a component
  id: client-side-component-api#creating-a-component
  summary: 'A client-side component — that is, a component compiled with generate: ''dom'' (or the generate option left unspecified) is a JavaScript class'
  belongs_to: client-side-component-api
  description: |-
    ## Creating a component

    ``` javascript
    const component = new Component(options);
    ```

    A client-side component — that is, a component compiled with `generate: 'dom'` (or the `generate` option left unspecified) is a JavaScript class.

    ``` javascript
    import App from './App.svelte';


    const app = new App({
        target: document.body,
        props: {
            // assuming App.svelte contains something like
            // `export let answer`:
            answer: 42
        }
    });
    ```

    The following initialisation options can be provided:

    | option    | default     | description                                                                                          |
    |-----------|-------------|------------------------------------------------------------------------------------------------------|
    | `target`  | **none**    | An `HTMLElement` or `ShadowRoot` to render to. This option is required                               |
    | `anchor`  | `null`      | A child of `target` to render the component immediately before                                       |
    | `props`   | `{}`        | An object of properties to supply to the component                                                   |
    | `context` | `new Map()` | A `Map` of root-level context key-value pairs to supply to the component                             |
    | `hydrate` | `false`     | See below                                                                                            |
    | `intro`   | `false`     | If `true`, will play transitions on initial render, rather than waiting for subsequent state changes |

    Existing children of `target` are left where they are.

    The `hydrate` option instructs Svelte to upgrade existing DOM (usually from server-side rendering) rather than creating new elements. It will only work if the component was compiled with the [`hydratable: true` option](svelte-compiler#compile). Hydration of `<head>` elements only works properly if the server-side rendering code was also compiled with `hydratable: true`, which adds a marker to each element in the `<head>` so that the component knows which elements it's responsible for removing during hydration.

    Whereas children of `target` are normally left alone, `hydrate: true` will cause any children to be removed. For that reason, the `anchor` option cannot be used alongside `hydrate: true`.

    The existing DOM doesn't need to match the component — Svelte will 'repair' the DOM as it goes.

    index.js

    ``` javascript
    import App from './App.svelte';


    const app = new App({
        target: document.querySelector('#server-rendered-html'),
        hydrate: true
    });
    ```
- name: crossfade
  id: svelte-transition#crossfade
  summary: The crossfade function creates a pair of transitions called send and receive
  belongs_to: svelte-transition
  description: |-
    ## crossfade

    ``` javascript
    function crossfade({
        fallback,
        ...defaults
    }: CrossfadeParams & {
        fallback?:
            | ((
                    node: Element,
                    params: CrossfadeParams,
                    intro: boolean
              ) => TransitionConfig)
            | undefined;
    }): [
        (
            node: any,
            params: CrossfadeParams & {
                key: any;
            }
        ) => () => TransitionConfig,
        (
            node: any,
            params: CrossfadeParams & {
                key: any;
            }
        ) => () => TransitionConfig
    ];
    ```

    The `crossfade` function creates a pair of [transitions](element-directives#transition-fn) called `send` and `receive`. When an element is 'sent', it looks for a corresponding element being 'received', and generates a transition that transforms the element to its counterpart's position and fades it out. When an element is 'received', the reverse happens. If there is no counterpart, the `fallback` transition is used.

    `crossfade` accepts the following parameters:

    - `delay` (`number`, default 0) — milliseconds before starting
    - `duration` (`number` \| `function`, default 800) — milliseconds the transition lasts
    - `easing` (`function`, default `cubicOut`) — an [easing function](svelte-easing)
    - `fallback` (`function`) — A fallback [transition](element-directives#transition-fn) to use for send when there is no matching element being received, and for receive when there is no element being sent.

    ``` javascript
    <script>
        import { crossfade } from 'svelte/transition';
        import { quintOut } from 'svelte/easing';

        const [send, receive] = crossfade({
            duration: 1500,
            easing: quintOut
        });
    </script>

    {#if condition}
        <h1 in:send={{ key }} out:receive={{ key }}>BIG ELEM</h1>
    {:else}
        <small in:send={{ key }} out:receive={{ key }}>small elem</small>
    {/if}
    ```
- name: CrossfadeParams
  id: svelte-transition#types-crossfadeparams
  summary: null
  belongs_to: svelte-transition
  description: |-
    ### CrossfadeParams

    ``` javascript
    interface CrossfadeParams {…}
    ```

    ``` javascript
    delay?: number;
    ```

    ``` javascript
    duration?: number | ((len: number) => number);
    ```

    ``` javascript
    easing?: EasingFunction;
    ```
- name: CssHashGetter
  id: svelte-compiler#types-csshashgetter
  summary: null
  belongs_to: svelte-compiler
  description: |-
    ### CssHashGetter

    ``` javascript
    type CssHashGetter = (args: {
        name: string;
        filename: string | undefined;
        css: string;
        hash: (input: string) => string;
    }) => string;
    ```
- name: Custom animation functions
  id: element-directives#custom-animation-functions
  summary: Animations can use custom functions that provide the node, an animation object and any parameters as arguments
  belongs_to: element-directives
  description: "## Custom animation functions\n\nAnimations can use custom functions that provide the `node`, an `animation` object and any `parameters` as arguments. The `animation` parameter is an object containing `from` and `to` properties each containing a [DOMRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect#Properties) describing the geometry of the element in its `start` and `end` positions. The `from` property is the DOMRect of the element in its starting position, and the `to` property is the DOMRect of the element in its final position after the list has been reordered and the DOM updated.\n\nIf the returned object has a `css` method, Svelte will create a CSS animation that plays on the element.\n\nThe `t` argument passed to `css` is a value that goes from `0` and `1` after the `easing` function has been applied. The `u` argument is equal to `1 - t`.\n\nThe function is called repeatedly *before* the animation begins, with different `t` and `u` arguments.\n\n``` javascript\n<script>\n    import { cubicOut } from 'svelte/easing';\n\n    /**\n     * @param {HTMLElement} node\n     * @param {{ from: DOMRect; to: DOMRect }} states\n     * @param {any} params\n     */\n    function whizz(node, { from, to }, params) {\n        const dx = from.left - to.left;\n        const dy = from.top - to.top;\n\n        const d = Math.sqrt(dx * dx + dy * dy);\n\n        return {\n            delay: 0,\n            duration: Math.sqrt(d) * 120,\n            easing: cubicOut,\n            css: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`\n        };\n    }\n</script>\n\n{#each list as item, index (item)}\n    <div animate:whizz>{item}</div>\n{/each}\n```\n\nA custom animation function can also return a `tick` function, which is called *during* the animation with the same `t` and `u` arguments.\n\n> If it's possible to use `css` instead of `tick`, do so — CSS animations can run off the main thread, preventing jank on slower devices.\n\n``` javascript\n<script>\n    import { cubicOut } from 'svelte/easing';\n\n    /**\n     * @param {HTMLElement} node\n     * @param {{ from: DOMRect; to: DOMRect }} states\n     * @param {any} params\n     */\n    function whizz(node, { from, to }, params) {\n        const dx = from.left - to.left;\n        const dy = from.top - to.top;\n\n        const d = Math.sqrt(dx * dx + dy * dy);\n\n        return {\n            delay: 0,\n            duration: Math.sqrt(d) * 120,\n            easing: cubicOut,\n            tick: (t, u) => Object.assign(node.style, { color: t > 0.5 ? 'Pink' : 'Blue' })\n        };\n    }\n</script>\n\n{#each list as item, index (item)}\n    <div animate:whizz>{item}</div>\n{/each}\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/element-directives](https://svelte.dev/docs/element-directives)"
- name: Custom Elements with Svelte
  id: v4-migration-guide#custom-elements-with-svelte
  summary: The creation of custom elements with Svelte has been overhauled and significantly improved
  belongs_to: v4-migration-guide
  description: |-
    ## Custom Elements with Svelte

    The creation of custom elements with Svelte has been overhauled and significantly improved. The `tag` option is deprecated in favor of the new `customElement` option:

    This change was made to allow [more configurability](custom-elements-api#component-options) for advanced use cases. The migration script will adjust your code automatically. The update timing of properties has changed slightly as well. ([\#8457](https://github.com/sveltejs/svelte/issues/8457))
- name: Custom transition functions
  id: element-directives#custom-transition-functions
  summary: Transitions can use custom functions
  belongs_to: element-directives
  description: "## Custom transition functions\n\nTransitions can use custom functions. If the returned object has a `css` function, Svelte will create a CSS animation that plays on the element.\n\nThe `t` argument passed to `css` is a value between `0` and `1` after the `easing` function has been applied. *In* transitions run from `0` to `1`, *out* transitions run from `1` to `0` — in other words, `1` is the element's natural state, as though no transition had been applied. The `u` argument is equal to `1 - t`.\n\nThe function is called repeatedly *before* the transition begins, with different `t` and `u` arguments.\n\n``` javascript\n<script>\n    import { elasticOut } from 'svelte/easing';\n\n    /** @type {boolean} */\n    export let visible;\n\n    /**\n     * @param {HTMLElement} node\n     * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params\n     */\n    function whoosh(node, params) {\n        const existingTransform = getComputedStyle(node).transform.replace('none', '');\n\n        return {\n            delay: params.delay || 0,\n            duration: params.duration || 400,\n            easing: params.easing || elasticOut,\n            css: (t, u) => `transform: ${existingTransform} scale(${t})`\n        };\n    }\n</script>\n\n{#if visible}\n    <div in:whoosh>whooshes in</div>\n{/if}\n```\n\nA custom transition function can also return a `tick` function, which is called *during* the transition with the same `t` and `u` arguments.\n\n> If it's possible to use `css` instead of `tick`, do so — CSS animations can run off the main thread, preventing jank on slower devices.\n\nApp.svelte\n\n``` javascript\n<script>\n    export let visible = false;\n\n    /**\n     * @param {HTMLElement} node\n     * @param {{ speed?: number }} params\n     */\n    function typewriter(node, { speed = 1 }) {\n        const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;\n\n        if (!valid) {\n            throw new Error(`This transition only works on elements with a single text node child`);\n        }\n\n        const text = node.textContent;\n        const duration = text.length / (speed * 0.01);\n\n        return {\n            duration,\n            tick: (t) => {\n                const i = ~~(text.length * t);\n                node.textContent = text.slice(0, i);\n            }\n        };\n    }\n</script>\n\n{#if visible}\n    <p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>\n{/if}\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    export let visible = false;\n    \n    function typewriter(node: HTMLElement, { speed = 1 }: { speed?: number }) {\n        const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;\n    \n        if (!valid) {\n            throw new Error(`This transition only works on elements with a single text node child`);\n        }\n    \n        const text = node.textContent;\n        const duration = text.length / (speed * 0.01);\n    \n        return {\n            duration,\n            tick: (t) => {\n                const i = ~~(text.length * t);\n                node.textContent = text.slice(0, i);\n            },\n        };\n    }\n</script>\n\n{#if visible}\n    <p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>\n{/if}\n```\n\nIf a transition returns a function instead of a transition object, the function will be called in the next microtask. This allows multiple transitions to coordinate, making [crossfade effects](https://learn.svelte.dev/tutorial/deferred-transitions) possible.\n\nTransition functions also receive a third argument, `options`, which contains information about the transition.\n\nAvailable values in the `options` object are:\n\n- `direction` - one of `in`, `out`, or `both` depending on the type of transition"
- name: custom-elements-api
  id: custom-elements-api
  summary: 'Svelte components can also be compiled to custom elements (aka web components) using the customElement: true compiler option'
  description: "# Custom elements API\n\nSvelte components can also be compiled to custom elements (aka web components) using the `customElement: true` compiler option. You should specify a tag name for the component using the `<svelte:options>` [element](special-elements#svelte-options).\n\n``` javascript\n<svelte:options customElement=\"my-element\" />\n\n<!-- in Svelte 3, do this instead:\n<svelte:options tag=\"my-element\" />\n-->\n\n<script>\n    export let name = 'world';\n</script>\n\n<h1>Hello {name}!</h1>\n<slot />\n```\n\nYou can leave out the tag name for any of your inner components which you don't want to expose and use them like regular Svelte components. Consumers of the component can still name it afterwards if needed, using the static `element` property which contains the custom element constructor and which is available when the `customElement` compiler option is `true`.\n\n``` javascript\nimport MyElement from './MyElement.svelte';\n\n\ncustomElements.define('my-element', MyElement.element);\n// In Svelte 3, do this instead:\n// customElements.define('my-element', MyElement);\n```\n\nOnce a custom element has been defined, it can be used as a regular DOM element:\n\n``` javascript\ndocument.body.innerHTML = `\n    <my-element>\n        <p>This is some slotted content</p>\n    </my-element>\n`;\n```\n\nBy default, custom elements are compiled with `accessors: true`, which means that any [props](basic-markup#attributes-and-props) are exposed as properties of the DOM element (as well as being readable/writable as attributes, where possible).\n\nTo prevent this, add `accessors={false}` to `<svelte:options>`.\n\n``` javascript\nconst el = document.querySelector('my-element');\n\n\n// get the current value of the 'name' prop\nconsole.log(el.name);\n\n\n// set a new value, updating the shadow DOM\nel.name = 'everybody';\n```\n\n## Component lifecycle\n\nCustom elements are created from Svelte components using a wrapper approach. This means the inner Svelte component has no knowledge that it is a custom element. The custom element wrapper takes care of handling its lifecycle appropriately.\n\nWhen a custom element is created, the Svelte component it wraps is *not* created right away. It is only created in the next tick after the `connectedCallback` is invoked. Properties assigned to the custom element before it is inserted into the DOM are temporarily saved and then set on component creation, so their values are not lost. The same does not work for invoking exported functions on the custom element though, they are only available after the element has mounted. If you need to invoke functions before component creation, you can work around it by using the [`extend` option](#component-options).\n\nWhen a custom element written with Svelte is created or updated, the shadow DOM will reflect the value in the next tick, not immediately. This way updates can be batched, and DOM moves which temporarily (but synchronously) detach the element from the DOM don't lead to unmounting the inner component.\n\nThe inner Svelte component is destroyed in the next tick after the `disconnectedCallback` is invoked.\n\n## Component options\n\nWhen constructing a custom element, you can tailor several aspects by defining `customElement` as an object within `<svelte:options>` since Svelte 4. This object may contain the following properties:\n\n- `tag`: the mandatory `tag` property for the custom element's name\n- `shadow`: an optional property that can be set to `\"none\"` to forgo shadow root creation. Note that styles are then no longer encapsulated, and you can't use slots\n- `props`: an optional property to modify certain details and behaviors of your component's properties. It offers the following settings:\n  - `attribute: string`: To update a custom element's prop, you have two alternatives: either set the property on the custom element's reference as illustrated above or use an HTML attribute. For the latter, the default attribute name is the lowercase property name. Modify this by assigning `attribute: \"<desired name>\"`.\n  - `reflect: boolean`: By default, updated prop values do not reflect back to the DOM. To enable this behavior, set `reflect: true`.\n  - `type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'`: While converting an attribute value to a prop value and reflecting it back, the prop value is assumed to be a `String` by default. This may not always be accurate. For instance, for a number type, define it using `type: \"Number\"` You don't need to list all properties, those not listed will use the default settings.\n- `extend`: an optional property which expects a function as its argument. It is passed the custom element class generated by Svelte and expects you to return a custom element class. This comes in handy if you have very specific requirements to the life cycle of the custom element or want to enhance the class to for example use [ElementInternals](https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals#examples) for better HTML form integration.\n\n``` javascript\n<svelte:options\n    customElement={{\n        tag: 'custom-element',\n        shadow: 'none',\n        props: {\n            name: { reflect: true, type: 'Number', attribute: 'element-index' }\n        },\n        extend: (customElementConstructor) => {\n            // Extend the class so we can let it participate in HTML forms\n            return class extends customElementConstructor {\n                static formAssociated = true;\n\n                constructor() {\n                    super();\n                    this.attachedInternals = this.attachInternals();\n                }\n\n                // Add the function here, not below in the component so that\n                // it's always available, not just when the inner Svelte component\n                // is mounted\n                randomIndex() {\n                    this.elementIndex = Math.random();\n                }\n            };\n        }\n    }}\n/>\n\n<script>\n    export let elementIndex;\n    export let attachedInternals;\n    // ...\n    function check() {\n        attachedInternals.checkValidity();\n    }\n</script>\n\n...\n```\n\n## Caveats and limitations\n\nCustom elements can be a useful way to package components for consumption in a non-Svelte app, as they will work with vanilla HTML and JavaScript as well as [most frameworks](https://custom-elements-everywhere.com/). There are, however, some important differences to be aware of:\n\n- Styles are *encapsulated*, rather than merely *scoped* (unless you set `shadow: \"none\"`). This means that any non-component styles (such as you might have in a `global.css` file) will not apply to the custom element, including styles with the `:global(...)` modifier\n- Instead of being extracted out as a separate .css file, styles are inlined into the component as a JavaScript string\n- Custom elements are not generally suitable for server-side rendering, as the shadow DOM is invisible until JavaScript loads\n- In Svelte, slotted content renders *lazily*. In the DOM, it renders *eagerly*. In other words, it will always be created even if the component's `<slot>` element is inside an `{#if ...}` block. Similarly, including a `<slot>` in an `{#each ...}` block will not cause the slotted content to be rendered multiple times\n- The `let:` directive has no effect, because custom elements do not have a way to pass data to the parent component that fills the slot\n- Polyfills are required to support older browsers\n- You can use Svelte's context feature between regular Svelte components within a custom element, but you can't use them across custom elements. In other words, you can't use `setContext` on a parent custom element and read that with `getContext` in a child custom element.\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/custom-elements-api](https://svelte.dev/docs/custom-elements-api)"
- name: Default slot bindings
  id: v4-migration-guide#default-slot-bindings
  summary: This makes slot bindings more consistent as the behavior is undefined when for example the default slot is from a list and the named slot is not
  belongs_to: v4-migration-guide
  description: |-
    ## Default slot bindings

    Default slot bindings are no longer exposed to named slots and vice versa:

    ``` javascript
    <script>
        import Nested from './Nested.svelte';
    </script>

    <Nested let:count>
        <p>
            count in default slot - is available: {count}
        </p>
        <p slot="bar">
            count in bar slot - is not available: {count}
        </p>
    </Nested>
    ```

    This makes slot bindings more consistent as the behavior is undefined when for example the default slot is from a list and the named slot is not. ([\#6049](https://github.com/sveltejs/svelte/issues/6049))
- name: derived
  id: svelte-store#derived
  summary: Derives a store from one or more other stores
  belongs_to: svelte-store
  description: |-
    ## derived

    ``` javascript
    function derived<S extends Stores, T>(
        stores: S,
        fn: (
            values: StoresValues<S>,
            set: (value: T) => void,
            update: (fn: Updater<T>) => void
        ) => Unsubscriber | void,
        initial_value?: T | undefined
    ): Readable<T>;
    ```

    ``` javascript
    function derived<S extends Stores, T>(
        stores: S,
        fn: (values: StoresValues<S>) => T,
        initial_value?: T | undefined
    ): Readable<T>;
    ```

    Derives a store from one or more other stores. The callback runs initially when the first subscriber subscribes and then whenever the store dependencies change.

    In the simplest version, `derived` takes a single store, and the callback returns a derived value.

    ``` javascript
    import { derived } from 'svelte/store';


    const doubled = derived(a, ($a) => $a * 2);
    ```

    The callback can set a value asynchronously by accepting a second argument, `set`, and an optional third argument, `update`, calling either or both of them when appropriate.

    In this case, you can also pass a third argument to `derived` — the initial value of the derived store before `set` or `update` is first called. If no initial value is specified, the store's initial value will be `undefined`.

    ``` javascript
    import { derived } from 'svelte/store';


    const delayed = derived(
        a,
        ($a, set) => {
            setTimeout(() => set($a), 1000);
        },
        2000
    );


    const delayedIncrement = derived(a, ($a, set, update) => {
        set($a);
        setTimeout(() => update((x) => x + 1), 1000);
        // every time $a produces a value, this produces two
        // values, $a immediately and then $a + 1 a second later
    });
    ```

    If you return a function from the callback, it will be called when a) the callback runs again, or b) the last subscriber unsubscribes.

    ``` javascript
    import { derived } from 'svelte/store';


    const tick = derived(
        frequency,
        ($frequency, set) => {
            const interval = setInterval(() => {
                set(Date.now());
            }, 1000 / $frequency);


            return () => {
                clearInterval(interval);
            };
        },
        2000
    );
    ```

    In both cases, an array of arguments can be passed as the first argument instead of a single store.

    ``` javascript
    import { derived } from 'svelte/store';


    const summed = derived([a, b], ([$a, $b]) => $a + $b);


    const delayed = derived([a, b], ([$a, $b], set) => {
        setTimeout(() => set($a + $b), 1000);
    });
    ```
- name: Does Svelte scale?
  id: faq#does-svelte-scale
  summary: There will be a blog post about this eventually, but in the meantime, check out this issue
  belongs_to: faq
  description: |-
    ## Does Svelte scale?

    There will be a blog post about this eventually, but in the meantime, check out [this issue](https://github.com/sveltejs/svelte/issues/2546).
- name: draw
  id: svelte-transition#draw
  summary: Animates the stroke of an SVG element, like a snake in a tube
  belongs_to: svelte-transition
  description: |-
    ## draw

    ``` javascript
    function draw(
        node: SVGElement & {
            getTotalLength(): number;
        },
        {
            delay,
            speed,
            duration,
            easing
        }?: DrawParams | undefined
    ): TransitionConfig;
    ```

    ``` javascript
    transition:draw={params}
    ```

    ``` javascript
    in:draw={params}
    ```

    ``` javascript
    out:draw={params}
    ```

    Animates the stroke of an SVG element, like a snake in a tube. `in` transitions begin with the path invisible and draw the path to the screen over time. `out` transitions start in a visible state and gradually erase the path. `draw` only works with elements that have a `getTotalLength` method, like `<path>` and `<polyline>`.

    `draw` accepts the following parameters:

    - `delay` (`number`, default 0) — milliseconds before starting
    - `speed` (`number`, default undefined) - the speed of the animation, see below.
    - `duration` (`number` \| `function`, default 800) — milliseconds the transition lasts
    - `easing` (`function`, default `cubicInOut`) — an [easing function](svelte-easing)

    The `speed` parameter is a means of setting the duration of the transition relative to the path's length. It is a modifier that is applied to the length of the path: `duration = length / speed`. A path that is 1000 pixels with a speed of 1 will have a duration of `1000ms`, setting the speed to `0.5` will double that duration and setting it to `2` will halve it.

    ``` javascript
    <script>
        import { draw } from 'svelte/transition';
        import { quintOut } from 'svelte/easing';
    </script>

    <svg viewBox="0 0 5 5" xmlns="http://www.w3.org/2000/svg">
        {#if condition}
            <path
                transition:draw={{ duration: 5000, delay: 500, easing: quintOut }}
                d="M2 1 h1 v1 h1 v1 h-1 v1 h-1 v-1 h-1 v-1 h1 z"
                fill="none"
                stroke="cornflowerblue"
                stroke-width="0.1px"
                stroke-linejoin="round"
            />
        {/if}
    </svg>
    ```
- name: DrawParams
  id: svelte-transition#types-drawparams
  summary: null
  belongs_to: svelte-transition
  description: |-
    ### DrawParams

    ``` javascript
    interface DrawParams {…}
    ```

    ``` javascript
    delay?: number;
    ```

    ``` javascript
    speed?: number;
    ```

    ``` javascript
    duration?: number | ((len: number) => number);
    ```

    ``` javascript
    easing?: EasingFunction;
    ```
- name: EasingFunction
  id: svelte-transition#types-easingfunction
  summary: null
  belongs_to: svelte-transition
  description: |-
    ### EasingFunction

    ``` javascript
    type EasingFunction = (t: number) => number;
    ```
- name: Editor tooling
  id: index#editor-tooling
  summary: The Svelte team maintains a VS Code extension and there are integrations with various other editors and tools as well
  description: |-
    ## Editor tooling

    The Svelte team maintains a [VS Code extension](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode) and there are integrations with various other [editors](https://sveltesociety.dev/tools#editor-support) and tools as well.
- name: element-directives
  id: element-directives
  summary: As well as attributes, elements can have directives, which control the element's behaviour in some way
  description: "# Element directives\n\nAs well as attributes, elements can have *directives*, which control the element's behaviour in some way.\n\n## on:*eventname*\n\n``` javascript\non:eventname={handler}\n```\n\n``` javascript\non:eventname|modifiers={handler}\n```\n\nUse the `on:` directive to listen to DOM events.\n\nApp.svelte\n\n``` javascript\n<script>\n    let count = 0;\n\n    /** @param {MouseEvent} event */\n    function handleClick(event) {\n        count += 1;\n    }\n</script>\n\n<button on:click={handleClick}>\n    count: {count}\n</button>\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    let count = 0;\n    \n    function handleClick(event: MouseEvent) {\n        count += 1;\n    }\n</script>\n\n<button on:click={handleClick}>\n    count: {count}\n</button>\n```\n\nHandlers can be declared inline with no performance penalty. As with attributes, directive values may be quoted for the sake of syntax highlighters.\n\n``` javascript\n<button on:click={() => (count += 1)}>\n    count: {count}\n</button>\n```\n\nAdd *modifiers* to DOM events with the `|` character.\n\n``` javascript\n<form on:submit|preventDefault={handleSubmit}>\n    <!-- the `submit` event's default is prevented,\n         so the page won't reload -->\n</form>\n```\n\nThe following modifiers are available:\n\n- `preventDefault` — calls `event.preventDefault()` before running the handler\n- `stopPropagation` — calls `event.stopPropagation()`, preventing the event reaching the next element\n- `stopImmediatePropagation` - calls `event.stopImmediatePropagation()`, preventing other listeners of the same event from being fired.\n- `passive` — improves scrolling performance on touch/wheel events (Svelte will add it automatically where it's safe to do so)\n- `nonpassive` — explicitly set `passive: false`\n- `capture` — fires the handler during the *capture* phase instead of the *bubbling* phase\n- `once` — remove the handler after the first time it runs\n- `self` — only trigger handler if `event.target` is the element itself\n- `trusted` — only trigger handler if `event.isTrusted` is `true`. I.e. if the event is triggered by a user action.\n\nModifiers can be chained together, e.g. `on:click|once|capture={...}`.\n\nIf the `on:` directive is used without a value, the component will *forward* the event, meaning that a consumer of the component can listen for it.\n\n``` javascript\n<button on:click> The component itself will emit the click event </button>\n```\n\nIt's possible to have multiple event listeners for the same event:\n\n``` javascript\n<script>\n    let counter = 0;\n    function increment() {\n        counter = counter + 1;\n    }\n\n    /** @param {MouseEvent} event */\n    function track(event) {\n        trackEvent(event);\n    }\n</script>\n\n<button on:click={increment} on:click={track}>Click me!</button>\n```\n\n## bind:*property*\n\n``` javascript\nbind:property={variable}\n```\n\nData ordinarily flows down, from parent to child. The `bind:` directive allows data to flow the other way, from child to parent. Most bindings are specific to particular elements.\n\nThe simplest bindings reflect the value of a property, such as `input.value`.\n\n``` javascript\n<input bind:value={name} />\n<textarea bind:value={text} />\n\n<input type=\"checkbox\" bind:checked={yes} />\n```\n\nIf the name matches the value, you can use a shorthand.\n\n``` javascript\n<input bind:value />\n<!-- equivalent to\n<input bind:value={value} />\n-->\n```\n\nNumeric input values are coerced; even though `input.value` is a string as far as the DOM is concerned, Svelte will treat it as a number. If the input is empty or invalid (in the case of `type=\"number\"`), the value is `undefined`.\n\n``` javascript\n<input type=\"number\" bind:value={num} />\n<input type=\"range\" bind:value={num} />\n```\n\nOn `<input>` elements with `type=\"file\"`, you can use `bind:files` to get the [`FileList` of selected files](https://developer.mozilla.org/en-US/docs/Web/API/FileList). It is readonly.\n\n``` javascript\n<label for=\"avatar\">Upload a picture:</label>\n<input accept=\"image/png, image/jpeg\" bind:files id=\"avatar\" name=\"avatar\" type=\"file\" />\n```\n\nIf you're using `bind:` directives together with `on:` directives, the order that they're defined in affects the value of the bound variable when the event handler is called.\n\n``` javascript\n<script>\n    let value = 'Hello World';\n</script>\n\n<input\n    on:input={() => console.log('Old value:', value)}\n    bind:value\n    on:input={() => console.log('New value:', value)}\n/>\n```\n\nHere we were binding to the value of a text input, which uses the `input` event. Bindings on other elements may use different events such as `change`.\n\n## Binding \\<select\\> value\n\nA `<select>` value binding corresponds to the `value` property on the selected `<option>`, which can be any value (not just strings, as is normally the case in the DOM).\n\n``` javascript\n<select bind:value={selected}>\n    <option value={a}>a</option>\n    <option value={b}>b</option>\n    <option value={c}>c</option>\n</select>\n```\n\nA `<select multiple>` element behaves similarly to a checkbox group. The bound variable is an array with an entry corresponding to the `value` property of each selected `<option>`.\n\n``` javascript\n<select multiple bind:value={fillings}>\n    <option value=\"Rice\">Rice</option>\n    <option value=\"Beans\">Beans</option>\n    <option value=\"Cheese\">Cheese</option>\n    <option value=\"Guac (extra)\">Guac (extra)</option>\n</select>\n```\n\nWhen the value of an `<option>` matches its text content, the attribute can be omitted.\n\n``` javascript\n<select multiple bind:value={fillings}>\n    <option>Rice</option>\n    <option>Beans</option>\n    <option>Cheese</option>\n    <option>Guac (extra)</option>\n</select>\n```\n\nElements with the `contenteditable` attribute support the following bindings:\n\n- [`innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)\n- [`innerText`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText)\n- [`textContent`](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent)\n\nThere are slight differences between each of these, read more about them [here](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#Differences_from_innerText).\n\n``` javascript\n<div contenteditable=\"true\" bind:innerHTML={html} />\n```\n\n`<details>` elements support binding to the `open` property.\n\n``` javascript\n<details bind:open={isOpen}>\n    <summary>Details</summary>\n    <p>Something small enough to escape casual notice.</p>\n</details>\n```\n\n## Media element bindings\n\nMedia elements (`<audio>` and `<video>`) have their own set of bindings — seven *readonly* ones...\n\n- `duration` (readonly) — the total duration of the video, in seconds\n- `buffered` (readonly) — an array of `{start, end}` objects\n- `played` (readonly) — ditto\n- `seekable` (readonly) — ditto\n- `seeking` (readonly) — boolean\n- `ended` (readonly) — boolean\n- `readyState` (readonly) — number between (and including) 0 and 4\n\n...and five *two-way* bindings:\n\n- `currentTime` — the current playback time in the video, in seconds\n- `playbackRate` — how fast or slow to play the video, where 1 is 'normal'\n- `paused` — this one should be self-explanatory\n- `volume` — a value between 0 and 1\n- `muted` — a boolean value indicating whether the player is muted\n\nVideos additionally have readonly `videoWidth` and `videoHeight` bindings.\n\n``` javascript\n<video\n    src={clip}\n    bind:duration\n    bind:buffered\n    bind:played\n    bind:seekable\n    bind:seeking\n    bind:ended\n    bind:readyState\n    bind:currentTime\n    bind:playbackRate\n    bind:paused\n    bind:volume\n    bind:muted\n    bind:videoWidth\n    bind:videoHeight\n/>\n```\n\n## Image element bindings\n\nImage elements (`<img>`) have two readonly bindings:\n\n- `naturalWidth` (readonly) — the original width of the image, available after the image has loaded\n- `naturalHeight` (readonly) — the original height of the image, available after the image has loaded\n\n``` javascript\n<img\n    bind:naturalWidth\n    bind:naturalHeight\n></img>\n```\n\n## Block-level element bindings\n\nBlock-level elements have 4 read-only bindings, measured using a technique similar to [this one](http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/):\n\n- `clientWidth`\n- `clientHeight`\n- `offsetWidth`\n- `offsetHeight`\n\n``` javascript\n<div bind:offsetWidth={width} bind:offsetHeight={height}>\n    <Chart {width} {height} />\n</div>\n```\n\n## bind:group\n\n``` javascript\nbind:group={variable}\n```\n\nInputs that work together can use `bind:group`.\n\n``` javascript\n<script>\n    let tortilla = 'Plain';\n\n    /** @type {Array<string>} */\n    let fillings = [];\n</script>\n\n<!-- grouped radio inputs are mutually exclusive -->\n<input type=\"radio\" bind:group={tortilla} value=\"Plain\" />\n<input type=\"radio\" bind:group={tortilla} value=\"Whole wheat\" />\n<input type=\"radio\" bind:group={tortilla} value=\"Spinach\" />\n\n<!-- grouped checkbox inputs populate an array -->\n<input type=\"checkbox\" bind:group={fillings} value=\"Rice\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Beans\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Cheese\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Guac (extra)\" />\n```\n\n> `bind:group` only works if the inputs are in the same Svelte component.\n\n## bind:this\n\n``` javascript\nbind:this={dom_node}\n```\n\nTo get a reference to a DOM node, use `bind:this`.\n\n``` javascript\n<script>\n    import { onMount } from 'svelte';\n\n    /** @type {HTMLCanvasElement} */\n    let canvasElement;\n\n    onMount(() => {\n        const ctx = canvasElement.getContext('2d');\n        drawStuff(ctx);\n    });\n</script>\n\n<canvas bind:this={canvasElement} />\n```\n\n## class:*name*\n\n``` javascript\nclass:name={value}\n```\n\n``` javascript\nclass:name\n```\n\nA `class:` directive provides a shorter way of toggling a class on an element.\n\n``` javascript\n<!-- These are equivalent -->\n<div class={isActive ? 'active' : ''}>...</div>\n<div class:active={isActive}>...</div>\n\n<!-- Shorthand, for when name and value match -->\n<div class:active>...</div>\n\n<!-- Multiple class toggles can be included -->\n<div class:active class:inactive={!active} class:isAdmin>...</div>\n```\n\n## style:*property*\n\n``` javascript\nstyle:property={value}\n```\n\n``` javascript\nstyle:property=\"value\"\n```\n\n``` javascript\nstyle:property\n```\n\nThe `style:` directive provides a shorthand for setting multiple styles on an element.\n\n``` javascript\n<!-- These are equivalent -->\n<div style:color=\"red\">...</div>\n<div style=\"color: red;\">...</div>\n\n<!-- Variables can be used -->\n<div style:color={myColor}>...</div>\n\n<!-- Shorthand, for when property and variable name match -->\n<div style:color>...</div>\n\n<!-- Multiple styles can be included -->\n<div style:color style:width=\"12rem\" style:background-color={darkMode ? 'black' : 'white'}>...</div>\n\n<!-- Styles can be marked as important -->\n<div style:color|important=\"red\">...</div>\n```\n\nWhen `style:` directives are combined with `style` attributes, the directives will take precedence:\n\n``` javascript\n<div style=\"color: blue;\" style:color=\"red\">This will be red</div>\n```\n\n## use:*action*\n\n``` javascript\nuse:action\n```\n\n``` javascript\nuse:action={parameters}\n```\n\n``` javascript\naction = (node: HTMLElement, parameters: any) => {\n    update?: (parameters: any) => void,\n    destroy?: () => void\n}\n```\n\nActions are functions that are called when an element is created. They can return an object with a `destroy` method that is called after the element is unmounted:\n\n``` javascript\n<script>\n    /** @type {import('svelte/action').Action}  */\n    function foo(node) {\n        // the node has been mounted in the DOM\n\n        return {\n            destroy() {\n                // the node has been removed from the DOM\n            }\n        };\n    }\n</script>\n\n<div use:foo />\n```\n\nAn action can have a parameter. If the returned value has an `update` method, it will be called whenever that parameter changes, immediately after Svelte has applied updates to the markup.\n\n> Don't worry about the fact that we're redeclaring the `foo` function for every component instance — Svelte will hoist any functions that don't depend on local state out of the component definition.\n\n``` javascript\n<script>\n    export let bar;\n\n    /** @type {import('svelte/action').Action}  */\n    function foo(node, bar) {\n        // the node has been mounted in the DOM\n\n        return {\n            update(bar) {\n                // the value of `bar` has changed\n            },\n\n            destroy() {\n                // the node has been removed from the DOM\n            }\n        };\n    }\n</script>\n\n<div use:foo={bar} />\n```\n\nRead more in the [`svelte/action`](svelte-action) page.\n\n## transition:*fn*\n\n``` javascript\ntransition:fn\n```\n\n``` javascript\ntransition:fn={params}\n```\n\n``` javascript\ntransition:fn|global\n```\n\n``` javascript\ntransition:fn|global={params}\n```\n\n``` javascript\ntransition:fn|local\n```\n\n``` javascript\ntransition:fn|local={params}\n```\n\n``` javascript\ntransition = (node: HTMLElement, params: any, options: { direction: 'in' | 'out' | 'both' }) => {\n    delay?: number,\n    duration?: number,\n    easing?: (t: number) => number,\n    css?: (t: number, u: number) => string,\n    tick?: (t: number, u: number) => void\n}\n```\n\nA transition is triggered by an element entering or leaving the DOM as a result of a state change.\n\nWhen a block is transitioning out, all elements inside the block, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed.\n\nThe `transition:` directive indicates a *bidirectional* transition, which means it can be smoothly reversed while the transition is in progress.\n\n``` javascript\n{#if visible}\n    <div transition:fade>fades in and out</div>\n{/if}\n```\n\nTransitions are local by default (in Svelte 3, they were global by default). Local transitions only play when the block they belong to is created or destroyed, *not* when parent blocks are created or destroyed.\n\n``` javascript\n{#if x}\n    {#if y}\n        <!-- Svelte 3: <p transition:fade|local> -->\n        <p transition:fade>fades in and out only when y changes</p>\n\n        <!-- Svelte 3: <p transition:fade> -->\n        <p transition:fade|global>fades in and out when x or y change</p>\n    {/if}\n{/if}\n```\n\n> By default intro transitions will not play on first render. You can modify this behaviour by setting `intro: true` when you [create a component](client-side-component-api) and marking the transition as `global`.\n\n## Transition parameters\n\nLike actions, transitions can have parameters.\n\n(The double `{{curlies}}` aren't a special syntax; this is an object literal inside an expression tag.)\n\n``` javascript\n{#if visible}\n    <div transition:fade={{ duration: 2000 }}>fades in and out over two seconds</div>\n{/if}\n```\n\n## Custom transition functions\n\nTransitions can use custom functions. If the returned object has a `css` function, Svelte will create a CSS animation that plays on the element.\n\nThe `t` argument passed to `css` is a value between `0` and `1` after the `easing` function has been applied. *In* transitions run from `0` to `1`, *out* transitions run from `1` to `0` — in other words, `1` is the element's natural state, as though no transition had been applied. The `u` argument is equal to `1 - t`.\n\nThe function is called repeatedly *before* the transition begins, with different `t` and `u` arguments.\n\n``` javascript\n<script>\n    import { elasticOut } from 'svelte/easing';\n\n    /** @type {boolean} */\n    export let visible;\n\n    /**\n     * @param {HTMLElement} node\n     * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params\n     */\n    function whoosh(node, params) {\n        const existingTransform = getComputedStyle(node).transform.replace('none', '');\n\n        return {\n            delay: params.delay || 0,\n            duration: params.duration || 400,\n            easing: params.easing || elasticOut,\n            css: (t, u) => `transform: ${existingTransform} scale(${t})`\n        };\n    }\n</script>\n\n{#if visible}\n    <div in:whoosh>whooshes in</div>\n{/if}\n```\n\nA custom transition function can also return a `tick` function, which is called *during* the transition with the same `t` and `u` arguments.\n\n> If it's possible to use `css` instead of `tick`, do so — CSS animations can run off the main thread, preventing jank on slower devices.\n\nApp.svelte\n\n``` javascript\n<script>\n    export let visible = false;\n\n    /**\n     * @param {HTMLElement} node\n     * @param {{ speed?: number }} params\n     */\n    function typewriter(node, { speed = 1 }) {\n        const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;\n\n        if (!valid) {\n            throw new Error(`This transition only works on elements with a single text node child`);\n        }\n\n        const text = node.textContent;\n        const duration = text.length / (speed * 0.01);\n\n        return {\n            duration,\n            tick: (t) => {\n                const i = ~~(text.length * t);\n                node.textContent = text.slice(0, i);\n            }\n        };\n    }\n</script>\n\n{#if visible}\n    <p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>\n{/if}\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    export let visible = false;\n    \n    function typewriter(node: HTMLElement, { speed = 1 }: { speed?: number }) {\n        const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;\n    \n        if (!valid) {\n            throw new Error(`This transition only works on elements with a single text node child`);\n        }\n    \n        const text = node.textContent;\n        const duration = text.length / (speed * 0.01);\n    \n        return {\n            duration,\n            tick: (t) => {\n                const i = ~~(text.length * t);\n                node.textContent = text.slice(0, i);\n            },\n        };\n    }\n</script>\n\n{#if visible}\n    <p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>\n{/if}\n```\n\nIf a transition returns a function instead of a transition object, the function will be called in the next microtask. This allows multiple transitions to coordinate, making [crossfade effects](https://learn.svelte.dev/tutorial/deferred-transitions) possible.\n\nTransition functions also receive a third argument, `options`, which contains information about the transition.\n\nAvailable values in the `options` object are:\n\n- `direction` - one of `in`, `out`, or `both` depending on the type of transition\n\n## Transition events\n\nAn element with transitions will dispatch the following events in addition to any standard DOM events:\n\n- `introstart`\n- `introend`\n- `outrostart`\n- `outroend`\n\n``` javascript\n{#if visible}\n    <p\n        transition:fly={{ y: 200, duration: 2000 }}\n        on:introstart={() => (status = 'intro started')}\n        on:outrostart={() => (status = 'outro started')}\n        on:introend={() => (status = 'intro ended')}\n        on:outroend={() => (status = 'outro ended')}\n    >\n        Flies in and out\n    </p>\n{/if}\n```\n\n## in:*fn*/out:*fn*\n\n``` javascript\nin:fn\n```\n\n``` javascript\nin:fn={params}\n```\n\n``` javascript\nin:fn|global\n```\n\n``` javascript\nin:fn|global={params}\n```\n\n``` javascript\nin:fn|local\n```\n\n``` javascript\nin:fn|local={params}\n```\n\n``` javascript\nout:fn\n```\n\n``` javascript\nout:fn={params}\n```\n\n``` javascript\nout:fn|global\n```\n\n``` javascript\nout:fn|global={params}\n```\n\n``` javascript\nout:fn|local\n```\n\n``` javascript\nout:fn|local={params}\n```\n\nSimilar to `transition:`, but only applies to elements entering (`in:`) or leaving (`out:`) the DOM.\n\nUnlike with `transition:`, transitions applied with `in:` and `out:` are not bidirectional — an in transition will continue to 'play' alongside the out transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.\n\n``` javascript\n{#if visible}\n    <div in:fly out:fade>flies in, fades out</div>\n{/if}\n```\n\n## animate:*fn*\n\n``` javascript\nanimate:name\n```\n\n``` javascript\nanimate:name={params}\n```\n\n``` javascript\nanimation = (node: HTMLElement, { from: DOMRect, to: DOMRect } , params: any) => {\n    delay?: number,\n    duration?: number,\n    easing?: (t: number) => number,\n    css?: (t: number, u: number) => string,\n    tick?: (t: number, u: number) => void\n}\n```\n\n``` javascript\nDOMRect {\n    bottom: number,\n    height: number,\n    ​​left: number,\n    right: number,\n    ​top: number,\n    width: number,\n    x: number,\n    y: number\n}\n```\n\nAn animation is triggered when the contents of a [keyed each block](logic-blocks#each) are re-ordered. Animations do not run when an element is added or removed, only when the index of an existing data item within the each block changes. Animate directives must be on an element that is an *immediate* child of a keyed each block.\n\nAnimations can be used with Svelte's [built-in animation functions](svelte-animate) or [custom animation functions](element-directives#custom-animation-functions).\n\n``` javascript\n<!-- When `list` is reordered the animation will run-->\n{#each list as item, index (item)}\n    <li animate:flip>{item}</li>\n{/each}\n```\n\n## Animation Parameters\n\nAs with actions and transitions, animations can have parameters.\n\n(The double `{{curlies}}` aren't a special syntax; this is an object literal inside an expression tag.)\n\n``` javascript\n{#each list as item, index (item)}\n    <li animate:flip={{ delay: 500 }}>{item}</li>\n{/each}\n```\n\n## Custom animation functions\n\nAnimations can use custom functions that provide the `node`, an `animation` object and any `parameters` as arguments. The `animation` parameter is an object containing `from` and `to` properties each containing a [DOMRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect#Properties) describing the geometry of the element in its `start` and `end` positions. The `from` property is the DOMRect of the element in its starting position, and the `to` property is the DOMRect of the element in its final position after the list has been reordered and the DOM updated.\n\nIf the returned object has a `css` method, Svelte will create a CSS animation that plays on the element.\n\nThe `t` argument passed to `css` is a value that goes from `0` and `1` after the `easing` function has been applied. The `u` argument is equal to `1 - t`.\n\nThe function is called repeatedly *before* the animation begins, with different `t` and `u` arguments.\n\n``` javascript\n<script>\n    import { cubicOut } from 'svelte/easing';\n\n    /**\n     * @param {HTMLElement} node\n     * @param {{ from: DOMRect; to: DOMRect }} states\n     * @param {any} params\n     */\n    function whizz(node, { from, to }, params) {\n        const dx = from.left - to.left;\n        const dy = from.top - to.top;\n\n        const d = Math.sqrt(dx * dx + dy * dy);\n\n        return {\n            delay: 0,\n            duration: Math.sqrt(d) * 120,\n            easing: cubicOut,\n            css: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`\n        };\n    }\n</script>\n\n{#each list as item, index (item)}\n    <div animate:whizz>{item}</div>\n{/each}\n```\n\nA custom animation function can also return a `tick` function, which is called *during* the animation with the same `t` and `u` arguments.\n\n> If it's possible to use `css` instead of `tick`, do so — CSS animations can run off the main thread, preventing jank on slower devices.\n\n``` javascript\n<script>\n    import { cubicOut } from 'svelte/easing';\n\n    /**\n     * @param {HTMLElement} node\n     * @param {{ from: DOMRect; to: DOMRect }} states\n     * @param {any} params\n     */\n    function whizz(node, { from, to }, params) {\n        const dx = from.left - to.left;\n        const dy = from.top - to.top;\n\n        const d = Math.sqrt(dx * dx + dy * dy);\n\n        return {\n            delay: 0,\n            duration: Math.sqrt(d) * 120,\n            easing: cubicOut,\n            tick: (t, u) => Object.assign(node.style, { color: t > 0.5 ? 'Pink' : 'Blue' })\n        };\n    }\n</script>\n\n{#each list as item, index (item)}\n    <div animate:whizz>{item}</div>\n{/each}\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/element-directives](https://svelte.dev/docs/element-directives)"
- name: EnableSourcemap
  id: svelte-compiler#types-enablesourcemap
  summary: null
  belongs_to: svelte-compiler
  description: |-
    ### EnableSourcemap

    ``` javascript
    type EnableSourcemap =
        | boolean
        | { js: boolean; css: boolean };
    ```
- name: Enhancing built-in DOM types
  id: typescript#enhancing-built-in-dom-types
  summary: Svelte provides a best effort of all the HTML DOM types that exist
  belongs_to: typescript
  description: |-
    ## Enhancing built-in DOM types

    Svelte provides a best effort of all the HTML DOM types that exist. Sometimes you may want to use experimental attributes or custom events coming from an action. In these cases, TypeScript will throw a type error, saying that it does not know these types. If it's a non-experimental standard attribute/event, this may very well be a missing typing from our [HTML typings](https://github.com/sveltejs/svelte/blob/master/packages/svelte/elements.d.ts). In that case, you are welcome to open an issue and/or a PR fixing it.

    In case this is a custom or experimental attribute/event, you can enhance the typings like this:

    additional-svelte-typings.d.ts

    ``` javascript
    declare namespace svelteHTML {
        // enhance elements
        interface IntrinsicElements {
            'my-custom-element': { someattribute: string; 'on:event': (e: CustomEvent<any>) => void };
        }
        // enhance attributes
        interface HTMLAttributes<T> {
            // If you want to use on:beforeinstallprompt
            'on:beforeinstallprompt'?: (event: any) => any;
            // If you want to use myCustomAttribute={..} (note: all lowercase)
            mycustomattribute?: any; // You can replace any with something more specific if you like
        }
    }
    ```

    Then make sure that `d.ts` file is referenced in your `tsconfig.json`. If it reads something like `"include": ["src/**/*"]` and your `d.ts` file is inside `src`, it should work. You may need to reload for the changes to take effect.

    Since Svelte version 4.2 / `svelte-check` version 3.5 / VS Code extension version 107.10.0 you can also declare the typings by augmenting the `svelte/elements` module like this:

    additional-svelte-typings.d.ts

    ``` javascript
    import { HTMLButtonAttributes } from 'svelte/elements';


    declare module 'svelte/elements' {
        export interface SvelteHTMLElements {
            'custom-button': HTMLButtonAttributes;
        }


        // allows for more granular control over what element to add the typings to
        export interface HTMLButtonAttributes {
            veryexperimentalattribute?: string;
        }
    }


    export {}; // ensure this is not an ambient module, else types will be overridden instead of augmented
    ```
- name: Events
  id: typescript#script-lang-ts-events
  summary: null
  belongs_to: typescript
  description: |-
    ### Events

    Events can be typed with `createEventDispatcher`:

    ``` javascript
    <script lang="ts">
        import { createEventDispatcher } from 'svelte';

        const dispatch = createEventDispatcher<{
            event: null; // does not accept a payload
            click: string; // has a required string payload
            type: string | null; // has an optional string payload
        }>();

        function handleClick() {
            dispatch('event');
            dispatch('click', 'hello');
        }

        function handleType() {
            dispatch('event');
            dispatch('type', Math.random() > 0.5 ? 'world' : null);
        }
    </script>

    <button on:click={handleClick} on:keydown={handleType}>Click</button>
    ```
- name: Experimental advanced typings
  id: typescript#experimental-advanced-typings
  summary: A few features are missing from taking full advantage of TypeScript in more advanced use cases like typing that a component implements a certain interface, explicitly typing slots, or using generics
  belongs_to: typescript
  description: |-
    ## Experimental advanced typings

    A few features are missing from taking full advantage of TypeScript in more advanced use cases like typing that a component implements a certain interface, explicitly typing slots, or using generics. These things are possible using experimental advanced type capabilities. See [this RFC](https://github.com/dummdidumm/rfcs/blob/ts-typedefs-within-svelte-components/text/ts-typing-props-slots-events.md) for more information on how to make use of them.

    > The API is experimental and may change at any point
- name: fade
  id: svelte-transition#fade
  summary: Animates the opacity of an element from 0 to the current opacity for in transitions and from the current opacity to 0 for out transitions
  belongs_to: svelte-transition
  description: |-
    ## fade

    ``` javascript
    function fade(
        node: Element,
        { delay, duration, easing }?: FadeParams | undefined
    ): TransitionConfig;
    ```

    ``` javascript
    transition:fade={params}
    ```

    ``` javascript
    in:fade={params}
    ```

    ``` javascript
    out:fade={params}
    ```

    Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.

    `fade` accepts the following parameters:

    - `delay` (`number`, default 0) — milliseconds before starting
    - `duration` (`number`, default 400) — milliseconds the transition lasts
    - `easing` (`function`, default `linear`) — an [easing function](svelte-easing)

    You can see the `fade` transition in action in the [transition tutorial](https://learn.svelte.dev/tutorial/transition).

    ``` javascript
    <script>
        import { fade } from 'svelte/transition';
    </script>

    {#if condition}
        <div transition:fade={{ delay: 250, duration: 300 }}>fades in and out</div>
    {/if}
    ```
- name: FadeParams
  id: svelte-transition#types-fadeparams
  summary: null
  belongs_to: svelte-transition
  description: |-
    ### FadeParams

    ``` javascript
    interface FadeParams {…}
    ```

    ``` javascript
    delay?: number;
    ```

    ``` javascript
    duration?: number;
    ```

    ``` javascript
    easing?: EasingFunction;
    ```
- name: faq
  id: faq
  summary: We think the best way to get started is playing through the interactive tutorial
  description: "# Frequently asked questions\n\n## I'm new to Svelte. Where should I start?\n\nWe think the best way to get started is playing through the interactive [tutorial](https://learn.svelte.dev/). Each step there is mainly focused on one specific aspect and is easy to follow. You'll be editing and running real Svelte components right in your browser.\n\nFive to ten minutes should be enough to get you up and running. An hour and a half should get you through the entire tutorial.\n\n## Where can I get support?\n\nIf your question is about certain syntax, the [API page](https://svelte.dev/docs) is a good place to start.\n\nStack Overflow is a popular forum to ask code-level questions or if you’re stuck with a specific error. Read through the existing questions tagged with [Svelte](https://stackoverflow.com/questions/tagged/svelte+or+svelte-3) or [ask your own](https://stackoverflow.com/questions/ask?tags=svelte)!\n\nThere are online forums and chats which are a great place for discussion about best practices, application architecture or just to get to know fellow Svelte users. [Our Discord](https://svelte.dev/chat) or [the Reddit channel](https://www.reddit.com/r/sveltejs/) are examples of that. If you have an answerable code-level question, Stack Overflow is usually a better fit.\n\n## Are there any third-party resources?\n\nSvelte Society maintains a [list of books and videos](https://sveltesociety.dev/resources).\n\n## How can I get VS Code to syntax-highlight my .svelte files?\n\nThere is an [official VS Code extension for Svelte](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode).\n\n## Is there a tool to automatically format my .svelte files?\n\nYou can use prettier with the [prettier-plugin-svelte](https://www.npmjs.com/package/prettier-plugin-svelte) plugin.\n\n## How do I document my components?\n\nIn editors which use the Svelte Language Server you can document Components, functions and exports using specially formatted comments.\n\n```` javascript\n<script>\n    /** What should we call the user? */\n    export let name = 'world';\n</script>\n\n<!--\n@component\nHere's some documentation for this component.\nIt will show up on hover.\n\n- You can use markdown here.\n- You can also use code blocks here.\n- Usage:\n  ```tsx\n  <main name=\"Arethra\">\n  ```\n-->\n<main>\n    <h1>\n        Hello, {name}\n    </h1>\n</main>\n````\n\nNote: The `@component` is necessary in the HTML comment which describes your component.\n\n## Does Svelte scale?\n\nThere will be a blog post about this eventually, but in the meantime, check out [this issue](https://github.com/sveltejs/svelte/issues/2546).\n\n## Is there a UI component library?\n\nThere are several UI component libraries as well as standalone components. Find them under the [design systems section of the components page](https://sveltesociety.dev/components#design-systems) on the Svelte Society website.\n\n## How do I test Svelte apps?\n\nHow your application is structured and where logic is defined will determine the best way to ensure it is properly tested. It is important to note that not all logic belongs within a component - this includes concerns such as data transformation, cross-component state management, and logging, among others. Remember that the Svelte library has its own test suite, so you do not need to write tests to validate implementation details provided by Svelte.\n\nA Svelte application will typically have three different types of tests: Unit, Component, and End-to-End (E2E).\n\n*Unit Tests*: Focus on testing business logic in isolation. Often this is validating individual functions and edge cases. By minimizing the surface area of these tests they can be kept lean and fast, and by extracting as much logic as possible from your Svelte components more of your application can be covered using them. When creating a new SvelteKit project, you will be asked whether you would like to setup [Vitest](https://vitest.dev/) for unit testing. There are a number of other test runners that could be used as well.\n\n*Component Tests*: Validating that a Svelte component mounts and interacts as expected throughout its lifecycle requires a tool that provides a Document Object Model (DOM). Components can be compiled (since Svelte is a compiler and not a normal library) and mounted to allow asserting against element structure, listeners, state, and all the other capabilities provided by a Svelte component. Tools for component testing range from an in-memory implementation like jsdom paired with a test runner like [Vitest](https://vitest.dev/) to solutions that leverage an actual browser to provide a visual testing capability such as [Playwright](https://playwright.dev/docs/test-components) or [Cypress](https://www.cypress.io/).\n\n*End-to-End Tests*: To ensure your users are able to interact with your application it is necessary to test it as a whole in a manner as close to production as possible. This is done by writing end-to-end (E2E) tests which load and interact with a deployed version of your application in order to simulate how the user will interact with your application. When creating a new SvelteKit project, you will be asked whether you would like to setup [Playwright](https://playwright.dev/) for end-to-end testing. There are many other E2E test libraries available for use as well.\n\nSome resources for getting started with testing:\n\n- [Svelte Testing Library](https://testing-library.com/docs/svelte-testing-library/example/)\n- [Svelte Component Testing in Cypress](https://docs.cypress.io/guides/component-testing/svelte/overview)\n- [Example using vitest](https://github.com/vitest-dev/vitest/tree/main/examples/svelte)\n- [Example using uvu test runner with JSDOM](https://github.com/lukeed/uvu/tree/master/examples/svelte)\n- [Test Svelte components using Vitest & Playwright](https://davipon.hashnode.dev/test-svelte-component-using-vitest-playwright)\n- [Component testing with WebdriverIO](https://webdriver.io/docs/component-testing/svelte)\n\n## Is there a router?\n\nThe official routing library is [SvelteKit](https://kit.svelte.dev/). SvelteKit provides a filesystem router, server-side rendering (SSR), and hot module reloading (HMR) in one easy-to-use package. It shares similarities with Next.js for React.\n\nHowever, you can use any router library. A lot of people use [page.js](https://github.com/visionmedia/page.js). There's also [navaid](https://github.com/lukeed/navaid), which is very similar. And [universal-router](https://github.com/kriasoft/universal-router), which is isomorphic with child routes, but without built-in history support.\n\nIf you prefer a declarative HTML approach, there's the isomorphic [svelte-routing](https://github.com/EmilTholin/svelte-routing) library and a fork of it called [svelte-navigator](https://github.com/mefechoel/svelte-navigator) containing some additional functionality.\n\nIf you need hash-based routing on the client side, check out [svelte-spa-router](https://github.com/ItalyPaleAle/svelte-spa-router) or [abstract-state-router](https://github.com/TehShrike/abstract-state-router/).\n\n[Routify](https://routify.dev) is another filesystem-based router, similar to SvelteKit's router. Version 3 supports Svelte's native SSR.\n\nYou can see a [community-maintained list of routers on sveltesociety.dev](https://sveltesociety.dev/components#routers).\n\n## Can I tell Svelte not to remove my unused styles?\n\nNo. Svelte removes the styles from the component and warns you about them in order to prevent issues that would otherwise arise.\n\nSvelte's component style scoping works by generating a class unique to the given component, adding it to the relevant elements in the component that are under Svelte's control, and then adding it to each of the selectors in that component's styles. When the compiler can't see what elements a style selector applies to, there would be two bad options for keeping it:\n\n- If it keeps the selector and adds the scoping class to it, the selector will likely not match the expected elements in the component, and they definitely won't if they were created by a child component or `{@html ...}`.\n- If it keeps the selector without adding the scoping class to it, the given style will become a global style, affecting your entire page.\n\nIf you need to style something that Svelte can't identify at compile time, you will need to explicitly opt into global styles by using `:global(...)`. But also keep in mind that you can wrap `:global(...)` around only part of a selector. `.foo :global(.bar) { ... }` will style any `.bar` elements that appear within the component's `.foo` elements. As long as there's some parent element in the current component to start from, partially global selectors like this will almost always be able to get you what you want.\n\n## Is Svelte v2 still available?\n\nNew features aren't being added to it, and bugs will probably only be fixed if they are extremely nasty or present some sort of security vulnerability.\n\nThe documentation is still available [here](https://v2.svelte.dev/guide).\n\n## How do I do hot module reloading?\n\nWe recommend using [SvelteKit](https://kit.svelte.dev/), which supports HMR out of the box and is built on top of [Vite](https://vitejs.dev/) and [svelte-hmr](https://github.com/sveltejs/svelte-hmr). There are also community plugins for [rollup](https://github.com/rixo/rollup-plugin-svelte-hot) and [webpack](https://github.com/sveltejs/svelte-loader).\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/faq](https://svelte.dev/docs/faq)"
- name: flip
  id: svelte-animate#flip
  summary: The flip function calculates the start and end position of an element and animates between them, translating the x and y values
  belongs_to: svelte-animate
  description: |-
    ## flip

    ``` javascript
    function flip(
        node: Element,
        {
            from,
            to
        }: {
            from: DOMRect;
            to: DOMRect;
        },
        params?: FlipParams
    ): AnimationConfig;
    ```

    ``` javascript
    animate:flip={params}
    ```

    The `flip` function calculates the start and end position of an element and animates between them, translating the `x` and `y` values. `flip` stands for [First, Last, Invert, Play](https://aerotwist.com/blog/flip-your-animations/).

    `flip` accepts the following parameters:

    - `delay` (`number`, default 0) — milliseconds before starting
    - `duration` (`number` \| `function`, default `d => Math.sqrt(d) * 120`) — see below
    - `easing` (`function`, default `cubicOut`) — an [easing function](svelte-easing)

    `duration` can be provided as either:

    - a `number`, in milliseconds.
    - a function, `distance: number => duration: number`, receiving the distance the element will travel in pixels and returning the duration in milliseconds. This allows you to assign a duration that is relative to the distance travelled by each element.

    You can see a full example on the [animations tutorial](https://learn.svelte.dev/tutorial/animate).

    ``` javascript
    <script>
        import { flip } from 'svelte/animate';
        import { quintOut } from 'svelte/easing';

        let list = [1, 2, 3];
    </script>

    {#each list as n (n)}
        <div animate:flip={{ delay: 250, duration: 250, easing: quintOut }}>
            {n}
        </div>
    {/each}
    ```
- name: FlipParams
  id: svelte-animate#types-flipparams
  summary: © 2016–2023 Rich Harris and contributors Licensed under the MIT License
  belongs_to: svelte-animate
  description: "### FlipParams\n\n``` javascript\ninterface FlipParams {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number | ((len: number) => number);\n```\n\n``` javascript\neasing?: (t: number) => number;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-animate](https://svelte.dev/docs/svelte-animate)"
- name: fly
  id: svelte-transition#fly
  summary: Animates the x and y positions and the opacity of an element
  belongs_to: svelte-transition
  description: |-
    ## fly

    ``` javascript
    function fly(
        node: Element,
        {
            delay,
            duration,
            easing,
            x,
            y,
            opacity
        }?: FlyParams | undefined
    ): TransitionConfig;
    ```

    ``` javascript
    transition:fly={params}
    ```

    ``` javascript
    in:fly={params}
    ```

    ``` javascript
    out:fly={params}
    ```

    Animates the x and y positions and the opacity of an element. `in` transitions animate from the provided values, passed as parameters to the element's default values. `out` transitions animate from the element's default values to the provided values.

    `fly` accepts the following parameters:

    - `delay` (`number`, default 0) — milliseconds before starting
    - `duration` (`number`, default 400) — milliseconds the transition lasts
    - `easing` (`function`, default `cubicOut`) — an [easing function](svelte-easing)
    - `x` (`number | string`, default 0) - the x offset to animate out to and in from
    - `y` (`number | string`, default 0) - the y offset to animate out to and in from
    - `opacity` (`number`, default 0) - the opacity value to animate out to and in from

    x and y use `px` by default but support css units, for example `x: '100vw'` or `y: '50%'`. You can see the `fly` transition in action in the [transition tutorial](https://learn.svelte.dev/tutorial/adding-parameters-to-transitions).

    ``` javascript
    <script>
        import { fly } from 'svelte/transition';
        import { quintOut } from 'svelte/easing';
    </script>

    {#if condition}
        <div
            transition:fly={{ delay: 250, duration: 300, x: 100, y: 500, opacity: 0.5, easing: quintOut }}
        >
            flies in and out
        </div>
    {/if}
    ```
- name: FlyParams
  id: svelte-transition#types-flyparams
  summary: null
  belongs_to: svelte-transition
  description: |-
    ### FlyParams

    ``` javascript
    interface FlyParams {…}
    ```

    ``` javascript
    delay?: number;
    ```

    ``` javascript
    duration?: number;
    ```

    ``` javascript
    easing?: EasingFunction;
    ```

    ``` javascript
    x?: number | string;
    ```

    ``` javascript
    y?: number | string;
    ```

    ``` javascript
    opacity?: number;
    ```
- name: get
  id: svelte-store#get
  summary: Generally, you should read the value of a store by subscribing to it and using the value as it changes over time
  belongs_to: svelte-store
  description: |-
    ## get

    ``` javascript
    function get<T>(store: Readable<T>): T;
    ```

    Generally, you should read the value of a store by subscribing to it and using the value as it changes over time. Occasionally, you may need to retrieve the value of a store to which you're not subscribed. `get` allows you to do so.

    > This works by creating a subscription, reading the value, then unsubscribing. It's therefore not recommended in hot code paths.

    ``` javascript
    import { get } from 'svelte/store';


    const value = get(store);
    ```
- name: getAllContexts
  id: svelte#getallcontexts
  summary: Retrieves the whole context map that belongs to the closest parent component
  belongs_to: svelte
  description: |-
    ## getAllContexts

    ``` javascript
    function getAllContexts<
        T extends Map<any, any> = Map<any, any>
    >(): T;
    ```

    Retrieves the whole context map that belongs to the closest parent component. Must be called during component initialisation. Useful, for example, if you programmatically create a component and want to pass the existing context to it.

    ``` javascript
    <script>
        import { getAllContexts } from 'svelte';

        const contexts = getAllContexts();
    </script>
    ```
- name: getContext
  id: svelte#getcontext
  summary: Retrieves the context that belongs to the closest parent component with the specified key
  belongs_to: svelte
  description: |-
    ## getContext

    ``` javascript
    function getContext<T>(key: any): T;
    ```

    Retrieves the context that belongs to the closest parent component with the specified `key`. Must be called during component initialisation.

    ``` javascript
    <script>
        import { getContext } from 'svelte';

        const answer = getContext('answer');
    </script>
    ```
- name: Getting help
  id: index#getting-help
  summary: Don't be shy about asking for help in the Discord chatroom! You can also find answers on Stack Overflow
  description: "## Getting help\n\nDon't be shy about asking for help in the [Discord chatroom](https://svelte.dev/chat)! You can also find answers on [Stack Overflow](https://stackoverflow.com/questions/tagged/svelte).\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/introduction](https://svelte.dev/docs/introduction)"
- name: hasContext
  id: svelte#hascontext
  summary: Checks whether a given key has been set in the context of a parent component
  belongs_to: svelte
  description: |-
    ## hasContext

    ``` javascript
    function hasContext(key: any): boolean;
    ```

    Checks whether a given `key` has been set in the context of a parent component. Must be called during component initialisation.

    ``` javascript
    <script>
        import { hasContext } from 'svelte';

        if (hasContext('answer')) {
            // do something
        }
    </script>
    ```
- name: How can I get VS Code to syntax-highlight my .svelte files?
  id: faq#how-can-i-get-vs-code-to-syntax-highlight-my-svelte-files
  summary: There is an official VS Code extension for Svelte
  belongs_to: faq
  description: |-
    ## How can I get VS Code to syntax-highlight my .svelte files?

    There is an [official VS Code extension for Svelte](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode).
- name: How do I do hot module reloading?
  id: faq#how-do-i-do-hot-module-reloading
  summary: We recommend using SvelteKit, which supports HMR out of the box and is built on top of Vite and svelte-hmr
  belongs_to: faq
  description: "## How do I do hot module reloading?\n\nWe recommend using [SvelteKit](https://kit.svelte.dev/), which supports HMR out of the box and is built on top of [Vite](https://vitejs.dev/) and [svelte-hmr](https://github.com/sveltejs/svelte-hmr). There are also community plugins for [rollup](https://github.com/rixo/rollup-plugin-svelte-hot) and [webpack](https://github.com/sveltejs/svelte-loader).\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/faq](https://svelte.dev/docs/faq)"
- name: How do I document my components?
  id: faq#how-do-i-document-my-components
  summary: In editors which use the Svelte Language Server you can document Components, functions and exports using specially formatted comments
  belongs_to: faq
  description: |-
    ## How do I document my components?

    In editors which use the Svelte Language Server you can document Components, functions and exports using specially formatted comments.

    ```` javascript
    <script>
        /** What should we call the user? */
        export let name = 'world';
    </script>

    <!--
    @component
    Here's some documentation for this component.
    It will show up on hover.

    - You can use markdown here.
    - You can also use code blocks here.
    - Usage:
      ```tsx
      <main name="Arethra">
      ```
    -->
    <main>
        <h1>
            Hello, {name}
        </h1>
    </main>
    ````

    Note: The `@component` is necessary in the HTML comment which describes your component.
- name: How do I test Svelte apps?
  id: faq#how-do-i-test-svelte-apps
  summary: How your application is structured and where logic is defined will determine the best way to ensure it is properly tested
  belongs_to: faq
  description: |-
    ## How do I test Svelte apps?

    How your application is structured and where logic is defined will determine the best way to ensure it is properly tested. It is important to note that not all logic belongs within a component - this includes concerns such as data transformation, cross-component state management, and logging, among others. Remember that the Svelte library has its own test suite, so you do not need to write tests to validate implementation details provided by Svelte.

    A Svelte application will typically have three different types of tests: Unit, Component, and End-to-End (E2E).

    *Unit Tests*: Focus on testing business logic in isolation. Often this is validating individual functions and edge cases. By minimizing the surface area of these tests they can be kept lean and fast, and by extracting as much logic as possible from your Svelte components more of your application can be covered using them. When creating a new SvelteKit project, you will be asked whether you would like to setup [Vitest](https://vitest.dev/) for unit testing. There are a number of other test runners that could be used as well.

    *Component Tests*: Validating that a Svelte component mounts and interacts as expected throughout its lifecycle requires a tool that provides a Document Object Model (DOM). Components can be compiled (since Svelte is a compiler and not a normal library) and mounted to allow asserting against element structure, listeners, state, and all the other capabilities provided by a Svelte component. Tools for component testing range from an in-memory implementation like jsdom paired with a test runner like [Vitest](https://vitest.dev/) to solutions that leverage an actual browser to provide a visual testing capability such as [Playwright](https://playwright.dev/docs/test-components) or [Cypress](https://www.cypress.io/).

    *End-to-End Tests*: To ensure your users are able to interact with your application it is necessary to test it as a whole in a manner as close to production as possible. This is done by writing end-to-end (E2E) tests which load and interact with a deployed version of your application in order to simulate how the user will interact with your application. When creating a new SvelteKit project, you will be asked whether you would like to setup [Playwright](https://playwright.dev/) for end-to-end testing. There are many other E2E test libraries available for use as well.

    Some resources for getting started with testing:

    - [Svelte Testing Library](https://testing-library.com/docs/svelte-testing-library/example/)
    - [Svelte Component Testing in Cypress](https://docs.cypress.io/guides/component-testing/svelte/overview)
    - [Example using vitest](https://github.com/vitest-dev/vitest/tree/main/examples/svelte)
    - [Example using uvu test runner with JSDOM](https://github.com/lukeed/uvu/tree/master/examples/svelte)
    - [Test Svelte components using Vitest & Playwright](https://davipon.hashnode.dev/test-svelte-component-using-vitest-playwright)
    - [Component testing with WebdriverIO](https://webdriver.io/docs/component-testing/svelte)
- name: I'm new to Svelte. Where should I start?
  id: faq#i-m-new-to-svelte-where-should-i-start
  summary: We think the best way to get started is playing through the interactive tutorial
  belongs_to: faq
  description: |-
    ## I'm new to Svelte. Where should I start?

    We think the best way to get started is playing through the interactive [tutorial](https://learn.svelte.dev/). Each step there is mainly focused on one specific aspect and is easy to follow. You'll be editing and running real Svelte components right in your browser.

    Five to ten minutes should be enough to get you up and running. An hour and a half should get you through the entire tutorial.
- name: Image element bindings
  id: element-directives#image-element-bindings
  summary: null
  belongs_to: element-directives
  description: |-
    ## Image element bindings

    Image elements (`<img>`) have two readonly bindings:

    - `naturalWidth` (readonly) — the original width of the image, available after the image has loaded
    - `naturalHeight` (readonly) — the original height of the image, available after the image has loaded

    ``` javascript
    <img
        bind:naturalWidth
        bind:naturalHeight
    ></img>
    ```
- name: in:fn/out:fn
  id: element-directives#in-fn-out-fn
  summary: Similar to transition:, but only applies to elements entering (in:) or leaving (out:) the DOM
  belongs_to: element-directives
  description: |-
    ## in:*fn*/out:*fn*

    ``` javascript
    in:fn
    ```

    ``` javascript
    in:fn={params}
    ```

    ``` javascript
    in:fn|global
    ```

    ``` javascript
    in:fn|global={params}
    ```

    ``` javascript
    in:fn|local
    ```

    ``` javascript
    in:fn|local={params}
    ```

    ``` javascript
    out:fn
    ```

    ``` javascript
    out:fn={params}
    ```

    ``` javascript
    out:fn|global
    ```

    ``` javascript
    out:fn|global={params}
    ```

    ``` javascript
    out:fn|local
    ```

    ``` javascript
    out:fn|local={params}
    ```

    Similar to `transition:`, but only applies to elements entering (`in:`) or leaving (`out:`) the DOM.

    Unlike with `transition:`, transitions applied with `in:` and `out:` are not bidirectional — an in transition will continue to 'play' alongside the out transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.

    ``` javascript
    {#if visible}
        <div in:fly out:fade>flies in, fades out</div>
    {/if}
    ```
- name: Is Svelte v2 still available?
  id: faq#is-svelte-v2-still-available
  summary: New features aren't being added to it, and bugs will probably only be fixed if they are extremely nasty or present some sort of security vulnerability
  belongs_to: faq
  description: |-
    ## Is Svelte v2 still available?

    New features aren't being added to it, and bugs will probably only be fixed if they are extremely nasty or present some sort of security vulnerability.

    The documentation is still available [here](https://v2.svelte.dev/guide).
- name: Is there a router?
  id: faq#is-there-a-router
  summary: The official routing library is SvelteKit
  belongs_to: faq
  description: |-
    ## Is there a router?

    The official routing library is [SvelteKit](https://kit.svelte.dev/). SvelteKit provides a filesystem router, server-side rendering (SSR), and hot module reloading (HMR) in one easy-to-use package. It shares similarities with Next.js for React.

    However, you can use any router library. A lot of people use [page.js](https://github.com/visionmedia/page.js). There's also [navaid](https://github.com/lukeed/navaid), which is very similar. And [universal-router](https://github.com/kriasoft/universal-router), which is isomorphic with child routes, but without built-in history support.

    If you prefer a declarative HTML approach, there's the isomorphic [svelte-routing](https://github.com/EmilTholin/svelte-routing) library and a fork of it called [svelte-navigator](https://github.com/mefechoel/svelte-navigator) containing some additional functionality.

    If you need hash-based routing on the client side, check out [svelte-spa-router](https://github.com/ItalyPaleAle/svelte-spa-router) or [abstract-state-router](https://github.com/TehShrike/abstract-state-router/).

    [Routify](https://routify.dev) is another filesystem-based router, similar to SvelteKit's router. Version 3 supports Svelte's native SSR.

    You can see a [community-maintained list of routers on sveltesociety.dev](https://sveltesociety.dev/components#routers).
- name: Is there a tool to automatically format my .svelte files?
  id: faq#is-there-a-tool-to-automatically-format-my-svelte-files
  summary: You can use prettier with the prettier-plugin-svelte plugin
  belongs_to: faq
  description: |-
    ## Is there a tool to automatically format my .svelte files?

    You can use prettier with the [prettier-plugin-svelte](https://www.npmjs.com/package/prettier-plugin-svelte) plugin.
- name: Is there a UI component library?
  id: faq#is-there-a-ui-component-library
  summary: There are several UI component libraries as well as standalone components
  belongs_to: faq
  description: |-
    ## Is there a UI component library?

    There are several UI component libraries as well as standalone components. Find them under the [design systems section of the components page](https://sveltesociety.dev/components#design-systems) on the Svelte Society website.
- name: Limitations
  id: typescript#limitations
  summary: null
  belongs_to: typescript
  description: '## Limitations'
- name: logic-blocks
  id: logic-blocks
  summary: Content that is conditionally rendered can be wrapped in an if block
  description: "# Logic blocks\n\n## {#if ...}\n\n``` javascript\n{#if expression}...{/if}\n```\n\n``` javascript\n{#if expression}...{:else if expression}...{/if}\n```\n\n``` javascript\n{#if expression}...{:else}...{/if}\n```\n\nContent that is conditionally rendered can be wrapped in an if block.\n\n``` javascript\n{#if answer === 42}\n    <p>what was the question?</p>\n{/if}\n```\n\nAdditional conditions can be added with `{:else if expression}`, optionally ending in an `{:else}` clause.\n\n``` javascript\n{#if porridge.temperature > 100}\n    <p>too hot!</p>\n{:else if 80 > porridge.temperature}\n    <p>too cold!</p>\n{:else}\n    <p>just right!</p>\n{/if}\n```\n\n(Blocks don't have to wrap elements, they can also wrap text within elements!)\n\n## {#each ...}\n\n``` javascript\n{#each expression as name}...{/each}\n```\n\n``` javascript\n{#each expression as name, index}...{/each}\n```\n\n``` javascript\n{#each expression as name (key)}...{/each}\n```\n\n``` javascript\n{#each expression as name, index (key)}...{/each}\n```\n\n``` javascript\n{#each expression as name}...{:else}...{/each}\n```\n\nIterating over lists of values can be done with an each block.\n\n``` javascript\n<h1>Shopping list</h1>\n<ul>\n    {#each items as item}\n        <li>{item.name} x {item.qty}</li>\n    {/each}\n</ul>\n```\n\nYou can use each blocks to iterate over any array or array-like value — that is, any object with a `length` property.\n\nAn each block can also specify an *index*, equivalent to the second argument in an `array.map(...)` callback:\n\n``` javascript\n{#each items as item, i}\n    <li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}\n```\n\nIf a *key* expression is provided — which must uniquely identify each list item — Svelte will use it to diff the list when data changes, rather than adding or removing items at the end. The key can be any object, but strings and numbers are recommended since they allow identity to persist when the objects themselves change.\n\n``` javascript\n{#each items as item (item.id)}\n    <li>{item.name} x {item.qty}</li>\n{/each}\n\n<!-- or with additional index value -->\n{#each items as item, i (item.id)}\n    <li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}\n```\n\nYou can freely use destructuring and rest patterns in each blocks.\n\n``` javascript\n{#each items as { id, name, qty }, i (id)}\n    <li>{i + 1}: {name} x {qty}</li>\n{/each}\n\n{#each objects as { id, ...rest }}\n    <li><span>{id}</span><MyComponent {...rest} /></li>\n{/each}\n\n{#each items as [id, ...rest]}\n    <li><span>{id}</span><MyComponent values={rest} /></li>\n{/each}\n```\n\nAn each block can also have an `{:else}` clause, which is rendered if the list is empty.\n\n``` javascript\n{#each todos as todo}\n    <p>{todo.text}</p>\n{:else}\n    <p>No tasks today!</p>\n{/each}\n```\n\nSince Svelte 4 it is possible to iterate over iterables like `Map` or `Set`. Iterables need to be finite and static (they shouldn't change while being iterated over). Under the hood, they are transformed to an array using `Array.from` before being passed off to rendering. If you're writing performance-sensitive code, try to avoid iterables and use regular arrays as they are more performant.\n\n## {#await ...}\n\n``` javascript\n{#await expression}...{:then name}...{:catch name}...{/await}\n```\n\n``` javascript\n{#await expression}...{:then name}...{/await}\n```\n\n``` javascript\n{#await expression then name}...{/await}\n```\n\n``` javascript\n{#await expression catch name}...{/await}\n```\n\nAwait blocks allow you to branch on the three possible states of a Promise — pending, fulfilled or rejected. In SSR mode, only the pending state will be rendered on the server.\n\n``` javascript\n{#await promise}\n    <!-- promise is pending -->\n    <p>waiting for the promise to resolve...</p>\n{:then value}\n    <!-- promise was fulfilled -->\n    <p>The value is {value}</p>\n{:catch error}\n    <!-- promise was rejected -->\n    <p>Something went wrong: {error.message}</p>\n{/await}\n```\n\nThe `catch` block can be omitted if you don't need to render anything when the promise rejects (or no error is possible).\n\n``` javascript\n{#await promise}\n    <!-- promise is pending -->\n    <p>waiting for the promise to resolve...</p>\n{:then value}\n    <!-- promise was fulfilled -->\n    <p>The value is {value}</p>\n{/await}\n```\n\nIf you don't care about the pending state, you can also omit the initial block.\n\n``` javascript\n{#await promise then value}\n    <p>The value is {value}</p>\n{/await}\n```\n\nSimilarly, if you only want to show the error state, you can omit the `then` block.\n\n``` javascript\n{#await promise catch error}\n    <p>The error is {error}</p>\n{/await}\n```\n\n## {#key ...}\n\n``` javascript\n{#key expression}...{/key}\n```\n\nKey blocks destroy and recreate their contents when the value of an expression changes.\n\nThis is useful if you want an element to play its transition whenever a value changes.\n\n``` javascript\n{#key value}\n    <div transition:fade>{value}</div>\n{/key}\n```\n\nWhen used around components, this will cause them to be reinstantiated and reinitialised.\n\n``` javascript\n{#key value}\n    <Component />\n{/key}\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/logic-blocks](https://svelte.dev/docs/logic-blocks)"
- name: MarkupPreprocessor
  id: svelte-compiler#types-markuppreprocessor
  summary: A markup preprocessor that takes a string of code and returns a processed version
  belongs_to: svelte-compiler
  description: |-
    ### MarkupPreprocessor

    A markup preprocessor that takes a string of code and returns a processed version.

    ``` javascript
    type MarkupPreprocessor = (options: {
        /**
         * The whole Svelte file content
         */
        content: string;
        /**
         * The filename of the Svelte file
         */
        filename?: string;
    }) => Processed | void | Promise<Processed | void>;
    ```
- name: Media element bindings
  id: element-directives#media-element-bindings
  summary: Videos additionally have readonly videoWidth and videoHeight bindings
  belongs_to: element-directives
  description: |-
    ## Media element bindings

    Media elements (`<audio>` and `<video>`) have their own set of bindings — seven *readonly* ones...

    - `duration` (readonly) — the total duration of the video, in seconds
    - `buffered` (readonly) — an array of `{start, end}` objects
    - `played` (readonly) — ditto
    - `seekable` (readonly) — ditto
    - `seeking` (readonly) — boolean
    - `ended` (readonly) — boolean
    - `readyState` (readonly) — number between (and including) 0 and 4

    ...and five *two-way* bindings:

    - `currentTime` — the current playback time in the video, in seconds
    - `playbackRate` — how fast or slow to play the video, where 1 is 'normal'
    - `paused` — this one should be self-explanatory
    - `volume` — a value between 0 and 1
    - `muted` — a boolean value indicating whether the player is muted

    Videos additionally have readonly `videoWidth` and `videoHeight` bindings.

    ``` javascript
    <video
        src={clip}
        bind:duration
        bind:buffered
        bind:played
        bind:seekable
        bind:seeking
        bind:ended
        bind:readyState
        bind:currentTime
        bind:playbackRate
        bind:paused
        bind:volume
        bind:muted
        bind:videoWidth
        bind:videoHeight
    />
    ```
- name: Minimum version requirements
  id: v4-migration-guide#minimum-version-requirements
  summary: null
  belongs_to: v4-migration-guide
  description: |-
    ## Minimum version requirements

    - Upgrade to Node 16 or higher. Earlier versions are no longer supported. ([\#8566](https://github.com/sveltejs/svelte/issues/8566))
    - If you are using SvelteKit, upgrade to 1.20.4 or newer ([sveltejs/kit#10172](https://github.com/sveltejs/kit/pull/10172))
    - If you are using Vite without SvelteKit, upgrade to `vite-plugin-svelte` 2.4.1 or newer ([\#8516](https://github.com/sveltejs/svelte/issues/8516))
    - If you are using webpack, upgrade to webpack 5 or higher and `svelte-loader` 3.1.8 or higher. Earlier versions are no longer supported. ([\#8515](https://github.com/sveltejs/svelte/issues/8515), [198dbcf](https://github.com/sveltejs/svelte/commit/198dbcf))
    - If you are using Rollup, upgrade to `rollup-plugin-svelte` 7.1.5 or higher ([198dbcf](https://github.com/sveltejs/svelte/commit/198dbcf))
    - If you are using TypeScript, upgrade to TypeScript 5 or higher. Lower versions might still work, but no guarantees are made about that. ([\#8488](https://github.com/sveltejs/svelte/issues/8488))
- name: New eslint package
  id: v4-migration-guide#new-eslint-package
  summary: eslint-plugin-svelte3 is deprecated
  belongs_to: v4-migration-guide
  description: |-
    ## New eslint package

    `eslint-plugin-svelte3` is deprecated. It may still work with Svelte 4 but we make no guarantees about that. We recommend switching to our new package [eslint-plugin-svelte](https://github.com/sveltejs/eslint-plugin-svelte). See [this Github post](https://github.com/sveltejs/kit/issues/10242#issuecomment-1610798405) for an instruction how to migrate. Alternatively, you can create a new project using `npm create svelte@latest`, select the eslint (and possibly TypeScript) option and then copy over the related files into your existing project.
- name: No TS in markup
  id: typescript#limitations-no-ts-in-markup
  summary: You cannot use TypeScript in your template's markup
  belongs_to: typescript
  description: |-
    ### No TS in markup

    You cannot use TypeScript in your template's markup. For example, the following does not work:

    ``` javascript
    <script lang="ts">
        let count = 10;
    </script>

    <h1>Count as string: {count as string}!</h1> <!-- ❌ Does not work -->
    {#if count > 4}
        {@const countString: string = count} <!-- ❌ Does not work -->
        {countString}
    {/if}
    ```
- name: on:eventname
  id: element-directives#on-eventname
  summary: 'Use the on: directive to listen to DOM events'
  belongs_to: element-directives
  description: "## on:*eventname*\n\n``` javascript\non:eventname={handler}\n```\n\n``` javascript\non:eventname|modifiers={handler}\n```\n\nUse the `on:` directive to listen to DOM events.\n\nApp.svelte\n\n``` javascript\n<script>\n    let count = 0;\n\n    /** @param {MouseEvent} event */\n    function handleClick(event) {\n        count += 1;\n    }\n</script>\n\n<button on:click={handleClick}>\n    count: {count}\n</button>\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    let count = 0;\n    \n    function handleClick(event: MouseEvent) {\n        count += 1;\n    }\n</script>\n\n<button on:click={handleClick}>\n    count: {count}\n</button>\n```\n\nHandlers can be declared inline with no performance penalty. As with attributes, directive values may be quoted for the sake of syntax highlighters.\n\n``` javascript\n<button on:click={() => (count += 1)}>\n    count: {count}\n</button>\n```\n\nAdd *modifiers* to DOM events with the `|` character.\n\n``` javascript\n<form on:submit|preventDefault={handleSubmit}>\n    <!-- the `submit` event's default is prevented,\n         so the page won't reload -->\n</form>\n```\n\nThe following modifiers are available:\n\n- `preventDefault` — calls `event.preventDefault()` before running the handler\n- `stopPropagation` — calls `event.stopPropagation()`, preventing the event reaching the next element\n- `stopImmediatePropagation` - calls `event.stopImmediatePropagation()`, preventing other listeners of the same event from being fired.\n- `passive` — improves scrolling performance on touch/wheel events (Svelte will add it automatically where it's safe to do so)\n- `nonpassive` — explicitly set `passive: false`\n- `capture` — fires the handler during the *capture* phase instead of the *bubbling* phase\n- `once` — remove the handler after the first time it runs\n- `self` — only trigger handler if `event.target` is the element itself\n- `trusted` — only trigger handler if `event.isTrusted` is `true`. I.e. if the event is triggered by a user action.\n\nModifiers can be chained together, e.g. `on:click|once|capture={...}`.\n\nIf the `on:` directive is used without a value, the component will *forward* the event, meaning that a consumer of the component can listen for it.\n\n``` javascript\n<button on:click> The component itself will emit the click event </button>\n```\n\nIt's possible to have multiple event listeners for the same event:\n\n``` javascript\n<script>\n    let counter = 0;\n    function increment() {\n        counter = counter + 1;\n    }\n\n    /** @param {MouseEvent} event */\n    function track(event) {\n        trackEvent(event);\n    }\n</script>\n\n<button on:click={increment} on:click={track}>Click me!</button>\n```"
- name: on:eventname
  id: component-directives#on-eventname
  summary: Components can emit events using createEventDispatcher or by forwarding DOM events
  belongs_to: component-directives
  description: |-
    ## on:*eventname*

    ``` javascript
    on:eventname={handler}
    ```

    Components can emit events using [`createEventDispatcher`](svelte#createeventdispatcher) or by forwarding DOM events.

    ``` javascript
    <script>
        import { createEventDispatcher } from 'svelte';

        const dispatch = createEventDispatcher();
    </script>

    <!-- programmatic dispatching -->
    <button on:click={() => dispatch('hello')}> one </button>

    <!-- declarative event forwarding -->
    <button on:click> two </button>
    ```

    Listening for component events looks the same as listening for DOM events:

    ``` javascript
    <SomeComponent on:whatever={handler} />
    ```

    As with DOM events, if the `on:` directive is used without a value, the event will be forwarded, meaning that a consumer can listen for it.

    ``` javascript
    <SomeComponent on:whatever />
    ```
- name: onDestroy
  id: svelte#ondestroy
  summary: Schedules a callback to run immediately before the component is unmounted
  belongs_to: svelte
  description: |-
    ## onDestroy

    ``` javascript
    function onDestroy(fn: () => any): void;
    ```

    Schedules a callback to run immediately before the component is unmounted.

    Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.

    ``` javascript
    <script>
        import { onDestroy } from 'svelte';

        onDestroy(() => {
            console.log('the component is being destroyed');
        });
    </script>
    ```
- name: onMount
  id: svelte#onmount
  summary: The onMount function schedules a callback to run as soon as the component has been mounted to the DOM
  belongs_to: svelte
  description: |-
    ## onMount

    ``` javascript
    function onMount<T>(
        fn: () =>
            | NotFunction<T>
            | Promise<NotFunction<T>>
            | (() => any)
    ): void;
    ```

    The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM. It must be called during the component's initialisation (but doesn't need to live *inside* the component; it can be called from an external module).

    `onMount` does not run inside a [server-side component](server-side-component-api).

    ``` javascript
    <script>
        import { onMount } from 'svelte';

        onMount(() => {
            console.log('the component has mounted');
        });
    </script>
    ```

    If a function is returned from `onMount`, it will be called when the component is unmounted.

    ``` javascript
    <script>
        import { onMount } from 'svelte';

        onMount(() => {
            const interval = setInterval(() => {
                console.log('beep');
            }, 1000);

            return () => clearInterval(interval);
        });
    </script>
    ```

    > This behaviour will only work when the function passed to `onMount` *synchronously* returns a value. `async` functions always return a `Promise`, and as such cannot *synchronously* return a function.
- name: Other breaking changes
  id: v4-migration-guide#other-breaking-changes
  summary: © 2016–2023 Rich Harris and contributors Licensed under the MIT License
  belongs_to: v4-migration-guide
  description: "## Other breaking changes\n\n- the `inert` attribute is now applied to outroing elements to make them invisible to assistive technology and prevent interaction. ([\\#8628](https://github.com/sveltejs/svelte/pull/8628))\n- the runtime now uses `classList.toggle(name, boolean)` which may not work in very old browsers. Consider using a [polyfill](https://github.com/eligrey/classList.js) if you need to support these browsers. ([\\#8629](https://github.com/sveltejs/svelte/issues/8629))\n- the runtime now uses the `CustomEvent` constructor which may not work in very old browsers. Consider using a [polyfill](https://github.com/theftprevention/event-constructor-polyfill/tree/master) if you need to support these browsers. ([\\#8775](https://github.com/sveltejs/svelte/pull/8775))\n- people implementing their own stores from scratch using the [`StartStopNotifier`](svelte-store#types-startstopnotifier) interface (which is passed to the create function of `writable` etc) from `svelte/store` now need to pass an update function in addition to the set function. This has no effect on people using stores or creating stores using the existing Svelte stores. ([\\#6750](https://github.com/sveltejs/svelte/issues/6750))\n- `derived` will now throw an error on falsy values instead of stores passed to it. ([\\#7947](https://github.com/sveltejs/svelte/issues/7947))\n- type definitions for `svelte/internal` were removed to further discourage usage of those internal methods which are not public API. Most of these will likely change for Svelte 5\n- Removal of DOM nodes is now batched which slightly changes its order, which might affect the order of events fired if you're using a `MutationObserver` on these elements ([\\#8763](https://github.com/sveltejs/svelte/pull/8763))\n- if you enhanced the global typings through the `svelte.JSX` namespace before, you need to migrate this to use the `svelteHTML` namespace. Similarly if you used the `svelte.JSX` namespace to use type definitions from it, you need to migrate those to use the types from `svelte/elements` instead. You can find more information about what to do [here](https://github.com/sveltejs/language-tools/blob/master/docs/preprocessors/typescript.md#im-getting-deprecation-warnings-for-sveltejsx--i-want-to-migrate-to-the-new-typings)\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/v4-migration-guide](https://svelte.dev/docs/v4-migration-guide)"
- name: Other build tools
  id: typescript#setup-other-build-tools
  summary: If you're using tools like Rollup or Webpack instead, install their respective Svelte plugins
  belongs_to: typescript
  description: |-
    ### Other build tools

    If you're using tools like Rollup or Webpack instead, install their respective Svelte plugins. For Rollup that's [rollup-plugin-svelte](https://github.com/sveltejs/rollup-plugin-svelte) and for Webpack that's [svelte-loader](https://github.com/sveltejs/svelte-loader). For both, you need to install `typescript` and `svelte-preprocess` and add the preprocessor to the plugin config (see the respective READMEs for more info). If you're starting a new project, you can also use the [rollup](https://github.com/sveltejs/template) or [webpack](https://github.com/sveltejs/template-webpack) template to scaffold the setup from a script.

    > If you're starting a new project, we recommend using SvelteKit or Vite instead
- name: parse
  id: svelte-compiler#parse
  summary: The parse function parses a component, returning only its abstract syntax tree
  belongs_to: svelte-compiler
  description: |-
    ## parse

    ``` javascript
    function parse(
        template: string,
        options?: ParserOptions
    ): Ast;
    ```

    The `parse` function parses a component, returning only its abstract syntax tree. Unlike compiling with the `generate: false` option, this will not perform any validation or other analysis of the component beyond parsing it. Note that the returned AST is not considered public API, so breaking changes could occur at any point in time.

    ``` javascript
    import { parse } from 'svelte/compiler';


    const ast = parse(source, { filename: 'App.svelte' });
    ```
- name: preprocess
  id: svelte-compiler#preprocess
  summary: A number of official and community-maintained preprocessing plugins are available to allow you to use Svelte with tools like TypeScript, PostCSS, SCSS, and Less
  belongs_to: svelte-compiler
  description: |-
    ## preprocess

    ``` javascript
    function preprocess(
        source: string,
        preprocessor: PreprocessorGroup | PreprocessorGroup[],
        options?:
            | {
                    filename?: string | undefined;
              }
            | undefined
    ): Promise<Processed>;
    ```

    A number of [official and community-maintained preprocessing plugins](https://sveltesociety.dev/tools#preprocessors) are available to allow you to use Svelte with tools like TypeScript, PostCSS, SCSS, and Less.

    You can write your own preprocessor using the `svelte.preprocess` API.

    The `preprocess` function provides convenient hooks for arbitrarily transforming component source code. For example, it can be used to convert a `<style lang="sass">` block into vanilla CSS.

    The first argument is the component source code. The second is an array of *preprocessors* (or a single preprocessor, if you only have one), where a preprocessor is an object with a `name` which is required, and `markup`, `script` and `style` functions, each of which is optional.

    The `markup` function receives the entire component source text, along with the component's `filename` if it was specified in the third argument.

    The `script` and `style` functions receive the contents of `<script>` and `<style>` elements respectively (`content`) as well as the entire component source text (`markup`). In addition to `filename`, they get an object of the element's attributes.

    Each `markup`, `script` or `style` function must return an object (or a Promise that resolves to an object) with a `code` property, representing the transformed source code. Optionally they can return an array of `dependencies` which represents files to watch for changes, and a `map` object which is a sourcemap mapping back the transformation to the original code. `script` and `style` preprocessors can optionally return a record of attributes which represent the updated attributes on the script/style tag.

    > Preprocessor functions should return a `map` object whenever possible or else debugging becomes harder as stack traces can't link to the original code correctly.

    ``` javascript
    import { preprocess } from 'svelte/compiler';
    import MagicString from 'magic-string';


    const { code } = await preprocess(
        source,
        {
            markup: ({ content, filename }) => {
                const pos = content.indexOf('foo');
                if (pos < 0) {
                    return { code: content };
                }
                const s = new MagicString(content, { filename });
                s.overwrite(pos, pos + 3, 'bar', { storeName: true });
                return {
                    code: s.toString(),
                    map: s.generateMap()
                };
            }
        },
        {
            filename: 'App.svelte'
        }
    );
    ```

    If a `dependencies` array is returned, it will be included in the result object. This is used by packages like [vite-plugin-svelte](https://github.com/sveltejs/vite-plugin-svelte) and [rollup-plugin-svelte](https://github.com/sveltejs/rollup-plugin-svelte) to watch additional files for changes, in the case where your `<style>` tag has an `@import` (for example).

    preprocess-sass.js

    ``` javascript
    import { preprocess } from 'svelte/compiler';
    import MagicString from 'magic-string';
    import sass from 'sass';
    import { dirname } from 'path';


    const { code } = await preprocess(
        source,
        {
            name: 'my-fancy-preprocessor',
            markup: ({ content, filename }) => {
                // Return code as is when no foo string present
                const pos = content.indexOf('foo');
                if (pos < 0) {
                    return;
                }


                // Replace foo with bar using MagicString which provides
                // a source map along with the changed code
                const s = new MagicString(content, { filename });
                s.overwrite(pos, pos + 3, 'bar', { storeName: true });


                return {
                    code: s.toString(),
                    map: s.generateMap({ hires: true, file: filename })
                };
            },
            style: async ({ content, attributes, filename }) => {
                // only process <style lang="sass">
                if (attributes.lang !== 'sass') return;


                const { css, stats } = await new Promise((resolve, reject) =>
                    sass.render(
                        {
                            file: filename,
                            data: content,
                            includePaths: [dirname(filename)]
                        },
                        (err, result) => {
                            if (err) reject(err);
                            else resolve(result);
                        }
                    )
                );


                // remove lang attribute from style tag
                delete attributes.lang;


                return {
                    code: css.toString(),
                    dependencies: stats.includedFiles,
                    attributes
                };
            }
        },
        {
            filename: 'App.svelte'
        }
    );
    ```

    Multiple preprocessors can be used together. The output of the first becomes the input to the second. Within one preprocessor, `markup` runs first, then `script` and `style`.

    > In Svelte 3, all `markup` functions ran first, then all `script` and then all `style` preprocessors. This order was changed in Svelte 4.

    multiple-preprocessor.js

    ``` javascript
    import { preprocess } from 'svelte/compiler';


    const { code } = await preprocess(source, [
        {
            name: 'first preprocessor',
            markup: () => {
                console.log('this runs first');
            },
            script: () => {
                console.log('this runs second');
            },
            style: () => {
                console.log('this runs third');
            }
        },
        {
            name: 'second preprocessor',
            markup: () => {
                console.log('this runs fourth');
            },
            script: () => {
                console.log('this runs fifth');
            },
            style: () => {
                console.log('this runs sixth');
            }
        }
    ], {
        filename: 'App.svelte'
    });
    ```

    multiple-preprocessor.ts

    ``` javascript
    import { preprocess } from 'svelte/compiler';


    const { code } = await preprocess(
        source,
        [
            {
                name: 'first preprocessor',
                markup: () => {
                    console.log('this runs first');
                },
                script: () => {
                    console.log('this runs second');
                },
                style: () => {
                    console.log('this runs third');
                },
            },
            {
                name: 'second preprocessor',
                markup: () => {
                    console.log('this runs fourth');
                },
                script: () => {
                    console.log('this runs fifth');
                },
                style: () => {
                    console.log('this runs sixth');
                },
            },
        ],
        {
            filename: 'App.svelte',
        },
    );
    ```
- name: Preprocessor
  id: svelte-compiler#types-preprocessor
  summary: A script/style preprocessor that takes a string of code and returns a processed version
  belongs_to: svelte-compiler
  description: |-
    ### Preprocessor

    A script/style preprocessor that takes a string of code and returns a processed version.

    ``` javascript
    type Preprocessor = (options: {
        /**
         * The script/style tag content
         */
        content: string;
        /**
         * The attributes on the script/style tag
         */
        attributes: Record<string, string | boolean>;
        /**
         * The whole Svelte file content
         */
        markup: string;
        /**
         * The filename of the Svelte file
         */
        filename?: string;
    }) => Processed | void | Promise<Processed | void>;
    ```
- name: PreprocessorGroup
  id: svelte-compiler#types-preprocessorgroup
  summary: A preprocessor group is a set of preprocessors that are applied to a Svelte file
  belongs_to: svelte-compiler
  description: |-
    ### PreprocessorGroup

    A preprocessor group is a set of preprocessors that are applied to a Svelte file.

    ``` javascript
    interface PreprocessorGroup {…}
    ```

    ``` javascript
    name?: string;
    ```

    Name of the preprocessor. Will be a required option in the next major version

    ``` javascript
    markup?: MarkupPreprocessor;
    ```

    ``` javascript
    style?: Preprocessor;
    ```

    ``` javascript
    script?: Preprocessor;
    ```
- name: Preprocessors
  id: v4-migration-guide#preprocessors
  summary: The order in which preprocessors are applied has changed
  belongs_to: v4-migration-guide
  description: |-
    ## Preprocessors

    The order in which preprocessors are applied has changed. Now, preprocessors are executed in order, and within one group, the order is markup, script, style.

    ``` javascript
    import { preprocess } from 'svelte/compiler';


    const { code } = await preprocess(
        source,
        [
            {
                markup: () => {
                    console.log('markup-1');
                },
                script: () => {
                    console.log('script-1');
                },
                style: () => {
                    console.log('style-1');
                }
            },
            {
                markup: () => {
                    console.log('markup-2');
                },
                script: () => {
                    console.log('script-2');
                },
                style: () => {
                    console.log('style-2');
                }
            }
        ],
        {
            filename: 'App.svelte'
        }
    );


    // Svelte 3 logs:
    // markup-1
    // markup-2
    // script-1
    // script-2
    // style-1
    // style-2


    // Svelte 4 logs:
    // markup-1
    // script-1
    // style-1
    // markup-2
    // script-2
    // style-2
    ```

    This could affect you for example if you are using `MDsveX` - in which case you should make sure it comes before any script or style preprocessor.

    Each preprocessor must also have a name. ([\#8618](https://github.com/sveltejs/svelte/issues/8618))
- name: Processed
  id: svelte-compiler#types-processed
  summary: The result of a preprocessor run
  belongs_to: svelte-compiler
  description: |-
    ### Processed

    The result of a preprocessor run. If the preprocessor does not return a result, it is assumed that the code is unchanged.

    ``` javascript
    interface Processed {…}
    ```

    ``` javascript
    code: string;
    ```

    The new code

    ``` javascript
    map?: string | object;
    ```

    A source map mapping back to the original code

    ``` javascript
    dependencies?: string[];
    ```

    A list of additional files to watch for changes

    ``` javascript
    attributes?: Record<string, string | boolean>;
    ```

    Only for script/style preprocessors: The updated attributes to set on the tag. If undefined, attributes stay unchanged.

    ``` javascript
    toString?: () => string;
    ```
- name: Props
  id: typescript#script-lang-ts-props
  summary: null
  belongs_to: typescript
  description: |-
    ### Props

    Props can be typed directly on the `export let` statement:

    ``` javascript
    <script lang="ts">
        export let name: string;
    </script>
    ```
- name: Reactive Declarations
  id: typescript#limitations-reactive-declarations
  summary: You cannot type your reactive declarations with TypeScript in the way you type a variable
  belongs_to: typescript
  description: |-
    ### Reactive Declarations

    You cannot type your reactive declarations with TypeScript in the way you type a variable. For example, the following does not work:

    ``` javascript
    <script lang="ts">
        let count = 0;

        $: doubled: number = count * 2; // ❌ Does not work
    </script>
    ```

    You cannot add a `: TYPE` because it's invalid syntax in this position. Instead, you can move the definition to a `let` statement just above:

    ``` javascript
    <script lang="ts">
        let count = 0;

        let doubled: number;
        $: doubled = count * 2;
    </script>
    ```
- name: Readable
  id: svelte-store#types-readable
  summary: Readable interface for subscribing
  belongs_to: svelte-store
  description: |-
    ### Readable

    Readable interface for subscribing.

    ``` javascript
    interface Readable<T> {…}
    ```

    ``` javascript
    subscribe(this: void, run: Subscriber<T>, invalidate?: Invalidator<T>): Unsubscriber;
    ```

    - `run` subscription callback
    - `invalidate` cleanup callback

    Subscribe on value changes.
- name: readable
  id: svelte-store#readable
  summary: Creates a store whose value cannot be set from 'outside', the first argument is the store's initial value, and the second argument to readable is the same as the second argument to writable
  belongs_to: svelte-store
  description: |-
    ## readable

    ``` javascript
    function readable<T>(
        value?: T | undefined,
        start?: StartStopNotifier<T> | undefined
    ): Readable<T>;
    ```

    Creates a store whose value cannot be set from 'outside', the first argument is the store's initial value, and the second argument to `readable` is the same as the second argument to `writable`.

    ``` javascript
    import { readable } from 'svelte/store';


    const time = readable(new Date(), (set) => {
        set(new Date());


        const interval = setInterval(() => {
            set(new Date());
        }, 1000);


        return () => clearInterval(interval);
    });


    const ticktock = readable('tick', (set, update) => {
        const interval = setInterval(() => {
            update((sound) => (sound === 'tick' ? 'tock' : 'tick'));
        }, 1000);


        return () => clearInterval(interval);
    });
    ```
- name: readonly
  id: svelte-store#readonly
  summary: This simple helper function makes a store readonly
  belongs_to: svelte-store
  description: |-
    ## readonly

    ``` javascript
    function readonly<T>(store: Readable<T>): Readable<T>;
    ```

    This simple helper function makes a store readonly. You can still subscribe to the changes from the original one using this new readable store.

    ``` javascript
    import { readonly, writable } from 'svelte/store';


    const writableStore = writable(1);
    const readableStore = readonly(writableStore);


    readableStore.subscribe(console.log);


    writableStore.set(2); // console: 2
    readableStore.set(2); // ERROR
    ```
- name: Removal of CJS related output
  id: v4-migration-guide#removal-of-cjs-related-output
  summary: Svelte no longer supports the CommonJS (CJS) format for compiler output and has also removed the svelte/register hook and the CJS runtime version
  belongs_to: v4-migration-guide
  description: |-
    ## Removal of CJS related output

    Svelte no longer supports the CommonJS (CJS) format for compiler output and has also removed the `svelte/register` hook and the CJS runtime version. If you need to stay on the CJS output format, consider using a bundler to convert Svelte's ESM output to CJS in a post-build step. ([\#8613](https://github.com/sveltejs/svelte/issues/8613))
- name: scale
  id: svelte-transition#scale
  summary: Animates the opacity and scale of an element
  belongs_to: svelte-transition
  description: |-
    ## scale

    ``` javascript
    function scale(
        node: Element,
        {
            delay,
            duration,
            easing,
            start,
            opacity
        }?: ScaleParams | undefined
    ): TransitionConfig;
    ```

    ``` javascript
    transition:scale={params}
    ```

    ``` javascript
    in:scale={params}
    ```

    ``` javascript
    out:scale={params}
    ```

    Animates the opacity and scale of an element. `in` transitions animate from an element's current (default) values to the provided values, passed as parameters. `out` transitions animate from the provided values to an element's default values.

    `scale` accepts the following parameters:

    - `delay` (`number`, default 0) — milliseconds before starting
    - `duration` (`number`, default 400) — milliseconds the transition lasts
    - `easing` (`function`, default `cubicOut`) — an [easing function](svelte-easing)
    - `start` (`number`, default 0) - the scale value to animate out to and in from
    - `opacity` (`number`, default 0) - the opacity value to animate out to and in from

    ``` javascript
    <script>
        import { scale } from 'svelte/transition';
        import { quintOut } from 'svelte/easing';
    </script>

    {#if condition}
        <div transition:scale={{ duration: 500, delay: 500, opacity: 0.5, start: 0.5, easing: quintOut }}>
            scales in and out
        </div>
    {/if}
    ```
- name: ScaleParams
  id: svelte-transition#types-scaleparams
  summary: null
  belongs_to: svelte-transition
  description: |-
    ### ScaleParams

    ``` javascript
    interface ScaleParams {…}
    ```

    ``` javascript
    delay?: number;
    ```

    ``` javascript
    duration?: number;
    ```

    ``` javascript
    easing?: EasingFunction;
    ```

    ``` javascript
    start?: number;
    ```

    ``` javascript
    opacity?: number;
    ```
- name: server-side-component-api
  id: server-side-component-api
  summary: Unlike client-side components, server-side components don't have a lifespan after you render them — their whole job is to create some HTML and CSS
  description: "# Server-side component API\n\n``` javascript\nconst result = Component.render(...)\n```\n\nUnlike client-side components, server-side components don't have a lifespan after you render them — their whole job is to create some HTML and CSS. For that reason, the API is somewhat different.\n\nA server-side component exposes a `render` method that can be called with optional props. It returns an object with `head`, `html`, and `css` properties, where `head` contains the contents of any `<svelte:head>` elements encountered.\n\nYou can import a Svelte component directly into Node using [`svelte/register`](svelte-register).\n\n``` javascript\nrequire('svelte/register');\n\n\nconst App = require('./App.svelte').default;\n\n\nconst { head, html, css } = App.render({\n    answer: 42\n});\n```\n\nThe `.render()` method accepts the following parameters:\n\n| parameter | default | description                                        |\n|-----------|---------|----------------------------------------------------|\n| `props`   | `{}`    | An object of properties to supply to the component |\n| `options` | `{}`    | An object of options                               |\n\nThe `options` object takes in the following options:\n\n| option    | default     | description                                                              |\n|-----------|-------------|--------------------------------------------------------------------------|\n| `context` | `new Map()` | A `Map` of root-level context key-value pairs to supply to the component |\n\n``` javascript\nconst { head, html, css } = App.render(\n    // props\n    { answer: 42 },\n    // options\n    {\n        context: new Map([['context-key', 'context-value']])\n    }\n);\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/server-side-component-api](https://svelte.dev/docs/server-side-component-api)"
- name: setContext
  id: svelte#setcontext
  summary: Associates an arbitrary context object with the current component and the specified key and returns that object
  belongs_to: svelte
  description: |-
    ## setContext

    ``` javascript
    function setContext<T>(key: any, context: T): T;
    ```

    Associates an arbitrary `context` object with the current component and the specified `key` and returns that object. The context is then available to children of the component (including slotted content) with `getContext`.

    Like lifecycle functions, this must be called during component initialisation.

    ``` javascript
    <script>
        import { setContext } from 'svelte';

        setContext('answer', 42);
    </script>
    ```

    > Context is not inherently reactive. If you need reactive values in context then you can pass a store into context, which *will* be reactive.
- name: Setup
  id: typescript#setup
  summary: To use TypeScript within Svelte components, you need to add a preprocessor that will turn TypeScript into JavaScript
  belongs_to: typescript
  description: |-
    ## Setup

    To use TypeScript within Svelte components, you need to add a preprocessor that will turn TypeScript into JavaScript.
- name: slide
  id: svelte-transition#slide
  summary: Slides an element in and out
  belongs_to: svelte-transition
  description: |-
    ## slide

    ``` javascript
    function slide(
        node: Element,
        {
            delay,
            duration,
            easing,
            axis
        }?: SlideParams | undefined
    ): TransitionConfig;
    ```

    ``` javascript
    transition:slide={params}
    ```

    ``` javascript
    in:slide={params}
    ```

    ``` javascript
    out:slide={params}
    ```

    Slides an element in and out.

    `slide` accepts the following parameters:

    - `delay` (`number`, default 0) — milliseconds before starting
    - `duration` (`number`, default 400) — milliseconds the transition lasts
    - `easing` (`function`, default `cubicOut`) — an [easing function](svelte-easing)

    - `axis` (`x` \| `y`, default `y`) — the axis of motion along which the transition occurs

    ``` javascript
    <script>
        import { slide } from 'svelte/transition';
        import { quintOut } from 'svelte/easing';
    </script>

    {#if condition}
        <div transition:slide={{ delay: 250, duration: 300, easing: quintOut, axis: 'x' }}>
            slides in and out horizontally
        </div>
    {/if}
    ```
- name: SlideParams
  id: svelte-transition#types-slideparams
  summary: null
  belongs_to: svelte-transition
  description: |-
    ### SlideParams

    ``` javascript
    interface SlideParams {…}
    ```

    ``` javascript
    delay?: number;
    ```

    ``` javascript
    duration?: number;
    ```

    ``` javascript
    easing?: EasingFunction;
    ```

    ``` javascript
    axis?: 'x' | 'y';
    ```
- name: Slots
  id: typescript#script-lang-ts-slots
  summary: null
  belongs_to: typescript
  description: |-
    ### Slots

    Slot and slot prop types are inferred from the types of the slot props passed to them:

    ``` javascript
    <script lang="ts">
        export let name: string;
    </script>

    <slot {name} />

    <!-- Later -->
    <Comp let:name>
        <!--    ^ Inferred as string -->
        {name}
    </Comp>
    ```
- name: special-elements
  id: special-elements
  summary: Components can have child content, in the same way that elements can
  description: "# Special elements\n\n## \\<slot\\>\n\n``` javascript\n<slot><!-- optional fallback --></slot>\n```\n\n``` javascript\n<slot name=\"x\"><!-- optional fallback --></slot>\n```\n\n``` javascript\n<slot prop={value} />\n```\n\nComponents can have child content, in the same way that elements can.\n\nThe content is exposed in the child component using the `<slot>` element, which can contain fallback content that is rendered if no children are provided.\n\n``` javascript\n<!-- Widget.svelte -->\n<div>\n    <slot>\n        this fallback content will be rendered when no content is provided, like in the first example\n    </slot>\n</div>\n\n<!-- App.svelte -->\n<Widget />\n<!-- this component will render the default content -->\n\n<Widget>\n    <p>this is some child content that will overwrite the default slot content</p>\n</Widget>\n```\n\nNote: If you want to render regular `<slot>` element, You can use `<svelte:element this=\"slot\" />`.\n\n### \\<slot name=\"*name*\"\\>\n\nNamed slots allow consumers to target specific areas. They can also have fallback content.\n\n``` javascript\n<!-- Widget.svelte -->\n<div>\n    <slot name=\"header\">No header was provided</slot>\n    <p>Some content between header and footer</p>\n    <slot name=\"footer\" />\n</div>\n\n<!-- App.svelte -->\n<Widget>\n    <h1 slot=\"header\">Hello</h1>\n    <p slot=\"footer\">Copyright (c) 2019 Svelte Industries</p>\n</Widget>\n```\n\nComponents can be placed in a named slot using the syntax `<Component slot=\"name\" />`. In order to place content in a slot without using a wrapper element, you can use the special element `<svelte:fragment>`.\n\n``` javascript\n<!-- Widget.svelte -->\n<div>\n    <slot name=\"header\">No header was provided</slot>\n    <p>Some content between header and footer</p>\n    <slot name=\"footer\" />\n</div>\n\n<!-- App.svelte -->\n<Widget>\n    <HeaderComponent slot=\"header\" />\n    <svelte:fragment slot=\"footer\">\n        <p>All rights reserved.</p>\n        <p>Copyright (c) 2019 Svelte Industries</p>\n    </svelte:fragment>\n</Widget>\n```\n\n### $$slots\n\n`$$slots` is an object whose keys are the names of the slots passed into the component by the parent. If the parent does not pass in a slot with a particular name, that name will not be present in `$$slots`. This allows components to render a slot (and other elements, like wrappers for styling) only if the parent provides it.\n\nNote that explicitly passing in an empty named slot will add that slot's name to `$$slots`. For example, if a parent passes `<div slot=\"title\" />` to a child component, `$$slots.title` will be truthy within the child.\n\n``` javascript\n<!-- Card.svelte -->\n<div>\n    <slot name=\"title\" />\n    {#if $$slots.description}\n        <!-- This <hr> and slot will render only if a slot named \"description\" is provided. -->\n        <hr />\n        <slot name=\"description\" />\n    {/if}\n</div>\n\n<!-- App.svelte -->\n<Card>\n    <h1 slot=\"title\">Blog Post Title</h1>\n    <!-- No slot named \"description\" was provided so the optional slot will not be rendered. -->\n</Card>\n```\n\n### \\<slot key={*value*}\\>\n\nSlots can be rendered zero or more times and can pass values *back* to the parent using props. The parent exposes the values to the slot template using the `let:` directive.\n\nThe usual shorthand rules apply — `let:item` is equivalent to `let:item={item}`, and `<slot {item}>` is equivalent to `<slot item={item}>`.\n\n``` javascript\n<!-- FancyList.svelte -->\n<ul>\n    {#each items as item}\n        <li class=\"fancy\">\n            <slot prop={item} />\n        </li>\n    {/each}\n</ul>\n\n<!-- App.svelte -->\n<FancyList {items} let:prop={thing}>\n    <div>{thing.text}</div>\n</FancyList>\n```\n\nNamed slots can also expose values. The `let:` directive goes on the element with the `slot` attribute.\n\n``` javascript\n<!-- FancyList.svelte -->\n<ul>\n    {#each items as item}\n        <li class=\"fancy\">\n            <slot name=\"item\" {item} />\n        </li>\n    {/each}\n</ul>\n\n<slot name=\"footer\" />\n\n<!-- App.svelte -->\n<FancyList {items}>\n    <div slot=\"item\" let:item>{item.text}</div>\n    <p slot=\"footer\">Copyright (c) 2019 Svelte Industries</p>\n</FancyList>\n```\n\n## \\<svelte:self\\>\n\nThe `<svelte:self>` element allows a component to include itself, recursively.\n\nIt cannot appear at the top level of your markup; it must be inside an if or each block or passed to a component's slot to prevent an infinite loop.\n\n``` javascript\n<script>\n    /** @type {number} */\n    export let count;\n</script>\n\n{#if count > 0}\n    <p>counting down... {count}</p>\n    <svelte:self count={count - 1} />\n{:else}\n    <p>lift-off!</p>\n{/if}\n```\n\n## \\<svelte:component\\>\n\n``` javascript\n<svelte:component this={expression} />\n```\n\nThe `<svelte:component>` element renders a component dynamically, using the component constructor specified as the `this` property. When the property changes, the component is destroyed and recreated.\n\nIf `this` is falsy, no component is rendered.\n\n``` javascript\n<svelte:component this={currentSelection.component} foo={bar} />\n```\n\n## \\<svelte:element\\>\n\n``` javascript\n<svelte:element this={expression} />\n```\n\nThe `<svelte:element>` element lets you render an element of a dynamically specified type. This is useful for example when displaying rich text content from a CMS. Any properties and event listeners present will be applied to the element.\n\nThe only supported binding is `bind:this`, since the element type-specific bindings that Svelte does at build time (e.g. `bind:value` for input elements) do not work with a dynamic tag type.\n\nIf `this` has a nullish value, the element and its children will not be rendered.\n\nIf `this` is the name of a [void element](https://developer.mozilla.org/en-US/docs/Glossary/Void_element) (e.g., `br`) and `<svelte:element>` has child elements, a runtime error will be thrown in development mode.\n\n``` javascript\n<script>\n    let tag = 'div';\n\n    export let handler;\n</script>\n\n<svelte:element this={tag} on:click={handler}>Foo</svelte:element>\n```\n\n## \\<svelte:window\\>\n\n``` javascript\n<svelte:window on:event={handler} />\n```\n\n``` javascript\n<svelte:window bind:prop={value} />\n```\n\nThe `<svelte:window>` element allows you to add event listeners to the `window` object without worrying about removing them when the component is destroyed, or checking for the existence of `window` when server-side rendering.\n\nUnlike `<svelte:self>`, this element may only appear at the top level of your component and must never be inside a block or element.\n\n``` javascript\n<script>\n    /** @param {KeyboardEvent} event */\n    function handleKeydown(event) {\n        alert(`pressed the ${event.key} key`);\n    }\n</script>\n\n<svelte:window on:keydown={handleKeydown} />\n```\n\nYou can also bind to the following properties:\n\n- `innerWidth`\n- `innerHeight`\n- `outerWidth`\n- `outerHeight`\n- `scrollX`\n- `scrollY`\n- `online` — an alias for `window.navigator.onLine`\n- `devicePixelRatio`\n\nAll except `scrollX` and `scrollY` are readonly.\n\n``` javascript\n<svelte:window bind:scrollY={y} />\n```\n\n> Note that the page will not be scrolled to the initial value to avoid accessibility issues. Only subsequent changes to the bound variable of `scrollX` and `scrollY` will cause scrolling. However, if the scrolling behaviour is desired, call `scrollTo()` in `onMount()`.\n\n## \\<svelte:document\\>\n\n``` javascript\n<svelte:document on:event={handler} />\n```\n\n``` javascript\n<svelte:document bind:prop={value} />\n```\n\nSimilarly to `<svelte:window>`, this element allows you to add listeners to events on `document`, such as `visibilitychange`, which don't fire on `window`. It also lets you use [actions](element-directives#use-action) on `document`.\n\nAs with `<svelte:window>`, this element may only appear the top level of your component and must never be inside a block or element.\n\n``` javascript\n<svelte:document on:visibilitychange={handleVisibilityChange} use:someAction />\n```\n\nYou can also bind to the following properties:\n\n- `fullscreenElement`\n- `visibilityState`\n\nAll are readonly.\n\n## \\<svelte:body\\>\n\n``` javascript\n<svelte:body on:event={handler} />\n```\n\nSimilarly to `<svelte:window>`, this element allows you to add listeners to events on `document.body`, such as `mouseenter` and `mouseleave`, which don't fire on `window`. It also lets you use [actions](element-directives#use-action) on the `<body>` element.\n\nAs with `<svelte:window>` and `<svelte:document>`, this element may only appear the top level of your component and must never be inside a block or element.\n\n``` javascript\n<svelte:body on:mouseenter={handleMouseenter} on:mouseleave={handleMouseleave} use:someAction />\n```\n\n## \\<svelte:head\\>\n\n``` javascript\n<svelte:head>...</svelte:head>\n```\n\nThis element makes it possible to insert elements into `document.head`. During server-side rendering, `head` content is exposed separately to the main `html` content.\n\nAs with `<svelte:window>`, `<svelte:document>` and `<svelte:body>`, this element may only appear at the top level of your component and must never be inside a block or element.\n\n``` javascript\n<svelte:head>\n    <title>Hello world!</title>\n    <meta name=\"description\" content=\"This is where the description goes for SEO\" />\n</svelte:head>\n```\n\n## \\<svelte:options\\>\n\n``` javascript\n<svelte:options option={value} />\n```\n\nThe `<svelte:options>` element provides a place to specify per-component compiler options, which are detailed in the [compiler section](svelte-compiler#compile). The possible options are:\n\n- `immutable={true}` — you never use mutable data, so the compiler can do simple referential equality checks to determine if values have changed\n- `immutable={false}` — the default. Svelte will be more conservative about whether or not mutable objects have changed\n- `accessors={true}` — adds getters and setters for the component's props\n- `accessors={false}` — the default\n- `namespace=\"...\"` — the namespace where this component will be used, most commonly \"svg\"; use the \"foreign\" namespace to opt out of case-insensitive attribute names and HTML-specific warnings\n- `customElement=\"...\"` — the name to use when compiling this component as a custom element\n\n``` javascript\n<svelte:options customElement=\"my-custom-element\" />\n```\n\n## \\<svelte:fragment\\>\n\nThe `<svelte:fragment>` element allows you to place content in a [named slot](special-elements#slot-slot-name-name) without wrapping it in a container DOM element. This keeps the flow layout of your document intact.\n\n``` javascript\n<!-- Widget.svelte -->\n<div>\n    <slot name=\"header\">No header was provided</slot>\n    <p>Some content between header and footer</p>\n    <slot name=\"footer\" />\n</div>\n\n<!-- App.svelte -->\n<Widget>\n    <h1 slot=\"header\">Hello</h1>\n    <svelte:fragment slot=\"footer\">\n        <p>All rights reserved.</p>\n        <p>Copyright (c) 2019 Svelte Industries</p>\n    </svelte:fragment>\n</Widget>\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/special-elements](https://svelte.dev/docs/special-elements)"
- name: special-tags
  id: special-tags
  summary: In a text expression, characters like < and > are escaped; however, with HTML expressions, they're not
  description: "# Special tags\n\n## {@html ...}\n\n``` javascript\n{@html expression}\n```\n\nIn a text expression, characters like `<` and `>` are escaped; however, with HTML expressions, they're not.\n\nThe expression should be valid standalone HTML — `{@html \"<div>\"}content{@html \"</div>\"}` will *not* work, because `</div>` is not valid HTML. It also will *not* compile Svelte code.\n\n> Svelte does not sanitize expressions before injecting HTML. If the data comes from an untrusted source, you must sanitize it, or you are exposing your users to an XSS vulnerability.\n\n``` javascript\n<div class=\"blog-post\">\n    <h1>{post.title}</h1>\n    {@html post.content}\n</div>\n```\n\n## {@debug ...}\n\n``` javascript\n{@debug}\n```\n\n``` javascript\n{@debug var1, var2, ..., varN}\n```\n\nThe `{@debug ...}` tag offers an alternative to `console.log(...)`. It logs the values of specific variables whenever they change, and pauses code execution if you have devtools open.\n\n``` javascript\n<script>\n    let user = {\n        firstname: 'Ada',\n        lastname: 'Lovelace'\n    };\n</script>\n\n{@debug user}\n\n<h1>Hello {user.firstname}!</h1>\n```\n\n`{@debug ...}` accepts a comma-separated list of variable names (not arbitrary expressions).\n\n``` javascript\n<!-- Compiles -->\n{@debug user}\n{@debug user1, user2, user3}\n\n<!-- WON'T compile -->\n{@debug user.firstname}\n{@debug myArray[0]}\n{@debug !isReady}\n{@debug typeof user === 'object'}\n```\n\nThe `{@debug}` tag without any arguments will insert a `debugger` statement that gets triggered when *any* state changes, as opposed to the specified variables.\n\n## {@const ...}\n\n``` javascript\n{@const assignment}\n```\n\nThe `{@const ...}` tag defines a local constant.\n\n``` javascript\n<script>\n    export let boxes;\n</script>\n\n{#each boxes as box}\n    {@const area = box.width * box.height}\n    {box.width} * {box.height} = {area}\n{/each}\n```\n\n`{@const}` is only allowed as direct child of `{#if}`, `{:else if}`, `{:else}`, `{#each}`, `{:then}`, `{:catch}`, `<Component />` or `<svelte:fragment />`.\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/special-tags](https://svelte.dev/docs/special-tags)"
- name: Spring
  id: svelte-motion#types-spring
  summary: null
  belongs_to: svelte-motion
  description: |-
    ### Spring

    ``` javascript
    interface Spring<T> extends Readable<T> {…}
    ```

    ``` javascript
    set: (new_value: T, opts?: SpringUpdateOpts) => Promise<void>;
    ```

    ``` javascript
    update: (fn: Updater<T>, opts?: SpringUpdateOpts) => Promise<void>;
    ```

    ``` javascript
    precision: number;
    ```

    ``` javascript
    damping: number;
    ```

    ``` javascript
    stiffness: number;
    ```
- name: spring
  id: svelte-motion#spring
  summary: A spring store gradually changes to its target value based on its stiffness and damping parameters
  belongs_to: svelte-motion
  description: |-
    ## spring

    ``` javascript
    function spring<T = any>(
        value?: T | undefined,
        opts?: SpringOpts | undefined
    ): Spring<T>;
    ```

    A `spring` store gradually changes to its target value based on its `stiffness` and `damping` parameters. Whereas `tweened` stores change their values over a fixed duration, `spring` stores change over a duration that is determined by their existing velocity, allowing for more natural-seeming motion in many situations. The following options are available:

    - `stiffness` (`number`, default `0.15`) — a value between 0 and 1 where higher means a 'tighter' spring
    - `damping` (`number`, default `0.8`) — a value between 0 and 1 where lower means a 'springier' spring
    - `precision` (`number`, default `0.01`) — determines the threshold at which the spring is considered to have 'settled', where lower means more precise

    All of the options above can be changed while the spring is in motion, and will take immediate effect.

    ``` javascript
    import { spring } from 'svelte/motion';


    const size = spring(100);
    size.stiffness = 0.3;
    size.damping = 0.4;
    size.precision = 0.005;
    ```

    As with [`tweened`](svelte-motion#tweened) stores, `set` and `update` return a Promise that resolves if the spring settles.

    Both `set` and `update` can take a second argument — an object with `hard` or `soft` properties. `{ hard: true }` sets the target value immediately; `{ soft: n }` preserves existing momentum for `n` seconds before settling. `{ soft: true }` is equivalent to `{ soft: 0.5 }`.

    ``` javascript
    import { spring } from 'svelte/motion';


    const coords = spring({ x: 50, y: 50 });
    // updates the value immediately
    coords.set({ x: 100, y: 200 }, { hard: true });
    // preserves existing momentum for 1s
    coords.update(
        (target_coords, coords) => {
            return { x: target_coords.x, y: coords.y };
        },
        { soft: 1 }
    );
    ```

    [See a full example on the spring tutorial.](https://learn.svelte.dev/tutorial/springs)

    ``` javascript
    <script>
        import { spring } from 'svelte/motion';

        const coords = spring(
            { x: 50, y: 50 },
            {
                stiffness: 0.1,
                damping: 0.25
            }
        );
    </script>
    ```

    If the initial value is `undefined` or `null`, the first value change will take effect immediately, just as with `tweened` values (see above).

    ``` javascript
    import { spring } from 'svelte/motion';


    const size = spring();
    $: $size = big ? 100 : 10;
    ```
- name: Start a new project
  id: index#start-a-new-project
  summary: SvelteKit will handle calling the Svelte compiler to convert your .svelte files into .js files that create the DOM and .css files that style it
  description: |-
    ## Start a new project

    We recommend using [SvelteKit](https://kit.svelte.dev/), the official application framework from the Svelte team:

    ``` javascript
    npm create svelte@latest myapp
    cd myapp
    npm install
    npm run dev
    ```

    SvelteKit will handle calling [the Svelte compiler](https://www.npmjs.com/package/svelte) to convert your `.svelte` files into `.js` files that create the DOM and `.css` files that style it. It also provides all the other pieces you need to build a web application such as a development server, routing, deployment, and SSR support. [SvelteKit](https://kit.svelte.dev/) uses [Vite](https://vitejs.dev/) to build your code.
- name: StartStopNotifier
  id: svelte-store#types-startstopnotifier
  summary: Start and stop notification callbacks
  belongs_to: svelte-store
  description: |-
    ### StartStopNotifier

    Start and stop notification callbacks. This function is called when the first subscriber subscribes.

    ``` javascript
    type StartStopNotifier<T> = (
        set: (value: T) => void,
        update: (fn: Updater<T>) => void
    ) => void | (() => void);
    ```
- name: Store contract
  id: svelte-components#script-4-prefix-stores-with-$-to-access-their-values-store-contract
  summary: For interoperability with RxJS Observables, the .subscribe method is also allowed to return an object with an .unsubscribe method, rather than return the unsubscription function directly
  belongs_to: svelte-components
  description: |-
    #### Store contract

    ``` javascript
    store = { subscribe: (subscription: (value: any) => void) => (() => void), set?: (value: any) => void }
    ```

    You can create your own stores without relying on [`svelte/store`](svelte-store), by implementing the *store contract*:

    1.  A store must contain a `.subscribe` method, which must accept as its argument a subscription function. This subscription function must be immediately and synchronously called with the store's current value upon calling `.subscribe`. All of a store's active subscription functions must later be synchronously called whenever the store's value changes.
    2.  The `.subscribe` method must return an unsubscribe function. Calling an unsubscribe function must stop its subscription, and its corresponding subscription function must not be called again by the store.
    3.  A store may *optionally* contain a `.set` method, which must accept as its argument a new value for the store, and which synchronously calls all of the store's active subscription functions. Such a store is called a *writable store*.

    For interoperability with RxJS Observables, the `.subscribe` method is also allowed to return an object with an `.unsubscribe` method, rather than return the unsubscription function directly. Note however that unless `.subscribe` synchronously calls the subscription (which is not required by the Observable spec), Svelte will see the value of the store as `undefined` until it does.
- name: Stricter types for Svelte functions
  id: v4-migration-guide#stricter-types-for-svelte-functions
  summary: null
  belongs_to: v4-migration-guide
  description: |-
    ## Stricter types for Svelte functions

    There are now stricter types for `createEventDispatcher`, [`Action`](svelte-action#types-action), [`ActionReturn`](svelte-action#types-actionreturn), and `onMount`:

    - `createEventDispatcher` now supports specifying that a payload is optional, required, or non-existent, and the call sites are checked accordingly ([\#7224](https://github.com/sveltejs/svelte/issues/7224))

    ``` javascript
    import { createEventDispatcher } from 'svelte';


    const dispatch = createEventDispatcher<{
        optional: number | null;
        required: string;
        noArgument: null;
    }>();


    // Svelte version 3:
    dispatch('optional');
    dispatch('required'); // I can still omit the detail argument
    dispatch('noArgument', 'surprise'); // I can still add a detail argument


    // Svelte version 4 using TypeScript strict mode:
    dispatch('optional');
    dispatch('required'); // error, missing argument
    dispatch('noArgument', 'surprise'); // error, cannot pass an argument
    ```

    - [`Action`](svelte-action#types-action) and [`ActionReturn`](svelte-action#types-actionreturn) have a default parameter type of `undefined` now, which means you need to type the generic if you want to specify that this action receives a parameter. The migration script will migrate this automatically ([\#7442](https://github.com/sveltejs/svelte/pull/7442))

    &nbsp;

    - `onMount` now shows a type error if you return a function asynchronously from it, because this is likely a bug in your code where you expect the callback to be called on destroy, which it will only do for synchronously returned functions ([\#8136](https://github.com/sveltejs/svelte/issues/8136))

    &nbsp;
- name: style:property
  id: element-directives#style-property
  summary: 'The style: directive provides a shorthand for setting multiple styles on an element'
  belongs_to: element-directives
  description: |-
    ## style:*property*

    ``` javascript
    style:property={value}
    ```

    ``` javascript
    style:property="value"
    ```

    ``` javascript
    style:property
    ```

    The `style:` directive provides a shorthand for setting multiple styles on an element.

    ``` javascript
    <!-- These are equivalent -->
    <div style:color="red">...</div>
    <div style="color: red;">...</div>

    <!-- Variables can be used -->
    <div style:color={myColor}>...</div>

    <!-- Shorthand, for when property and variable name match -->
    <div style:color>...</div>

    <!-- Multiple styles can be included -->
    <div style:color style:width="12rem" style:background-color={darkMode ? 'black' : 'white'}>...</div>

    <!-- Styles can be marked as important -->
    <div style:color|important="red">...</div>
    ```

    When `style:` directives are combined with `style` attributes, the directives will take precedence:

    ``` javascript
    <div style="color: blue;" style:color="red">This will be red</div>
    ```
- name: Subscriber
  id: svelte-store#types-subscriber
  summary: Callback to inform of a value updates
  belongs_to: svelte-store
  description: |-
    ### Subscriber

    Callback to inform of a value updates.

    ``` javascript
    type Subscriber<T> = (value: T) => void;
    ```
- name: svelte
  id: svelte
  summary: The svelte package exposes lifecycle functions and the context API
  description: "# svelte\n\nThe `svelte` package exposes [lifecycle functions](https://learn.svelte.dev/tutorial/onmount) and the [context API](https://learn.svelte.dev/tutorial/context-api).\n\n## onMount\n\n``` javascript\nfunction onMount<T>(\n    fn: () =>\n        | NotFunction<T>\n        | Promise<NotFunction<T>>\n        | (() => any)\n): void;\n```\n\nThe `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM. It must be called during the component's initialisation (but doesn't need to live *inside* the component; it can be called from an external module).\n\n`onMount` does not run inside a [server-side component](server-side-component-api).\n\n``` javascript\n<script>\n    import { onMount } from 'svelte';\n\n    onMount(() => {\n        console.log('the component has mounted');\n    });\n</script>\n```\n\nIf a function is returned from `onMount`, it will be called when the component is unmounted.\n\n``` javascript\n<script>\n    import { onMount } from 'svelte';\n\n    onMount(() => {\n        const interval = setInterval(() => {\n            console.log('beep');\n        }, 1000);\n\n        return () => clearInterval(interval);\n    });\n</script>\n```\n\n> This behaviour will only work when the function passed to `onMount` *synchronously* returns a value. `async` functions always return a `Promise`, and as such cannot *synchronously* return a function.\n\n## beforeUpdate\n\n``` javascript\nfunction beforeUpdate(fn: () => any): void;\n```\n\nSchedules a callback to run immediately before the component is updated after any state change.\n\n> The first time the callback runs will be before the initial `onMount`\n\n``` javascript\n<script>\n    import { beforeUpdate } from 'svelte';\n\n    beforeUpdate(() => {\n        console.log('the component is about to update');\n    });\n</script>\n```\n\n## afterUpdate\n\n``` javascript\nfunction afterUpdate(fn: () => any): void;\n```\n\nSchedules a callback to run immediately after the component has been updated.\n\n> The first time the callback runs will be after the initial `onMount`\n\n``` javascript\n<script>\n    import { afterUpdate } from 'svelte';\n\n    afterUpdate(() => {\n        console.log('the component just updated');\n    });\n</script>\n```\n\n## onDestroy\n\n``` javascript\nfunction onDestroy(fn: () => any): void;\n```\n\nSchedules a callback to run immediately before the component is unmounted.\n\nOut of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.\n\n``` javascript\n<script>\n    import { onDestroy } from 'svelte';\n\n    onDestroy(() => {\n        console.log('the component is being destroyed');\n    });\n</script>\n```\n\n## tick\n\n``` javascript\nfunction tick(): Promise<void>;\n```\n\nReturns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.\n\n``` javascript\n<script>\n    import { beforeUpdate, tick } from 'svelte';\n\n    beforeUpdate(async () => {\n        console.log('the component is about to update');\n        await tick();\n        console.log('the component just updated');\n    });\n</script>\n```\n\n## setContext\n\n``` javascript\nfunction setContext<T>(key: any, context: T): T;\n```\n\nAssociates an arbitrary `context` object with the current component and the specified `key` and returns that object. The context is then available to children of the component (including slotted content) with `getContext`.\n\nLike lifecycle functions, this must be called during component initialisation.\n\n``` javascript\n<script>\n    import { setContext } from 'svelte';\n\n    setContext('answer', 42);\n</script>\n```\n\n> Context is not inherently reactive. If you need reactive values in context then you can pass a store into context, which *will* be reactive.\n\n## getContext\n\n``` javascript\nfunction getContext<T>(key: any): T;\n```\n\nRetrieves the context that belongs to the closest parent component with the specified `key`. Must be called during component initialisation.\n\n``` javascript\n<script>\n    import { getContext } from 'svelte';\n\n    const answer = getContext('answer');\n</script>\n```\n\n## hasContext\n\n``` javascript\nfunction hasContext(key: any): boolean;\n```\n\nChecks whether a given `key` has been set in the context of a parent component. Must be called during component initialisation.\n\n``` javascript\n<script>\n    import { hasContext } from 'svelte';\n\n    if (hasContext('answer')) {\n        // do something\n    }\n</script>\n```\n\n## getAllContexts\n\n``` javascript\nfunction getAllContexts<\n    T extends Map<any, any> = Map<any, any>\n>(): T;\n```\n\nRetrieves the whole context map that belongs to the closest parent component. Must be called during component initialisation. Useful, for example, if you programmatically create a component and want to pass the existing context to it.\n\n``` javascript\n<script>\n    import { getAllContexts } from 'svelte';\n\n    const contexts = getAllContexts();\n</script>\n```\n\n## createEventDispatcher\n\n``` javascript\nfunction createEventDispatcher<\n    EventMap extends Record<string, any> = any\n>(): EventDispatcher<EventMap>;\n```\n\nCreates an event dispatcher that can be used to dispatch [component events](component-directives#on-eventname). Event dispatchers are functions that can take two arguments: `name` and `detail`.\n\nComponent events created with `createEventDispatcher` create a [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent). These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture). The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail) property and can contain any type of data.\n\n``` javascript\n<script>\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n</script>\n\n<button on:click={() => dispatch('notify', 'detail value')}>Fire Event</button>\n```\n\nEvents dispatched from child components can be listened to in their parent. Any data provided when the event was dispatched is available on the `detail` property of the event object.\n\n``` javascript\n<script>\n    function callbackFunction(event) {\n        console.log(`Notify fired! Detail: ${event.detail}`);\n    }\n</script>\n\n<Child on:notify={callbackFunction} />\n```\n\nEvents can be cancelable by passing a third parameter to the dispatch function. The function returns `false` if the event is cancelled with `event.preventDefault()`, otherwise it returns `true`.\n\n``` javascript\n<script>\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    function notify() {\n        const shouldContinue = dispatch('notify', 'detail value', { cancelable: true });\n        if (shouldContinue) {\n            // no one called preventDefault\n        } else {\n            // a listener called preventDefault\n        }\n    }\n</script>\n```\n\nYou can type the event dispatcher to define which events it can receive. This will make your code more type safe both within the component (wrong calls are flagged) and when using the component (types of the events are now narrowed). See [here](typescript#script-lang-ts-events) how to do it.\n\n## Types\n\n### ComponentConstructorOptions\n\n``` javascript\ninterface ComponentConstructorOptions<\n    Props extends Record<string, any> = Record<string, any>\n> {…}\n```\n\n``` javascript\ntarget: Element | Document | ShadowRoot;\n```\n\n``` javascript\nanchor?: Element;\n```\n\n``` javascript\nprops?: Props;\n```\n\n``` javascript\ncontext?: Map<any, any>;\n```\n\n``` javascript\nhydrate?: boolean;\n```\n\n``` javascript\nintro?: boolean;\n```\n\n``` javascript\n$$inline?: boolean;\n```\n\n### ComponentEvents\n\nConvenience type to get the events the given component expects. Example:\n\n``` javascript\n<script lang=\"ts\">\n   import type { ComponentEvents } from 'svelte';\n   import Component from './Component.svelte';\n\n   function handleCloseEvent(event: ComponentEvents<Component>['close']) {\n      console.log(event.detail);\n   }\n</script>\n\n<Component on:close={handleCloseEvent} />\n```\n\n``` javascript\ntype ComponentEvents<Component extends SvelteComponent_1> =\n    Component extends SvelteComponent<any, infer Events>\n        ? Events\n        : never;\n```\n\n### ComponentProps\n\nConvenience type to get the props the given component expects. Example:\n\n``` javascript\n<script lang=\"ts\">\n    import type { ComponentProps } from 'svelte';\n    import Component from './Component.svelte';\n\n    const props: ComponentProps<Component> = { foo: 'bar' }; // Errors if these aren't the correct props\n</script>\n```\n\n``` javascript\ntype ComponentProps<Component extends SvelteComponent_1> =\n    Component extends SvelteComponent<infer Props>\n        ? Props\n        : never;\n```\n\n### ComponentType\n\nConvenience type to get the type of a Svelte component. Useful for example in combination with dynamic components using `<svelte:component>`.\n\nExample:\n\n``` javascript\n<script lang=\"ts\">\n    import type { ComponentType, SvelteComponent } from 'svelte';\n    import Component1 from './Component1.svelte';\n    import Component2 from './Component2.svelte';\n\n    const component: ComponentType = someLogic() ? Component1 : Component2;\n    const componentOfCertainSubType: ComponentType<SvelteComponent<{ needsThisProp: string }>> = someLogic() ? Component1 : Component2;\n</script>\n\n<svelte:component this={component} />\n<svelte:component this={componentOfCertainSubType} needsThisProp=\"hello\" />\n```\n\n``` javascript\ntype ComponentType<\n    Component extends SvelteComponent = SvelteComponent\n> = (new (\n    options: ComponentConstructorOptions<\n        Component extends SvelteComponent<infer Props>\n            ? Props\n            : Record<string, any>\n    >\n) => Component) & {\n    /** The custom element version of the component. Only present if compiled with the `customElement` compiler option */\n    element?: typeof HTMLElement;\n};\n```\n\n### SvelteComponent\n\nBase class for Svelte components with some minor dev-enhancements. Used when dev=true.\n\nCan be used to create strongly typed Svelte components.\n\n#### Example:\n\nYou have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:\n\n``` javascript\nimport { SvelteComponent } from \"svelte\";\nexport class MyComponent extends SvelteComponent<{foo: string}> {}\n```\n\nTyping this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:\n\n``` javascript\n<script lang=\"ts\">\n    import { MyComponent } from \"component-library\";\n</script>\n<MyComponent foo={'bar'} />\n```\n\n``` javascript\nclass SvelteComponent<\n    Props extends Record<string, any> = any,\n    Events extends Record<string, any> = any,\n    Slots extends Record<string, any> = any\n> extends SvelteComponent_1<Props, Events> {…}\n```\n\n``` javascript\n[prop: string]: any;\n```\n\n``` javascript\nconstructor(options: ComponentConstructorOptions<Props>);\n```\n\n``` javascript\n$capture_state(): void;\n```\n\n``` javascript\n$inject_state(): void;\n```\n\n### SvelteComponentTyped\n\n> Use `SvelteComponent` instead. See PR for more information: <https://github.com/sveltejs/svelte/pull/8512>\n\n``` javascript\nclass SvelteComponentTyped<\n    Props extends Record<string, any> = any,\n    Events extends Record<string, any> = any,\n    Slots extends Record<string, any> = any\n> extends SvelteComponent<Props, Events, Slots> {}\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte](https://svelte.dev/docs/svelte)"
- name: svelte-action
  id: svelte-action
  summary: Actions are functions that are called when an element is created
  description: "# svelte/action\n\nActions are functions that are called when an element is created. They can return an object with a `destroy` method that is called after the element is unmounted:\n\n``` javascript\n<script>\n    /** @type {import('svelte/action').Action}  */\n    function foo(node) {\n        // the node has been mounted in the DOM\n\n        return {\n            destroy() {\n                // the node has been removed from the DOM\n            }\n        };\n    }\n</script>\n\n<div use:foo />\n```\n\nAn action can have a parameter. If the returned value has an `update` method, it will be called immediately after Svelte has applied updates to the markup whenever that parameter changes.\n\n> Don't worry that we're redeclaring the `foo` function for every component instance — Svelte will hoist any functions that don't depend on local state out of the component definition.\n\n``` javascript\n<script>\n    /** @type {string} */\n    export let bar;\n\n    /** @type {import('svelte/action').Action<HTMLElement, string>}  */\n    function foo(node, bar) {\n        // the node has been mounted in the DOM\n\n        return {\n            update(bar) {\n                // the value of `bar` has changed\n            },\n\n            destroy() {\n                // the node has been removed from the DOM\n            }\n        };\n    }\n</script>\n\n<div use:foo={bar} />\n```\n\n## Attributes\n\nSometimes actions emit custom events and apply custom attributes to the element they are applied to. To support this, actions typed with [`Action`](svelte-action#types-action) or [`ActionReturn`](svelte-action#types-actionreturn) type can have a last parameter, `Attributes`:\n\n``` javascript\n<script>\n    /**\n     * @type {import('svelte/action').Action<HTMLDivElement, { prop: any }, { 'on:emit': (e: CustomEvent<string>) => void }>}\n     */\n    function foo(node, { prop }) {\n        // the node has been mounted in the DOM\n\n        //...LOGIC\n        node.dispatchEvent(new CustomEvent('emit', { detail: 'hello' }));\n\n        return {\n            destroy() {\n                // the node has been removed from the DOM\n            }\n        };\n    }\n</script>\n\n<div use:foo={{ prop: 'someValue' }} on:emit={handleEmit} />\n```\n\n## Types\n\n### Action\n\nActions are functions that are called when an element is created. You can use this interface to type such actions. The following example defines an action that only works on `<div>` elements and optionally accepts a parameter which it has a default value for:\n\n``` javascript\nexport const myAction: Action<HTMLDivElement, { someProperty: boolean } | undefined> = (node, param = { someProperty: true }) => {\n  // ...\n}\n```\n\n[`Action`](svelte-action#types-action)`<HTMLDivElement>` and [`Action`](svelte-action#types-action)`<HTMLDivElement, undefined>` both signal that the action accepts no parameters.\n\nYou can return an object with methods `update` and `destroy` from the function and type which additional attributes and events it has. See interface [`ActionReturn`](svelte-action#types-actionreturn) for more details.\n\nDocs: [https://svelte.dev/docs/svelte-action](svelte-action)\n\n``` javascript\ninterface Action<\n    Element = HTMLElement,\n    Parameter = undefined,\n    Attributes extends Record<string, any> = Record<\n        never,\n        any\n    >\n> {…}\n```\n\n``` javascript\n<Node extends Element>(\n    ...args: undefined extends Parameter\n        ? [node: Node, parameter?: Parameter]\n        : [node: Node, parameter: Parameter]\n): void | ActionReturn<Parameter, Attributes>;\n```\n\n### ActionReturn\n\nActions can return an object containing the two properties defined in this interface. Both are optional.\n\n- update: An action can have a parameter. This method will be called whenever that parameter changes, immediately after Svelte has applied updates to the markup. [`ActionReturn`](svelte-action#types-actionreturn) and [`ActionReturn`](svelte-action#types-actionreturn)`<undefined>` both mean that the action accepts no parameters.\n- destroy: Method that is called after the element is unmounted\n\nAdditionally, you can specify which additional attributes and events the action enables on the applied element. This applies to TypeScript typings only and has no effect at runtime.\n\nExample usage:\n\n``` javascript\ninterface Attributes {\n    newprop?: string;\n    'on:event': (e: CustomEvent<boolean>) => void;\n}\n\n\nexport function myAction(node: HTMLElement, parameter: Parameter): ActionReturn<Parameter, Attributes> {\n    // ...\n    return {\n        update: (updatedParameter) => {...},\n        destroy: () => {...}\n    };\n}\n```\n\nDocs: [https://svelte.dev/docs/svelte-action](svelte-action)\n\n``` javascript\ninterface ActionReturn<\n    Parameter = undefined,\n    Attributes extends Record<string, any> = Record<\n        never,\n        any\n    >\n> {…}\n```\n\n``` javascript\nupdate?: (parameter: Parameter) => void;\n```\n\n``` javascript\ndestroy?: () => void;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-action](https://svelte.dev/docs/svelte-action)"
- name: svelte-animate
  id: svelte-animate
  summary: The svelte/animate module exports one function for use with Svelte animations
  description: "# svelte/animate\n\nThe `svelte/animate` module exports one function for use with Svelte [animations](element-directives#animate-fn).\n\n## flip\n\n``` javascript\nfunction flip(\n    node: Element,\n    {\n        from,\n        to\n    }: {\n        from: DOMRect;\n        to: DOMRect;\n    },\n    params?: FlipParams\n): AnimationConfig;\n```\n\n``` javascript\nanimate:flip={params}\n```\n\nThe `flip` function calculates the start and end position of an element and animates between them, translating the `x` and `y` values. `flip` stands for [First, Last, Invert, Play](https://aerotwist.com/blog/flip-your-animations/).\n\n`flip` accepts the following parameters:\n\n- `delay` (`number`, default 0) — milliseconds before starting\n- `duration` (`number` \\| `function`, default `d => Math.sqrt(d) * 120`) — see below\n- `easing` (`function`, default `cubicOut`) — an [easing function](svelte-easing)\n\n`duration` can be provided as either:\n\n- a `number`, in milliseconds.\n- a function, `distance: number => duration: number`, receiving the distance the element will travel in pixels and returning the duration in milliseconds. This allows you to assign a duration that is relative to the distance travelled by each element.\n\nYou can see a full example on the [animations tutorial](https://learn.svelte.dev/tutorial/animate).\n\n``` javascript\n<script>\n    import { flip } from 'svelte/animate';\n    import { quintOut } from 'svelte/easing';\n\n    let list = [1, 2, 3];\n</script>\n\n{#each list as n (n)}\n    <div animate:flip={{ delay: 250, duration: 250, easing: quintOut }}>\n        {n}\n    </div>\n{/each}\n```\n\n## Types\n\n### AnimationConfig\n\n``` javascript\ninterface AnimationConfig {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number;\n```\n\n``` javascript\neasing?: (t: number) => number;\n```\n\n``` javascript\ncss?: (t: number, u: number) => string;\n```\n\n``` javascript\ntick?: (t: number, u: number) => void;\n```\n\n### FlipParams\n\n``` javascript\ninterface FlipParams {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number | ((len: number) => number);\n```\n\n``` javascript\neasing?: (t: number) => number;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-animate](https://svelte.dev/docs/svelte-animate)"
- name: svelte-compiler
  id: svelte-compiler
  summary: Typically, you won't interact with the Svelte compiler directly, but will instead integrate it into your build system using a bundler plugin
  description: "# svelte/compiler\n\nTypically, you won't interact with the Svelte compiler directly, but will instead integrate it into your build system using a bundler plugin. The bundler plugin that the Svelte team most recommends and invests in is [vite-plugin-svelte](https://github.com/sveltejs/vite-plugin-svelte). The [SvelteKit](https://kit.svelte.dev/) framework provides a setup leveraging `vite-plugin-svelte` to build applications as well as a [tool for packaging Svelte component libraries](https://kit.svelte.dev/docs/packaging). Svelte Society maintains a list of [other bundler plugins](https://sveltesociety.dev/tools/#bundling) for additional tools like Rollup and Webpack.\n\nNonetheless, it's useful to understand how to use the compiler, since bundler plugins generally expose compiler options to you.\n\n## compile\n\n``` javascript\nfunction compile(\n    source: string,\n    options?: CompileOptions\n): CompileResult;\n```\n\nThis is where the magic happens. `svelte.compile` takes your component source code, and turns it into a JavaScript module that exports a class.\n\n``` javascript\nimport { compile } from 'svelte/compiler';\n\n\nconst result = compile(source, {\n    // options\n});\n```\n\nRefer to [CompileOptions](#types-compileoptions) for all the available options.\n\nThe returned `result` object contains the code for your component, along with useful bits of metadata.\n\n``` javascript\nconst { js, css, ast, warnings, vars, stats } = compile(source);\n```\n\nRefer to [CompileResult](#types-compileresult) for a full description of the compile result.\n\n## parse\n\n``` javascript\nfunction parse(\n    template: string,\n    options?: ParserOptions\n): Ast;\n```\n\nThe `parse` function parses a component, returning only its abstract syntax tree. Unlike compiling with the `generate: false` option, this will not perform any validation or other analysis of the component beyond parsing it. Note that the returned AST is not considered public API, so breaking changes could occur at any point in time.\n\n``` javascript\nimport { parse } from 'svelte/compiler';\n\n\nconst ast = parse(source, { filename: 'App.svelte' });\n```\n\n## preprocess\n\n``` javascript\nfunction preprocess(\n    source: string,\n    preprocessor: PreprocessorGroup | PreprocessorGroup[],\n    options?:\n        | {\n                filename?: string | undefined;\n          }\n        | undefined\n): Promise<Processed>;\n```\n\nA number of [official and community-maintained preprocessing plugins](https://sveltesociety.dev/tools#preprocessors) are available to allow you to use Svelte with tools like TypeScript, PostCSS, SCSS, and Less.\n\nYou can write your own preprocessor using the `svelte.preprocess` API.\n\nThe `preprocess` function provides convenient hooks for arbitrarily transforming component source code. For example, it can be used to convert a `<style lang=\"sass\">` block into vanilla CSS.\n\nThe first argument is the component source code. The second is an array of *preprocessors* (or a single preprocessor, if you only have one), where a preprocessor is an object with a `name` which is required, and `markup`, `script` and `style` functions, each of which is optional.\n\nThe `markup` function receives the entire component source text, along with the component's `filename` if it was specified in the third argument.\n\nThe `script` and `style` functions receive the contents of `<script>` and `<style>` elements respectively (`content`) as well as the entire component source text (`markup`). In addition to `filename`, they get an object of the element's attributes.\n\nEach `markup`, `script` or `style` function must return an object (or a Promise that resolves to an object) with a `code` property, representing the transformed source code. Optionally they can return an array of `dependencies` which represents files to watch for changes, and a `map` object which is a sourcemap mapping back the transformation to the original code. `script` and `style` preprocessors can optionally return a record of attributes which represent the updated attributes on the script/style tag.\n\n> Preprocessor functions should return a `map` object whenever possible or else debugging becomes harder as stack traces can't link to the original code correctly.\n\n``` javascript\nimport { preprocess } from 'svelte/compiler';\nimport MagicString from 'magic-string';\n\n\nconst { code } = await preprocess(\n    source,\n    {\n        markup: ({ content, filename }) => {\n            const pos = content.indexOf('foo');\n            if (pos < 0) {\n                return { code: content };\n            }\n            const s = new MagicString(content, { filename });\n            s.overwrite(pos, pos + 3, 'bar', { storeName: true });\n            return {\n                code: s.toString(),\n                map: s.generateMap()\n            };\n        }\n    },\n    {\n        filename: 'App.svelte'\n    }\n);\n```\n\nIf a `dependencies` array is returned, it will be included in the result object. This is used by packages like [vite-plugin-svelte](https://github.com/sveltejs/vite-plugin-svelte) and [rollup-plugin-svelte](https://github.com/sveltejs/rollup-plugin-svelte) to watch additional files for changes, in the case where your `<style>` tag has an `@import` (for example).\n\npreprocess-sass.js\n\n``` javascript\nimport { preprocess } from 'svelte/compiler';\nimport MagicString from 'magic-string';\nimport sass from 'sass';\nimport { dirname } from 'path';\n\n\nconst { code } = await preprocess(\n    source,\n    {\n        name: 'my-fancy-preprocessor',\n        markup: ({ content, filename }) => {\n            // Return code as is when no foo string present\n            const pos = content.indexOf('foo');\n            if (pos < 0) {\n                return;\n            }\n\n\n            // Replace foo with bar using MagicString which provides\n            // a source map along with the changed code\n            const s = new MagicString(content, { filename });\n            s.overwrite(pos, pos + 3, 'bar', { storeName: true });\n\n\n            return {\n                code: s.toString(),\n                map: s.generateMap({ hires: true, file: filename })\n            };\n        },\n        style: async ({ content, attributes, filename }) => {\n            // only process <style lang=\"sass\">\n            if (attributes.lang !== 'sass') return;\n\n\n            const { css, stats } = await new Promise((resolve, reject) =>\n                sass.render(\n                    {\n                        file: filename,\n                        data: content,\n                        includePaths: [dirname(filename)]\n                    },\n                    (err, result) => {\n                        if (err) reject(err);\n                        else resolve(result);\n                    }\n                )\n            );\n\n\n            // remove lang attribute from style tag\n            delete attributes.lang;\n\n\n            return {\n                code: css.toString(),\n                dependencies: stats.includedFiles,\n                attributes\n            };\n        }\n    },\n    {\n        filename: 'App.svelte'\n    }\n);\n```\n\nMultiple preprocessors can be used together. The output of the first becomes the input to the second. Within one preprocessor, `markup` runs first, then `script` and `style`.\n\n> In Svelte 3, all `markup` functions ran first, then all `script` and then all `style` preprocessors. This order was changed in Svelte 4.\n\nmultiple-preprocessor.js\n\n``` javascript\nimport { preprocess } from 'svelte/compiler';\n\n\nconst { code } = await preprocess(source, [\n    {\n        name: 'first preprocessor',\n        markup: () => {\n            console.log('this runs first');\n        },\n        script: () => {\n            console.log('this runs second');\n        },\n        style: () => {\n            console.log('this runs third');\n        }\n    },\n    {\n        name: 'second preprocessor',\n        markup: () => {\n            console.log('this runs fourth');\n        },\n        script: () => {\n            console.log('this runs fifth');\n        },\n        style: () => {\n            console.log('this runs sixth');\n        }\n    }\n], {\n    filename: 'App.svelte'\n});\n```\n\nmultiple-preprocessor.ts\n\n``` javascript\nimport { preprocess } from 'svelte/compiler';\n\n\nconst { code } = await preprocess(\n    source,\n    [\n        {\n            name: 'first preprocessor',\n            markup: () => {\n                console.log('this runs first');\n            },\n            script: () => {\n                console.log('this runs second');\n            },\n            style: () => {\n                console.log('this runs third');\n            },\n        },\n        {\n            name: 'second preprocessor',\n            markup: () => {\n                console.log('this runs fourth');\n            },\n            script: () => {\n                console.log('this runs fifth');\n            },\n            style: () => {\n                console.log('this runs sixth');\n            },\n        },\n    ],\n    {\n        filename: 'App.svelte',\n    },\n);\n```\n\n## walk\n\nThe `walk` function provides a way to walk the abstract syntax trees generated by the parser, using the compiler's own built-in instance of [estree-walker](https://github.com/Rich-Harris/estree-walker).\n\nThe walker takes an abstract syntax tree to walk and an object with two optional methods: `enter` and `leave`. For each node, `enter` is called (if present). Then, unless `this.skip()` is called during `enter`, each of the children are traversed, and then `leave` is called on the node.\n\ncompiler-walk.js\n\n``` javascript\nimport { walk } from 'svelte/compiler';\n\n\nwalk(ast, {\n    enter(node, parent, prop, index) {\n        do_something(node);\n        if (should_skip_children(node)) {\n            this.skip();\n        }\n    },\n    leave(node, parent, prop, index) {\n        do_something_else(node);\n    }\n});\n```\n\ncompiler-walk.ts\n\n``` javascript\nimport { walk } from 'svelte/compiler';\n\n\nwalk(ast, {\n    enter(node, parent, prop, index) {\n        do_something(node);\n        if (should_skip_children(node)) {\n            this.skip();\n        }\n    },\n    leave(node, parent, prop, index) {\n        do_something_else(node);\n    },\n});\n```\n\n## VERSION\n\n``` javascript\nconst VERSION: string;\n```\n\nThe current version, as set in package.json.\n\n``` javascript\nimport { VERSION } from 'svelte/compiler';\nconsole.log(`running svelte version ${VERSION}`);\n```\n\n## Types\n\n### CompileOptions\n\n``` javascript\ninterface CompileOptions {…}\n```\n\n``` javascript\nname?: string;\n```\n\n- default `'Component'`\n\nSets the name of the resulting JavaScript class (though the compiler will rename it if it would otherwise conflict with other variables in scope). It will normally be inferred from `filename`\n\n``` javascript\nfilename?: string;\n```\n\n- default `null`\n\nUsed for debugging hints and sourcemaps. Your bundler plugin will set it automatically.\n\n``` javascript\ngenerate?: 'dom' | 'ssr' | false;\n```\n\n- default `'dom'`\n\nIf `\"dom\"`, Svelte emits a JavaScript class for mounting to the DOM. If `\"ssr\"`, Svelte emits an object with a `render` method suitable for server-side rendering. If `false`, no JavaScript or CSS is returned; just metadata.\n\n``` javascript\nerrorMode?: 'throw' | 'warn';\n```\n\n- default `'throw'`\n\nIf `\"throw\"`, Svelte throws when a compilation error occurred. If `\"warn\"`, Svelte will treat errors as warnings and add them to the warning report.\n\n``` javascript\nvarsReport?: 'full' | 'strict' | false;\n```\n\n- default `'strict'`\n\nIf `\"strict\"`, Svelte returns a variables report with only variables that are not globals nor internals. If `\"full\"`, Svelte returns a variables report with all detected variables. If `false`, no variables report is returned.\n\n``` javascript\nsourcemap?: object | string;\n```\n\n- default `null`\n\nAn initial sourcemap that will be merged into the final output sourcemap. This is usually the preprocessor sourcemap.\n\n``` javascript\nenableSourcemap?: EnableSourcemap;\n```\n\n- default `true`\n\nIf `true`, Svelte generate sourcemaps for components. Use an object with `js` or `css` for more granular control of sourcemap generation.\n\n``` javascript\noutputFilename?: string;\n```\n\n- default `null`\n\nUsed for your JavaScript sourcemap.\n\n``` javascript\ncssOutputFilename?: string;\n```\n\n- default `null`\n\nUsed for your CSS sourcemap.\n\n``` javascript\nsveltePath?: string;\n```\n\n- default `'svelte'`\n\nThe location of the `svelte` package. Any imports from `svelte` or `svelte/[module]` will be modified accordingly.\n\n``` javascript\ndev?: boolean;\n```\n\n- default `false`\n\nIf `true`, causes extra code to be added to components that will perform runtime checks and provide debugging information during development.\n\n``` javascript\naccessors?: boolean;\n```\n\n- default `false`\n\nIf `true`, getters and setters will be created for the component's props. If `false`, they will only be created for readonly exported values (i.e. those declared with `const`, `class` and `function`). If compiling with `customElement: true` this option defaults to `true`.\n\n``` javascript\nimmutable?: boolean;\n```\n\n- default `false`\n\nIf `true`, tells the compiler that you promise not to mutate any objects. This allows it to be less conservative about checking whether values have changed.\n\n``` javascript\nhydratable?: boolean;\n```\n\n- default `false`\n\nIf `true` when generating DOM code, enables the `hydrate: true` runtime option, which allows a component to upgrade existing DOM rather than creating new DOM from scratch. When generating SSR code, this adds markers to `<head>` elements so that hydration knows which to replace.\n\n``` javascript\nlegacy?: boolean;\n```\n\n- default `false`\n\nIf `true`, generates code that will work in IE9 and IE10, which don't support things like `element.dataset`.\n\n``` javascript\ncustomElement?: boolean;\n```\n\n- default `false`\n\nIf `true`, tells the compiler to generate a custom element constructor instead of a regular Svelte component.\n\n``` javascript\ntag?: string;\n```\n\n- default `null`\n\nA `string` that tells Svelte what tag name to register the custom element with. It must be a lowercase alphanumeric string with at least one hyphen, e.g. `\"my-element\"`.\n\n``` javascript\ncss?: 'injected' | 'external' | 'none' | boolean;\n```\n\n- `'injected'` (formerly `true`), styles will be included in the JavaScript class and injected at runtime for the components actually rendered.\n- `'external'` (formerly `false`), the CSS will be returned in the `css` field of the compilation result. Most Svelte bundler plugins will set this to `'external'` and use the CSS that is statically generated for better performance, as it will result in smaller JavaScript bundles and the output can be served as cacheable `.css` files.\n- `'none'`, styles are completely avoided and no CSS output is generated.\n\n``` javascript\nloopGuardTimeout?: number;\n```\n\n- default `0`\n\nA `number` that tells Svelte to break the loop if it blocks the thread for more than `loopGuardTimeout` ms. This is useful to prevent infinite loops. **Only available when `dev: true`**.\n\n``` javascript\nnamespace?: string;\n```\n\n- default `'html'`\n\nThe namespace of the element; e.g., `\"mathml\"`, `\"svg\"`, `\"foreign\"`.\n\n``` javascript\ncssHash?: CssHashGetter;\n```\n\n- default `undefined`\n\nA function that takes a `{ hash, css, name, filename }` argument and returns the string that is used as a classname for scoped CSS. It defaults to returning `svelte-${hash(css)}`.\n\n``` javascript\npreserveComments?: boolean;\n```\n\n- default `false`\n\nIf `true`, your HTML comments will be preserved during server-side rendering. By default, they are stripped out.\n\n``` javascript\npreserveWhitespace?: boolean;\n```\n\n- default `false`\n\nIf `true`, whitespace inside and between elements is kept as you typed it, rather than removed or collapsed to a single space where possible.\n\n``` javascript\ndiscloseVersion?: boolean;\n```\n\n- default `true`\n\nIf `true`, exposes the Svelte major version on the global `window` object in the browser.\n\n### CompileResult\n\nThe returned shape of `compile` from `svelte/compiler`\n\n``` javascript\ninterface CompileResult {…}\n```\n\n``` javascript\njs: {…}\n```\n\nThe resulting JavaScript code from compling the component\n\n``` javascript\ncode: string;\n```\n\nCode as a string\n\n``` javascript\nmap: any;\n```\n\nA source map\n\n``` javascript\ncss: CssResult;\n```\n\nThe resulting CSS code from compling the component\n\n``` javascript\nast: Ast;\n```\n\nThe abstract syntax tree representing the structure of the component\n\n``` javascript\nwarnings: Warning[];\n```\n\nAn array of warning objects that were generated during compilation. Each warning has several properties:\n\n- code is a string identifying the category of warning\n- message describes the issue in human-readable terms\n- start and end, if the warning relates to a specific location, are objects with line, column and character properties\n- frame, if applicable, is a string highlighting the offending code with line numbers\n\n``` javascript\nvars: Var[];\n```\n\nAn array of the component's declarations used by tooling in the ecosystem (like our ESLint plugin) to infer more information\n\n``` javascript\nstats: {\n    timings: {\n        total: number;\n    };\n};\n```\n\nAn object used by the Svelte developer team for diagnosing the compiler. Avoid relying on it to stay the same!\n\n### CssHashGetter\n\n``` javascript\ntype CssHashGetter = (args: {\n    name: string;\n    filename: string | undefined;\n    css: string;\n    hash: (input: string) => string;\n}) => string;\n```\n\n### EnableSourcemap\n\n``` javascript\ntype EnableSourcemap =\n    | boolean\n    | { js: boolean; css: boolean };\n```\n\n### MarkupPreprocessor\n\nA markup preprocessor that takes a string of code and returns a processed version.\n\n``` javascript\ntype MarkupPreprocessor = (options: {\n    /**\n     * The whole Svelte file content\n     */\n    content: string;\n    /**\n     * The filename of the Svelte file\n     */\n    filename?: string;\n}) => Processed | void | Promise<Processed | void>;\n```\n\n### Preprocessor\n\nA script/style preprocessor that takes a string of code and returns a processed version.\n\n``` javascript\ntype Preprocessor = (options: {\n    /**\n     * The script/style tag content\n     */\n    content: string;\n    /**\n     * The attributes on the script/style tag\n     */\n    attributes: Record<string, string | boolean>;\n    /**\n     * The whole Svelte file content\n     */\n    markup: string;\n    /**\n     * The filename of the Svelte file\n     */\n    filename?: string;\n}) => Processed | void | Promise<Processed | void>;\n```\n\n### PreprocessorGroup\n\nA preprocessor group is a set of preprocessors that are applied to a Svelte file.\n\n``` javascript\ninterface PreprocessorGroup {…}\n```\n\n``` javascript\nname?: string;\n```\n\nName of the preprocessor. Will be a required option in the next major version\n\n``` javascript\nmarkup?: MarkupPreprocessor;\n```\n\n``` javascript\nstyle?: Preprocessor;\n```\n\n``` javascript\nscript?: Preprocessor;\n```\n\n### Processed\n\nThe result of a preprocessor run. If the preprocessor does not return a result, it is assumed that the code is unchanged.\n\n``` javascript\ninterface Processed {…}\n```\n\n``` javascript\ncode: string;\n```\n\nThe new code\n\n``` javascript\nmap?: string | object;\n```\n\nA source map mapping back to the original code\n\n``` javascript\ndependencies?: string[];\n```\n\nA list of additional files to watch for changes\n\n``` javascript\nattributes?: Record<string, string | boolean>;\n```\n\nOnly for script/style preprocessors: The updated attributes to set on the tag. If undefined, attributes stay unchanged.\n\n``` javascript\ntoString?: () => string;\n```\n\n### SveltePreprocessor\n\nUtility type to extract the type of a preprocessor from a preprocessor group\n\n``` javascript\ninterface SveltePreprocessor<\n    PreprocessorType extends keyof PreprocessorGroup,\n    Options = any\n> {…}\n```\n\n``` javascript\n(options?: Options): Required<Pick<PreprocessorGroup, PreprocessorType>>;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-compiler](https://svelte.dev/docs/svelte-compiler)"
- name: svelte-components
  id: svelte-components
  summary: Components are the building blocks of Svelte applications
  description: "# Svelte components\n\nComponents are the building blocks of Svelte applications. They are written into `.svelte` files, using a superset of HTML.\n\nAll three sections — script, styles and markup — are optional.\n\n``` javascript\n<script>\n    // logic goes here\n</script>\n\n<!-- markup (zero or more items) goes here -->\n\n<style>\n    /* styles go here */\n</style>\n```\n\n## \\<script\\>\n\nA `<script>` block contains JavaScript that runs when a component instance is created. Variables declared (or imported) at the top level are 'visible' from the component's markup. There are four additional rules:\n\n### 1. export creates a component prop\n\nSvelte uses the `export` keyword to mark a variable declaration as a *property* or *prop*, which means it becomes accessible to consumers of the component (see the section on [attributes and props](basic-markup#attributes-and-props) for more information).\n\n``` javascript\n<script>\n    export let foo;\n\n    // Values that are passed in as props\n    // are immediately available\n    console.log({ foo });\n</script>\n```\n\nYou can specify a default initial value for a prop. It will be used if the component's consumer doesn't specify the prop on the component (or if its initial value is `undefined`) when instantiating the component. Note that if the values of props are subsequently updated, then any prop whose value is not specified will be set to `undefined` (rather than its initial value).\n\nIn development mode (see the [compiler options](svelte-compiler#compile)), a warning will be printed if no default initial value is provided and the consumer does not specify a value. To squelch this warning, ensure that a default initial value is specified, even if it is `undefined`.\n\n``` javascript\n<script>\n    export let bar = 'optional default initial value';\n    export let baz = undefined;\n</script>\n```\n\nIf you export a `const`, `class` or `function`, it is readonly from outside the component. Functions are valid prop values, however, as shown below.\n\nApp.svelte\n\n``` javascript\n<script>\n    // these are readonly\n    export const thisIs = 'readonly';\n\n    /** @param {string} name */\n    export function greet(name) {\n        alert(`hello ${name}!`);\n    }\n\n    // this is a prop\n    export let format = (n) => n.toFixed(2);\n</script>\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    // these are readonly\n    export const thisIs = 'readonly';\n    \n    export function greet(name: string) {\n        alert(`hello ${name}!`);\n    }\n    \n    // this is a prop\n    export let format = (n) => n.toFixed(2);\n</script>\n```\n\nReadonly props can be accessed as properties on the element, tied to the component using [`bind:this` syntax](component-directives#bind-this).\n\nYou can use reserved words as prop names.\n\nApp.svelte\n\n``` javascript\n<script>\n    /** @type {string} */\n    let className;\n\n    // creates a `class` property, even\n    // though it is a reserved word\n    export { className as class };\n</script>\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    let className: string;\n    \n    // creates a `class` property, even\n    // though it is a reserved word\n    export { className as class };\n</script>\n```\n\n### 2. Assignments are 'reactive'\n\nTo change component state and trigger a re-render, just assign to a locally declared variable.\n\nUpdate expressions (`count += 1`) and property assignments (`obj.x = y`) have the same effect.\n\n``` javascript\n<script>\n    let count = 0;\n\n    function handleClick() {\n        // calling this function will trigger an\n        // update if the markup references `count`\n        count = count + 1;\n    }\n</script>\n```\n\nBecause Svelte's reactivity is based on assignments, using array methods like `.push()` and `.splice()` won't automatically trigger updates. A subsequent assignment is required to trigger the update. This and more details can also be found in the [tutorial](https://learn.svelte.dev/tutorial/updating-arrays-and-objects).\n\n``` javascript\n<script>\n    let arr = [0, 1];\n\n    function handleClick() {\n        // this method call does not trigger an update\n        arr.push(2);\n        // this assignment will trigger an update\n        // if the markup references `arr`\n        arr = arr;\n    }\n</script>\n```\n\nSvelte's `<script>` blocks are run only when the component is created, so assignments within a `<script>` block are not automatically run again when a prop updates. If you'd like to track changes to a prop, see the next example in the following section.\n\n``` javascript\n<script>\n    export let person;\n    // this will only set `name` on component creation\n    // it will not update when `person` does\n    let { name } = person;\n</script>\n```\n\n### 3. $: marks a statement as reactive\n\nAny top-level statement (i.e. not inside a block or a function) can be made reactive by prefixing it with the `$:` [JS label syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label). Reactive statements run after other script code and before the component markup is rendered, whenever the values that they depend on have changed.\n\n``` javascript\n<script>\n    export let title;\n    export let person;\n\n    // this will update `document.title` whenever\n    // the `title` prop changes\n    $: document.title = title;\n\n    $: {\n        console.log(`multiple statements can be combined`);\n        console.log(`the current title is ${title}`);\n    }\n\n    // this will update `name` when 'person' changes\n    $: ({ name } = person);\n\n    // don't do this. it will run before the previous line\n    let name2 = name;\n</script>\n```\n\nOnly values which directly appear within the `$:` block will become dependencies of the reactive statement. For example, in the code below `total` will only update when `x` changes, but not `y`.\n\nApp.svelte\n\n``` javascript\n<script>\n    let x = 0;\n    let y = 0;\n\n    /** @param {number} value */\n    function yPlusAValue(value) {\n        return value + y;\n    }\n\n    $: total = yPlusAValue(x);\n</script>\n\nTotal: {total}\n<button on:click={() => x++}> Increment X </button>\n\n<button on:click={() => y++}> Increment Y </button>\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    let x = 0;\n    let y = 0;\n    \n    function yPlusAValue(value: number) {\n        return value + y;\n    }\n    \n    $: total = yPlusAValue(x);\n</script>\n\nTotal: {total}\n<button on:click={() => x++}> Increment X </button>\n\n<button on:click={() => y++}> Increment Y </button>\n```\n\nIt is important to note that the reactive blocks are ordered via simple static analysis at compile time, and all the compiler looks at are the variables that are assigned to and used within the block itself, not in any functions called by them. This means that `yDependent` will not be updated when `x` is updated in the following example:\n\n``` javascript\n<script>\n    let x = 0;\n    let y = 0;\n\n    /** @param {number} value */\n    function setY(value) {\n        y = value;\n    }\n\n    $: yDependent = y;\n    $: setY(x);\n</script>\n```\n\nMoving the line `$: yDependent = y` below `$: setY(x)` will cause `yDependent` to be updated when `x` is updated.\n\nIf a statement consists entirely of an assignment to an undeclared variable, Svelte will inject a `let` declaration on your behalf.\n\nApp.svelte\n\n``` javascript\n<script>\n    /** @type {number} */\n    export let num;\n\n    // we don't need to declare `squared` and `cubed`\n    // — Svelte does it for us\n    $: squared = num * num;\n    $: cubed = squared * num;\n</script>\n```\n\nApp.svelte\n\n``` javascript\n<script lang=\"ts\">\n    export let num: number;\n    \n    // we don't need to declare `squared` and `cubed`\n    // — Svelte does it for us\n    $: squared = num * num;\n    $: cubed = squared * num;\n</script>\n```\n\n### 4. Prefix stores with $ to access their values\n\nA *store* is an object that allows reactive access to a value via a simple *store contract*. The [`svelte/store` module](svelte-store) contains minimal store implementations which fulfil this contract.\n\nAny time you have a reference to a store, you can access its value inside a component by prefixing it with the `$` character. This causes Svelte to declare the prefixed variable, subscribe to the store at component initialization and unsubscribe when appropriate.\n\nAssignments to `$`-prefixed variables require that the variable be a writable store, and will result in a call to the store's `.set` method.\n\nNote that the store must be declared at the top level of the component — not inside an `if` block or a function, for example.\n\nLocal variables (that do not represent store values) must *not* have a `$` prefix.\n\n``` javascript\n<script>\n    import { writable } from 'svelte/store';\n\n    const count = writable(0);\n    console.log($count); // logs 0\n\n    count.set(1);\n    console.log($count); // logs 1\n\n    $count = 2;\n    console.log($count); // logs 2\n</script>\n```\n\n#### Store contract\n\n``` javascript\nstore = { subscribe: (subscription: (value: any) => void) => (() => void), set?: (value: any) => void }\n```\n\nYou can create your own stores without relying on [`svelte/store`](svelte-store), by implementing the *store contract*:\n\n1.  A store must contain a `.subscribe` method, which must accept as its argument a subscription function. This subscription function must be immediately and synchronously called with the store's current value upon calling `.subscribe`. All of a store's active subscription functions must later be synchronously called whenever the store's value changes.\n2.  The `.subscribe` method must return an unsubscribe function. Calling an unsubscribe function must stop its subscription, and its corresponding subscription function must not be called again by the store.\n3.  A store may *optionally* contain a `.set` method, which must accept as its argument a new value for the store, and which synchronously calls all of the store's active subscription functions. Such a store is called a *writable store*.\n\nFor interoperability with RxJS Observables, the `.subscribe` method is also allowed to return an object with an `.unsubscribe` method, rather than return the unsubscription function directly. Note however that unless `.subscribe` synchronously calls the subscription (which is not required by the Observable spec), Svelte will see the value of the store as `undefined` until it does.\n\n## \\<script context=\"module\"\\>\n\nA `<script>` tag with a `context=\"module\"` attribute runs once when the module first evaluates, rather than for each component instance. Values declared in this block are accessible from a regular `<script>` (and the component markup) but not vice versa.\n\nYou can `export` bindings from this block, and they will become exports of the compiled module.\n\nYou cannot `export default`, since the default export is the component itself.\n\n> Variables defined in `module` scripts are not reactive — reassigning them will not trigger a rerender even though the variable itself will update. For values shared between multiple components, consider using a [store](svelte-store).\n\n``` javascript\n<script context=\"module\">\n    let totalComponents = 0;\n\n    // the export keyword allows this function to imported with e.g.\n    // `import Example, { alertTotal } from './Example.svelte'`\n    export function alertTotal() {\n        alert(totalComponents);\n    }\n</script>\n\n<script>\n    totalComponents += 1;\n    console.log(`total number of times this component has been created: ${totalComponents}`);\n</script>\n```\n\n## \\<style\\>\n\nCSS inside a `<style>` block will be scoped to that component.\n\nThis works by adding a class to affected elements, which is based on a hash of the component styles (e.g. `svelte-123xyz`).\n\n``` javascript\n<style>\n    p {\n        /* this will only affect <p> elements in this component */\n        color: burlywood;\n    }\n</style>\n```\n\nTo apply styles to a selector globally, use the `:global(...)` modifier.\n\n``` javascript\n<style>\n    :global(body) {\n        /* this will apply to <body> */\n        margin: 0;\n    }\n\n    div :global(strong) {\n        /* this will apply to all <strong> elements, in any\n             component, that are inside <div> elements belonging\n             to this component */\n        color: goldenrod;\n    }\n\n    p:global(.red) {\n        /* this will apply to all <p> elements belonging to this\n             component with a class of red, even if class=\"red\" does\n             not initially appear in the markup, and is instead\n             added at runtime. This is useful when the class\n             of the element is dynamically applied, for instance\n             when updating the element's classList property directly. */\n    }\n</style>\n```\n\nIf you want to make @keyframes that are accessible globally, you need to prepend your keyframe names with `-global-`.\n\nThe `-global-` part will be removed when compiled, and the keyframe then be referenced using just `my-animation-name` elsewhere in your code.\n\n``` javascript\n<style>\n    @keyframes -global-my-animation-name {\n        /* code goes here */\n    }\n</style>\n```\n\nThere should only be 1 top-level `<style>` tag per component.\n\nHowever, it is possible to have `<style>` tag nested inside other elements or logic blocks.\n\nIn that case, the `<style>` tag will be inserted as-is into the DOM, no scoping or processing will be done on the `<style>` tag.\n\n``` javascript\n<div>\n    <style>\n        /* this style tag will be inserted as-is */\n        div {\n            /* this will apply to all `<div>` elements in the DOM */\n            color: red;\n        }\n    </style>\n</div>\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-components](https://svelte.dev/docs/svelte-components)"
- name: svelte-easing
  id: svelte-easing
  summary: Easing functions specify the rate of change over time and are useful when working with Svelte's built-in transitions and animations as well as the tweened and spring utilities
  description: "# svelte/easing\n\nEasing functions specify the rate of change over time and are useful when working with Svelte's built-in transitions and animations as well as the tweened and spring utilities. `svelte/easing` contains 31 named exports, a `linear` ease and 3 variants of 10 different easing functions: `in`, `out` and `inOut`.\n\nYou can explore the various eases using the [ease visualiser](https://svelte.dev/examples/easing) in the [examples section](https://svelte.dev/examples).\n\n| ease        | in          | out          | inOut          |\n|-------------|-------------|--------------|----------------|\n| **back**    | `backIn`    | `backOut`    | `backInOut`    |\n| **bounce**  | `bounceIn`  | `bounceOut`  | `bounceInOut`  |\n| **circ**    | `circIn`    | `circOut`    | `circInOut`    |\n| **cubic**   | `cubicIn`   | `cubicOut`   | `cubicInOut`   |\n| **elastic** | `elasticIn` | `elasticOut` | `elasticInOut` |\n| **expo**    | `expoIn`    | `expoOut`    | `expoInOut`    |\n| **quad**    | `quadIn`    | `quadOut`    | `quadInOut`    |\n| **quart**   | `quartIn`   | `quartOut`   | `quartInOut`   |\n| **quint**   | `quintIn`   | `quintOut`   | `quintInOut`   |\n| **sine**    | `sineIn`    | `sineOut`    | `sineInOut`    |\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-easing](https://svelte.dev/docs/svelte-easing)"
- name: svelte-motion
  id: svelte-motion
  summary: The svelte/motion module exports two functions, tweened and spring, for creating writable stores whose values change over time after set and update, rather than immediately
  description: "# svelte/motion\n\nThe `svelte/motion` module exports two functions, `tweened` and `spring`, for creating writable stores whose values change over time after `set` and `update`, rather than immediately.\n\n## tweened\n\n``` javascript\nfunction tweened<T>(\n    value?: T | undefined,\n    defaults?: TweenedOptions<T> | undefined\n): Tweened<T>;\n```\n\nTweened stores update their values over a fixed duration. The following options are available:\n\n- `delay` (`number`, default 0) — milliseconds before starting\n- `duration` (`number` \\| `function`, default 400) — milliseconds the tween lasts\n- `easing` (`function`, default `t => t`) — an [easing function](svelte-easing)\n- `interpolate` (`function`) — see below\n\n`store.set` and `store.update` can accept a second `options` argument that will override the options passed in upon instantiation.\n\nBoth functions return a Promise that resolves when the tween completes. If the tween is interrupted, the promise will never resolve.\n\nOut of the box, Svelte will interpolate between two numbers, two arrays or two objects (as long as the arrays and objects are the same 'shape', and their 'leaf' properties are also numbers).\n\n``` javascript\n<script>\n    import { tweened } from 'svelte/motion';\n    import { cubicOut } from 'svelte/easing';\n\n    const size = tweened(1, {\n        duration: 300,\n        easing: cubicOut\n    });\n\n    function handleClick() {\n        // this is equivalent to size.update(n => n + 1)\n        $size += 1;\n    }\n</script>\n\n<button on:click={handleClick} style=\"transform: scale({$size}); transform-origin: 0 0\">\n    embiggen\n</button>\n```\n\nIf the initial value is `undefined` or `null`, the first value change will take effect immediately. This is useful when you have tweened values that are based on props, and don't want any motion when the component first renders.\n\n``` javascript\nimport { tweened } from 'svelte/motion';\nimport { cubicOut } from 'svelte/easing';\n\n\nconst size = tweened(undefined, {\n    duration: 300,\n    easing: cubicOut\n});\n\n\n$: $size = big ? 100 : 10;\n```\n\nThe `interpolate` option allows you to tween between *any* arbitrary values. It must be an `(a, b) => t => value` function, where `a` is the starting value, `b` is the target value, `t` is a number between 0 and 1, and `value` is the result. For example, we can use the [d3-interpolate](https://github.com/d3/d3-interpolate) package to smoothly interpolate between two colours.\n\n``` javascript\n<script>\n    import { interpolateLab } from 'd3-interpolate';\n    import { tweened } from 'svelte/motion';\n\n    const colors = ['rgb(255, 62, 0)', 'rgb(64, 179, 255)', 'rgb(103, 103, 120)'];\n\n    const color = tweened(colors[0], {\n        duration: 800,\n        interpolate: interpolateLab\n    });\n</script>\n\n{#each colors as c}\n    <button style=\"background-color: {c}; color: white; border: none;\" on:click={(e) => color.set(c)}>\n        {c}\n    </button>\n{/each}\n\n<h1 style=\"color: {$color}\">{$color}</h1>\n```\n\n## spring\n\n``` javascript\nfunction spring<T = any>(\n    value?: T | undefined,\n    opts?: SpringOpts | undefined\n): Spring<T>;\n```\n\nA `spring` store gradually changes to its target value based on its `stiffness` and `damping` parameters. Whereas `tweened` stores change their values over a fixed duration, `spring` stores change over a duration that is determined by their existing velocity, allowing for more natural-seeming motion in many situations. The following options are available:\n\n- `stiffness` (`number`, default `0.15`) — a value between 0 and 1 where higher means a 'tighter' spring\n- `damping` (`number`, default `0.8`) — a value between 0 and 1 where lower means a 'springier' spring\n- `precision` (`number`, default `0.01`) — determines the threshold at which the spring is considered to have 'settled', where lower means more precise\n\nAll of the options above can be changed while the spring is in motion, and will take immediate effect.\n\n``` javascript\nimport { spring } from 'svelte/motion';\n\n\nconst size = spring(100);\nsize.stiffness = 0.3;\nsize.damping = 0.4;\nsize.precision = 0.005;\n```\n\nAs with [`tweened`](svelte-motion#tweened) stores, `set` and `update` return a Promise that resolves if the spring settles.\n\nBoth `set` and `update` can take a second argument — an object with `hard` or `soft` properties. `{ hard: true }` sets the target value immediately; `{ soft: n }` preserves existing momentum for `n` seconds before settling. `{ soft: true }` is equivalent to `{ soft: 0.5 }`.\n\n``` javascript\nimport { spring } from 'svelte/motion';\n\n\nconst coords = spring({ x: 50, y: 50 });\n// updates the value immediately\ncoords.set({ x: 100, y: 200 }, { hard: true });\n// preserves existing momentum for 1s\ncoords.update(\n    (target_coords, coords) => {\n        return { x: target_coords.x, y: coords.y };\n    },\n    { soft: 1 }\n);\n```\n\n[See a full example on the spring tutorial.](https://learn.svelte.dev/tutorial/springs)\n\n``` javascript\n<script>\n    import { spring } from 'svelte/motion';\n\n    const coords = spring(\n        { x: 50, y: 50 },\n        {\n            stiffness: 0.1,\n            damping: 0.25\n        }\n    );\n</script>\n```\n\nIf the initial value is `undefined` or `null`, the first value change will take effect immediately, just as with `tweened` values (see above).\n\n``` javascript\nimport { spring } from 'svelte/motion';\n\n\nconst size = spring();\n$: $size = big ? 100 : 10;\n```\n\n## Types\n\n### Spring\n\n``` javascript\ninterface Spring<T> extends Readable<T> {…}\n```\n\n``` javascript\nset: (new_value: T, opts?: SpringUpdateOpts) => Promise<void>;\n```\n\n``` javascript\nupdate: (fn: Updater<T>, opts?: SpringUpdateOpts) => Promise<void>;\n```\n\n``` javascript\nprecision: number;\n```\n\n``` javascript\ndamping: number;\n```\n\n``` javascript\nstiffness: number;\n```\n\n### Tweened\n\n``` javascript\ninterface Tweened<T> extends Readable<T> {…}\n```\n\n``` javascript\nset(value: T, opts?: TweenedOptions<T>): Promise<void>;\n```\n\n``` javascript\nupdate(updater: Updater<T>, opts?: TweenedOptions<T>): Promise<void>;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-motion](https://svelte.dev/docs/svelte-motion)"
- name: svelte-register
  id: svelte-register
  summary: This API is removed in Svelte 4
  description: "# svelte/register\n\n> This API is removed in Svelte 4. `require` hooks are deprecated and current Node versions understand ESM. Use a bundler like Vite or our full-stack framework [SvelteKit](https://kit.svelte.dev) instead to create JavaScript modules from Svelte components.\n\nTo render Svelte components in Node.js without bundling, use `require('svelte/register')`. After that, you can use `require` to include any `.svelte` file.\n\n``` javascript\nrequire('svelte/register');\n\n\nconst App = require('./App.svelte').default;\n\n\n// ...\n\n\nconst { html, css, head } = App.render({ answer: 42 });\n```\n\n> The `.default` is necessary because we're converting from native JavaScript modules to the CommonJS modules recognised by Node. Note that if your component imports JavaScript modules, they will fail to load in Node and you will need to use a bundler instead.\n\nTo set compile options, or to use a custom file extension, call the `register` hook as a function:\n\n``` javascript\nrequire('svelte/register')({\n    extensions: ['.customextension'], // defaults to ['.html', '.svelte']\n    preserveComments: true\n});\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-register](https://svelte.dev/docs/svelte-register)"
- name: svelte-store
  id: svelte-store
  summary: The svelte/store module exports functions for creating readable, writable and derived stores
  description: "# svelte/store\n\nThe `svelte/store` module exports functions for creating [readable](svelte-store#readable), [writable](svelte-store#writable) and [derived](svelte-store#derived) stores.\n\nKeep in mind that you don't *have* to use these functions to enjoy the [reactive `$store` syntax](svelte-components#script-4-prefix-stores-with-$-to-access-their-values) in your components. Any object that correctly implements `.subscribe`, unsubscribe, and (optionally) `.set` is a valid store, and will work both with the special syntax, and with Svelte's built-in [`derived` stores](svelte-store#derived).\n\nThis makes it possible to wrap almost any other reactive state handling library for use in Svelte. Read more about the [store contract](svelte-components#script-4-prefix-stores-with-$-to-access-their-values) to see what a correct implementation looks like.\n\n## writable\n\n``` javascript\nfunction writable<T>(\n    value?: T | undefined,\n    start?: StartStopNotifier<T> | undefined\n): Writable<T>;\n```\n\nFunction that creates a store which has values that can be set from 'outside' components. It gets created as an object with additional `set` and `update` methods.\n\n`set` is a method that takes one argument which is the value to be set. The store value gets set to the value of the argument if the store value is not already equal to it.\n\n`update` is a method that takes one argument which is a callback. The callback takes the existing store value as its argument and returns the new value to be set to the store.\n\nstore.js\n\n``` javascript\nimport { writable } from 'svelte/store';\n\n\nconst count = writable(0);\n\n\ncount.subscribe((value) => {\n    console.log(value);\n}); // logs '0'\n\n\ncount.set(1); // logs '1'\n\n\ncount.update((n) => n + 1); // logs '2'\n```\n\nstore.ts\n\n``` javascript\nimport { writable } from 'svelte/store';\n\n\nconst count = writable(0);\n\n\ncount.subscribe((value) => {\n    console.log(value);\n}); // logs '0'\n\n\ncount.set(1); // logs '1'\n\n\ncount.update((n) => n + 1); // logs '2'\n```\n\nIf a function is passed as the second argument, it will be called when the number of subscribers goes from zero to one (but not from one to two, etc). That function will be passed a `set` function which changes the value of the store, and an `update` function which works like the `update` method on the store, taking a callback to calculate the store's new value from its old value. It must return a `stop` function that is called when the subscriber count goes from one to zero.\n\nstore.js\n\n``` javascript\nimport { writable } from 'svelte/store';\n\n\nconst count = writable(0, () => {\n    console.log('got a subscriber');\n    return () => console.log('no more subscribers');\n});\n\n\ncount.set(1); // does nothing\n\n\nconst unsubscribe = count.subscribe((value) => {\n    console.log(value);\n}); // logs 'got a subscriber', then '1'\n\n\nunsubscribe(); // logs 'no more subscribers'\n```\n\nstore.ts\n\n``` javascript\nimport { writable } from 'svelte/store';\n\n\nconst count = writable(0, () => {\n    console.log('got a subscriber');\n    return () => console.log('no more subscribers');\n});\n\n\ncount.set(1); // does nothing\n\n\nconst unsubscribe = count.subscribe((value) => {\n    console.log(value);\n}); // logs 'got a subscriber', then '1'\n\n\nunsubscribe(); // logs 'no more subscribers'\n```\n\nNote that the value of a `writable` is lost when it is destroyed, for example when the page is refreshed. However, you can write your own logic to sync the value to for example the `localStorage`.\n\n## readable\n\n``` javascript\nfunction readable<T>(\n    value?: T | undefined,\n    start?: StartStopNotifier<T> | undefined\n): Readable<T>;\n```\n\nCreates a store whose value cannot be set from 'outside', the first argument is the store's initial value, and the second argument to `readable` is the same as the second argument to `writable`.\n\n``` javascript\nimport { readable } from 'svelte/store';\n\n\nconst time = readable(new Date(), (set) => {\n    set(new Date());\n\n\n    const interval = setInterval(() => {\n        set(new Date());\n    }, 1000);\n\n\n    return () => clearInterval(interval);\n});\n\n\nconst ticktock = readable('tick', (set, update) => {\n    const interval = setInterval(() => {\n        update((sound) => (sound === 'tick' ? 'tock' : 'tick'));\n    }, 1000);\n\n\n    return () => clearInterval(interval);\n});\n```\n\n## derived\n\n``` javascript\nfunction derived<S extends Stores, T>(\n    stores: S,\n    fn: (\n        values: StoresValues<S>,\n        set: (value: T) => void,\n        update: (fn: Updater<T>) => void\n    ) => Unsubscriber | void,\n    initial_value?: T | undefined\n): Readable<T>;\n```\n\n``` javascript\nfunction derived<S extends Stores, T>(\n    stores: S,\n    fn: (values: StoresValues<S>) => T,\n    initial_value?: T | undefined\n): Readable<T>;\n```\n\nDerives a store from one or more other stores. The callback runs initially when the first subscriber subscribes and then whenever the store dependencies change.\n\nIn the simplest version, `derived` takes a single store, and the callback returns a derived value.\n\n``` javascript\nimport { derived } from 'svelte/store';\n\n\nconst doubled = derived(a, ($a) => $a * 2);\n```\n\nThe callback can set a value asynchronously by accepting a second argument, `set`, and an optional third argument, `update`, calling either or both of them when appropriate.\n\nIn this case, you can also pass a third argument to `derived` — the initial value of the derived store before `set` or `update` is first called. If no initial value is specified, the store's initial value will be `undefined`.\n\n``` javascript\nimport { derived } from 'svelte/store';\n\n\nconst delayed = derived(\n    a,\n    ($a, set) => {\n        setTimeout(() => set($a), 1000);\n    },\n    2000\n);\n\n\nconst delayedIncrement = derived(a, ($a, set, update) => {\n    set($a);\n    setTimeout(() => update((x) => x + 1), 1000);\n    // every time $a produces a value, this produces two\n    // values, $a immediately and then $a + 1 a second later\n});\n```\n\nIf you return a function from the callback, it will be called when a) the callback runs again, or b) the last subscriber unsubscribes.\n\n``` javascript\nimport { derived } from 'svelte/store';\n\n\nconst tick = derived(\n    frequency,\n    ($frequency, set) => {\n        const interval = setInterval(() => {\n            set(Date.now());\n        }, 1000 / $frequency);\n\n\n        return () => {\n            clearInterval(interval);\n        };\n    },\n    2000\n);\n```\n\nIn both cases, an array of arguments can be passed as the first argument instead of a single store.\n\n``` javascript\nimport { derived } from 'svelte/store';\n\n\nconst summed = derived([a, b], ([$a, $b]) => $a + $b);\n\n\nconst delayed = derived([a, b], ([$a, $b], set) => {\n    setTimeout(() => set($a + $b), 1000);\n});\n```\n\n## readonly\n\n``` javascript\nfunction readonly<T>(store: Readable<T>): Readable<T>;\n```\n\nThis simple helper function makes a store readonly. You can still subscribe to the changes from the original one using this new readable store.\n\n``` javascript\nimport { readonly, writable } from 'svelte/store';\n\n\nconst writableStore = writable(1);\nconst readableStore = readonly(writableStore);\n\n\nreadableStore.subscribe(console.log);\n\n\nwritableStore.set(2); // console: 2\nreadableStore.set(2); // ERROR\n```\n\n## get\n\n``` javascript\nfunction get<T>(store: Readable<T>): T;\n```\n\nGenerally, you should read the value of a store by subscribing to it and using the value as it changes over time. Occasionally, you may need to retrieve the value of a store to which you're not subscribed. `get` allows you to do so.\n\n> This works by creating a subscription, reading the value, then unsubscribing. It's therefore not recommended in hot code paths.\n\n``` javascript\nimport { get } from 'svelte/store';\n\n\nconst value = get(store);\n```\n\n## Types\n\n### Readable\n\nReadable interface for subscribing.\n\n``` javascript\ninterface Readable<T> {…}\n```\n\n``` javascript\nsubscribe(this: void, run: Subscriber<T>, invalidate?: Invalidator<T>): Unsubscriber;\n```\n\n- `run` subscription callback\n- `invalidate` cleanup callback\n\nSubscribe on value changes.\n\n### StartStopNotifier\n\nStart and stop notification callbacks. This function is called when the first subscriber subscribes.\n\n``` javascript\ntype StartStopNotifier<T> = (\n    set: (value: T) => void,\n    update: (fn: Updater<T>) => void\n) => void | (() => void);\n```\n\n### Subscriber\n\nCallback to inform of a value updates.\n\n``` javascript\ntype Subscriber<T> = (value: T) => void;\n```\n\n### Unsubscriber\n\nUnsubscribes from value updates.\n\n``` javascript\ntype Unsubscriber = () => void;\n```\n\n### Updater\n\nCallback to update a value.\n\n``` javascript\ntype Updater<T> = (value: T) => T;\n```\n\n### Writable\n\nWritable interface for both updating and subscribing.\n\n``` javascript\ninterface Writable<T> extends Readable<T> {…}\n```\n\n``` javascript\nset(this: void, value: T): void;\n```\n\n- `value` to set\n\nSet value and inform subscribers.\n\n``` javascript\nupdate(this: void, updater: Updater<T>): void;\n```\n\n- `updater` callback\n\nUpdate value using callback and inform subscribers.\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-store](https://svelte.dev/docs/svelte-store)"
- name: svelte-transition
  id: svelte-transition
  summary: 'The svelte/transition module exports seven functions: fade, blur, fly, slide, scale, draw and crossfade'
  description: "# svelte/transition\n\nThe `svelte/transition` module exports seven functions: `fade`, `blur`, `fly`, `slide`, `scale`, `draw` and `crossfade`. They are for use with Svelte [`transitions`](element-directives#transition-fn).\n\n## fade\n\n``` javascript\nfunction fade(\n    node: Element,\n    { delay, duration, easing }?: FadeParams | undefined\n): TransitionConfig;\n```\n\n``` javascript\ntransition:fade={params}\n```\n\n``` javascript\nin:fade={params}\n```\n\n``` javascript\nout:fade={params}\n```\n\nAnimates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.\n\n`fade` accepts the following parameters:\n\n- `delay` (`number`, default 0) — milliseconds before starting\n- `duration` (`number`, default 400) — milliseconds the transition lasts\n- `easing` (`function`, default `linear`) — an [easing function](svelte-easing)\n\nYou can see the `fade` transition in action in the [transition tutorial](https://learn.svelte.dev/tutorial/transition).\n\n``` javascript\n<script>\n    import { fade } from 'svelte/transition';\n</script>\n\n{#if condition}\n    <div transition:fade={{ delay: 250, duration: 300 }}>fades in and out</div>\n{/if}\n```\n\n## blur\n\n``` javascript\nfunction blur(\n    node: Element,\n    {\n        delay,\n        duration,\n        easing,\n        amount,\n        opacity\n    }?: BlurParams | undefined\n): TransitionConfig;\n```\n\n``` javascript\ntransition:blur={params}\n```\n\n``` javascript\nin:blur={params}\n```\n\n``` javascript\nout:blur={params}\n```\n\nAnimates a `blur` filter alongside an element's opacity.\n\n`blur` accepts the following parameters:\n\n- `delay` (`number`, default 0) — milliseconds before starting\n- `duration` (`number`, default 400) — milliseconds the transition lasts\n- `easing` (`function`, default `cubicInOut`) — an [easing function](svelte-easing)\n- `opacity` (`number`, default 0) - the opacity value to animate out to and in from\n- `amount` (`number | string`, default 5) - the size of the blur. Supports css units (for example: `\"4rem\"`). The default unit is `px`\n\n``` javascript\n<script>\n    import { blur } from 'svelte/transition';\n</script>\n\n{#if condition}\n    <div transition:blur={{ amount: 10 }}>fades in and out</div>\n{/if}\n```\n\n## fly\n\n``` javascript\nfunction fly(\n    node: Element,\n    {\n        delay,\n        duration,\n        easing,\n        x,\n        y,\n        opacity\n    }?: FlyParams | undefined\n): TransitionConfig;\n```\n\n``` javascript\ntransition:fly={params}\n```\n\n``` javascript\nin:fly={params}\n```\n\n``` javascript\nout:fly={params}\n```\n\nAnimates the x and y positions and the opacity of an element. `in` transitions animate from the provided values, passed as parameters to the element's default values. `out` transitions animate from the element's default values to the provided values.\n\n`fly` accepts the following parameters:\n\n- `delay` (`number`, default 0) — milliseconds before starting\n- `duration` (`number`, default 400) — milliseconds the transition lasts\n- `easing` (`function`, default `cubicOut`) — an [easing function](svelte-easing)\n- `x` (`number | string`, default 0) - the x offset to animate out to and in from\n- `y` (`number | string`, default 0) - the y offset to animate out to and in from\n- `opacity` (`number`, default 0) - the opacity value to animate out to and in from\n\nx and y use `px` by default but support css units, for example `x: '100vw'` or `y: '50%'`. You can see the `fly` transition in action in the [transition tutorial](https://learn.svelte.dev/tutorial/adding-parameters-to-transitions).\n\n``` javascript\n<script>\n    import { fly } from 'svelte/transition';\n    import { quintOut } from 'svelte/easing';\n</script>\n\n{#if condition}\n    <div\n        transition:fly={{ delay: 250, duration: 300, x: 100, y: 500, opacity: 0.5, easing: quintOut }}\n    >\n        flies in and out\n    </div>\n{/if}\n```\n\n## slide\n\n``` javascript\nfunction slide(\n    node: Element,\n    {\n        delay,\n        duration,\n        easing,\n        axis\n    }?: SlideParams | undefined\n): TransitionConfig;\n```\n\n``` javascript\ntransition:slide={params}\n```\n\n``` javascript\nin:slide={params}\n```\n\n``` javascript\nout:slide={params}\n```\n\nSlides an element in and out.\n\n`slide` accepts the following parameters:\n\n- `delay` (`number`, default 0) — milliseconds before starting\n- `duration` (`number`, default 400) — milliseconds the transition lasts\n- `easing` (`function`, default `cubicOut`) — an [easing function](svelte-easing)\n\n- `axis` (`x` \\| `y`, default `y`) — the axis of motion along which the transition occurs\n\n``` javascript\n<script>\n    import { slide } from 'svelte/transition';\n    import { quintOut } from 'svelte/easing';\n</script>\n\n{#if condition}\n    <div transition:slide={{ delay: 250, duration: 300, easing: quintOut, axis: 'x' }}>\n        slides in and out horizontally\n    </div>\n{/if}\n```\n\n## scale\n\n``` javascript\nfunction scale(\n    node: Element,\n    {\n        delay,\n        duration,\n        easing,\n        start,\n        opacity\n    }?: ScaleParams | undefined\n): TransitionConfig;\n```\n\n``` javascript\ntransition:scale={params}\n```\n\n``` javascript\nin:scale={params}\n```\n\n``` javascript\nout:scale={params}\n```\n\nAnimates the opacity and scale of an element. `in` transitions animate from an element's current (default) values to the provided values, passed as parameters. `out` transitions animate from the provided values to an element's default values.\n\n`scale` accepts the following parameters:\n\n- `delay` (`number`, default 0) — milliseconds before starting\n- `duration` (`number`, default 400) — milliseconds the transition lasts\n- `easing` (`function`, default `cubicOut`) — an [easing function](svelte-easing)\n- `start` (`number`, default 0) - the scale value to animate out to and in from\n- `opacity` (`number`, default 0) - the opacity value to animate out to and in from\n\n``` javascript\n<script>\n    import { scale } from 'svelte/transition';\n    import { quintOut } from 'svelte/easing';\n</script>\n\n{#if condition}\n    <div transition:scale={{ duration: 500, delay: 500, opacity: 0.5, start: 0.5, easing: quintOut }}>\n        scales in and out\n    </div>\n{/if}\n```\n\n## draw\n\n``` javascript\nfunction draw(\n    node: SVGElement & {\n        getTotalLength(): number;\n    },\n    {\n        delay,\n        speed,\n        duration,\n        easing\n    }?: DrawParams | undefined\n): TransitionConfig;\n```\n\n``` javascript\ntransition:draw={params}\n```\n\n``` javascript\nin:draw={params}\n```\n\n``` javascript\nout:draw={params}\n```\n\nAnimates the stroke of an SVG element, like a snake in a tube. `in` transitions begin with the path invisible and draw the path to the screen over time. `out` transitions start in a visible state and gradually erase the path. `draw` only works with elements that have a `getTotalLength` method, like `<path>` and `<polyline>`.\n\n`draw` accepts the following parameters:\n\n- `delay` (`number`, default 0) — milliseconds before starting\n- `speed` (`number`, default undefined) - the speed of the animation, see below.\n- `duration` (`number` \\| `function`, default 800) — milliseconds the transition lasts\n- `easing` (`function`, default `cubicInOut`) — an [easing function](svelte-easing)\n\nThe `speed` parameter is a means of setting the duration of the transition relative to the path's length. It is a modifier that is applied to the length of the path: `duration = length / speed`. A path that is 1000 pixels with a speed of 1 will have a duration of `1000ms`, setting the speed to `0.5` will double that duration and setting it to `2` will halve it.\n\n``` javascript\n<script>\n    import { draw } from 'svelte/transition';\n    import { quintOut } from 'svelte/easing';\n</script>\n\n<svg viewBox=\"0 0 5 5\" xmlns=\"http://www.w3.org/2000/svg\">\n    {#if condition}\n        <path\n            transition:draw={{ duration: 5000, delay: 500, easing: quintOut }}\n            d=\"M2 1 h1 v1 h1 v1 h-1 v1 h-1 v-1 h-1 v-1 h1 z\"\n            fill=\"none\"\n            stroke=\"cornflowerblue\"\n            stroke-width=\"0.1px\"\n            stroke-linejoin=\"round\"\n        />\n    {/if}\n</svg>\n```\n\n## crossfade\n\n``` javascript\nfunction crossfade({\n    fallback,\n    ...defaults\n}: CrossfadeParams & {\n    fallback?:\n        | ((\n                node: Element,\n                params: CrossfadeParams,\n                intro: boolean\n          ) => TransitionConfig)\n        | undefined;\n}): [\n    (\n        node: any,\n        params: CrossfadeParams & {\n            key: any;\n        }\n    ) => () => TransitionConfig,\n    (\n        node: any,\n        params: CrossfadeParams & {\n            key: any;\n        }\n    ) => () => TransitionConfig\n];\n```\n\nThe `crossfade` function creates a pair of [transitions](element-directives#transition-fn) called `send` and `receive`. When an element is 'sent', it looks for a corresponding element being 'received', and generates a transition that transforms the element to its counterpart's position and fades it out. When an element is 'received', the reverse happens. If there is no counterpart, the `fallback` transition is used.\n\n`crossfade` accepts the following parameters:\n\n- `delay` (`number`, default 0) — milliseconds before starting\n- `duration` (`number` \\| `function`, default 800) — milliseconds the transition lasts\n- `easing` (`function`, default `cubicOut`) — an [easing function](svelte-easing)\n- `fallback` (`function`) — A fallback [transition](element-directives#transition-fn) to use for send when there is no matching element being received, and for receive when there is no element being sent.\n\n``` javascript\n<script>\n    import { crossfade } from 'svelte/transition';\n    import { quintOut } from 'svelte/easing';\n\n    const [send, receive] = crossfade({\n        duration: 1500,\n        easing: quintOut\n    });\n</script>\n\n{#if condition}\n    <h1 in:send={{ key }} out:receive={{ key }}>BIG ELEM</h1>\n{:else}\n    <small in:send={{ key }} out:receive={{ key }}>small elem</small>\n{/if}\n```\n\n## Types\n\n### BlurParams\n\n``` javascript\ninterface BlurParams {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number;\n```\n\n``` javascript\neasing?: EasingFunction;\n```\n\n``` javascript\namount?: number | string;\n```\n\n``` javascript\nopacity?: number;\n```\n\n### CrossfadeParams\n\n``` javascript\ninterface CrossfadeParams {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number | ((len: number) => number);\n```\n\n``` javascript\neasing?: EasingFunction;\n```\n\n### DrawParams\n\n``` javascript\ninterface DrawParams {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nspeed?: number;\n```\n\n``` javascript\nduration?: number | ((len: number) => number);\n```\n\n``` javascript\neasing?: EasingFunction;\n```\n\n### EasingFunction\n\n``` javascript\ntype EasingFunction = (t: number) => number;\n```\n\n### FadeParams\n\n``` javascript\ninterface FadeParams {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number;\n```\n\n``` javascript\neasing?: EasingFunction;\n```\n\n### FlyParams\n\n``` javascript\ninterface FlyParams {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number;\n```\n\n``` javascript\neasing?: EasingFunction;\n```\n\n``` javascript\nx?: number | string;\n```\n\n``` javascript\ny?: number | string;\n```\n\n``` javascript\nopacity?: number;\n```\n\n### ScaleParams\n\n``` javascript\ninterface ScaleParams {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number;\n```\n\n``` javascript\neasing?: EasingFunction;\n```\n\n``` javascript\nstart?: number;\n```\n\n``` javascript\nopacity?: number;\n```\n\n### SlideParams\n\n``` javascript\ninterface SlideParams {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number;\n```\n\n``` javascript\neasing?: EasingFunction;\n```\n\n``` javascript\naxis?: 'x' | 'y';\n```\n\n### TransitionConfig\n\n``` javascript\ninterface TransitionConfig {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number;\n```\n\n``` javascript\neasing?: EasingFunction;\n```\n\n``` javascript\ncss?: (t: number, u: number) => string;\n```\n\n``` javascript\ntick?: (t: number, u: number) => void;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-transition](https://svelte.dev/docs/svelte-transition)"
- name: SvelteComponent
  id: typescript#types-sveltecomponent
  summary: Base class for Svelte components with some minor dev-enhancements
  belongs_to: typescript
  description: |-
    ### SvelteComponent

    Base class for Svelte components with some minor dev-enhancements. Used when dev=true.

    Can be used to create strongly typed Svelte components.

    #### Example:

    You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:

    ``` javascript
    import { SvelteComponent } from "svelte";
    export class MyComponent extends SvelteComponent<{foo: string}> {}
    ```

    Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:

    ``` javascript
    <script lang="ts">
        import { MyComponent } from "component-library";
    </script>
    <MyComponent foo={'bar'} />
    ```

    ``` javascript
    class SvelteComponent<
        Props extends Record<string, any> = any,
        Events extends Record<string, any> = any,
        Slots extends Record<string, any> = any
    > extends SvelteComponent_1<Props, Events> {…}
    ```

    ``` javascript
    [prop: string]: any;
    ```

    ``` javascript
    constructor(options: ComponentConstructorOptions<Props>);
    ```

    ``` javascript
    $capture_state(): void;
    ```

    ``` javascript
    $inject_state(): void;
    ```
- name: SvelteComponent
  id: svelte#types-sveltecomponent
  summary: Base class for Svelte components with some minor dev-enhancements
  belongs_to: svelte
  description: |-
    ### SvelteComponent

    Base class for Svelte components with some minor dev-enhancements. Used when dev=true.

    Can be used to create strongly typed Svelte components.

    #### Example:

    You have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:

    ``` javascript
    import { SvelteComponent } from "svelte";
    export class MyComponent extends SvelteComponent<{foo: string}> {}
    ```

    Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:

    ``` javascript
    <script lang="ts">
        import { MyComponent } from "component-library";
    </script>
    <MyComponent foo={'bar'} />
    ```

    ``` javascript
    class SvelteComponent<
        Props extends Record<string, any> = any,
        Events extends Record<string, any> = any,
        Slots extends Record<string, any> = any
    > extends SvelteComponent_1<Props, Events> {…}
    ```

    ``` javascript
    [prop: string]: any;
    ```

    ``` javascript
    constructor(options: ComponentConstructorOptions<Props>);
    ```

    ``` javascript
    $capture_state(): void;
    ```

    ``` javascript
    $inject_state(): void;
    ```
- name: SvelteComponentTyped
  id: svelte#types-sveltecomponenttyped
  summary: Use SvelteComponent instead
  belongs_to: svelte
  description: "### SvelteComponentTyped\n\n> Use `SvelteComponent` instead. See PR for more information: <https://github.com/sveltejs/svelte/pull/8512>\n\n``` javascript\nclass SvelteComponentTyped<\n    Props extends Record<string, any> = any,\n    Events extends Record<string, any> = any,\n    Slots extends Record<string, any> = any\n> extends SvelteComponent<Props, Events, Slots> {}\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte](https://svelte.dev/docs/svelte)"
- name: SvelteComponentTyped
  id: typescript#types-sveltecomponenttyped
  summary: Use SvelteComponent instead
  belongs_to: typescript
  description: "### SvelteComponentTyped\n\n> Use `SvelteComponent` instead. See PR for more information: <https://github.com/sveltejs/svelte/pull/8512>\n\n``` javascript\nclass SvelteComponentTyped<\n    Props extends Record<string, any> = any,\n    Events extends Record<string, any> = any,\n    Slots extends Record<string, any> = any\n> extends SvelteComponent<Props, Events, Slots> {}\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/typescript](https://svelte.dev/docs/typescript)"
- name: SvelteComponentTyped is deprecated
  id: v4-migration-guide#sveltecomponenttyped-is-deprecated
  summary: SvelteComponentTyped is deprecated, as SvelteComponent now has all its typing capabilities
  belongs_to: v4-migration-guide
  description: |-
    ## SvelteComponentTyped is deprecated

    [`SvelteComponentTyped`](svelte#types-sveltecomponenttyped) is deprecated, as [`SvelteComponent`](svelte#types-sveltecomponent) now has all its typing capabilities. Replace all instances of [`SvelteComponentTyped`](svelte#types-sveltecomponenttyped) with [`SvelteComponent`](svelte#types-sveltecomponent).

    If you have used [`SvelteComponent`](svelte#types-sveltecomponent) as the component instance type previously, you may see a somewhat opaque type error now, which is solved by changing `: typeof `[`SvelteComponent`](svelte#types-sveltecomponent) to `: typeof `[`SvelteComponent`](svelte#types-sveltecomponent)`<any>`.

    The migration script will do both automatically for you. ([\#8512](https://github.com/sveltejs/svelte/issues/8512))
- name: SveltePreprocessor
  id: svelte-compiler#types-sveltepreprocessor
  summary: © 2016–2023 Rich Harris and contributors Licensed under the MIT License
  belongs_to: svelte-compiler
  description: "### SveltePreprocessor\n\nUtility type to extract the type of a preprocessor from a preprocessor group\n\n``` javascript\ninterface SveltePreprocessor<\n    PreprocessorType extends keyof PreprocessorGroup,\n    Options = any\n> {…}\n```\n\n``` javascript\n(options?: Options): Required<Pick<PreprocessorGroup, PreprocessorType>>;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-compiler](https://svelte.dev/docs/svelte-compiler)"
- name: Tags
  id: basic-markup#tags
  summary: A lowercase tag, like <div>, denotes a regular HTML element
  belongs_to: basic-markup
  description: |-
    ## Tags

    A lowercase tag, like `<div>`, denotes a regular HTML element. A capitalised tag, such as `<Widget>` or `<Namespace.Widget>`, indicates a *component*.

    ``` javascript
    <script>
        import Widget from './Widget.svelte';
    </script>

    <div>
        <Widget />
    </div>
    ```
- name: Text expressions
  id: basic-markup#text-expressions
  summary: A JavaScript expression can be included as text by surrounding it with curly braces
  belongs_to: basic-markup
  description: |-
    ## Text expressions

    A JavaScript expression can be included as text by surrounding it with curly braces.

    ``` javascript
    {expression}
    ```

    Curly braces can be included in a Svelte template by using their [HTML entity](https://developer.mozilla.org/docs/Glossary/Entity) strings: `&lbrace;`, `&lcub;`, or `&#123;` for `{` and `&rbrace;`, `&rcub;`, or `&#125;` for `}`.

    > If you're using a regular expression (`RegExp`) [literal notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#literal_notation_and_constructor), you'll need to wrap it in parentheses.

    ``` javascript
    <h1>Hello {name}!</h1>
    <p>{a} + {b} = {a + b}.</p>

    <div>{(/^[A-Za-z ]+$/).test(value) ? x : y}</div>
    ```
- name: tick
  id: svelte#tick
  summary: Returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none
  belongs_to: svelte
  description: |-
    ## tick

    ``` javascript
    function tick(): Promise<void>;
    ```

    Returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.

    ``` javascript
    <script>
        import { beforeUpdate, tick } from 'svelte';

        beforeUpdate(async () => {
            console.log('the component is about to update');
            await tick();
            console.log('the component just updated');
        });
    </script>
    ```
- name: Transition events
  id: element-directives#transition-events
  summary: null
  belongs_to: element-directives
  description: |-
    ## Transition events

    An element with transitions will dispatch the following events in addition to any standard DOM events:

    - `introstart`
    - `introend`
    - `outrostart`
    - `outroend`

    ``` javascript
    {#if visible}
        <p
            transition:fly={{ y: 200, duration: 2000 }}
            on:introstart={() => (status = 'intro started')}
            on:outrostart={() => (status = 'outro started')}
            on:introend={() => (status = 'intro ended')}
            on:outroend={() => (status = 'outro ended')}
        >
            Flies in and out
        </p>
    {/if}
    ```
- name: Transition parameters
  id: element-directives#transition-parameters
  summary: Like actions, transitions can have parameters
  belongs_to: element-directives
  description: |-
    ## Transition parameters

    Like actions, transitions can have parameters.

    (The double `{{curlies}}` aren't a special syntax; this is an object literal inside an expression tag.)

    ``` javascript
    {#if visible}
        <div transition:fade={{ duration: 2000 }}>fades in and out over two seconds</div>
    {/if}
    ```
- name: transition:fn
  id: element-directives#transition-fn
  summary: A transition is triggered by an element entering or leaving the DOM as a result of a state change
  belongs_to: element-directives
  description: |-
    ## transition:*fn*

    ``` javascript
    transition:fn
    ```

    ``` javascript
    transition:fn={params}
    ```

    ``` javascript
    transition:fn|global
    ```

    ``` javascript
    transition:fn|global={params}
    ```

    ``` javascript
    transition:fn|local
    ```

    ``` javascript
    transition:fn|local={params}
    ```

    ``` javascript
    transition = (node: HTMLElement, params: any, options: { direction: 'in' | 'out' | 'both' }) => {
        delay?: number,
        duration?: number,
        easing?: (t: number) => number,
        css?: (t: number, u: number) => string,
        tick?: (t: number, u: number) => void
    }
    ```

    A transition is triggered by an element entering or leaving the DOM as a result of a state change.

    When a block is transitioning out, all elements inside the block, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed.

    The `transition:` directive indicates a *bidirectional* transition, which means it can be smoothly reversed while the transition is in progress.

    ``` javascript
    {#if visible}
        <div transition:fade>fades in and out</div>
    {/if}
    ```

    Transitions are local by default (in Svelte 3, they were global by default). Local transitions only play when the block they belong to is created or destroyed, *not* when parent blocks are created or destroyed.

    ``` javascript
    {#if x}
        {#if y}
            <!-- Svelte 3: <p transition:fade|local> -->
            <p transition:fade>fades in and out only when y changes</p>

            <!-- Svelte 3: <p transition:fade> -->
            <p transition:fade|global>fades in and out when x or y change</p>
        {/if}
    {/if}
    ```

    > By default intro transitions will not play on first render. You can modify this behaviour by setting `intro: true` when you [create a component](client-side-component-api) and marking the transition as `global`.
- name: TransitionConfig
  id: svelte-transition#types-transitionconfig
  summary: © 2016–2023 Rich Harris and contributors Licensed under the MIT License
  belongs_to: svelte-transition
  description: "### TransitionConfig\n\n``` javascript\ninterface TransitionConfig {…}\n```\n\n``` javascript\ndelay?: number;\n```\n\n``` javascript\nduration?: number;\n```\n\n``` javascript\neasing?: EasingFunction;\n```\n\n``` javascript\ncss?: (t: number, u: number) => string;\n```\n\n``` javascript\ntick?: (t: number, u: number) => void;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-transition](https://svelte.dev/docs/svelte-transition)"
- name: Transitions are local by default
  id: v4-migration-guide#transitions-are-local-by-default
  summary: Transitions are now local by default to prevent confusion around page navigations
  belongs_to: v4-migration-guide
  description: |-
    ## Transitions are local by default

    Transitions are now local by default to prevent confusion around page navigations. "local" means that a transition will not play if it's within a nested control flow block (`each/if/await/key`) and not the direct parent block but a block above it is created/destroyed. In the following example, the `slide` intro animation will only play when `success` goes from `false` to `true`, but it will *not* play when `show` goes from `false` to `true`:

    ``` javascript
    {#if show}
        ...
        {#if success}
            <p in:slide>Success</p>
        {/each}
    {/if}
    ```

    To make transitions global, add the `|global` modifier - then they will play when *any* control flow block above is created/destroyed. The migration script will do this automatically for you. ([\#6686](https://github.com/sveltejs/svelte/issues/6686))
- name: tweened
  id: svelte-motion#tweened
  summary: Tweened stores update their values over a fixed duration
  belongs_to: svelte-motion
  description: |-
    ## tweened

    ``` javascript
    function tweened<T>(
        value?: T | undefined,
        defaults?: TweenedOptions<T> | undefined
    ): Tweened<T>;
    ```

    Tweened stores update their values over a fixed duration. The following options are available:

    - `delay` (`number`, default 0) — milliseconds before starting
    - `duration` (`number` \| `function`, default 400) — milliseconds the tween lasts
    - `easing` (`function`, default `t => t`) — an [easing function](svelte-easing)
    - `interpolate` (`function`) — see below

    `store.set` and `store.update` can accept a second `options` argument that will override the options passed in upon instantiation.

    Both functions return a Promise that resolves when the tween completes. If the tween is interrupted, the promise will never resolve.

    Out of the box, Svelte will interpolate between two numbers, two arrays or two objects (as long as the arrays and objects are the same 'shape', and their 'leaf' properties are also numbers).

    ``` javascript
    <script>
        import { tweened } from 'svelte/motion';
        import { cubicOut } from 'svelte/easing';

        const size = tweened(1, {
            duration: 300,
            easing: cubicOut
        });

        function handleClick() {
            // this is equivalent to size.update(n => n + 1)
            $size += 1;
        }
    </script>

    <button on:click={handleClick} style="transform: scale({$size}); transform-origin: 0 0">
        embiggen
    </button>
    ```

    If the initial value is `undefined` or `null`, the first value change will take effect immediately. This is useful when you have tweened values that are based on props, and don't want any motion when the component first renders.

    ``` javascript
    import { tweened } from 'svelte/motion';
    import { cubicOut } from 'svelte/easing';


    const size = tweened(undefined, {
        duration: 300,
        easing: cubicOut
    });


    $: $size = big ? 100 : 10;
    ```

    The `interpolate` option allows you to tween between *any* arbitrary values. It must be an `(a, b) => t => value` function, where `a` is the starting value, `b` is the target value, `t` is a number between 0 and 1, and `value` is the result. For example, we can use the [d3-interpolate](https://github.com/d3/d3-interpolate) package to smoothly interpolate between two colours.

    ``` javascript
    <script>
        import { interpolateLab } from 'd3-interpolate';
        import { tweened } from 'svelte/motion';

        const colors = ['rgb(255, 62, 0)', 'rgb(64, 179, 255)', 'rgb(103, 103, 120)'];

        const color = tweened(colors[0], {
            duration: 800,
            interpolate: interpolateLab
        });
    </script>

    {#each colors as c}
        <button style="background-color: {c}; color: white; border: none;" on:click={(e) => color.set(c)}>
            {c}
        </button>
    {/each}

    <h1 style="color: {$color}">{$color}</h1>
    ```
- name: Tweened
  id: svelte-motion#types-tweened
  summary: © 2016–2023 Rich Harris and contributors Licensed under the MIT License
  belongs_to: svelte-motion
  description: "### Tweened\n\n``` javascript\ninterface Tweened<T> extends Readable<T> {…}\n```\n\n``` javascript\nset(value: T, opts?: TweenedOptions<T>): Promise<void>;\n```\n\n``` javascript\nupdate(updater: Updater<T>, opts?: TweenedOptions<T>): Promise<void>;\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-motion](https://svelte.dev/docs/svelte-motion)"
- name: Types
  id: svelte-action#types
  summary: null
  belongs_to: svelte-action
  description: '## Types'
- name: Types
  id: svelte-animate#types
  summary: null
  belongs_to: svelte-animate
  description: '## Types'
- name: Types
  id: svelte-compiler#types
  summary: null
  belongs_to: svelte-compiler
  description: '## Types'
- name: Types
  id: svelte-transition#types
  summary: null
  belongs_to: svelte-transition
  description: '## Types'
- name: Types
  id: typescript#types
  summary: null
  belongs_to: typescript
  description: '## Types'
- name: Types
  id: svelte-motion#types
  summary: null
  belongs_to: svelte-motion
  description: '## Types'
- name: Types
  id: svelte-store#types
  summary: null
  belongs_to: svelte-store
  description: '## Types'
- name: Types
  id: svelte#types
  summary: null
  belongs_to: svelte
  description: '## Types'
- name: typescript
  id: typescript
  summary: You can use TypeScript within Svelte components
  description: "# TypeScript\n\nYou can use TypeScript within Svelte components. IDE extensions like the [Svelte VSCode extension](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode) will help you catch errors right in your editor, and [`svelte-check`](https://www.npmjs.com/package/svelte-check) does the same on the command line, which you can integrate into your CI.\n\n## Setup\n\nTo use TypeScript within Svelte components, you need to add a preprocessor that will turn TypeScript into JavaScript.\n\n### Using SvelteKit or Vite\n\nThe easiest way to get started is scaffolding a new SvelteKit project by typing `npm create svelte@latest`, following the prompts and choosing the TypeScript option.\n\nsvelte.config.js\n\n``` javascript\nimport { vitePreprocess } from '@sveltejs/kit/vite';\n\n\nconst config = {\n    preprocess: vitePreprocess()\n};\n\n\nexport default config;\n```\n\nIf you don't need or want all the features SvelteKit has to offer, you can scaffold a Svelte-flavoured Vite project instead by typing `npm create vite@latest` and selecting the `svelte-ts` option.\n\nsvelte.config.js\n\n``` javascript\nimport { vitePreprocess } from '@sveltejs/vite-plugin-svelte';\n\n\nconst config = {\n    preprocess: vitePreprocess()\n};\n\n\nexport default config;\n```\n\nIn both cases, a `svelte.config.js` with `vitePreprocess` will be added. Vite/SvelteKit will read from this config file.\n\n### Other build tools\n\nIf you're using tools like Rollup or Webpack instead, install their respective Svelte plugins. For Rollup that's [rollup-plugin-svelte](https://github.com/sveltejs/rollup-plugin-svelte) and for Webpack that's [svelte-loader](https://github.com/sveltejs/svelte-loader). For both, you need to install `typescript` and `svelte-preprocess` and add the preprocessor to the plugin config (see the respective READMEs for more info). If you're starting a new project, you can also use the [rollup](https://github.com/sveltejs/template) or [webpack](https://github.com/sveltejs/template-webpack) template to scaffold the setup from a script.\n\n> If you're starting a new project, we recommend using SvelteKit or Vite instead\n\n## \\<script lang=\"ts\"\\>\n\nTo use TypeScript inside your Svelte components, add `lang=\"ts\"` to your `script` tags:\n\n``` javascript\n<script lang=\"ts\">\n    let name: string = 'world';\n\n    function greet(name: string) {\n        alert(`Hello, ${name}!`);\n    }\n</script>\n```\n\n### Props\n\nProps can be typed directly on the `export let` statement:\n\n``` javascript\n<script lang=\"ts\">\n    export let name: string;\n</script>\n```\n\n### Slots\n\nSlot and slot prop types are inferred from the types of the slot props passed to them:\n\n``` javascript\n<script lang=\"ts\">\n    export let name: string;\n</script>\n\n<slot {name} />\n\n<!-- Later -->\n<Comp let:name>\n    <!--    ^ Inferred as string -->\n    {name}\n</Comp>\n```\n\n### Events\n\nEvents can be typed with `createEventDispatcher`:\n\n``` javascript\n<script lang=\"ts\">\n    import { createEventDispatcher } from 'svelte';\n\n    const dispatch = createEventDispatcher<{\n        event: null; // does not accept a payload\n        click: string; // has a required string payload\n        type: string | null; // has an optional string payload\n    }>();\n\n    function handleClick() {\n        dispatch('event');\n        dispatch('click', 'hello');\n    }\n\n    function handleType() {\n        dispatch('event');\n        dispatch('type', Math.random() > 0.5 ? 'world' : null);\n    }\n</script>\n\n<button on:click={handleClick} on:keydown={handleType}>Click</button>\n```\n\n## Enhancing built-in DOM types\n\nSvelte provides a best effort of all the HTML DOM types that exist. Sometimes you may want to use experimental attributes or custom events coming from an action. In these cases, TypeScript will throw a type error, saying that it does not know these types. If it's a non-experimental standard attribute/event, this may very well be a missing typing from our [HTML typings](https://github.com/sveltejs/svelte/blob/master/packages/svelte/elements.d.ts). In that case, you are welcome to open an issue and/or a PR fixing it.\n\nIn case this is a custom or experimental attribute/event, you can enhance the typings like this:\n\nadditional-svelte-typings.d.ts\n\n``` javascript\ndeclare namespace svelteHTML {\n    // enhance elements\n    interface IntrinsicElements {\n        'my-custom-element': { someattribute: string; 'on:event': (e: CustomEvent<any>) => void };\n    }\n    // enhance attributes\n    interface HTMLAttributes<T> {\n        // If you want to use on:beforeinstallprompt\n        'on:beforeinstallprompt'?: (event: any) => any;\n        // If you want to use myCustomAttribute={..} (note: all lowercase)\n        mycustomattribute?: any; // You can replace any with something more specific if you like\n    }\n}\n```\n\nThen make sure that `d.ts` file is referenced in your `tsconfig.json`. If it reads something like `\"include\": [\"src/**/*\"]` and your `d.ts` file is inside `src`, it should work. You may need to reload for the changes to take effect.\n\nSince Svelte version 4.2 / `svelte-check` version 3.5 / VS Code extension version 107.10.0 you can also declare the typings by augmenting the `svelte/elements` module like this:\n\nadditional-svelte-typings.d.ts\n\n``` javascript\nimport { HTMLButtonAttributes } from 'svelte/elements';\n\n\ndeclare module 'svelte/elements' {\n    export interface SvelteHTMLElements {\n        'custom-button': HTMLButtonAttributes;\n    }\n\n\n    // allows for more granular control over what element to add the typings to\n    export interface HTMLButtonAttributes {\n        veryexperimentalattribute?: string;\n    }\n}\n\n\nexport {}; // ensure this is not an ambient module, else types will be overridden instead of augmented\n```\n\n## Experimental advanced typings\n\nA few features are missing from taking full advantage of TypeScript in more advanced use cases like typing that a component implements a certain interface, explicitly typing slots, or using generics. These things are possible using experimental advanced type capabilities. See [this RFC](https://github.com/dummdidumm/rfcs/blob/ts-typedefs-within-svelte-components/text/ts-typing-props-slots-events.md) for more information on how to make use of them.\n\n> The API is experimental and may change at any point\n\n## Limitations\n\n### No TS in markup\n\nYou cannot use TypeScript in your template's markup. For example, the following does not work:\n\n``` javascript\n<script lang=\"ts\">\n    let count = 10;\n</script>\n\n<h1>Count as string: {count as string}!</h1> <!-- ❌ Does not work -->\n{#if count > 4}\n    {@const countString: string = count} <!-- ❌ Does not work -->\n    {countString}\n{/if}\n```\n\n### Reactive Declarations\n\nYou cannot type your reactive declarations with TypeScript in the way you type a variable. For example, the following does not work:\n\n``` javascript\n<script lang=\"ts\">\n    let count = 0;\n\n    $: doubled: number = count * 2; // ❌ Does not work\n</script>\n```\n\nYou cannot add a `: TYPE` because it's invalid syntax in this position. Instead, you can move the definition to a `let` statement just above:\n\n``` javascript\n<script lang=\"ts\">\n    let count = 0;\n\n    let doubled: number;\n    $: doubled = count * 2;\n</script>\n```\n\n## Types\n\n### ComponentConstructorOptions\n\n``` javascript\ninterface ComponentConstructorOptions<\n    Props extends Record<string, any> = Record<string, any>\n> {…}\n```\n\n``` javascript\ntarget: Element | Document | ShadowRoot;\n```\n\n``` javascript\nanchor?: Element;\n```\n\n``` javascript\nprops?: Props;\n```\n\n``` javascript\ncontext?: Map<any, any>;\n```\n\n``` javascript\nhydrate?: boolean;\n```\n\n``` javascript\nintro?: boolean;\n```\n\n``` javascript\n$$inline?: boolean;\n```\n\n### ComponentEvents\n\nConvenience type to get the events the given component expects. Example:\n\n``` javascript\n<script lang=\"ts\">\n   import type { ComponentEvents } from 'svelte';\n   import Component from './Component.svelte';\n\n   function handleCloseEvent(event: ComponentEvents<Component>['close']) {\n      console.log(event.detail);\n   }\n</script>\n\n<Component on:close={handleCloseEvent} />\n```\n\n``` javascript\ntype ComponentEvents<Component extends SvelteComponent_1> =\n    Component extends SvelteComponent<any, infer Events>\n        ? Events\n        : never;\n```\n\n### ComponentProps\n\nConvenience type to get the props the given component expects. Example:\n\n``` javascript\n<script lang=\"ts\">\n    import type { ComponentProps } from 'svelte';\n    import Component from './Component.svelte';\n\n    const props: ComponentProps<Component> = { foo: 'bar' }; // Errors if these aren't the correct props\n</script>\n```\n\n``` javascript\ntype ComponentProps<Component extends SvelteComponent_1> =\n    Component extends SvelteComponent<infer Props>\n        ? Props\n        : never;\n```\n\n### ComponentType\n\nConvenience type to get the type of a Svelte component. Useful for example in combination with dynamic components using `<svelte:component>`.\n\nExample:\n\n``` javascript\n<script lang=\"ts\">\n    import type { ComponentType, SvelteComponent } from 'svelte';\n    import Component1 from './Component1.svelte';\n    import Component2 from './Component2.svelte';\n\n    const component: ComponentType = someLogic() ? Component1 : Component2;\n    const componentOfCertainSubType: ComponentType<SvelteComponent<{ needsThisProp: string }>> = someLogic() ? Component1 : Component2;\n</script>\n\n<svelte:component this={component} />\n<svelte:component this={componentOfCertainSubType} needsThisProp=\"hello\" />\n```\n\n``` javascript\ntype ComponentType<\n    Component extends SvelteComponent = SvelteComponent\n> = (new (\n    options: ComponentConstructorOptions<\n        Component extends SvelteComponent<infer Props>\n            ? Props\n            : Record<string, any>\n    >\n) => Component) & {\n    /** The custom element version of the component. Only present if compiled with the `customElement` compiler option */\n    element?: typeof HTMLElement;\n};\n```\n\n### SvelteComponent\n\nBase class for Svelte components with some minor dev-enhancements. Used when dev=true.\n\nCan be used to create strongly typed Svelte components.\n\n#### Example:\n\nYou have component library on npm called `component-library`, from which you export a component called `MyComponent`. For Svelte+TypeScript users, you want to provide typings. Therefore you create a `index.d.ts`:\n\n``` javascript\nimport { SvelteComponent } from \"svelte\";\nexport class MyComponent extends SvelteComponent<{foo: string}> {}\n```\n\nTyping this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:\n\n``` javascript\n<script lang=\"ts\">\n    import { MyComponent } from \"component-library\";\n</script>\n<MyComponent foo={'bar'} />\n```\n\n``` javascript\nclass SvelteComponent<\n    Props extends Record<string, any> = any,\n    Events extends Record<string, any> = any,\n    Slots extends Record<string, any> = any\n> extends SvelteComponent_1<Props, Events> {…}\n```\n\n``` javascript\n[prop: string]: any;\n```\n\n``` javascript\nconstructor(options: ComponentConstructorOptions<Props>);\n```\n\n``` javascript\n$capture_state(): void;\n```\n\n``` javascript\n$inject_state(): void;\n```\n\n### SvelteComponentTyped\n\n> Use `SvelteComponent` instead. See PR for more information: <https://github.com/sveltejs/svelte/pull/8512>\n\n``` javascript\nclass SvelteComponentTyped<\n    Props extends Record<string, any> = any,\n    Events extends Record<string, any> = any,\n    Slots extends Record<string, any> = any\n> extends SvelteComponent<Props, Events, Slots> {}\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/typescript](https://svelte.dev/docs/typescript)"
- name: Unsubscriber
  id: svelte-store#types-unsubscriber
  summary: Unsubscribes from value updates
  belongs_to: svelte-store
  description: |-
    ### Unsubscriber

    Unsubscribes from value updates.

    ``` javascript
    type Unsubscriber = () => void;
    ```
- name: Updater
  id: svelte-store#types-updater
  summary: Callback to update a value
  belongs_to: svelte-store
  description: |-
    ### Updater

    Callback to update a value.

    ``` javascript
    type Updater<T> = (value: T) => T;
    ```
- name: use:action
  id: element-directives#use-action
  summary: Actions are functions that are called when an element is created
  belongs_to: element-directives
  description: |-
    ## use:*action*

    ``` javascript
    use:action
    ```

    ``` javascript
    use:action={parameters}
    ```

    ``` javascript
    action = (node: HTMLElement, parameters: any) => {
        update?: (parameters: any) => void,
        destroy?: () => void
    }
    ```

    Actions are functions that are called when an element is created. They can return an object with a `destroy` method that is called after the element is unmounted:

    ``` javascript
    <script>
        /** @type {import('svelte/action').Action}  */
        function foo(node) {
            // the node has been mounted in the DOM

            return {
                destroy() {
                    // the node has been removed from the DOM
                }
            };
        }
    </script>

    <div use:foo />
    ```

    An action can have a parameter. If the returned value has an `update` method, it will be called whenever that parameter changes, immediately after Svelte has applied updates to the markup.

    > Don't worry about the fact that we're redeclaring the `foo` function for every component instance — Svelte will hoist any functions that don't depend on local state out of the component definition.

    ``` javascript
    <script>
        export let bar;

        /** @type {import('svelte/action').Action}  */
        function foo(node, bar) {
            // the node has been mounted in the DOM

            return {
                update(bar) {
                    // the value of `bar` has changed
                },

                destroy() {
                    // the node has been removed from the DOM
                }
            };
        }
    </script>

    <div use:foo={bar} />
    ```

    Read more in the [`svelte/action`](svelte-action) page.
- name: Using SvelteKit or Vite
  id: typescript#setup-using-sveltekit-or-vite
  summary: The easiest way to get started is scaffolding a new SvelteKit project by typing npm create svelte@latest, following the prompts and choosing the TypeScript option
  belongs_to: typescript
  description: |-
    ### Using SvelteKit or Vite

    The easiest way to get started is scaffolding a new SvelteKit project by typing `npm create svelte@latest`, following the prompts and choosing the TypeScript option.

    svelte.config.js

    ``` javascript
    import { vitePreprocess } from '@sveltejs/kit/vite';


    const config = {
        preprocess: vitePreprocess()
    };


    export default config;
    ```

    If you don't need or want all the features SvelteKit has to offer, you can scaffold a Svelte-flavoured Vite project instead by typing `npm create vite@latest` and selecting the `svelte-ts` option.

    svelte.config.js

    ``` javascript
    import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';


    const config = {
        preprocess: vitePreprocess()
    };


    export default config;
    ```

    In both cases, a `svelte.config.js` with `vitePreprocess` will be added. Vite/SvelteKit will read from this config file.
- name: v4-migration-guide
  id: v4-migration-guide
  summary: This migration guide provides an overview of how to migrate from Svelte version 3 to 4
  description: "# Svelte 4 migration guide\n\nThis migration guide provides an overview of how to migrate from Svelte version 3 to 4. See the linked PRs for more details about each change. Use the migration script to migrate some of these automatically: `npx svelte-migrate@latest svelte-4`\n\nIf you're a library author, consider whether to only support Svelte 4 or if it's possible to support Svelte 3 too. Since most of the breaking changes don't affect many people, this may be easily possible. Also remember to update the version range in your `peerDependencies`.\n\n## Minimum version requirements\n\n- Upgrade to Node 16 or higher. Earlier versions are no longer supported. ([\\#8566](https://github.com/sveltejs/svelte/issues/8566))\n- If you are using SvelteKit, upgrade to 1.20.4 or newer ([sveltejs/kit#10172](https://github.com/sveltejs/kit/pull/10172))\n- If you are using Vite without SvelteKit, upgrade to `vite-plugin-svelte` 2.4.1 or newer ([\\#8516](https://github.com/sveltejs/svelte/issues/8516))\n- If you are using webpack, upgrade to webpack 5 or higher and `svelte-loader` 3.1.8 or higher. Earlier versions are no longer supported. ([\\#8515](https://github.com/sveltejs/svelte/issues/8515), [198dbcf](https://github.com/sveltejs/svelte/commit/198dbcf))\n- If you are using Rollup, upgrade to `rollup-plugin-svelte` 7.1.5 or higher ([198dbcf](https://github.com/sveltejs/svelte/commit/198dbcf))\n- If you are using TypeScript, upgrade to TypeScript 5 or higher. Lower versions might still work, but no guarantees are made about that. ([\\#8488](https://github.com/sveltejs/svelte/issues/8488))\n\n## Browser conditions for bundlers\n\nBundlers must now specify the `browser` condition when building a frontend bundle for the browser. SvelteKit and Vite will handle this automatically for you. If you're using any others, you may observe lifecycle callbacks such as `onMount` not get called and you'll need to update the module resolution configuration.\n\n- For Rollup this is done within the `@rollup/plugin-node-resolve` plugin by setting `browser: true` in its options. See the [`rollup-plugin-svelte`](https://github.com/sveltejs/rollup-plugin-svelte/#usage) documentation for more details\n- For wepback this is done by adding `\"browser\"` to the `conditionNames` array. You may also have to update your `alias` config, if you have set it. See the [`svelte-loader`](https://github.com/sveltejs/svelte-loader#usage) documentation for more details\n\n([\\#8516](https://github.com/sveltejs/svelte/issues/8516))\n\n## Removal of CJS related output\n\nSvelte no longer supports the CommonJS (CJS) format for compiler output and has also removed the `svelte/register` hook and the CJS runtime version. If you need to stay on the CJS output format, consider using a bundler to convert Svelte's ESM output to CJS in a post-build step. ([\\#8613](https://github.com/sveltejs/svelte/issues/8613))\n\n## Stricter types for Svelte functions\n\nThere are now stricter types for `createEventDispatcher`, [`Action`](svelte-action#types-action), [`ActionReturn`](svelte-action#types-actionreturn), and `onMount`:\n\n- `createEventDispatcher` now supports specifying that a payload is optional, required, or non-existent, and the call sites are checked accordingly ([\\#7224](https://github.com/sveltejs/svelte/issues/7224))\n\n``` javascript\nimport { createEventDispatcher } from 'svelte';\n\n\nconst dispatch = createEventDispatcher<{\n    optional: number | null;\n    required: string;\n    noArgument: null;\n}>();\n\n\n// Svelte version 3:\ndispatch('optional');\ndispatch('required'); // I can still omit the detail argument\ndispatch('noArgument', 'surprise'); // I can still add a detail argument\n\n\n// Svelte version 4 using TypeScript strict mode:\ndispatch('optional');\ndispatch('required'); // error, missing argument\ndispatch('noArgument', 'surprise'); // error, cannot pass an argument\n```\n\n- [`Action`](svelte-action#types-action) and [`ActionReturn`](svelte-action#types-actionreturn) have a default parameter type of `undefined` now, which means you need to type the generic if you want to specify that this action receives a parameter. The migration script will migrate this automatically ([\\#7442](https://github.com/sveltejs/svelte/pull/7442))\n\n- `onMount` now shows a type error if you return a function asynchronously from it, because this is likely a bug in your code where you expect the callback to be called on destroy, which it will only do for synchronously returned functions ([\\#8136](https://github.com/sveltejs/svelte/issues/8136))\n\n## Custom Elements with Svelte\n\nThe creation of custom elements with Svelte has been overhauled and significantly improved. The `tag` option is deprecated in favor of the new `customElement` option:\n\nThis change was made to allow [more configurability](custom-elements-api#component-options) for advanced use cases. The migration script will adjust your code automatically. The update timing of properties has changed slightly as well. ([\\#8457](https://github.com/sveltejs/svelte/issues/8457))\n\n## SvelteComponentTyped is deprecated\n\n[`SvelteComponentTyped`](svelte#types-sveltecomponenttyped) is deprecated, as [`SvelteComponent`](svelte#types-sveltecomponent) now has all its typing capabilities. Replace all instances of [`SvelteComponentTyped`](svelte#types-sveltecomponenttyped) with [`SvelteComponent`](svelte#types-sveltecomponent).\n\nIf you have used [`SvelteComponent`](svelte#types-sveltecomponent) as the component instance type previously, you may see a somewhat opaque type error now, which is solved by changing `: typeof `[`SvelteComponent`](svelte#types-sveltecomponent) to `: typeof `[`SvelteComponent`](svelte#types-sveltecomponent)`<any>`.\n\nThe migration script will do both automatically for you. ([\\#8512](https://github.com/sveltejs/svelte/issues/8512))\n\n## Transitions are local by default\n\nTransitions are now local by default to prevent confusion around page navigations. \"local\" means that a transition will not play if it's within a nested control flow block (`each/if/await/key`) and not the direct parent block but a block above it is created/destroyed. In the following example, the `slide` intro animation will only play when `success` goes from `false` to `true`, but it will *not* play when `show` goes from `false` to `true`:\n\n``` javascript\n{#if show}\n    ...\n    {#if success}\n        <p in:slide>Success</p>\n    {/each}\n{/if}\n```\n\nTo make transitions global, add the `|global` modifier - then they will play when *any* control flow block above is created/destroyed. The migration script will do this automatically for you. ([\\#6686](https://github.com/sveltejs/svelte/issues/6686))\n\n## Default slot bindings\n\nDefault slot bindings are no longer exposed to named slots and vice versa:\n\n``` javascript\n<script>\n    import Nested from './Nested.svelte';\n</script>\n\n<Nested let:count>\n    <p>\n        count in default slot - is available: {count}\n    </p>\n    <p slot=\"bar\">\n        count in bar slot - is not available: {count}\n    </p>\n</Nested>\n```\n\nThis makes slot bindings more consistent as the behavior is undefined when for example the default slot is from a list and the named slot is not. ([\\#6049](https://github.com/sveltejs/svelte/issues/6049))\n\n## Preprocessors\n\nThe order in which preprocessors are applied has changed. Now, preprocessors are executed in order, and within one group, the order is markup, script, style.\n\n``` javascript\nimport { preprocess } from 'svelte/compiler';\n\n\nconst { code } = await preprocess(\n    source,\n    [\n        {\n            markup: () => {\n                console.log('markup-1');\n            },\n            script: () => {\n                console.log('script-1');\n            },\n            style: () => {\n                console.log('style-1');\n            }\n        },\n        {\n            markup: () => {\n                console.log('markup-2');\n            },\n            script: () => {\n                console.log('script-2');\n            },\n            style: () => {\n                console.log('style-2');\n            }\n        }\n    ],\n    {\n        filename: 'App.svelte'\n    }\n);\n\n\n// Svelte 3 logs:\n// markup-1\n// markup-2\n// script-1\n// script-2\n// style-1\n// style-2\n\n\n// Svelte 4 logs:\n// markup-1\n// script-1\n// style-1\n// markup-2\n// script-2\n// style-2\n```\n\nThis could affect you for example if you are using `MDsveX` - in which case you should make sure it comes before any script or style preprocessor.\n\nEach preprocessor must also have a name. ([\\#8618](https://github.com/sveltejs/svelte/issues/8618))\n\n## New eslint package\n\n`eslint-plugin-svelte3` is deprecated. It may still work with Svelte 4 but we make no guarantees about that. We recommend switching to our new package [eslint-plugin-svelte](https://github.com/sveltejs/eslint-plugin-svelte). See [this Github post](https://github.com/sveltejs/kit/issues/10242#issuecomment-1610798405) for an instruction how to migrate. Alternatively, you can create a new project using `npm create svelte@latest`, select the eslint (and possibly TypeScript) option and then copy over the related files into your existing project.\n\n## Other breaking changes\n\n- the `inert` attribute is now applied to outroing elements to make them invisible to assistive technology and prevent interaction. ([\\#8628](https://github.com/sveltejs/svelte/pull/8628))\n- the runtime now uses `classList.toggle(name, boolean)` which may not work in very old browsers. Consider using a [polyfill](https://github.com/eligrey/classList.js) if you need to support these browsers. ([\\#8629](https://github.com/sveltejs/svelte/issues/8629))\n- the runtime now uses the `CustomEvent` constructor which may not work in very old browsers. Consider using a [polyfill](https://github.com/theftprevention/event-constructor-polyfill/tree/master) if you need to support these browsers. ([\\#8775](https://github.com/sveltejs/svelte/pull/8775))\n- people implementing their own stores from scratch using the [`StartStopNotifier`](svelte-store#types-startstopnotifier) interface (which is passed to the create function of `writable` etc) from `svelte/store` now need to pass an update function in addition to the set function. This has no effect on people using stores or creating stores using the existing Svelte stores. ([\\#6750](https://github.com/sveltejs/svelte/issues/6750))\n- `derived` will now throw an error on falsy values instead of stores passed to it. ([\\#7947](https://github.com/sveltejs/svelte/issues/7947))\n- type definitions for `svelte/internal` were removed to further discourage usage of those internal methods which are not public API. Most of these will likely change for Svelte 5\n- Removal of DOM nodes is now batched which slightly changes its order, which might affect the order of events fired if you're using a `MutationObserver` on these elements ([\\#8763](https://github.com/sveltejs/svelte/pull/8763))\n- if you enhanced the global typings through the `svelte.JSX` namespace before, you need to migrate this to use the `svelteHTML` namespace. Similarly if you used the `svelte.JSX` namespace to use type definitions from it, you need to migrate those to use the types from `svelte/elements` instead. You can find more information about what to do [here](https://github.com/sveltejs/language-tools/blob/master/docs/preprocessors/typescript.md#im-getting-deprecation-warnings-for-sveltejsx--i-want-to-migrate-to-the-new-typings)\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/v4-migration-guide](https://svelte.dev/docs/v4-migration-guide)"
- name: VERSION
  id: svelte-compiler#version
  summary: The current version, as set in package.json
  belongs_to: svelte-compiler
  description: |-
    ## VERSION

    ``` javascript
    const VERSION: string;
    ```

    The current version, as set in package.json.

    ``` javascript
    import { VERSION } from 'svelte/compiler';
    console.log(`running svelte version ${VERSION}`);
    ```
- name: walk
  id: svelte-compiler#walk
  summary: The walk function provides a way to walk the abstract syntax trees generated by the parser, using the compiler's own built-in instance of estree-walker
  belongs_to: svelte-compiler
  description: |-
    ## walk

    The `walk` function provides a way to walk the abstract syntax trees generated by the parser, using the compiler's own built-in instance of [estree-walker](https://github.com/Rich-Harris/estree-walker).

    The walker takes an abstract syntax tree to walk and an object with two optional methods: `enter` and `leave`. For each node, `enter` is called (if present). Then, unless `this.skip()` is called during `enter`, each of the children are traversed, and then `leave` is called on the node.

    compiler-walk.js

    ``` javascript
    import { walk } from 'svelte/compiler';


    walk(ast, {
        enter(node, parent, prop, index) {
            do_something(node);
            if (should_skip_children(node)) {
                this.skip();
            }
        },
        leave(node, parent, prop, index) {
            do_something_else(node);
        }
    });
    ```

    compiler-walk.ts

    ``` javascript
    import { walk } from 'svelte/compiler';


    walk(ast, {
        enter(node, parent, prop, index) {
            do_something(node);
            if (should_skip_children(node)) {
                this.skip();
            }
        },
        leave(node, parent, prop, index) {
            do_something_else(node);
        },
    });
    ```
- name: Where can I get support?
  id: faq#where-can-i-get-support
  summary: If your question is about certain syntax, the API page is a good place to start
  belongs_to: faq
  description: |-
    ## Where can I get support?

    If your question is about certain syntax, the [API page](https://svelte.dev/docs) is a good place to start.

    Stack Overflow is a popular forum to ask code-level questions or if you’re stuck with a specific error. Read through the existing questions tagged with [Svelte](https://stackoverflow.com/questions/tagged/svelte+or+svelte-3) or [ask your own](https://stackoverflow.com/questions/ask?tags=svelte)!

    There are online forums and chats which are a great place for discussion about best practices, application architecture or just to get to know fellow Svelte users. [Our Discord](https://svelte.dev/chat) or [the Reddit channel](https://www.reddit.com/r/sveltejs/) are examples of that. If you have an answerable code-level question, Stack Overflow is usually a better fit.
- name: writable
  id: svelte-store#writable
  summary: Function that creates a store which has values that can be set from 'outside' components
  belongs_to: svelte-store
  description: |-
    ## writable

    ``` javascript
    function writable<T>(
        value?: T | undefined,
        start?: StartStopNotifier<T> | undefined
    ): Writable<T>;
    ```

    Function that creates a store which has values that can be set from 'outside' components. It gets created as an object with additional `set` and `update` methods.

    `set` is a method that takes one argument which is the value to be set. The store value gets set to the value of the argument if the store value is not already equal to it.

    `update` is a method that takes one argument which is a callback. The callback takes the existing store value as its argument and returns the new value to be set to the store.

    store.js

    ``` javascript
    import { writable } from 'svelte/store';


    const count = writable(0);


    count.subscribe((value) => {
        console.log(value);
    }); // logs '0'


    count.set(1); // logs '1'


    count.update((n) => n + 1); // logs '2'
    ```

    store.ts

    ``` javascript
    import { writable } from 'svelte/store';


    const count = writable(0);


    count.subscribe((value) => {
        console.log(value);
    }); // logs '0'


    count.set(1); // logs '1'


    count.update((n) => n + 1); // logs '2'
    ```

    If a function is passed as the second argument, it will be called when the number of subscribers goes from zero to one (but not from one to two, etc). That function will be passed a `set` function which changes the value of the store, and an `update` function which works like the `update` method on the store, taking a callback to calculate the store's new value from its old value. It must return a `stop` function that is called when the subscriber count goes from one to zero.

    store.js

    ``` javascript
    import { writable } from 'svelte/store';


    const count = writable(0, () => {
        console.log('got a subscriber');
        return () => console.log('no more subscribers');
    });


    count.set(1); // does nothing


    const unsubscribe = count.subscribe((value) => {
        console.log(value);
    }); // logs 'got a subscriber', then '1'


    unsubscribe(); // logs 'no more subscribers'
    ```

    store.ts

    ``` javascript
    import { writable } from 'svelte/store';


    const count = writable(0, () => {
        console.log('got a subscriber');
        return () => console.log('no more subscribers');
    });


    count.set(1); // does nothing


    const unsubscribe = count.subscribe((value) => {
        console.log(value);
    }); // logs 'got a subscriber', then '1'


    unsubscribe(); // logs 'no more subscribers'
    ```

    Note that the value of a `writable` is lost when it is destroyed, for example when the page is refreshed. However, you can write your own logic to sync the value to for example the `localStorage`.
- name: Writable
  id: svelte-store#types-writable
  summary: Writable interface for both updating and subscribing
  belongs_to: svelte-store
  description: "### Writable\n\nWritable interface for both updating and subscribing.\n\n``` javascript\ninterface Writable<T> extends Readable<T> {…}\n```\n\n``` javascript\nset(this: void, value: T): void;\n```\n\n- `value` to set\n\nSet value and inform subscribers.\n\n``` javascript\nupdate(this: void, updater: Updater<T>): void;\n```\n\n- `updater` callback\n\nUpdate value using callback and inform subscribers.\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/svelte-store](https://svelte.dev/docs/svelte-store)"
- name: '{#await ...}'
  id: logic-blocks#await
  summary: Await blocks allow you to branch on the three possible states of a Promise — pending, fulfilled or rejected
  belongs_to: logic-blocks
  description: |-
    ## {#await ...}

    ``` javascript
    {#await expression}...{:then name}...{:catch name}...{/await}
    ```

    ``` javascript
    {#await expression}...{:then name}...{/await}
    ```

    ``` javascript
    {#await expression then name}...{/await}
    ```

    ``` javascript
    {#await expression catch name}...{/await}
    ```

    Await blocks allow you to branch on the three possible states of a Promise — pending, fulfilled or rejected. In SSR mode, only the pending state will be rendered on the server.

    ``` javascript
    {#await promise}
        <!-- promise is pending -->
        <p>waiting for the promise to resolve...</p>
    {:then value}
        <!-- promise was fulfilled -->
        <p>The value is {value}</p>
    {:catch error}
        <!-- promise was rejected -->
        <p>Something went wrong: {error.message}</p>
    {/await}
    ```

    The `catch` block can be omitted if you don't need to render anything when the promise rejects (or no error is possible).

    ``` javascript
    {#await promise}
        <!-- promise is pending -->
        <p>waiting for the promise to resolve...</p>
    {:then value}
        <!-- promise was fulfilled -->
        <p>The value is {value}</p>
    {/await}
    ```

    If you don't care about the pending state, you can also omit the initial block.

    ``` javascript
    {#await promise then value}
        <p>The value is {value}</p>
    {/await}
    ```

    Similarly, if you only want to show the error state, you can omit the `then` block.

    ``` javascript
    {#await promise catch error}
        <p>The error is {error}</p>
    {/await}
    ```
- name: '{#each ...}'
  id: logic-blocks#each
  summary: Iterating over lists of values can be done with an each block
  belongs_to: logic-blocks
  description: |-
    ## {#each ...}

    ``` javascript
    {#each expression as name}...{/each}
    ```

    ``` javascript
    {#each expression as name, index}...{/each}
    ```

    ``` javascript
    {#each expression as name (key)}...{/each}
    ```

    ``` javascript
    {#each expression as name, index (key)}...{/each}
    ```

    ``` javascript
    {#each expression as name}...{:else}...{/each}
    ```

    Iterating over lists of values can be done with an each block.

    ``` javascript
    <h1>Shopping list</h1>
    <ul>
        {#each items as item}
            <li>{item.name} x {item.qty}</li>
        {/each}
    </ul>
    ```

    You can use each blocks to iterate over any array or array-like value — that is, any object with a `length` property.

    An each block can also specify an *index*, equivalent to the second argument in an `array.map(...)` callback:

    ``` javascript
    {#each items as item, i}
        <li>{i + 1}: {item.name} x {item.qty}</li>
    {/each}
    ```

    If a *key* expression is provided — which must uniquely identify each list item — Svelte will use it to diff the list when data changes, rather than adding or removing items at the end. The key can be any object, but strings and numbers are recommended since they allow identity to persist when the objects themselves change.

    ``` javascript
    {#each items as item (item.id)}
        <li>{item.name} x {item.qty}</li>
    {/each}

    <!-- or with additional index value -->
    {#each items as item, i (item.id)}
        <li>{i + 1}: {item.name} x {item.qty}</li>
    {/each}
    ```

    You can freely use destructuring and rest patterns in each blocks.

    ``` javascript
    {#each items as { id, name, qty }, i (id)}
        <li>{i + 1}: {name} x {qty}</li>
    {/each}

    {#each objects as { id, ...rest }}
        <li><span>{id}</span><MyComponent {...rest} /></li>
    {/each}

    {#each items as [id, ...rest]}
        <li><span>{id}</span><MyComponent values={rest} /></li>
    {/each}
    ```

    An each block can also have an `{:else}` clause, which is rendered if the list is empty.

    ``` javascript
    {#each todos as todo}
        <p>{todo.text}</p>
    {:else}
        <p>No tasks today!</p>
    {/each}
    ```

    Since Svelte 4 it is possible to iterate over iterables like `Map` or `Set`. Iterables need to be finite and static (they shouldn't change while being iterated over). Under the hood, they are transformed to an array using `Array.from` before being passed off to rendering. If you're writing performance-sensitive code, try to avoid iterables and use regular arrays as they are more performant.
- name: '{#if ...}'
  id: logic-blocks#if
  summary: Content that is conditionally rendered can be wrapped in an if block
  belongs_to: logic-blocks
  description: |-
    ## {#if ...}

    ``` javascript
    {#if expression}...{/if}
    ```

    ``` javascript
    {#if expression}...{:else if expression}...{/if}
    ```

    ``` javascript
    {#if expression}...{:else}...{/if}
    ```

    Content that is conditionally rendered can be wrapped in an if block.

    ``` javascript
    {#if answer === 42}
        <p>what was the question?</p>
    {/if}
    ```

    Additional conditions can be added with `{:else if expression}`, optionally ending in an `{:else}` clause.

    ``` javascript
    {#if porridge.temperature > 100}
        <p>too hot!</p>
    {:else if 80 > porridge.temperature}
        <p>too cold!</p>
    {:else}
        <p>just right!</p>
    {/if}
    ```

    (Blocks don't have to wrap elements, they can also wrap text within elements!)
- name: '{#key ...}'
  id: logic-blocks#key
  summary: Key blocks destroy and recreate their contents when the value of an expression changes
  belongs_to: logic-blocks
  description: "## {#key ...}\n\n``` javascript\n{#key expression}...{/key}\n```\n\nKey blocks destroy and recreate their contents when the value of an expression changes.\n\nThis is useful if you want an element to play its transition whenever a value changes.\n\n``` javascript\n{#key value}\n    <div transition:fade>{value}</div>\n{/key}\n```\n\nWhen used around components, this will cause them to be reinstantiated and reinitialised.\n\n``` javascript\n{#key value}\n    <Component />\n{/key}\n```\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/logic-blocks](https://svelte.dev/docs/logic-blocks)"
- name: '{@const ...}'
  id: special-tags#const
  summary: The {@const ...} tag defines a local constant
  belongs_to: special-tags
  description: "## {@const ...}\n\n``` javascript\n{@const assignment}\n```\n\nThe `{@const ...}` tag defines a local constant.\n\n``` javascript\n<script>\n    export let boxes;\n</script>\n\n{#each boxes as box}\n    {@const area = box.width * box.height}\n    {box.width} * {box.height} = {area}\n{/each}\n```\n\n`{@const}` is only allowed as direct child of `{#if}`, `{:else if}`, `{:else}`, `{#each}`, `{:then}`, `{:catch}`, `<Component />` or `<svelte:fragment />`.\n\n© 2016–2023 Rich Harris and contributors  \nLicensed under the MIT License.  \n[https://svelte.dev/docs/special-tags](https://svelte.dev/docs/special-tags)"
- name: '{@debug ...}'
  id: special-tags#debug
  summary: The {@debug ...} tag offers an alternative to console.log(...)
  belongs_to: special-tags
  description: |-
    ## {@debug ...}

    ``` javascript
    {@debug}
    ```

    ``` javascript
    {@debug var1, var2, ..., varN}
    ```

    The `{@debug ...}` tag offers an alternative to `console.log(...)`. It logs the values of specific variables whenever they change, and pauses code execution if you have devtools open.

    ``` javascript
    <script>
        let user = {
            firstname: 'Ada',
            lastname: 'Lovelace'
        };
    </script>

    {@debug user}

    <h1>Hello {user.firstname}!</h1>
    ```

    `{@debug ...}` accepts a comma-separated list of variable names (not arbitrary expressions).

    ``` javascript
    <!-- Compiles -->
    {@debug user}
    {@debug user1, user2, user3}

    <!-- WON'T compile -->
    {@debug user.firstname}
    {@debug myArray[0]}
    {@debug !isReady}
    {@debug typeof user === 'object'}
    ```

    The `{@debug}` tag without any arguments will insert a `debugger` statement that gets triggered when *any* state changes, as opposed to the specified variables.
- name: '{@html ...}'
  id: special-tags#html
  summary: In a text expression, characters like < and > are escaped; however, with HTML expressions, they're not
  belongs_to: special-tags
  description: |-
    ## {@html ...}

    ``` javascript
    {@html expression}
    ```

    In a text expression, characters like `<` and `>` are escaped; however, with HTML expressions, they're not.

    The expression should be valid standalone HTML — `{@html "<div>"}content{@html "</div>"}` will *not* work, because `</div>` is not valid HTML. It also will *not* compile Svelte code.

    > Svelte does not sanitize expressions before injecting HTML. If the data comes from an untrusted source, you must sanitize it, or you are exposing your users to an XSS vulnerability.

    ``` javascript
    <div class="blog-post">
        <h1>{post.title}</h1>
        {@html post.content}
    </div>
    ```
